{"version":3,"file":"useDossier-CiPcwRKl.js","sources":["../../src/services/dossier-api.ts","../../src/hooks/useDossier.ts"],"sourcesContent":["/**\n * Dossier API Client\n * Part of: 026-unified-dossier-architecture implementation\n *\n * Typed API client for unified dossier operations using Class Table Inheritance pattern.\n * Handles authentication, error handling, and response parsing for all 7 dossier types:\n * country, organization, forum, engagement, topic, working_group, person\n */\n\nimport { supabase } from '@/lib/supabase';\nimport type { Database } from '../../../backend/src/types/database.types';\n\n// Get Supabase URL for Edge Functions\nconst supabaseUrl = import.meta.env.VITE_SUPABASE_URL;\n\nif (!supabaseUrl) {\n  throw new Error('Missing VITE_SUPABASE_URL environment variable');\n}\n\ntype Dossier = Database['public']['Tables']['dossiers']['Row'];\ntype DossierInsert = Database['public']['Tables']['dossiers']['Insert'];\ntype DossierUpdate = Database['public']['Tables']['dossiers']['Update'];\n\n/**\n * Dossier Types\n */\nexport type DossierType = 'country' | 'organization' | 'forum' | 'engagement' | 'topic' | 'working_group' | 'person';\nexport type DossierStatus = 'active' | 'inactive' | 'archived' | 'deleted';\n\n/**\n * Extension Data Interfaces (type-specific fields)\n */\nexport interface CountryExtension {\n  iso_code_2?: string;\n  iso_code_3?: string;\n  capital_en?: string;\n  capital_ar?: string;\n  region?: string;\n  subregion?: string;\n  population?: number;\n  area_sq_km?: number;\n  flag_url?: string;\n}\n\nexport interface OrganizationExtension {\n  org_code?: string;\n  org_type?: 'government' | 'ngo' | 'private' | 'international' | 'academic';\n  headquarters_country_id?: string;\n  parent_org_id?: string;\n  website?: string;\n  email?: string;\n  phone?: string;\n  address_en?: string;\n  address_ar?: string;\n  logo_url?: string;\n  established_date?: string;\n}\n\nexport interface ForumExtension {\n  number_of_sessions?: number;\n  keynote_speakers?: Array<{ name: string; title: string; org: string }>;\n  sponsors?: Array<unknown>;\n  registration_fee?: number;\n  currency?: string;\n  agenda_url?: string;\n  live_stream_url?: string;\n}\n\nexport interface EngagementExtension {\n  engagement_type?: 'meeting' | 'consultation' | 'coordination' | 'workshop' | 'conference' | 'site_visit' | 'ceremony';\n  engagement_category?: 'bilateral' | 'multilateral' | 'regional' | 'internal';\n  location_en?: string;\n  location_ar?: string;\n}\n\nexport interface TopicExtension {\n  topic_category?: 'policy' | 'technical' | 'strategic' | 'operational';\n  parent_topic_id?: string;\n}\n\nexport interface WorkingGroupExtension {\n  mandate_en?: string;\n  mandate_ar?: string;\n  lead_org_id?: string;\n  wg_status?: 'active' | 'suspended' | 'disbanded';\n  established_date?: string;\n  disbandment_date?: string;\n}\n\nexport interface PersonExtension {\n  title_en?: string;\n  title_ar?: string;\n  organization_id?: string;\n  nationality_country_id?: string;\n  biography_en?: string;\n  biography_ar?: string;\n  photo_url?: string;\n}\n\nexport type DossierExtensionData =\n  | CountryExtension\n  | OrganizationExtension\n  | ForumExtension\n  | EngagementExtension\n  | TopicExtension\n  | WorkingGroupExtension\n  | PersonExtension;\n\n/**\n * API Request types\n */\nexport interface CreateDossierRequest {\n  type: DossierType;\n  name_en: string;\n  name_ar: string;\n  description_en?: string;\n  description_ar?: string;\n  status?: DossierStatus;\n  sensitivity_level?: number;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n  extensionData?: DossierExtensionData;\n}\n\nexport interface UpdateDossierRequest {\n  name_en?: string;\n  name_ar?: string;\n  description_en?: string;\n  description_ar?: string;\n  status?: DossierStatus;\n  sensitivity_level?: number;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n  extensionData?: DossierExtensionData;\n}\n\nexport interface DossierFilters {\n  type?: DossierType;\n  status?: DossierStatus | DossierStatus[]; // Single or multiple statuses\n  sensitivity_level?: number;\n  tags?: string[];\n  search?: string;\n  is_active?: boolean;\n  page?: number;\n  page_size?: number;\n  sort_by?: 'created_at' | 'updated_at' | 'name_en' | 'name_ar';\n  sort_order?: 'asc' | 'desc';\n}\n\nexport interface DossierWithExtension extends Dossier {\n  extension?: DossierExtensionData;\n}\n\nexport interface DossiersListResponse {\n  dossiers: DossierWithExtension[];\n  total_count: number;\n  page: number;\n  page_size: number;\n}\n\n/**\n * API Error class\n */\nexport class DossierAPIError extends Error {\n  code: string;\n  status: number;\n  details?: any;\n\n  constructor(message: string, status: number, code: string, details?: any) {\n    super(message);\n    this.name = 'DossierAPIError';\n    this.code = code;\n    this.status = status;\n    this.details = details;\n  }\n}\n\n/**\n * Helper function to get auth headers\n */\nasync function getAuthHeaders(): Promise<Record<string, string>> {\n  const { data: { session } } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new DossierAPIError('Not authenticated', 401, 'AUTH_REQUIRED');\n  }\n\n  return {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${session.access_token}`,\n  };\n}\n\n/**\n * Helper function to handle API responses\n */\nasync function handleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    let error: any;\n    try {\n      error = await response.json();\n    } catch {\n      error = { message: response.statusText };\n    }\n\n    throw new DossierAPIError(\n      error.message || 'API request failed',\n      response.status,\n      error.code || 'API_ERROR',\n      error.details\n    );\n  }\n\n  return response.json();\n}\n\n/**\n * Create a new dossier\n */\nexport async function createDossier(\n  request: CreateDossierRequest\n): Promise<DossierWithExtension> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${supabaseUrl}/functions/v1/dossiers-create`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(request),\n  });\n\n  return handleResponse<DossierWithExtension>(response);\n}\n\n/**\n * Get a dossier by ID with extension data\n */\nexport async function getDossier(id: string, include?: string[]): Promise<DossierWithExtension> {\n  const headers = await getAuthHeaders();\n  const includeParam = include && include.length > 0 ? `&include=${include.join(',')}` : '';\n  const response = await fetch(`${supabaseUrl}/functions/v1/dossiers-get?id=${id}${includeParam}`, {\n    method: 'GET',\n    headers,\n  });\n\n  return handleResponse<DossierWithExtension>(response);\n}\n\n/**\n * Update a dossier\n */\nexport async function updateDossier(\n  id: string,\n  request: UpdateDossierRequest\n): Promise<DossierWithExtension> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${supabaseUrl}/functions/v1/dossiers-update`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ id, ...request }),\n  });\n\n  return handleResponse<DossierWithExtension>(response);\n}\n\n/**\n * Delete a dossier (archives it)\n */\nexport async function deleteDossier(id: string): Promise<void> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${supabaseUrl}/functions/v1/dossiers-archive`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ id }),\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ message: response.statusText }));\n    throw new DossierAPIError(\n      error.message || 'Failed to delete dossier',\n      response.status,\n      error.code || 'DELETE_FAILED',\n      error.details\n    );\n  }\n}\n\n/**\n * List dossiers with filters\n */\nexport async function listDossiers(\n  filters?: DossierFilters\n): Promise<DossiersListResponse> {\n  const headers = await getAuthHeaders();\n  const params = new URLSearchParams();\n\n  if (filters) {\n    Object.entries(filters).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        if (Array.isArray(value)) {\n          params.append(key, JSON.stringify(value));\n        } else {\n          params.append(key, String(value));\n        }\n      }\n    });\n  }\n\n  const url = `${supabaseUrl}/functions/v1/dossiers-list${params.toString() ? `?${params.toString()}` : ''}`;\n  const response = await fetch(url, {\n    method: 'GET',\n    headers,\n  });\n\n  return handleResponse<DossiersListResponse>(response);\n}\n\n/**\n * Get dossiers by type (convenience method)\n */\nexport async function getDossiersByType(\n  type: DossierType,\n  page?: number,\n  page_size?: number\n): Promise<DossiersListResponse> {\n  return listDossiers({ type, page, page_size });\n}\n\n/**\n * Linked Document Interface\n */\nexport interface LinkedDocument {\n  id: string;\n  title: string;\n  type: 'position' | 'mou' | 'brief';\n  created_at: string;\n  updated_at?: string;\n  clearance_level?: number;\n}\n\n/**\n * Get documents linked to a dossier\n */\nexport async function getDocumentsForDossier(dossierId: string): Promise<LinkedDocument[]> {\n  const headers = await getAuthHeaders();\n  const url = `${supabaseUrl}/functions/v1/dossiers/${dossierId}/documents`;\n\n  const response = await fetch(url, {\n    method: 'GET',\n    headers,\n  });\n\n  return handleResponse<LinkedDocument[]>(response);\n}\n\n/**\n * Link a document to a dossier\n */\nexport async function linkDocumentToDossier(\n  dossierId: string,\n  documentId: string,\n  documentType: 'position' | 'mou' | 'brief'\n): Promise<void> {\n  const headers = await getAuthHeaders();\n  const url = `${supabaseUrl}/functions/v1/dossiers/${dossierId}/documents`;\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ documentId, documentType }),\n  });\n\n  return handleResponse<void>(response);\n}\n\n/**\n * Unlink a document from a dossier\n */\nexport async function unlinkDocumentFromDossier(\n  dossierId: string,\n  documentId: string,\n  documentType: 'position' | 'mou' | 'brief'\n): Promise<void> {\n  const headers = await getAuthHeaders();\n  const url = `${supabaseUrl}/functions/v1/dossiers/${dossierId}/documents/${documentId}`;\n\n  const response = await fetch(url, {\n    method: 'DELETE',\n    headers,\n    body: JSON.stringify({ documentType }),\n  });\n\n  return handleResponse<void>(response);\n}\n\n/**\n * Type Count with Status Breakdown Interface\n */\nexport interface DossierTypeCount {\n  type: DossierType;\n  total: number;\n  active: number;\n  inactive: number;\n  archived: number;\n}\n\n/**\n * Get dossier counts by type with status breakdown\n * More efficient than fetching counts separately for each type and status\n */\nexport async function getDossierCountsByType(): Promise<Record<DossierType, DossierTypeCount>> {\n  const { data, error } = await supabase\n    .from('dossiers')\n    .select('type, status')\n    .not('status', 'eq', 'deleted'); // Exclude deleted dossiers from counts\n\n  if (error) {\n    throw new DossierAPIError(\n      error.message || 'Failed to fetch dossier counts',\n      500,\n      'COUNTS_FETCH_FAILED',\n      error\n    );\n  }\n\n  // Initialize counts object\n  const types: DossierType[] = ['country', 'organization', 'forum', 'engagement', 'topic', 'working_group', 'person'];\n  const counts: Record<DossierType, DossierTypeCount> = {} as any;\n\n  types.forEach((type) => {\n    counts[type] = {\n      type,\n      total: 0,\n      active: 0,\n      inactive: 0,\n      archived: 0,\n    };\n  });\n\n  // Aggregate counts\n  data?.forEach((row) => {\n    const type = row.type as DossierType;\n    const status = row.status as DossierStatus;\n\n    if (counts[type]) {\n      counts[type].total++;\n\n      if (status === 'active') {\n        counts[type].active++;\n      } else if (status === 'inactive') {\n        counts[type].inactive++;\n      } else if (status === 'archived') {\n        counts[type].archived++;\n      }\n    }\n  });\n\n  return counts;\n}\n","/**\n * Dossier Hooks\n * @module hooks/useDossier\n * @feature 026-unified-dossier-architecture\n * @feature 028-type-specific-dossier-pages\n * @feature 034-dossier-ui-polish\n *\n * TanStack Query hooks for dossier CRUD operations with automatic caching,\n * cache invalidation, optimistic updates, and type-safe variants.\n *\n * @description\n * This module provides a comprehensive set of React hooks for managing dossier entities:\n * - Query hooks for fetching single dossiers, lists, and type-specific collections\n * - Mutation hooks for create, update, and delete operations with optimistic updates\n * - Document linking hooks for managing dossier-document relationships\n * - Type-safe variants with runtime validation using type guards\n * - Prefetch and cache invalidation utilities\n *\n * @example\n * // Fetch a single dossier\n * const { data, isLoading } = useDossier('uuid-here');\n *\n * @example\n * // Fetch with type safety\n * const { data } = useTypedDossier('uuid', 'country');\n * // data is typed as CountryDossier\n *\n * @example\n * // Create a new dossier\n * const { mutate } = useCreateDossier();\n * mutate({ type: 'country', name_en: 'France', extension: { iso_code_2: 'FR' } });\n */\n\nimport { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query'\nimport {\n  createDossier,\n  getDossier,\n  updateDossier,\n  deleteDossier,\n  listDossiers,\n  getDossiersByType,\n  getDocumentsForDossier,\n  linkDocumentToDossier,\n  unlinkDocumentFromDossier,\n  getDossierCountsByType,\n  type CreateDossierRequest,\n  type UpdateDossierRequest,\n  type DossierFilters,\n  type DossierWithExtension,\n  type DossiersListResponse,\n  type DossierType,\n  type LinkedDocument,\n  type DossierTypeCount,\n  DossierAPIError,\n} from '@/services/dossier-api'\nimport { toast } from 'sonner'\nimport { useTranslation } from 'react-i18next'\n\n/**\n * Query Keys Factory for dossier-related queries\n *\n * @description\n * Provides a hierarchical key structure for TanStack Query cache management.\n * Keys are structured to enable granular cache invalidation.\n *\n * @example\n * // Invalidate all dossier queries\n * queryClient.invalidateQueries({ queryKey: dossierKeys.all });\n *\n * @example\n * // Invalidate only list queries\n * queryClient.invalidateQueries({ queryKey: dossierKeys.lists() });\n *\n * @example\n * // Invalidate specific dossier detail\n * queryClient.invalidateQueries({ queryKey: dossierKeys.detail('uuid') });\n */\nexport const dossierKeys = {\n  all: ['dossiers'] as const,\n  lists: () => [...dossierKeys.all, 'list'] as const,\n  list: (filters?: DossierFilters) => [...dossierKeys.lists(), { filters }] as const,\n  details: () => [...dossierKeys.all, 'detail'] as const,\n  detail: (id: string) => [...dossierKeys.details(), id] as const,\n  byType: (type: DossierType, page?: number, page_size?: number) =>\n    [...dossierKeys.all, 'type', type, { page, page_size }] as const,\n}\n\n/**\n * Hook to fetch a single dossier by ID\n *\n * @description\n * Fetches a dossier with optional related data includes. The query is automatically\n * cached and can be invalidated using dossierKeys.detail(id).\n *\n * @param id - The unique identifier (UUID) of the dossier to fetch\n * @param include - Optional array of related data to include (e.g., ['extension', 'relationships'])\n * @param options - Additional TanStack Query options (excluding queryKey and queryFn)\n * @returns TanStack Query result with data typed as DossierWithExtension\n *\n * @example\n * // Basic usage\n * const { data, isLoading, error } = useDossier('uuid-123');\n *\n * @example\n * // With includes and options\n * const { data } = useDossier('uuid-123', ['extension', 'relationships'], {\n *   staleTime: 60000,\n *   enabled: !!dossierId,\n * });\n */\nexport function useDossier(\n  id: string,\n  include?: string[],\n  options?: Omit<UseQueryOptions<DossierWithExtension, DossierAPIError>, 'queryKey' | 'queryFn'>,\n) {\n  return useQuery({\n    queryKey: [...dossierKeys.detail(id), { include }],\n    queryFn: () => getDossier(id, include),\n    ...options,\n  })\n}\n\n/**\n * Hook to fetch list of dossiers with filters\n *\n * @description\n * Fetches a paginated list of dossiers with optional filtering by type, status,\n * search query, and other criteria. Results are cached based on filter parameters.\n *\n * @param filters - Optional filters to apply (type, status, search, page, page_size)\n * @param options - Additional TanStack Query options (excluding queryKey and queryFn)\n * @returns TanStack Query result with paginated dossier list\n *\n * @example\n * // Fetch all dossiers\n * const { data } = useDossiers();\n *\n * @example\n * // Fetch with filters\n * const { data } = useDossiers({\n *   type: 'country',\n *   status: 'active',\n *   search: 'France',\n *   page: 1,\n *   page_size: 20,\n * });\n */\nexport function useDossiers(\n  filters?: DossierFilters,\n  options?: Omit<UseQueryOptions<DossiersListResponse, DossierAPIError>, 'queryKey' | 'queryFn'>,\n) {\n  return useQuery({\n    queryKey: dossierKeys.list(filters),\n    queryFn: () => listDossiers(filters),\n    ...options,\n  })\n}\n\n/**\n * Hook to fetch dossiers by type with pagination\n *\n * @description\n * Fetches a paginated list of dossiers filtered by a specific type.\n * Useful for type-specific listing pages (e.g., Countries, Organizations).\n *\n * @param type - The dossier type to filter by ('country', 'organization', 'person', etc.)\n * @param page - Page number for pagination (1-indexed, defaults to 1)\n * @param page_size - Number of items per page (defaults to 20)\n * @param options - Additional TanStack Query options (excluding queryKey and queryFn)\n * @returns TanStack Query result with paginated dossier list\n *\n * @example\n * // Fetch first page of countries\n * const { data } = useDossiersByType('country');\n *\n * @example\n * // Fetch page 2 with 10 items per page\n * const { data } = useDossiersByType('organization', 2, 10);\n */\nexport function useDossiersByType(\n  type: DossierType,\n  page?: number,\n  page_size?: number,\n  options?: Omit<UseQueryOptions<DossiersListResponse, DossierAPIError>, 'queryKey' | 'queryFn'>,\n) {\n  return useQuery({\n    queryKey: dossierKeys.byType(type, page, page_size),\n    queryFn: () => getDossiersByType(type, page, page_size),\n    ...options,\n  })\n}\n\n/**\n * Hook to create a new dossier\n *\n * @description\n * Creates a new dossier entity with automatic cache invalidation and toast notifications.\n * On success, invalidates list queries and pre-populates the detail cache with the new entity.\n *\n * @returns TanStack Mutation result with mutate function accepting CreateDossierRequest\n *\n * @example\n * const { mutate, isPending, isError } = useCreateDossier();\n *\n * // Create a country dossier\n * mutate({\n *   type: 'country',\n *   name_en: 'France',\n *   name_ar: 'فرنسا',\n *   status: 'active',\n *   extension: { iso_code_2: 'FR', iso_code_3: 'FRA' },\n * });\n */\nexport function useCreateDossier() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation()\n\n  return useMutation({\n    mutationFn: (request: CreateDossierRequest) => createDossier(request),\n    onSuccess: (data) => {\n      // Invalidate all dossier lists to refetch with new data\n      queryClient.invalidateQueries({ queryKey: dossierKeys.lists() })\n      queryClient.invalidateQueries({ queryKey: dossierKeys.byType(data.type) })\n\n      // Set the new dossier in the cache\n      queryClient.setQueryData(dossierKeys.detail(data.id), data)\n\n      toast.success(t('dossier.create.success', { name: data.name_en }))\n    },\n    onError: (error: DossierAPIError) => {\n      toast.error(t('dossier.create.error', { message: error.message }))\n    },\n  })\n}\n\n/**\n * Hook to update a dossier with optimistic updates\n *\n * @description\n * Updates an existing dossier with optimistic UI updates for instant feedback.\n * Implements TanStack Query's optimistic update pattern:\n * 1. Immediately updates the cache with new values (onMutate)\n * 2. Rolls back to previous state if the mutation fails (onError)\n * 3. Updates cache with server response on success (onSuccess)\n *\n * @returns TanStack Mutation result with mutate function accepting { id, request }\n *\n * @example\n * const { mutate, isPending } = useUpdateDossier();\n *\n * // Update dossier name and status\n * mutate({\n *   id: 'uuid-123',\n *   request: {\n *     name_en: 'Updated Name',\n *     status: 'inactive',\n *   },\n * });\n */\nexport function useUpdateDossier() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation()\n\n  return useMutation({\n    mutationFn: ({ id, request }: { id: string; request: UpdateDossierRequest }) =>\n      updateDossier(id, request),\n    onMutate: async ({ id, request }) => {\n      // Cancel any outgoing refetches to avoid overwriting optimistic update\n      await queryClient.cancelQueries({ queryKey: dossierKeys.detail(id) })\n\n      // Snapshot the previous value\n      const previousDossier = queryClient.getQueryData<DossierWithExtension>(dossierKeys.detail(id))\n\n      // Optimistically update the cache\n      if (previousDossier) {\n        queryClient.setQueryData<DossierWithExtension>(dossierKeys.detail(id), {\n          ...previousDossier,\n          ...request,\n          updated_at: new Date().toISOString(),\n        })\n      }\n\n      return { previousDossier }\n    },\n    onSuccess: (data, { id }) => {\n      // Update the cache with server response\n      queryClient.setQueryData(dossierKeys.detail(id), data)\n\n      // Invalidate lists to refetch\n      queryClient.invalidateQueries({ queryKey: dossierKeys.lists() })\n      queryClient.invalidateQueries({ queryKey: dossierKeys.byType(data.type) })\n\n      toast.success(t('dossier.update.success', { name: data.name_en }))\n    },\n    onError: (error: DossierAPIError, { id }, context) => {\n      // Rollback optimistic update on error\n      if (context?.previousDossier) {\n        queryClient.setQueryData(dossierKeys.detail(id), context.previousDossier)\n      }\n\n      toast.error(t('dossier.update.error', { message: error.message }))\n    },\n  })\n}\n\n/**\n * Hook to delete a dossier with optimistic removal\n *\n * @description\n * Deletes a dossier with optimistic cache removal for instant UI feedback.\n * Implements soft-delete pattern (marks as deleted) with rollback on failure.\n *\n * @returns TanStack Mutation result with mutate function accepting dossier ID\n *\n * @example\n * const { mutate, isPending } = useDeleteDossier();\n *\n * // Delete with confirmation\n * const handleDelete = (id: string) => {\n *   if (confirm('Are you sure?')) {\n *     mutate(id);\n *   }\n * };\n */\nexport function useDeleteDossier() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation()\n\n  return useMutation({\n    mutationFn: (id: string) => deleteDossier(id),\n    onMutate: async (id) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: dossierKeys.detail(id) })\n\n      // Snapshot the previous value\n      const previousDossier = queryClient.getQueryData<DossierWithExtension>(dossierKeys.detail(id))\n\n      // Optimistically remove from cache\n      queryClient.removeQueries({ queryKey: dossierKeys.detail(id) })\n\n      return { previousDossier }\n    },\n    onSuccess: (_, id) => {\n      // Invalidate all lists to refetch without deleted item\n      queryClient.invalidateQueries({ queryKey: dossierKeys.lists() })\n      queryClient.invalidateQueries({ queryKey: dossierKeys.all })\n\n      toast.success(t('dossier.delete.success'))\n    },\n    onError: (error: DossierAPIError, id, context) => {\n      // Restore the previous value on error\n      if (context?.previousDossier) {\n        queryClient.setQueryData(dossierKeys.detail(id), context.previousDossier)\n      }\n\n      toast.error(t('dossier.delete.error', { message: error.message }))\n    },\n  })\n}\n\n/**\n * Hook to prefetch a dossier for improved UX\n *\n * @description\n * Returns a prefetch function that can be called on hover or focus events\n * to pre-populate the cache before navigation. Improves perceived performance.\n *\n * @returns Prefetch function accepting dossier ID\n *\n * @example\n * const prefetch = usePrefetchDossier();\n *\n * // Prefetch on hover\n * <Link\n *   to={`/dossiers/${id}`}\n *   onMouseEnter={() => prefetch(id)}\n * >\n *   View Dossier\n * </Link>\n */\nexport function usePrefetchDossier() {\n  const queryClient = useQueryClient()\n\n  return (id: string) => {\n    queryClient.prefetchQuery({\n      queryKey: dossierKeys.detail(id),\n      queryFn: () => getDossier(id),\n    })\n  }\n}\n\n/**\n * Hook to invalidate all dossier queries\n *\n * @description\n * Returns a function to invalidate all dossier-related queries in the cache.\n * Useful after bulk operations or external data changes that affect multiple dossiers.\n *\n * @returns Invalidation function (no parameters)\n *\n * @example\n * const invalidate = useInvalidateDossiers();\n *\n * // After bulk import\n * await bulkImportDossiers(data);\n * invalidate(); // Force refetch of all dossier queries\n */\nexport function useInvalidateDossiers() {\n  const queryClient = useQueryClient()\n\n  return () => {\n    queryClient.invalidateQueries({ queryKey: dossierKeys.all })\n  }\n}\n\n/**\n * Query Keys Factory for document-dossier link queries\n *\n * @description\n * Provides cache keys for managing document-dossier relationships.\n * Enables granular invalidation of document link queries per dossier.\n */\nexport const documentLinksKeys = {\n  all: ['documentLinks'] as const,\n  forDossier: (dossierId: string) => [...documentLinksKeys.all, 'dossier', dossierId] as const,\n}\n\n/**\n * Hook to fetch linked documents for a dossier\n *\n * @description\n * Fetches all documents (positions, MOUs, briefs) linked to a specific dossier.\n * Returns an array of LinkedDocument objects with document metadata.\n *\n * @param dossierId - The dossier ID to fetch linked documents for\n * @param options - Additional TanStack Query options\n * @returns TanStack Query result with array of LinkedDocument\n *\n * @example\n * const { data: documents, isLoading } = useDocumentLinks('dossier-uuid');\n *\n * // Render linked documents\n * documents?.map(doc => <DocumentCard key={doc.id} document={doc} />);\n */\nexport function useDocumentLinks(\n  dossierId: string,\n  options?: Omit<UseQueryOptions<LinkedDocument[], DossierAPIError>, 'queryKey' | 'queryFn'>,\n) {\n  return useQuery({\n    queryKey: documentLinksKeys.forDossier(dossierId),\n    queryFn: () => getDocumentsForDossier(dossierId),\n    ...options,\n  })\n}\n\n/**\n * Hook to link a document to a dossier\n *\n * @description\n * Creates a relationship between a document (position, MOU, or brief) and a dossier.\n * Automatically invalidates the document links query for the affected dossier.\n *\n * @returns TanStack Mutation result with mutate function\n *\n * @example\n * const { mutate } = useLinkDocument();\n *\n * // Link a position paper to a dossier\n * mutate({\n *   dossierId: 'dossier-uuid',\n *   documentId: 'position-uuid',\n *   documentType: 'position',\n * });\n */\nexport function useLinkDocument() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation()\n\n  return useMutation({\n    mutationFn: ({\n      dossierId,\n      documentId,\n      documentType,\n    }: {\n      dossierId: string\n      documentId: string\n      documentType: 'position' | 'mou' | 'brief'\n    }) => linkDocumentToDossier(dossierId, documentId, documentType),\n    onSuccess: (_, variables) => {\n      // Invalidate document links for this dossier\n      queryClient.invalidateQueries({\n        queryKey: documentLinksKeys.forDossier(variables.dossierId),\n      })\n      toast.success(t('document.linkSuccess'))\n    },\n    onError: (error: DossierAPIError) => {\n      toast.error(t('document.linkError', { message: error.message }))\n    },\n  })\n}\n\n/**\n * Hook to unlink a document from a dossier\n *\n * @description\n * Removes the relationship between a document and a dossier.\n * Automatically invalidates the document links query for the affected dossier.\n *\n * @returns TanStack Mutation result with mutate function\n *\n * @example\n * const { mutate } = useUnlinkDocument();\n *\n * // Unlink a document\n * mutate({\n *   dossierId: 'dossier-uuid',\n *   documentId: 'position-uuid',\n *   documentType: 'position',\n * });\n */\nexport function useUnlinkDocument() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation()\n\n  return useMutation({\n    mutationFn: ({\n      dossierId,\n      documentId,\n      documentType,\n    }: {\n      dossierId: string\n      documentId: string\n      documentType: 'position' | 'mou' | 'brief'\n    }) => unlinkDocumentFromDossier(dossierId, documentId, documentType),\n    onSuccess: (_, variables) => {\n      // Invalidate document links for this dossier\n      queryClient.invalidateQueries({\n        queryKey: documentLinksKeys.forDossier(variables.dossierId),\n      })\n      toast.success(t('document.unlinkSuccess'))\n    },\n    onError: (error: DossierAPIError) => {\n      toast.error(t('document.unlinkError', { message: error.message }))\n    },\n  })\n}\n\n/**\n * Type-Safe Dossier Hooks\n * @feature 028-type-specific-dossier-pages\n *\n * @description\n * These hooks provide compile-time and runtime type safety for dossier operations.\n * They use discriminated unions and type guards to ensure type correctness when\n * working with specific dossier types (country, organization, person, etc.).\n */\n\nimport type {\n  Dossier,\n  DossierType as TypeGuardDossierType,\n  CountryDossier,\n  OrganizationDossier,\n  PersonDossier,\n  EngagementDossier,\n  ForumDossier,\n  WorkingGroupDossier,\n  getTypeGuard,\n  validateDossierType,\n} from '@/lib/dossier-type-guards'\n\n/**\n * Hook to fetch a dossier with compile-time type safety\n *\n * @description\n * Fetches a dossier and validates it matches the expected type at runtime.\n * Returns a typed result that narrows to the specific dossier type.\n * Throws an error if the fetched dossier doesn't match the expected type.\n *\n * @template T - The expected dossier type ('country', 'organization', etc.)\n * @param id - The dossier UUID to fetch\n * @param expectedType - The expected dossier type for runtime validation\n * @param options - Additional TanStack Query options\n * @returns TanStack Query result with data typed to the specific dossier type\n *\n * @example\n * // Fetch a country dossier with type safety\n * const { data } = useTypedDossier('uuid-123', 'country');\n * // data is typed as CountryDossier\n * // data.extension.iso_code_2 is accessible with autocompletion\n *\n * @example\n * // Fetch an organization dossier\n * const { data } = useTypedDossier('uuid-456', 'organization');\n * // data is typed as OrganizationDossier\n * // data.extension.organization_type is accessible\n *\n * @throws Error if fetched dossier type doesn't match expectedType\n */\nexport function useTypedDossier<T extends TypeGuardDossierType>(\n  id: string,\n  expectedType: T,\n  options?: Omit<\n    UseQueryOptions<Extract<Dossier, { type: T }>, DossierAPIError>,\n    'queryKey' | 'queryFn'\n  >,\n) {\n  const typeGuard = getTypeGuard(expectedType)\n\n  return useQuery({\n    queryKey: [...dossierKeys.detail(id), { expectedType }],\n    queryFn: async () => {\n      const dossier = await getDossier(id)\n\n      // Runtime type validation\n      if (!validateDossierType(dossier as unknown as Dossier, expectedType)) {\n        throw new Error(`Type mismatch: expected ${expectedType}, got ${(dossier as any).type}`)\n      }\n\n      // Type narrowing with type guard\n      if (!typeGuard(dossier as unknown as Dossier)) {\n        throw new Error(`Type guard failed for dossier ${id} with type ${expectedType}`)\n      }\n\n      return dossier as unknown as Extract<Dossier, { type: T }>\n    },\n    ...options,\n  })\n}\n\n/**\n * Query Keys Factory for dossier count queries\n *\n * @description\n * Provides cache keys for dossier count aggregations.\n * Used by the Dossiers Hub to display count badges per type.\n */\nexport const dossierCountsKeys = {\n  all: ['dossierCounts'] as const,\n  byType: (type: TypeGuardDossierType) => [...dossierCountsKeys.all, type] as const,\n}\n\n/**\n * Hook to fetch dossier counts for all types with status breakdown\n *\n * @description\n * Fetches aggregated counts for all dossier types in a single efficient query.\n * Returns a record mapping each type to its count breakdown by status.\n * Used primarily by the Dossiers Hub page to display count badges.\n * Results are cached for 5 minutes to reduce server load.\n *\n * @param options - Additional TanStack Query options\n * @returns TanStack Query result with Record<DossierType, DossierTypeCount>\n *\n * @example\n * const { data: counts, isLoading } = useDossierCounts();\n *\n * // Access counts per type\n * counts?.country.total;     // Total countries\n * counts?.country.active;    // Active countries\n * counts?.organization.total; // Total organizations\n */\nexport function useDossierCounts(\n  options?: Omit<\n    UseQueryOptions<Record<TypeGuardDossierType, DossierTypeCount>, DossierAPIError>,\n    'queryKey' | 'queryFn'\n  >,\n) {\n  return useQuery({\n    queryKey: dossierCountsKeys.all,\n    queryFn: async () => {\n      try {\n        const counts = await getDossierCountsByType()\n        return counts as Record<TypeGuardDossierType, DossierTypeCount>\n      } catch (error) {\n        console.warn('Failed to fetch dossier counts:', error)\n        // Return empty counts on error\n        const types: TypeGuardDossierType[] = [\n          'country',\n          'organization',\n          'person',\n          'engagement',\n          'forum',\n          'working_group',\n        ]\n        const emptyCounts: Record<TypeGuardDossierType, DossierTypeCount> = {} as any\n        types.forEach((type) => {\n          emptyCounts[type] = {\n            type: type as DossierType,\n            total: 0,\n            active: 0,\n            inactive: 0,\n            archived: 0,\n          }\n        })\n        return emptyCounts\n      }\n    },\n    staleTime: 5 * 60 * 1000, // Cache for 5 minutes\n    ...options,\n  })\n}\n\n/**\n * Hook to fetch count for a specific dossier type\n *\n * @description\n * Fetches the total count for a single dossier type.\n * Uses an efficient minimal query (page_size=1) to get total count.\n * Results are cached for 5 minutes.\n *\n * @param type - The dossier type to get count for\n * @param options - Additional TanStack Query options\n * @returns TanStack Query result with count number\n *\n * @example\n * const { data: countryCount } = useDossierCountByType('country');\n * console.log(`Total countries: ${countryCount}`);\n */\nexport function useDossierCountByType(\n  type: TypeGuardDossierType,\n  options?: Omit<UseQueryOptions<number, DossierAPIError>, 'queryKey' | 'queryFn'>,\n) {\n  return useQuery({\n    queryKey: dossierCountsKeys.byType(type),\n    queryFn: async () => {\n      try {\n        const response = await getDossiersByType(type, 1, 1)\n        return response.total || 0\n      } catch (error) {\n        console.warn(`Failed to fetch count for ${type}:`, error)\n        return 0\n      }\n    },\n    staleTime: 5 * 60 * 1000, // Cache for 5 minutes\n    ...options,\n  })\n}\n"],"names":["supabaseUrl","DossierAPIError","message","status","code","details","getAuthHeaders","session","supabase","handleResponse","response","error","createDossier","request","headers","getDossier","id","include","includeParam","listDossiers","filters","params","key","value","url","getDossiersByType","type","page","page_size","getDossierCountsByType","data","types","counts","row","dossierKeys","useDossier","options","useQuery","useDossiers","useDossiersByType","useCreateDossier","queryClient","useQueryClient","t","useTranslation","useMutation","toast","useTypedDossier","expectedType","typeGuard","dossier","dossierCountsKeys","useDossierCounts","emptyCounts"],"mappings":"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"}