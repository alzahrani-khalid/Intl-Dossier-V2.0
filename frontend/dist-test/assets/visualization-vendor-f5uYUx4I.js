import { r as v, a as id, k as xy, b as by, P as wy, j as z } from './react-vendor-Buoak6m3.js'
import {
  a5 as le,
  a6 as wn,
  a7 as Qc,
  a8 as Py,
  a9 as R,
  aa as so,
  ab as Ve,
  ac as Te,
  ad as Ht,
  ae as Ne,
  af as Sy,
  ag as Jc,
  ah as se,
  ai as tr,
  aj as od,
  ak as Ey,
  al as _y,
  am as Ay,
  an as Oy,
  ao as jn,
  ap as Er,
  aq as Cy,
  ar as ky,
  as as My,
  at as ye,
  au as Ty,
  av as de,
  aw as Ny,
} from './vendor-misc-BiJvMP0A.js'
var Dy = [
  'dangerouslySetInnerHTML',
  'onCopy',
  'onCopyCapture',
  'onCut',
  'onCutCapture',
  'onPaste',
  'onPasteCapture',
  'onCompositionEnd',
  'onCompositionEndCapture',
  'onCompositionStart',
  'onCompositionStartCapture',
  'onCompositionUpdate',
  'onCompositionUpdateCapture',
  'onFocus',
  'onFocusCapture',
  'onBlur',
  'onBlurCapture',
  'onChange',
  'onChangeCapture',
  'onBeforeInput',
  'onBeforeInputCapture',
  'onInput',
  'onInputCapture',
  'onReset',
  'onResetCapture',
  'onSubmit',
  'onSubmitCapture',
  'onInvalid',
  'onInvalidCapture',
  'onLoad',
  'onLoadCapture',
  'onError',
  'onErrorCapture',
  'onKeyDown',
  'onKeyDownCapture',
  'onKeyPress',
  'onKeyPressCapture',
  'onKeyUp',
  'onKeyUpCapture',
  'onAbort',
  'onAbortCapture',
  'onCanPlay',
  'onCanPlayCapture',
  'onCanPlayThrough',
  'onCanPlayThroughCapture',
  'onDurationChange',
  'onDurationChangeCapture',
  'onEmptied',
  'onEmptiedCapture',
  'onEncrypted',
  'onEncryptedCapture',
  'onEnded',
  'onEndedCapture',
  'onLoadedData',
  'onLoadedDataCapture',
  'onLoadedMetadata',
  'onLoadedMetadataCapture',
  'onLoadStart',
  'onLoadStartCapture',
  'onPause',
  'onPauseCapture',
  'onPlay',
  'onPlayCapture',
  'onPlaying',
  'onPlayingCapture',
  'onProgress',
  'onProgressCapture',
  'onRateChange',
  'onRateChangeCapture',
  'onSeeked',
  'onSeekedCapture',
  'onSeeking',
  'onSeekingCapture',
  'onStalled',
  'onStalledCapture',
  'onSuspend',
  'onSuspendCapture',
  'onTimeUpdate',
  'onTimeUpdateCapture',
  'onVolumeChange',
  'onVolumeChangeCapture',
  'onWaiting',
  'onWaitingCapture',
  'onAuxClick',
  'onAuxClickCapture',
  'onClick',
  'onClickCapture',
  'onContextMenu',
  'onContextMenuCapture',
  'onDoubleClick',
  'onDoubleClickCapture',
  'onDrag',
  'onDragCapture',
  'onDragEnd',
  'onDragEndCapture',
  'onDragEnter',
  'onDragEnterCapture',
  'onDragExit',
  'onDragExitCapture',
  'onDragLeave',
  'onDragLeaveCapture',
  'onDragOver',
  'onDragOverCapture',
  'onDragStart',
  'onDragStartCapture',
  'onDrop',
  'onDropCapture',
  'onMouseDown',
  'onMouseDownCapture',
  'onMouseEnter',
  'onMouseLeave',
  'onMouseMove',
  'onMouseMoveCapture',
  'onMouseOut',
  'onMouseOutCapture',
  'onMouseOver',
  'onMouseOverCapture',
  'onMouseUp',
  'onMouseUpCapture',
  'onSelect',
  'onSelectCapture',
  'onTouchCancel',
  'onTouchCancelCapture',
  'onTouchEnd',
  'onTouchEndCapture',
  'onTouchMove',
  'onTouchMoveCapture',
  'onTouchStart',
  'onTouchStartCapture',
  'onPointerDown',
  'onPointerDownCapture',
  'onPointerMove',
  'onPointerMoveCapture',
  'onPointerUp',
  'onPointerUpCapture',
  'onPointerCancel',
  'onPointerCancelCapture',
  'onPointerEnter',
  'onPointerEnterCapture',
  'onPointerLeave',
  'onPointerLeaveCapture',
  'onPointerOver',
  'onPointerOverCapture',
  'onPointerOut',
  'onPointerOutCapture',
  'onGotPointerCapture',
  'onGotPointerCaptureCapture',
  'onLostPointerCapture',
  'onLostPointerCaptureCapture',
  'onScroll',
  'onScrollCapture',
  'onWheel',
  'onWheelCapture',
  'onAnimationStart',
  'onAnimationStartCapture',
  'onAnimationEnd',
  'onAnimationEndCapture',
  'onAnimationIteration',
  'onAnimationIterationCapture',
  'onTransitionEnd',
  'onTransitionEndCapture',
]
function ds(e) {
  if (typeof e != 'string') return !1
  var t = Dy
  return t.includes(e)
}
var Iy = [
  'aria-activedescendant',
  'aria-atomic',
  'aria-autocomplete',
  'aria-busy',
  'aria-checked',
  'aria-colcount',
  'aria-colindex',
  'aria-colspan',
  'aria-controls',
  'aria-current',
  'aria-describedby',
  'aria-details',
  'aria-disabled',
  'aria-errormessage',
  'aria-expanded',
  'aria-flowto',
  'aria-haspopup',
  'aria-hidden',
  'aria-invalid',
  'aria-keyshortcuts',
  'aria-label',
  'aria-labelledby',
  'aria-level',
  'aria-live',
  'aria-modal',
  'aria-multiline',
  'aria-multiselectable',
  'aria-orientation',
  'aria-owns',
  'aria-placeholder',
  'aria-posinset',
  'aria-pressed',
  'aria-readonly',
  'aria-relevant',
  'aria-required',
  'aria-roledescription',
  'aria-rowcount',
  'aria-rowindex',
  'aria-rowspan',
  'aria-selected',
  'aria-setsize',
  'aria-sort',
  'aria-valuemax',
  'aria-valuemin',
  'aria-valuenow',
  'aria-valuetext',
  'className',
  'color',
  'height',
  'id',
  'lang',
  'max',
  'media',
  'method',
  'min',
  'name',
  'style',
  'target',
  'width',
  'role',
  'tabIndex',
  'accentHeight',
  'accumulate',
  'additive',
  'alignmentBaseline',
  'allowReorder',
  'alphabetic',
  'amplitude',
  'arabicForm',
  'ascent',
  'attributeName',
  'attributeType',
  'autoReverse',
  'azimuth',
  'baseFrequency',
  'baselineShift',
  'baseProfile',
  'bbox',
  'begin',
  'bias',
  'by',
  'calcMode',
  'capHeight',
  'clip',
  'clipPath',
  'clipPathUnits',
  'clipRule',
  'colorInterpolation',
  'colorInterpolationFilters',
  'colorProfile',
  'colorRendering',
  'contentScriptType',
  'contentStyleType',
  'cursor',
  'cx',
  'cy',
  'd',
  'decelerate',
  'descent',
  'diffuseConstant',
  'direction',
  'display',
  'divisor',
  'dominantBaseline',
  'dur',
  'dx',
  'dy',
  'edgeMode',
  'elevation',
  'enableBackground',
  'end',
  'exponent',
  'externalResourcesRequired',
  'fill',
  'fillOpacity',
  'fillRule',
  'filter',
  'filterRes',
  'filterUnits',
  'floodColor',
  'floodOpacity',
  'focusable',
  'fontFamily',
  'fontSize',
  'fontSizeAdjust',
  'fontStretch',
  'fontStyle',
  'fontVariant',
  'fontWeight',
  'format',
  'from',
  'fx',
  'fy',
  'g1',
  'g2',
  'glyphName',
  'glyphOrientationHorizontal',
  'glyphOrientationVertical',
  'glyphRef',
  'gradientTransform',
  'gradientUnits',
  'hanging',
  'horizAdvX',
  'horizOriginX',
  'href',
  'ideographic',
  'imageRendering',
  'in2',
  'in',
  'intercept',
  'k1',
  'k2',
  'k3',
  'k4',
  'k',
  'kernelMatrix',
  'kernelUnitLength',
  'kerning',
  'keyPoints',
  'keySplines',
  'keyTimes',
  'lengthAdjust',
  'letterSpacing',
  'lightingColor',
  'limitingConeAngle',
  'local',
  'markerEnd',
  'markerHeight',
  'markerMid',
  'markerStart',
  'markerUnits',
  'markerWidth',
  'mask',
  'maskContentUnits',
  'maskUnits',
  'mathematical',
  'mode',
  'numOctaves',
  'offset',
  'opacity',
  'operator',
  'order',
  'orient',
  'orientation',
  'origin',
  'overflow',
  'overlinePosition',
  'overlineThickness',
  'paintOrder',
  'panose1',
  'pathLength',
  'patternContentUnits',
  'patternTransform',
  'patternUnits',
  'pointerEvents',
  'pointsAtX',
  'pointsAtY',
  'pointsAtZ',
  'preserveAlpha',
  'preserveAspectRatio',
  'primitiveUnits',
  'r',
  'radius',
  'refX',
  'refY',
  'renderingIntent',
  'repeatCount',
  'repeatDur',
  'requiredExtensions',
  'requiredFeatures',
  'restart',
  'result',
  'rotate',
  'rx',
  'ry',
  'seed',
  'shapeRendering',
  'slope',
  'spacing',
  'specularConstant',
  'specularExponent',
  'speed',
  'spreadMethod',
  'startOffset',
  'stdDeviation',
  'stemh',
  'stemv',
  'stitchTiles',
  'stopColor',
  'stopOpacity',
  'strikethroughPosition',
  'strikethroughThickness',
  'string',
  'stroke',
  'strokeDasharray',
  'strokeDashoffset',
  'strokeLinecap',
  'strokeLinejoin',
  'strokeMiterlimit',
  'strokeOpacity',
  'strokeWidth',
  'surfaceScale',
  'systemLanguage',
  'tableValues',
  'targetX',
  'targetY',
  'textAnchor',
  'textDecoration',
  'textLength',
  'textRendering',
  'to',
  'transform',
  'u1',
  'u2',
  'underlinePosition',
  'underlineThickness',
  'unicode',
  'unicodeBidi',
  'unicodeRange',
  'unitsPerEm',
  'vAlphabetic',
  'values',
  'vectorEffect',
  'version',
  'vertAdvY',
  'vertOriginX',
  'vertOriginY',
  'vHanging',
  'vIdeographic',
  'viewTarget',
  'visibility',
  'vMathematical',
  'widths',
  'wordSpacing',
  'writingMode',
  'x1',
  'x2',
  'x',
  'xChannelSelector',
  'xHeight',
  'xlinkActuate',
  'xlinkArcrole',
  'xlinkHref',
  'xlinkRole',
  'xlinkShow',
  'xlinkTitle',
  'xlinkType',
  'xmlBase',
  'xmlLang',
  'xmlns',
  'xmlnsXlink',
  'xmlSpace',
  'y1',
  'y2',
  'y',
  'yChannelSelector',
  'z',
  'zoomAndPan',
  'ref',
  'key',
  'angle',
]
function ad(e) {
  if (typeof e != 'string') return !1
  var t = Iy
  return t.includes(e)
}
function sd(e) {
  return typeof e == 'string' && e.startsWith('data-')
}
function ft(e) {
  var t = Object.entries(e).filter((n) => {
    var [r] = n
    return ad(r) || sd(r)
  })
  return Object.fromEntries(t)
}
function hs(e) {
  if (e == null) return null
  if (v.isValidElement(e) && typeof e.props == 'object' && e.props !== null) {
    var t = e.props
    return ft(t)
  }
  return typeof e == 'object' && !Array.isArray(e) ? ft(e) : null
}
function et(e) {
  var t = Object.entries(e).filter((n) => {
    var [r] = n
    return ad(r) || sd(r) || ds(r)
  })
  return Object.fromEntries(t)
}
var jy = ['children', 'width', 'height', 'viewBox', 'className', 'style', 'title', 'desc']
function xa() {
  return (
    (xa = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    xa.apply(null, arguments)
  )
}
function $y(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = Ly(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function Ly(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var ps = v.forwardRef((e, t) => {
    var {
        children: n,
        width: r,
        height: i,
        viewBox: o,
        className: a,
        style: s,
        title: l,
        desc: c,
      } = e,
      u = $y(e, jy),
      f = o || { width: r, height: i, x: 0, y: 0 },
      d = le('recharts-surface', a)
    return v.createElement(
      'svg',
      xa({}, et(u), {
        className: d,
        width: r,
        height: i,
        style: s,
        viewBox: ''.concat(f.x, ' ').concat(f.y, ' ').concat(f.width, ' ').concat(f.height),
        ref: t,
      }),
      v.createElement('title', null, l),
      v.createElement('desc', null, c),
      n,
    )
  }),
  zy = ['children', 'className']
function ba() {
  return (
    (ba = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    ba.apply(null, arguments)
  )
}
function Ry(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = By(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function By(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var St = v.forwardRef((e, t) => {
    var { children: n, className: r } = e,
      i = Ry(e, zy),
      o = le('recharts-layer', r)
    return v.createElement('g', ba({ className: o }, et(i), { ref: t }), n)
  }),
  cd = v.createContext(null),
  Hy = () => v.useContext(cd)
function ce(e) {
  return function () {
    return e
  }
}
const ld = Math.cos,
  wi = Math.sin,
  ct = Math.sqrt,
  Pi = Math.PI,
  co = 2 * Pi,
  wa = Math.PI,
  Pa = 2 * wa,
  Xt = 1e-6,
  Fy = Pa - Xt
function ud(e) {
  this._ += e[0]
  for (let t = 1, n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
}
function Vy(e) {
  let t = Math.floor(e)
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`)
  if (t > 15) return ud
  const n = 10 ** t
  return function (r) {
    this._ += r[0]
    for (let i = 1, o = r.length; i < o; ++i) this._ += Math.round(arguments[i] * n) / n + r[i]
  }
}
class Wy {
  constructor(t) {
    ;((this._x0 = this._y0 = this._x1 = this._y1 = null),
      (this._ = ''),
      (this._append = t == null ? ud : Vy(t)))
  }
  moveTo(t, n) {
    this._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +n)}`
  }
  closePath() {
    this._x1 !== null && ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`)
  }
  lineTo(t, n) {
    this._append`L${(this._x1 = +t)},${(this._y1 = +n)}`
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${(this._x1 = +r)},${(this._y1 = +i)}`
  }
  bezierCurveTo(t, n, r, i, o, a) {
    this._append`C${+t},${+n},${+r},${+i},${(this._x1 = +o)},${(this._y1 = +a)}`
  }
  arcTo(t, n, r, i, o) {
    if (((t = +t), (n = +n), (r = +r), (i = +i), (o = +o), o < 0))
      throw new Error(`negative radius: ${o}`)
    let a = this._x1,
      s = this._y1,
      l = r - t,
      c = i - n,
      u = a - t,
      f = s - n,
      d = u * u + f * f
    if (this._x1 === null) this._append`M${(this._x1 = t)},${(this._y1 = n)}`
    else if (d > Xt)
      if (!(Math.abs(f * l - c * u) > Xt) || !o) this._append`L${(this._x1 = t)},${(this._y1 = n)}`
      else {
        let h = r - a,
          g = i - s,
          p = l * l + c * c,
          x = h * h + g * g,
          y = Math.sqrt(p),
          w = Math.sqrt(d),
          m = o * Math.tan((wa - Math.acos((p + d - x) / (2 * y * w))) / 2),
          b = m / w,
          P = m / y
        ;(Math.abs(b - 1) > Xt && this._append`L${t + b * u},${n + b * f}`,
          this
            ._append`A${o},${o},0,0,${+(f * h > u * g)},${(this._x1 = t + P * l)},${(this._y1 = n + P * c)}`)
      }
  }
  arc(t, n, r, i, o, a) {
    if (((t = +t), (n = +n), (r = +r), (a = !!a), r < 0)) throw new Error(`negative radius: ${r}`)
    let s = r * Math.cos(i),
      l = r * Math.sin(i),
      c = t + s,
      u = n + l,
      f = 1 ^ a,
      d = a ? i - o : o - i
    ;(this._x1 === null
      ? this._append`M${c},${u}`
      : (Math.abs(this._x1 - c) > Xt || Math.abs(this._y1 - u) > Xt) && this._append`L${c},${u}`,
      r &&
        (d < 0 && (d = (d % Pa) + Pa),
        d > Fy
          ? this
              ._append`A${r},${r},0,1,${f},${t - s},${n - l}A${r},${r},0,1,${f},${(this._x1 = c)},${(this._y1 = u)}`
          : d > Xt &&
            this
              ._append`A${r},${r},0,${+(d >= wa)},${f},${(this._x1 = t + r * Math.cos(o))},${(this._y1 = n + r * Math.sin(o))}`))
  }
  rect(t, n, r, i) {
    this
      ._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +n)}h${(r = +r)}v${+i}h${-r}Z`
  }
  toString() {
    return this._
  }
}
function vs(e) {
  let t = 3
  return (
    (e.digits = function (n) {
      if (!arguments.length) return t
      if (n == null) t = null
      else {
        const r = Math.floor(n)
        if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`)
        t = r
      }
      return e
    }),
    () => new Wy(t)
  )
}
function gs(e) {
  return typeof e == 'object' && 'length' in e ? e : Array.from(e)
}
function fd(e) {
  this._context = e
}
fd.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    this._point = 0
  },
  lineEnd: function () {
    ;((this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      (this._line = 1 - this._line))
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;((this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t))
        break
      case 1:
        this._point = 2
      default:
        this._context.lineTo(e, t)
        break
    }
  },
}
function lo(e) {
  return new fd(e)
}
function dd(e) {
  return e[0]
}
function hd(e) {
  return e[1]
}
function pd(e, t) {
  var n = ce(!0),
    r = null,
    i = lo,
    o = null,
    a = vs(s)
  ;((e = typeof e == 'function' ? e : e === void 0 ? dd : ce(e)),
    (t = typeof t == 'function' ? t : t === void 0 ? hd : ce(t)))
  function s(l) {
    var c,
      u = (l = gs(l)).length,
      f,
      d = !1,
      h
    for (r == null && (o = i((h = a()))), c = 0; c <= u; ++c)
      (!(c < u && n((f = l[c]), c, l)) === d && ((d = !d) ? o.lineStart() : o.lineEnd()),
        d && o.point(+e(f, c, l), +t(f, c, l)))
    if (h) return ((o = null), h + '' || null)
  }
  return (
    (s.x = function (l) {
      return arguments.length ? ((e = typeof l == 'function' ? l : ce(+l)), s) : e
    }),
    (s.y = function (l) {
      return arguments.length ? ((t = typeof l == 'function' ? l : ce(+l)), s) : t
    }),
    (s.defined = function (l) {
      return arguments.length ? ((n = typeof l == 'function' ? l : ce(!!l)), s) : n
    }),
    (s.curve = function (l) {
      return arguments.length ? ((i = l), r != null && (o = i(r)), s) : i
    }),
    (s.context = function (l) {
      return arguments.length ? (l == null ? (r = o = null) : (o = i((r = l))), s) : r
    }),
    s
  )
}
function Ur(e, t, n) {
  var r = null,
    i = ce(!0),
    o = null,
    a = lo,
    s = null,
    l = vs(c)
  ;((e = typeof e == 'function' ? e : e === void 0 ? dd : ce(+e)),
    (t = typeof t == 'function' ? t : ce(t === void 0 ? 0 : +t)),
    (n = typeof n == 'function' ? n : n === void 0 ? hd : ce(+n)))
  function c(f) {
    var d,
      h,
      g,
      p = (f = gs(f)).length,
      x,
      y = !1,
      w,
      m = new Array(p),
      b = new Array(p)
    for (o == null && (s = a((w = l()))), d = 0; d <= p; ++d) {
      if (!(d < p && i((x = f[d]), d, f)) === y)
        if ((y = !y)) ((h = d), s.areaStart(), s.lineStart())
        else {
          for (s.lineEnd(), s.lineStart(), g = d - 1; g >= h; --g) s.point(m[g], b[g])
          ;(s.lineEnd(), s.areaEnd())
        }
      y &&
        ((m[d] = +e(x, d, f)),
        (b[d] = +t(x, d, f)),
        s.point(r ? +r(x, d, f) : m[d], n ? +n(x, d, f) : b[d]))
    }
    if (w) return ((s = null), w + '' || null)
  }
  function u() {
    return pd().defined(i).curve(a).context(o)
  }
  return (
    (c.x = function (f) {
      return arguments.length ? ((e = typeof f == 'function' ? f : ce(+f)), (r = null), c) : e
    }),
    (c.x0 = function (f) {
      return arguments.length ? ((e = typeof f == 'function' ? f : ce(+f)), c) : e
    }),
    (c.x1 = function (f) {
      return arguments.length
        ? ((r = f == null ? null : typeof f == 'function' ? f : ce(+f)), c)
        : r
    }),
    (c.y = function (f) {
      return arguments.length ? ((t = typeof f == 'function' ? f : ce(+f)), (n = null), c) : t
    }),
    (c.y0 = function (f) {
      return arguments.length ? ((t = typeof f == 'function' ? f : ce(+f)), c) : t
    }),
    (c.y1 = function (f) {
      return arguments.length
        ? ((n = f == null ? null : typeof f == 'function' ? f : ce(+f)), c)
        : n
    }),
    (c.lineX0 = c.lineY0 =
      function () {
        return u().x(e).y(t)
      }),
    (c.lineY1 = function () {
      return u().x(e).y(n)
    }),
    (c.lineX1 = function () {
      return u().x(r).y(t)
    }),
    (c.defined = function (f) {
      return arguments.length ? ((i = typeof f == 'function' ? f : ce(!!f)), c) : i
    }),
    (c.curve = function (f) {
      return arguments.length ? ((a = f), o != null && (s = a(o)), c) : a
    }),
    (c.context = function (f) {
      return arguments.length ? (f == null ? (o = s = null) : (s = a((o = f))), c) : o
    }),
    c
  )
}
class vd {
  constructor(t, n) {
    ;((this._context = t), (this._x = n))
  }
  areaStart() {
    this._line = 0
  }
  areaEnd() {
    this._line = NaN
  }
  lineStart() {
    this._point = 0
  }
  lineEnd() {
    ;((this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      (this._line = 1 - this._line))
  }
  point(t, n) {
    switch (((t = +t), (n = +n), this._point)) {
      case 0: {
        ;((this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n))
        break
      }
      case 1:
        this._point = 2
      default: {
        this._x
          ? this._context.bezierCurveTo(
              (this._x0 = (this._x0 + t) / 2),
              this._y0,
              this._x0,
              n,
              t,
              n,
            )
          : this._context.bezierCurveTo(
              this._x0,
              (this._y0 = (this._y0 + n) / 2),
              t,
              this._y0,
              t,
              n,
            )
        break
      }
    }
    ;((this._x0 = t), (this._y0 = n))
  }
}
function Ky(e) {
  return new vd(e, !0)
}
function Yy(e) {
  return new vd(e, !1)
}
const ms = {
    draw(e, t) {
      const n = ct(t / Pi)
      ;(e.moveTo(n, 0), e.arc(0, 0, n, 0, co))
    },
  },
  Uy = {
    draw(e, t) {
      const n = ct(t / 5) / 2
      ;(e.moveTo(-3 * n, -n),
        e.lineTo(-n, -n),
        e.lineTo(-n, -3 * n),
        e.lineTo(n, -3 * n),
        e.lineTo(n, -n),
        e.lineTo(3 * n, -n),
        e.lineTo(3 * n, n),
        e.lineTo(n, n),
        e.lineTo(n, 3 * n),
        e.lineTo(-n, 3 * n),
        e.lineTo(-n, n),
        e.lineTo(-3 * n, n),
        e.closePath())
    },
  },
  gd = ct(1 / 3),
  Xy = gd * 2,
  Gy = {
    draw(e, t) {
      const n = ct(t / Xy),
        r = n * gd
      ;(e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath())
    },
  },
  qy = {
    draw(e, t) {
      const n = ct(t),
        r = -n / 2
      e.rect(r, r, n, n)
    },
  },
  Zy = 0.8908130915292852,
  md = wi(Pi / 10) / wi((7 * Pi) / 10),
  Qy = wi(co / 10) * md,
  Jy = -ld(co / 10) * md,
  e0 = {
    draw(e, t) {
      const n = ct(t * Zy),
        r = Qy * n,
        i = Jy * n
      ;(e.moveTo(0, -n), e.lineTo(r, i))
      for (let o = 1; o < 5; ++o) {
        const a = (co * o) / 5,
          s = ld(a),
          l = wi(a)
        ;(e.lineTo(l * n, -s * n), e.lineTo(s * r - l * i, l * r + s * i))
      }
      e.closePath()
    },
  },
  qo = ct(3),
  t0 = {
    draw(e, t) {
      const n = -ct(t / (qo * 3))
      ;(e.moveTo(0, n * 2), e.lineTo(-qo * n, -n), e.lineTo(qo * n, -n), e.closePath())
    },
  },
  Ue = -0.5,
  Xe = ct(3) / 2,
  Sa = 1 / ct(12),
  n0 = (Sa / 2 + 1) * 3,
  r0 = {
    draw(e, t) {
      const n = ct(t / n0),
        r = n / 2,
        i = n * Sa,
        o = r,
        a = n * Sa + n,
        s = -o,
        l = a
      ;(e.moveTo(r, i),
        e.lineTo(o, a),
        e.lineTo(s, l),
        e.lineTo(Ue * r - Xe * i, Xe * r + Ue * i),
        e.lineTo(Ue * o - Xe * a, Xe * o + Ue * a),
        e.lineTo(Ue * s - Xe * l, Xe * s + Ue * l),
        e.lineTo(Ue * r + Xe * i, Ue * i - Xe * r),
        e.lineTo(Ue * o + Xe * a, Ue * a - Xe * o),
        e.lineTo(Ue * s + Xe * l, Ue * l - Xe * s),
        e.closePath())
    },
  }
function i0(e, t) {
  let n = null,
    r = vs(i)
  ;((e = typeof e == 'function' ? e : ce(e || ms)),
    (t = typeof t == 'function' ? t : ce(t === void 0 ? 64 : +t)))
  function i() {
    let o
    if ((n || (n = o = r()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o))
      return ((n = null), o + '' || null)
  }
  return (
    (i.type = function (o) {
      return arguments.length ? ((e = typeof o == 'function' ? o : ce(o)), i) : e
    }),
    (i.size = function (o) {
      return arguments.length ? ((t = typeof o == 'function' ? o : ce(+o)), i) : t
    }),
    (i.context = function (o) {
      return arguments.length ? ((n = o ?? null), i) : n
    }),
    i
  )
}
function Si() {}
function Ei(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6,
  )
}
function yd(e) {
  this._context = e
}
yd.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;((this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0))
  },
  lineEnd: function () {
    switch (this._point) {
      case 3:
        Ei(this, this._x1, this._y1)
      case 2:
        this._context.lineTo(this._x1, this._y1)
        break
    }
    ;((this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      (this._line = 1 - this._line))
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;((this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t))
        break
      case 1:
        this._point = 2
        break
      case 2:
        ;((this._point = 3),
          this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6))
      default:
        Ei(this, e, t)
        break
    }
    ;((this._x0 = this._x1), (this._x1 = e), (this._y0 = this._y1), (this._y1 = t))
  },
}
function o0(e) {
  return new yd(e)
}
function xd(e) {
  this._context = e
}
xd.prototype = {
  areaStart: Si,
  areaEnd: Si,
  lineStart: function () {
    ;((this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
        NaN),
      (this._point = 0))
  },
  lineEnd: function () {
    switch (this._point) {
      case 1: {
        ;(this._context.moveTo(this._x2, this._y2), this._context.closePath())
        break
      }
      case 2: {
        ;(this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3),
          this._context.closePath())
        break
      }
      case 3: {
        ;(this.point(this._x2, this._y2),
          this.point(this._x3, this._y3),
          this.point(this._x4, this._y4))
        break
      }
    }
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;((this._point = 1), (this._x2 = e), (this._y2 = t))
        break
      case 1:
        ;((this._point = 2), (this._x3 = e), (this._y3 = t))
        break
      case 2:
        ;((this._point = 3),
          (this._x4 = e),
          (this._y4 = t),
          this._context.moveTo(
            (this._x0 + 4 * this._x1 + e) / 6,
            (this._y0 + 4 * this._y1 + t) / 6,
          ))
        break
      default:
        Ei(this, e, t)
        break
    }
    ;((this._x0 = this._x1), (this._x1 = e), (this._y0 = this._y1), (this._y1 = t))
  },
}
function a0(e) {
  return new xd(e)
}
function bd(e) {
  this._context = e
}
bd.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;((this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0))
  },
  lineEnd: function () {
    ;((this._line || (this._line !== 0 && this._point === 3)) && this._context.closePath(),
      (this._line = 1 - this._line))
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        this._point = 1
        break
      case 1:
        this._point = 2
        break
      case 2:
        this._point = 3
        var n = (this._x0 + 4 * this._x1 + e) / 6,
          r = (this._y0 + 4 * this._y1 + t) / 6
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r)
        break
      case 3:
        this._point = 4
      default:
        Ei(this, e, t)
        break
    }
    ;((this._x0 = this._x1), (this._x1 = e), (this._y0 = this._y1), (this._y1 = t))
  },
}
function s0(e) {
  return new bd(e)
}
function wd(e) {
  this._context = e
}
wd.prototype = {
  areaStart: Si,
  areaEnd: Si,
  lineStart: function () {
    this._point = 0
  },
  lineEnd: function () {
    this._point && this._context.closePath()
  },
  point: function (e, t) {
    ;((e = +e),
      (t = +t),
      this._point ? this._context.lineTo(e, t) : ((this._point = 1), this._context.moveTo(e, t)))
  },
}
function c0(e) {
  return new wd(e)
}
function el(e) {
  return e < 0 ? -1 : 1
}
function tl(e, t, n) {
  var r = e._x1 - e._x0,
    i = t - e._x1,
    o = (e._y1 - e._y0) / (r || (i < 0 && -0)),
    a = (n - e._y1) / (i || (r < 0 && -0)),
    s = (o * i + a * r) / (r + i)
  return (el(o) + el(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(s)) || 0
}
function nl(e, t) {
  var n = e._x1 - e._x0
  return n ? ((3 * (e._y1 - e._y0)) / n - t) / 2 : t
}
function Zo(e, t, n) {
  var r = e._x0,
    i = e._y0,
    o = e._x1,
    a = e._y1,
    s = (o - r) / 3
  e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a)
}
function _i(e) {
  this._context = e
}
_i.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;((this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN), (this._point = 0))
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1)
        break
      case 3:
        Zo(this, this._t0, nl(this, this._t0))
        break
    }
    ;((this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      (this._line = 1 - this._line))
  },
  point: function (e, t) {
    var n = NaN
    if (((e = +e), (t = +t), !(e === this._x1 && t === this._y1))) {
      switch (this._point) {
        case 0:
          ;((this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t))
          break
        case 1:
          this._point = 2
          break
        case 2:
          ;((this._point = 3), Zo(this, nl(this, (n = tl(this, e, t))), n))
          break
        default:
          Zo(this, this._t0, (n = tl(this, e, t)))
          break
      }
      ;((this._x0 = this._x1),
        (this._x1 = e),
        (this._y0 = this._y1),
        (this._y1 = t),
        (this._t0 = n))
    }
  },
}
function Pd(e) {
  this._context = new Sd(e)
}
;(Pd.prototype = Object.create(_i.prototype)).point = function (e, t) {
  _i.prototype.point.call(this, t, e)
}
function Sd(e) {
  this._context = e
}
Sd.prototype = {
  moveTo: function (e, t) {
    this._context.moveTo(t, e)
  },
  closePath: function () {
    this._context.closePath()
  },
  lineTo: function (e, t) {
    this._context.lineTo(t, e)
  },
  bezierCurveTo: function (e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i)
  },
}
function l0(e) {
  return new _i(e)
}
function u0(e) {
  return new Pd(e)
}
function Ed(e) {
  this._context = e
}
Ed.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;((this._x = []), (this._y = []))
  },
  lineEnd: function () {
    var e = this._x,
      t = this._y,
      n = e.length
    if (n)
      if (
        (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
      )
        this._context.lineTo(e[1], t[1])
      else
        for (var r = rl(e), i = rl(t), o = 0, a = 1; a < n; ++o, ++a)
          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[a], t[a])
    ;((this._line || (this._line !== 0 && n === 1)) && this._context.closePath(),
      (this._line = 1 - this._line),
      (this._x = this._y = null))
  },
  point: function (e, t) {
    ;(this._x.push(+e), this._y.push(+t))
  },
}
function rl(e) {
  var t,
    n = e.length - 1,
    r,
    i = new Array(n),
    o = new Array(n),
    a = new Array(n)
  for (i[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    ((i[t] = 1), (o[t] = 4), (a[t] = 4 * e[t] + 2 * e[t + 1]))
  for (i[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    ((r = i[t] / o[t - 1]), (o[t] -= r), (a[t] -= r * a[t - 1]))
  for (i[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t) i[t] = (a[t] - i[t + 1]) / o[t]
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t) o[t] = 2 * e[t + 1] - i[t + 1]
  return [i, o]
}
function f0(e) {
  return new Ed(e)
}
function uo(e, t) {
  ;((this._context = e), (this._t = t))
}
uo.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;((this._x = this._y = NaN), (this._point = 0))
  },
  lineEnd: function () {
    ;(0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y),
      (this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line)))
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;((this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t))
        break
      case 1:
        this._point = 2
      default: {
        if (this._t <= 0) (this._context.lineTo(this._x, t), this._context.lineTo(e, t))
        else {
          var n = this._x * (1 - this._t) + e * this._t
          ;(this._context.lineTo(n, this._y), this._context.lineTo(n, t))
        }
        break
      }
    }
    ;((this._x = e), (this._y = t))
  },
}
function d0(e) {
  return new uo(e, 0.5)
}
function h0(e) {
  return new uo(e, 0)
}
function p0(e) {
  return new uo(e, 1)
}
function Pn(e, t) {
  if ((a = e.length) > 1)
    for (var n = 1, r, i, o = e[t[0]], a, s = o.length; n < a; ++n)
      for (i = o, o = e[t[n]], r = 0; r < s; ++r)
        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1]
}
function Ea(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; ) n[t] = t
  return n
}
function v0(e, t) {
  return e[t]
}
function g0(e) {
  const t = []
  return ((t.key = e), t)
}
function m0() {
  var e = ce([]),
    t = Ea,
    n = Pn,
    r = v0
  function i(o) {
    var a = Array.from(e.apply(this, arguments), g0),
      s,
      l = a.length,
      c = -1,
      u
    for (const f of o) for (s = 0, ++c; s < l; ++s) (a[s][c] = [0, +r(f, a[s].key, c, o)]).data = f
    for (s = 0, u = gs(t(a)); s < l; ++s) a[u[s]].index = s
    return (n(a, u), a)
  }
  return (
    (i.keys = function (o) {
      return arguments.length ? ((e = typeof o == 'function' ? o : ce(Array.from(o))), i) : e
    }),
    (i.value = function (o) {
      return arguments.length ? ((r = typeof o == 'function' ? o : ce(+o)), i) : r
    }),
    (i.order = function (o) {
      return arguments.length
        ? ((t = o == null ? Ea : typeof o == 'function' ? o : ce(Array.from(o))), i)
        : t
    }),
    (i.offset = function (o) {
      return arguments.length ? ((n = o ?? Pn), i) : n
    }),
    i
  )
}
function y0(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, i = 0, o = e[0].length, a; i < o; ++i) {
      for (a = n = 0; n < r; ++n) a += e[n][i][1] || 0
      if (a) for (n = 0; n < r; ++n) e[n][i][1] /= a
    }
    Pn(e, t)
  }
}
function x0(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
      for (var a = 0, s = 0; a < i; ++a) s += e[a][n][1] || 0
      r[n][1] += r[n][0] = -s / 2
    }
    Pn(e, t)
  }
}
function b0(e, t) {
  if (!(!((a = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, i, o, a; r < o; ++r) {
      for (var s = 0, l = 0, c = 0; s < a; ++s) {
        for (
          var u = e[t[s]], f = u[r][1] || 0, d = u[r - 1][1] || 0, h = (f - d) / 2, g = 0;
          g < s;
          ++g
        ) {
          var p = e[t[g]],
            x = p[r][1] || 0,
            y = p[r - 1][1] || 0
          h += x - y
        }
        ;((l += f), (c += h * f))
      }
      ;((i[r - 1][1] += i[r - 1][0] = n), l && (n -= c / l))
    }
    ;((i[r - 1][1] += i[r - 1][0] = n), Pn(e, t))
  }
}
var Qe = (e) => (e === 0 ? 0 : e > 0 ? 1 : -1),
  st = (e) => typeof e == 'number' && e != +e,
  sr = (e) => typeof e == 'string' && e.indexOf('%') === e.length - 1,
  te = (e) => (typeof e == 'number' || e instanceof Number) && !st(e),
  dt = (e) => te(e) || typeof e == 'string',
  w0 = 0,
  cr = (e) => {
    var t = ++w0
    return ''.concat(e || '').concat(t)
  },
  Wt = function (t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
      i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1
    if (!te(t) && typeof t != 'string') return r
    var o
    if (sr(t)) {
      if (n == null) return r
      var a = t.indexOf('%')
      o = (n * parseFloat(t.slice(0, a))) / 100
    } else o = +t
    return (st(o) && (o = r), i && n != null && o > n && (o = n), o)
  },
  _d = (e) => {
    if (!Array.isArray(e)) return !1
    for (var t = e.length, n = {}, r = 0; r < t; r++)
      if (!n[e[r]]) n[e[r]] = !0
      else return !0
    return !1
  },
  Xr = (e, t) => (te(e) && te(t) ? (n) => e + n * (t - e) : () => t)
function gt(e, t, n) {
  return te(e) && te(t) ? e + n * (t - e) : t
}
function Ad(e, t, n) {
  if (!(!e || !e.length))
    return e.find((r) => r && (typeof t == 'function' ? t(r) : wn(r, t)) === n)
}
var P0 = (e) => {
    if (!e || !e.length) return null
    for (
      var t = e.length, n = 0, r = 0, i = 0, o = 0, a = 1 / 0, s = -1 / 0, l = 0, c = 0, u = 0;
      u < t;
      u++
    )
      ((l = e[u].cx || 0),
        (c = e[u].cy || 0),
        (n += l),
        (r += c),
        (i += l * c),
        (o += l * l),
        (a = Math.min(a, l)),
        (s = Math.max(s, l)))
    var f = t * o !== n * n ? (t * i - n * r) / (t * o - n * n) : 0
    return { xmin: a, xmax: s, a: f, b: (r - f * n) / t }
  },
  ge = (e) => e === null || typeof e > 'u',
  _r = (e) => (ge(e) ? e : ''.concat(e.charAt(0).toUpperCase()).concat(e.slice(1))),
  S0 = ['type', 'size', 'sizeType']
function _a() {
  return (
    (_a = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    _a.apply(null, arguments)
  )
}
function il(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function ol(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? il(Object(n), !0).forEach(function (r) {
          E0(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : il(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function E0(e, t, n) {
  return (
    (t = _0(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function _0(e) {
  var t = A0(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function A0(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function O0(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = C0(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function C0(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var Od = {
    symbolCircle: ms,
    symbolCross: Uy,
    symbolDiamond: Gy,
    symbolSquare: qy,
    symbolStar: e0,
    symbolTriangle: t0,
    symbolWye: r0,
  },
  k0 = Math.PI / 180,
  M0 = (e) => {
    var t = 'symbol'.concat(_r(e))
    return Od[t] || ms
  },
  T0 = (e, t, n) => {
    if (t === 'area') return e
    switch (n) {
      case 'cross':
        return (5 * e * e) / 9
      case 'diamond':
        return (0.5 * e * e) / Math.sqrt(3)
      case 'square':
        return e * e
      case 'star': {
        var r = 18 * k0
        return 1.25 * e * e * (Math.tan(r) - Math.tan(r * 2) * Math.tan(r) ** 2)
      }
      case 'triangle':
        return (Math.sqrt(3) * e * e) / 4
      case 'wye':
        return ((21 - 10 * Math.sqrt(3)) * e * e) / 8
      default:
        return (Math.PI * e * e) / 4
    }
  },
  N0 = (e, t) => {
    Od['symbol'.concat(_r(e))] = t
  },
  fo = (e) => {
    var { type: t = 'circle', size: n = 64, sizeType: r = 'area' } = e,
      i = O0(e, S0),
      o = ol(ol({}, i), {}, { type: t, size: n, sizeType: r }),
      a = 'circle'
    typeof t == 'string' && (a = t)
    var s = () => {
        var d = M0(a),
          h = i0()
            .type(d)
            .size(T0(n, r, a)),
          g = h()
        if (g !== null) return g
      },
      { className: l, cx: c, cy: u } = o,
      f = et(o)
    return c === +c && u === +u && n === +n
      ? v.createElement(
          'path',
          _a({}, f, {
            className: le('recharts-symbols', l),
            transform: 'translate('.concat(c, ', ').concat(u, ')'),
            d: s(),
          }),
        )
      : null
  }
fo.registerSymbol = N0
var D0 = (e, t) => {
    if (!e || typeof e == 'function' || typeof e == 'boolean') return null
    var n = e
    if ((v.isValidElement(e) && (n = e.props), typeof n != 'object' && typeof n != 'function'))
      return null
    var r = {}
    return (
      Object.keys(n).forEach((i) => {
        ds(i) && (r[i] = (o) => n[i](n, o))
      }),
      r
    )
  },
  I0 = (e, t, n) => (r) => (e(t, n, r), null),
  ys = (e, t, n) => {
    if (e === null || (typeof e != 'object' && typeof e != 'function')) return null
    var r = null
    return (
      Object.keys(e).forEach((i) => {
        var o = e[i]
        ds(i) && typeof o == 'function' && (r || (r = {}), (r[i] = I0(o, t, n)))
      }),
      r
    )
  }
function Aa() {
  return (
    (Aa = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Aa.apply(null, arguments)
  )
}
function al(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function j0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? al(Object(n), !0).forEach(function (r) {
          xs(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : al(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function xs(e, t, n) {
  return (
    (t = $0(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function $0(e) {
  var t = L0(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function L0(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var Ge = 32
class bs extends v.PureComponent {
  renderIcon(t, n) {
    var { inactiveColor: r } = this.props,
      i = Ge / 2,
      o = Ge / 6,
      a = Ge / 3,
      s = t.inactive ? r : t.color,
      l = n ?? t.type
    if (l === 'none') return null
    if (l === 'plainline')
      return v.createElement('line', {
        strokeWidth: 4,
        fill: 'none',
        stroke: s,
        strokeDasharray: t.payload.strokeDasharray,
        x1: 0,
        y1: i,
        x2: Ge,
        y2: i,
        className: 'recharts-legend-icon',
      })
    if (l === 'line')
      return v.createElement('path', {
        strokeWidth: 4,
        fill: 'none',
        stroke: s,
        d: 'M0,'
          .concat(i, 'h')
          .concat(
            a,
            `
            A`,
          )
          .concat(o, ',')
          .concat(o, ',0,1,1,')
          .concat(2 * a, ',')
          .concat(
            i,
            `
            H`,
          )
          .concat(Ge, 'M')
          .concat(2 * a, ',')
          .concat(
            i,
            `
            A`,
          )
          .concat(o, ',')
          .concat(o, ',0,1,1,')
          .concat(a, ',')
          .concat(i),
        className: 'recharts-legend-icon',
      })
    if (l === 'rect')
      return v.createElement('path', {
        stroke: 'none',
        fill: s,
        d: 'M0,'
          .concat(Ge / 8, 'h')
          .concat(Ge, 'v')
          .concat((Ge * 3) / 4, 'h')
          .concat(-Ge, 'z'),
        className: 'recharts-legend-icon',
      })
    if (v.isValidElement(t.legendIcon)) {
      var c = j0({}, t)
      return (delete c.legendIcon, v.cloneElement(t.legendIcon, c))
    }
    return v.createElement(fo, { fill: s, cx: i, cy: i, size: Ge, sizeType: 'diameter', type: l })
  }
  renderItems() {
    var {
        payload: t,
        iconSize: n,
        layout: r,
        formatter: i,
        inactiveColor: o,
        iconType: a,
      } = this.props,
      s = { x: 0, y: 0, width: Ge, height: Ge },
      l = { display: r === 'horizontal' ? 'inline-block' : 'block', marginRight: 10 },
      c = { display: 'inline-block', verticalAlign: 'middle', marginRight: 4 }
    return t.map((u, f) => {
      var d = u.formatter || i,
        h = le({ 'recharts-legend-item': !0, ['legend-item-'.concat(f)]: !0, inactive: u.inactive })
      if (u.type === 'none') return null
      var g = u.inactive ? o : u.color,
        p = d ? d(u.value, u, f) : u.value
      return v.createElement(
        'li',
        Aa({ className: h, style: l, key: 'legend-item-'.concat(f) }, ys(this.props, u, f)),
        v.createElement(
          ps,
          { width: n, height: n, viewBox: s, style: c, 'aria-label': ''.concat(p, ' legend icon') },
          this.renderIcon(u, a),
        ),
        v.createElement('span', { className: 'recharts-legend-item-text', style: { color: g } }, p),
      )
    })
  }
  render() {
    var { payload: t, layout: n, align: r } = this.props
    if (!t || !t.length) return null
    var i = { padding: 0, margin: 0, textAlign: n === 'horizontal' ? r : 'left' }
    return v.createElement(
      'ul',
      { className: 'recharts-default-legend', style: i },
      this.renderItems(),
    )
  }
}
xs(bs, 'displayName', 'Legend')
xs(bs, 'defaultProps', {
  align: 'center',
  iconSize: 14,
  inactiveColor: '#ccc',
  layout: 'horizontal',
  verticalAlign: 'middle',
})
function Cd(e, t, n) {
  return t === !0 ? Qc(e, n) : typeof t == 'function' ? Qc(e, t) : e
}
var ws = v.createContext(null),
  z0 = (e) => e,
  pe = () => {
    var e = v.useContext(ws)
    return e ? e.store.dispatch : z0
  },
  di = () => {},
  R0 = () => di,
  B0 = (e, t) => e === t
function J(e) {
  var t = v.useContext(ws)
  return Py.useSyncExternalStoreWithSelector(
    t ? t.subscription.addNestedSub : R0,
    t ? t.store.getState : di,
    t ? t.store.getState : di,
    t ? e : di,
    B0,
  )
}
var kd = (e) => e.legend.settings,
  H0 = (e) => e.legend.size,
  F0 = (e) => e.legend.payload,
  V0 = R([F0, kd], (e, t) => {
    var { itemSorter: n } = t,
      r = e.flat(1)
    return n ? so(r, n) : r
  })
function W0() {
  return J(V0)
}
var Gr = 1
function Md() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
    [t, n] = v.useState({ height: 0, left: 0, top: 0, width: 0 }),
    r = v.useCallback(
      (i) => {
        if (i != null) {
          var o = i.getBoundingClientRect(),
            a = { height: o.height, left: o.left, top: o.top, width: o.width }
          ;(Math.abs(a.height - t.height) > Gr ||
            Math.abs(a.left - t.left) > Gr ||
            Math.abs(a.top - t.top) > Gr ||
            Math.abs(a.width - t.width) > Gr) &&
            n({ height: a.height, left: a.left, top: a.top, width: a.width })
        }
      },
      [t.width, t.height, t.top, t.left, ...e],
    )
  return [t, r]
}
var K0 = {
    layoutType: 'horizontal',
    width: 0,
    height: 0,
    margin: { top: 5, right: 5, bottom: 5, left: 5 },
    scale: 1,
  },
  Td = Ve({
    name: 'chartLayout',
    initialState: K0,
    reducers: {
      setLayout(e, t) {
        e.layoutType = t.payload
      },
      setChartSize(e, t) {
        ;((e.width = t.payload.width), (e.height = t.payload.height))
      },
      setMargin(e, t) {
        var n, r, i, o
        ;((e.margin.top = (n = t.payload.top) !== null && n !== void 0 ? n : 0),
          (e.margin.right = (r = t.payload.right) !== null && r !== void 0 ? r : 0),
          (e.margin.bottom = (i = t.payload.bottom) !== null && i !== void 0 ? i : 0),
          (e.margin.left = (o = t.payload.left) !== null && o !== void 0 ? o : 0))
      },
      setScale(e, t) {
        e.scale = t.payload
      },
    },
  }),
  { setMargin: Y0, setLayout: U0, setChartSize: X0, setScale: G0 } = Td.actions,
  q0 = Td.reducer
function sl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function cl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? sl(Object(n), !0).forEach(function (r) {
          Z0(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : sl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Z0(e, t, n) {
  return (
    (t = Q0(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function Q0(e) {
  var t = J0(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function J0(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var Ai = Math.PI / 180,
  ex = (e) => (e * 180) / Math.PI,
  _e = (e, t, n, r) => ({ x: e + Math.cos(-Ai * r) * n, y: t + Math.sin(-Ai * r) * n }),
  tx = function (t, n) {
    var r =
      arguments.length > 2 && arguments[2] !== void 0
        ? arguments[2]
        : { top: 0, right: 0, bottom: 0, left: 0 }
    return (
      Math.min(
        Math.abs(t - (r.left || 0) - (r.right || 0)),
        Math.abs(n - (r.top || 0) - (r.bottom || 0)),
      ) / 2
    )
  },
  nx = (e, t) => {
    var { x: n, y: r } = e,
      { x: i, y: o } = t
    return Math.sqrt((n - i) ** 2 + (r - o) ** 2)
  },
  rx = (e, t) => {
    var { x: n, y: r } = e,
      { cx: i, cy: o } = t,
      a = nx({ x: n, y: r }, { x: i, y: o })
    if (a <= 0) return { radius: a, angle: 0 }
    var s = (n - i) / a,
      l = Math.acos(s)
    return (r > o && (l = 2 * Math.PI - l), { radius: a, angle: ex(l), angleInRadian: l })
  },
  ix = (e) => {
    var { startAngle: t, endAngle: n } = e,
      r = Math.floor(t / 360),
      i = Math.floor(n / 360),
      o = Math.min(r, i)
    return { startAngle: t - o * 360, endAngle: n - o * 360 }
  },
  ox = (e, t) => {
    var { startAngle: n, endAngle: r } = t,
      i = Math.floor(n / 360),
      o = Math.floor(r / 360),
      a = Math.min(i, o)
    return e + a * 360
  },
  ax = (e, t) => {
    var { x: n, y: r } = e,
      { radius: i, angle: o } = rx({ x: n, y: r }, t),
      { innerRadius: a, outerRadius: s } = t
    if (i < a || i > s || i === 0) return null
    var { startAngle: l, endAngle: c } = ix(t),
      u = o,
      f
    if (l <= c) {
      for (; u > c; ) u -= 360
      for (; u < l; ) u += 360
      f = u >= l && u <= c
    } else {
      for (; u > l; ) u -= 360
      for (; u < c; ) u += 360
      f = u >= c && u <= l
    }
    return f ? cl(cl({}, t), {}, { radius: i, angle: ox(u, t) }) : null
  }
function Nd(e, t, n) {
  return Array.isArray(e) && e && t + n !== 0 ? e.slice(t, n + 1) : e
}
function ll(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Ze(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? ll(Object(n), !0).forEach(function (r) {
          sx(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ll(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function sx(e, t, n) {
  return (
    (t = cx(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function cx(e) {
  var t = lx(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function lx(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function Ae(e, t, n) {
  return ge(e) || ge(t) ? n : dt(t) ? wn(e, t, n) : typeof t == 'function' ? t(e) : n
}
var ux = (e, t, n, r, i) => {
    var o,
      a = -1,
      s = (o = t?.length) !== null && o !== void 0 ? o : 0
    if (s <= 1 || e == null) return 0
    if (r === 'angleAxis' && i != null && Math.abs(Math.abs(i[1] - i[0]) - 360) <= 1e-6)
      for (var l = 0; l < s; l++) {
        var c = l > 0 ? n[l - 1].coordinate : n[s - 1].coordinate,
          u = n[l].coordinate,
          f = l >= s - 1 ? n[0].coordinate : n[l + 1].coordinate,
          d = void 0
        if (Qe(u - c) !== Qe(f - u)) {
          var h = []
          if (Qe(f - u) === Qe(i[1] - i[0])) {
            d = f
            var g = u + i[1] - i[0]
            ;((h[0] = Math.min(g, (g + c) / 2)), (h[1] = Math.max(g, (g + c) / 2)))
          } else {
            d = c
            var p = f + i[1] - i[0]
            ;((h[0] = Math.min(u, (p + u) / 2)), (h[1] = Math.max(u, (p + u) / 2)))
          }
          var x = [Math.min(u, (d + u) / 2), Math.max(u, (d + u) / 2)]
          if ((e > x[0] && e <= x[1]) || (e >= h[0] && e <= h[1])) {
            ;({ index: a } = n[l])
            break
          }
        } else {
          var y = Math.min(c, f),
            w = Math.max(c, f)
          if (e > (y + u) / 2 && e <= (w + u) / 2) {
            ;({ index: a } = n[l])
            break
          }
        }
      }
    else if (t) {
      for (var m = 0; m < s; m++)
        if (
          (m === 0 && e <= (t[m].coordinate + t[m + 1].coordinate) / 2) ||
          (m > 0 &&
            m < s - 1 &&
            e > (t[m].coordinate + t[m - 1].coordinate) / 2 &&
            e <= (t[m].coordinate + t[m + 1].coordinate) / 2) ||
          (m === s - 1 && e > (t[m].coordinate + t[m - 1].coordinate) / 2)
        ) {
          ;({ index: a } = t[m])
          break
        }
    }
    return a
  },
  fx = (e, t, n) => {
    if (t && n) {
      var { width: r, height: i } = n,
        { align: o, verticalAlign: a, layout: s } = t
      if (
        (s === 'vertical' || (s === 'horizontal' && a === 'middle')) &&
        o !== 'center' &&
        te(e[o])
      )
        return Ze(Ze({}, e), {}, { [o]: e[o] + (r || 0) })
      if (
        (s === 'horizontal' || (s === 'vertical' && o === 'center')) &&
        a !== 'middle' &&
        te(e[a])
      )
        return Ze(Ze({}, e), {}, { [a]: e[a] + (i || 0) })
    }
    return e
  },
  ln = (e, t) =>
    (e === 'horizontal' && t === 'xAxis') ||
    (e === 'vertical' && t === 'yAxis') ||
    (e === 'centric' && t === 'angleAxis') ||
    (e === 'radial' && t === 'radiusAxis'),
  Dd = (e, t, n, r) => {
    if (r) return e.map((s) => s.coordinate)
    var i,
      o,
      a = e.map(
        (s) => (s.coordinate === t && (i = !0), s.coordinate === n && (o = !0), s.coordinate),
      )
    return (i || a.push(t), o || a.push(n), a)
  },
  Id = (e, t, n) => {
    if (!e) return null
    var {
      duplicateDomain: r,
      type: i,
      range: o,
      scale: a,
      realScaleType: s,
      isCategorical: l,
      categoricalDomain: c,
      tickCount: u,
      ticks: f,
      niceTicks: d,
      axisType: h,
    } = e
    if (!a) return null
    var g = s === 'scaleBand' && a.bandwidth ? a.bandwidth() / 2 : 2,
      p = i === 'category' && a.bandwidth ? a.bandwidth() / g : 0
    if (((p = h === 'angleAxis' && o && o.length >= 2 ? Qe(o[0] - o[1]) * 2 * p : p), f || d)) {
      var x = (f || d || []).map((y, w) => {
        var m = r ? r.indexOf(y) : y
        return { coordinate: a(m) + p, value: y, offset: p, index: w }
      })
      return x.filter((y) => !st(y.coordinate))
    }
    return l && c
      ? c.map((y, w) => ({ coordinate: a(y) + p, value: y, index: w, offset: p }))
      : a.ticks && u != null
        ? a.ticks(u).map((y, w) => ({ coordinate: a(y) + p, value: y, offset: p, index: w }))
        : a
            .domain()
            .map((y, w) => ({ coordinate: a(y) + p, value: r ? r[y] : y, index: w, offset: p }))
  },
  ul = 1e-4,
  dx = (e) => {
    var t = e.domain()
    if (!(!t || t.length <= 2)) {
      var n = t.length,
        r = e.range(),
        i = Math.min(r[0], r[1]) - ul,
        o = Math.max(r[0], r[1]) + ul,
        a = e(t[0]),
        s = e(t[n - 1])
      ;(a < i || a > o || s < i || s > o) && e.domain([t[0], t[n - 1]])
    }
  },
  hx = (e) => {
    var t = e.length
    if (!(t <= 0))
      for (var n = 0, r = e[0].length; n < r; ++n)
        for (var i = 0, o = 0, a = 0; a < t; ++a) {
          var s = st(e[a][n][1]) ? e[a][n][0] : e[a][n][1]
          s >= 0
            ? ((e[a][n][0] = i), (e[a][n][1] = i + s), (i = e[a][n][1]))
            : ((e[a][n][0] = o), (e[a][n][1] = o + s), (o = e[a][n][1]))
        }
  },
  px = (e) => {
    var t = e.length
    if (!(t <= 0))
      for (var n = 0, r = e[0].length; n < r; ++n)
        for (var i = 0, o = 0; o < t; ++o) {
          var a = st(e[o][n][1]) ? e[o][n][0] : e[o][n][1]
          a >= 0
            ? ((e[o][n][0] = i), (e[o][n][1] = i + a), (i = e[o][n][1]))
            : ((e[o][n][0] = 0), (e[o][n][1] = 0))
        }
  },
  vx = { sign: hx, expand: y0, none: Pn, silhouette: x0, wiggle: b0, positive: px },
  gx = (e, t, n) => {
    var r = vx[n],
      i = m0()
        .keys(t)
        .value((o, a) => +Ae(o, a, 0))
        .order(Ea)
        .offset(r)
    return i(e)
  }
function fl(e) {
  var { axis: t, ticks: n, bandSize: r, entry: i, index: o, dataKey: a } = e
  if (t.type === 'category') {
    if (!t.allowDuplicatedCategory && t.dataKey && !ge(i[t.dataKey])) {
      var s = Ad(n, 'value', i[t.dataKey])
      if (s) return s.coordinate + r / 2
    }
    return n[o] ? n[o].coordinate + r / 2 : null
  }
  var l = Ae(i, ge(a) ? t.dataKey : a)
  return ge(l) ? null : t.scale(l)
}
var mx = (e) => {
    var t = e.flat(2).filter(te)
    return [Math.min(...t), Math.max(...t)]
  },
  yx = (e) => [e[0] === 1 / 0 ? 0 : e[0], e[1] === -1 / 0 ? 0 : e[1]],
  xx = (e, t, n) => {
    if (e != null)
      return yx(
        Object.keys(e).reduce(
          (r, i) => {
            var o = e[i],
              { stackedData: a } = o,
              s = a.reduce(
                (l, c) => {
                  var u = Nd(c, t, n),
                    f = mx(u)
                  return [Math.min(l[0], f[0]), Math.max(l[1], f[1])]
                },
                [1 / 0, -1 / 0],
              )
            return [Math.min(s[0], r[0]), Math.max(s[1], r[1])]
          },
          [1 / 0, -1 / 0],
        ),
      )
  },
  dl = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
  hl = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
  bx = (e, t, n) => {
    if (e && e.scale && e.scale.bandwidth) {
      var r = e.scale.bandwidth()
      return r
    }
    if (e && t && t.length >= 2) {
      for (var i = so(t, (u) => u.coordinate), o = 1 / 0, a = 1, s = i.length; a < s; a++) {
        var l = i[a],
          c = i[a - 1]
        o = Math.min((l.coordinate || 0) - (c.coordinate || 0), o)
      }
      return o === 1 / 0 ? 0 : o
    }
    return 0
  }
function pl(e) {
  var { tooltipEntrySettings: t, dataKey: n, payload: r, value: i, name: o } = e
  return Ze(Ze({}, t), {}, { dataKey: n, payload: r, value: i, name: o })
}
function jd(e, t) {
  if (e) return String(e)
  if (typeof t == 'string') return t
}
function wx(e, t, n, r, i) {
  if (n === 'horizontal' || n === 'vertical') {
    var o = e >= i.left && e <= i.left + i.width && t >= i.top && t <= i.top + i.height
    return o ? { x: e, y: t } : null
  }
  return r ? ax({ x: e, y: t }, r) : null
}
var Px = (e, t, n, r) => {
    var i = t.find((c) => c && c.index === n)
    if (i) {
      if (e === 'horizontal') return { x: i.coordinate, y: r.y }
      if (e === 'vertical') return { x: r.x, y: i.coordinate }
      if (e === 'centric') {
        var o = i.coordinate,
          { radius: a } = r
        return Ze(Ze(Ze({}, r), _e(r.cx, r.cy, a, o)), {}, { angle: o, radius: a })
      }
      var s = i.coordinate,
        { angle: l } = r
      return Ze(Ze(Ze({}, r), _e(r.cx, r.cy, s, l)), {}, { angle: l, radius: s })
    }
    return { x: 0, y: 0 }
  },
  Sx = (e, t) =>
    t === 'horizontal' ? e.x : t === 'vertical' ? e.y : t === 'centric' ? e.angle : e.radius,
  Ct = (e) => e.layout.width,
  kt = (e) => e.layout.height,
  Ex = (e) => e.layout.scale,
  $d = (e) => e.layout.margin,
  ho = R(
    (e) => e.cartesianAxis.xAxis,
    (e) => Object.values(e),
  ),
  po = R(
    (e) => e.cartesianAxis.yAxis,
    (e) => Object.values(e),
  ),
  Ld = 'data-recharts-item-index',
  zd = 'data-recharts-item-data-key',
  Ar = 60
function vl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function qr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? vl(Object(n), !0).forEach(function (r) {
          _x(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : vl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function _x(e, t, n) {
  return (
    (t = Ax(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function Ax(e) {
  var t = Ox(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function Ox(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var Cx = (e) => e.brush.height
function kx(e) {
  var t = po(e)
  return t.reduce((n, r) => {
    if (r.orientation === 'left' && !r.mirror && !r.hide) {
      var i = typeof r.width == 'number' ? r.width : Ar
      return n + i
    }
    return n
  }, 0)
}
function Mx(e) {
  var t = po(e)
  return t.reduce((n, r) => {
    if (r.orientation === 'right' && !r.mirror && !r.hide) {
      var i = typeof r.width == 'number' ? r.width : Ar
      return n + i
    }
    return n
  }, 0)
}
function Tx(e) {
  var t = ho(e)
  return t.reduce((n, r) => (r.orientation === 'top' && !r.mirror && !r.hide ? n + r.height : n), 0)
}
function Nx(e) {
  var t = ho(e)
  return t.reduce(
    (n, r) => (r.orientation === 'bottom' && !r.mirror && !r.hide ? n + r.height : n),
    0,
  )
}
var Oe = R([Ct, kt, $d, Cx, kx, Mx, Tx, Nx, kd, H0], (e, t, n, r, i, o, a, s, l, c) => {
    var u = { left: (n.left || 0) + i, right: (n.right || 0) + o },
      f = { top: (n.top || 0) + a, bottom: (n.bottom || 0) + s },
      d = qr(qr({}, f), u),
      h = d.bottom
    ;((d.bottom += r), (d = fx(d, l, c)))
    var g = e - d.left - d.right,
      p = t - d.top - d.bottom
    return qr(qr({ brushBottom: h }, d), {}, { width: Math.max(g, 0), height: Math.max(p, 0) })
  }),
  Dx = R(Oe, (e) => ({ x: e.left, y: e.top, width: e.width, height: e.height })),
  Rd = R(Ct, kt, (e, t) => ({ x: 0, y: 0, width: e, height: t })),
  Ix = v.createContext(null),
  We = () => v.useContext(Ix) != null,
  vo = (e) => e.brush,
  go = R([vo, Oe, $d], (e, t, n) => ({
    height: e.height,
    x: te(e.x) ? e.x : t.left,
    y: te(e.y) ? e.y : t.top + t.height + t.brushBottom - (n?.bottom || 0),
    width: te(e.width) ? e.width : t.width,
  })),
  gl = function (t, n) {
    for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
      i[o - 2] = arguments[o]
  }
function Le(e) {
  return Number.isFinite(e)
}
function Oi(e) {
  return typeof e == 'number' && e > 0 && Number.isFinite(e)
}
var jx = v.createContext({ width: -1, height: -1 }),
  Bd = () => v.useContext(jx),
  Or = () => {
    var e,
      t = We(),
      n = J(Dx),
      r = J(go),
      i = (e = J(vo)) === null || e === void 0 ? void 0 : e.padding
    return !t || !r || !i
      ? n
      : {
          width: r.width - i.left - i.right,
          height: r.height - i.top - i.bottom,
          x: i.left,
          y: i.top,
        }
  },
  $x = { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0, brushBottom: 0 },
  Hd = () => {
    var e
    return (e = J(Oe)) !== null && e !== void 0 ? e : $x
  },
  Ps = () => J(Ct),
  Ss = () => J(kt),
  Lx = () => J((e) => e.layout.margin),
  he = (e) => e.layout.layoutType,
  Fd = () => J(he),
  mo = (e) => {
    var t = pe(),
      n = We(),
      { width: r, height: i } = e,
      o = Bd(),
      a = r,
      s = i
    return (
      o && ((a = o.width > 0 ? o.width : r), (s = o.height > 0 ? o.height : i)),
      v.useEffect(() => {
        !n && Oi(a) && Oi(s) && t(X0({ width: a, height: s }))
      }, [t, n, a, s]),
      null
    )
  },
  zx = {
    settings: {
      layout: 'horizontal',
      align: 'center',
      verticalAlign: 'middle',
      itemSorter: 'value',
    },
    size: { width: 0, height: 0 },
    payload: [],
  },
  Vd = Ve({
    name: 'legend',
    initialState: zx,
    reducers: {
      setLegendSize(e, t) {
        ;((e.size.width = t.payload.width), (e.size.height = t.payload.height))
      },
      setLegendSettings(e, t) {
        ;((e.settings.align = t.payload.align),
          (e.settings.layout = t.payload.layout),
          (e.settings.verticalAlign = t.payload.verticalAlign),
          (e.settings.itemSorter = t.payload.itemSorter))
      },
      addLegendPayload: {
        reducer(e, t) {
          e.payload.push(Ne(t.payload))
        },
        prepare: Te(),
      },
      removeLegendPayload: {
        reducer(e, t) {
          var n = Ht(e).payload.indexOf(Ne(t.payload))
          n > -1 && e.payload.splice(n, 1)
        },
        prepare: Te(),
      },
    },
  }),
  {
    setLegendSize: ml,
    setLegendSettings: Rx,
    addLegendPayload: Bx,
    removeLegendPayload: Hx,
  } = Vd.actions,
  Fx = Vd.reducer,
  Vx = ['contextPayload']
function Oa() {
  return (
    (Oa = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Oa.apply(null, arguments)
  )
}
function yl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Sn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? yl(Object(n), !0).forEach(function (r) {
          Es(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : yl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Es(e, t, n) {
  return (
    (t = Wx(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function Wx(e) {
  var t = Kx(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function Kx(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function Yx(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = Ux(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function Ux(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function Xx(e) {
  return e.value
}
function Gx(e) {
  var { contextPayload: t } = e,
    n = Yx(e, Vx),
    r = Cd(t, e.payloadUniqBy, Xx),
    i = Sn(Sn({}, n), {}, { payload: r })
  return v.isValidElement(e.content)
    ? v.cloneElement(e.content, i)
    : typeof e.content == 'function'
      ? v.createElement(e.content, i)
      : v.createElement(bs, i)
}
function qx(e, t, n, r, i, o) {
  var { layout: a, align: s, verticalAlign: l } = t,
    c,
    u
  return (
    (!e || ((e.left === void 0 || e.left === null) && (e.right === void 0 || e.right === null))) &&
      (s === 'center' && a === 'vertical'
        ? (c = { left: ((r || 0) - o.width) / 2 })
        : (c = s === 'right' ? { right: (n && n.right) || 0 } : { left: (n && n.left) || 0 })),
    (!e || ((e.top === void 0 || e.top === null) && (e.bottom === void 0 || e.bottom === null))) &&
      (l === 'middle'
        ? (u = { top: ((i || 0) - o.height) / 2 })
        : (u = l === 'bottom' ? { bottom: (n && n.bottom) || 0 } : { top: (n && n.top) || 0 })),
    Sn(Sn({}, c), u)
  )
}
function Zx(e) {
  var t = pe()
  return (
    v.useEffect(() => {
      t(Rx(e))
    }, [t, e]),
    null
  )
}
function Qx(e) {
  var t = pe()
  return (
    v.useEffect(
      () => (
        t(ml(e)),
        () => {
          t(ml({ width: 0, height: 0 }))
        }
      ),
      [t, e],
    ),
    null
  )
}
function Jx(e) {
  var t = W0(),
    n = Hy(),
    r = Lx(),
    { width: i, height: o, wrapperStyle: a, portal: s } = e,
    [l, c] = Md([t]),
    u = Ps(),
    f = Ss()
  if (u == null || f == null) return null
  var d = u - (r.left || 0) - (r.right || 0),
    h = _s.getWidthOrHeight(e.layout, o, i, d),
    g = s
      ? a
      : Sn(
          Sn(
            {
              position: 'absolute',
              width: h?.width || i || 'auto',
              height: h?.height || o || 'auto',
            },
            qx(a, e, r, u, f, l),
          ),
          a,
        ),
    p = s ?? n
  if (p == null) return null
  var x = v.createElement(
    'div',
    { className: 'recharts-legend-wrapper', style: g, ref: c },
    v.createElement(Zx, {
      layout: e.layout,
      align: e.align,
      verticalAlign: e.verticalAlign,
      itemSorter: e.itemSorter,
    }),
    v.createElement(Qx, { width: l.width, height: l.height }),
    v.createElement(
      Gx,
      Oa({}, e, h, { margin: r, chartWidth: u, chartHeight: f, contextPayload: t }),
    ),
  )
  return id.createPortal(x, p)
}
class _s extends v.PureComponent {
  static getWidthOrHeight(t, n, r, i) {
    return t === 'vertical' && te(n) ? { height: n } : t === 'horizontal' ? { width: r || i } : null
  }
  render() {
    return v.createElement(Jx, this.props)
  }
}
Es(_s, 'displayName', 'Legend')
Es(_s, 'defaultProps', {
  align: 'center',
  iconSize: 14,
  itemSorter: 'value',
  layout: 'horizontal',
  verticalAlign: 'bottom',
})
function Ca() {
  return (
    (Ca = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Ca.apply(null, arguments)
  )
}
function xl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Qo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? xl(Object(n), !0).forEach(function (r) {
          eb(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : xl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function eb(e, t, n) {
  return (
    (t = tb(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function tb(e) {
  var t = nb(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function nb(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function rb(e) {
  return Array.isArray(e) && dt(e[0]) && dt(e[1]) ? e.join(' ~ ') : e
}
var ib = (e) => {
    var {
        separator: t = ' : ',
        contentStyle: n = {},
        itemStyle: r = {},
        labelStyle: i = {},
        payload: o,
        formatter: a,
        itemSorter: s,
        wrapperClassName: l,
        labelClassName: c,
        label: u,
        labelFormatter: f,
        accessibilityLayer: d = !1,
      } = e,
      h = () => {
        if (o && o.length) {
          var P = { padding: 0, margin: 0 },
            S = (s ? so(o, s) : o).map((_, M) => {
              if (_.type === 'none') return null
              var T = _.formatter || a || rb,
                { value: F, name: D } = _,
                k = F,
                $ = D
              if (T) {
                var E = T(F, D, _, M, o)
                if (Array.isArray(E)) [k, $] = E
                else if (E != null) k = E
                else return null
              }
              var O = Qo(
                { display: 'block', paddingTop: 4, paddingBottom: 4, color: _.color || '#000' },
                r,
              )
              return v.createElement(
                'li',
                { className: 'recharts-tooltip-item', key: 'tooltip-item-'.concat(M), style: O },
                dt($)
                  ? v.createElement('span', { className: 'recharts-tooltip-item-name' }, $)
                  : null,
                dt($)
                  ? v.createElement('span', { className: 'recharts-tooltip-item-separator' }, t)
                  : null,
                v.createElement('span', { className: 'recharts-tooltip-item-value' }, k),
                v.createElement('span', { className: 'recharts-tooltip-item-unit' }, _.unit || ''),
              )
            })
          return v.createElement('ul', { className: 'recharts-tooltip-item-list', style: P }, S)
        }
        return null
      },
      g = Qo(
        {
          margin: 0,
          padding: 10,
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          whiteSpace: 'nowrap',
        },
        n,
      ),
      p = Qo({ margin: 0 }, i),
      x = !ge(u),
      y = x ? u : '',
      w = le('recharts-default-tooltip', l),
      m = le('recharts-tooltip-label', c)
    x && f && o !== void 0 && o !== null && (y = f(u, o))
    var b = d ? { role: 'status', 'aria-live': 'assertive' } : {}
    return v.createElement(
      'div',
      Ca({ className: w, style: g }, b),
      v.createElement('p', { className: m, style: p }, v.isValidElement(y) ? y : ''.concat(y)),
      h(),
    )
  },
  Yn = 'recharts-tooltip-wrapper',
  ob = { visibility: 'hidden' }
function ab(e) {
  var { coordinate: t, translateX: n, translateY: r } = e
  return le(Yn, {
    [''.concat(Yn, '-right')]: te(n) && t && te(t.x) && n >= t.x,
    [''.concat(Yn, '-left')]: te(n) && t && te(t.x) && n < t.x,
    [''.concat(Yn, '-bottom')]: te(r) && t && te(t.y) && r >= t.y,
    [''.concat(Yn, '-top')]: te(r) && t && te(t.y) && r < t.y,
  })
}
function bl(e) {
  var {
    allowEscapeViewBox: t,
    coordinate: n,
    key: r,
    offsetTopLeft: i,
    position: o,
    reverseDirection: a,
    tooltipDimension: s,
    viewBox: l,
    viewBoxDimension: c,
  } = e
  if (o && te(o[r])) return o[r]
  var u = n[r] - s - (i > 0 ? i : 0),
    f = n[r] + i
  if (t[r]) return a[r] ? u : f
  var d = l[r]
  if (d == null) return 0
  if (a[r]) {
    var h = u,
      g = d
    return h < g ? Math.max(f, d) : Math.max(u, d)
  }
  if (c == null) return 0
  var p = f + s,
    x = d + c
  return p > x ? Math.max(u, d) : Math.max(f, d)
}
function sb(e) {
  var { translateX: t, translateY: n, useTranslate3d: r } = e
  return {
    transform: r
      ? 'translate3d('.concat(t, 'px, ').concat(n, 'px, 0)')
      : 'translate('.concat(t, 'px, ').concat(n, 'px)'),
  }
}
function cb(e) {
  var {
      allowEscapeViewBox: t,
      coordinate: n,
      offsetTopLeft: r,
      position: i,
      reverseDirection: o,
      tooltipBox: a,
      useTranslate3d: s,
      viewBox: l,
    } = e,
    c,
    u,
    f
  return (
    a.height > 0 && a.width > 0 && n
      ? ((u = bl({
          allowEscapeViewBox: t,
          coordinate: n,
          key: 'x',
          offsetTopLeft: r,
          position: i,
          reverseDirection: o,
          tooltipDimension: a.width,
          viewBox: l,
          viewBoxDimension: l.width,
        })),
        (f = bl({
          allowEscapeViewBox: t,
          coordinate: n,
          key: 'y',
          offsetTopLeft: r,
          position: i,
          reverseDirection: o,
          tooltipDimension: a.height,
          viewBox: l,
          viewBoxDimension: l.height,
        })),
        (c = sb({ translateX: u, translateY: f, useTranslate3d: s })))
      : (c = ob),
    { cssProperties: c, cssClasses: ab({ translateX: u, translateY: f, coordinate: n }) }
  )
}
function wl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Zr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? wl(Object(n), !0).forEach(function (r) {
          ka(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : wl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function ka(e, t, n) {
  return (
    (t = lb(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function lb(e) {
  var t = ub(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function ub(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
class fb extends v.PureComponent {
  constructor() {
    ;(super(...arguments),
      ka(this, 'state', { dismissed: !1, dismissedAtCoordinate: { x: 0, y: 0 } }),
      ka(this, 'handleKeyDown', (t) => {
        if (t.key === 'Escape') {
          var n, r, i, o
          this.setState({
            dismissed: !0,
            dismissedAtCoordinate: {
              x:
                (n = (r = this.props.coordinate) === null || r === void 0 ? void 0 : r.x) !==
                  null && n !== void 0
                  ? n
                  : 0,
              y:
                (i = (o = this.props.coordinate) === null || o === void 0 ? void 0 : o.y) !==
                  null && i !== void 0
                  ? i
                  : 0,
            },
          })
        }
      }))
  }
  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyDown)
  }
  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyDown)
  }
  componentDidUpdate() {
    var t, n
    this.state.dismissed &&
      (((t = this.props.coordinate) === null || t === void 0 ? void 0 : t.x) !==
        this.state.dismissedAtCoordinate.x ||
        ((n = this.props.coordinate) === null || n === void 0 ? void 0 : n.y) !==
          this.state.dismissedAtCoordinate.y) &&
      (this.state.dismissed = !1)
  }
  render() {
    var {
        active: t,
        allowEscapeViewBox: n,
        animationDuration: r,
        animationEasing: i,
        children: o,
        coordinate: a,
        hasPayload: s,
        isAnimationActive: l,
        offset: c,
        position: u,
        reverseDirection: f,
        useTranslate3d: d,
        viewBox: h,
        wrapperStyle: g,
        lastBoundingBox: p,
        innerRef: x,
        hasPortalFromProps: y,
      } = this.props,
      { cssClasses: w, cssProperties: m } = cb({
        allowEscapeViewBox: n,
        coordinate: a,
        offsetTopLeft: c,
        position: u,
        reverseDirection: f,
        tooltipBox: { height: p.height, width: p.width },
        useTranslate3d: d,
        viewBox: h,
      }),
      b = y
        ? {}
        : Zr(
            Zr({ transition: l && t ? 'transform '.concat(r, 'ms ').concat(i) : void 0 }, m),
            {},
            {
              pointerEvents: 'none',
              visibility: !this.state.dismissed && t && s ? 'visible' : 'hidden',
              position: 'absolute',
              top: 0,
              left: 0,
            },
          ),
      P = Zr(
        Zr({}, b),
        {},
        { visibility: !this.state.dismissed && t && s ? 'visible' : 'hidden' },
        g,
      )
    return v.createElement(
      'div',
      { xmlns: 'http://www.w3.org/1999/xhtml', tabIndex: -1, className: w, style: P, ref: x },
      o,
    )
  }
}
var db = () =>
    !(typeof window < 'u' && window.document && window.document.createElement && window.setTimeout),
  $n = { devToolsEnabled: !1, isSsr: db() },
  Wd = () => J((e) => e.rootProps.accessibilityLayer)
function Ma() {
  return (
    (Ma = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Ma.apply(null, arguments)
  )
}
function Pl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Sl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Pl(Object(n), !0).forEach(function (r) {
          hb(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Pl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function hb(e, t, n) {
  return (
    (t = pb(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function pb(e) {
  var t = vb(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function vb(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var El = {
    curveBasisClosed: a0,
    curveBasisOpen: s0,
    curveBasis: o0,
    curveBumpX: Ky,
    curveBumpY: Yy,
    curveLinearClosed: c0,
    curveLinear: lo,
    curveMonotoneX: l0,
    curveMonotoneY: u0,
    curveNatural: f0,
    curveStep: d0,
    curveStepAfter: p0,
    curveStepBefore: h0,
  },
  Qr = (e) => Le(e.x) && Le(e.y),
  Un = (e) => e.x,
  Xn = (e) => e.y,
  gb = (e, t) => {
    if (typeof e == 'function') return e
    var n = 'curve'.concat(_r(e))
    return (n === 'curveMonotone' || n === 'curveBump') && t
      ? El[''.concat(n).concat(t === 'vertical' ? 'Y' : 'X')]
      : El[n] || lo
  },
  mb = (e) => {
    var { type: t = 'linear', points: n = [], baseLine: r, layout: i, connectNulls: o = !1 } = e,
      a = gb(t, i),
      s = o ? n.filter(Qr) : n,
      l
    if (Array.isArray(r)) {
      var c = o ? r.filter((f) => Qr(f)) : r,
        u = s.map((f, d) => Sl(Sl({}, f), {}, { base: c[d] }))
      return (
        i === 'vertical'
          ? (l = Ur()
              .y(Xn)
              .x1(Un)
              .x0((f) => f.base.x))
          : (l = Ur()
              .x(Un)
              .y1(Xn)
              .y0((f) => f.base.y)),
        l.defined(Qr).curve(a),
        l(u)
      )
    }
    return (
      i === 'vertical' && te(r)
        ? (l = Ur().y(Xn).x1(Un).x0(r))
        : te(r)
          ? (l = Ur().x(Un).y1(Xn).y0(r))
          : (l = pd().x(Un).y(Xn)),
      l.defined(Qr).curve(a),
      l(s)
    )
  },
  Kd = (e) => {
    var { className: t, points: n, path: r, pathRef: i } = e
    if ((!n || !n.length) && !r) return null
    var o = n && n.length ? mb(e) : r
    return v.createElement(
      'path',
      Ma({}, ft(e), D0(e), {
        className: le('recharts-curve', t),
        d: o === null ? void 0 : o,
        ref: i,
      }),
    )
  },
  yb = ['x', 'y', 'top', 'left', 'width', 'height', 'className']
function Ta() {
  return (
    (Ta = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Ta.apply(null, arguments)
  )
}
function _l(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function xb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? _l(Object(n), !0).forEach(function (r) {
          bb(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : _l(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function bb(e, t, n) {
  return (
    (t = wb(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function wb(e) {
  var t = Pb(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function Pb(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function Sb(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = Eb(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function Eb(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var _b = (e, t, n, r, i, o) =>
    'M'.concat(e, ',').concat(i, 'v').concat(r, 'M').concat(o, ',').concat(t, 'h').concat(n),
  Ab = (e) => {
    var {
        x: t = 0,
        y: n = 0,
        top: r = 0,
        left: i = 0,
        width: o = 0,
        height: a = 0,
        className: s,
      } = e,
      l = Sb(e, yb),
      c = xb({ x: t, y: n, top: r, left: i, width: o, height: a }, l)
    return !te(t) || !te(n) || !te(o) || !te(a) || !te(r) || !te(i)
      ? null
      : v.createElement(
          'path',
          Ta({}, et(c), { className: le('recharts-cross', s), d: _b(t, n, o, a, r, i) }),
        )
  }
function Ob(e, t, n, r) {
  var i = r / 2
  return {
    stroke: 'none',
    fill: '#ccc',
    x: e === 'horizontal' ? t.x - i : n.left + 0.5,
    y: e === 'horizontal' ? n.top + 0.5 : t.y - i,
    width: e === 'horizontal' ? r : n.width - 1,
    height: e === 'horizontal' ? n.height - 1 : r,
  }
}
function Al(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Cb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Al(Object(n), !0).forEach(function (r) {
          kb(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Al(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function kb(e, t, n) {
  return (
    (t = Mb(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function Mb(e) {
  var t = Tb(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function Tb(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function Ke(e, t) {
  var n = Cb({}, e),
    r = t,
    i = Object.keys(t),
    o = i.reduce((a, s) => (a[s] === void 0 && r[s] !== void 0 && (a[s] = r[s]), a), n)
  return o
}
function Ol(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Cl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Ol(Object(n), !0).forEach(function (r) {
          Nb(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Ol(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Nb(e, t, n) {
  return (
    (t = Db(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function Db(e) {
  var t = Ib(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function Ib(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var jb = (e) => e.replace(/([A-Z])/g, (t) => '-'.concat(t.toLowerCase())),
  Yd = (e, t, n) => e.map((r) => ''.concat(jb(r), ' ').concat(t, 'ms ').concat(n)).join(','),
  $b = (e, t) => [Object.keys(e), Object.keys(t)].reduce((n, r) => n.filter((i) => r.includes(i))),
  lr = (e, t) => Object.keys(t).reduce((n, r) => Cl(Cl({}, n), {}, { [r]: e(r, t[r]) }), {})
function kl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Ee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? kl(Object(n), !0).forEach(function (r) {
          Lb(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : kl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Lb(e, t, n) {
  return (
    (t = zb(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function zb(e) {
  var t = Rb(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function Rb(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var Ci = (e, t, n) => e + (t - e) * n,
  Na = (e) => {
    var { from: t, to: n } = e
    return t !== n
  },
  Ud = (e, t, n) => {
    var r = lr((i, o) => {
      if (Na(o)) {
        var [a, s] = e(o.from, o.to, o.velocity)
        return Ee(Ee({}, o), {}, { from: a, velocity: s })
      }
      return o
    }, t)
    return n < 1
      ? lr(
          (i, o) =>
            Na(o)
              ? Ee(
                  Ee({}, o),
                  {},
                  { velocity: Ci(o.velocity, r[i].velocity, n), from: Ci(o.from, r[i].from, n) },
                )
              : o,
          t,
        )
      : Ud(e, r, n - 1)
  }
function Bb(e, t, n, r, i, o) {
  var a,
    s = r.reduce((d, h) => Ee(Ee({}, d), {}, { [h]: { from: e[h], velocity: 0, to: t[h] } }), {}),
    l = () => lr((d, h) => h.from, s),
    c = () => !Object.values(s).filter(Na).length,
    u = null,
    f = (d) => {
      a || (a = d)
      var h = d - a,
        g = h / n.dt
      ;((s = Ud(n, s, g)), i(Ee(Ee(Ee({}, e), t), l())), (a = d), c() || (u = o.setTimeout(f)))
    }
  return () => (
    (u = o.setTimeout(f)),
    () => {
      u()
    }
  )
}
function Hb(e, t, n, r, i, o, a) {
  var s = null,
    l = i.reduce((f, d) => Ee(Ee({}, f), {}, { [d]: [e[d], t[d]] }), {}),
    c,
    u = (f) => {
      c || (c = f)
      var d = (f - c) / r,
        h = lr((p, x) => Ci(...x, n(d)), l)
      if ((o(Ee(Ee(Ee({}, e), t), h)), d < 1)) s = a.setTimeout(u)
      else {
        var g = lr((p, x) => Ci(...x, n(1)), l)
        o(Ee(Ee(Ee({}, e), t), g))
      }
    }
  return () => (
    (s = a.setTimeout(u)),
    () => {
      s()
    }
  )
}
const Fb = (e, t, n, r, i, o) => {
  var a = $b(e, t)
  return n.isStepper === !0 ? Bb(e, t, n, a, i, o) : Hb(e, t, n, r, a, i, o)
}
var ki = 1e-4,
  Xd = (e, t) => [0, 3 * e, 3 * t - 6 * e, 3 * e - 3 * t + 1],
  Gd = (e, t) => e.map((n, r) => n * t ** r).reduce((n, r) => n + r),
  Ml = (e, t) => (n) => {
    var r = Xd(e, t)
    return Gd(r, n)
  },
  Vb = (e, t) => (n) => {
    var r = Xd(e, t),
      i = [...r.map((o, a) => o * a).slice(1), 0]
    return Gd(i, n)
  },
  Tl = function () {
    for (var t, n, r, i, o = arguments.length, a = new Array(o), s = 0; s < o; s++)
      a[s] = arguments[s]
    if (a.length === 1)
      switch (a[0]) {
        case 'linear':
          ;[t, r, n, i] = [0, 0, 1, 1]
          break
        case 'ease':
          ;[t, r, n, i] = [0.25, 0.1, 0.25, 1]
          break
        case 'ease-in':
          ;[t, r, n, i] = [0.42, 0, 1, 1]
          break
        case 'ease-out':
          ;[t, r, n, i] = [0.42, 0, 0.58, 1]
          break
        case 'ease-in-out':
          ;[t, r, n, i] = [0, 0, 0.58, 1]
          break
        default: {
          var l = a[0].split('(')
          l[0] === 'cubic-bezier' &&
            l[1].split(')')[0].split(',').length === 4 &&
            ([t, r, n, i] = l[1]
              .split(')')[0]
              .split(',')
              .map((g) => parseFloat(g)))
        }
      }
    else a.length === 4 && ([t, r, n, i] = a)
    var c = Ml(t, n),
      u = Ml(r, i),
      f = Vb(t, n),
      d = (g) => (g > 1 ? 1 : g < 0 ? 0 : g),
      h = (g) => {
        for (var p = g > 1 ? 1 : g, x = p, y = 0; y < 8; ++y) {
          var w = c(x) - p,
            m = f(x)
          if (Math.abs(w - p) < ki || m < ki) return u(x)
          x = d(x - w / m)
        }
        return u(x)
      }
    return ((h.isStepper = !1), h)
  },
  Wb = function () {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      { stiff: n = 100, damping: r = 8, dt: i = 17 } = t,
      o = (a, s, l) => {
        var c = -(a - s) * n,
          u = l * r,
          f = l + ((c - u) * i) / 1e3,
          d = (l * i) / 1e3 + a
        return Math.abs(d - s) < ki && Math.abs(f) < ki ? [s, 0] : [d, f]
      }
    return ((o.isStepper = !0), (o.dt = i), o)
  },
  Kb = (e) => {
    if (typeof e == 'string')
      switch (e) {
        case 'ease':
        case 'ease-in-out':
        case 'ease-out':
        case 'ease-in':
        case 'linear':
          return Tl(e)
        case 'spring':
          return Wb()
        default:
          if (e.split('(')[0] === 'cubic-bezier') return Tl(e)
      }
    return typeof e == 'function' ? e : null
  }
function Yb(e) {
  var t,
    n = () => null,
    r = !1,
    i = null,
    o = (a) => {
      if (!r) {
        if (Array.isArray(a)) {
          if (!a.length) return
          var s = a,
            [l, ...c] = s
          if (typeof l == 'number') {
            i = e.setTimeout(o.bind(null, c), l)
            return
          }
          ;(o(l), (i = e.setTimeout(o.bind(null, c))))
          return
        }
        ;(typeof a == 'string' && ((t = a), n(t)),
          typeof a == 'object' && ((t = a), n(t)),
          typeof a == 'function' && a())
      }
    }
  return {
    stop: () => {
      r = !0
    },
    start: (a) => {
      ;((r = !1), i && (i(), (i = null)), o(a))
    },
    subscribe: (a) => (
      (n = a),
      () => {
        n = () => null
      }
    ),
    getTimeoutController: () => e,
  }
}
class Ub {
  setTimeout(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
      r = performance.now(),
      i = null,
      o = (a) => {
        a - r >= n
          ? t(a)
          : typeof requestAnimationFrame == 'function' && (i = requestAnimationFrame(o))
      }
    return (
      (i = requestAnimationFrame(o)),
      () => {
        cancelAnimationFrame(i)
      }
    )
  }
}
function Xb() {
  return Yb(new Ub())
}
var Gb = v.createContext(Xb)
function qb(e, t) {
  var n = v.useContext(Gb)
  return v.useMemo(() => t ?? n(e), [e, t, n])
}
var Zb = {
    begin: 0,
    duration: 1e3,
    easing: 'ease',
    isActive: !0,
    canBegin: !0,
    onAnimationEnd: () => {},
    onAnimationStart: () => {},
  },
  Nl = { t: 0 },
  Jo = { t: 1 }
function As(e) {
  var t = Ke(e, Zb),
    {
      isActive: n,
      canBegin: r,
      duration: i,
      easing: o,
      begin: a,
      onAnimationEnd: s,
      onAnimationStart: l,
      children: c,
    } = t,
    u = qb(t.animationId, t.animationManager),
    [f, d] = v.useState(n ? Nl : Jo),
    h = v.useRef(null)
  return (
    v.useEffect(() => {
      n || d(Jo)
    }, [n]),
    v.useEffect(() => {
      if (!n || !r) return Sy
      var g = Fb(Nl, Jo, Kb(o), i, d, u.getTimeoutController()),
        p = () => {
          h.current = g()
        }
      return (
        u.start([l, a, p, i, s]),
        () => {
          ;(u.stop(), h.current && h.current(), s())
        }
      )
    }, [n, r, i, o, a, l, s, u]),
    c(f.t)
  )
}
function Os(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'animation-',
    n = v.useRef(cr(t)),
    r = v.useRef(e)
  return (r.current !== e && ((n.current = cr(t)), (r.current = e)), n.current)
}
var Qb = ['radius'],
  Jb = ['radius']
function Dl(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Il(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Dl(Object(n), !0).forEach(function (r) {
          ew(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Dl(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function ew(e, t, n) {
  return (
    (t = tw(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function tw(e) {
  var t = nw(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function nw(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function Mi() {
  return (
    (Mi = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Mi.apply(null, arguments)
  )
}
function jl(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = rw(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function rw(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var $l = (e, t, n, r, i) => {
    var o = Math.min(Math.abs(n) / 2, Math.abs(r) / 2),
      a = r >= 0 ? 1 : -1,
      s = n >= 0 ? 1 : -1,
      l = (r >= 0 && n >= 0) || (r < 0 && n < 0) ? 1 : 0,
      c
    if (o > 0 && i instanceof Array) {
      for (var u = [0, 0, 0, 0], f = 0, d = 4; f < d; f++) u[f] = i[f] > o ? o : i[f]
      ;((c = 'M'.concat(e, ',').concat(t + a * u[0])),
        u[0] > 0 &&
          (c += 'A '
            .concat(u[0], ',')
            .concat(u[0], ',0,0,')
            .concat(l, ',')
            .concat(e + s * u[0], ',')
            .concat(t)),
        (c += 'L '.concat(e + n - s * u[1], ',').concat(t)),
        u[1] > 0 &&
          (c += 'A '
            .concat(u[1], ',')
            .concat(u[1], ',0,0,')
            .concat(
              l,
              `,
        `,
            )
            .concat(e + n, ',')
            .concat(t + a * u[1])),
        (c += 'L '.concat(e + n, ',').concat(t + r - a * u[2])),
        u[2] > 0 &&
          (c += 'A '
            .concat(u[2], ',')
            .concat(u[2], ',0,0,')
            .concat(
              l,
              `,
        `,
            )
            .concat(e + n - s * u[2], ',')
            .concat(t + r)),
        (c += 'L '.concat(e + s * u[3], ',').concat(t + r)),
        u[3] > 0 &&
          (c += 'A '
            .concat(u[3], ',')
            .concat(u[3], ',0,0,')
            .concat(
              l,
              `,
        `,
            )
            .concat(e, ',')
            .concat(t + r - a * u[3])),
        (c += 'Z'))
    } else if (o > 0 && i === +i && i > 0) {
      var h = Math.min(o, i)
      c = 'M '
        .concat(e, ',')
        .concat(
          t + a * h,
          `
            A `,
        )
        .concat(h, ',')
        .concat(h, ',0,0,')
        .concat(l, ',')
        .concat(e + s * h, ',')
        .concat(
          t,
          `
            L `,
        )
        .concat(e + n - s * h, ',')
        .concat(
          t,
          `
            A `,
        )
        .concat(h, ',')
        .concat(h, ',0,0,')
        .concat(l, ',')
        .concat(e + n, ',')
        .concat(
          t + a * h,
          `
            L `,
        )
        .concat(e + n, ',')
        .concat(
          t + r - a * h,
          `
            A `,
        )
        .concat(h, ',')
        .concat(h, ',0,0,')
        .concat(l, ',')
        .concat(e + n - s * h, ',')
        .concat(
          t + r,
          `
            L `,
        )
        .concat(e + s * h, ',')
        .concat(
          t + r,
          `
            A `,
        )
        .concat(h, ',')
        .concat(h, ',0,0,')
        .concat(l, ',')
        .concat(e, ',')
        .concat(t + r - a * h, ' Z')
    } else
      c = 'M '.concat(e, ',').concat(t, ' h ').concat(n, ' v ').concat(r, ' h ').concat(-n, ' Z')
    return c
  },
  iw = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    radius: 0,
    isAnimationActive: !1,
    isUpdateAnimationActive: !1,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: 'ease',
  },
  qd = (e) => {
    var t = Ke(e, iw),
      n = v.useRef(null),
      [r, i] = v.useState(-1)
    v.useEffect(() => {
      if (n.current && n.current.getTotalLength)
        try {
          var C = n.current.getTotalLength()
          C && i(C)
        } catch {}
    }, [])
    var { x: o, y: a, width: s, height: l, radius: c, className: u } = t,
      {
        animationEasing: f,
        animationDuration: d,
        animationBegin: h,
        isAnimationActive: g,
        isUpdateAnimationActive: p,
      } = t,
      x = v.useRef(s),
      y = v.useRef(l),
      w = v.useRef(o),
      m = v.useRef(a),
      b = v.useMemo(() => ({ x: o, y: a, width: s, height: l, radius: c }), [o, a, s, l, c]),
      P = Os(b, 'rectangle-')
    if (o !== +o || a !== +a || s !== +s || l !== +l || s === 0 || l === 0) return null
    var S = le('recharts-rectangle', u)
    if (!p) {
      var _ = et(t),
        { radius: M } = _,
        T = jl(_, Qb)
      return v.createElement(
        'path',
        Mi({}, T, {
          radius: typeof c == 'number' ? c : void 0,
          className: S,
          d: $l(o, a, s, l, c),
        }),
      )
    }
    var F = x.current,
      D = y.current,
      k = w.current,
      $ = m.current,
      E = '0px '.concat(r === -1 ? 1 : r, 'px'),
      O = ''.concat(r, 'px 0px'),
      A = Yd(['strokeDasharray'], d, typeof f == 'string' ? f : void 0)
    return v.createElement(
      As,
      { animationId: P, key: P, canBegin: r > 0, duration: d, easing: f, isActive: p, begin: h },
      (C) => {
        var N = gt(F, s, C),
          I = gt(D, l, C),
          H = gt(k, o, C),
          V = gt($, a, C)
        n.current && ((x.current = N), (y.current = I), (w.current = H), (m.current = V))
        var B
        g
          ? C > 0
            ? (B = { transition: A, strokeDasharray: O })
            : (B = { strokeDasharray: E })
          : (B = { strokeDasharray: O })
        var Y = et(t),
          { radius: K } = Y,
          G = jl(Y, Jb)
        return v.createElement(
          'path',
          Mi({}, G, {
            radius: typeof c == 'number' ? c : void 0,
            className: S,
            d: $l(H, V, N, I, c),
            ref: n,
            style: Il(Il({}, B), t.style),
          }),
        )
      },
    )
  }
function Zd(e) {
  var { cx: t, cy: n, radius: r, startAngle: i, endAngle: o } = e,
    a = _e(t, n, r, i),
    s = _e(t, n, r, o)
  return { points: [a, s], cx: t, cy: n, radius: r, startAngle: i, endAngle: o }
}
function Da() {
  return (
    (Da = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Da.apply(null, arguments)
  )
}
var ow = (e, t) => {
    var n = Qe(t - e),
      r = Math.min(Math.abs(t - e), 359.999)
    return n * r
  },
  Jr = (e) => {
    var {
        cx: t,
        cy: n,
        radius: r,
        angle: i,
        sign: o,
        isExternal: a,
        cornerRadius: s,
        cornerIsExternal: l,
      } = e,
      c = s * (a ? 1 : -1) + r,
      u = Math.asin(s / c) / Ai,
      f = l ? i : i + o * u,
      d = _e(t, n, c, f),
      h = _e(t, n, r, f),
      g = l ? i - o * u : i,
      p = _e(t, n, c * Math.cos(u * Ai), g)
    return { center: d, circleTangency: h, lineTangency: p, theta: u }
  },
  Qd = (e) => {
    var { cx: t, cy: n, innerRadius: r, outerRadius: i, startAngle: o, endAngle: a } = e,
      s = ow(o, a),
      l = o + s,
      c = _e(t, n, i, o),
      u = _e(t, n, i, l),
      f = 'M '
        .concat(c.x, ',')
        .concat(
          c.y,
          `
    A `,
        )
        .concat(i, ',')
        .concat(
          i,
          `,0,
    `,
        )
        .concat(+(Math.abs(s) > 180), ',')
        .concat(
          +(o > l),
          `,
    `,
        )
        .concat(u.x, ',')
        .concat(
          u.y,
          `
  `,
        )
    if (r > 0) {
      var d = _e(t, n, r, o),
        h = _e(t, n, r, l)
      f += 'L '
        .concat(h.x, ',')
        .concat(
          h.y,
          `
            A `,
        )
        .concat(r, ',')
        .concat(
          r,
          `,0,
            `,
        )
        .concat(+(Math.abs(s) > 180), ',')
        .concat(
          +(o <= l),
          `,
            `,
        )
        .concat(d.x, ',')
        .concat(d.y, ' Z')
    } else f += 'L '.concat(t, ',').concat(n, ' Z')
    return f
  },
  aw = (e) => {
    var {
        cx: t,
        cy: n,
        innerRadius: r,
        outerRadius: i,
        cornerRadius: o,
        forceCornerRadius: a,
        cornerIsExternal: s,
        startAngle: l,
        endAngle: c,
      } = e,
      u = Qe(c - l),
      {
        circleTangency: f,
        lineTangency: d,
        theta: h,
      } = Jr({ cx: t, cy: n, radius: i, angle: l, sign: u, cornerRadius: o, cornerIsExternal: s }),
      {
        circleTangency: g,
        lineTangency: p,
        theta: x,
      } = Jr({ cx: t, cy: n, radius: i, angle: c, sign: -u, cornerRadius: o, cornerIsExternal: s }),
      y = s ? Math.abs(l - c) : Math.abs(l - c) - h - x
    if (y < 0)
      return a
        ? 'M '
            .concat(d.x, ',')
            .concat(
              d.y,
              `
        a`,
            )
            .concat(o, ',')
            .concat(o, ',0,0,1,')
            .concat(
              o * 2,
              `,0
        a`,
            )
            .concat(o, ',')
            .concat(o, ',0,0,1,')
            .concat(
              -o * 2,
              `,0
      `,
            )
        : Qd({ cx: t, cy: n, innerRadius: r, outerRadius: i, startAngle: l, endAngle: c })
    var w = 'M '
      .concat(d.x, ',')
      .concat(
        d.y,
        `
    A`,
      )
      .concat(o, ',')
      .concat(o, ',0,0,')
      .concat(+(u < 0), ',')
      .concat(f.x, ',')
      .concat(
        f.y,
        `
    A`,
      )
      .concat(i, ',')
      .concat(i, ',0,')
      .concat(+(y > 180), ',')
      .concat(+(u < 0), ',')
      .concat(g.x, ',')
      .concat(
        g.y,
        `
    A`,
      )
      .concat(o, ',')
      .concat(o, ',0,0,')
      .concat(+(u < 0), ',')
      .concat(p.x, ',')
      .concat(
        p.y,
        `
  `,
      )
    if (r > 0) {
      var {
          circleTangency: m,
          lineTangency: b,
          theta: P,
        } = Jr({
          cx: t,
          cy: n,
          radius: r,
          angle: l,
          sign: u,
          isExternal: !0,
          cornerRadius: o,
          cornerIsExternal: s,
        }),
        {
          circleTangency: S,
          lineTangency: _,
          theta: M,
        } = Jr({
          cx: t,
          cy: n,
          radius: r,
          angle: c,
          sign: -u,
          isExternal: !0,
          cornerRadius: o,
          cornerIsExternal: s,
        }),
        T = s ? Math.abs(l - c) : Math.abs(l - c) - P - M
      if (T < 0 && o === 0) return ''.concat(w, 'L').concat(t, ',').concat(n, 'Z')
      w += 'L'
        .concat(_.x, ',')
        .concat(
          _.y,
          `
      A`,
        )
        .concat(o, ',')
        .concat(o, ',0,0,')
        .concat(+(u < 0), ',')
        .concat(S.x, ',')
        .concat(
          S.y,
          `
      A`,
        )
        .concat(r, ',')
        .concat(r, ',0,')
        .concat(+(T > 180), ',')
        .concat(+(u > 0), ',')
        .concat(m.x, ',')
        .concat(
          m.y,
          `
      A`,
        )
        .concat(o, ',')
        .concat(o, ',0,0,')
        .concat(+(u < 0), ',')
        .concat(b.x, ',')
        .concat(b.y, 'Z')
    } else w += 'L'.concat(t, ',').concat(n, 'Z')
    return w
  },
  sw = {
    cx: 0,
    cy: 0,
    innerRadius: 0,
    outerRadius: 0,
    startAngle: 0,
    endAngle: 0,
    cornerRadius: 0,
    forceCornerRadius: !1,
    cornerIsExternal: !1,
  },
  Jd = (e) => {
    var t = Ke(e, sw),
      {
        cx: n,
        cy: r,
        innerRadius: i,
        outerRadius: o,
        cornerRadius: a,
        forceCornerRadius: s,
        cornerIsExternal: l,
        startAngle: c,
        endAngle: u,
        className: f,
      } = t
    if (o < i || c === u) return null
    var d = le('recharts-sector', f),
      h = o - i,
      g = Wt(a, h, 0, !0),
      p
    return (
      g > 0 && Math.abs(c - u) < 360
        ? (p = aw({
            cx: n,
            cy: r,
            innerRadius: i,
            outerRadius: o,
            cornerRadius: Math.min(g, h / 2),
            forceCornerRadius: s,
            cornerIsExternal: l,
            startAngle: c,
            endAngle: u,
          }))
        : (p = Qd({ cx: n, cy: r, innerRadius: i, outerRadius: o, startAngle: c, endAngle: u })),
      v.createElement('path', Da({}, et(t), { className: d, d: p }))
    )
  }
function cw(e, t, n) {
  var r, i, o, a
  if (e === 'horizontal') ((r = t.x), (o = r), (i = n.top), (a = n.top + n.height))
  else if (e === 'vertical') ((i = t.y), (a = i), (r = n.left), (o = n.left + n.width))
  else if (t.cx != null && t.cy != null)
    if (e === 'centric') {
      var { cx: s, cy: l, innerRadius: c, outerRadius: u, angle: f } = t,
        d = _e(s, l, c, f),
        h = _e(s, l, u, f)
      ;((r = d.x), (i = d.y), (o = h.x), (a = h.y))
    } else return Zd(t)
  return [
    { x: r, y: i },
    { x: o, y: a },
  ]
}
function Ft(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
}
function lw(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
}
function Cs(e) {
  let t, n, r
  e.length !== 2
    ? ((t = Ft), (n = (s, l) => Ft(e(s), l)), (r = (s, l) => e(s) - l))
    : ((t = e === Ft || e === lw ? e : uw), (n = e), (r = e))
  function i(s, l, c = 0, u = s.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u
      do {
        const f = (c + u) >>> 1
        n(s[f], l) < 0 ? (c = f + 1) : (u = f)
      } while (c < u)
    }
    return c
  }
  function o(s, l, c = 0, u = s.length) {
    if (c < u) {
      if (t(l, l) !== 0) return u
      do {
        const f = (c + u) >>> 1
        n(s[f], l) <= 0 ? (c = f + 1) : (u = f)
      } while (c < u)
    }
    return c
  }
  function a(s, l, c = 0, u = s.length) {
    const f = i(s, l, c, u - 1)
    return f > c && r(s[f - 1], l) > -r(s[f], l) ? f - 1 : f
  }
  return { left: i, center: a, right: o }
}
function uw() {
  return 0
}
function eh(e) {
  return e === null ? NaN : +e
}
function* fw(e, t) {
  for (let n of e) n != null && (n = +n) >= n && (yield n)
}
const dw = Cs(Ft),
  Cr = dw.right
Cs(eh).center
function hw(e = Ft) {
  if (e === Ft) return th
  if (typeof e != 'function') throw new TypeError('compare is not a function')
  return (t, n) => {
    const r = e(t, n)
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0)
  }
}
function th(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0)
}
const pw = Math.sqrt(50),
  vw = Math.sqrt(10),
  gw = Math.sqrt(2)
function Ti(e, t, n) {
  const r = (t - e) / Math.max(0, n),
    i = Math.floor(Math.log10(r)),
    o = r / Math.pow(10, i),
    a = o >= pw ? 10 : o >= vw ? 5 : o >= gw ? 2 : 1
  let s, l, c
  return (
    i < 0
      ? ((c = Math.pow(10, -i) / a),
        (s = Math.round(e * c)),
        (l = Math.round(t * c)),
        s / c < e && ++s,
        l / c > t && --l,
        (c = -c))
      : ((c = Math.pow(10, i) * a),
        (s = Math.round(e / c)),
        (l = Math.round(t / c)),
        s * c < e && ++s,
        l * c > t && --l),
    l < s && 0.5 <= n && n < 2 ? Ti(e, t, n * 2) : [s, l, c]
  )
}
function Ia(e, t, n) {
  if (((t = +t), (e = +e), (n = +n), !(n > 0))) return []
  if (e === t) return [e]
  const r = t < e,
    [i, o, a] = r ? Ti(t, e, n) : Ti(e, t, n)
  if (!(o >= i)) return []
  const s = o - i + 1,
    l = new Array(s)
  if (r)
    if (a < 0) for (let c = 0; c < s; ++c) l[c] = (o - c) / -a
    else for (let c = 0; c < s; ++c) l[c] = (o - c) * a
  else if (a < 0) for (let c = 0; c < s; ++c) l[c] = (i + c) / -a
  else for (let c = 0; c < s; ++c) l[c] = (i + c) * a
  return l
}
function ja(e, t, n) {
  return ((t = +t), (e = +e), (n = +n), Ti(e, t, n)[2])
}
function $a(e, t, n) {
  ;((t = +t), (e = +e), (n = +n))
  const r = t < e,
    i = r ? ja(t, e, n) : ja(e, t, n)
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i)
}
function Ll(e, t) {
  let n
  for (const r of e) r != null && (n < r || (n === void 0 && r >= r)) && (n = r)
  return n
}
function zl(e, t) {
  let n
  for (const r of e) r != null && (n > r || (n === void 0 && r >= r)) && (n = r)
  return n
}
function nh(e, t, n = 0, r = 1 / 0, i) {
  if (
    ((t = Math.floor(t)),
    (n = Math.floor(Math.max(0, n))),
    (r = Math.floor(Math.min(e.length - 1, r))),
    !(n <= t && t <= r))
  )
    return e
  for (i = i === void 0 ? th : hw(i); r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1,
        c = t - n + 1,
        u = Math.log(l),
        f = 0.5 * Math.exp((2 * u) / 3),
        d = 0.5 * Math.sqrt((u * f * (l - f)) / l) * (c - l / 2 < 0 ? -1 : 1),
        h = Math.max(n, Math.floor(t - (c * f) / l + d)),
        g = Math.min(r, Math.floor(t + ((l - c) * f) / l + d))
      nh(e, t, h, g, i)
    }
    const o = e[t]
    let a = n,
      s = r
    for (Gn(e, n, t), i(e[r], o) > 0 && Gn(e, n, r); a < s; ) {
      for (Gn(e, a, s), ++a, --s; i(e[a], o) < 0; ) ++a
      for (; i(e[s], o) > 0; ) --s
    }
    ;(i(e[n], o) === 0 ? Gn(e, n, s) : (++s, Gn(e, s, r)),
      s <= t && (n = s + 1),
      t <= s && (r = s - 1))
  }
  return e
}
function Gn(e, t, n) {
  const r = e[t]
  ;((e[t] = e[n]), (e[n] = r))
}
function mw(e, t, n) {
  if (((e = Float64Array.from(fw(e))), !(!(r = e.length) || isNaN((t = +t))))) {
    if (t <= 0 || r < 2) return zl(e)
    if (t >= 1) return Ll(e)
    var r,
      i = (r - 1) * t,
      o = Math.floor(i),
      a = Ll(nh(e, o).subarray(0, o + 1)),
      s = zl(e.subarray(o + 1))
    return a + (s - a) * (i - o)
  }
}
function yw(e, t, n = eh) {
  if (!(!(r = e.length) || isNaN((t = +t)))) {
    if (t <= 0 || r < 2) return +n(e[0], 0, e)
    if (t >= 1) return +n(e[r - 1], r - 1, e)
    var r,
      i = (r - 1) * t,
      o = Math.floor(i),
      a = +n(e[o], o, e),
      s = +n(e[o + 1], o + 1, e)
    return a + (s - a) * (i - o)
  }
}
function xw(e, t, n) {
  ;((e = +e), (t = +t), (n = (i = arguments.length) < 2 ? ((t = e), (e = 0), 1) : i < 3 ? 1 : +n))
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e + r * n
  return o
}
function tt(e, t) {
  switch (arguments.length) {
    case 0:
      break
    case 1:
      this.range(e)
      break
    default:
      this.range(t).domain(e)
      break
  }
  return this
}
function Mt(e, t) {
  switch (arguments.length) {
    case 0:
      break
    case 1: {
      typeof e == 'function' ? this.interpolator(e) : this.range(e)
      break
    }
    default: {
      ;(this.domain(e), typeof t == 'function' ? this.interpolator(t) : this.range(t))
      break
    }
  }
  return this
}
const Rl = Symbol('implicit')
function rh() {
  var e = new Jc(),
    t = [],
    n = [],
    r = Rl
  function i(o) {
    let a = e.get(o)
    if (a === void 0) {
      if (r !== Rl) return r
      e.set(o, (a = t.push(o) - 1))
    }
    return n[a % n.length]
  }
  return (
    (i.domain = function (o) {
      if (!arguments.length) return t.slice()
      ;((t = []), (e = new Jc()))
      for (const a of o) e.has(a) || e.set(a, t.push(a) - 1)
      return i
    }),
    (i.range = function (o) {
      return arguments.length ? ((n = Array.from(o)), i) : n.slice()
    }),
    (i.unknown = function (o) {
      return arguments.length ? ((r = o), i) : r
    }),
    (i.copy = function () {
      return rh(t, n).unknown(r)
    }),
    tt.apply(i, arguments),
    i
  )
}
function ih() {
  var e = rh().unknown(void 0),
    t = e.domain,
    n = e.range,
    r = 0,
    i = 1,
    o,
    a,
    s = !1,
    l = 0,
    c = 0,
    u = 0.5
  delete e.unknown
  function f() {
    var d = t().length,
      h = i < r,
      g = h ? i : r,
      p = h ? r : i
    ;((o = (p - g) / Math.max(1, d - l + c * 2)),
      s && (o = Math.floor(o)),
      (g += (p - g - o * (d - l)) * u),
      (a = o * (1 - l)),
      s && ((g = Math.round(g)), (a = Math.round(a))))
    var x = xw(d).map(function (y) {
      return g + o * y
    })
    return n(h ? x.reverse() : x)
  }
  return (
    (e.domain = function (d) {
      return arguments.length ? (t(d), f()) : t()
    }),
    (e.range = function (d) {
      return arguments.length ? (([r, i] = d), (r = +r), (i = +i), f()) : [r, i]
    }),
    (e.rangeRound = function (d) {
      return (([r, i] = d), (r = +r), (i = +i), (s = !0), f())
    }),
    (e.bandwidth = function () {
      return a
    }),
    (e.step = function () {
      return o
    }),
    (e.round = function (d) {
      return arguments.length ? ((s = !!d), f()) : s
    }),
    (e.padding = function (d) {
      return arguments.length ? ((l = Math.min(1, (c = +d))), f()) : l
    }),
    (e.paddingInner = function (d) {
      return arguments.length ? ((l = Math.min(1, d)), f()) : l
    }),
    (e.paddingOuter = function (d) {
      return arguments.length ? ((c = +d), f()) : c
    }),
    (e.align = function (d) {
      return arguments.length ? ((u = Math.max(0, Math.min(1, d))), f()) : u
    }),
    (e.copy = function () {
      return ih(t(), [r, i]).round(s).paddingInner(l).paddingOuter(c).align(u)
    }),
    tt.apply(f(), arguments)
  )
}
function oh(e) {
  var t = e.copy
  return (
    (e.padding = e.paddingOuter),
    delete e.paddingInner,
    delete e.paddingOuter,
    (e.copy = function () {
      return oh(t())
    }),
    e
  )
}
function g$() {
  return oh(ih.apply(null, arguments).paddingInner(1))
}
function ks(e, t, n) {
  ;((e.prototype = t.prototype = n), (n.constructor = e))
}
function ah(e, t) {
  var n = Object.create(e.prototype)
  for (var r in t) n[r] = t[r]
  return n
}
function kr() {}
var ur = 0.7,
  Ni = 1 / ur,
  xn = '\\s*([+-]?\\d+)\\s*',
  fr = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
  ut = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
  bw = /^#([0-9a-f]{3,8})$/,
  ww = new RegExp(`^rgb\\(${xn},${xn},${xn}\\)$`),
  Pw = new RegExp(`^rgb\\(${ut},${ut},${ut}\\)$`),
  Sw = new RegExp(`^rgba\\(${xn},${xn},${xn},${fr}\\)$`),
  Ew = new RegExp(`^rgba\\(${ut},${ut},${ut},${fr}\\)$`),
  _w = new RegExp(`^hsl\\(${fr},${ut},${ut}\\)$`),
  Aw = new RegExp(`^hsla\\(${fr},${ut},${ut},${fr}\\)$`),
  Bl = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  }
ks(kr, tn, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e)
  },
  displayable() {
    return this.rgb().displayable()
  },
  hex: Hl,
  formatHex: Hl,
  formatHex8: Ow,
  formatHsl: Cw,
  formatRgb: Fl,
  toString: Fl,
})
function Hl() {
  return this.rgb().formatHex()
}
function Ow() {
  return this.rgb().formatHex8()
}
function Cw() {
  return sh(this).formatHsl()
}
function Fl() {
  return this.rgb().formatRgb()
}
function tn(e) {
  var t, n
  return (
    (e = (e + '').trim().toLowerCase()),
    (t = bw.exec(e))
      ? ((n = t[1].length),
        (t = parseInt(t[1], 16)),
        n === 6
          ? Vl(t)
          : n === 3
            ? new $e(
                ((t >> 8) & 15) | ((t >> 4) & 240),
                ((t >> 4) & 15) | (t & 240),
                ((t & 15) << 4) | (t & 15),
                1,
              )
            : n === 8
              ? ei((t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, (t & 255) / 255)
              : n === 4
                ? ei(
                    ((t >> 12) & 15) | ((t >> 8) & 240),
                    ((t >> 8) & 15) | ((t >> 4) & 240),
                    ((t >> 4) & 15) | (t & 240),
                    (((t & 15) << 4) | (t & 15)) / 255,
                  )
                : null)
      : (t = ww.exec(e))
        ? new $e(t[1], t[2], t[3], 1)
        : (t = Pw.exec(e))
          ? new $e((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, 1)
          : (t = Sw.exec(e))
            ? ei(t[1], t[2], t[3], t[4])
            : (t = Ew.exec(e))
              ? ei((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, t[4])
              : (t = _w.exec(e))
                ? Yl(t[1], t[2] / 100, t[3] / 100, 1)
                : (t = Aw.exec(e))
                  ? Yl(t[1], t[2] / 100, t[3] / 100, t[4])
                  : Bl.hasOwnProperty(e)
                    ? Vl(Bl[e])
                    : e === 'transparent'
                      ? new $e(NaN, NaN, NaN, 0)
                      : null
  )
}
function Vl(e) {
  return new $e((e >> 16) & 255, (e >> 8) & 255, e & 255, 1)
}
function ei(e, t, n, r) {
  return (r <= 0 && (e = t = n = NaN), new $e(e, t, n, r))
}
function kw(e) {
  return (
    e instanceof kr || (e = tn(e)),
    e ? ((e = e.rgb()), new $e(e.r, e.g, e.b, e.opacity)) : new $e()
  )
}
function La(e, t, n, r) {
  return arguments.length === 1 ? kw(e) : new $e(e, t, n, r ?? 1)
}
function $e(e, t, n, r) {
  ;((this.r = +e), (this.g = +t), (this.b = +n), (this.opacity = +r))
}
ks(
  $e,
  La,
  ah(kr, {
    brighter(e) {
      return (
        (e = e == null ? Ni : Math.pow(Ni, e)),
        new $e(this.r * e, this.g * e, this.b * e, this.opacity)
      )
    },
    darker(e) {
      return (
        (e = e == null ? ur : Math.pow(ur, e)),
        new $e(this.r * e, this.g * e, this.b * e, this.opacity)
      )
    },
    rgb() {
      return this
    },
    clamp() {
      return new $e(Jt(this.r), Jt(this.g), Jt(this.b), Di(this.opacity))
    },
    displayable() {
      return (
        -0.5 <= this.r &&
        this.r < 255.5 &&
        -0.5 <= this.g &&
        this.g < 255.5 &&
        -0.5 <= this.b &&
        this.b < 255.5 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    hex: Wl,
    formatHex: Wl,
    formatHex8: Mw,
    formatRgb: Kl,
    toString: Kl,
  }),
)
function Wl() {
  return `#${qt(this.r)}${qt(this.g)}${qt(this.b)}`
}
function Mw() {
  return `#${qt(this.r)}${qt(this.g)}${qt(this.b)}${qt((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
}
function Kl() {
  const e = Di(this.opacity)
  return `${e === 1 ? 'rgb(' : 'rgba('}${Jt(this.r)}, ${Jt(this.g)}, ${Jt(this.b)}${e === 1 ? ')' : `, ${e})`}`
}
function Di(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
}
function Jt(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0))
}
function qt(e) {
  return ((e = Jt(e)), (e < 16 ? '0' : '') + e.toString(16))
}
function Yl(e, t, n, r) {
  return (
    r <= 0 ? (e = t = n = NaN) : n <= 0 || n >= 1 ? (e = t = NaN) : t <= 0 && (e = NaN),
    new it(e, t, n, r)
  )
}
function sh(e) {
  if (e instanceof it) return new it(e.h, e.s, e.l, e.opacity)
  if ((e instanceof kr || (e = tn(e)), !e)) return new it()
  if (e instanceof it) return e
  e = e.rgb()
  var t = e.r / 255,
    n = e.g / 255,
    r = e.b / 255,
    i = Math.min(t, n, r),
    o = Math.max(t, n, r),
    a = NaN,
    s = o - i,
    l = (o + i) / 2
  return (
    s
      ? (t === o
          ? (a = (n - r) / s + (n < r) * 6)
          : n === o
            ? (a = (r - t) / s + 2)
            : (a = (t - n) / s + 4),
        (s /= l < 0.5 ? o + i : 2 - o - i),
        (a *= 60))
      : (s = l > 0 && l < 1 ? 0 : a),
    new it(a, s, l, e.opacity)
  )
}
function Tw(e, t, n, r) {
  return arguments.length === 1 ? sh(e) : new it(e, t, n, r ?? 1)
}
function it(e, t, n, r) {
  ;((this.h = +e), (this.s = +t), (this.l = +n), (this.opacity = +r))
}
ks(
  it,
  Tw,
  ah(kr, {
    brighter(e) {
      return (
        (e = e == null ? Ni : Math.pow(Ni, e)),
        new it(this.h, this.s, this.l * e, this.opacity)
      )
    },
    darker(e) {
      return (
        (e = e == null ? ur : Math.pow(ur, e)),
        new it(this.h, this.s, this.l * e, this.opacity)
      )
    },
    rgb() {
      var e = (this.h % 360) + (this.h < 0) * 360,
        t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
        n = this.l,
        r = n + (n < 0.5 ? n : 1 - n) * t,
        i = 2 * n - r
      return new $e(
        ea(e >= 240 ? e - 240 : e + 120, i, r),
        ea(e, i, r),
        ea(e < 120 ? e + 240 : e - 120, i, r),
        this.opacity,
      )
    },
    clamp() {
      return new it(Ul(this.h), ti(this.s), ti(this.l), Di(this.opacity))
    },
    displayable() {
      return (
        ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
        0 <= this.l &&
        this.l <= 1 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    formatHsl() {
      const e = Di(this.opacity)
      return `${e === 1 ? 'hsl(' : 'hsla('}${Ul(this.h)}, ${ti(this.s) * 100}%, ${ti(this.l) * 100}%${e === 1 ? ')' : `, ${e})`}`
    },
  }),
)
function Ul(e) {
  return ((e = (e || 0) % 360), e < 0 ? e + 360 : e)
}
function ti(e) {
  return Math.max(0, Math.min(1, e || 0))
}
function ea(e, t, n) {
  return (
    (e < 60 ? t + ((n - t) * e) / 60 : e < 180 ? n : e < 240 ? t + ((n - t) * (240 - e)) / 60 : t) *
    255
  )
}
const Ms = (e) => () => e
function Nw(e, t) {
  return function (n) {
    return e + n * t
  }
}
function Dw(e, t, n) {
  return (
    (e = Math.pow(e, n)),
    (t = Math.pow(t, n) - e),
    (n = 1 / n),
    function (r) {
      return Math.pow(e + r * t, n)
    }
  )
}
function Iw(e) {
  return (e = +e) == 1
    ? ch
    : function (t, n) {
        return n - t ? Dw(t, n, e) : Ms(isNaN(t) ? n : t)
      }
}
function ch(e, t) {
  var n = t - e
  return n ? Nw(e, n) : Ms(isNaN(e) ? t : e)
}
const Ii = (function e(t) {
  var n = Iw(t)
  function r(i, o) {
    var a = n((i = La(i)).r, (o = La(o)).r),
      s = n(i.g, o.g),
      l = n(i.b, o.b),
      c = ch(i.opacity, o.opacity)
    return function (u) {
      return ((i.r = a(u)), (i.g = s(u)), (i.b = l(u)), (i.opacity = c(u)), i + '')
    }
  }
  return ((r.gamma = e), r)
})(1)
function jw(e, t) {
  t || (t = [])
  var n = e ? Math.min(t.length, e.length) : 0,
    r = t.slice(),
    i
  return function (o) {
    for (i = 0; i < n; ++i) r[i] = e[i] * (1 - o) + t[i] * o
    return r
  }
}
function $w(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView)
}
function Lw(e, t) {
  var n = t ? t.length : 0,
    r = e ? Math.min(n, e.length) : 0,
    i = new Array(r),
    o = new Array(n),
    a
  for (a = 0; a < r; ++a) i[a] = Pt(e[a], t[a])
  for (; a < n; ++a) o[a] = t[a]
  return function (s) {
    for (a = 0; a < r; ++a) o[a] = i[a](s)
    return o
  }
}
function zw(e, t) {
  var n = new Date()
  return (
    (e = +e),
    (t = +t),
    function (r) {
      return (n.setTime(e * (1 - r) + t * r), n)
    }
  )
}
function rt(e, t) {
  return (
    (e = +e),
    (t = +t),
    function (n) {
      return e * (1 - n) + t * n
    }
  )
}
function Rw(e, t) {
  var n = {},
    r = {},
    i
  ;((e === null || typeof e != 'object') && (e = {}),
    (t === null || typeof t != 'object') && (t = {}))
  for (i in t) i in e ? (n[i] = Pt(e[i], t[i])) : (r[i] = t[i])
  return function (o) {
    for (i in n) r[i] = n[i](o)
    return r
  }
}
var za = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  ta = new RegExp(za.source, 'g')
function Bw(e) {
  return function () {
    return e
  }
}
function Hw(e) {
  return function (t) {
    return e(t) + ''
  }
}
function lh(e, t) {
  var n = (za.lastIndex = ta.lastIndex = 0),
    r,
    i,
    o,
    a = -1,
    s = [],
    l = []
  for (e = e + '', t = t + ''; (r = za.exec(e)) && (i = ta.exec(t)); )
    ((o = i.index) > n && ((o = t.slice(n, o)), s[a] ? (s[a] += o) : (s[++a] = o)),
      (r = r[0]) === (i = i[0])
        ? s[a]
          ? (s[a] += i)
          : (s[++a] = i)
        : ((s[++a] = null), l.push({ i: a, x: rt(r, i) })),
      (n = ta.lastIndex))
  return (
    n < t.length && ((o = t.slice(n)), s[a] ? (s[a] += o) : (s[++a] = o)),
    s.length < 2
      ? l[0]
        ? Hw(l[0].x)
        : Bw(t)
      : ((t = l.length),
        function (c) {
          for (var u = 0, f; u < t; ++u) s[(f = l[u]).i] = f.x(c)
          return s.join('')
        })
  )
}
function Pt(e, t) {
  var n = typeof t,
    r
  return t == null || n === 'boolean'
    ? Ms(t)
    : (n === 'number'
        ? rt
        : n === 'string'
          ? (r = tn(t))
            ? ((t = r), Ii)
            : lh
          : t instanceof tn
            ? Ii
            : t instanceof Date
              ? zw
              : $w(t)
                ? jw
                : Array.isArray(t)
                  ? Lw
                  : (typeof t.valueOf != 'function' && typeof t.toString != 'function') || isNaN(t)
                    ? Rw
                    : rt)(e, t)
}
function Ts(e, t) {
  return (
    (e = +e),
    (t = +t),
    function (n) {
      return Math.round(e * (1 - n) + t * n)
    }
  )
}
var Xl = 180 / Math.PI,
  Ra = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }
function uh(e, t, n, r, i, o) {
  var a, s, l
  return (
    (a = Math.sqrt(e * e + t * t)) && ((e /= a), (t /= a)),
    (l = e * n + t * r) && ((n -= e * l), (r -= t * l)),
    (s = Math.sqrt(n * n + r * r)) && ((n /= s), (r /= s), (l /= s)),
    e * r < t * n && ((e = -e), (t = -t), (l = -l), (a = -a)),
    {
      translateX: i,
      translateY: o,
      rotate: Math.atan2(t, e) * Xl,
      skewX: Math.atan(l) * Xl,
      scaleX: a,
      scaleY: s,
    }
  )
}
var ni
function Fw(e) {
  const t = new (typeof DOMMatrix == 'function' ? DOMMatrix : WebKitCSSMatrix)(e + '')
  return t.isIdentity ? Ra : uh(t.a, t.b, t.c, t.d, t.e, t.f)
}
function Vw(e) {
  return e == null ||
    (ni || (ni = document.createElementNS('http://www.w3.org/2000/svg', 'g')),
    ni.setAttribute('transform', e),
    !(e = ni.transform.baseVal.consolidate()))
    ? Ra
    : ((e = e.matrix), uh(e.a, e.b, e.c, e.d, e.e, e.f))
}
function fh(e, t, n, r) {
  function i(c) {
    return c.length ? c.pop() + ' ' : ''
  }
  function o(c, u, f, d, h, g) {
    if (c !== f || u !== d) {
      var p = h.push('translate(', null, t, null, n)
      g.push({ i: p - 4, x: rt(c, f) }, { i: p - 2, x: rt(u, d) })
    } else (f || d) && h.push('translate(' + f + t + d + n)
  }
  function a(c, u, f, d) {
    c !== u
      ? (c - u > 180 ? (u += 360) : u - c > 180 && (c += 360),
        d.push({ i: f.push(i(f) + 'rotate(', null, r) - 2, x: rt(c, u) }))
      : u && f.push(i(f) + 'rotate(' + u + r)
  }
  function s(c, u, f, d) {
    c !== u
      ? d.push({ i: f.push(i(f) + 'skewX(', null, r) - 2, x: rt(c, u) })
      : u && f.push(i(f) + 'skewX(' + u + r)
  }
  function l(c, u, f, d, h, g) {
    if (c !== f || u !== d) {
      var p = h.push(i(h) + 'scale(', null, ',', null, ')')
      g.push({ i: p - 4, x: rt(c, f) }, { i: p - 2, x: rt(u, d) })
    } else (f !== 1 || d !== 1) && h.push(i(h) + 'scale(' + f + ',' + d + ')')
  }
  return function (c, u) {
    var f = [],
      d = []
    return (
      (c = e(c)),
      (u = e(u)),
      o(c.translateX, c.translateY, u.translateX, u.translateY, f, d),
      a(c.rotate, u.rotate, f, d),
      s(c.skewX, u.skewX, f, d),
      l(c.scaleX, c.scaleY, u.scaleX, u.scaleY, f, d),
      (c = u = null),
      function (h) {
        for (var g = -1, p = d.length, x; ++g < p; ) f[(x = d[g]).i] = x.x(h)
        return f.join('')
      }
    )
  }
}
var Ww = fh(Fw, 'px, ', 'px)', 'deg)'),
  Kw = fh(Vw, ', ', ')', ')'),
  Yw = 1e-12
function Gl(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2
}
function Uw(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2
}
function Xw(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1)
}
const hi = (function e(t, n, r) {
  function i(o, a) {
    var s = o[0],
      l = o[1],
      c = o[2],
      u = a[0],
      f = a[1],
      d = a[2],
      h = u - s,
      g = f - l,
      p = h * h + g * g,
      x,
      y
    if (p < Yw)
      ((y = Math.log(d / c) / t),
        (x = function (_) {
          return [s + _ * h, l + _ * g, c * Math.exp(t * _ * y)]
        }))
    else {
      var w = Math.sqrt(p),
        m = (d * d - c * c + r * p) / (2 * c * n * w),
        b = (d * d - c * c - r * p) / (2 * d * n * w),
        P = Math.log(Math.sqrt(m * m + 1) - m),
        S = Math.log(Math.sqrt(b * b + 1) - b)
      ;((y = (S - P) / t),
        (x = function (_) {
          var M = _ * y,
            T = Gl(P),
            F = (c / (n * w)) * (T * Xw(t * M + P) - Uw(P))
          return [s + F * h, l + F * g, (c * T) / Gl(t * M + P)]
        }))
    }
    return ((x.duration = (y * 1e3 * t) / Math.SQRT2), x)
  }
  return (
    (i.rho = function (o) {
      var a = Math.max(0.001, +o),
        s = a * a,
        l = s * s
      return e(a, s, l)
    }),
    i
  )
})(Math.SQRT2, 2, 4)
function Gw(e, t) {
  t === void 0 && ((t = e), (e = Pt))
  for (var n = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); n < r; )
    o[n] = e(i, (i = t[++n]))
  return function (a) {
    var s = Math.max(0, Math.min(r - 1, Math.floor((a *= r))))
    return o[s](a - s)
  }
}
function qw(e) {
  return function () {
    return e
  }
}
function ji(e) {
  return +e
}
var ql = [0, 1]
function De(e) {
  return e
}
function Ba(e, t) {
  return (t -= e = +e)
    ? function (n) {
        return (n - e) / t
      }
    : qw(isNaN(t) ? NaN : 0.5)
}
function Zw(e, t) {
  var n
  return (
    e > t && ((n = e), (e = t), (t = n)),
    function (r) {
      return Math.max(e, Math.min(t, r))
    }
  )
}
function Qw(e, t, n) {
  var r = e[0],
    i = e[1],
    o = t[0],
    a = t[1]
  return (
    i < r ? ((r = Ba(i, r)), (o = n(a, o))) : ((r = Ba(r, i)), (o = n(o, a))),
    function (s) {
      return o(r(s))
    }
  )
}
function Jw(e, t, n) {
  var r = Math.min(e.length, t.length) - 1,
    i = new Array(r),
    o = new Array(r),
    a = -1
  for (e[r] < e[0] && ((e = e.slice().reverse()), (t = t.slice().reverse())); ++a < r; )
    ((i[a] = Ba(e[a], e[a + 1])), (o[a] = n(t[a], t[a + 1])))
  return function (s) {
    var l = Cr(e, s, 1, r) - 1
    return o[l](i[l](s))
  }
}
function Mr(e, t) {
  return t
    .domain(e.domain())
    .range(e.range())
    .interpolate(e.interpolate())
    .clamp(e.clamp())
    .unknown(e.unknown())
}
function yo() {
  var e = ql,
    t = ql,
    n = Pt,
    r,
    i,
    o,
    a = De,
    s,
    l,
    c
  function u() {
    var d = Math.min(e.length, t.length)
    return (a !== De && (a = Zw(e[0], e[d - 1])), (s = d > 2 ? Jw : Qw), (l = c = null), f)
  }
  function f(d) {
    return d == null || isNaN((d = +d)) ? o : (l || (l = s(e.map(r), t, n)))(r(a(d)))
  }
  return (
    (f.invert = function (d) {
      return a(i((c || (c = s(t, e.map(r), rt)))(d)))
    }),
    (f.domain = function (d) {
      return arguments.length ? ((e = Array.from(d, ji)), u()) : e.slice()
    }),
    (f.range = function (d) {
      return arguments.length ? ((t = Array.from(d)), u()) : t.slice()
    }),
    (f.rangeRound = function (d) {
      return ((t = Array.from(d)), (n = Ts), u())
    }),
    (f.clamp = function (d) {
      return arguments.length ? ((a = d ? !0 : De), u()) : a !== De
    }),
    (f.interpolate = function (d) {
      return arguments.length ? ((n = d), u()) : n
    }),
    (f.unknown = function (d) {
      return arguments.length ? ((o = d), f) : o
    }),
    function (d, h) {
      return ((r = d), (i = h), u())
    }
  )
}
function Ns() {
  return yo()(De, De)
}
function e1(e) {
  return Math.abs((e = Math.round(e))) >= 1e21
    ? e.toLocaleString('en').replace(/,/g, '')
    : e.toString(10)
}
function $i(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf('e')) < 0) return null
  var n,
    r = e.slice(0, n)
  return [r.length > 1 ? r[0] + r.slice(2) : r, +e.slice(n + 1)]
}
function En(e) {
  return ((e = $i(Math.abs(e))), e ? e[1] : NaN)
}
function t1(e, t) {
  return function (n, r) {
    for (
      var i = n.length, o = [], a = 0, s = e[0], l = 0;
      i > 0 &&
      s > 0 &&
      (l + s + 1 > r && (s = Math.max(1, r - l)),
      o.push(n.substring((i -= s), i + s)),
      !((l += s + 1) > r));

    )
      s = e[(a = (a + 1) % e.length)]
    return o.reverse().join(t)
  }
}
function n1(e) {
  return function (t) {
    return t.replace(/[0-9]/g, function (n) {
      return e[+n]
    })
  }
}
var r1 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i
function dr(e) {
  if (!(t = r1.exec(e))) throw new Error('invalid format: ' + e)
  var t
  return new Ds({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10],
  })
}
dr.prototype = Ds.prototype
function Ds(e) {
  ;((this.fill = e.fill === void 0 ? ' ' : e.fill + ''),
    (this.align = e.align === void 0 ? '>' : e.align + ''),
    (this.sign = e.sign === void 0 ? '-' : e.sign + ''),
    (this.symbol = e.symbol === void 0 ? '' : e.symbol + ''),
    (this.zero = !!e.zero),
    (this.width = e.width === void 0 ? void 0 : +e.width),
    (this.comma = !!e.comma),
    (this.precision = e.precision === void 0 ? void 0 : +e.precision),
    (this.trim = !!e.trim),
    (this.type = e.type === void 0 ? '' : e.type + ''))
}
Ds.prototype.toString = function () {
  return (
    this.fill +
    this.align +
    this.sign +
    this.symbol +
    (this.zero ? '0' : '') +
    (this.width === void 0 ? '' : Math.max(1, this.width | 0)) +
    (this.comma ? ',' : '') +
    (this.precision === void 0 ? '' : '.' + Math.max(0, this.precision | 0)) +
    (this.trim ? '~' : '') +
    this.type
  )
}
function i1(e) {
  e: for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
    switch (e[n]) {
      case '.':
        r = i = n
        break
      case '0':
        ;(r === 0 && (r = n), (i = n))
        break
      default:
        if (!+e[n]) break e
        r > 0 && (r = 0)
        break
    }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e
}
var dh
function o1(e, t) {
  var n = $i(e, t)
  if (!n) return e + ''
  var r = n[0],
    i = n[1],
    o = i - (dh = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1,
    a = r.length
  return o === a
    ? r
    : o > a
      ? r + new Array(o - a + 1).join('0')
      : o > 0
        ? r.slice(0, o) + '.' + r.slice(o)
        : '0.' + new Array(1 - o).join('0') + $i(e, Math.max(0, t + o - 1))[0]
}
function Zl(e, t) {
  var n = $i(e, t)
  if (!n) return e + ''
  var r = n[0],
    i = n[1]
  return i < 0
    ? '0.' + new Array(-i).join('0') + r
    : r.length > i + 1
      ? r.slice(0, i + 1) + '.' + r.slice(i + 1)
      : r + new Array(i - r.length + 2).join('0')
}
const Ql = {
  '%': (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + '',
  d: e1,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => Zl(e * 100, t),
  r: Zl,
  s: o1,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16),
}
function Jl(e) {
  return e
}
var eu = Array.prototype.map,
  tu = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']
function a1(e) {
  var t =
      e.grouping === void 0 || e.thousands === void 0
        ? Jl
        : t1(eu.call(e.grouping, Number), e.thousands + ''),
    n = e.currency === void 0 ? '' : e.currency[0] + '',
    r = e.currency === void 0 ? '' : e.currency[1] + '',
    i = e.decimal === void 0 ? '.' : e.decimal + '',
    o = e.numerals === void 0 ? Jl : n1(eu.call(e.numerals, String)),
    a = e.percent === void 0 ? '%' : e.percent + '',
    s = e.minus === void 0 ? '' : e.minus + '',
    l = e.nan === void 0 ? 'NaN' : e.nan + ''
  function c(f) {
    f = dr(f)
    var d = f.fill,
      h = f.align,
      g = f.sign,
      p = f.symbol,
      x = f.zero,
      y = f.width,
      w = f.comma,
      m = f.precision,
      b = f.trim,
      P = f.type
    ;(P === 'n' ? ((w = !0), (P = 'g')) : Ql[P] || (m === void 0 && (m = 12), (b = !0), (P = 'g')),
      (x || (d === '0' && h === '=')) && ((x = !0), (d = '0'), (h = '=')))
    var S = p === '$' ? n : p === '#' && /[boxX]/.test(P) ? '0' + P.toLowerCase() : '',
      _ = p === '$' ? r : /[%p]/.test(P) ? a : '',
      M = Ql[P],
      T = /[defgprs%]/.test(P)
    m =
      m === void 0
        ? 6
        : /[gprs]/.test(P)
          ? Math.max(1, Math.min(21, m))
          : Math.max(0, Math.min(20, m))
    function F(D) {
      var k = S,
        $ = _,
        E,
        O,
        A
      if (P === 'c') (($ = M(D) + $), (D = ''))
      else {
        D = +D
        var C = D < 0 || 1 / D < 0
        if (
          ((D = isNaN(D) ? l : M(Math.abs(D), m)),
          b && (D = i1(D)),
          C && +D == 0 && g !== '+' && (C = !1),
          (k = (C ? (g === '(' ? g : s) : g === '-' || g === '(' ? '' : g) + k),
          ($ = (P === 's' ? tu[8 + dh / 3] : '') + $ + (C && g === '(' ? ')' : '')),
          T)
        ) {
          for (E = -1, O = D.length; ++E < O; )
            if (((A = D.charCodeAt(E)), 48 > A || A > 57)) {
              ;(($ = (A === 46 ? i + D.slice(E + 1) : D.slice(E)) + $), (D = D.slice(0, E)))
              break
            }
        }
      }
      w && !x && (D = t(D, 1 / 0))
      var N = k.length + D.length + $.length,
        I = N < y ? new Array(y - N + 1).join(d) : ''
      switch ((w && x && ((D = t(I + D, I.length ? y - $.length : 1 / 0)), (I = '')), h)) {
        case '<':
          D = k + D + $ + I
          break
        case '=':
          D = k + I + D + $
          break
        case '^':
          D = I.slice(0, (N = I.length >> 1)) + k + D + $ + I.slice(N)
          break
        default:
          D = I + k + D + $
          break
      }
      return o(D)
    }
    return (
      (F.toString = function () {
        return f + ''
      }),
      F
    )
  }
  function u(f, d) {
    var h = c(((f = dr(f)), (f.type = 'f'), f)),
      g = Math.max(-8, Math.min(8, Math.floor(En(d) / 3))) * 3,
      p = Math.pow(10, -g),
      x = tu[8 + g / 3]
    return function (y) {
      return h(p * y) + x
    }
  }
  return { format: c, formatPrefix: u }
}
var ri, Is, hh
s1({ thousands: ',', grouping: [3], currency: ['$', ''] })
function s1(e) {
  return ((ri = a1(e)), (Is = ri.format), (hh = ri.formatPrefix), ri)
}
function c1(e) {
  return Math.max(0, -En(Math.abs(e)))
}
function l1(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(En(t) / 3))) * 3 - En(Math.abs(e)))
}
function u1(e, t) {
  return ((e = Math.abs(e)), (t = Math.abs(t) - e), Math.max(0, En(t) - En(e)) + 1)
}
function f1(e, t, n, r) {
  var i = $a(e, t, n),
    o
  switch (((r = dr(r ?? ',f')), r.type)) {
    case 's': {
      var a = Math.max(Math.abs(e), Math.abs(t))
      return (r.precision == null && !isNaN((o = l1(i, a))) && (r.precision = o), hh(r, a))
    }
    case '':
    case 'e':
    case 'g':
    case 'p':
    case 'r': {
      r.precision == null &&
        !isNaN((o = u1(i, Math.max(Math.abs(e), Math.abs(t))))) &&
        (r.precision = o - (r.type === 'e'))
      break
    }
    case 'f':
    case '%': {
      r.precision == null && !isNaN((o = c1(i))) && (r.precision = o - (r.type === '%') * 2)
      break
    }
  }
  return Is(r)
}
function Kt(e) {
  var t = e.domain
  return (
    (e.ticks = function (n) {
      var r = t()
      return Ia(r[0], r[r.length - 1], n ?? 10)
    }),
    (e.tickFormat = function (n, r) {
      var i = t()
      return f1(i[0], i[i.length - 1], n ?? 10, r)
    }),
    (e.nice = function (n) {
      n == null && (n = 10)
      var r = t(),
        i = 0,
        o = r.length - 1,
        a = r[i],
        s = r[o],
        l,
        c,
        u = 10
      for (s < a && ((c = a), (a = s), (s = c), (c = i), (i = o), (o = c)); u-- > 0; ) {
        if (((c = ja(a, s, n)), c === l)) return ((r[i] = a), (r[o] = s), t(r))
        if (c > 0) ((a = Math.floor(a / c) * c), (s = Math.ceil(s / c) * c))
        else if (c < 0) ((a = Math.ceil(a * c) / c), (s = Math.floor(s * c) / c))
        else break
        l = c
      }
      return e
    }),
    e
  )
}
function d1() {
  var e = Ns()
  return (
    (e.copy = function () {
      return Mr(e, d1())
    }),
    tt.apply(e, arguments),
    Kt(e)
  )
}
function h1(e) {
  var t
  function n(r) {
    return r == null || isNaN((r = +r)) ? t : r
  }
  return (
    (n.invert = n),
    (n.domain = n.range =
      function (r) {
        return arguments.length ? ((e = Array.from(r, ji)), n) : e.slice()
      }),
    (n.unknown = function (r) {
      return arguments.length ? ((t = r), n) : t
    }),
    (n.copy = function () {
      return h1(e).unknown(t)
    }),
    (e = arguments.length ? Array.from(e, ji) : [0, 1]),
    Kt(n)
  )
}
function ph(e, t) {
  e = e.slice()
  var n = 0,
    r = e.length - 1,
    i = e[n],
    o = e[r],
    a
  return (
    o < i && ((a = n), (n = r), (r = a), (a = i), (i = o), (o = a)),
    (e[n] = t.floor(i)),
    (e[r] = t.ceil(o)),
    e
  )
}
function nu(e) {
  return Math.log(e)
}
function ru(e) {
  return Math.exp(e)
}
function p1(e) {
  return -Math.log(-e)
}
function v1(e) {
  return -Math.exp(-e)
}
function g1(e) {
  return isFinite(e) ? +('1e' + e) : e < 0 ? 0 : e
}
function m1(e) {
  return e === 10 ? g1 : e === Math.E ? Math.exp : (t) => Math.pow(e, t)
}
function y1(e) {
  return e === Math.E
    ? Math.log
    : (e === 10 && Math.log10) ||
        (e === 2 && Math.log2) ||
        ((e = Math.log(e)), (t) => Math.log(t) / e)
}
function iu(e) {
  return (t, n) => -e(-t, n)
}
function js(e) {
  const t = e(nu, ru),
    n = t.domain
  let r = 10,
    i,
    o
  function a() {
    return (
      (i = y1(r)),
      (o = m1(r)),
      n()[0] < 0 ? ((i = iu(i)), (o = iu(o)), e(p1, v1)) : e(nu, ru),
      t
    )
  }
  return (
    (t.base = function (s) {
      return arguments.length ? ((r = +s), a()) : r
    }),
    (t.domain = function (s) {
      return arguments.length ? (n(s), a()) : n()
    }),
    (t.ticks = (s) => {
      const l = n()
      let c = l[0],
        u = l[l.length - 1]
      const f = u < c
      f && ([c, u] = [u, c])
      let d = i(c),
        h = i(u),
        g,
        p
      const x = s == null ? 10 : +s
      let y = []
      if (!(r % 1) && h - d < x) {
        if (((d = Math.floor(d)), (h = Math.ceil(h)), c > 0)) {
          for (; d <= h; ++d)
            for (g = 1; g < r; ++g)
              if (((p = d < 0 ? g / o(-d) : g * o(d)), !(p < c))) {
                if (p > u) break
                y.push(p)
              }
        } else
          for (; d <= h; ++d)
            for (g = r - 1; g >= 1; --g)
              if (((p = d > 0 ? g / o(-d) : g * o(d)), !(p < c))) {
                if (p > u) break
                y.push(p)
              }
        y.length * 2 < x && (y = Ia(c, u, x))
      } else y = Ia(d, h, Math.min(h - d, x)).map(o)
      return f ? y.reverse() : y
    }),
    (t.tickFormat = (s, l) => {
      if (
        (s == null && (s = 10),
        l == null && (l = r === 10 ? 's' : ','),
        typeof l != 'function' &&
          (!(r % 1) && (l = dr(l)).precision == null && (l.trim = !0), (l = Is(l))),
        s === 1 / 0)
      )
        return l
      const c = Math.max(1, (r * s) / t.ticks().length)
      return (u) => {
        let f = u / o(Math.round(i(u)))
        return (f * r < r - 0.5 && (f *= r), f <= c ? l(u) : '')
      }
    }),
    (t.nice = () =>
      n(ph(n(), { floor: (s) => o(Math.floor(i(s))), ceil: (s) => o(Math.ceil(i(s))) }))),
    t
  )
}
function x1() {
  const e = js(yo()).domain([1, 10])
  return ((e.copy = () => Mr(e, x1()).base(e.base())), tt.apply(e, arguments), e)
}
function ou(e) {
  return function (t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e))
  }
}
function au(e) {
  return function (t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e
  }
}
function $s(e) {
  var t = 1,
    n = e(ou(t), au(t))
  return (
    (n.constant = function (r) {
      return arguments.length ? e(ou((t = +r)), au(t)) : t
    }),
    Kt(n)
  )
}
function b1() {
  var e = $s(yo())
  return (
    (e.copy = function () {
      return Mr(e, b1()).constant(e.constant())
    }),
    tt.apply(e, arguments)
  )
}
function su(e) {
  return function (t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e)
  }
}
function w1(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e)
}
function P1(e) {
  return e < 0 ? -e * e : e * e
}
function Ls(e) {
  var t = e(De, De),
    n = 1
  function r() {
    return n === 1 ? e(De, De) : n === 0.5 ? e(w1, P1) : e(su(n), su(1 / n))
  }
  return (
    (t.exponent = function (i) {
      return arguments.length ? ((n = +i), r()) : n
    }),
    Kt(t)
  )
}
function vh() {
  var e = Ls(yo())
  return (
    (e.copy = function () {
      return Mr(e, vh()).exponent(e.exponent())
    }),
    tt.apply(e, arguments),
    e
  )
}
function m$() {
  return vh.apply(null, arguments).exponent(0.5)
}
function cu(e) {
  return Math.sign(e) * e * e
}
function S1(e) {
  return Math.sign(e) * Math.sqrt(Math.abs(e))
}
function E1() {
  var e = Ns(),
    t = [0, 1],
    n = !1,
    r
  function i(o) {
    var a = S1(e(o))
    return isNaN(a) ? r : n ? Math.round(a) : a
  }
  return (
    (i.invert = function (o) {
      return e.invert(cu(o))
    }),
    (i.domain = function (o) {
      return arguments.length ? (e.domain(o), i) : e.domain()
    }),
    (i.range = function (o) {
      return arguments.length ? (e.range((t = Array.from(o, ji)).map(cu)), i) : t.slice()
    }),
    (i.rangeRound = function (o) {
      return i.range(o).round(!0)
    }),
    (i.round = function (o) {
      return arguments.length ? ((n = !!o), i) : n
    }),
    (i.clamp = function (o) {
      return arguments.length ? (e.clamp(o), i) : e.clamp()
    }),
    (i.unknown = function (o) {
      return arguments.length ? ((r = o), i) : r
    }),
    (i.copy = function () {
      return E1(e.domain(), t).round(n).clamp(e.clamp()).unknown(r)
    }),
    tt.apply(i, arguments),
    Kt(i)
  )
}
function _1() {
  var e = [],
    t = [],
    n = [],
    r
  function i() {
    var a = 0,
      s = Math.max(1, t.length)
    for (n = new Array(s - 1); ++a < s; ) n[a - 1] = yw(e, a / s)
    return o
  }
  function o(a) {
    return a == null || isNaN((a = +a)) ? r : t[Cr(n, a)]
  }
  return (
    (o.invertExtent = function (a) {
      var s = t.indexOf(a)
      return s < 0 ? [NaN, NaN] : [s > 0 ? n[s - 1] : e[0], s < n.length ? n[s] : e[e.length - 1]]
    }),
    (o.domain = function (a) {
      if (!arguments.length) return e.slice()
      e = []
      for (let s of a) s != null && !isNaN((s = +s)) && e.push(s)
      return (e.sort(Ft), i())
    }),
    (o.range = function (a) {
      return arguments.length ? ((t = Array.from(a)), i()) : t.slice()
    }),
    (o.unknown = function (a) {
      return arguments.length ? ((r = a), o) : r
    }),
    (o.quantiles = function () {
      return n.slice()
    }),
    (o.copy = function () {
      return _1().domain(e).range(t).unknown(r)
    }),
    tt.apply(o, arguments)
  )
}
function A1() {
  var e = 0,
    t = 1,
    n = 1,
    r = [0.5],
    i = [0, 1],
    o
  function a(l) {
    return l != null && l <= l ? i[Cr(r, l, 0, n)] : o
  }
  function s() {
    var l = -1
    for (r = new Array(n); ++l < n; ) r[l] = ((l + 1) * t - (l - n) * e) / (n + 1)
    return a
  }
  return (
    (a.domain = function (l) {
      return arguments.length ? (([e, t] = l), (e = +e), (t = +t), s()) : [e, t]
    }),
    (a.range = function (l) {
      return arguments.length ? ((n = (i = Array.from(l)).length - 1), s()) : i.slice()
    }),
    (a.invertExtent = function (l) {
      var c = i.indexOf(l)
      return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]]
    }),
    (a.unknown = function (l) {
      return (arguments.length && (o = l), a)
    }),
    (a.thresholds = function () {
      return r.slice()
    }),
    (a.copy = function () {
      return A1().domain([e, t]).range(i).unknown(o)
    }),
    tt.apply(Kt(a), arguments)
  )
}
function O1() {
  var e = [0.5],
    t = [0, 1],
    n,
    r = 1
  function i(o) {
    return o != null && o <= o ? t[Cr(e, o, 0, r)] : n
  }
  return (
    (i.domain = function (o) {
      return arguments.length
        ? ((e = Array.from(o)), (r = Math.min(e.length, t.length - 1)), i)
        : e.slice()
    }),
    (i.range = function (o) {
      return arguments.length
        ? ((t = Array.from(o)), (r = Math.min(e.length, t.length - 1)), i)
        : t.slice()
    }),
    (i.invertExtent = function (o) {
      var a = t.indexOf(o)
      return [e[a - 1], e[a]]
    }),
    (i.unknown = function (o) {
      return arguments.length ? ((n = o), i) : n
    }),
    (i.copy = function () {
      return O1().domain(e).range(t).unknown(n)
    }),
    tt.apply(i, arguments)
  )
}
const na = new Date(),
  ra = new Date()
function xe(e, t, n, r) {
  function i(o) {
    return (e((o = arguments.length === 0 ? new Date() : new Date(+o))), o)
  }
  return (
    (i.floor = (o) => (e((o = new Date(+o))), o)),
    (i.ceil = (o) => (e((o = new Date(o - 1))), t(o, 1), e(o), o)),
    (i.round = (o) => {
      const a = i(o),
        s = i.ceil(o)
      return o - a < s - o ? a : s
    }),
    (i.offset = (o, a) => (t((o = new Date(+o)), a == null ? 1 : Math.floor(a)), o)),
    (i.range = (o, a, s) => {
      const l = []
      if (((o = i.ceil(o)), (s = s == null ? 1 : Math.floor(s)), !(o < a) || !(s > 0))) return l
      let c
      do (l.push((c = new Date(+o))), t(o, s), e(o))
      while (c < o && o < a)
      return l
    }),
    (i.filter = (o) =>
      xe(
        (a) => {
          if (a >= a) for (; e(a), !o(a); ) a.setTime(a - 1)
        },
        (a, s) => {
          if (a >= a)
            if (s < 0) for (; ++s <= 0; ) for (; t(a, -1), !o(a); );
            else for (; --s >= 0; ) for (; t(a, 1), !o(a); );
        },
      )),
    n &&
      ((i.count = (o, a) => (na.setTime(+o), ra.setTime(+a), e(na), e(ra), Math.floor(n(na, ra)))),
      (i.every = (o) => (
        (o = Math.floor(o)),
        !isFinite(o) || !(o > 0)
          ? null
          : o > 1
            ? i.filter(r ? (a) => r(a) % o === 0 : (a) => i.count(0, a) % o === 0)
            : i
      ))),
    i
  )
}
const Li = xe(
  () => {},
  (e, t) => {
    e.setTime(+e + t)
  },
  (e, t) => t - e,
)
Li.every = (e) => (
  (e = Math.floor(e)),
  !isFinite(e) || !(e > 0)
    ? null
    : e > 1
      ? xe(
          (t) => {
            t.setTime(Math.floor(t / e) * e)
          },
          (t, n) => {
            t.setTime(+t + n * e)
          },
          (t, n) => (n - t) / e,
        )
      : Li
)
Li.range
const xt = 1e3,
  Je = xt * 60,
  bt = Je * 60,
  Et = bt * 24,
  zs = Et * 7,
  lu = Et * 30,
  ia = Et * 365,
  Zt = xe(
    (e) => {
      e.setTime(e - e.getMilliseconds())
    },
    (e, t) => {
      e.setTime(+e + t * xt)
    },
    (e, t) => (t - e) / xt,
    (e) => e.getUTCSeconds(),
  )
Zt.range
const Rs = xe(
  (e) => {
    e.setTime(e - e.getMilliseconds() - e.getSeconds() * xt)
  },
  (e, t) => {
    e.setTime(+e + t * Je)
  },
  (e, t) => (t - e) / Je,
  (e) => e.getMinutes(),
)
Rs.range
const Bs = xe(
  (e) => {
    e.setUTCSeconds(0, 0)
  },
  (e, t) => {
    e.setTime(+e + t * Je)
  },
  (e, t) => (t - e) / Je,
  (e) => e.getUTCMinutes(),
)
Bs.range
const Hs = xe(
  (e) => {
    e.setTime(e - e.getMilliseconds() - e.getSeconds() * xt - e.getMinutes() * Je)
  },
  (e, t) => {
    e.setTime(+e + t * bt)
  },
  (e, t) => (t - e) / bt,
  (e) => e.getHours(),
)
Hs.range
const Fs = xe(
  (e) => {
    e.setUTCMinutes(0, 0, 0)
  },
  (e, t) => {
    e.setTime(+e + t * bt)
  },
  (e, t) => (t - e) / bt,
  (e) => e.getUTCHours(),
)
Fs.range
const Tr = xe(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Je) / Et,
  (e) => e.getDate() - 1,
)
Tr.range
const xo = xe(
  (e) => {
    e.setUTCHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setUTCDate(e.getUTCDate() + t)
  },
  (e, t) => (t - e) / Et,
  (e) => e.getUTCDate() - 1,
)
xo.range
const gh = xe(
  (e) => {
    e.setUTCHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setUTCDate(e.getUTCDate() + t)
  },
  (e, t) => (t - e) / Et,
  (e) => Math.floor(e / Et),
)
gh.range
function un(e) {
  return xe(
    (t) => {
      ;(t.setDate(t.getDate() - ((t.getDay() + 7 - e) % 7)), t.setHours(0, 0, 0, 0))
    },
    (t, n) => {
      t.setDate(t.getDate() + n * 7)
    },
    (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Je) / zs,
  )
}
const bo = un(0),
  zi = un(1),
  C1 = un(2),
  k1 = un(3),
  _n = un(4),
  M1 = un(5),
  T1 = un(6)
bo.range
zi.range
C1.range
k1.range
_n.range
M1.range
T1.range
function fn(e) {
  return xe(
    (t) => {
      ;(t.setUTCDate(t.getUTCDate() - ((t.getUTCDay() + 7 - e) % 7)), t.setUTCHours(0, 0, 0, 0))
    },
    (t, n) => {
      t.setUTCDate(t.getUTCDate() + n * 7)
    },
    (t, n) => (n - t) / zs,
  )
}
const wo = fn(0),
  Ri = fn(1),
  N1 = fn(2),
  D1 = fn(3),
  An = fn(4),
  I1 = fn(5),
  j1 = fn(6)
wo.range
Ri.range
N1.range
D1.range
An.range
I1.range
j1.range
const Vs = xe(
  (e) => {
    ;(e.setDate(1), e.setHours(0, 0, 0, 0))
  },
  (e, t) => {
    e.setMonth(e.getMonth() + t)
  },
  (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12,
  (e) => e.getMonth(),
)
Vs.range
const Ws = xe(
  (e) => {
    ;(e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0))
  },
  (e, t) => {
    e.setUTCMonth(e.getUTCMonth() + t)
  },
  (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12,
  (e) => e.getUTCMonth(),
)
Ws.range
const _t = xe(
  (e) => {
    ;(e.setMonth(0, 1), e.setHours(0, 0, 0, 0))
  },
  (e, t) => {
    e.setFullYear(e.getFullYear() + t)
  },
  (e, t) => t.getFullYear() - e.getFullYear(),
  (e) => e.getFullYear(),
)
_t.every = (e) =>
  !isFinite((e = Math.floor(e))) || !(e > 0)
    ? null
    : xe(
        (t) => {
          ;(t.setFullYear(Math.floor(t.getFullYear() / e) * e),
            t.setMonth(0, 1),
            t.setHours(0, 0, 0, 0))
        },
        (t, n) => {
          t.setFullYear(t.getFullYear() + n * e)
        },
      )
_t.range
const At = xe(
  (e) => {
    ;(e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0))
  },
  (e, t) => {
    e.setUTCFullYear(e.getUTCFullYear() + t)
  },
  (e, t) => t.getUTCFullYear() - e.getUTCFullYear(),
  (e) => e.getUTCFullYear(),
)
At.every = (e) =>
  !isFinite((e = Math.floor(e))) || !(e > 0)
    ? null
    : xe(
        (t) => {
          ;(t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e),
            t.setUTCMonth(0, 1),
            t.setUTCHours(0, 0, 0, 0))
        },
        (t, n) => {
          t.setUTCFullYear(t.getUTCFullYear() + n * e)
        },
      )
At.range
function mh(e, t, n, r, i, o) {
  const a = [
    [Zt, 1, xt],
    [Zt, 5, 5 * xt],
    [Zt, 15, 15 * xt],
    [Zt, 30, 30 * xt],
    [o, 1, Je],
    [o, 5, 5 * Je],
    [o, 15, 15 * Je],
    [o, 30, 30 * Je],
    [i, 1, bt],
    [i, 3, 3 * bt],
    [i, 6, 6 * bt],
    [i, 12, 12 * bt],
    [r, 1, Et],
    [r, 2, 2 * Et],
    [n, 1, zs],
    [t, 1, lu],
    [t, 3, 3 * lu],
    [e, 1, ia],
  ]
  function s(c, u, f) {
    const d = u < c
    d && ([c, u] = [u, c])
    const h = f && typeof f.range == 'function' ? f : l(c, u, f),
      g = h ? h.range(c, +u + 1) : []
    return d ? g.reverse() : g
  }
  function l(c, u, f) {
    const d = Math.abs(u - c) / f,
      h = Cs(([, , x]) => x).right(a, d)
    if (h === a.length) return e.every($a(c / ia, u / ia, f))
    if (h === 0) return Li.every(Math.max($a(c, u, f), 1))
    const [g, p] = a[d / a[h - 1][2] < a[h][2] / d ? h - 1 : h]
    return g.every(p)
  }
  return [s, l]
}
const [$1, L1] = mh(At, Ws, wo, gh, Fs, Bs),
  [z1, R1] = mh(_t, Vs, bo, Tr, Hs, Rs)
function oa(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L)
    return (t.setFullYear(e.y), t)
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L)
}
function aa(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L))
    return (t.setUTCFullYear(e.y), t)
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L))
}
function qn(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 }
}
function B1(e) {
  var t = e.dateTime,
    n = e.date,
    r = e.time,
    i = e.periods,
    o = e.days,
    a = e.shortDays,
    s = e.months,
    l = e.shortMonths,
    c = Zn(i),
    u = Qn(i),
    f = Zn(o),
    d = Qn(o),
    h = Zn(a),
    g = Qn(a),
    p = Zn(s),
    x = Qn(s),
    y = Zn(l),
    w = Qn(l),
    m = {
      a: C,
      A: N,
      b: I,
      B: H,
      c: null,
      d: vu,
      e: vu,
      f: lP,
      g: xP,
      G: wP,
      H: aP,
      I: sP,
      j: cP,
      L: yh,
      m: uP,
      M: fP,
      p: V,
      q: B,
      Q: yu,
      s: xu,
      S: dP,
      u: hP,
      U: pP,
      V: vP,
      w: gP,
      W: mP,
      x: null,
      X: null,
      y: yP,
      Y: bP,
      Z: PP,
      '%': mu,
    },
    b = {
      a: Y,
      A: K,
      b: G,
      B: re,
      c: null,
      d: gu,
      e: gu,
      f: AP,
      g: $P,
      G: zP,
      H: SP,
      I: EP,
      j: _P,
      L: bh,
      m: OP,
      M: CP,
      p: q,
      q: W,
      Q: yu,
      s: xu,
      S: kP,
      u: MP,
      U: TP,
      V: NP,
      w: DP,
      W: IP,
      x: null,
      X: null,
      y: jP,
      Y: LP,
      Z: RP,
      '%': mu,
    },
    P = {
      a: F,
      A: D,
      b: k,
      B: $,
      c: E,
      d: hu,
      e: hu,
      f: nP,
      g: du,
      G: fu,
      H: pu,
      I: pu,
      j: Q1,
      L: tP,
      m: Z1,
      M: J1,
      p: T,
      q: q1,
      Q: iP,
      s: oP,
      S: eP,
      u: K1,
      U: Y1,
      V: U1,
      w: W1,
      W: X1,
      x: O,
      X: A,
      y: du,
      Y: fu,
      Z: G1,
      '%': rP,
    }
  ;((m.x = S(n, m)),
    (m.X = S(r, m)),
    (m.c = S(t, m)),
    (b.x = S(n, b)),
    (b.X = S(r, b)),
    (b.c = S(t, b)))
  function S(j, U) {
    return function (X) {
      var L = [],
        Q = -1,
        Z = 0,
        ne = j.length,
        ae,
        ue,
        Ye
      for (X instanceof Date || (X = new Date(+X)); ++Q < ne; )
        j.charCodeAt(Q) === 37 &&
          (L.push(j.slice(Z, Q)),
          (ue = uu[(ae = j.charAt(++Q))]) != null
            ? (ae = j.charAt(++Q))
            : (ue = ae === 'e' ? ' ' : '0'),
          (Ye = U[ae]) && (ae = Ye(X, ue)),
          L.push(ae),
          (Z = Q + 1))
      return (L.push(j.slice(Z, Q)), L.join(''))
    }
  }
  function _(j, U) {
    return function (X) {
      var L = qn(1900, void 0, 1),
        Q = M(L, j, (X += ''), 0),
        Z,
        ne
      if (Q != X.length) return null
      if ('Q' in L) return new Date(L.Q)
      if ('s' in L) return new Date(L.s * 1e3 + ('L' in L ? L.L : 0))
      if (
        (U && !('Z' in L) && (L.Z = 0),
        'p' in L && (L.H = (L.H % 12) + L.p * 12),
        L.m === void 0 && (L.m = 'q' in L ? L.q : 0),
        'V' in L)
      ) {
        if (L.V < 1 || L.V > 53) return null
        ;('w' in L || (L.w = 1),
          'Z' in L
            ? ((Z = aa(qn(L.y, 0, 1))),
              (ne = Z.getUTCDay()),
              (Z = ne > 4 || ne === 0 ? Ri.ceil(Z) : Ri(Z)),
              (Z = xo.offset(Z, (L.V - 1) * 7)),
              (L.y = Z.getUTCFullYear()),
              (L.m = Z.getUTCMonth()),
              (L.d = Z.getUTCDate() + ((L.w + 6) % 7)))
            : ((Z = oa(qn(L.y, 0, 1))),
              (ne = Z.getDay()),
              (Z = ne > 4 || ne === 0 ? zi.ceil(Z) : zi(Z)),
              (Z = Tr.offset(Z, (L.V - 1) * 7)),
              (L.y = Z.getFullYear()),
              (L.m = Z.getMonth()),
              (L.d = Z.getDate() + ((L.w + 6) % 7))))
      } else
        ('W' in L || 'U' in L) &&
          ('w' in L || (L.w = 'u' in L ? L.u % 7 : 'W' in L ? 1 : 0),
          (ne = 'Z' in L ? aa(qn(L.y, 0, 1)).getUTCDay() : oa(qn(L.y, 0, 1)).getDay()),
          (L.m = 0),
          (L.d =
            'W' in L ? ((L.w + 6) % 7) + L.W * 7 - ((ne + 5) % 7) : L.w + L.U * 7 - ((ne + 6) % 7)))
      return 'Z' in L ? ((L.H += (L.Z / 100) | 0), (L.M += L.Z % 100), aa(L)) : oa(L)
    }
  }
  function M(j, U, X, L) {
    for (var Q = 0, Z = U.length, ne = X.length, ae, ue; Q < Z; ) {
      if (L >= ne) return -1
      if (((ae = U.charCodeAt(Q++)), ae === 37)) {
        if (
          ((ae = U.charAt(Q++)),
          (ue = P[ae in uu ? U.charAt(Q++) : ae]),
          !ue || (L = ue(j, X, L)) < 0)
        )
          return -1
      } else if (ae != X.charCodeAt(L++)) return -1
    }
    return L
  }
  function T(j, U, X) {
    var L = c.exec(U.slice(X))
    return L ? ((j.p = u.get(L[0].toLowerCase())), X + L[0].length) : -1
  }
  function F(j, U, X) {
    var L = h.exec(U.slice(X))
    return L ? ((j.w = g.get(L[0].toLowerCase())), X + L[0].length) : -1
  }
  function D(j, U, X) {
    var L = f.exec(U.slice(X))
    return L ? ((j.w = d.get(L[0].toLowerCase())), X + L[0].length) : -1
  }
  function k(j, U, X) {
    var L = y.exec(U.slice(X))
    return L ? ((j.m = w.get(L[0].toLowerCase())), X + L[0].length) : -1
  }
  function $(j, U, X) {
    var L = p.exec(U.slice(X))
    return L ? ((j.m = x.get(L[0].toLowerCase())), X + L[0].length) : -1
  }
  function E(j, U, X) {
    return M(j, t, U, X)
  }
  function O(j, U, X) {
    return M(j, n, U, X)
  }
  function A(j, U, X) {
    return M(j, r, U, X)
  }
  function C(j) {
    return a[j.getDay()]
  }
  function N(j) {
    return o[j.getDay()]
  }
  function I(j) {
    return l[j.getMonth()]
  }
  function H(j) {
    return s[j.getMonth()]
  }
  function V(j) {
    return i[+(j.getHours() >= 12)]
  }
  function B(j) {
    return 1 + ~~(j.getMonth() / 3)
  }
  function Y(j) {
    return a[j.getUTCDay()]
  }
  function K(j) {
    return o[j.getUTCDay()]
  }
  function G(j) {
    return l[j.getUTCMonth()]
  }
  function re(j) {
    return s[j.getUTCMonth()]
  }
  function q(j) {
    return i[+(j.getUTCHours() >= 12)]
  }
  function W(j) {
    return 1 + ~~(j.getUTCMonth() / 3)
  }
  return {
    format: function (j) {
      var U = S((j += ''), m)
      return (
        (U.toString = function () {
          return j
        }),
        U
      )
    },
    parse: function (j) {
      var U = _((j += ''), !1)
      return (
        (U.toString = function () {
          return j
        }),
        U
      )
    },
    utcFormat: function (j) {
      var U = S((j += ''), b)
      return (
        (U.toString = function () {
          return j
        }),
        U
      )
    },
    utcParse: function (j) {
      var U = _((j += ''), !0)
      return (
        (U.toString = function () {
          return j
        }),
        U
      )
    },
  }
}
var uu = { '-': '', _: ' ', 0: '0' },
  Se = /^\s*\d+/,
  H1 = /^%/,
  F1 = /[\\^$*+?|[\]().{}]/g
function oe(e, t, n) {
  var r = e < 0 ? '-' : '',
    i = (r ? -e : e) + '',
    o = i.length
  return r + (o < n ? new Array(n - o + 1).join(t) + i : i)
}
function V1(e) {
  return e.replace(F1, '\\$&')
}
function Zn(e) {
  return new RegExp('^(?:' + e.map(V1).join('|') + ')', 'i')
}
function Qn(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]))
}
function W1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 1))
  return r ? ((e.w = +r[0]), n + r[0].length) : -1
}
function K1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 1))
  return r ? ((e.u = +r[0]), n + r[0].length) : -1
}
function Y1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.U = +r[0]), n + r[0].length) : -1
}
function U1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.V = +r[0]), n + r[0].length) : -1
}
function X1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.W = +r[0]), n + r[0].length) : -1
}
function fu(e, t, n) {
  var r = Se.exec(t.slice(n, n + 4))
  return r ? ((e.y = +r[0]), n + r[0].length) : -1
}
function du(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3)), n + r[0].length) : -1
}
function G1(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6))
  return r ? ((e.Z = r[1] ? 0 : -(r[2] + (r[3] || '00'))), n + r[0].length) : -1
}
function q1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 1))
  return r ? ((e.q = r[0] * 3 - 3), n + r[0].length) : -1
}
function Z1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.m = r[0] - 1), n + r[0].length) : -1
}
function hu(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.d = +r[0]), n + r[0].length) : -1
}
function Q1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 3))
  return r ? ((e.m = 0), (e.d = +r[0]), n + r[0].length) : -1
}
function pu(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.H = +r[0]), n + r[0].length) : -1
}
function J1(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.M = +r[0]), n + r[0].length) : -1
}
function eP(e, t, n) {
  var r = Se.exec(t.slice(n, n + 2))
  return r ? ((e.S = +r[0]), n + r[0].length) : -1
}
function tP(e, t, n) {
  var r = Se.exec(t.slice(n, n + 3))
  return r ? ((e.L = +r[0]), n + r[0].length) : -1
}
function nP(e, t, n) {
  var r = Se.exec(t.slice(n, n + 6))
  return r ? ((e.L = Math.floor(r[0] / 1e3)), n + r[0].length) : -1
}
function rP(e, t, n) {
  var r = H1.exec(t.slice(n, n + 1))
  return r ? n + r[0].length : -1
}
function iP(e, t, n) {
  var r = Se.exec(t.slice(n))
  return r ? ((e.Q = +r[0]), n + r[0].length) : -1
}
function oP(e, t, n) {
  var r = Se.exec(t.slice(n))
  return r ? ((e.s = +r[0]), n + r[0].length) : -1
}
function vu(e, t) {
  return oe(e.getDate(), t, 2)
}
function aP(e, t) {
  return oe(e.getHours(), t, 2)
}
function sP(e, t) {
  return oe(e.getHours() % 12 || 12, t, 2)
}
function cP(e, t) {
  return oe(1 + Tr.count(_t(e), e), t, 3)
}
function yh(e, t) {
  return oe(e.getMilliseconds(), t, 3)
}
function lP(e, t) {
  return yh(e, t) + '000'
}
function uP(e, t) {
  return oe(e.getMonth() + 1, t, 2)
}
function fP(e, t) {
  return oe(e.getMinutes(), t, 2)
}
function dP(e, t) {
  return oe(e.getSeconds(), t, 2)
}
function hP(e) {
  var t = e.getDay()
  return t === 0 ? 7 : t
}
function pP(e, t) {
  return oe(bo.count(_t(e) - 1, e), t, 2)
}
function xh(e) {
  var t = e.getDay()
  return t >= 4 || t === 0 ? _n(e) : _n.ceil(e)
}
function vP(e, t) {
  return ((e = xh(e)), oe(_n.count(_t(e), e) + (_t(e).getDay() === 4), t, 2))
}
function gP(e) {
  return e.getDay()
}
function mP(e, t) {
  return oe(zi.count(_t(e) - 1, e), t, 2)
}
function yP(e, t) {
  return oe(e.getFullYear() % 100, t, 2)
}
function xP(e, t) {
  return ((e = xh(e)), oe(e.getFullYear() % 100, t, 2))
}
function bP(e, t) {
  return oe(e.getFullYear() % 1e4, t, 4)
}
function wP(e, t) {
  var n = e.getDay()
  return ((e = n >= 4 || n === 0 ? _n(e) : _n.ceil(e)), oe(e.getFullYear() % 1e4, t, 4))
}
function PP(e) {
  var t = e.getTimezoneOffset()
  return (t > 0 ? '-' : ((t *= -1), '+')) + oe((t / 60) | 0, '0', 2) + oe(t % 60, '0', 2)
}
function gu(e, t) {
  return oe(e.getUTCDate(), t, 2)
}
function SP(e, t) {
  return oe(e.getUTCHours(), t, 2)
}
function EP(e, t) {
  return oe(e.getUTCHours() % 12 || 12, t, 2)
}
function _P(e, t) {
  return oe(1 + xo.count(At(e), e), t, 3)
}
function bh(e, t) {
  return oe(e.getUTCMilliseconds(), t, 3)
}
function AP(e, t) {
  return bh(e, t) + '000'
}
function OP(e, t) {
  return oe(e.getUTCMonth() + 1, t, 2)
}
function CP(e, t) {
  return oe(e.getUTCMinutes(), t, 2)
}
function kP(e, t) {
  return oe(e.getUTCSeconds(), t, 2)
}
function MP(e) {
  var t = e.getUTCDay()
  return t === 0 ? 7 : t
}
function TP(e, t) {
  return oe(wo.count(At(e) - 1, e), t, 2)
}
function wh(e) {
  var t = e.getUTCDay()
  return t >= 4 || t === 0 ? An(e) : An.ceil(e)
}
function NP(e, t) {
  return ((e = wh(e)), oe(An.count(At(e), e) + (At(e).getUTCDay() === 4), t, 2))
}
function DP(e) {
  return e.getUTCDay()
}
function IP(e, t) {
  return oe(Ri.count(At(e) - 1, e), t, 2)
}
function jP(e, t) {
  return oe(e.getUTCFullYear() % 100, t, 2)
}
function $P(e, t) {
  return ((e = wh(e)), oe(e.getUTCFullYear() % 100, t, 2))
}
function LP(e, t) {
  return oe(e.getUTCFullYear() % 1e4, t, 4)
}
function zP(e, t) {
  var n = e.getUTCDay()
  return ((e = n >= 4 || n === 0 ? An(e) : An.ceil(e)), oe(e.getUTCFullYear() % 1e4, t, 4))
}
function RP() {
  return '+0000'
}
function mu() {
  return '%'
}
function yu(e) {
  return +e
}
function xu(e) {
  return Math.floor(+e / 1e3)
}
var hn, Ph, Sh
BP({
  dateTime: '%x, %X',
  date: '%-m/%-d/%Y',
  time: '%-I:%M:%S %p',
  periods: ['AM', 'PM'],
  days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  months: [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
  ],
  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
})
function BP(e) {
  return ((hn = B1(e)), (Ph = hn.format), hn.parse, (Sh = hn.utcFormat), hn.utcParse, hn)
}
function HP(e) {
  return new Date(e)
}
function FP(e) {
  return e instanceof Date ? +e : +new Date(+e)
}
function Ks(e, t, n, r, i, o, a, s, l, c) {
  var u = Ns(),
    f = u.invert,
    d = u.domain,
    h = c('.%L'),
    g = c(':%S'),
    p = c('%I:%M'),
    x = c('%I %p'),
    y = c('%a %d'),
    w = c('%b %d'),
    m = c('%B'),
    b = c('%Y')
  function P(S) {
    return (
      l(S) < S
        ? h
        : s(S) < S
          ? g
          : a(S) < S
            ? p
            : o(S) < S
              ? x
              : r(S) < S
                ? i(S) < S
                  ? y
                  : w
                : n(S) < S
                  ? m
                  : b
    )(S)
  }
  return (
    (u.invert = function (S) {
      return new Date(f(S))
    }),
    (u.domain = function (S) {
      return arguments.length ? d(Array.from(S, FP)) : d().map(HP)
    }),
    (u.ticks = function (S) {
      var _ = d()
      return e(_[0], _[_.length - 1], S ?? 10)
    }),
    (u.tickFormat = function (S, _) {
      return _ == null ? P : c(_)
    }),
    (u.nice = function (S) {
      var _ = d()
      return (
        (!S || typeof S.range != 'function') && (S = t(_[0], _[_.length - 1], S ?? 10)),
        S ? d(ph(_, S)) : u
      )
    }),
    (u.copy = function () {
      return Mr(u, Ks(e, t, n, r, i, o, a, s, l, c))
    }),
    u
  )
}
function y$() {
  return tt.apply(
    Ks(z1, R1, _t, Vs, bo, Tr, Hs, Rs, Zt, Ph).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]),
    arguments,
  )
}
function x$() {
  return tt.apply(
    Ks($1, L1, At, Ws, wo, xo, Fs, Bs, Zt, Sh).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]),
    arguments,
  )
}
function Po() {
  var e = 0,
    t = 1,
    n,
    r,
    i,
    o,
    a = De,
    s = !1,
    l
  function c(f) {
    return f == null || isNaN((f = +f))
      ? l
      : a(i === 0 ? 0.5 : ((f = (o(f) - n) * i), s ? Math.max(0, Math.min(1, f)) : f))
  }
  ;((c.domain = function (f) {
    return arguments.length
      ? (([e, t] = f), (n = o((e = +e))), (r = o((t = +t))), (i = n === r ? 0 : 1 / (r - n)), c)
      : [e, t]
  }),
    (c.clamp = function (f) {
      return arguments.length ? ((s = !!f), c) : s
    }),
    (c.interpolator = function (f) {
      return arguments.length ? ((a = f), c) : a
    }))
  function u(f) {
    return function (d) {
      var h, g
      return arguments.length ? (([h, g] = d), (a = f(h, g)), c) : [a(0), a(1)]
    }
  }
  return (
    (c.range = u(Pt)),
    (c.rangeRound = u(Ts)),
    (c.unknown = function (f) {
      return arguments.length ? ((l = f), c) : l
    }),
    function (f) {
      return ((o = f), (n = f(e)), (r = f(t)), (i = n === r ? 0 : 1 / (r - n)), c)
    }
  )
}
function Yt(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown())
}
function VP() {
  var e = Kt(Po()(De))
  return (
    (e.copy = function () {
      return Yt(e, VP())
    }),
    Mt.apply(e, arguments)
  )
}
function WP() {
  var e = js(Po()).domain([1, 10])
  return (
    (e.copy = function () {
      return Yt(e, WP()).base(e.base())
    }),
    Mt.apply(e, arguments)
  )
}
function KP() {
  var e = $s(Po())
  return (
    (e.copy = function () {
      return Yt(e, KP()).constant(e.constant())
    }),
    Mt.apply(e, arguments)
  )
}
function Eh() {
  var e = Ls(Po())
  return (
    (e.copy = function () {
      return Yt(e, Eh()).exponent(e.exponent())
    }),
    Mt.apply(e, arguments)
  )
}
function b$() {
  return Eh.apply(null, arguments).exponent(0.5)
}
function YP() {
  var e = [],
    t = De
  function n(r) {
    if (r != null && !isNaN((r = +r))) return t((Cr(e, r, 1) - 1) / (e.length - 1))
  }
  return (
    (n.domain = function (r) {
      if (!arguments.length) return e.slice()
      e = []
      for (let i of r) i != null && !isNaN((i = +i)) && e.push(i)
      return (e.sort(Ft), n)
    }),
    (n.interpolator = function (r) {
      return arguments.length ? ((t = r), n) : t
    }),
    (n.range = function () {
      return e.map((r, i) => t(i / (e.length - 1)))
    }),
    (n.quantiles = function (r) {
      return Array.from({ length: r + 1 }, (i, o) => mw(e, o / r))
    }),
    (n.copy = function () {
      return YP(t).domain(e)
    }),
    Mt.apply(n, arguments)
  )
}
function So() {
  var e = 0,
    t = 0.5,
    n = 1,
    r = 1,
    i,
    o,
    a,
    s,
    l,
    c = De,
    u,
    f = !1,
    d
  function h(p) {
    return isNaN((p = +p))
      ? d
      : ((p = 0.5 + ((p = +u(p)) - o) * (r * p < r * o ? s : l)),
        c(f ? Math.max(0, Math.min(1, p)) : p))
  }
  ;((h.domain = function (p) {
    return arguments.length
      ? (([e, t, n] = p),
        (i = u((e = +e))),
        (o = u((t = +t))),
        (a = u((n = +n))),
        (s = i === o ? 0 : 0.5 / (o - i)),
        (l = o === a ? 0 : 0.5 / (a - o)),
        (r = o < i ? -1 : 1),
        h)
      : [e, t, n]
  }),
    (h.clamp = function (p) {
      return arguments.length ? ((f = !!p), h) : f
    }),
    (h.interpolator = function (p) {
      return arguments.length ? ((c = p), h) : c
    }))
  function g(p) {
    return function (x) {
      var y, w, m
      return arguments.length ? (([y, w, m] = x), (c = Gw(p, [y, w, m])), h) : [c(0), c(0.5), c(1)]
    }
  }
  return (
    (h.range = g(Pt)),
    (h.rangeRound = g(Ts)),
    (h.unknown = function (p) {
      return arguments.length ? ((d = p), h) : d
    }),
    function (p) {
      return (
        (u = p),
        (i = p(e)),
        (o = p(t)),
        (a = p(n)),
        (s = i === o ? 0 : 0.5 / (o - i)),
        (l = o === a ? 0 : 0.5 / (a - o)),
        (r = o < i ? -1 : 1),
        h
      )
    }
  )
}
function UP() {
  var e = Kt(So()(De))
  return (
    (e.copy = function () {
      return Yt(e, UP())
    }),
    Mt.apply(e, arguments)
  )
}
function XP() {
  var e = js(So()).domain([0.1, 1, 10])
  return (
    (e.copy = function () {
      return Yt(e, XP()).base(e.base())
    }),
    Mt.apply(e, arguments)
  )
}
function GP() {
  var e = $s(So())
  return (
    (e.copy = function () {
      return Yt(e, GP()).constant(e.constant())
    }),
    Mt.apply(e, arguments)
  )
}
function _h() {
  var e = Ls(So())
  return (
    (e.copy = function () {
      return Yt(e, _h()).exponent(e.exponent())
    }),
    Mt.apply(e, arguments)
  )
}
function w$() {
  return _h.apply(null, arguments).exponent(0.5)
}
var Ut = (e) => e.chartData,
  qP = R([Ut], (e) => {
    var t = e.chartData != null ? e.chartData.length - 1 : 0
    return {
      chartData: e.chartData,
      computedData: e.computedData,
      dataEndIndex: t,
      dataStartIndex: 0,
    }
  }),
  Ys = (e, t, n, r) => (r ? qP(e) : Ut(e))
function nn(e) {
  if (Array.isArray(e) && e.length === 2) {
    var [t, n] = e
    if (Le(t) && Le(n)) return !0
  }
  return !1
}
function bu(e, t, n) {
  return n ? e : [Math.min(e[0], t[0]), Math.max(e[1], t[1])]
}
function Ah(e, t) {
  if (t && typeof e != 'function' && Array.isArray(e) && e.length === 2) {
    var [n, r] = e,
      i,
      o
    if (Le(n)) i = n
    else if (typeof n == 'function') return
    if (Le(r)) o = r
    else if (typeof r == 'function') return
    var a = [i, o]
    if (nn(a)) return a
  }
}
function ZP(e, t, n) {
  if (!(!n && t == null)) {
    if (typeof e == 'function' && t != null)
      try {
        var r = e(t, n)
        if (nn(r)) return bu(r, t, n)
      } catch {}
    if (Array.isArray(e) && e.length === 2) {
      var [i, o] = e,
        a,
        s
      if (i === 'auto') t != null && (a = Math.min(...t))
      else if (te(i)) a = i
      else if (typeof i == 'function')
        try {
          t != null && (a = i(t?.[0]))
        } catch {}
      else if (typeof i == 'string' && dl.test(i)) {
        var l = dl.exec(i)
        if (l == null || t == null) a = void 0
        else {
          var c = +l[1]
          a = t[0] - c
        }
      } else a = t?.[0]
      if (o === 'auto') t != null && (s = Math.max(...t))
      else if (te(o)) s = o
      else if (typeof o == 'function')
        try {
          t != null && (s = o(t?.[1]))
        } catch {}
      else if (typeof o == 'string' && hl.test(o)) {
        var u = hl.exec(o)
        if (u == null || t == null) s = void 0
        else {
          var f = +u[1]
          s = t[1] + f
        }
      } else s = t?.[1]
      var d = [a, s]
      if (nn(d)) return t == null ? d : bu(d, t, n)
    }
  }
}
var QP = (e) => e,
  Oh = {},
  Ch = (e) => e === Oh,
  wu = (e) =>
    function t() {
      return arguments.length === 0 ||
        (arguments.length === 1 && Ch(arguments.length <= 0 ? void 0 : arguments[0]))
        ? t
        : e(...arguments)
    },
  kh = (e, t) =>
    e === 1
      ? t
      : wu(function () {
          for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i]
          var o = r.filter((a) => a !== Oh).length
          return o >= e
            ? t(...r)
            : kh(
                e - o,
                wu(function () {
                  for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
                    s[l] = arguments[l]
                  var c = r.map((u) => (Ch(u) ? s.shift() : u))
                  return t(...c, ...s)
                }),
              )
        }),
  Eo = (e) => kh(e.length, e),
  Ha = (e, t) => {
    for (var n = [], r = e; r < t; ++r) n[r - e] = r
    return n
  },
  JP = Eo((e, t) =>
    Array.isArray(t)
      ? t.map(e)
      : Object.keys(t)
          .map((n) => t[n])
          .map(e),
  ),
  eS = function () {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r]
    if (!n.length) return QP
    var i = n.reverse(),
      o = i[0],
      a = i.slice(1)
    return function () {
      return a.reduce((s, l) => l(s), o(...arguments))
    }
  },
  Fa = (e) => (Array.isArray(e) ? e.reverse() : e.split('').reverse().join('')),
  Mh = (e) => {
    var t = null,
      n = null
    return function () {
      for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o]
      return (
        (t &&
          i.every((a, s) => {
            var l
            return a === ((l = t) === null || l === void 0 ? void 0 : l[s])
          })) ||
          ((t = i), (n = e(...i))),
        n
      )
    }
  }
function Th(e) {
  var t
  return (e === 0 ? (t = 1) : (t = Math.floor(new se(e).abs().log(10).toNumber()) + 1), t)
}
function Nh(e, t, n) {
  for (var r = new se(e), i = 0, o = []; r.lt(t) && i < 1e5; )
    (o.push(r.toNumber()), (r = r.add(n)), i++)
  return o
}
Eo((e, t, n) => {
  var r = +e,
    i = +t
  return r + n * (i - r)
})
Eo((e, t, n) => {
  var r = t - +e
  return ((r = r || 1 / 0), (n - e) / r)
})
Eo((e, t, n) => {
  var r = t - +e
  return ((r = r || 1 / 0), Math.max(0, Math.min(1, (n - e) / r)))
})
var Dh = (e) => {
    var [t, n] = e,
      [r, i] = [t, n]
    return (t > n && ([r, i] = [n, t]), [r, i])
  },
  Ih = (e, t, n) => {
    if (e.lte(0)) return new se(0)
    var r = Th(e.toNumber()),
      i = new se(10).pow(r),
      o = e.div(i),
      a = r !== 1 ? 0.05 : 0.1,
      s = new se(Math.ceil(o.div(a).toNumber())).add(n).mul(a),
      l = s.mul(i)
    return t ? new se(l.toNumber()) : new se(Math.ceil(l.toNumber()))
  },
  tS = (e, t, n) => {
    var r = new se(1),
      i = new se(e)
    if (!i.isint() && n) {
      var o = Math.abs(e)
      o < 1
        ? ((r = new se(10).pow(Th(e) - 1)), (i = new se(Math.floor(i.div(r).toNumber())).mul(r)))
        : o > 1 && (i = new se(Math.floor(e)))
    } else e === 0 ? (i = new se(Math.floor((t - 1) / 2))) : n || (i = new se(Math.floor(e)))
    var a = Math.floor((t - 1) / 2),
      s = eS(
        JP((l) => i.add(new se(l - a).mul(r)).toNumber()),
        Ha,
      )
    return s(0, t)
  },
  jh = function (t, n, r, i) {
    var o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0
    if (!Number.isFinite((n - t) / (r - 1)))
      return { step: new se(0), tickMin: new se(0), tickMax: new se(0) }
    var a = Ih(new se(n).sub(t).div(r - 1), i, o),
      s
    t <= 0 && n >= 0
      ? (s = new se(0))
      : ((s = new se(t).add(n).div(2)), (s = s.sub(new se(s).mod(a))))
    var l = Math.ceil(s.sub(t).div(a).toNumber()),
      c = Math.ceil(new se(n).sub(s).div(a).toNumber()),
      u = l + c + 1
    return u > r
      ? jh(t, n, r, i, o + 1)
      : (u < r && ((c = n > 0 ? c + (r - u) : c), (l = n > 0 ? l : l + (r - u))),
        { step: a, tickMin: s.sub(new se(l).mul(a)), tickMax: s.add(new se(c).mul(a)) })
  }
function nS(e) {
  var [t, n] = e,
    r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6,
    i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
    o = Math.max(r, 2),
    [a, s] = Dh([t, n])
  if (a === -1 / 0 || s === 1 / 0) {
    var l =
      s === 1 / 0 ? [a, ...Ha(0, r - 1).map(() => 1 / 0)] : [...Ha(0, r - 1).map(() => -1 / 0), s]
    return t > n ? Fa(l) : l
  }
  if (a === s) return tS(a, r, i)
  var { step: c, tickMin: u, tickMax: f } = jh(a, s, o, i, 0),
    d = Nh(u, f.add(new se(0.1).mul(c)), c)
  return t > n ? Fa(d) : d
}
function rS(e, t) {
  var [n, r] = e,
    i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
    [o, a] = Dh([n, r])
  if (o === -1 / 0 || a === 1 / 0) return [n, r]
  if (o === a) return [o]
  var s = Math.max(t, 2),
    l = Ih(new se(a).sub(o).div(s - 1), i, 0),
    c = [...Nh(new se(o), new se(a), l), a]
  return (i === !1 && (c = c.map((u) => Math.round(u))), n > r ? Fa(c) : c)
}
var iS = Mh(nS),
  oS = Mh(rS),
  aS = (e) => e.rootProps.barCategoryGap,
  _o = (e) => e.rootProps.stackOffset,
  Us = (e) => e.options.chartName,
  Xs = (e) => e.rootProps.syncId,
  $h = (e) => e.rootProps.syncMethod,
  Gs = (e) => e.options.eventEmitter,
  mt = {
    allowDuplicatedCategory: !0,
    angleAxisId: 0,
    reversed: !1,
    scale: 'auto',
    tick: !0,
    type: 'category',
  },
  Be = {
    allowDataOverflow: !1,
    allowDuplicatedCategory: !0,
    radiusAxisId: 0,
    scale: 'auto',
    tick: !0,
    tickCount: 5,
    type: 'number',
  },
  Ao = (e, t) => {
    if (!(!e || !t)) return e != null && e.reversed ? [t[1], t[0]] : t
  },
  sS = {
    allowDataOverflow: !1,
    allowDecimals: !1,
    allowDuplicatedCategory: !1,
    dataKey: void 0,
    domain: void 0,
    id: mt.angleAxisId,
    includeHidden: !1,
    name: void 0,
    reversed: mt.reversed,
    scale: mt.scale,
    tick: mt.tick,
    tickCount: void 0,
    ticks: void 0,
    type: mt.type,
    unit: void 0,
  },
  cS = {
    allowDataOverflow: Be.allowDataOverflow,
    allowDecimals: !1,
    allowDuplicatedCategory: Be.allowDuplicatedCategory,
    dataKey: void 0,
    domain: void 0,
    id: Be.radiusAxisId,
    includeHidden: !1,
    name: void 0,
    reversed: !1,
    scale: Be.scale,
    tick: Be.tick,
    tickCount: Be.tickCount,
    ticks: void 0,
    type: Be.type,
    unit: void 0,
  },
  lS = {
    allowDataOverflow: !1,
    allowDecimals: !1,
    allowDuplicatedCategory: mt.allowDuplicatedCategory,
    dataKey: void 0,
    domain: void 0,
    id: mt.angleAxisId,
    includeHidden: !1,
    name: void 0,
    reversed: !1,
    scale: mt.scale,
    tick: mt.tick,
    tickCount: void 0,
    ticks: void 0,
    type: 'number',
    unit: void 0,
  },
  uS = {
    allowDataOverflow: Be.allowDataOverflow,
    allowDecimals: !1,
    allowDuplicatedCategory: Be.allowDuplicatedCategory,
    dataKey: void 0,
    domain: void 0,
    id: Be.radiusAxisId,
    includeHidden: !1,
    name: void 0,
    reversed: !1,
    scale: Be.scale,
    tick: Be.tick,
    tickCount: Be.tickCount,
    ticks: void 0,
    type: 'category',
    unit: void 0,
  },
  qs = (e, t) =>
    e.polarAxis.angleAxis[t] != null
      ? e.polarAxis.angleAxis[t]
      : e.layout.layoutType === 'radial'
        ? lS
        : sS,
  Zs = (e, t) =>
    e.polarAxis.radiusAxis[t] != null
      ? e.polarAxis.radiusAxis[t]
      : e.layout.layoutType === 'radial'
        ? uS
        : cS,
  Oo = (e) => e.polarOptions,
  Qs = R([Ct, kt, Oe], tx),
  Lh = R([Oo, Qs], (e, t) => {
    if (e != null) return Wt(e.innerRadius, t, 0)
  }),
  zh = R([Oo, Qs], (e, t) => {
    if (e != null) return Wt(e.outerRadius, t, t * 0.8)
  }),
  fS = (e) => {
    if (e == null) return [0, 0]
    var { startAngle: t, endAngle: n } = e
    return [t, n]
  },
  Rh = R([Oo], fS)
R([qs, Rh], Ao)
var Bh = R([Qs, Lh, zh], (e, t, n) => {
  if (!(e == null || t == null || n == null)) return [t, n]
})
R([Zs, Bh], Ao)
var Hh = R([he, Oo, Lh, zh, Ct, kt], (e, t, n, r, i, o) => {
    if (!((e !== 'centric' && e !== 'radial') || t == null || n == null || r == null)) {
      var { cx: a, cy: s, startAngle: l, endAngle: c } = t
      return {
        cx: Wt(a, i, i / 2),
        cy: Wt(s, o, o / 2),
        innerRadius: n,
        outerRadius: r,
        startAngle: l,
        endAngle: c,
        clockWise: !1,
      }
    }
  }),
  be = (e, t) => t,
  Co = (e, t, n) => n
function Fh(e) {
  return e?.id
}
var we = (e) => {
    var t = he(e)
    return t === 'horizontal'
      ? 'xAxis'
      : t === 'vertical'
        ? 'yAxis'
        : t === 'centric'
          ? 'angleAxis'
          : 'radiusAxis'
  },
  Ln = (e) => e.tooltip.settings.axisId,
  Pe = (e) => {
    var t = we(e),
      n = Ln(e)
    return Nr(e, t, n)
  },
  Vh = R([Pe], (e) => e?.dataKey)
function Wh(e, t, n) {
  var { chartData: r = [] } = t,
    { allowDuplicatedCategory: i, dataKey: o } = n,
    a = new Map()
  return (
    e.forEach((s) => {
      var l,
        c = (l = s.data) !== null && l !== void 0 ? l : r
      if (!(c == null || c.length === 0)) {
        var u = Fh(s)
        c.forEach((f, d) => {
          var h = o == null || i ? d : String(Ae(f, o, null)),
            g = Ae(f, s.dataKey, 0),
            p
          ;(a.has(h) ? (p = a.get(h)) : (p = {}), Object.assign(p, { [u]: g }), a.set(h, p))
        })
      }
    }),
    Array.from(a.values())
  )
}
function Js(e) {
  return e.stackId != null && e.dataKey != null
}
var ko = (e, t) => (e === t ? !0 : e == null || t == null ? !1 : e[0] === t[0] && e[1] === t[1])
function Mo(e, t) {
  return Array.isArray(e) && Array.isArray(t) && e.length === 0 && t.length === 0 ? !0 : e === t
}
function Pu(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Bi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Pu(Object(n), !0).forEach(function (r) {
          dS(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Pu(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function dS(e, t, n) {
  return (
    (t = hS(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function hS(e) {
  var t = pS(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function pS(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var Va = [0, 'auto'],
  ze = {
    allowDataOverflow: !1,
    allowDecimals: !0,
    allowDuplicatedCategory: !0,
    angle: 0,
    dataKey: void 0,
    domain: void 0,
    height: 30,
    hide: !0,
    id: 0,
    includeHidden: !1,
    interval: 'preserveEnd',
    minTickGap: 5,
    mirror: !1,
    name: void 0,
    orientation: 'bottom',
    padding: { left: 0, right: 0 },
    reversed: !1,
    scale: 'auto',
    tick: !0,
    tickCount: 5,
    tickFormatter: void 0,
    ticks: void 0,
    type: 'category',
    unit: void 0,
  },
  Kh = (e, t) => e.cartesianAxis.xAxis[t],
  Tt = (e, t) => {
    var n = Kh(e, t)
    return n ?? ze
  },
  Re = {
    allowDataOverflow: !1,
    allowDecimals: !0,
    allowDuplicatedCategory: !0,
    angle: 0,
    dataKey: void 0,
    domain: Va,
    hide: !0,
    id: 0,
    includeHidden: !1,
    interval: 'preserveEnd',
    minTickGap: 5,
    mirror: !1,
    name: void 0,
    orientation: 'left',
    padding: { top: 0, bottom: 0 },
    reversed: !1,
    scale: 'auto',
    tick: !0,
    tickCount: 5,
    tickFormatter: void 0,
    ticks: void 0,
    type: 'number',
    unit: void 0,
    width: Ar,
  },
  Yh = (e, t) => e.cartesianAxis.yAxis[t],
  Nt = (e, t) => {
    var n = Yh(e, t)
    return n ?? Re
  },
  Bt = {
    domain: [0, 'auto'],
    includeHidden: !1,
    reversed: !1,
    allowDataOverflow: !1,
    allowDuplicatedCategory: !1,
    dataKey: void 0,
    id: 0,
    name: '',
    range: [64, 64],
    scale: 'auto',
    type: 'number',
    unit: '',
  },
  ec = (e, t) => {
    var n = e.cartesianAxis.zAxis[t]
    return n ?? Bt
  },
  Ie = (e, t, n) => {
    switch (t) {
      case 'xAxis':
        return Tt(e, n)
      case 'yAxis':
        return Nt(e, n)
      case 'zAxis':
        return ec(e, n)
      case 'angleAxis':
        return qs(e, n)
      case 'radiusAxis':
        return Zs(e, n)
      default:
        throw new Error('Unexpected axis type: '.concat(t))
    }
  },
  vS = (e, t, n) => {
    switch (t) {
      case 'xAxis':
        return Tt(e, n)
      case 'yAxis':
        return Nt(e, n)
      default:
        throw new Error('Unexpected axis type: '.concat(t))
    }
  },
  Nr = (e, t, n) => {
    switch (t) {
      case 'xAxis':
        return Tt(e, n)
      case 'yAxis':
        return Nt(e, n)
      case 'angleAxis':
        return qs(e, n)
      case 'radiusAxis':
        return Zs(e, n)
      default:
        throw new Error('Unexpected axis type: '.concat(t))
    }
  },
  Uh = (e) =>
    e.graphicalItems.cartesianItems.some((t) => t.type === 'bar') ||
    e.graphicalItems.polarItems.some((t) => t.type === 'radialBar')
function Xh(e, t) {
  return (n) => {
    switch (e) {
      case 'xAxis':
        return 'xAxisId' in n && n.xAxisId === t
      case 'yAxis':
        return 'yAxisId' in n && n.yAxisId === t
      case 'zAxis':
        return 'zAxisId' in n && n.zAxisId === t
      case 'angleAxis':
        return 'angleAxisId' in n && n.angleAxisId === t
      case 'radiusAxis':
        return 'radiusAxisId' in n && n.radiusAxisId === t
      default:
        return !1
    }
  }
}
var Gh = (e) => e.graphicalItems.cartesianItems,
  gS = R([be, Co], Xh),
  qh = (e, t, n) => e.filter(n).filter((r) => (t?.includeHidden === !0 ? !0 : !r.hide)),
  Dr = R([Gh, Ie, gS], qh, { memoizeOptions: { resultEqualityCheck: Mo } }),
  Zh = R([Dr], (e) => e.filter((t) => t.type === 'area' || t.type === 'bar').filter(Js)),
  Qh = (e) => e.filter((t) => !('stackId' in t) || t.stackId === void 0),
  mS = R([Dr], Qh),
  Jh = (e) =>
    e
      .map((t) => t.data)
      .filter(Boolean)
      .flat(1),
  yS = R([Dr], Jh, { memoizeOptions: { resultEqualityCheck: Mo } }),
  ep = (e, t) => {
    var { chartData: n = [], dataStartIndex: r, dataEndIndex: i } = t
    return e.length > 0 ? e : n.slice(r, i + 1)
  },
  tc = R([yS, Ys], ep),
  tp = (e, t, n) =>
    t?.dataKey != null
      ? e.map((r) => ({ value: Ae(r, t.dataKey) }))
      : n.length > 0
        ? n.map((r) => r.dataKey).flatMap((r) => e.map((i) => ({ value: Ae(i, r) })))
        : e.map((r) => ({ value: r })),
  To = R([tc, Ie, Dr], tp)
function np(e, t) {
  switch (e) {
    case 'xAxis':
      return t.direction === 'x'
    case 'yAxis':
      return t.direction === 'y'
    default:
      return !1
  }
}
function pi(e) {
  if (dt(e) || e instanceof Date) {
    var t = Number(e)
    if (Le(t)) return t
  }
}
function Su(e) {
  if (Array.isArray(e)) {
    var t = [pi(e[0]), pi(e[1])]
    return nn(t) ? t : void 0
  }
  var n = pi(e)
  if (n != null) return [n, n]
}
function zn(e) {
  return e.map(pi).filter(Ey)
}
function xS(e, t, n) {
  return !n || typeof t != 'number' || st(t)
    ? []
    : n.length
      ? zn(
          n.flatMap((r) => {
            var i = Ae(e, r.dataKey),
              o,
              a
            if ((Array.isArray(i) ? ([o, a] = i) : (o = a = i), !(!Le(o) || !Le(a))))
              return [t - o, t + a]
          }),
        )
      : []
}
var bS = R([Zh, Ys, Pe], Wh),
  rp = (e, t, n) => {
    var r = {},
      i = t.reduce(
        (o, a) => (
          a.stackId == null || (o[a.stackId] == null && (o[a.stackId] = []), o[a.stackId].push(a)),
          o
        ),
        r,
      )
    return Object.fromEntries(
      Object.entries(i).map((o) => {
        var [a, s] = o,
          l = s.map(Fh)
        return [a, { stackedData: gx(e, l, n), graphicalItems: s }]
      }),
    )
  },
  wS = R([bS, Zh, _o], rp),
  ip = (e, t, n, r) => {
    var { dataStartIndex: i, dataEndIndex: o } = t
    if (r == null && n !== 'zAxis') {
      var a = xx(e, i, o)
      if (!(a != null && a[0] === 0 && a[1] === 0)) return a
    }
  },
  PS = R([Ie], (e) => e.allowDataOverflow),
  nc = (e) => {
    var t
    if (e == null || !('domain' in e)) return Va
    if (e.domain != null) return e.domain
    if (e.ticks != null) {
      if (e.type === 'number') {
        var n = zn(e.ticks)
        return [Math.min(...n), Math.max(...n)]
      }
      if (e.type === 'category') return e.ticks.map(String)
    }
    return (t = e?.domain) !== null && t !== void 0 ? t : Va
  },
  op = R([Ie], nc),
  ap = R([op, PS], Ah),
  SS = R([wS, Ut, be, ap], ip, { memoizeOptions: { resultEqualityCheck: ko } }),
  rc = (e) => e.errorBars,
  ES = (e, t, n) =>
    e
      .flatMap((r) => t[r.id])
      .filter(Boolean)
      .filter((r) => np(n, r)),
  Hi = function () {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r]
    var i = n.filter(Boolean)
    if (i.length !== 0) {
      var o = i.flat(),
        a = Math.min(...o),
        s = Math.max(...o)
      return [a, s]
    }
  },
  sp = (e, t, n, r, i) => {
    var o, a
    if (
      (n.length > 0 &&
        e.forEach((s) => {
          n.forEach((l) => {
            var c,
              u,
              f = (c = r[l.id]) === null || c === void 0 ? void 0 : c.filter((y) => np(i, y)),
              d = Ae(s, (u = t.dataKey) !== null && u !== void 0 ? u : l.dataKey),
              h = xS(s, d, f)
            if (h.length >= 2) {
              var g = Math.min(...h),
                p = Math.max(...h)
              ;((o == null || g < o) && (o = g), (a == null || p > a) && (a = p))
            }
            var x = Su(d)
            x != null &&
              ((o = o == null ? x[0] : Math.min(o, x[0])),
              (a = a == null ? x[1] : Math.max(a, x[1])))
          })
        }),
      t?.dataKey != null &&
        e.forEach((s) => {
          var l = Su(Ae(s, t.dataKey))
          l != null &&
            ((o = o == null ? l[0] : Math.min(o, l[0])), (a = a == null ? l[1] : Math.max(a, l[1])))
        }),
      Le(o) && Le(a))
    )
      return [o, a]
  },
  _S = R([tc, Ie, mS, rc, be], sp, { memoizeOptions: { resultEqualityCheck: ko } })
function AS(e) {
  var { value: t } = e
  if (dt(t) || t instanceof Date) return t
}
var OS = (e, t, n) => {
    var r = e.map(AS).filter((i) => i != null)
    return n && (t.dataKey == null || (t.allowDuplicatedCategory && _d(r)))
      ? od(0, e.length)
      : t.allowDuplicatedCategory
        ? r
        : Array.from(new Set(r))
  },
  cp = (e) => e.referenceElements.dots,
  Rn = (e, t, n) =>
    e
      .filter((r) => r.ifOverflow === 'extendDomain')
      .filter((r) => (t === 'xAxis' ? r.xAxisId === n : r.yAxisId === n)),
  CS = R([cp, be, Co], Rn),
  lp = (e) => e.referenceElements.areas,
  kS = R([lp, be, Co], Rn),
  up = (e) => e.referenceElements.lines,
  MS = R([up, be, Co], Rn),
  fp = (e, t) => {
    var n = zn(e.map((r) => (t === 'xAxis' ? r.x : r.y)))
    if (n.length !== 0) return [Math.min(...n), Math.max(...n)]
  },
  TS = R(CS, be, fp),
  dp = (e, t) => {
    var n = zn(e.flatMap((r) => [t === 'xAxis' ? r.x1 : r.y1, t === 'xAxis' ? r.x2 : r.y2]))
    if (n.length !== 0) return [Math.min(...n), Math.max(...n)]
  },
  NS = R([kS, be], dp),
  hp = (e, t) => {
    var n = zn(e.map((r) => (t === 'xAxis' ? r.x : r.y)))
    if (n.length !== 0) return [Math.min(...n), Math.max(...n)]
  },
  DS = R(MS, be, hp),
  IS = R(TS, DS, NS, (e, t, n) => Hi(e, n, t)),
  pp = (e, t, n, r, i, o, a, s) => {
    if (n != null) return n
    var l = (a === 'vertical' && s === 'xAxis') || (a === 'horizontal' && s === 'yAxis'),
      c = l ? Hi(r, o, i) : Hi(o, i)
    return ZP(t, c, e.allowDataOverflow)
  },
  jS = R([Ie, op, ap, SS, _S, IS, he, be], pp, { memoizeOptions: { resultEqualityCheck: ko } }),
  $S = [0, 1],
  vp = (e, t, n, r, i, o, a) => {
    if (!((e == null || n == null || n.length === 0) && a === void 0)) {
      var { dataKey: s, type: l } = e,
        c = ln(t, o)
      return c && s == null
        ? od(0, n.length)
        : l === 'category'
          ? OS(r, e, c)
          : i === 'expand'
            ? $S
            : a
    }
  },
  ic = R([Ie, he, tc, To, _o, be, jS], vp),
  gp = (e, t, n, r, i) => {
    if (e != null) {
      var { scale: o, type: a } = e
      if (o === 'auto')
        return t === 'radial' && i === 'radiusAxis'
          ? 'band'
          : t === 'radial' && i === 'angleAxis'
            ? 'linear'
            : a === 'category' &&
                r &&
                (r.indexOf('LineChart') >= 0 ||
                  r.indexOf('AreaChart') >= 0 ||
                  (r.indexOf('ComposedChart') >= 0 && !n))
              ? 'point'
              : a === 'category'
                ? 'band'
                : 'linear'
      if (typeof o == 'string') {
        var s = 'scale'.concat(_r(o))
        return s in tr ? s : 'point'
      }
    }
  },
  Ir = R([Ie, he, Uh, Us, be], gp)
function LS(e) {
  if (e != null) {
    if (e in tr) return tr[e]()
    var t = 'scale'.concat(_r(e))
    if (t in tr) return tr[t]()
  }
}
function oc(e, t, n, r) {
  if (!(n == null || r == null)) {
    if (typeof e.scale == 'function') return e.scale.copy().domain(n).range(r)
    var i = LS(t)
    if (i != null) {
      var o = i.domain(n).range(r)
      return (dx(o), o)
    }
  }
}
var mp = (e, t, n) => {
    var r = nc(t)
    if (!(n !== 'auto' && n !== 'linear')) {
      if (
        t != null &&
        t.tickCount &&
        Array.isArray(r) &&
        (r[0] === 'auto' || r[1] === 'auto') &&
        nn(e)
      )
        return iS(e, t.tickCount, t.allowDecimals)
      if (t != null && t.tickCount && t.type === 'number' && nn(e))
        return oS(e, t.tickCount, t.allowDecimals)
    }
  },
  ac = R([ic, Nr, Ir], mp),
  yp = (e, t, n, r) => {
    if (r !== 'angleAxis' && e?.type === 'number' && nn(t) && Array.isArray(n) && n.length > 0) {
      var i = t[0],
        o = n[0],
        a = t[1],
        s = n[n.length - 1]
      return [Math.min(i, o), Math.max(a, s)]
    }
    return t
  },
  zS = R([Ie, ic, ac, be], yp),
  RS = R(To, Ie, (e, t) => {
    if (!(!t || t.type !== 'number')) {
      var n = 1 / 0,
        r = Array.from(zn(e.map((s) => s.value))).sort((s, l) => s - l)
      if (r.length < 2) return 1 / 0
      var i = r[r.length - 1] - r[0]
      if (i === 0) return 1 / 0
      for (var o = 0; o < r.length - 1; o++) {
        var a = r[o + 1] - r[o]
        n = Math.min(n, a)
      }
      return n / i
    }
  }),
  xp = R(
    RS,
    he,
    aS,
    Oe,
    (e, t, n, r) => r,
    (e, t, n, r, i) => {
      if (!Le(e)) return 0
      var o = t === 'vertical' ? r.height : r.width
      if (i === 'gap') return (e * o) / 2
      if (i === 'no-gap') {
        var a = Wt(n, e * o),
          s = (e * o) / 2
        return s - a - ((s - a) / o) * a
      }
      return 0
    },
  ),
  BS = (e, t) => {
    var n = Tt(e, t)
    return n == null || typeof n.padding != 'string' ? 0 : xp(e, 'xAxis', t, n.padding)
  },
  HS = (e, t) => {
    var n = Nt(e, t)
    return n == null || typeof n.padding != 'string' ? 0 : xp(e, 'yAxis', t, n.padding)
  },
  FS = R(Tt, BS, (e, t) => {
    var n, r
    if (e == null) return { left: 0, right: 0 }
    var { padding: i } = e
    return typeof i == 'string'
      ? { left: t, right: t }
      : {
          left: ((n = i.left) !== null && n !== void 0 ? n : 0) + t,
          right: ((r = i.right) !== null && r !== void 0 ? r : 0) + t,
        }
  }),
  VS = R(Nt, HS, (e, t) => {
    var n, r
    if (e == null) return { top: 0, bottom: 0 }
    var { padding: i } = e
    return typeof i == 'string'
      ? { top: t, bottom: t }
      : {
          top: ((n = i.top) !== null && n !== void 0 ? n : 0) + t,
          bottom: ((r = i.bottom) !== null && r !== void 0 ? r : 0) + t,
        }
  }),
  WS = R([Oe, FS, go, vo, (e, t, n) => n], (e, t, n, r, i) => {
    var { padding: o } = r
    return i ? [o.left, n.width - o.right] : [e.left + t.left, e.left + e.width - t.right]
  }),
  KS = R([Oe, he, VS, go, vo, (e, t, n) => n], (e, t, n, r, i, o) => {
    var { padding: a } = i
    return o
      ? [r.height - a.bottom, a.top]
      : t === 'horizontal'
        ? [e.top + e.height - n.bottom, e.top + n.top]
        : [e.top + n.top, e.top + e.height - n.bottom]
  }),
  jr = (e, t, n, r) => {
    var i
    switch (t) {
      case 'xAxis':
        return WS(e, n, r)
      case 'yAxis':
        return KS(e, n, r)
      case 'zAxis':
        return (i = ec(e, n)) === null || i === void 0 ? void 0 : i.range
      case 'angleAxis':
        return Rh(e)
      case 'radiusAxis':
        return Bh(e, n)
      default:
        return
    }
  },
  bp = R([Ie, jr], Ao),
  Bn = R([Ie, Ir, zS, bp], oc)
R([Dr, rc, be], ES)
function wp(e, t) {
  return e.id < t.id ? -1 : e.id > t.id ? 1 : 0
}
var No = (e, t) => t,
  Do = (e, t, n) => n,
  YS = R(ho, No, Do, (e, t, n) =>
    e
      .filter((r) => r.orientation === t)
      .filter((r) => r.mirror === n)
      .sort(wp),
  ),
  US = R(po, No, Do, (e, t, n) =>
    e
      .filter((r) => r.orientation === t)
      .filter((r) => r.mirror === n)
      .sort(wp),
  ),
  Pp = (e, t) => ({ width: e.width, height: t.height }),
  XS = (e, t) => {
    var n = typeof t.width == 'number' ? t.width : Ar
    return { width: n, height: e.height }
  },
  GS = R(Oe, Tt, Pp),
  qS = (e, t, n) => {
    switch (t) {
      case 'top':
        return e.top
      case 'bottom':
        return n - e.bottom
      default:
        return 0
    }
  },
  ZS = (e, t, n) => {
    switch (t) {
      case 'left':
        return e.left
      case 'right':
        return n - e.right
      default:
        return 0
    }
  },
  QS = R(kt, Oe, YS, No, Do, (e, t, n, r, i) => {
    var o = {},
      a
    return (
      n.forEach((s) => {
        var l = Pp(t, s)
        a == null && (a = qS(t, r, e))
        var c = (r === 'top' && !i) || (r === 'bottom' && i)
        ;((o[s.id] = a - Number(c) * l.height), (a += (c ? -1 : 1) * l.height))
      }),
      o
    )
  }),
  JS = R(Ct, Oe, US, No, Do, (e, t, n, r, i) => {
    var o = {},
      a
    return (
      n.forEach((s) => {
        var l = XS(t, s)
        a == null && (a = ZS(t, r, e))
        var c = (r === 'left' && !i) || (r === 'right' && i)
        ;((o[s.id] = a - Number(c) * l.width), (a += (c ? -1 : 1) * l.width))
      }),
      o
    )
  }),
  eE = (e, t) => {
    var n = Tt(e, t)
    if (n != null) return QS(e, n.orientation, n.mirror)
  },
  tE = R([Oe, Tt, eE, (e, t) => t], (e, t, n, r) => {
    if (t != null) {
      var i = n?.[r]
      return i == null ? { x: e.left, y: 0 } : { x: e.left, y: i }
    }
  }),
  nE = (e, t) => {
    var n = Nt(e, t)
    if (n != null) return JS(e, n.orientation, n.mirror)
  },
  rE = R([Oe, Nt, nE, (e, t) => t], (e, t, n, r) => {
    if (t != null) {
      var i = n?.[r]
      return i == null ? { x: 0, y: e.top } : { x: i, y: e.top }
    }
  }),
  iE = R(Oe, Nt, (e, t) => {
    var n = typeof t.width == 'number' ? t.width : Ar
    return { width: n, height: e.height }
  }),
  Sp = (e, t, n, r) => {
    if (n != null) {
      var { allowDuplicatedCategory: i, type: o, dataKey: a } = n,
        s = ln(e, r),
        l = t.map((c) => c.value)
      if (a && s && o === 'category' && i && _d(l)) return l
    }
  },
  sc = R([he, To, Ie, be], Sp),
  Ep = (e, t, n, r) => {
    if (!(n == null || n.dataKey == null)) {
      var { type: i, scale: o } = n,
        a = ln(e, r)
      if (a && (i === 'number' || o !== 'auto')) return t.map((s) => s.value)
    }
  },
  cc = R([he, To, Nr, be], Ep),
  Eu = R([he, vS, Ir, Bn, sc, cc, jr, ac, be], (e, t, n, r, i, o, a, s, l) => {
    if (t == null) return null
    var c = ln(e, l)
    return {
      angle: t.angle,
      interval: t.interval,
      minTickGap: t.minTickGap,
      orientation: t.orientation,
      tick: t.tick,
      tickCount: t.tickCount,
      tickFormatter: t.tickFormatter,
      ticks: t.ticks,
      type: t.type,
      unit: t.unit,
      axisType: l,
      categoricalDomain: o,
      duplicateDomain: i,
      isCategorical: c,
      niceTicks: s,
      range: a,
      realScaleType: n,
      scale: r,
    }
  }),
  oE = (e, t, n, r, i, o, a, s, l) => {
    if (!(t == null || r == null)) {
      var c = ln(e, l),
        { type: u, ticks: f, tickCount: d } = t,
        h = n === 'scaleBand' && typeof r.bandwidth == 'function' ? r.bandwidth() / 2 : 2,
        g = u === 'category' && r.bandwidth ? r.bandwidth() / h : 0
      g = l === 'angleAxis' && o != null && o.length >= 2 ? Qe(o[0] - o[1]) * 2 * g : g
      var p = f || i
      if (p) {
        var x = p.map((y, w) => {
          var m = a ? a.indexOf(y) : y
          return { index: w, coordinate: r(m) + g, value: y, offset: g }
        })
        return x.filter((y) => !st(y.coordinate))
      }
      return c && s
        ? s.map((y, w) => ({ coordinate: r(y) + g, value: y, index: w, offset: g }))
        : r.ticks
          ? r.ticks(d).map((y) => ({ coordinate: r(y) + g, value: y, offset: g }))
          : r
              .domain()
              .map((y, w) => ({ coordinate: r(y) + g, value: a ? a[y] : y, index: w, offset: g }))
    }
  },
  _p = R([he, Nr, Ir, Bn, ac, jr, sc, cc, be], oE),
  aE = (e, t, n, r, i, o, a) => {
    if (!(t == null || n == null || r == null || r[0] === r[1])) {
      var s = ln(e, a),
        { tickCount: l } = t,
        c = 0
      return (
        (c = a === 'angleAxis' && r?.length >= 2 ? Qe(r[0] - r[1]) * 2 * c : c),
        s && o
          ? o.map((u, f) => ({ coordinate: n(u) + c, value: u, index: f, offset: c }))
          : n.ticks
            ? n.ticks(l).map((u) => ({ coordinate: n(u) + c, value: u, offset: c }))
            : n
                .domain()
                .map((u, f) => ({ coordinate: n(u) + c, value: i ? i[u] : u, index: f, offset: c }))
      )
    }
  },
  Ap = R([he, Nr, Bn, jr, sc, cc, be], aE),
  Op = R(Ie, Bn, (e, t) => {
    if (!(e == null || t == null)) return Bi(Bi({}, e), {}, { scale: t })
  }),
  sE = R([Ie, Ir, ic, bp], oc),
  cE = R(
    (e, t, n) => ec(e, n),
    sE,
    (e, t) => {
      if (!(e == null || t == null)) return Bi(Bi({}, e), {}, { scale: t })
    },
  ),
  lE = R([he, ho, po], (e, t, n) => {
    switch (e) {
      case 'horizontal':
        return t.some((r) => r.reversed) ? 'right-to-left' : 'left-to-right'
      case 'vertical':
        return n.some((r) => r.reversed) ? 'bottom-to-top' : 'top-to-bottom'
      case 'centric':
      case 'radial':
        return 'left-to-right'
      default:
        return
    }
  }),
  Cp = (e) => e.options.defaultTooltipEventType,
  kp = (e) => e.options.validateTooltipEventTypes
function Mp(e, t, n) {
  if (e == null) return t
  var r = e ? 'axis' : 'item'
  return n == null ? t : n.includes(r) ? r : t
}
function lc(e, t) {
  var n = Cp(e),
    r = kp(e)
  return Mp(t, n, r)
}
function uE(e) {
  return J((t) => lc(t, e))
}
var Tp = (e, t) => {
    var n,
      r = Number(t)
    if (!(st(r) || t == null))
      return r >= 0 ? (e == null || (n = e[r]) === null || n === void 0 ? void 0 : n.value) : void 0
  },
  fE = (e) => e.tooltip.settings,
  zt = { active: !1, index: null, dataKey: void 0, coordinate: void 0 },
  dE = {
    itemInteraction: { click: zt, hover: zt },
    axisInteraction: { click: zt, hover: zt },
    keyboardInteraction: zt,
    syncInteraction: {
      active: !1,
      index: null,
      dataKey: void 0,
      label: void 0,
      coordinate: void 0,
      sourceViewBox: void 0,
    },
    tooltipItemPayloads: [],
    settings: { shared: void 0, trigger: 'hover', axisId: 0, active: !1, defaultIndex: void 0 },
  },
  Np = Ve({
    name: 'tooltip',
    initialState: dE,
    reducers: {
      addTooltipEntrySettings: {
        reducer(e, t) {
          e.tooltipItemPayloads.push(Ne(t.payload))
        },
        prepare: Te(),
      },
      removeTooltipEntrySettings: {
        reducer(e, t) {
          var n = Ht(e).tooltipItemPayloads.indexOf(Ne(t.payload))
          n > -1 && e.tooltipItemPayloads.splice(n, 1)
        },
        prepare: Te(),
      },
      setTooltipSettingsState(e, t) {
        e.settings = t.payload
      },
      setActiveMouseOverItemIndex(e, t) {
        ;((e.syncInteraction.active = !1),
          (e.keyboardInteraction.active = !1),
          (e.itemInteraction.hover.active = !0),
          (e.itemInteraction.hover.index = t.payload.activeIndex),
          (e.itemInteraction.hover.dataKey = t.payload.activeDataKey),
          (e.itemInteraction.hover.coordinate = t.payload.activeCoordinate))
      },
      mouseLeaveChart(e) {
        ;((e.itemInteraction.hover.active = !1), (e.axisInteraction.hover.active = !1))
      },
      mouseLeaveItem(e) {
        e.itemInteraction.hover.active = !1
      },
      setActiveClickItemIndex(e, t) {
        ;((e.syncInteraction.active = !1),
          (e.itemInteraction.click.active = !0),
          (e.keyboardInteraction.active = !1),
          (e.itemInteraction.click.index = t.payload.activeIndex),
          (e.itemInteraction.click.dataKey = t.payload.activeDataKey),
          (e.itemInteraction.click.coordinate = t.payload.activeCoordinate))
      },
      setMouseOverAxisIndex(e, t) {
        ;((e.syncInteraction.active = !1),
          (e.axisInteraction.hover.active = !0),
          (e.keyboardInteraction.active = !1),
          (e.axisInteraction.hover.index = t.payload.activeIndex),
          (e.axisInteraction.hover.dataKey = t.payload.activeDataKey),
          (e.axisInteraction.hover.coordinate = t.payload.activeCoordinate))
      },
      setMouseClickAxisIndex(e, t) {
        ;((e.syncInteraction.active = !1),
          (e.keyboardInteraction.active = !1),
          (e.axisInteraction.click.active = !0),
          (e.axisInteraction.click.index = t.payload.activeIndex),
          (e.axisInteraction.click.dataKey = t.payload.activeDataKey),
          (e.axisInteraction.click.coordinate = t.payload.activeCoordinate))
      },
      setSyncInteraction(e, t) {
        e.syncInteraction = t.payload
      },
      setKeyboardInteraction(e, t) {
        ;((e.keyboardInteraction.active = t.payload.active),
          (e.keyboardInteraction.index = t.payload.activeIndex),
          (e.keyboardInteraction.coordinate = t.payload.activeCoordinate),
          (e.keyboardInteraction.dataKey = t.payload.activeDataKey))
      },
    },
  }),
  {
    addTooltipEntrySettings: hE,
    removeTooltipEntrySettings: pE,
    setTooltipSettingsState: vE,
    setActiveMouseOverItemIndex: Dp,
    mouseLeaveItem: gE,
    mouseLeaveChart: Ip,
    setActiveClickItemIndex: mE,
    setMouseOverAxisIndex: jp,
    setMouseClickAxisIndex: yE,
    setSyncInteraction: Wa,
    setKeyboardInteraction: Ka,
  } = Np.actions,
  xE = Np.reducer
function _u(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function ii(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? _u(Object(n), !0).forEach(function (r) {
          bE(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : _u(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function bE(e, t, n) {
  return (
    (t = wE(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function wE(e) {
  var t = PE(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function PE(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function SE(e, t, n) {
  return t === 'axis'
    ? n === 'click'
      ? e.axisInteraction.click
      : e.axisInteraction.hover
    : n === 'click'
      ? e.itemInteraction.click
      : e.itemInteraction.hover
}
function EE(e) {
  return e.index != null
}
var $p = (e, t, n, r) => {
    if (t == null) return zt
    var i = SE(e, t, n)
    if (i == null) return zt
    if (i.active) return i
    if (e.keyboardInteraction.active) return e.keyboardInteraction
    if (e.syncInteraction.active && e.syncInteraction.index != null) return e.syncInteraction
    var o = e.settings.active === !0
    if (EE(i)) {
      if (o) return ii(ii({}, i), {}, { active: !0 })
    } else if (r != null) return { active: !0, coordinate: void 0, dataKey: void 0, index: r }
    return ii(ii({}, zt), {}, { coordinate: i.coordinate })
  },
  uc = (e, t) => {
    var n = e?.index
    if (n == null) return null
    var r = Number(n)
    if (!Le(r)) return n
    var i = 0,
      o = 1 / 0
    return (t.length > 0 && (o = t.length - 1), String(Math.max(i, Math.min(r, o))))
  },
  Lp = (e, t, n, r, i, o, a, s) => {
    if (!(o == null || s == null)) {
      var l = a[0],
        c = l == null ? void 0 : s(l.positions, o)
      if (c != null) return c
      var u = i?.[Number(o)]
      if (u)
        switch (n) {
          case 'horizontal':
            return { x: u.coordinate, y: (r.top + t) / 2 }
          default:
            return { x: (r.left + e) / 2, y: u.coordinate }
        }
    }
  },
  zp = (e, t, n, r) => {
    if (t === 'axis') return e.tooltipItemPayloads
    if (e.tooltipItemPayloads.length === 0) return []
    var i
    return (
      n === 'hover' ? (i = e.itemInteraction.hover.dataKey) : (i = e.itemInteraction.click.dataKey),
      i == null && r != null
        ? [e.tooltipItemPayloads[0]]
        : e.tooltipItemPayloads.filter((o) => {
            var a
            return ((a = o.settings) === null || a === void 0 ? void 0 : a.dataKey) === i
          })
    )
  },
  $r = (e) => e.options.tooltipPayloadSearcher,
  Hn = (e) => e.tooltip
function Au(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Ou(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Au(Object(n), !0).forEach(function (r) {
          _E(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Au(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function _E(e, t, n) {
  return (
    (t = AE(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function AE(e) {
  var t = OE(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function OE(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function CE(e, t) {
  return e ?? t
}
var Rp = (e, t, n, r, i, o, a) => {
    if (!(t == null || o == null)) {
      var { chartData: s, computedData: l, dataStartIndex: c, dataEndIndex: u } = n,
        f = []
      return e.reduce((d, h) => {
        var g,
          { dataDefinedOnItem: p, settings: x } = h,
          y = CE(p, s),
          w = Array.isArray(y) ? Nd(y, c, u) : y,
          m = (g = x?.dataKey) !== null && g !== void 0 ? g : r,
          b = x?.nameKey,
          P
        if (
          (r && Array.isArray(w) && !Array.isArray(w[0]) && a === 'axis'
            ? (P = Ad(w, r, i))
            : (P = o(w, t, l, b)),
          Array.isArray(P))
        )
          P.forEach((_) => {
            var M = Ou(Ou({}, x), {}, { name: _.name, unit: _.unit, color: void 0, fill: void 0 })
            d.push(
              pl({
                tooltipEntrySettings: M,
                dataKey: _.dataKey,
                payload: _.payload,
                value: Ae(_.payload, _.dataKey),
                name: _.name,
              }),
            )
          })
        else {
          var S
          d.push(
            pl({
              tooltipEntrySettings: x,
              dataKey: m,
              payload: P,
              value: Ae(P, m),
              name: (S = Ae(P, b)) !== null && S !== void 0 ? S : x?.name,
            }),
          )
        }
        return d
      }, f)
    }
  },
  fc = R([Pe, he, Uh, Us, we], gp),
  kE = R([(e) => e.graphicalItems.cartesianItems, (e) => e.graphicalItems.polarItems], (e, t) => [
    ...e,
    ...t,
  ]),
  ME = R([we, Ln], Xh),
  Lr = R([kE, Pe, ME], qh, { memoizeOptions: { resultEqualityCheck: Mo } }),
  TE = R([Lr], (e) => e.filter(Js)),
  NE = R([Lr], Jh, { memoizeOptions: { resultEqualityCheck: Mo } }),
  Fn = R([NE, Ut], ep),
  DE = R([TE, Ut, Pe], Wh),
  dc = R([Fn, Pe, Lr], tp),
  Bp = R([Pe], nc),
  IE = R([Pe], (e) => e.allowDataOverflow),
  Hp = R([Bp, IE], Ah),
  jE = R([Lr], (e) => e.filter(Js)),
  $E = R([DE, jE, _o], rp),
  LE = R([$E, Ut, we, Hp], ip),
  zE = R([Lr], Qh),
  RE = R([Fn, Pe, zE, rc, we], sp, { memoizeOptions: { resultEqualityCheck: ko } }),
  BE = R([cp, we, Ln], Rn),
  HE = R([BE, we], fp),
  FE = R([lp, we, Ln], Rn),
  VE = R([FE, we], dp),
  WE = R([up, we, Ln], Rn),
  KE = R([WE, we], hp),
  YE = R([HE, KE, VE], Hi),
  UE = R([Pe, Bp, Hp, LE, RE, YE, he, we], pp),
  Fp = R([Pe, he, Fn, dc, _o, we, UE], vp),
  XE = R([Fp, Pe, fc], mp),
  GE = R([Pe, Fp, XE, we], yp),
  Vp = (e) => {
    var t = we(e),
      n = Ln(e),
      r = !1
    return jr(e, t, n, r)
  },
  Wp = R([Pe, Vp], Ao),
  Kp = R([Pe, fc, GE, Wp], oc),
  qE = R([he, dc, Pe, we], Sp),
  ZE = R([he, dc, Pe, we], Ep),
  QE = (e, t, n, r, i, o, a, s) => {
    if (t) {
      var { type: l } = t,
        c = ln(e, s)
      if (r) {
        var u = n === 'scaleBand' && r.bandwidth ? r.bandwidth() / 2 : 2,
          f = l === 'category' && r.bandwidth ? r.bandwidth() / u : 0
        return (
          (f = s === 'angleAxis' && i != null && i?.length >= 2 ? Qe(i[0] - i[1]) * 2 * f : f),
          c && a
            ? a.map((d, h) => ({ coordinate: r(d) + f, value: d, index: h, offset: f }))
            : r
                .domain()
                .map((d, h) => ({ coordinate: r(d) + f, value: o ? o[d] : d, index: h, offset: f }))
        )
      }
    }
  },
  Dt = R([he, Pe, fc, Kp, Vp, qE, ZE, we], QE),
  hc = R([Cp, kp, fE], (e, t, n) => Mp(n.shared, e, t)),
  Yp = (e) => e.tooltip.settings.trigger,
  pc = (e) => e.tooltip.settings.defaultIndex,
  Io = R([Hn, hc, Yp, pc], $p),
  hr = R([Io, Fn], uc),
  Up = R([Dt, hr], Tp),
  JE = R([Io], (e) => {
    if (e) return e.dataKey
  }),
  Xp = R([Hn, hc, Yp, pc], zp),
  e_ = R([Ct, kt, he, Oe, Dt, pc, Xp, $r], Lp),
  t_ = R([Io, e_], (e, t) => (e != null && e.coordinate ? e.coordinate : t)),
  n_ = R([Io], (e) => e.active),
  r_ = R([Xp, hr, Ut, Vh, Up, $r, hc], Rp)
R([r_], (e) => {
  if (e != null) {
    var t = e.map((n) => n.payload).filter((n) => n != null)
    return Array.from(new Set(t))
  }
})
function Cu(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function ku(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Cu(Object(n), !0).forEach(function (r) {
          i_(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Cu(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function i_(e, t, n) {
  return (
    (t = o_(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function o_(e) {
  var t = a_(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function a_(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var s_ = () => J(Pe),
  c_ = () => {
    var e = s_(),
      t = J(Dt),
      n = J(Kp)
    return bx(ku(ku({}, e), {}, { scale: n }), t)
  },
  l_ = () => J(Us),
  vc = (e, t) => t,
  Gp = (e, t, n) => n,
  gc = (e, t, n, r) => r,
  u_ = R(Dt, (e) => so(e, (t) => t.coordinate)),
  mc = R([Hn, vc, Gp, gc], $p),
  qp = R([mc, Fn], uc),
  f_ = (e, t, n) => {
    if (t != null) {
      var r = Hn(e)
      return t === 'axis'
        ? n === 'hover'
          ? r.axisInteraction.hover.dataKey
          : r.axisInteraction.click.dataKey
        : n === 'hover'
          ? r.itemInteraction.hover.dataKey
          : r.itemInteraction.click.dataKey
    }
  },
  Zp = R([Hn, vc, Gp, gc], zp),
  Fi = R([Ct, kt, he, Oe, Dt, gc, Zp, $r], Lp),
  d_ = R([mc, Fi], (e, t) => {
    var n
    return (n = e.coordinate) !== null && n !== void 0 ? n : t
  }),
  Qp = R(Dt, qp, Tp),
  h_ = R([Zp, qp, Ut, Vh, Qp, $r, vc], Rp),
  p_ = R([mc], (e) => ({ isActive: e.active, activeIndex: e.index })),
  v_ = (e, t, n, r, i, o, a, s) => {
    if (!(!e || !t || !r || !i || !o)) {
      var l = wx(e.chartX, e.chartY, t, n, s)
      if (l) {
        var c = Sx(l, t),
          u = ux(c, a, o, r, i),
          f = Px(t, o, u, l)
        return { activeIndex: String(u), activeCoordinate: f }
      }
    }
  }
function Ya() {
  return (
    (Ya = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Ya.apply(null, arguments)
  )
}
function Mu(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function oi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Mu(Object(n), !0).forEach(function (r) {
          g_(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Mu(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function g_(e, t, n) {
  return (
    (t = m_(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function m_(e) {
  var t = y_(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function y_(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function x_(e) {
  var {
      coordinate: t,
      payload: n,
      index: r,
      offset: i,
      tooltipAxisBandSize: o,
      layout: a,
      cursor: s,
      tooltipEventType: l,
      chartName: c,
    } = e,
    u = t,
    f = n,
    d = r
  if (!s || !u || (c !== 'ScatterChart' && l !== 'axis')) return null
  var h, g
  if (c === 'ScatterChart') ((h = u), (g = Ab))
  else if (c === 'BarChart') ((h = Ob(a, u, i, o)), (g = qd))
  else if (a === 'radial') {
    var { cx: p, cy: x, radius: y, startAngle: w, endAngle: m } = Zd(u)
    ;((h = { cx: p, cy: x, startAngle: w, endAngle: m, innerRadius: y, outerRadius: y }), (g = Jd))
  } else ((h = { points: cw(a, u, i) }), (g = Kd))
  var b = typeof s == 'object' && 'className' in s ? s.className : void 0,
    P = oi(
      oi(oi(oi({ stroke: '#ccc', pointerEvents: 'none' }, i), h), hs(s)),
      {},
      { payload: f, payloadIndex: d, className: le('recharts-tooltip-cursor', b) },
    )
  return v.isValidElement(s) ? v.cloneElement(s, P) : v.createElement(g, P)
}
function b_(e) {
  var t = c_(),
    n = Hd(),
    r = Fd(),
    i = l_()
  return v.createElement(
    x_,
    Ya({}, e, {
      coordinate: e.coordinate,
      index: e.index,
      payload: e.payload,
      offset: n,
      layout: r,
      tooltipAxisBandSize: t,
      chartName: i,
    }),
  )
}
var Jp = v.createContext(null),
  w_ = () => v.useContext(Jp),
  pr = new _y(),
  Ua = 'recharts.syncEvent.tooltip',
  Tu = 'recharts.syncEvent.brush'
function P_(e, t) {
  if (t) {
    var n = Number.parseInt(t, 10)
    if (!st(n)) return e?.[n]
  }
}
var S_ = {
    chartName: '',
    tooltipPayloadSearcher: void 0,
    eventEmitter: void 0,
    defaultTooltipEventType: 'axis',
  },
  ev = Ve({
    name: 'options',
    initialState: S_,
    reducers: {
      createEventEmitter: (e) => {
        e.eventEmitter == null && (e.eventEmitter = Symbol('rechartsEventEmitter'))
      },
    },
  }),
  E_ = ev.reducer,
  { createEventEmitter: __ } = ev.actions
function A_(e) {
  return e.tooltip.syncInteraction
}
var O_ = { chartData: void 0, computedData: void 0, dataStartIndex: 0, dataEndIndex: 0 },
  tv = Ve({
    name: 'chartData',
    initialState: O_,
    reducers: {
      setChartData(e, t) {
        if (((e.chartData = t.payload), t.payload == null)) {
          ;((e.dataStartIndex = 0), (e.dataEndIndex = 0))
          return
        }
        t.payload.length > 0 &&
          e.dataEndIndex !== t.payload.length - 1 &&
          (e.dataEndIndex = t.payload.length - 1)
      },
      setComputedData(e, t) {
        e.computedData = t.payload
      },
      setDataStartEndIndexes(e, t) {
        var { startIndex: n, endIndex: r } = t.payload
        ;(n != null && (e.dataStartIndex = n), r != null && (e.dataEndIndex = r))
      },
    },
  }),
  { setChartData: Nu, setDataStartEndIndexes: C_, setComputedData: P$ } = tv.actions,
  k_ = tv.reducer,
  M_ = ['x', 'y']
function Du(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function pn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Du(Object(n), !0).forEach(function (r) {
          T_(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Du(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function T_(e, t, n) {
  return (
    (t = N_(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function N_(e) {
  var t = D_(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function D_(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function I_(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = j_(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function j_(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var nv = () => {}
function $_() {
  var e = J(Xs),
    t = J(Gs),
    n = pe(),
    r = J($h),
    i = J(Dt),
    o = Fd(),
    a = Or(),
    s = J((l) => l.rootProps.className)
  v.useEffect(() => {
    if (e == null) return nv
    var l = (c, u, f) => {
      if (t !== f && e === c) {
        if (r === 'index') {
          var d
          if (
            a &&
            u !== null &&
            u !== void 0 &&
            (d = u.payload) !== null &&
            d !== void 0 &&
            d.coordinate &&
            u.payload.sourceViewBox
          ) {
            var h = u.payload.coordinate,
              { x: g, y: p } = h,
              x = I_(h, M_),
              { x: y, y: w, width: m, height: b } = u.payload.sourceViewBox,
              P = pn(
                pn({}, x),
                {},
                {
                  x: a.x + (m ? (g - y) / m : 0) * a.width,
                  y: a.y + (b ? (p - w) / b : 0) * a.height,
                },
              )
            n(pn(pn({}, u), {}, { payload: pn(pn({}, u.payload), {}, { coordinate: P }) }))
          } else n(u)
          return
        }
        if (i != null) {
          var S
          if (typeof r == 'function') {
            var _ = {
                activeTooltipIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
                isTooltipActive: u.payload.active,
                activeIndex: u.payload.index == null ? void 0 : Number(u.payload.index),
                activeLabel: u.payload.label,
                activeDataKey: u.payload.dataKey,
                activeCoordinate: u.payload.coordinate,
              },
              M = r(i, _)
            S = i[M]
          } else r === 'value' && (S = i.find((A) => String(A.value) === u.payload.label))
          var { coordinate: T } = u.payload
          if (S == null || u.payload.active === !1 || T == null || a == null) {
            n(
              Wa({
                active: !1,
                coordinate: void 0,
                dataKey: void 0,
                index: null,
                label: void 0,
                sourceViewBox: void 0,
              }),
            )
            return
          }
          var { x: F, y: D } = T,
            k = Math.min(F, a.x + a.width),
            $ = Math.min(D, a.y + a.height),
            E = {
              x: o === 'horizontal' ? S.coordinate : k,
              y: o === 'horizontal' ? $ : S.coordinate,
            },
            O = Wa({
              active: u.payload.active,
              coordinate: E,
              dataKey: u.payload.dataKey,
              index: String(S.index),
              label: u.payload.label,
              sourceViewBox: u.payload.sourceViewBox,
            })
          n(O)
        }
      }
    }
    return (
      pr.on(Ua, l),
      () => {
        pr.off(Ua, l)
      }
    )
  }, [s, n, t, e, r, i, o, a])
}
function L_() {
  var e = J(Xs),
    t = J(Gs),
    n = pe()
  v.useEffect(() => {
    if (e == null) return nv
    var r = (i, o, a) => {
      t !== a && e === i && n(C_(o))
    }
    return (
      pr.on(Tu, r),
      () => {
        pr.off(Tu, r)
      }
    )
  }, [n, t, e])
}
function z_() {
  var e = pe()
  ;(v.useEffect(() => {
    e(__())
  }, [e]),
    $_(),
    L_())
}
function R_(e, t, n, r, i, o) {
  var a = J((h) => f_(h, e, t)),
    s = J(Gs),
    l = J(Xs),
    c = J($h),
    u = J(A_),
    f = u?.active,
    d = Or()
  v.useEffect(() => {
    if (!f && l != null && s != null) {
      var h = Wa({
        active: o,
        coordinate: n,
        dataKey: a,
        index: i,
        label: typeof r == 'number' ? String(r) : r,
        sourceViewBox: d,
      })
      pr.emit(Ua, l, h, s)
    }
  }, [f, n, a, i, r, s, l, c, o, d])
}
function Iu(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function ju(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Iu(Object(n), !0).forEach(function (r) {
          B_(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Iu(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function B_(e, t, n) {
  return (
    (t = H_(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function H_(e) {
  var t = F_(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function F_(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function V_(e) {
  return e.dataKey
}
function W_(e, t) {
  return v.isValidElement(e)
    ? v.cloneElement(e, t)
    : typeof e == 'function'
      ? v.createElement(e, t)
      : v.createElement(ib, t)
}
var $u = [],
  K_ = {
    allowEscapeViewBox: { x: !1, y: !1 },
    animationDuration: 400,
    animationEasing: 'ease',
    axisId: 0,
    contentStyle: {},
    cursor: !0,
    filterNull: !0,
    isAnimationActive: !$n.isSsr,
    itemSorter: 'name',
    itemStyle: {},
    labelStyle: {},
    offset: 10,
    reverseDirection: { x: !1, y: !1 },
    separator: ' : ',
    trigger: 'hover',
    useTranslate3d: !1,
    wrapperStyle: {},
  }
function S$(e) {
  var t = Ke(e, K_),
    {
      active: n,
      allowEscapeViewBox: r,
      animationDuration: i,
      animationEasing: o,
      content: a,
      filterNull: s,
      isAnimationActive: l,
      offset: c,
      payloadUniqBy: u,
      position: f,
      reverseDirection: d,
      useTranslate3d: h,
      wrapperStyle: g,
      cursor: p,
      shared: x,
      trigger: y,
      defaultIndex: w,
      portal: m,
      axisId: b,
    } = t,
    P = pe(),
    S = typeof w == 'number' ? String(w) : w
  v.useEffect(() => {
    P(vE({ shared: x, trigger: y, axisId: b, active: n, defaultIndex: S }))
  }, [P, x, y, b, n, S])
  var _ = Or(),
    M = Wd(),
    T = uE(x),
    { activeIndex: F, isActive: D } = J((G) => p_(G, T, y, S)),
    k = J((G) => h_(G, T, y, S)),
    $ = J((G) => Qp(G, T, y, S)),
    E = J((G) => d_(G, T, y, S)),
    O = k,
    A = w_(),
    C = n ?? D,
    [N, I] = Md([O, C]),
    H = T === 'axis' ? $ : void 0
  R_(T, y, E, H, F, C)
  var V = m ?? A
  if (V == null) return null
  var B = O ?? $u
  ;(C || (B = $u),
    s &&
      B.length &&
      (B = Cd(
        O.filter((G) => G.value != null && (G.hide !== !0 || t.includeHidden)),
        u,
        V_,
      )))
  var Y = B.length > 0,
    K = v.createElement(
      fb,
      {
        allowEscapeViewBox: r,
        animationDuration: i,
        animationEasing: o,
        isAnimationActive: l,
        active: C,
        coordinate: E,
        hasPayload: Y,
        offset: c,
        position: f,
        reverseDirection: d,
        useTranslate3d: h,
        viewBox: _,
        wrapperStyle: g,
        lastBoundingBox: N,
        innerRef: I,
        hasPortalFromProps: !!m,
      },
      W_(
        a,
        ju(
          ju({}, t),
          {},
          { payload: B, label: H, active: C, coordinate: E, accessibilityLayer: M },
        ),
      ),
    )
  return v.createElement(
    v.Fragment,
    null,
    id.createPortal(K, V),
    C &&
      v.createElement(b_, { cursor: p, tooltipEventType: T, coordinate: E, payload: O, index: F }),
  )
}
var rv = (e) => null
rv.displayName = 'Cell'
function Y_(e, t, n) {
  return (
    (t = U_(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function U_(e) {
  var t = X_(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function X_(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
class G_ {
  constructor(t) {
    ;(Y_(this, 'cache', new Map()), (this.maxSize = t))
  }
  get(t) {
    var n = this.cache.get(t)
    return (n !== void 0 && (this.cache.delete(t), this.cache.set(t, n)), n)
  }
  set(t, n) {
    if (this.cache.has(t)) this.cache.delete(t)
    else if (this.cache.size >= this.maxSize) {
      var r = this.cache.keys().next().value
      this.cache.delete(r)
    }
    this.cache.set(t, n)
  }
  clear() {
    this.cache.clear()
  }
  size() {
    return this.cache.size
  }
}
function Lu(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function q_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Lu(Object(n), !0).forEach(function (r) {
          Z_(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Lu(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Z_(e, t, n) {
  return (
    (t = Q_(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function Q_(e) {
  var t = J_(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function J_(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var eA = { cacheSize: 2e3, enableCache: !0 },
  iv = q_({}, eA),
  zu = new G_(iv.cacheSize),
  tA = {
    position: 'absolute',
    top: '-20000px',
    left: 0,
    padding: 0,
    margin: 0,
    border: 'none',
    whiteSpace: 'pre',
  },
  Ru = 'recharts_measurement_span'
function nA(e, t) {
  var n = t.fontSize || '',
    r = t.fontFamily || '',
    i = t.fontWeight || '',
    o = t.fontStyle || '',
    a = t.letterSpacing || '',
    s = t.textTransform || ''
  return ''
    .concat(e, '|')
    .concat(n, '|')
    .concat(r, '|')
    .concat(i, '|')
    .concat(o, '|')
    .concat(a, '|')
    .concat(s)
}
var Bu = (e, t) => {
    try {
      var n = document.getElementById(Ru)
      ;(n ||
        ((n = document.createElement('span')),
        n.setAttribute('id', Ru),
        n.setAttribute('aria-hidden', 'true'),
        document.body.appendChild(n)),
        Object.assign(n.style, tA, t),
        (n.textContent = ''.concat(e)))
      var r = n.getBoundingClientRect()
      return { width: r.width, height: r.height }
    } catch {
      return { width: 0, height: 0 }
    }
  },
  ir = function (t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    if (t == null || $n.isSsr) return { width: 0, height: 0 }
    if (!iv.enableCache) return Bu(t, n)
    var r = nA(t, n),
      i = zu.get(r)
    if (i) return i
    var o = Bu(t, n)
    return (zu.set(r, o), o)
  },
  Hu = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
  Fu = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
  rA = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/,
  iA = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/,
  ov = {
    cm: 96 / 2.54,
    mm: 96 / 25.4,
    pt: 96 / 72,
    pc: 96 / 6,
    in: 96,
    Q: 96 / (2.54 * 40),
    px: 1,
  },
  oA = Object.keys(ov),
  gn = 'NaN'
function aA(e, t) {
  return e * ov[t]
}
class je {
  static parse(t) {
    var n,
      [, r, i] = (n = iA.exec(t)) !== null && n !== void 0 ? n : []
    return new je(parseFloat(r), i ?? '')
  }
  constructor(t, n) {
    ;((this.num = t),
      (this.unit = n),
      (this.num = t),
      (this.unit = n),
      st(t) && (this.unit = ''),
      n !== '' && !rA.test(n) && ((this.num = NaN), (this.unit = '')),
      oA.includes(n) && ((this.num = aA(t, n)), (this.unit = 'px')))
  }
  add(t) {
    return this.unit !== t.unit ? new je(NaN, '') : new je(this.num + t.num, this.unit)
  }
  subtract(t) {
    return this.unit !== t.unit ? new je(NaN, '') : new je(this.num - t.num, this.unit)
  }
  multiply(t) {
    return this.unit !== '' && t.unit !== '' && this.unit !== t.unit
      ? new je(NaN, '')
      : new je(this.num * t.num, this.unit || t.unit)
  }
  divide(t) {
    return this.unit !== '' && t.unit !== '' && this.unit !== t.unit
      ? new je(NaN, '')
      : new je(this.num / t.num, this.unit || t.unit)
  }
  toString() {
    return ''.concat(this.num).concat(this.unit)
  }
  isNaN() {
    return st(this.num)
  }
}
function av(e) {
  if (e.includes(gn)) return gn
  for (var t = e; t.includes('*') || t.includes('/'); ) {
    var n,
      [, r, i, o] = (n = Hu.exec(t)) !== null && n !== void 0 ? n : [],
      a = je.parse(r ?? ''),
      s = je.parse(o ?? ''),
      l = i === '*' ? a.multiply(s) : a.divide(s)
    if (l.isNaN()) return gn
    t = t.replace(Hu, l.toString())
  }
  for (; t.includes('+') || /.-\d+(?:\.\d+)?/.test(t); ) {
    var c,
      [, u, f, d] = (c = Fu.exec(t)) !== null && c !== void 0 ? c : [],
      h = je.parse(u ?? ''),
      g = je.parse(d ?? ''),
      p = f === '+' ? h.add(g) : h.subtract(g)
    if (p.isNaN()) return gn
    t = t.replace(Fu, p.toString())
  }
  return t
}
var Vu = /\(([^()]*)\)/
function sA(e) {
  for (var t = e, n; (n = Vu.exec(t)) != null; ) {
    var [, r] = n
    t = t.replace(Vu, av(r))
  }
  return t
}
function cA(e) {
  var t = e.replace(/\s+/g, '')
  return ((t = sA(t)), (t = av(t)), t)
}
function lA(e) {
  try {
    return cA(e)
  } catch {
    return gn
  }
}
function sa(e) {
  var t = lA(e.slice(5, -1))
  return t === gn ? '' : t
}
var uA = [
    'x',
    'y',
    'lineHeight',
    'capHeight',
    'scaleToFit',
    'textAnchor',
    'verticalAnchor',
    'fill',
  ],
  fA = ['dx', 'dy', 'angle', 'className', 'breakAll']
function Xa() {
  return (
    (Xa = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Xa.apply(null, arguments)
  )
}
function Wu(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = dA(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function dA(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var sv = /[ \f\n\r\t\v\u2028\u2029]+/,
  cv = (e) => {
    var { children: t, breakAll: n, style: r } = e
    try {
      var i = []
      ge(t) || (n ? (i = t.toString().split('')) : (i = t.toString().split(sv)))
      var o = i.map((s) => ({ word: s, width: ir(s, r).width })),
        a = n ? 0 : ir('', r).width
      return { wordsWithComputedWidth: o, spaceWidth: a }
    } catch {
      return null
    }
  },
  hA = (e, t, n, r, i) => {
    var { maxLines: o, children: a, style: s, breakAll: l } = e,
      c = te(o),
      u = a,
      f = function () {
        var D = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
        return D.reduce((k, $) => {
          var { word: E, width: O } = $,
            A = k[k.length - 1]
          if (A && (r == null || i || A.width + O + n < Number(r)))
            (A.words.push(E), (A.width += O + n))
          else {
            var C = { words: [E], width: O }
            k.push(C)
          }
          return k
        }, [])
      },
      d = f(t),
      h = (F) => F.reduce((D, k) => (D.width > k.width ? D : k))
    if (!c || i) return d
    var g = d.length > o || h(d).width > Number(r)
    if (!g) return d
    for (
      var p = '',
        x = (F) => {
          var D = u.slice(0, F),
            k = cv({ breakAll: l, style: s, children: D + p }).wordsWithComputedWidth,
            $ = f(k),
            E = $.length > o || h($).width > Number(r)
          return [E, $]
        },
        y = 0,
        w = u.length - 1,
        m = 0,
        b;
      y <= w && m <= u.length - 1;

    ) {
      var P = Math.floor((y + w) / 2),
        S = P - 1,
        [_, M] = x(S),
        [T] = x(P)
      if ((!_ && !T && (y = P + 1), _ && T && (w = P - 1), !_ && T)) {
        b = M
        break
      }
      m++
    }
    return b || d
  },
  Ku = (e) => {
    var t = ge(e) ? [] : e.toString().split(sv)
    return [{ words: t }]
  },
  pA = (e) => {
    var { width: t, scaleToFit: n, children: r, style: i, breakAll: o, maxLines: a } = e
    if ((t || n) && !$n.isSsr) {
      var s,
        l,
        c = cv({ breakAll: o, children: r, style: i })
      if (c) {
        var { wordsWithComputedWidth: u, spaceWidth: f } = c
        ;((s = u), (l = f))
      } else return Ku(r)
      return hA({ breakAll: o, children: r, maxLines: a, style: i }, s, l, t, n)
    }
    return Ku(r)
  },
  Yu = '#808080',
  yc = v.forwardRef((e, t) => {
    var {
        x: n = 0,
        y: r = 0,
        lineHeight: i = '1em',
        capHeight: o = '0.71em',
        scaleToFit: a = !1,
        textAnchor: s = 'start',
        verticalAnchor: l = 'end',
        fill: c = Yu,
      } = e,
      u = Wu(e, uA),
      f = v.useMemo(
        () =>
          pA({
            breakAll: u.breakAll,
            children: u.children,
            maxLines: u.maxLines,
            scaleToFit: a,
            style: u.style,
            width: u.width,
          }),
        [u.breakAll, u.children, u.maxLines, a, u.style, u.width],
      ),
      { dx: d, dy: h, angle: g, className: p, breakAll: x } = u,
      y = Wu(u, fA)
    if (!dt(n) || !dt(r) || f.length === 0) return null
    var w = n + (te(d) ? d : 0),
      m = r + (te(h) ? h : 0),
      b
    switch (l) {
      case 'start':
        b = sa('calc('.concat(o, ')'))
        break
      case 'middle':
        b = sa(
          'calc('
            .concat((f.length - 1) / 2, ' * -')
            .concat(i, ' + (')
            .concat(o, ' / 2))'),
        )
        break
      default:
        b = sa('calc('.concat(f.length - 1, ' * -').concat(i, ')'))
        break
    }
    var P = []
    if (a) {
      var S = f[0].width,
        { width: _ } = u
      P.push('scale('.concat(te(_) ? _ / S : 1, ')'))
    }
    return (
      g && P.push('rotate('.concat(g, ', ').concat(w, ', ').concat(m, ')')),
      P.length && (y.transform = P.join(' ')),
      v.createElement(
        'text',
        Xa({}, et(y), {
          ref: t,
          x: w,
          y: m,
          className: le('recharts-text', p),
          textAnchor: s,
          fill: c.includes('url') ? Yu : c,
        }),
        f.map((M, T) => {
          var F = M.words.join(x ? '' : ' ')
          return v.createElement(
            'tspan',
            { x: w, dy: T === 0 ? b : i, key: ''.concat(F, '-').concat(T) },
            F,
          )
        }),
      )
    )
  })
yc.displayName = 'Text'
var vA = ['labelRef']
function gA(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = mA(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function mA(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function Uu(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function ve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Uu(Object(n), !0).forEach(function (r) {
          yA(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Uu(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function yA(e, t, n) {
  return (
    (t = xA(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function xA(e) {
  var t = bA(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function bA(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function yt() {
  return (
    (yt = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    yt.apply(null, arguments)
  )
}
var lv = v.createContext(null),
  wA = (e) => {
    var { x: t, y: n, width: r, height: i, children: o } = e,
      a = v.useMemo(() => ({ x: t, y: n, width: r, height: i }), [t, n, r, i])
    return v.createElement(lv.Provider, { value: a }, o)
  },
  uv = () => {
    var e = v.useContext(lv),
      t = Or()
    return e || t
  },
  PA = v.createContext(null),
  SA = () => {
    var e = v.useContext(PA),
      t = J(Hh)
    return e || t
  },
  EA = (e) => {
    var { value: t, formatter: n } = e,
      r = ge(e.children) ? t : e.children
    return typeof n == 'function' ? n(r) : r
  },
  xc = (e) => e != null && typeof e == 'function',
  _A = (e, t) => {
    var n = Qe(t - e),
      r = Math.min(Math.abs(t - e), 360)
    return n * r
  },
  AA = (e, t, n, r, i) => {
    var { offset: o, className: a } = e,
      {
        cx: s,
        cy: l,
        innerRadius: c,
        outerRadius: u,
        startAngle: f,
        endAngle: d,
        clockWise: h,
      } = i,
      g = (c + u) / 2,
      p = _A(f, d),
      x = p >= 0 ? 1 : -1,
      y,
      w
    switch (t) {
      case 'insideStart':
        ;((y = f + x * o), (w = h))
        break
      case 'insideEnd':
        ;((y = d - x * o), (w = !h))
        break
      case 'end':
        ;((y = d + x * o), (w = h))
        break
      default:
        throw new Error('Unsupported position '.concat(t))
    }
    w = p <= 0 ? w : !w
    var m = _e(s, l, g, y),
      b = _e(s, l, g, y + (w ? 1 : -1) * 359),
      P = 'M'
        .concat(m.x, ',')
        .concat(
          m.y,
          `
    A`,
        )
        .concat(g, ',')
        .concat(g, ',0,1,')
        .concat(
          w ? 0 : 1,
          `,
    `,
        )
        .concat(b.x, ',')
        .concat(b.y),
      S = ge(e.id) ? cr('recharts-radial-line-') : e.id
    return v.createElement(
      'text',
      yt({}, r, { dominantBaseline: 'central', className: le('recharts-radial-bar-label', a) }),
      v.createElement('defs', null, v.createElement('path', { id: S, d: P })),
      v.createElement('textPath', { xlinkHref: '#'.concat(S) }, n),
    )
  },
  OA = (e, t, n) => {
    var { cx: r, cy: i, innerRadius: o, outerRadius: a, startAngle: s, endAngle: l } = e,
      c = (s + l) / 2
    if (n === 'outside') {
      var { x: u, y: f } = _e(r, i, a + t, c)
      return { x: u, y: f, textAnchor: u >= r ? 'start' : 'end', verticalAnchor: 'middle' }
    }
    if (n === 'center') return { x: r, y: i, textAnchor: 'middle', verticalAnchor: 'middle' }
    if (n === 'centerTop') return { x: r, y: i, textAnchor: 'middle', verticalAnchor: 'start' }
    if (n === 'centerBottom') return { x: r, y: i, textAnchor: 'middle', verticalAnchor: 'end' }
    var d = (o + a) / 2,
      { x: h, y: g } = _e(r, i, d, c)
    return { x: h, y: g, textAnchor: 'middle', verticalAnchor: 'middle' }
  },
  fv = (e) => 'cx' in e && te(e.cx),
  CA = (e, t) => {
    var { parentViewBox: n, offset: r, position: i } = e,
      o
    n != null && !fv(n) && (o = n)
    var { x: a, y: s, width: l, height: c } = t,
      u = c >= 0 ? 1 : -1,
      f = u * r,
      d = u > 0 ? 'end' : 'start',
      h = u > 0 ? 'start' : 'end',
      g = l >= 0 ? 1 : -1,
      p = g * r,
      x = g > 0 ? 'end' : 'start',
      y = g > 0 ? 'start' : 'end'
    if (i === 'top') {
      var w = { x: a + l / 2, y: s - u * r, textAnchor: 'middle', verticalAnchor: d }
      return ve(ve({}, w), o ? { height: Math.max(s - o.y, 0), width: l } : {})
    }
    if (i === 'bottom') {
      var m = { x: a + l / 2, y: s + c + f, textAnchor: 'middle', verticalAnchor: h }
      return ve(ve({}, m), o ? { height: Math.max(o.y + o.height - (s + c), 0), width: l } : {})
    }
    if (i === 'left') {
      var b = { x: a - p, y: s + c / 2, textAnchor: x, verticalAnchor: 'middle' }
      return ve(ve({}, b), o ? { width: Math.max(b.x - o.x, 0), height: c } : {})
    }
    if (i === 'right') {
      var P = { x: a + l + p, y: s + c / 2, textAnchor: y, verticalAnchor: 'middle' }
      return ve(ve({}, P), o ? { width: Math.max(o.x + o.width - P.x, 0), height: c } : {})
    }
    var S = o ? { width: l, height: c } : {}
    return i === 'insideLeft'
      ? ve({ x: a + p, y: s + c / 2, textAnchor: y, verticalAnchor: 'middle' }, S)
      : i === 'insideRight'
        ? ve({ x: a + l - p, y: s + c / 2, textAnchor: x, verticalAnchor: 'middle' }, S)
        : i === 'insideTop'
          ? ve({ x: a + l / 2, y: s + f, textAnchor: 'middle', verticalAnchor: h }, S)
          : i === 'insideBottom'
            ? ve({ x: a + l / 2, y: s + c - f, textAnchor: 'middle', verticalAnchor: d }, S)
            : i === 'insideTopLeft'
              ? ve({ x: a + p, y: s + f, textAnchor: y, verticalAnchor: h }, S)
              : i === 'insideTopRight'
                ? ve({ x: a + l - p, y: s + f, textAnchor: x, verticalAnchor: h }, S)
                : i === 'insideBottomLeft'
                  ? ve({ x: a + p, y: s + c - f, textAnchor: y, verticalAnchor: d }, S)
                  : i === 'insideBottomRight'
                    ? ve({ x: a + l - p, y: s + c - f, textAnchor: x, verticalAnchor: d }, S)
                    : i && typeof i == 'object' && (te(i.x) || sr(i.x)) && (te(i.y) || sr(i.y))
                      ? ve(
                          {
                            x: a + Wt(i.x, l),
                            y: s + Wt(i.y, c),
                            textAnchor: 'end',
                            verticalAnchor: 'end',
                          },
                          S,
                        )
                      : ve(
                          {
                            x: a + l / 2,
                            y: s + c / 2,
                            textAnchor: 'middle',
                            verticalAnchor: 'middle',
                          },
                          S,
                        )
  },
  kA = { offset: 5 }
function Lt(e) {
  var t = Ke(e, kA),
    {
      viewBox: n,
      position: r,
      value: i,
      children: o,
      content: a,
      className: s = '',
      textBreakAll: l,
      labelRef: c,
    } = t,
    u = SA(),
    f = uv(),
    d = r === 'center' ? f : (u ?? f),
    h = n || d
  if (!h || (ge(i) && ge(o) && !v.isValidElement(a) && typeof a != 'function')) return null
  var g = ve(ve({}, t), {}, { viewBox: h })
  if (v.isValidElement(a)) {
    var { labelRef: p } = g,
      x = gA(g, vA)
    return v.cloneElement(a, x)
  }
  var y
  if (typeof a == 'function') {
    if (((y = v.createElement(a, g)), v.isValidElement(y))) return y
  } else y = EA(t)
  var w = fv(h),
    m = et(t)
  if (w && (r === 'insideStart' || r === 'insideEnd' || r === 'end')) return AA(t, r, y, m, h)
  var b = w ? OA(h, t.offset, t.position) : CA(t, h)
  return v.createElement(
    yc,
    yt({ ref: c, className: le('recharts-label', s) }, m, b, { breakAll: l }),
    y,
  )
}
Lt.displayName = 'Label'
var MA = (e, t, n) => {
  if (!e) return null
  var r = { viewBox: t, labelRef: n }
  return e === !0
    ? v.createElement(Lt, yt({ key: 'label-implicit' }, r))
    : dt(e)
      ? v.createElement(Lt, yt({ key: 'label-implicit', value: e }, r))
      : v.isValidElement(e)
        ? e.type === Lt
          ? v.cloneElement(e, ve({ key: 'label-implicit' }, r))
          : v.createElement(Lt, yt({ key: 'label-implicit', content: e }, r))
        : xc(e)
          ? v.createElement(Lt, yt({ key: 'label-implicit', content: e }, r))
          : e && typeof e == 'object'
            ? v.createElement(Lt, yt({}, e, { key: 'label-implicit' }, r))
            : null
}
function TA(e) {
  var { label: t, labelRef: n } = e,
    r = uv()
  return MA(t, r, n) || null
}
var NA = ['valueAccessor'],
  DA = ['dataKey', 'clockWise', 'id', 'textBreakAll']
function Vi() {
  return (
    (Vi = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Vi.apply(null, arguments)
  )
}
function Xu(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = IA(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function IA(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var jA = (e) => (Array.isArray(e.value) ? Ay(e.value) : e.value),
  dv = v.createContext(void 0),
  $A = dv.Provider,
  hv = v.createContext(void 0)
hv.Provider
function LA() {
  return v.useContext(dv)
}
function zA() {
  return v.useContext(hv)
}
function vi(e) {
  var { valueAccessor: t = jA } = e,
    n = Xu(e, NA),
    { dataKey: r, clockWise: i, id: o, textBreakAll: a } = n,
    s = Xu(n, DA),
    l = LA(),
    c = zA(),
    u = l || c
  return !u || !u.length
    ? null
    : v.createElement(
        St,
        { className: 'recharts-label-list' },
        u.map((f, d) => {
          var h,
            g = ge(r) ? t(f, d) : Ae(f && f.payload, r),
            p = ge(o) ? {} : { id: ''.concat(o, '-').concat(d) }
          return v.createElement(
            Lt,
            Vi({ key: 'label-'.concat(d) }, et(f), s, p, {
              fill: (h = n.fill) !== null && h !== void 0 ? h : f.fill,
              parentViewBox: f.parentViewBox,
              value: g,
              textBreakAll: a,
              viewBox: f.viewBox,
              index: d,
            }),
          )
        }),
      )
}
vi.displayName = 'LabelList'
function RA(e) {
  var { label: t } = e
  return t
    ? t === !0
      ? v.createElement(vi, { key: 'labelList-implicit' })
      : v.isValidElement(t) || xc(t)
        ? v.createElement(vi, { key: 'labelList-implicit', content: t })
        : typeof t == 'object'
          ? v.createElement(vi, Vi({ key: 'labelList-implicit' }, t, { type: String(t.type) }))
          : null
    : null
}
var BA = { radiusAxis: {}, angleAxis: {} },
  pv = Ve({
    name: 'polarAxis',
    initialState: BA,
    reducers: {
      addRadiusAxis(e, t) {
        e.radiusAxis[t.payload.id] = Ne(t.payload)
      },
      removeRadiusAxis(e, t) {
        delete e.radiusAxis[t.payload.id]
      },
      addAngleAxis(e, t) {
        e.angleAxis[t.payload.id] = Ne(t.payload)
      },
      removeAngleAxis(e, t) {
        delete e.angleAxis[t.payload.id]
      },
    },
  }),
  { addRadiusAxis: E$, removeRadiusAxis: _$, addAngleAxis: A$, removeAngleAxis: O$ } = pv.actions,
  HA = pv.reducer,
  Gu = (e) => (typeof e == 'string' ? e : e ? e.displayName || e.name || 'Component' : ''),
  qu = null,
  ca = null,
  vv = (e) => {
    if (e === qu && Array.isArray(ca)) return ca
    var t = []
    return (
      v.Children.forEach(e, (n) => {
        ge(n) || (xy.isFragment(n) ? (t = t.concat(vv(n.props.children))) : t.push(n))
      }),
      (ca = t),
      (qu = e),
      t
    )
  }
function FA(e, t) {
  var n = [],
    r = []
  return (
    Array.isArray(t) ? (r = t.map((i) => Gu(i))) : (r = [Gu(t)]),
    vv(e).forEach((i) => {
      var o = wn(i, 'type.displayName') || wn(i, 'type.name')
      r.indexOf(o) !== -1 && n.push(i)
    }),
    n
  )
}
function Zu(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Qu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Zu(Object(n), !0).forEach(function (r) {
          VA(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Zu(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function VA(e, t, n) {
  return (
    (t = WA(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function WA(e) {
  var t = KA(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function KA(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function Wi() {
  return (
    (Wi = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Wi.apply(null, arguments)
  )
}
var Ju = (e, t, n, r, i) => {
    var o = n - r,
      a
    return (
      (a = 'M '.concat(e, ',').concat(t)),
      (a += 'L '.concat(e + n, ',').concat(t)),
      (a += 'L '.concat(e + n - o / 2, ',').concat(t + i)),
      (a += 'L '.concat(e + n - o / 2 - r, ',').concat(t + i)),
      (a += 'L '.concat(e, ',').concat(t, ' Z')),
      a
    )
  },
  YA = {
    x: 0,
    y: 0,
    upperWidth: 0,
    lowerWidth: 0,
    height: 0,
    isUpdateAnimationActive: !1,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: 'ease',
  },
  UA = (e) => {
    var t = Ke(e, YA),
      { x: n, y: r, upperWidth: i, lowerWidth: o, height: a, className: s } = t,
      {
        animationEasing: l,
        animationDuration: c,
        animationBegin: u,
        isUpdateAnimationActive: f,
      } = t,
      d = v.useRef(null),
      [h, g] = v.useState(-1),
      p = v.useRef(i),
      x = v.useRef(o),
      y = v.useRef(a),
      w = v.useRef(n),
      m = v.useRef(r),
      b = Os(e, 'trapezoid-')
    if (
      (v.useEffect(() => {
        if (d.current && d.current.getTotalLength)
          try {
            var E = d.current.getTotalLength()
            E && g(E)
          } catch {}
      }, []),
      n !== +n || r !== +r || i !== +i || o !== +o || a !== +a || (i === 0 && o === 0) || a === 0)
    )
      return null
    var P = le('recharts-trapezoid', s)
    if (!f)
      return v.createElement(
        'g',
        null,
        v.createElement('path', Wi({}, et(t), { className: P, d: Ju(n, r, i, o, a) })),
      )
    var S = p.current,
      _ = x.current,
      M = y.current,
      T = w.current,
      F = m.current,
      D = '0px '.concat(h === -1 ? 1 : h, 'px'),
      k = ''.concat(h, 'px 0px'),
      $ = Yd(['strokeDasharray'], c, l)
    return v.createElement(
      As,
      { animationId: b, key: b, canBegin: h > 0, duration: c, easing: l, isActive: f, begin: u },
      (E) => {
        var O = gt(S, i, E),
          A = gt(_, o, E),
          C = gt(M, a, E),
          N = gt(T, n, E),
          I = gt(F, r, E)
        d.current &&
          ((p.current = O), (x.current = A), (y.current = C), (w.current = N), (m.current = I))
        var H = E > 0 ? { transition: $, strokeDasharray: k } : { strokeDasharray: D }
        return v.createElement(
          'path',
          Wi({}, et(t), {
            className: P,
            d: Ju(N, I, O, A, C),
            ref: d,
            style: Qu(Qu({}, H), t.style),
          }),
        )
      },
    )
  },
  XA = ['option', 'shapeType', 'propTransformer', 'activeClassName', 'isActive']
function GA(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = qA(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function qA(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function ef(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Ki(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? ef(Object(n), !0).forEach(function (r) {
          ZA(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ef(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function ZA(e, t, n) {
  return (
    (t = QA(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function QA(e) {
  var t = JA(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function JA(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function eO(e, t) {
  return Ki(Ki({}, t), e)
}
function tO(e, t) {
  return e === 'symbols'
}
function tf(e) {
  var { shapeType: t, elementProps: n } = e
  switch (t) {
    case 'rectangle':
      return v.createElement(qd, n)
    case 'trapezoid':
      return v.createElement(UA, n)
    case 'sector':
      return v.createElement(Jd, n)
    case 'symbols':
      if (tO(t)) return v.createElement(fo, n)
      break
    default:
      return null
  }
}
function nO(e) {
  return v.isValidElement(e) ? e.props : e
}
function nf(e) {
  var {
      option: t,
      shapeType: n,
      propTransformer: r = eO,
      activeClassName: i = 'recharts-active-shape',
      isActive: o,
    } = e,
    a = GA(e, XA),
    s
  if (v.isValidElement(t)) s = v.cloneElement(t, Ki(Ki({}, a), nO(t)))
  else if (typeof t == 'function') s = t(a)
  else if (Oy(t) && typeof t != 'boolean') {
    var l = r(t, a)
    s = v.createElement(tf, { shapeType: n, elementProps: l })
  } else {
    var c = a
    s = v.createElement(tf, { shapeType: n, elementProps: c })
  }
  return o ? v.createElement(St, { className: i }, s) : s
}
var rO = (e, t) => {
    var n = pe()
    return (r, i) => (o) => {
      ;(e?.(r, i, o),
        n(Dp({ activeIndex: String(i), activeDataKey: t, activeCoordinate: r.tooltipPosition })))
    }
  },
  iO = (e) => {
    var t = pe()
    return (n, r) => (i) => {
      ;(e?.(n, r, i), t(gE()))
    }
  },
  oO = (e, t) => {
    var n = pe()
    return (r, i) => (o) => {
      ;(e?.(r, i, o),
        n(mE({ activeIndex: String(i), activeDataKey: t, activeCoordinate: r.tooltipPosition })))
    }
  }
function aO(e) {
  var { fn: t, args: n } = e,
    r = pe(),
    i = We()
  return (
    v.useLayoutEffect(() => {
      if (!i) {
        var o = t(n)
        return (
          r(hE(o)),
          () => {
            r(pE(o))
          }
        )
      }
    }, [t, n, r, i]),
    null
  )
}
var sO = () => {}
function cO(e) {
  var { legendPayload: t } = e,
    n = pe(),
    r = We()
  return (
    v.useLayoutEffect(
      () =>
        r
          ? sO
          : (n(Bx(t)),
            () => {
              n(Hx(t))
            }),
      [n, r, t],
    ),
    null
  )
}
var la,
  lO = () => {
    var [e] = v.useState(() => cr('uid-'))
    return e
  },
  uO = (la = by.useId) !== null && la !== void 0 ? la : lO
function fO(e, t) {
  var n = uO()
  return t || (e ? ''.concat(e, '-').concat(n) : n)
}
var dO = v.createContext(void 0),
  hO = (e) => {
    var { id: t, type: n, children: r } = e,
      i = fO('recharts-'.concat(n), t)
    return v.createElement(dO.Provider, { value: i }, r(i))
  },
  pO = { cartesianItems: [], polarItems: [] },
  gv = Ve({
    name: 'graphicalItems',
    initialState: pO,
    reducers: {
      addCartesianGraphicalItem: {
        reducer(e, t) {
          e.cartesianItems.push(Ne(t.payload))
        },
        prepare: Te(),
      },
      replaceCartesianGraphicalItem: {
        reducer(e, t) {
          var { prev: n, next: r } = t.payload,
            i = Ht(e).cartesianItems.indexOf(Ne(n))
          i > -1 && (e.cartesianItems[i] = Ne(r))
        },
        prepare: Te(),
      },
      removeCartesianGraphicalItem: {
        reducer(e, t) {
          var n = Ht(e).cartesianItems.indexOf(Ne(t.payload))
          n > -1 && e.cartesianItems.splice(n, 1)
        },
        prepare: Te(),
      },
      addPolarGraphicalItem: {
        reducer(e, t) {
          e.polarItems.push(Ne(t.payload))
        },
        prepare: Te(),
      },
      removePolarGraphicalItem: {
        reducer(e, t) {
          var n = Ht(e).polarItems.indexOf(Ne(t.payload))
          n > -1 && e.polarItems.splice(n, 1)
        },
        prepare: Te(),
      },
    },
  }),
  {
    addCartesianGraphicalItem: vO,
    replaceCartesianGraphicalItem: gO,
    removeCartesianGraphicalItem: mO,
    addPolarGraphicalItem: C$,
    removePolarGraphicalItem: k$,
  } = gv.actions,
  yO = gv.reducer
function xO(e) {
  var t = pe(),
    n = v.useRef(null)
  return (
    v.useLayoutEffect(() => {
      ;(n.current === null ? t(vO(e)) : n.current !== e && t(gO({ prev: n.current, next: e })),
        (n.current = e))
    }, [t, e]),
    v.useLayoutEffect(
      () => () => {
        n.current && (t(mO(n.current)), (n.current = null))
      },
      [t],
    ),
    null
  )
}
function rf(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function of(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? rf(Object(n), !0).forEach(function (r) {
          bO(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : rf(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function bO(e, t, n) {
  return (
    (t = wO(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function wO(e) {
  var t = PO(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function PO(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var SO = { xAxis: {}, yAxis: {}, zAxis: {} },
  mv = Ve({
    name: 'cartesianAxis',
    initialState: SO,
    reducers: {
      addXAxis: {
        reducer(e, t) {
          e.xAxis[t.payload.id] = Ne(t.payload)
        },
        prepare: Te(),
      },
      removeXAxis: {
        reducer(e, t) {
          delete e.xAxis[t.payload.id]
        },
        prepare: Te(),
      },
      addYAxis: {
        reducer(e, t) {
          e.yAxis[t.payload.id] = Ne(t.payload)
        },
        prepare: Te(),
      },
      removeYAxis: {
        reducer(e, t) {
          delete e.yAxis[t.payload.id]
        },
        prepare: Te(),
      },
      addZAxis: {
        reducer(e, t) {
          e.zAxis[t.payload.id] = Ne(t.payload)
        },
        prepare: Te(),
      },
      removeZAxis: {
        reducer(e, t) {
          delete e.zAxis[t.payload.id]
        },
        prepare: Te(),
      },
      updateYAxisWidth(e, t) {
        var { id: n, width: r } = t.payload,
          i = e.yAxis[n]
        if (i) {
          var o = i.widthHistory || []
          if (
            o.length === 3 &&
            o[0] === o[2] &&
            r === o[1] &&
            r !== i.width &&
            Math.abs(r - o[0]) <= 1
          )
            return
          var a = [...o, r].slice(-3)
          e.yAxis[n] = of(of({}, e.yAxis[n]), {}, { width: r, widthHistory: a })
        }
      },
    },
  }),
  {
    addXAxis: EO,
    removeXAxis: _O,
    addYAxis: AO,
    removeYAxis: OO,
    addZAxis: CO,
    removeZAxis: kO,
    updateYAxisWidth: MO,
  } = mv.actions,
  TO = mv.reducer,
  NO = R([Oe], (e) => {
    if (e) return { top: e.top, bottom: e.bottom, left: e.left, right: e.right }
  }),
  DO = R([NO, Ct, kt], (e, t, n) => {
    if (!(!e || t == null || n == null))
      return {
        x: e.left,
        y: e.top,
        width: Math.max(0, t - e.left - e.right),
        height: Math.max(0, n - e.top - e.bottom),
      }
  }),
  yv = () => J(DO),
  IO = {},
  xv = Ve({
    name: 'errorBars',
    initialState: IO,
    reducers: {
      addErrorBar: (e, t) => {
        var { itemId: n, errorBar: r } = t.payload
        ;(e[n] || (e[n] = []), e[n].push(r))
      },
      replaceErrorBar: (e, t) => {
        var { itemId: n, prev: r, next: i } = t.payload
        e[n] &&
          (e[n] = e[n].map((o) => (o.dataKey === r.dataKey && o.direction === r.direction ? i : o)))
      },
      removeErrorBar: (e, t) => {
        var { itemId: n, errorBar: r } = t.payload
        e[n] && (e[n] = e[n].filter((i) => i.dataKey !== r.dataKey || i.direction !== r.direction))
      },
    },
  }),
  { addErrorBar: M$, replaceErrorBar: T$, removeErrorBar: N$ } = xv.actions,
  jO = xv.reducer,
  $O = ['children']
function LO(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = zO(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function zO(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var RO = {
    data: [],
    xAxisId: 'xAxis-0',
    yAxisId: 'yAxis-0',
    dataPointFormatter: () => ({ x: 0, y: 0, value: 0 }),
    errorBarOffset: 0,
  },
  BO = v.createContext(RO)
function HO(e) {
  var { children: t } = e,
    n = LO(e, $O)
  return v.createElement(BO.Provider, { value: n }, t)
}
function bv(e, t) {
  var n,
    r,
    i = J((c) => Tt(c, e)),
    o = J((c) => Nt(c, t)),
    a = (n = i?.allowDataOverflow) !== null && n !== void 0 ? n : ze.allowDataOverflow,
    s = (r = o?.allowDataOverflow) !== null && r !== void 0 ? r : Re.allowDataOverflow,
    l = a || s
  return { needClip: l, needClipX: a, needClipY: s }
}
function FO(e) {
  var { xAxisId: t, yAxisId: n, clipPathId: r } = e,
    i = yv(),
    { needClipX: o, needClipY: a, needClip: s } = bv(t, n)
  if (!s) return null
  var { x: l, y: c, width: u, height: f } = i
  return v.createElement(
    'clipPath',
    { id: 'clipPath-'.concat(r) },
    v.createElement('rect', {
      x: o ? l : l - u / 2,
      y: a ? c : c - f / 2,
      width: o ? u : u * 2,
      height: a ? f : f * 2,
    }),
  )
}
var VO = (e) => {
    var { chartData: t } = e,
      n = pe(),
      r = We()
    return (
      v.useEffect(
        () =>
          r
            ? () => {}
            : (n(Nu(t)),
              () => {
                n(Nu(void 0))
              }),
        [t, n, r],
      ),
      null
    )
  },
  af = { x: 0, y: 0, width: 0, height: 0, padding: { top: 0, right: 0, bottom: 0, left: 0 } },
  wv = Ve({
    name: 'brush',
    initialState: af,
    reducers: {
      setBrushSettings(e, t) {
        return t.payload == null ? af : t.payload
      },
    },
  }),
  { setBrushSettings: D$ } = wv.actions,
  WO = wv.reducer
function KO(e, t, n) {
  return (
    (t = YO(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function YO(e) {
  var t = UO(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function UO(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
class bc {
  static create(t) {
    return new bc(t)
  }
  constructor(t) {
    this.scale = t
  }
  get domain() {
    return this.scale.domain
  }
  get range() {
    return this.scale.range
  }
  get rangeMin() {
    return this.range()[0]
  }
  get rangeMax() {
    return this.range()[1]
  }
  get bandwidth() {
    return this.scale.bandwidth
  }
  apply(t) {
    var { bandAware: n, position: r } =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    if (t !== void 0) {
      if (r)
        switch (r) {
          case 'start':
            return this.scale(t)
          case 'middle': {
            var i = this.bandwidth ? this.bandwidth() / 2 : 0
            return this.scale(t) + i
          }
          case 'end': {
            var o = this.bandwidth ? this.bandwidth() : 0
            return this.scale(t) + o
          }
          default:
            return this.scale(t)
        }
      if (n) {
        var a = this.bandwidth ? this.bandwidth() / 2 : 0
        return this.scale(t) + a
      }
      return this.scale(t)
    }
  }
  isInRange(t) {
    var n = this.range(),
      r = n[0],
      i = n[n.length - 1]
    return r <= i ? t >= r && t <= i : t >= i && t <= r
  }
}
KO(bc, 'EPS', 1e-4)
function XO(e) {
  return ((e % 180) + 180) % 180
}
var GO = function (t) {
    var { width: n, height: r } = t,
      i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
      o = XO(i),
      a = (o * Math.PI) / 180,
      s = Math.atan(r / n),
      l = a > s && a < Math.PI - s ? r / Math.sin(a) : n / Math.cos(a)
    return Math.abs(l)
  },
  qO = { dots: [], areas: [], lines: [] },
  Pv = Ve({
    name: 'referenceElements',
    initialState: qO,
    reducers: {
      addDot: (e, t) => {
        e.dots.push(t.payload)
      },
      removeDot: (e, t) => {
        var n = Ht(e).dots.findIndex((r) => r === t.payload)
        n !== -1 && e.dots.splice(n, 1)
      },
      addArea: (e, t) => {
        e.areas.push(t.payload)
      },
      removeArea: (e, t) => {
        var n = Ht(e).areas.findIndex((r) => r === t.payload)
        n !== -1 && e.areas.splice(n, 1)
      },
      addLine: (e, t) => {
        e.lines.push(t.payload)
      },
      removeLine: (e, t) => {
        var n = Ht(e).lines.findIndex((r) => r === t.payload)
        n !== -1 && e.lines.splice(n, 1)
      },
    },
  }),
  {
    addDot: I$,
    removeDot: j$,
    addArea: $$,
    removeArea: L$,
    addLine: z$,
    removeLine: R$,
  } = Pv.actions,
  ZO = Pv.reducer,
  QO = v.createContext(void 0),
  JO = (e) => {
    var { children: t } = e,
      [n] = v.useState(''.concat(cr('recharts'), '-clip')),
      r = yv()
    if (r == null) return null
    var { x: i, y: o, width: a, height: s } = r
    return v.createElement(
      QO.Provider,
      { value: n },
      v.createElement(
        'defs',
        null,
        v.createElement(
          'clipPath',
          { id: n },
          v.createElement('rect', { x: i, y: o, height: s, width: a }),
        ),
      ),
      t,
    )
  }
function On(e, t) {
  for (var n in e)
    if ({}.hasOwnProperty.call(e, n) && (!{}.hasOwnProperty.call(t, n) || e[n] !== t[n])) return !1
  for (var r in t) if ({}.hasOwnProperty.call(t, r) && !{}.hasOwnProperty.call(e, r)) return !1
  return !0
}
function Sv(e, t, n) {
  if (t < 1) return []
  if (t === 1 && n === void 0) return e
  for (var r = [], i = 0; i < e.length; i += t) r.push(e[i])
  return r
}
function eC(e, t, n) {
  var r = { width: e.width + t.width, height: e.height + t.height }
  return GO(r, n)
}
function tC(e, t, n) {
  var r = n === 'width',
    { x: i, y: o, width: a, height: s } = e
  return t === 1
    ? { start: r ? i : o, end: r ? i + a : o + s }
    : { start: r ? i + a : o + s, end: r ? i : o }
}
function Yi(e, t, n, r, i) {
  if (e * t < e * r || e * t > e * i) return !1
  var o = n()
  return e * (t - (e * o) / 2 - r) >= 0 && e * (t + (e * o) / 2 - i) <= 0
}
function nC(e, t) {
  return Sv(e, t + 1)
}
function rC(e, t, n, r, i) {
  for (
    var o = (r || []).slice(),
      { start: a, end: s } = t,
      l = 0,
      c = 1,
      u = a,
      f = function () {
        var g = r?.[l]
        if (g === void 0) return { v: Sv(r, c) }
        var p = l,
          x,
          y = () => (x === void 0 && (x = n(g, p)), x),
          w = g.coordinate,
          m = l === 0 || Yi(e, w, y, u, s)
        ;(m || ((l = 0), (u = a), (c += 1)), m && ((u = w + e * (y() / 2 + i)), (l += c)))
      },
      d;
    c <= o.length;

  )
    if (((d = f()), d)) return d.v
  return []
}
function sf(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Ce(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? sf(Object(n), !0).forEach(function (r) {
          iC(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : sf(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function iC(e, t, n) {
  return (
    (t = oC(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function oC(e) {
  var t = aC(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function aC(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function sC(e, t, n, r, i) {
  for (
    var o = (r || []).slice(),
      a = o.length,
      { start: s } = t,
      { end: l } = t,
      c = function (d) {
        var h = o[d],
          g,
          p = () => (g === void 0 && (g = n(h, d)), g)
        if (d === a - 1) {
          var x = e * (h.coordinate + (e * p()) / 2 - l)
          o[d] = h = Ce(Ce({}, h), {}, { tickCoord: x > 0 ? h.coordinate - x * e : h.coordinate })
        } else o[d] = h = Ce(Ce({}, h), {}, { tickCoord: h.coordinate })
        var y = Yi(e, h.tickCoord, p, s, l)
        y && ((l = h.tickCoord - e * (p() / 2 + i)), (o[d] = Ce(Ce({}, h), {}, { isShow: !0 })))
      },
      u = a - 1;
    u >= 0;
    u--
  )
    c(u)
  return o
}
function cC(e, t, n, r, i, o) {
  var a = (r || []).slice(),
    s = a.length,
    { start: l, end: c } = t
  if (o) {
    var u = r[s - 1],
      f = n(u, s - 1),
      d = e * (u.coordinate + (e * f) / 2 - c)
    a[s - 1] = u = Ce(Ce({}, u), {}, { tickCoord: d > 0 ? u.coordinate - d * e : u.coordinate })
    var h = Yi(e, u.tickCoord, () => f, l, c)
    h && ((c = u.tickCoord - e * (f / 2 + i)), (a[s - 1] = Ce(Ce({}, u), {}, { isShow: !0 })))
  }
  for (
    var g = o ? s - 1 : s,
      p = function (w) {
        var m = a[w],
          b,
          P = () => (b === void 0 && (b = n(m, w)), b)
        if (w === 0) {
          var S = e * (m.coordinate - (e * P()) / 2 - l)
          a[w] = m = Ce(Ce({}, m), {}, { tickCoord: S < 0 ? m.coordinate - S * e : m.coordinate })
        } else a[w] = m = Ce(Ce({}, m), {}, { tickCoord: m.coordinate })
        var _ = Yi(e, m.tickCoord, P, l, c)
        _ && ((l = m.tickCoord + e * (P() / 2 + i)), (a[w] = Ce(Ce({}, m), {}, { isShow: !0 })))
      },
      x = 0;
    x < g;
    x++
  )
    p(x)
  return a
}
function wc(e, t, n) {
  var {
    tick: r,
    ticks: i,
    viewBox: o,
    minTickGap: a,
    orientation: s,
    interval: l,
    tickFormatter: c,
    unit: u,
    angle: f,
  } = e
  if (!i || !i.length || !r) return []
  if (te(l) || $n.isSsr) {
    var d
    return (d = nC(i, te(l) ? l : 0)) !== null && d !== void 0 ? d : []
  }
  var h = [],
    g = s === 'top' || s === 'bottom' ? 'width' : 'height',
    p = u && g === 'width' ? ir(u, { fontSize: t, letterSpacing: n }) : { width: 0, height: 0 },
    x = (m, b) => {
      var P = typeof c == 'function' ? c(m.value, b) : m.value
      return g === 'width'
        ? eC(ir(P, { fontSize: t, letterSpacing: n }), p, f)
        : ir(P, { fontSize: t, letterSpacing: n })[g]
    },
    y = i.length >= 2 ? Qe(i[1].coordinate - i[0].coordinate) : 1,
    w = tC(o, y, g)
  return l === 'equidistantPreserveStart'
    ? rC(y, w, x, i, a)
    : (l === 'preserveStart' || l === 'preserveStartEnd'
        ? (h = cC(y, w, x, i, a, l === 'preserveStartEnd'))
        : (h = sC(y, w, x, i, a)),
      h.filter((m) => m.isShow))
}
var lC = (e) => {
    var { ticks: t, label: n, labelGapWithTick: r = 5, tickSize: i = 0, tickMargin: o = 0 } = e,
      a = 0
    if (t) {
      Array.from(t).forEach((u) => {
        if (u) {
          var f = u.getBoundingClientRect()
          f.width > a && (a = f.width)
        }
      })
      var s = n ? n.getBoundingClientRect().width : 0,
        l = i + o,
        c = a + l + s + (n ? r : 0)
      return Math.round(c)
    }
    return 0
  },
  uC = ['axisLine', 'width', 'height', 'className', 'hide', 'ticks'],
  fC = ['viewBox'],
  dC = ['viewBox']
function Ga(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = hC(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function hC(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function rn() {
  return (
    (rn = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    rn.apply(null, arguments)
  )
}
function cf(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function me(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? cf(Object(n), !0).forEach(function (r) {
          pC(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : cf(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function pC(e, t, n) {
  return (
    (t = vC(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function vC(e) {
  var t = gC(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function gC(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var Pc = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: { x: 0, y: 0, width: 0, height: 0 },
  orientation: 'bottom',
  ticks: [],
  stroke: '#666',
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  tickSize: 6,
  tickMargin: 2,
  interval: 'preserveEnd',
}
function mC(e) {
  var {
    x: t,
    y: n,
    width: r,
    height: i,
    orientation: o,
    mirror: a,
    axisLine: s,
    otherSvgProps: l,
  } = e
  if (!s) return null
  var c = me(me(me({}, l), ft(s)), {}, { fill: 'none' })
  if (o === 'top' || o === 'bottom') {
    var u = +((o === 'top' && !a) || (o === 'bottom' && a))
    c = me(me({}, c), {}, { x1: t, y1: n + u * i, x2: t + r, y2: n + u * i })
  } else {
    var f = +((o === 'left' && !a) || (o === 'right' && a))
    c = me(me({}, c), {}, { x1: t + f * r, y1: n, x2: t + f * r, y2: n + i })
  }
  return v.createElement(
    'line',
    rn({}, c, { className: le('recharts-cartesian-axis-line', wn(s, 'className')) }),
  )
}
function yC(e, t, n, r, i, o, a, s, l) {
  var c,
    u,
    f,
    d,
    h,
    g,
    p = s ? -1 : 1,
    x = e.tickSize || a,
    y = te(e.tickCoord) ? e.tickCoord : e.coordinate
  switch (o) {
    case 'top':
      ;((c = u = e.coordinate), (d = n + +!s * i), (f = d - p * x), (g = f - p * l), (h = y))
      break
    case 'left':
      ;((f = d = e.coordinate), (u = t + +!s * r), (c = u - p * x), (h = c - p * l), (g = y))
      break
    case 'right':
      ;((f = d = e.coordinate), (u = t + +s * r), (c = u + p * x), (h = c + p * l), (g = y))
      break
    default:
      ;((c = u = e.coordinate), (d = n + +s * i), (f = d + p * x), (g = f + p * l), (h = y))
      break
  }
  return { line: { x1: c, y1: f, x2: u, y2: d }, tick: { x: h, y: g } }
}
function xC(e, t) {
  switch (e) {
    case 'left':
      return t ? 'start' : 'end'
    case 'right':
      return t ? 'end' : 'start'
    default:
      return 'middle'
  }
}
function bC(e, t) {
  switch (e) {
    case 'left':
    case 'right':
      return 'middle'
    case 'top':
      return t ? 'start' : 'end'
    default:
      return t ? 'end' : 'start'
  }
}
function wC(e) {
  var { option: t, tickProps: n, value: r } = e,
    i,
    o = le(n.className, 'recharts-cartesian-axis-tick-value')
  if (v.isValidElement(t)) i = v.cloneElement(t, me(me({}, n), {}, { className: o }))
  else if (typeof t == 'function') i = t(me(me({}, n), {}, { className: o }))
  else {
    var a = 'recharts-cartesian-axis-tick-value'
    ;(typeof t != 'boolean' && (a = le(a, t?.className)),
      (i = v.createElement(yc, rn({}, n, { className: a }), r)))
  }
  return i
}
function PC(e) {
  var {
      ticks: t = [],
      tick: n,
      tickLine: r,
      stroke: i,
      tickFormatter: o,
      unit: a,
      padding: s,
      tickTextProps: l,
      orientation: c,
      mirror: u,
      x: f,
      y: d,
      width: h,
      height: g,
      tickSize: p,
      tickMargin: x,
      fontSize: y,
      letterSpacing: w,
      getTicksConfig: m,
      events: b,
    } = e,
    P = wc(me(me({}, m), {}, { ticks: t }), y, w),
    S = xC(c, u),
    _ = bC(c, u),
    M = ft(m),
    T = hs(n),
    F = {}
  typeof r == 'object' && (F = r)
  var D = me(me({}, M), {}, { fill: 'none' }, F),
    k = P.map(($, E) => {
      var { line: O, tick: A } = yC($, f, d, h, g, c, p, u, x),
        C = me(
          me(
            me(me({ textAnchor: S, verticalAnchor: _ }, M), {}, { stroke: 'none', fill: i }, T),
            A,
          ),
          {},
          { index: E, payload: $, visibleTicksCount: P.length, tickFormatter: o, padding: s },
          l,
        )
      return v.createElement(
        St,
        rn(
          {
            className: 'recharts-cartesian-axis-tick',
            key: 'tick-'.concat($.value, '-').concat($.coordinate, '-').concat($.tickCoord),
          },
          ys(b, $, E),
        ),
        r &&
          v.createElement(
            'line',
            rn({}, D, O, {
              className: le('recharts-cartesian-axis-tick-line', wn(r, 'className')),
            }),
          ),
        n &&
          v.createElement(wC, {
            option: n,
            tickProps: C,
            value: ''.concat(typeof o == 'function' ? o($.value, E) : $.value).concat(a || ''),
          }),
      )
    })
  return k.length > 0
    ? v.createElement('g', { className: 'recharts-cartesian-axis-ticks' }, k)
    : null
}
var SC = v.forwardRef((e, t) => {
    var { axisLine: n, width: r, height: i, className: o, hide: a, ticks: s } = e,
      l = Ga(e, uC),
      [c, u] = v.useState(''),
      [f, d] = v.useState(''),
      h = v.useRef(null)
    v.useImperativeHandle(t, () => ({
      getCalculatedWidth: () => {
        var p
        return lC({
          ticks: h.current,
          label: (p = e.labelRef) === null || p === void 0 ? void 0 : p.current,
          labelGapWithTick: 5,
          tickSize: e.tickSize,
          tickMargin: e.tickMargin,
        })
      },
    }))
    var g = v.useCallback(
      (p) => {
        if (p) {
          var x = p.getElementsByClassName('recharts-cartesian-axis-tick-value')
          h.current = x
          var y = x[0]
          if (y) {
            var w = window.getComputedStyle(y),
              m = w.fontSize,
              b = w.letterSpacing
            ;(m !== c || b !== f) && (u(m), d(b))
          }
        }
      },
      [c, f],
    )
    return a || (r != null && r <= 0) || (i != null && i <= 0)
      ? null
      : v.createElement(
          St,
          { className: le('recharts-cartesian-axis', o), ref: g },
          v.createElement(mC, {
            x: e.x,
            y: e.y,
            width: r,
            height: i,
            orientation: e.orientation,
            mirror: e.mirror,
            axisLine: n,
            otherSvgProps: ft(e),
          }),
          v.createElement(PC, {
            ticks: s,
            tick: e.tick,
            tickLine: e.tickLine,
            stroke: e.stroke,
            tickFormatter: e.tickFormatter,
            unit: e.unit,
            padding: e.padding,
            tickTextProps: e.tickTextProps,
            orientation: e.orientation,
            mirror: e.mirror,
            x: e.x,
            y: e.y,
            width: e.width,
            height: e.height,
            tickSize: e.tickSize,
            tickMargin: e.tickMargin,
            fontSize: c,
            letterSpacing: f,
            getTicksConfig: e,
            events: l,
          }),
          v.createElement(
            wA,
            { x: e.x, y: e.y, width: e.width, height: e.height },
            v.createElement(TA, { label: e.label, labelRef: e.labelRef }),
            e.children,
          ),
        )
  }),
  EC = v.memo(SC, (e, t) => {
    var { viewBox: n } = e,
      r = Ga(e, fC),
      { viewBox: i } = t,
      o = Ga(t, dC)
    return On(n, i) && On(r, o)
  }),
  Sc = v.forwardRef((e, t) => {
    var n = Ke(e, Pc)
    return v.createElement(EC, rn({}, n, { ref: t }))
  })
Sc.displayName = 'CartesianAxis'
var _C = ['x1', 'y1', 'x2', 'y2', 'key'],
  AC = ['offset'],
  OC = ['xAxisId', 'yAxisId'],
  CC = ['xAxisId', 'yAxisId']
function lf(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function ke(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? lf(Object(n), !0).forEach(function (r) {
          kC(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : lf(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function kC(e, t, n) {
  return (
    (t = MC(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function MC(e) {
  var t = TC(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function TC(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function Qt() {
  return (
    (Qt = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Qt.apply(null, arguments)
  )
}
function Ui(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = NC(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function NC(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var DC = (e) => {
  var { fill: t } = e
  if (!t || t === 'none') return null
  var { fillOpacity: n, x: r, y: i, width: o, height: a, ry: s } = e
  return v.createElement('rect', {
    x: r,
    y: i,
    ry: s,
    width: o,
    height: a,
    stroke: 'none',
    fill: t,
    fillOpacity: n,
    className: 'recharts-cartesian-grid-bg',
  })
}
function Ev(e, t) {
  var n
  if (v.isValidElement(e)) n = v.cloneElement(e, t)
  else if (typeof e == 'function') n = e(t)
  else {
    var { x1: r, y1: i, x2: o, y2: a, key: s } = t,
      l = Ui(t, _C),
      c = ft(l),
      { offset: u } = c,
      f = Ui(c, AC)
    n = v.createElement('line', Qt({}, f, { x1: r, y1: i, x2: o, y2: a, fill: 'none', key: s }))
  }
  return n
}
function IC(e) {
  var { x: t, width: n, horizontal: r = !0, horizontalPoints: i } = e
  if (!r || !i || !i.length) return null
  var { xAxisId: o, yAxisId: a } = e,
    s = Ui(e, OC),
    l = i.map((c, u) => {
      var f = ke(
        ke({}, s),
        {},
        { x1: t, y1: c, x2: t + n, y2: c, key: 'line-'.concat(u), index: u },
      )
      return Ev(r, f)
    })
  return v.createElement('g', { className: 'recharts-cartesian-grid-horizontal' }, l)
}
function jC(e) {
  var { y: t, height: n, vertical: r = !0, verticalPoints: i } = e
  if (!r || !i || !i.length) return null
  var { xAxisId: o, yAxisId: a } = e,
    s = Ui(e, CC),
    l = i.map((c, u) => {
      var f = ke(
        ke({}, s),
        {},
        { x1: c, y1: t, x2: c, y2: t + n, key: 'line-'.concat(u), index: u },
      )
      return Ev(r, f)
    })
  return v.createElement('g', { className: 'recharts-cartesian-grid-vertical' }, l)
}
function $C(e) {
  var {
    horizontalFill: t,
    fillOpacity: n,
    x: r,
    y: i,
    width: o,
    height: a,
    horizontalPoints: s,
    horizontal: l = !0,
  } = e
  if (!l || !t || !t.length) return null
  var c = s.map((f) => Math.round(f + i - i)).sort((f, d) => f - d)
  i !== c[0] && c.unshift(0)
  var u = c.map((f, d) => {
    var h = !c[d + 1],
      g = h ? i + a - f : c[d + 1] - f
    if (g <= 0) return null
    var p = d % t.length
    return v.createElement('rect', {
      key: 'react-'.concat(d),
      y: f,
      x: r,
      height: g,
      width: o,
      stroke: 'none',
      fill: t[p],
      fillOpacity: n,
      className: 'recharts-cartesian-grid-bg',
    })
  })
  return v.createElement('g', { className: 'recharts-cartesian-gridstripes-horizontal' }, u)
}
function LC(e) {
  var {
    vertical: t = !0,
    verticalFill: n,
    fillOpacity: r,
    x: i,
    y: o,
    width: a,
    height: s,
    verticalPoints: l,
  } = e
  if (!t || !n || !n.length) return null
  var c = l.map((f) => Math.round(f + i - i)).sort((f, d) => f - d)
  i !== c[0] && c.unshift(0)
  var u = c.map((f, d) => {
    var h = !c[d + 1],
      g = h ? i + a - f : c[d + 1] - f
    if (g <= 0) return null
    var p = d % n.length
    return v.createElement('rect', {
      key: 'react-'.concat(d),
      x: f,
      y: o,
      width: g,
      height: s,
      stroke: 'none',
      fill: n[p],
      fillOpacity: r,
      className: 'recharts-cartesian-grid-bg',
    })
  })
  return v.createElement('g', { className: 'recharts-cartesian-gridstripes-vertical' }, u)
}
var zC = (e, t) => {
    var { xAxis: n, width: r, height: i, offset: o } = e
    return Dd(
      wc(ke(ke(ke({}, Pc), n), {}, { ticks: Id(n), viewBox: { x: 0, y: 0, width: r, height: i } })),
      o.left,
      o.left + o.width,
      t,
    )
  },
  RC = (e, t) => {
    var { yAxis: n, width: r, height: i, offset: o } = e
    return Dd(
      wc(ke(ke(ke({}, Pc), n), {}, { ticks: Id(n), viewBox: { x: 0, y: 0, width: r, height: i } })),
      o.top,
      o.top + o.height,
      t,
    )
  },
  BC = {
    horizontal: !0,
    vertical: !0,
    horizontalPoints: [],
    verticalPoints: [],
    stroke: '#ccc',
    fill: 'none',
    verticalFill: [],
    horizontalFill: [],
    xAxisId: 0,
    yAxisId: 0,
  }
function HC(e) {
  var t = Ps(),
    n = Ss(),
    r = Hd(),
    i = ke(
      ke({}, Ke(e, BC)),
      {},
      {
        x: te(e.x) ? e.x : r.left,
        y: te(e.y) ? e.y : r.top,
        width: te(e.width) ? e.width : r.width,
        height: te(e.height) ? e.height : r.height,
      },
    ),
    {
      xAxisId: o,
      yAxisId: a,
      x: s,
      y: l,
      width: c,
      height: u,
      syncWithTicks: f,
      horizontalValues: d,
      verticalValues: h,
    } = i,
    g = We(),
    p = J((T) => Eu(T, 'xAxis', o, g)),
    x = J((T) => Eu(T, 'yAxis', a, g))
  if (!te(c) || c <= 0 || !te(u) || u <= 0 || !te(s) || s !== +s || !te(l) || l !== +l) return null
  var y = i.verticalCoordinatesGenerator || zC,
    w = i.horizontalCoordinatesGenerator || RC,
    { horizontalPoints: m, verticalPoints: b } = i
  if ((!m || !m.length) && typeof w == 'function') {
    var P = d && d.length,
      S = w(
        {
          yAxis: x ? ke(ke({}, x), {}, { ticks: P ? d : x.ticks }) : void 0,
          width: t,
          height: n,
          offset: r,
        },
        P ? !0 : f,
      )
    ;(gl(
      Array.isArray(S),
      'horizontalCoordinatesGenerator should return Array but instead it returned ['.concat(
        typeof S,
        ']',
      ),
    ),
      Array.isArray(S) && (m = S))
  }
  if ((!b || !b.length) && typeof y == 'function') {
    var _ = h && h.length,
      M = y(
        {
          xAxis: p ? ke(ke({}, p), {}, { ticks: _ ? h : p.ticks }) : void 0,
          width: t,
          height: n,
          offset: r,
        },
        _ ? !0 : f,
      )
    ;(gl(
      Array.isArray(M),
      'verticalCoordinatesGenerator should return Array but instead it returned ['.concat(
        typeof M,
        ']',
      ),
    ),
      Array.isArray(M) && (b = M))
  }
  return v.createElement(
    'g',
    { className: 'recharts-cartesian-grid' },
    v.createElement(DC, {
      fill: i.fill,
      fillOpacity: i.fillOpacity,
      x: i.x,
      y: i.y,
      width: i.width,
      height: i.height,
      ry: i.ry,
    }),
    v.createElement($C, Qt({}, i, { horizontalPoints: m })),
    v.createElement(LC, Qt({}, i, { verticalPoints: b })),
    v.createElement(IC, Qt({}, i, { offset: r, horizontalPoints: m, xAxis: p, yAxis: x })),
    v.createElement(jC, Qt({}, i, { offset: r, verticalPoints: b, xAxis: p, yAxis: x })),
  )
}
HC.displayName = 'CartesianGrid'
function _v(e, t, n) {
  return (
    (t = FC(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function FC(e) {
  var t = VC(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function VC(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function WC(e) {
  var t = pe()
  return (
    v.useEffect(
      () => (
        t(CO(e)),
        () => {
          t(kO(e))
        }
      ),
      [e, t],
    ),
    null
  )
}
class Ec extends v.Component {
  render() {
    return v.createElement(WC, {
      domain: this.props.domain,
      id: this.props.zAxisId,
      dataKey: this.props.dataKey,
      name: this.props.name,
      unit: this.props.unit,
      range: this.props.range,
      scale: this.props.scale,
      type: this.props.type,
      allowDuplicatedCategory: Bt.allowDuplicatedCategory,
      allowDataOverflow: Bt.allowDataOverflow,
      reversed: Bt.reversed,
      includeHidden: Bt.includeHidden,
    })
  }
}
_v(Ec, 'displayName', 'ZAxis')
_v(Ec, 'defaultProps', { zAxisId: 0, range: Bt.range, scale: Bt.scale, type: Bt.type })
var KC = ['option', 'isActive']
function or() {
  return (
    (or = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    or.apply(null, arguments)
  )
}
function YC(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = UC(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function UC(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function XC(e) {
  var { option: t, isActive: n } = e,
    r = YC(e, KC)
  return typeof t == 'string'
    ? v.createElement(
        nf,
        or(
          { option: v.createElement(fo, or({ type: t }, r)), isActive: n, shapeType: 'symbols' },
          r,
        ),
      )
    : v.createElement(nf, or({ option: t, isActive: n, shapeType: 'symbols' }, r))
}
var GC = (e, t, n, r, i, o, a) => Op(e, 'xAxis', t, a),
  qC = (e, t, n, r, i, o, a) => Ap(e, 'xAxis', t, a),
  ZC = (e, t, n, r, i, o, a) => Op(e, 'yAxis', n, a),
  QC = (e, t, n, r, i, o, a) => Ap(e, 'yAxis', n, a),
  JC = (e, t, n, r) => cE(e, 'zAxis', r, !1),
  ek = (e, t, n, r, i) => i,
  tk = (e, t, n, r, i, o) => o,
  nk = (e, t, n, r, i, o, a) => Ys(e, t, n, a),
  rk = R([Gh, ek], (e, t) => e.filter((n) => n.type === 'scatter').find((n) => n.id === t)),
  ik = R([nk, GC, qC, ZC, QC, JC, rk, tk], (e, t, n, r, i, o, a, s) => {
    var { chartData: l, dataStartIndex: c, dataEndIndex: u } = e
    if (a != null) {
      var f
      if (
        (a?.data != null && a.data.length > 0 ? (f = a.data) : (f = l?.slice(c, u + 1)),
        !(
          f == null ||
          t == null ||
          r == null ||
          n == null ||
          i == null ||
          n?.length === 0 ||
          i?.length === 0
        ))
      )
        return yk({
          displayedData: f,
          xAxis: t,
          yAxis: r,
          zAxis: o,
          scatterSettings: a,
          xAxisTicks: n,
          yAxisTicks: i,
          cells: s,
        })
    }
  }),
  ok = ['onMouseEnter', 'onClick', 'onMouseLeave'],
  ak = ['id'],
  sk = [
    'animationBegin',
    'animationDuration',
    'animationEasing',
    'hide',
    'isAnimationActive',
    'legendType',
    'lineJointType',
    'lineType',
    'shape',
    'xAxisId',
    'yAxisId',
    'zAxisId',
  ]
function qa(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = ck(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function ck(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function on() {
  return (
    (on = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    on.apply(null, arguments)
  )
}
function uf(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function Me(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? uf(Object(n), !0).forEach(function (r) {
          lk(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : uf(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function lk(e, t, n) {
  return (
    (t = uk(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function uk(e) {
  var t = fk(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function fk(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
var dk = (e) => {
  var { dataKey: t, name: n, fill: r, legendType: i, hide: o } = e
  return [{ inactive: o, dataKey: t, type: i, color: r, value: jd(n, t), payload: e }]
}
function hk(e) {
  var { points: t, props: n } = e,
    { line: r, lineType: i, lineJointType: o } = n
  if (!r) return null
  var a = ft(n),
    s = hs(r),
    l,
    c
  if (i === 'joint') l = t.map((x) => ({ x: x.cx, y: x.cy }))
  else if (i === 'fitting') {
    var { xmin: u, xmax: f, a: d, b: h } = P0(t),
      g = (x) => d * x + h
    l = [
      { x: u, y: g(u) },
      { x: f, y: g(f) },
    ]
  }
  var p = Me(Me(Me({}, a), {}, { fill: 'none', stroke: a && a.fill }, s), {}, { points: l })
  return (
    v.isValidElement(r)
      ? (c = v.cloneElement(r, p))
      : typeof r == 'function'
        ? (c = r(p))
        : (c = v.createElement(Kd, on({}, p, { type: o }))),
    v.createElement(St, { className: 'recharts-scatter-line', key: 'recharts-scatter-line' }, c)
  )
}
function pk(e) {
  var { showLabels: t, points: n, children: r } = e,
    i = Or(),
    o = v.useMemo(
      () =>
        n?.map((a) => {
          var s = { x: a.x, y: a.y, width: a.width, height: a.height }
          return Me(
            Me({}, s),
            {},
            { value: void 0, payload: a.payload, viewBox: s, parentViewBox: i, fill: void 0 },
          )
        }),
      [i, n],
    )
  return v.createElement($A, { value: t ? o : null }, r)
}
function vk(e) {
  var { points: t, allOtherScatterProps: n } = e,
    { shape: r, activeShape: i, dataKey: o } = n,
    a = J(hr),
    { onMouseEnter: s, onClick: l, onMouseLeave: c } = n,
    u = qa(n, ok),
    f = rO(s, n.dataKey),
    d = iO(c),
    h = oO(l, n.dataKey)
  if (t == null) return null
  var { id: g } = n,
    p = qa(n, ak),
    x = ft(p)
  return v.createElement(
    v.Fragment,
    null,
    v.createElement(hk, { points: t, props: p }),
    t.map((y, w) => {
      var m = i && a === String(w),
        b = m ? i : r,
        P = Me(Me(Me({ key: 'symbol-'.concat(w) }, x), y), {}, { [Ld]: w, [zd]: String(o) })
      return v.createElement(
        St,
        on(
          {
            key: 'symbol-'.concat(y?.cx, '-').concat(y?.cy, '-').concat(y?.size, '-').concat(w),
            className: 'recharts-scatter-symbol',
          },
          ys(u, y, w),
          { onMouseEnter: f(y, w), onMouseLeave: d(y, w), onClick: h(y, w) },
        ),
        v.createElement(XC, on({ option: b, isActive: m }, P)),
      )
    }),
  )
}
function gk(e) {
  var { previousPointsRef: t, props: n } = e,
    {
      points: r,
      isAnimationActive: i,
      animationBegin: o,
      animationDuration: a,
      animationEasing: s,
    } = n,
    l = t.current,
    c = Os(n, 'recharts-scatter-'),
    [u, f] = v.useState(!1),
    d = v.useCallback(() => {
      f(!1)
    }, []),
    h = v.useCallback(() => {
      f(!0)
    }, []),
    g = !u
  return v.createElement(
    pk,
    { showLabels: g, points: r },
    n.children,
    v.createElement(
      As,
      {
        animationId: c,
        begin: o,
        duration: a,
        isActive: i,
        easing: s,
        onAnimationEnd: d,
        onAnimationStart: h,
        key: c,
      },
      (p) => {
        var x =
          p === 1
            ? r
            : r?.map((y, w) => {
                var m = l && l[w]
                if (m) {
                  var b = Xr(m.cx, y.cx),
                    P = Xr(m.cy, y.cy),
                    S = Xr(m.size, y.size)
                  return Me(Me({}, y), {}, { cx: b(p), cy: P(p), size: S(p) })
                }
                var _ = Xr(0, y.size)
                return Me(Me({}, y), {}, { size: _(p) })
              })
        return (
          p > 0 && (t.current = x),
          v.createElement(
            St,
            null,
            v.createElement(vk, { points: x, allOtherScatterProps: n, showLabels: g }),
          )
        )
      },
    ),
    v.createElement(RA, { label: n.label }),
  )
}
function mk(e) {
  var {
    dataKey: t,
    points: n,
    stroke: r,
    strokeWidth: i,
    fill: o,
    name: a,
    hide: s,
    tooltipType: l,
  } = e
  return {
    dataDefinedOnItem: n?.map((c) => c.tooltipPayload),
    positions: n?.map((c) => c.tooltipPosition),
    settings: {
      stroke: r,
      strokeWidth: i,
      fill: o,
      nameKey: void 0,
      dataKey: t,
      name: jd(a, t),
      hide: s,
      type: l,
      color: o,
      unit: '',
    },
  }
}
function yk(e) {
  var {
      displayedData: t,
      xAxis: n,
      yAxis: r,
      zAxis: i,
      scatterSettings: o,
      xAxisTicks: a,
      yAxisTicks: s,
      cells: l,
    } = e,
    c = ge(n.dataKey) ? o.dataKey : n.dataKey,
    u = ge(r.dataKey) ? o.dataKey : r.dataKey,
    f = i && i.dataKey,
    d = i ? i.range : Ec.defaultProps.range,
    h = d && d[0],
    g = n.scale.bandwidth ? n.scale.bandwidth() : 0,
    p = r.scale.bandwidth ? r.scale.bandwidth() : 0
  return t.map((x, y) => {
    var w = Ae(x, c),
      m = Ae(x, u),
      b = (!ge(f) && Ae(x, f)) || '-',
      P = [
        {
          name: ge(n.dataKey) ? o.name : n.name || n.dataKey,
          unit: n.unit || '',
          value: w,
          payload: x,
          dataKey: c,
          type: o.tooltipType,
        },
        {
          name: ge(r.dataKey) ? o.name : r.name || r.dataKey,
          unit: r.unit || '',
          value: m,
          payload: x,
          dataKey: u,
          type: o.tooltipType,
        },
      ]
    b !== '-' &&
      P.push({
        name: i.name || i.dataKey,
        unit: i.unit || '',
        value: b,
        payload: x,
        dataKey: f,
        type: o.tooltipType,
      })
    var S = fl({ axis: n, ticks: a, bandSize: g, entry: x, index: y, dataKey: c }),
      _ = fl({ axis: r, ticks: s, bandSize: p, entry: x, index: y, dataKey: u }),
      M = b !== '-' ? i.scale(b) : h,
      T = Math.sqrt(Math.max(M, 0) / Math.PI)
    return Me(
      Me({}, x),
      {},
      {
        cx: S,
        cy: _,
        x: S - T,
        y: _ - T,
        width: 2 * T,
        height: 2 * T,
        size: M,
        node: { x: w, y: m, z: b },
        tooltipPayload: P,
        tooltipPosition: { x: S, y: _ },
        payload: x,
      },
      l && l[y] && l[y].props,
    )
  })
}
var xk = (e, t, n) => ({
  x: e.cx,
  y: e.cy,
  value: n === 'x' ? +e.node.x : +e.node.y,
  errorVal: Ae(e, t),
})
function bk(e) {
  var { hide: t, points: n, className: r, needClip: i, xAxisId: o, yAxisId: a, id: s } = e,
    l = v.useRef(null)
  if (t) return null
  var c = le('recharts-scatter', r),
    u = s
  return v.createElement(
    St,
    { className: c, clipPath: i ? 'url(#clipPath-'.concat(u, ')') : null, id: s },
    i &&
      v.createElement('defs', null, v.createElement(FO, { clipPathId: u, xAxisId: o, yAxisId: a })),
    v.createElement(
      HO,
      { xAxisId: o, yAxisId: a, data: n, dataPointFormatter: xk, errorBarOffset: 0 },
      v.createElement(
        St,
        { key: 'recharts-scatter-symbols' },
        v.createElement(gk, { props: e, previousPointsRef: l }),
      ),
    ),
  )
}
var Av = {
  xAxisId: 0,
  yAxisId: 0,
  zAxisId: 0,
  legendType: 'circle',
  lineType: 'joint',
  lineJointType: 'linear',
  data: [],
  shape: 'circle',
  hide: !1,
  isAnimationActive: !$n.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: 'linear',
}
function wk(e) {
  var t = Ke(e, Av),
    {
      animationBegin: n,
      animationDuration: r,
      animationEasing: i,
      hide: o,
      isAnimationActive: a,
      legendType: s,
      lineJointType: l,
      lineType: c,
      shape: u,
      xAxisId: f,
      yAxisId: d,
      zAxisId: h,
    } = t,
    g = qa(t, sk),
    { needClip: p } = bv(f, d),
    x = v.useMemo(() => FA(e.children, rv), [e.children]),
    y = We(),
    w = J((m) => ik(m, f, d, h, e.id, x, y))
  return p == null || w == null
    ? null
    : v.createElement(
        v.Fragment,
        null,
        v.createElement(aO, { fn: mk, args: Me(Me({}, e), {}, { points: w }) }),
        v.createElement(
          bk,
          on({}, g, {
            xAxisId: f,
            yAxisId: d,
            zAxisId: h,
            lineType: c,
            lineJointType: l,
            legendType: s,
            shape: u,
            hide: o,
            isAnimationActive: a,
            animationBegin: n,
            animationDuration: r,
            animationEasing: i,
            points: w,
            needClip: p,
          }),
        ),
      )
}
function Pk(e) {
  var t = Ke(e, Av),
    n = We()
  return v.createElement(hO, { id: t.id, type: 'scatter' }, (r) =>
    v.createElement(
      v.Fragment,
      null,
      v.createElement(cO, { legendPayload: dk(t) }),
      v.createElement(xO, {
        type: 'scatter',
        id: r,
        data: t.data,
        xAxisId: t.xAxisId,
        yAxisId: t.yAxisId,
        zAxisId: t.zAxisId,
        dataKey: t.dataKey,
        hide: t.hide,
        name: t.name,
        tooltipType: t.tooltipType,
        isPanorama: n,
      }),
      v.createElement(wk, on({}, t, { id: r })),
    ),
  )
}
var Sk = v.memo(Pk)
Sk.displayName = 'Scatter'
var Ek = ['dangerouslySetInnerHTML', 'ticks'],
  _k = ['id'],
  Ak = ['domain'],
  Ok = ['domain']
function Za() {
  return (
    (Za = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Za.apply(null, arguments)
  )
}
function Xi(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = Ck(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function Ck(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function kk(e) {
  var t = pe()
  return (
    v.useLayoutEffect(
      () => (
        t(EO(e)),
        () => {
          t(_O(e))
        }
      ),
      [e, t],
    ),
    null
  )
}
var Mk = (e) => {
    var { xAxisId: t, className: n } = e,
      r = J(Rd),
      i = We(),
      o = 'xAxis',
      a = J((x) => Bn(x, o, t, i)),
      s = J((x) => _p(x, o, t, i)),
      l = J((x) => GS(x, t)),
      c = J((x) => tE(x, t)),
      u = J((x) => Kh(x, t))
    if (l == null || c == null || u == null) return null
    var { dangerouslySetInnerHTML: f, ticks: d } = e,
      h = Xi(e, Ek),
      { id: g } = u,
      p = Xi(u, _k)
    return v.createElement(
      Sc,
      Za({}, h, p, {
        scale: a,
        x: c.x,
        y: c.y,
        width: l.width,
        height: l.height,
        className: le('recharts-'.concat(o, ' ').concat(o), n),
        viewBox: r,
        ticks: s,
      }),
    )
  },
  Tk = {
    allowDataOverflow: ze.allowDataOverflow,
    allowDecimals: ze.allowDecimals,
    allowDuplicatedCategory: ze.allowDuplicatedCategory,
    height: ze.height,
    hide: !1,
    mirror: ze.mirror,
    orientation: ze.orientation,
    padding: ze.padding,
    reversed: ze.reversed,
    scale: ze.scale,
    tickCount: ze.tickCount,
    type: ze.type,
    xAxisId: 0,
  },
  Nk = (e) => {
    var t,
      n,
      r,
      i,
      o,
      a = Ke(e, Tk)
    return v.createElement(
      v.Fragment,
      null,
      v.createElement(kk, {
        interval: (t = a.interval) !== null && t !== void 0 ? t : 'preserveEnd',
        id: a.xAxisId,
        scale: a.scale,
        type: a.type,
        padding: a.padding,
        allowDataOverflow: a.allowDataOverflow,
        domain: a.domain,
        dataKey: a.dataKey,
        allowDuplicatedCategory: a.allowDuplicatedCategory,
        allowDecimals: a.allowDecimals,
        tickCount: a.tickCount,
        includeHidden: (n = a.includeHidden) !== null && n !== void 0 ? n : !1,
        reversed: a.reversed,
        ticks: a.ticks,
        height: a.height,
        orientation: a.orientation,
        mirror: a.mirror,
        hide: a.hide,
        unit: a.unit,
        name: a.name,
        angle: (r = a.angle) !== null && r !== void 0 ? r : 0,
        minTickGap: (i = a.minTickGap) !== null && i !== void 0 ? i : 5,
        tick: (o = a.tick) !== null && o !== void 0 ? o : !0,
        tickFormatter: a.tickFormatter,
      }),
      v.createElement(Mk, a),
    )
  },
  Dk = (e, t) => {
    var { domain: n } = e,
      r = Xi(e, Ak),
      { domain: i } = t,
      o = Xi(t, Ok)
    return On(r, o)
      ? Array.isArray(n) && n.length === 2 && Array.isArray(i) && i.length === 2
        ? n[0] === i[0] && n[1] === i[1]
        : On({ domain: n }, { domain: i })
      : !1
  },
  Ik = v.memo(Nk, Dk)
Ik.displayName = 'XAxis'
var jk = ['dangerouslySetInnerHTML', 'ticks'],
  $k = ['id'],
  Lk = ['domain'],
  zk = ['domain']
function Qa() {
  return (
    (Qa = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Qa.apply(null, arguments)
  )
}
function Gi(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = Rk(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function Rk(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function Bk(e) {
  var t = pe()
  return (
    v.useLayoutEffect(
      () => (
        t(AO(e)),
        () => {
          t(OO(e))
        }
      ),
      [e, t],
    ),
    null
  )
}
var Hk = (e) => {
    var { yAxisId: t, className: n, width: r, label: i } = e,
      o = v.useRef(null),
      a = v.useRef(null),
      s = J(Rd),
      l = We(),
      c = pe(),
      u = 'yAxis',
      f = J((P) => Bn(P, u, t, l)),
      d = J((P) => iE(P, t)),
      h = J((P) => rE(P, t)),
      g = J((P) => _p(P, u, t, l)),
      p = J((P) => Yh(P, t))
    if (
      (v.useLayoutEffect(() => {
        if (!(r !== 'auto' || !d || xc(i) || v.isValidElement(i) || p == null)) {
          var P = o.current
          if (P) {
            var S = P.getCalculatedWidth()
            Math.round(d.width) !== Math.round(S) && c(MO({ id: t, width: S }))
          }
        }
      }, [g, d, c, i, t, r, p]),
      d == null || h == null || p == null)
    )
      return null
    var { dangerouslySetInnerHTML: x, ticks: y } = e,
      w = Gi(e, jk),
      { id: m } = p,
      b = Gi(p, $k)
    return v.createElement(
      Sc,
      Qa({}, w, b, {
        ref: o,
        labelRef: a,
        scale: f,
        x: h.x,
        y: h.y,
        tickTextProps: r === 'auto' ? { width: void 0 } : { width: r },
        width: d.width,
        height: d.height,
        className: le('recharts-'.concat(u, ' ').concat(u), n),
        viewBox: s,
        ticks: g,
      }),
    )
  },
  Fk = {
    allowDataOverflow: Re.allowDataOverflow,
    allowDecimals: Re.allowDecimals,
    allowDuplicatedCategory: Re.allowDuplicatedCategory,
    hide: !1,
    mirror: Re.mirror,
    orientation: Re.orientation,
    padding: Re.padding,
    reversed: Re.reversed,
    scale: Re.scale,
    tickCount: Re.tickCount,
    type: Re.type,
    width: Re.width,
    yAxisId: 0,
  },
  Vk = (e) => {
    var t,
      n,
      r,
      i,
      o,
      a = Ke(e, Fk)
    return v.createElement(
      v.Fragment,
      null,
      v.createElement(Bk, {
        interval: (t = a.interval) !== null && t !== void 0 ? t : 'preserveEnd',
        id: a.yAxisId,
        scale: a.scale,
        type: a.type,
        domain: a.domain,
        allowDataOverflow: a.allowDataOverflow,
        dataKey: a.dataKey,
        allowDuplicatedCategory: a.allowDuplicatedCategory,
        allowDecimals: a.allowDecimals,
        tickCount: a.tickCount,
        padding: a.padding,
        includeHidden: (n = a.includeHidden) !== null && n !== void 0 ? n : !1,
        reversed: a.reversed,
        ticks: a.ticks,
        width: a.width,
        orientation: a.orientation,
        mirror: a.mirror,
        hide: a.hide,
        unit: a.unit,
        name: a.name,
        angle: (r = a.angle) !== null && r !== void 0 ? r : 0,
        minTickGap: (i = a.minTickGap) !== null && i !== void 0 ? i : 5,
        tick: (o = a.tick) !== null && o !== void 0 ? o : !0,
        tickFormatter: a.tickFormatter,
      }),
      v.createElement(Hk, a),
    )
  },
  Wk = (e, t) => {
    var { domain: n } = e,
      r = Gi(e, Lk),
      { domain: i } = t,
      o = Gi(t, zk)
    return On(r, o)
      ? Array.isArray(n) && n.length === 2 && Array.isArray(i) && i.length === 2
        ? n[0] === i[0] && n[1] === i[1]
        : On({ domain: n }, { domain: i })
      : !1
  },
  Kk = v.memo(Vk, Wk)
Kk.displayName = 'YAxis'
var Yk = (e, t) => t,
  _c = R([Yk, he, Hh, we, Wp, Dt, u_, Oe], v_),
  Ac = (e) => {
    var t = e.currentTarget.getBoundingClientRect(),
      n = t.width / e.currentTarget.offsetWidth,
      r = t.height / e.currentTarget.offsetHeight
    return {
      chartX: Math.round((e.clientX - t.left) / n),
      chartY: Math.round((e.clientY - t.top) / r),
    }
  },
  Ov = jn('mouseClick'),
  Cv = Er()
Cv.startListening({
  actionCreator: Ov,
  effect: (e, t) => {
    var n = e.payload,
      r = _c(t.getState(), Ac(n))
    r?.activeIndex != null &&
      t.dispatch(
        yE({
          activeIndex: r.activeIndex,
          activeDataKey: void 0,
          activeCoordinate: r.activeCoordinate,
        }),
      )
  },
})
var Ja = jn('mouseMove'),
  kv = Er()
kv.startListening({
  actionCreator: Ja,
  effect: (e, t) => {
    var n = e.payload,
      r = t.getState(),
      i = lc(r, r.tooltip.settings.shared),
      o = _c(r, Ac(n))
    i === 'axis' &&
      (o?.activeIndex != null
        ? t.dispatch(
            jp({
              activeIndex: o.activeIndex,
              activeDataKey: void 0,
              activeCoordinate: o.activeCoordinate,
            }),
          )
        : t.dispatch(Ip()))
  },
})
var ff = {
    accessibilityLayer: !0,
    barCategoryGap: '10%',
    barGap: 4,
    barSize: void 0,
    className: void 0,
    maxBarSize: void 0,
    stackOffset: 'none',
    syncId: void 0,
    syncMethod: 'index',
  },
  Mv = Ve({
    name: 'rootProps',
    initialState: ff,
    reducers: {
      updateOptions: (e, t) => {
        var n
        ;((e.accessibilityLayer = t.payload.accessibilityLayer),
          (e.barCategoryGap = t.payload.barCategoryGap),
          (e.barGap = (n = t.payload.barGap) !== null && n !== void 0 ? n : ff.barGap),
          (e.barSize = t.payload.barSize),
          (e.maxBarSize = t.payload.maxBarSize),
          (e.stackOffset = t.payload.stackOffset),
          (e.syncId = t.payload.syncId),
          (e.syncMethod = t.payload.syncMethod),
          (e.className = t.payload.className))
      },
    },
  }),
  Uk = Mv.reducer,
  { updateOptions: Xk } = Mv.actions,
  Tv = Ve({
    name: 'polarOptions',
    initialState: null,
    reducers: { updatePolarOptions: (e, t) => t.payload },
  }),
  { updatePolarOptions: B$ } = Tv.actions,
  Gk = Tv.reducer,
  Nv = jn('keyDown'),
  Dv = jn('focus'),
  Oc = Er()
Oc.startListening({
  actionCreator: Nv,
  effect: (e, t) => {
    var n = t.getState(),
      r = n.rootProps.accessibilityLayer !== !1
    if (r) {
      var { keyboardInteraction: i } = n.tooltip,
        o = e.payload
      if (!(o !== 'ArrowRight' && o !== 'ArrowLeft' && o !== 'Enter')) {
        var a = Number(uc(i, Fn(n))),
          s = Dt(n)
        if (o === 'Enter') {
          var l = Fi(n, 'axis', 'hover', String(i.index))
          t.dispatch(
            Ka({
              active: !i.active,
              activeIndex: i.index,
              activeDataKey: i.dataKey,
              activeCoordinate: l,
            }),
          )
          return
        }
        var c = lE(n),
          u = c === 'left-to-right' ? 1 : -1,
          f = o === 'ArrowRight' ? 1 : -1,
          d = a + f * u
        if (!(s == null || d >= s.length || d < 0)) {
          var h = Fi(n, 'axis', 'hover', String(d))
          t.dispatch(
            Ka({
              active: !0,
              activeIndex: d.toString(),
              activeDataKey: void 0,
              activeCoordinate: h,
            }),
          )
        }
      }
    }
  },
})
Oc.startListening({
  actionCreator: Dv,
  effect: (e, t) => {
    var n = t.getState(),
      r = n.rootProps.accessibilityLayer !== !1
    if (r) {
      var { keyboardInteraction: i } = n.tooltip
      if (!i.active && i.index == null) {
        var o = '0',
          a = Fi(n, 'axis', 'hover', String(o))
        t.dispatch(Ka({ activeDataKey: void 0, active: !0, activeIndex: o, activeCoordinate: a }))
      }
    }
  },
})
var qe = jn('externalEvent'),
  Iv = Er()
Iv.startListening({
  actionCreator: qe,
  effect: (e, t) => {
    if (e.payload.handler != null) {
      var n = t.getState(),
        r = {
          activeCoordinate: t_(n),
          activeDataKey: JE(n),
          activeIndex: hr(n),
          activeLabel: Up(n),
          activeTooltipIndex: hr(n),
          isTooltipActive: n_(n),
        }
      e.payload.handler(r, e.payload.reactEvent)
    }
  },
})
var qk = R([Hn], (e) => e.tooltipItemPayloads),
  Zk = R([qk, $r, (e, t, n) => t, (e, t, n) => n], (e, t, n, r) => {
    var i = e.find((s) => s.settings.dataKey === r)
    if (i != null) {
      var { positions: o } = i
      if (o != null) {
        var a = t(o, n)
        return a
      }
    }
  }),
  jv = jn('touchMove'),
  $v = Er()
$v.startListening({
  actionCreator: jv,
  effect: (e, t) => {
    var n = e.payload,
      r = t.getState(),
      i = lc(r, r.tooltip.settings.shared)
    if (i === 'axis') {
      var o = _c(
        r,
        Ac({
          clientX: n.touches[0].clientX,
          clientY: n.touches[0].clientY,
          currentTarget: n.currentTarget,
        }),
      )
      o?.activeIndex != null &&
        t.dispatch(
          jp({
            activeIndex: o.activeIndex,
            activeDataKey: void 0,
            activeCoordinate: o.activeCoordinate,
          }),
        )
    } else if (i === 'item') {
      var a,
        s = n.touches[0],
        l = document.elementFromPoint(s.clientX, s.clientY)
      if (!l || !l.getAttribute) return
      var c = l.getAttribute(Ld),
        u = (a = l.getAttribute(zd)) !== null && a !== void 0 ? a : void 0,
        f = Zk(t.getState(), c, u)
      t.dispatch(Dp({ activeDataKey: u, activeIndex: c, activeCoordinate: f }))
    }
  },
})
var Qk = My({
    brush: WO,
    cartesianAxis: TO,
    chartData: k_,
    errorBars: jO,
    graphicalItems: yO,
    layout: q0,
    legend: Fx,
    options: E_,
    polarAxis: HA,
    polarOptions: Gk,
    referenceElements: ZO,
    rootProps: Uk,
    tooltip: xE,
  }),
  Jk = function (t) {
    return Cy({
      reducer: Qk,
      preloadedState: t,
      middleware: (n) =>
        n({ serializableCheck: !1 }).concat([
          Cv.middleware,
          kv.middleware,
          Oc.middleware,
          Iv.middleware,
          $v.middleware,
        ]),
      enhancers: (n) => {
        var r = n
        return (typeof n == 'function' && (r = n()), r.concat(ky({ type: 'raf' })))
      },
      devTools: $n.devToolsEnabled,
    })
  }
function eM(e) {
  var { preloadedState: t, children: n, reduxStoreName: r } = e,
    i = We(),
    o = v.useRef(null)
  if (i) return n
  o.current == null && (o.current = Jk(t))
  var a = ws
  return v.createElement(wy, { context: a, store: o.current }, n)
}
function tM(e) {
  var { layout: t, margin: n } = e,
    r = pe(),
    i = We()
  return (
    v.useEffect(() => {
      i || (r(U0(t)), r(Y0(n)))
    }, [r, i, t, n]),
    null
  )
}
function nM(e) {
  var t = pe()
  return (
    v.useEffect(() => {
      t(Xk(e))
    }, [t, e]),
    null
  )
}
var rM = ['children']
function iM(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = oM(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function oM(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
function qi() {
  return (
    (qi = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    qi.apply(null, arguments)
  )
}
var aM = { width: '100%', height: '100%', display: 'block' },
  sM = v.forwardRef((e, t) => {
    var n = Ps(),
      r = Ss(),
      i = Wd()
    if (!Oi(n) || !Oi(r)) return null
    var { children: o, otherAttributes: a, title: s, desc: l } = e,
      c,
      u
    return (
      typeof a.tabIndex == 'number' ? (c = a.tabIndex) : (c = i ? 0 : void 0),
      typeof a.role == 'string' ? (u = a.role) : (u = i ? 'application' : void 0),
      v.createElement(
        ps,
        qi({}, a, {
          title: s,
          desc: l,
          role: u,
          tabIndex: c,
          width: n,
          height: r,
          style: aM,
          ref: t,
        }),
        o,
      )
    )
  }),
  cM = (e) => {
    var { children: t } = e,
      n = J(go)
    if (!n) return null
    var { width: r, height: i, y: o, x: a } = n
    return v.createElement(ps, { width: r, height: i, x: a, y: o }, t)
  },
  df = v.forwardRef((e, t) => {
    var { children: n } = e,
      r = iM(e, rM),
      i = We()
    return i ? v.createElement(cM, null, n) : v.createElement(sM, qi({ ref: t }, r), n)
  })
function lM() {
  var e = pe(),
    [t, n] = v.useState(null),
    r = J(Ex)
  return (
    v.useEffect(() => {
      if (t != null) {
        var i = t.getBoundingClientRect(),
          o = i.width / t.offsetWidth
        Le(o) && o !== r && e(G0(o))
      }
    }, [t, e, r]),
    n
  )
}
function hf(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    ;(t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r))
  }
  return n
}
function uM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? hf(Object(n), !0).forEach(function (r) {
          fM(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : hf(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function fM(e, t, n) {
  return (
    (t = dM(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function dM(e) {
  var t = hM(e, 'string')
  return typeof t == 'symbol' ? t : t + ''
}
function hM(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t)
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function an() {
  return (
    (an = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    an.apply(null, arguments)
  )
}
var pM = () => (z_(), null)
function Zi(e) {
  if (typeof e == 'number') return e
  if (typeof e == 'string') {
    var t = parseFloat(e)
    if (!Number.isNaN(t)) return t
  }
  return 0
}
var vM = v.forwardRef((e, t) => {
    var n,
      r,
      i = v.useRef(null),
      [o, a] = v.useState({
        containerWidth: Zi((n = e.style) === null || n === void 0 ? void 0 : n.width),
        containerHeight: Zi((r = e.style) === null || r === void 0 ? void 0 : r.height),
      }),
      s = v.useCallback((c, u) => {
        a((f) => {
          var d = Math.round(c),
            h = Math.round(u)
          return f.containerWidth === d && f.containerHeight === h
            ? f
            : { containerWidth: d, containerHeight: h }
        })
      }, []),
      l = v.useCallback(
        (c) => {
          if ((typeof t == 'function' && t(c), c != null)) {
            var { width: u, height: f } = c.getBoundingClientRect()
            s(u, f)
            var d = (g) => {
                var { width: p, height: x } = g[0].contentRect
                s(p, x)
              },
              h = new ResizeObserver(d)
            ;(h.observe(c), (i.current = h))
          }
        },
        [t, s],
      )
    return (
      v.useEffect(
        () => () => {
          var c = i.current
          c?.disconnect()
        },
        [s],
      ),
      v.createElement(
        v.Fragment,
        null,
        v.createElement(mo, { width: o.containerWidth, height: o.containerHeight }),
        v.createElement('div', an({ ref: l }, e)),
      )
    )
  }),
  gM = v.forwardRef((e, t) => {
    var { width: n, height: r } = e,
      [i, o] = v.useState({ containerWidth: Zi(n), containerHeight: Zi(r) }),
      a = v.useCallback((l, c) => {
        o((u) => {
          var f = Math.round(l),
            d = Math.round(c)
          return u.containerWidth === f && u.containerHeight === d
            ? u
            : { containerWidth: f, containerHeight: d }
        })
      }, []),
      s = v.useCallback(
        (l) => {
          if ((typeof t == 'function' && t(l), l != null)) {
            var { width: c, height: u } = l.getBoundingClientRect()
            a(c, u)
          }
        },
        [t, a],
      )
    return v.createElement(
      v.Fragment,
      null,
      v.createElement(mo, { width: i.containerWidth, height: i.containerHeight }),
      v.createElement('div', an({ ref: s }, e)),
    )
  }),
  mM = v.forwardRef((e, t) => {
    var { width: n, height: r } = e
    return v.createElement(
      v.Fragment,
      null,
      v.createElement(mo, { width: n, height: r }),
      v.createElement('div', an({ ref: t }, e)),
    )
  }),
  yM = v.forwardRef((e, t) => {
    var { width: n, height: r } = e
    return sr(n) || sr(r)
      ? v.createElement(gM, an({}, e, { ref: t }))
      : v.createElement(mM, an({}, e, { ref: t }))
  })
function xM(e) {
  return e === !0 ? vM : yM
}
var bM = v.forwardRef((e, t) => {
    var {
        children: n,
        className: r,
        height: i,
        onClick: o,
        onContextMenu: a,
        onDoubleClick: s,
        onMouseDown: l,
        onMouseEnter: c,
        onMouseLeave: u,
        onMouseMove: f,
        onMouseUp: d,
        onTouchEnd: h,
        onTouchMove: g,
        onTouchStart: p,
        style: x,
        width: y,
        responsive: w,
        dispatchTouchEvents: m = !0,
      } = e,
      b = v.useRef(null),
      P = pe(),
      [S, _] = v.useState(null),
      [M, T] = v.useState(null),
      F = lM(),
      D = Bd(),
      k = D?.width > 0 ? D.width : y,
      $ = D?.height > 0 ? D.height : i,
      E = v.useCallback(
        (j) => {
          ;(F(j), typeof t == 'function' && t(j), _(j), T(j), j != null && (b.current = j))
        },
        [F, t, _, T],
      ),
      O = v.useCallback(
        (j) => {
          ;(P(Ov(j)), P(qe({ handler: o, reactEvent: j })))
        },
        [P, o],
      ),
      A = v.useCallback(
        (j) => {
          ;(P(Ja(j)), P(qe({ handler: c, reactEvent: j })))
        },
        [P, c],
      ),
      C = v.useCallback(
        (j) => {
          ;(P(Ip()), P(qe({ handler: u, reactEvent: j })))
        },
        [P, u],
      ),
      N = v.useCallback(
        (j) => {
          ;(P(Ja(j)), P(qe({ handler: f, reactEvent: j })))
        },
        [P, f],
      ),
      I = v.useCallback(() => {
        P(Dv())
      }, [P]),
      H = v.useCallback(
        (j) => {
          P(Nv(j.key))
        },
        [P],
      ),
      V = v.useCallback(
        (j) => {
          P(qe({ handler: a, reactEvent: j }))
        },
        [P, a],
      ),
      B = v.useCallback(
        (j) => {
          P(qe({ handler: s, reactEvent: j }))
        },
        [P, s],
      ),
      Y = v.useCallback(
        (j) => {
          P(qe({ handler: l, reactEvent: j }))
        },
        [P, l],
      ),
      K = v.useCallback(
        (j) => {
          P(qe({ handler: d, reactEvent: j }))
        },
        [P, d],
      ),
      G = v.useCallback(
        (j) => {
          P(qe({ handler: p, reactEvent: j }))
        },
        [P, p],
      ),
      re = v.useCallback(
        (j) => {
          ;(m && P(jv(j)), P(qe({ handler: g, reactEvent: j })))
        },
        [P, m, g],
      ),
      q = v.useCallback(
        (j) => {
          P(qe({ handler: h, reactEvent: j }))
        },
        [P, h],
      ),
      W = xM(w)
    return v.createElement(
      Jp.Provider,
      { value: S },
      v.createElement(
        cd.Provider,
        { value: M },
        v.createElement(
          W,
          {
            width: k ?? x?.width,
            height: $ ?? x?.height,
            className: le('recharts-wrapper', r),
            style: uM({ position: 'relative', cursor: 'default', width: k, height: $ }, x),
            onClick: O,
            onContextMenu: V,
            onDoubleClick: B,
            onFocus: I,
            onKeyDown: H,
            onMouseDown: Y,
            onMouseEnter: A,
            onMouseLeave: C,
            onMouseMove: N,
            onMouseUp: K,
            onTouchEnd: q,
            onTouchMove: re,
            onTouchStart: G,
            ref: E,
          },
          v.createElement(pM, null),
          n,
        ),
      ),
    )
  }),
  wM = [
    'width',
    'height',
    'responsive',
    'children',
    'className',
    'style',
    'compact',
    'title',
    'desc',
  ]
function PM(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = SM(e, t)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (r = 0; r < o.length; r++)
      ((n = o[r]), t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
function SM(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue
      n[r] = e[r]
    }
  return n
}
var EM = v.forwardRef((e, t) => {
  var {
      width: n,
      height: r,
      responsive: i,
      children: o,
      className: a,
      style: s,
      compact: l,
      title: c,
      desc: u,
    } = e,
    f = PM(e, wM),
    d = ft(f)
  return l
    ? v.createElement(
        v.Fragment,
        null,
        v.createElement(mo, { width: n, height: r }),
        v.createElement(df, { otherAttributes: d, title: c, desc: u }, o),
      )
    : v.createElement(
        bM,
        {
          className: a,
          style: s,
          width: n,
          height: r,
          responsive: i,
          onClick: e.onClick,
          onMouseLeave: e.onMouseLeave,
          onMouseEnter: e.onMouseEnter,
          onMouseMove: e.onMouseMove,
          onMouseDown: e.onMouseDown,
          onMouseUp: e.onMouseUp,
          onContextMenu: e.onContextMenu,
          onDoubleClick: e.onDoubleClick,
          onTouchStart: e.onTouchStart,
          onTouchMove: e.onTouchMove,
          onTouchEnd: e.onTouchEnd,
        },
        v.createElement(
          df,
          { otherAttributes: d, title: c, desc: u, ref: t },
          v.createElement(JO, null, o),
        ),
      )
})
function es() {
  return (
    (es = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    es.apply(null, arguments)
  )
}
var _M = { top: 5, right: 5, bottom: 5, left: 5 },
  AM = {
    accessibilityLayer: !0,
    layout: 'horizontal',
    stackOffset: 'none',
    barCategoryGap: '10%',
    barGap: 4,
    margin: _M,
    reverseStackOrder: !1,
    syncMethod: 'index',
    responsive: !1,
  },
  OM = v.forwardRef(function (t, n) {
    var r,
      i = Ke(t.categoricalChartProps, AM),
      {
        chartName: o,
        defaultTooltipEventType: a,
        validateTooltipEventTypes: s,
        tooltipPayloadSearcher: l,
        categoricalChartProps: c,
      } = t,
      u = {
        chartName: o,
        defaultTooltipEventType: a,
        validateTooltipEventTypes: s,
        tooltipPayloadSearcher: l,
        eventEmitter: void 0,
      }
    return v.createElement(
      eM,
      {
        preloadedState: { options: u },
        reduxStoreName: (r = c.id) !== null && r !== void 0 ? r : o,
      },
      v.createElement(VO, { chartData: c.data }),
      v.createElement(tM, { layout: i.layout, margin: i.margin }),
      v.createElement(nM, {
        accessibilityLayer: i.accessibilityLayer,
        barCategoryGap: i.barCategoryGap,
        maxBarSize: i.maxBarSize,
        stackOffset: i.stackOffset,
        barGap: i.barGap,
        barSize: i.barSize,
        syncId: i.syncId,
        syncMethod: i.syncMethod,
        className: i.className,
      }),
      v.createElement(EM, es({}, i, { ref: n })),
    )
  }),
  CM = ['item'],
  H$ = v.forwardRef((e, t) =>
    v.createElement(OM, {
      chartName: 'ScatterChart',
      defaultTooltipEventType: 'item',
      validateTooltipEventTypes: CM,
      tooltipPayloadSearcher: P_,
      categoricalChartProps: e,
      ref: t,
    }),
  ),
  kM = { value: () => {} }
function jo() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + '') || r in n || /[\s.]/.test(r)) throw new Error('illegal type: ' + r)
    n[r] = []
  }
  return new gi(n)
}
function gi(e) {
  this._ = e
}
function MM(e, t) {
  return e
    .trim()
    .split(/^|\s+/)
    .map(function (n) {
      var r = '',
        i = n.indexOf('.')
      if ((i >= 0 && ((r = n.slice(i + 1)), (n = n.slice(0, i))), n && !t.hasOwnProperty(n)))
        throw new Error('unknown type: ' + n)
      return { type: n, name: r }
    })
}
gi.prototype = jo.prototype = {
  constructor: gi,
  on: function (e, t) {
    var n = this._,
      r = MM(e + '', n),
      i,
      o = -1,
      a = r.length
    if (arguments.length < 2) {
      for (; ++o < a; ) if ((i = (e = r[o]).type) && (i = TM(n[i], e.name))) return i
      return
    }
    if (t != null && typeof t != 'function') throw new Error('invalid callback: ' + t)
    for (; ++o < a; )
      if ((i = (e = r[o]).type)) n[i] = pf(n[i], e.name, t)
      else if (t == null) for (i in n) n[i] = pf(n[i], e.name, null)
    return this
  },
  copy: function () {
    var e = {},
      t = this._
    for (var n in t) e[n] = t[n].slice()
    return new gi(e)
  },
  call: function (e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, o; r < i; ++r) n[r] = arguments[r + 2]
    if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
    for (o = this._[e], r = 0, i = o.length; r < i; ++r) o[r].value.apply(t, n)
  },
  apply: function (e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
    for (var r = this._[e], i = 0, o = r.length; i < o; ++i) r[i].value.apply(t, n)
  },
}
function TM(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n) if ((i = e[n]).name === t) return i.value
}
function pf(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      ;((e[r] = kM), (e = e.slice(0, r).concat(e.slice(r + 1))))
      break
    }
  return (n != null && e.push({ name: t, value: n }), e)
}
var ts = 'http://www.w3.org/1999/xhtml'
const vf = {
  svg: 'http://www.w3.org/2000/svg',
  xhtml: ts,
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace',
  xmlns: 'http://www.w3.org/2000/xmlns/',
}
function $o(e) {
  var t = (e += ''),
    n = t.indexOf(':')
  return (
    n >= 0 && (t = e.slice(0, n)) !== 'xmlns' && (e = e.slice(n + 1)),
    vf.hasOwnProperty(t) ? { space: vf[t], local: e } : e
  )
}
function NM(e) {
  return function () {
    var t = this.ownerDocument,
      n = this.namespaceURI
    return n === ts && t.documentElement.namespaceURI === ts
      ? t.createElement(e)
      : t.createElementNS(n, e)
  }
}
function DM(e) {
  return function () {
    return this.ownerDocument.createElementNS(e.space, e.local)
  }
}
function Lv(e) {
  var t = $o(e)
  return (t.local ? DM : NM)(t)
}
function IM() {}
function Cc(e) {
  return e == null
    ? IM
    : function () {
        return this.querySelector(e)
      }
}
function jM(e) {
  typeof e != 'function' && (e = Cc(e))
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], a = o.length, s = (r[i] = new Array(a)), l, c, u = 0; u < a; ++u)
      (l = o[u]) &&
        (c = e.call(l, l.__data__, u, o)) &&
        ('__data__' in l && (c.__data__ = l.__data__), (s[u] = c))
  return new Fe(r, this._parents)
}
function $M(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e)
}
function LM() {
  return []
}
function zv(e) {
  return e == null
    ? LM
    : function () {
        return this.querySelectorAll(e)
      }
}
function zM(e) {
  return function () {
    return $M(e.apply(this, arguments))
  }
}
function RM(e) {
  typeof e == 'function' ? (e = zM(e)) : (e = zv(e))
  for (var t = this._groups, n = t.length, r = [], i = [], o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, l, c = 0; c < s; ++c)
      (l = a[c]) && (r.push(e.call(l, l.__data__, c, a)), i.push(l))
  return new Fe(r, i)
}
function Rv(e) {
  return function () {
    return this.matches(e)
  }
}
function Bv(e) {
  return function (t) {
    return t.matches(e)
  }
}
var BM = Array.prototype.find
function HM(e) {
  return function () {
    return BM.call(this.children, e)
  }
}
function FM() {
  return this.firstElementChild
}
function VM(e) {
  return this.select(e == null ? FM : HM(typeof e == 'function' ? e : Bv(e)))
}
var WM = Array.prototype.filter
function KM() {
  return Array.from(this.children)
}
function YM(e) {
  return function () {
    return WM.call(this.children, e)
  }
}
function UM(e) {
  return this.selectAll(e == null ? KM : YM(typeof e == 'function' ? e : Bv(e)))
}
function XM(e) {
  typeof e != 'function' && (e = Rv(e))
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], a = o.length, s = (r[i] = []), l, c = 0; c < a; ++c)
      (l = o[c]) && e.call(l, l.__data__, c, o) && s.push(l)
  return new Fe(r, this._parents)
}
function Hv(e) {
  return new Array(e.length)
}
function GM() {
  return new Fe(this._enter || this._groups.map(Hv), this._parents)
}
function Qi(e, t) {
  ;((this.ownerDocument = e.ownerDocument),
    (this.namespaceURI = e.namespaceURI),
    (this._next = null),
    (this._parent = e),
    (this.__data__ = t))
}
Qi.prototype = {
  constructor: Qi,
  appendChild: function (e) {
    return this._parent.insertBefore(e, this._next)
  },
  insertBefore: function (e, t) {
    return this._parent.insertBefore(e, t)
  },
  querySelector: function (e) {
    return this._parent.querySelector(e)
  },
  querySelectorAll: function (e) {
    return this._parent.querySelectorAll(e)
  },
}
function qM(e) {
  return function () {
    return e
  }
}
function ZM(e, t, n, r, i, o) {
  for (var a = 0, s, l = t.length, c = o.length; a < c; ++a)
    (s = t[a]) ? ((s.__data__ = o[a]), (r[a] = s)) : (n[a] = new Qi(e, o[a]))
  for (; a < l; ++a) (s = t[a]) && (i[a] = s)
}
function QM(e, t, n, r, i, o, a) {
  var s,
    l,
    c = new Map(),
    u = t.length,
    f = o.length,
    d = new Array(u),
    h
  for (s = 0; s < u; ++s)
    (l = t[s]) &&
      ((d[s] = h = a.call(l, l.__data__, s, t) + ''), c.has(h) ? (i[s] = l) : c.set(h, l))
  for (s = 0; s < f; ++s)
    ((h = a.call(e, o[s], s, o) + ''),
      (l = c.get(h)) ? ((r[s] = l), (l.__data__ = o[s]), c.delete(h)) : (n[s] = new Qi(e, o[s])))
  for (s = 0; s < u; ++s) (l = t[s]) && c.get(d[s]) === l && (i[s] = l)
}
function JM(e) {
  return e.__data__
}
function eT(e, t) {
  if (!arguments.length) return Array.from(this, JM)
  var n = t ? QM : ZM,
    r = this._parents,
    i = this._groups
  typeof e != 'function' && (e = qM(e))
  for (var o = i.length, a = new Array(o), s = new Array(o), l = new Array(o), c = 0; c < o; ++c) {
    var u = r[c],
      f = i[c],
      d = f.length,
      h = tT(e.call(u, u && u.__data__, c, r)),
      g = h.length,
      p = (s[c] = new Array(g)),
      x = (a[c] = new Array(g)),
      y = (l[c] = new Array(d))
    n(u, f, p, x, y, h, t)
    for (var w = 0, m = 0, b, P; w < g; ++w)
      if ((b = p[w])) {
        for (w >= m && (m = w + 1); !(P = x[m]) && ++m < g; );
        b._next = P || null
      }
  }
  return ((a = new Fe(a, r)), (a._enter = s), (a._exit = l), a)
}
function tT(e) {
  return typeof e == 'object' && 'length' in e ? e : Array.from(e)
}
function nT() {
  return new Fe(this._exit || this._groups.map(Hv), this._parents)
}
function rT(e, t, n) {
  var r = this.enter(),
    i = this,
    o = this.exit()
  return (
    typeof e == 'function' ? ((r = e(r)), r && (r = r.selection())) : (r = r.append(e + '')),
    t != null && ((i = t(i)), i && (i = i.selection())),
    n == null ? o.remove() : n(o),
    r && i ? r.merge(i).order() : i
  )
}
function iT(e) {
  for (
    var t = e.selection ? e.selection() : e,
      n = this._groups,
      r = t._groups,
      i = n.length,
      o = r.length,
      a = Math.min(i, o),
      s = new Array(i),
      l = 0;
    l < a;
    ++l
  )
    for (var c = n[l], u = r[l], f = c.length, d = (s[l] = new Array(f)), h, g = 0; g < f; ++g)
      (h = c[g] || u[g]) && (d[g] = h)
  for (; l < i; ++l) s[l] = n[l]
  return new Fe(s, this._parents)
}
function oT() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, o = r[i], a; --i >= 0; )
      (a = r[i]) &&
        (o && a.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(a, o), (o = a))
  return this
}
function aT(e) {
  e || (e = sT)
  function t(f, d) {
    return f && d ? e(f.__data__, d.__data__) : !f - !d
  }
  for (var n = this._groups, r = n.length, i = new Array(r), o = 0; o < r; ++o) {
    for (var a = n[o], s = a.length, l = (i[o] = new Array(s)), c, u = 0; u < s; ++u)
      (c = a[u]) && (l[u] = c)
    l.sort(t)
  }
  return new Fe(i, this._parents).order()
}
function sT(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
}
function cT() {
  var e = arguments[0]
  return ((arguments[0] = this), e.apply(null, arguments), this)
}
function lT() {
  return Array.from(this)
}
function uT() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length; i < o; ++i) {
      var a = r[i]
      if (a) return a
    }
  return null
}
function fT() {
  let e = 0
  for (const t of this) ++e
  return e
}
function dT() {
  return !this.node()
}
function hT(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], o = 0, a = i.length, s; o < a; ++o) (s = i[o]) && e.call(s, s.__data__, o, i)
  return this
}
function pT(e) {
  return function () {
    this.removeAttribute(e)
  }
}
function vT(e) {
  return function () {
    this.removeAttributeNS(e.space, e.local)
  }
}
function gT(e, t) {
  return function () {
    this.setAttribute(e, t)
  }
}
function mT(e, t) {
  return function () {
    this.setAttributeNS(e.space, e.local, t)
  }
}
function yT(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n)
  }
}
function xT(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n)
  }
}
function bT(e, t) {
  var n = $o(e)
  if (arguments.length < 2) {
    var r = this.node()
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n)
  }
  return this.each(
    (t == null
      ? n.local
        ? vT
        : pT
      : typeof t == 'function'
        ? n.local
          ? xT
          : yT
        : n.local
          ? mT
          : gT)(n, t),
  )
}
function Fv(e) {
  return (e.ownerDocument && e.ownerDocument.defaultView) || (e.document && e) || e.defaultView
}
function wT(e) {
  return function () {
    this.style.removeProperty(e)
  }
}
function PT(e, t, n) {
  return function () {
    this.style.setProperty(e, t, n)
  }
}
function ST(e, t, n) {
  return function () {
    var r = t.apply(this, arguments)
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n)
  }
}
function ET(e, t, n) {
  return arguments.length > 1
    ? this.each((t == null ? wT : typeof t == 'function' ? ST : PT)(e, t, n ?? ''))
    : Cn(this.node(), e)
}
function Cn(e, t) {
  return e.style.getPropertyValue(t) || Fv(e).getComputedStyle(e, null).getPropertyValue(t)
}
function _T(e) {
  return function () {
    delete this[e]
  }
}
function AT(e, t) {
  return function () {
    this[e] = t
  }
}
function OT(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    n == null ? delete this[e] : (this[e] = n)
  }
}
function CT(e, t) {
  return arguments.length > 1
    ? this.each((t == null ? _T : typeof t == 'function' ? OT : AT)(e, t))
    : this.node()[e]
}
function Vv(e) {
  return e.trim().split(/^|\s+/)
}
function kc(e) {
  return e.classList || new Wv(e)
}
function Wv(e) {
  ;((this._node = e), (this._names = Vv(e.getAttribute('class') || '')))
}
Wv.prototype = {
  add: function (e) {
    var t = this._names.indexOf(e)
    t < 0 && (this._names.push(e), this._node.setAttribute('class', this._names.join(' ')))
  },
  remove: function (e) {
    var t = this._names.indexOf(e)
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute('class', this._names.join(' ')))
  },
  contains: function (e) {
    return this._names.indexOf(e) >= 0
  },
}
function Kv(e, t) {
  for (var n = kc(e), r = -1, i = t.length; ++r < i; ) n.add(t[r])
}
function Yv(e, t) {
  for (var n = kc(e), r = -1, i = t.length; ++r < i; ) n.remove(t[r])
}
function kT(e) {
  return function () {
    Kv(this, e)
  }
}
function MT(e) {
  return function () {
    Yv(this, e)
  }
}
function TT(e, t) {
  return function () {
    ;(t.apply(this, arguments) ? Kv : Yv)(this, e)
  }
}
function NT(e, t) {
  var n = Vv(e + '')
  if (arguments.length < 2) {
    for (var r = kc(this.node()), i = -1, o = n.length; ++i < o; ) if (!r.contains(n[i])) return !1
    return !0
  }
  return this.each((typeof t == 'function' ? TT : t ? kT : MT)(n, t))
}
function DT() {
  this.textContent = ''
}
function IT(e) {
  return function () {
    this.textContent = e
  }
}
function jT(e) {
  return function () {
    var t = e.apply(this, arguments)
    this.textContent = t ?? ''
  }
}
function $T(e) {
  return arguments.length
    ? this.each(e == null ? DT : (typeof e == 'function' ? jT : IT)(e))
    : this.node().textContent
}
function LT() {
  this.innerHTML = ''
}
function zT(e) {
  return function () {
    this.innerHTML = e
  }
}
function RT(e) {
  return function () {
    var t = e.apply(this, arguments)
    this.innerHTML = t ?? ''
  }
}
function BT(e) {
  return arguments.length
    ? this.each(e == null ? LT : (typeof e == 'function' ? RT : zT)(e))
    : this.node().innerHTML
}
function HT() {
  this.nextSibling && this.parentNode.appendChild(this)
}
function FT() {
  return this.each(HT)
}
function VT() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
}
function WT() {
  return this.each(VT)
}
function KT(e) {
  var t = typeof e == 'function' ? e : Lv(e)
  return this.select(function () {
    return this.appendChild(t.apply(this, arguments))
  })
}
function YT() {
  return null
}
function UT(e, t) {
  var n = typeof e == 'function' ? e : Lv(e),
    r = t == null ? YT : typeof t == 'function' ? t : Cc(t)
  return this.select(function () {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null)
  })
}
function XT() {
  var e = this.parentNode
  e && e.removeChild(this)
}
function GT() {
  return this.each(XT)
}
function qT() {
  var e = this.cloneNode(!1),
    t = this.parentNode
  return t ? t.insertBefore(e, this.nextSibling) : e
}
function ZT() {
  var e = this.cloneNode(!0),
    t = this.parentNode
  return t ? t.insertBefore(e, this.nextSibling) : e
}
function QT(e) {
  return this.select(e ? ZT : qT)
}
function JT(e) {
  return arguments.length ? this.property('__data__', e) : this.node().__data__
}
function eN(e) {
  return function (t) {
    e.call(this, t, this.__data__)
  }
}
function tN(e) {
  return e
    .trim()
    .split(/^|\s+/)
    .map(function (t) {
      var n = '',
        r = t.indexOf('.')
      return (r >= 0 && ((n = t.slice(r + 1)), (t = t.slice(0, r))), { type: t, name: n })
    })
}
function nN(e) {
  return function () {
    var t = this.__on
    if (t) {
      for (var n = 0, r = -1, i = t.length, o; n < i; ++n)
        ((o = t[n]),
          (!e.type || o.type === e.type) && o.name === e.name
            ? this.removeEventListener(o.type, o.listener, o.options)
            : (t[++r] = o))
      ++r ? (t.length = r) : delete this.__on
    }
  }
}
function rN(e, t, n) {
  return function () {
    var r = this.__on,
      i,
      o = eN(t)
    if (r) {
      for (var a = 0, s = r.length; a < s; ++a)
        if ((i = r[a]).type === e.type && i.name === e.name) {
          ;(this.removeEventListener(i.type, i.listener, i.options),
            this.addEventListener(i.type, (i.listener = o), (i.options = n)),
            (i.value = t))
          return
        }
    }
    ;(this.addEventListener(e.type, o, n),
      (i = { type: e.type, name: e.name, value: t, listener: o, options: n }),
      r ? r.push(i) : (this.__on = [i]))
  }
}
function iN(e, t, n) {
  var r = tN(e + ''),
    i,
    o = r.length,
    a
  if (arguments.length < 2) {
    var s = this.node().__on
    if (s) {
      for (var l = 0, c = s.length, u; l < c; ++l)
        for (i = 0, u = s[l]; i < o; ++i)
          if ((a = r[i]).type === u.type && a.name === u.name) return u.value
    }
    return
  }
  for (s = t ? rN : nN, i = 0; i < o; ++i) this.each(s(r[i], t, n))
  return this
}
function Uv(e, t, n) {
  var r = Fv(e),
    i = r.CustomEvent
  ;(typeof i == 'function'
    ? (i = new i(t, n))
    : ((i = r.document.createEvent('Event')),
      n
        ? (i.initEvent(t, n.bubbles, n.cancelable), (i.detail = n.detail))
        : i.initEvent(t, !1, !1)),
    e.dispatchEvent(i))
}
function oN(e, t) {
  return function () {
    return Uv(this, e, t)
  }
}
function aN(e, t) {
  return function () {
    return Uv(this, e, t.apply(this, arguments))
  }
}
function sN(e, t) {
  return this.each((typeof t == 'function' ? aN : oN)(e, t))
}
function* cN() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length, a; i < o; ++i) (a = r[i]) && (yield a)
}
var Xv = [null]
function Fe(e, t) {
  ;((this._groups = e), (this._parents = t))
}
function zr() {
  return new Fe([[document.documentElement]], Xv)
}
function lN() {
  return this
}
Fe.prototype = zr.prototype = {
  constructor: Fe,
  select: jM,
  selectAll: RM,
  selectChild: VM,
  selectChildren: UM,
  filter: XM,
  data: eT,
  enter: GM,
  exit: nT,
  join: rT,
  merge: iT,
  selection: lN,
  order: oT,
  sort: aT,
  call: cT,
  nodes: lT,
  node: uT,
  size: fT,
  empty: dT,
  each: hT,
  attr: bT,
  style: ET,
  property: CT,
  classed: NT,
  text: $T,
  html: BT,
  raise: FT,
  lower: WT,
  append: KT,
  insert: UT,
  remove: GT,
  clone: QT,
  datum: JT,
  on: iN,
  dispatch: sN,
  [Symbol.iterator]: cN,
}
function He(e) {
  return typeof e == 'string'
    ? new Fe([[document.querySelector(e)]], [document.documentElement])
    : new Fe([[e]], Xv)
}
function uN(e) {
  let t
  for (; (t = e.sourceEvent); ) e = t
  return e
}
function nt(e, t) {
  if (((e = uN(e)), t === void 0 && (t = e.currentTarget), t)) {
    var n = t.ownerSVGElement || t
    if (n.createSVGPoint) {
      var r = n.createSVGPoint()
      return (
        (r.x = e.clientX),
        (r.y = e.clientY),
        (r = r.matrixTransform(t.getScreenCTM().inverse())),
        [r.x, r.y]
      )
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect()
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop]
    }
  }
  return [e.pageX, e.pageY]
}
const fN = { passive: !1 },
  vr = { capture: !0, passive: !1 }
function ua(e) {
  e.stopImmediatePropagation()
}
function bn(e) {
  ;(e.preventDefault(), e.stopImmediatePropagation())
}
function Gv(e) {
  var t = e.document.documentElement,
    n = He(e).on('dragstart.drag', bn, vr)
  'onselectstart' in t
    ? n.on('selectstart.drag', bn, vr)
    : ((t.__noselect = t.style.MozUserSelect), (t.style.MozUserSelect = 'none'))
}
function qv(e, t) {
  var n = e.document.documentElement,
    r = He(e).on('dragstart.drag', null)
  ;(t &&
    (r.on('click.drag', bn, vr),
    setTimeout(function () {
      r.on('click.drag', null)
    }, 0)),
    'onselectstart' in n
      ? r.on('selectstart.drag', null)
      : ((n.style.MozUserSelect = n.__noselect), delete n.__noselect))
}
const ai = (e) => () => e
function ns(
  e,
  {
    sourceEvent: t,
    subject: n,
    target: r,
    identifier: i,
    active: o,
    x: a,
    y: s,
    dx: l,
    dy: c,
    dispatch: u,
  },
) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: i, enumerable: !0, configurable: !0 },
    active: { value: o, enumerable: !0, configurable: !0 },
    x: { value: a, enumerable: !0, configurable: !0 },
    y: { value: s, enumerable: !0, configurable: !0 },
    dx: { value: l, enumerable: !0, configurable: !0 },
    dy: { value: c, enumerable: !0, configurable: !0 },
    _: { value: u },
  })
}
ns.prototype.on = function () {
  var e = this._.on.apply(this._, arguments)
  return e === this._ ? this : e
}
function dN(e) {
  return !e.ctrlKey && !e.button
}
function hN() {
  return this.parentNode
}
function pN(e, t) {
  return t ?? { x: e.x, y: e.y }
}
function vN() {
  return navigator.maxTouchPoints || 'ontouchstart' in this
}
function Zv() {
  var e = dN,
    t = hN,
    n = pN,
    r = vN,
    i = {},
    o = jo('start', 'drag', 'end'),
    a = 0,
    s,
    l,
    c,
    u,
    f = 0
  function d(b) {
    b.on('mousedown.drag', h)
      .filter(r)
      .on('touchstart.drag', x)
      .on('touchmove.drag', y, fN)
      .on('touchend.drag touchcancel.drag', w)
      .style('touch-action', 'none')
      .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')
  }
  function h(b, P) {
    if (!(u || !e.call(this, b, P))) {
      var S = m(this, t.call(this, b, P), b, P, 'mouse')
      S &&
        (He(b.view).on('mousemove.drag', g, vr).on('mouseup.drag', p, vr),
        Gv(b.view),
        ua(b),
        (c = !1),
        (s = b.clientX),
        (l = b.clientY),
        S('start', b))
    }
  }
  function g(b) {
    if ((bn(b), !c)) {
      var P = b.clientX - s,
        S = b.clientY - l
      c = P * P + S * S > f
    }
    i.mouse('drag', b)
  }
  function p(b) {
    ;(He(b.view).on('mousemove.drag mouseup.drag', null), qv(b.view, c), bn(b), i.mouse('end', b))
  }
  function x(b, P) {
    if (e.call(this, b, P)) {
      var S = b.changedTouches,
        _ = t.call(this, b, P),
        M = S.length,
        T,
        F
      for (T = 0; T < M; ++T)
        (F = m(this, _, b, P, S[T].identifier, S[T])) && (ua(b), F('start', b, S[T]))
    }
  }
  function y(b) {
    var P = b.changedTouches,
      S = P.length,
      _,
      M
    for (_ = 0; _ < S; ++_) (M = i[P[_].identifier]) && (bn(b), M('drag', b, P[_]))
  }
  function w(b) {
    var P = b.changedTouches,
      S = P.length,
      _,
      M
    for (
      u && clearTimeout(u),
        u = setTimeout(function () {
          u = null
        }, 500),
        _ = 0;
      _ < S;
      ++_
    )
      (M = i[P[_].identifier]) && (ua(b), M('end', b, P[_]))
  }
  function m(b, P, S, _, M, T) {
    var F = o.copy(),
      D = nt(T || S, P),
      k,
      $,
      E
    if (
      (E = n.call(
        b,
        new ns('beforestart', {
          sourceEvent: S,
          target: d,
          identifier: M,
          active: a,
          x: D[0],
          y: D[1],
          dx: 0,
          dy: 0,
          dispatch: F,
        }),
        _,
      )) != null
    )
      return (
        (k = E.x - D[0] || 0),
        ($ = E.y - D[1] || 0),
        function O(A, C, N) {
          var I = D,
            H
          switch (A) {
            case 'start':
              ;((i[M] = O), (H = a++))
              break
            case 'end':
              ;(delete i[M], --a)
            case 'drag':
              ;((D = nt(N || C, P)), (H = a))
              break
          }
          F.call(
            A,
            b,
            new ns(A, {
              sourceEvent: C,
              subject: E,
              target: d,
              identifier: M,
              active: H,
              x: D[0] + k,
              y: D[1] + $,
              dx: D[0] - I[0],
              dy: D[1] - I[1],
              dispatch: F,
            }),
            _,
          )
        }
      )
  }
  return (
    (d.filter = function (b) {
      return arguments.length ? ((e = typeof b == 'function' ? b : ai(!!b)), d) : e
    }),
    (d.container = function (b) {
      return arguments.length ? ((t = typeof b == 'function' ? b : ai(b)), d) : t
    }),
    (d.subject = function (b) {
      return arguments.length ? ((n = typeof b == 'function' ? b : ai(b)), d) : n
    }),
    (d.touchable = function (b) {
      return arguments.length ? ((r = typeof b == 'function' ? b : ai(!!b)), d) : r
    }),
    (d.on = function () {
      var b = o.on.apply(o, arguments)
      return b === o ? d : b
    }),
    (d.clickDistance = function (b) {
      return arguments.length ? ((f = (b = +b) * b), d) : Math.sqrt(f)
    }),
    d
  )
}
var kn = 0,
  nr = 0,
  Jn = 0,
  Qv = 1e3,
  Ji,
  rr,
  eo = 0,
  sn = 0,
  Lo = 0,
  gr = typeof performance == 'object' && performance.now ? performance : Date,
  Jv =
    typeof window == 'object' && window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : function (e) {
          setTimeout(e, 17)
        }
function Mc() {
  return sn || (Jv(gN), (sn = gr.now() + Lo))
}
function gN() {
  sn = 0
}
function to() {
  this._call = this._time = this._next = null
}
to.prototype = eg.prototype = {
  constructor: to,
  restart: function (e, t, n) {
    if (typeof e != 'function') throw new TypeError('callback is not a function')
    ;((n = (n == null ? Mc() : +n) + (t == null ? 0 : +t)),
      !this._next && rr !== this && (rr ? (rr._next = this) : (Ji = this), (rr = this)),
      (this._call = e),
      (this._time = n),
      rs())
  },
  stop: function () {
    this._call && ((this._call = null), (this._time = 1 / 0), rs())
  },
}
function eg(e, t, n) {
  var r = new to()
  return (r.restart(e, t, n), r)
}
function mN() {
  ;(Mc(), ++kn)
  for (var e = Ji, t; e; ) ((t = sn - e._time) >= 0 && e._call.call(void 0, t), (e = e._next))
  --kn
}
function gf() {
  ;((sn = (eo = gr.now()) + Lo), (kn = nr = 0))
  try {
    mN()
  } finally {
    ;((kn = 0), xN(), (sn = 0))
  }
}
function yN() {
  var e = gr.now(),
    t = e - eo
  t > Qv && ((Lo -= t), (eo = e))
}
function xN() {
  for (var e, t = Ji, n, r = 1 / 0; t; )
    t._call
      ? (r > t._time && (r = t._time), (e = t), (t = t._next))
      : ((n = t._next), (t._next = null), (t = e ? (e._next = n) : (Ji = n)))
  ;((rr = e), rs(r))
}
function rs(e) {
  if (!kn) {
    nr && (nr = clearTimeout(nr))
    var t = e - sn
    t > 24
      ? (e < 1 / 0 && (nr = setTimeout(gf, e - gr.now() - Lo)), Jn && (Jn = clearInterval(Jn)))
      : (Jn || ((eo = gr.now()), (Jn = setInterval(yN, Qv))), (kn = 1), Jv(gf))
  }
}
function mf(e, t, n) {
  var r = new to()
  return (
    (t = t == null ? 0 : +t),
    r.restart(
      (i) => {
        ;(r.stop(), e(i + t))
      },
      t,
      n,
    ),
    r
  )
}
var bN = jo('start', 'end', 'cancel', 'interrupt'),
  wN = [],
  tg = 0,
  yf = 1,
  is = 2,
  mi = 3,
  xf = 4,
  os = 5,
  yi = 6
function zo(e, t, n, r, i, o) {
  var a = e.__transition
  if (!a) e.__transition = {}
  else if (n in a) return
  PN(e, n, {
    name: t,
    index: r,
    group: i,
    on: bN,
    tween: wN,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: tg,
  })
}
function Tc(e, t) {
  var n = lt(e, t)
  if (n.state > tg) throw new Error('too late; already scheduled')
  return n
}
function pt(e, t) {
  var n = lt(e, t)
  if (n.state > mi) throw new Error('too late; already running')
  return n
}
function lt(e, t) {
  var n = e.__transition
  if (!n || !(n = n[t])) throw new Error('transition not found')
  return n
}
function PN(e, t, n) {
  var r = e.__transition,
    i
  ;((r[t] = n), (n.timer = eg(o, 0, n.time)))
  function o(c) {
    ;((n.state = yf), n.timer.restart(a, n.delay, n.time), n.delay <= c && a(c - n.delay))
  }
  function a(c) {
    var u, f, d, h
    if (n.state !== yf) return l()
    for (u in r)
      if (((h = r[u]), h.name === n.name)) {
        if (h.state === mi) return mf(a)
        h.state === xf
          ? ((h.state = yi),
            h.timer.stop(),
            h.on.call('interrupt', e, e.__data__, h.index, h.group),
            delete r[u])
          : +u < t &&
            ((h.state = yi),
            h.timer.stop(),
            h.on.call('cancel', e, e.__data__, h.index, h.group),
            delete r[u])
      }
    if (
      (mf(function () {
        n.state === mi && ((n.state = xf), n.timer.restart(s, n.delay, n.time), s(c))
      }),
      (n.state = is),
      n.on.call('start', e, e.__data__, n.index, n.group),
      n.state === is)
    ) {
      for (n.state = mi, i = new Array((d = n.tween.length)), u = 0, f = -1; u < d; ++u)
        (h = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (i[++f] = h)
      i.length = f + 1
    }
  }
  function s(c) {
    for (
      var u =
          c < n.duration
            ? n.ease.call(null, c / n.duration)
            : (n.timer.restart(l), (n.state = os), 1),
        f = -1,
        d = i.length;
      ++f < d;

    )
      i[f].call(e, u)
    n.state === os && (n.on.call('end', e, e.__data__, n.index, n.group), l())
  }
  function l() {
    ;((n.state = yi), n.timer.stop(), delete r[t])
    for (var c in r) return
    delete e.__transition
  }
}
function xi(e, t) {
  var n = e.__transition,
    r,
    i,
    o = !0,
    a
  if (n) {
    t = t == null ? null : t + ''
    for (a in n) {
      if ((r = n[a]).name !== t) {
        o = !1
        continue
      }
      ;((i = r.state > is && r.state < os),
        (r.state = yi),
        r.timer.stop(),
        r.on.call(i ? 'interrupt' : 'cancel', e, e.__data__, r.index, r.group),
        delete n[a])
    }
    o && delete e.__transition
  }
}
function SN(e) {
  return this.each(function () {
    xi(this, e)
  })
}
function EN(e, t) {
  var n, r
  return function () {
    var i = pt(this, e),
      o = i.tween
    if (o !== n) {
      r = n = o
      for (var a = 0, s = r.length; a < s; ++a)
        if (r[a].name === t) {
          ;((r = r.slice()), r.splice(a, 1))
          break
        }
    }
    i.tween = r
  }
}
function _N(e, t, n) {
  var r, i
  if (typeof n != 'function') throw new Error()
  return function () {
    var o = pt(this, e),
      a = o.tween
    if (a !== r) {
      i = (r = a).slice()
      for (var s = { name: t, value: n }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === t) {
          i[l] = s
          break
        }
      l === c && i.push(s)
    }
    o.tween = i
  }
}
function AN(e, t) {
  var n = this._id
  if (((e += ''), arguments.length < 2)) {
    for (var r = lt(this.node(), n).tween, i = 0, o = r.length, a; i < o; ++i)
      if ((a = r[i]).name === e) return a.value
    return null
  }
  return this.each((t == null ? EN : _N)(n, e, t))
}
function Nc(e, t, n) {
  var r = e._id
  return (
    e.each(function () {
      var i = pt(this, r)
      ;(i.value || (i.value = {}))[t] = n.apply(this, arguments)
    }),
    function (i) {
      return lt(i, r).value[t]
    }
  )
}
function ng(e, t) {
  var n
  return (typeof t == 'number' ? rt : t instanceof tn ? Ii : (n = tn(t)) ? ((t = n), Ii) : lh)(e, t)
}
function ON(e) {
  return function () {
    this.removeAttribute(e)
  }
}
function CN(e) {
  return function () {
    this.removeAttributeNS(e.space, e.local)
  }
}
function kN(e, t, n) {
  var r,
    i = n + '',
    o
  return function () {
    var a = this.getAttribute(e)
    return a === i ? null : a === r ? o : (o = t((r = a), n))
  }
}
function MN(e, t, n) {
  var r,
    i = n + '',
    o
  return function () {
    var a = this.getAttributeNS(e.space, e.local)
    return a === i ? null : a === r ? o : (o = t((r = a), n))
  }
}
function TN(e, t, n) {
  var r, i, o
  return function () {
    var a,
      s = n(this),
      l
    return s == null
      ? void this.removeAttribute(e)
      : ((a = this.getAttribute(e)),
        (l = s + ''),
        a === l ? null : a === r && l === i ? o : ((i = l), (o = t((r = a), s))))
  }
}
function NN(e, t, n) {
  var r, i, o
  return function () {
    var a,
      s = n(this),
      l
    return s == null
      ? void this.removeAttributeNS(e.space, e.local)
      : ((a = this.getAttributeNS(e.space, e.local)),
        (l = s + ''),
        a === l ? null : a === r && l === i ? o : ((i = l), (o = t((r = a), s))))
  }
}
function DN(e, t) {
  var n = $o(e),
    r = n === 'transform' ? Kw : ng
  return this.attrTween(
    e,
    typeof t == 'function'
      ? (n.local ? NN : TN)(n, r, Nc(this, 'attr.' + e, t))
      : t == null
        ? (n.local ? CN : ON)(n)
        : (n.local ? MN : kN)(n, r, t),
  )
}
function IN(e, t) {
  return function (n) {
    this.setAttribute(e, t.call(this, n))
  }
}
function jN(e, t) {
  return function (n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n))
  }
}
function $N(e, t) {
  var n, r
  function i() {
    var o = t.apply(this, arguments)
    return (o !== r && (n = (r = o) && jN(e, o)), n)
  }
  return ((i._value = t), i)
}
function LN(e, t) {
  var n, r
  function i() {
    var o = t.apply(this, arguments)
    return (o !== r && (n = (r = o) && IN(e, o)), n)
  }
  return ((i._value = t), i)
}
function zN(e, t) {
  var n = 'attr.' + e
  if (arguments.length < 2) return (n = this.tween(n)) && n._value
  if (t == null) return this.tween(n, null)
  if (typeof t != 'function') throw new Error()
  var r = $o(e)
  return this.tween(n, (r.local ? $N : LN)(r, t))
}
function RN(e, t) {
  return function () {
    Tc(this, e).delay = +t.apply(this, arguments)
  }
}
function BN(e, t) {
  return (
    (t = +t),
    function () {
      Tc(this, e).delay = t
    }
  )
}
function HN(e) {
  var t = this._id
  return arguments.length
    ? this.each((typeof e == 'function' ? RN : BN)(t, e))
    : lt(this.node(), t).delay
}
function FN(e, t) {
  return function () {
    pt(this, e).duration = +t.apply(this, arguments)
  }
}
function VN(e, t) {
  return (
    (t = +t),
    function () {
      pt(this, e).duration = t
    }
  )
}
function WN(e) {
  var t = this._id
  return arguments.length
    ? this.each((typeof e == 'function' ? FN : VN)(t, e))
    : lt(this.node(), t).duration
}
function KN(e, t) {
  if (typeof t != 'function') throw new Error()
  return function () {
    pt(this, e).ease = t
  }
}
function YN(e) {
  var t = this._id
  return arguments.length ? this.each(KN(t, e)) : lt(this.node(), t).ease
}
function UN(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    if (typeof n != 'function') throw new Error()
    pt(this, e).ease = n
  }
}
function XN(e) {
  if (typeof e != 'function') throw new Error()
  return this.each(UN(this._id, e))
}
function GN(e) {
  typeof e != 'function' && (e = Rv(e))
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], a = o.length, s = (r[i] = []), l, c = 0; c < a; ++c)
      (l = o[c]) && e.call(l, l.__data__, c, o) && s.push(l)
  return new Ot(r, this._parents, this._name, this._id)
}
function qN(e) {
  if (e._id !== this._id) throw new Error()
  for (
    var t = this._groups,
      n = e._groups,
      r = t.length,
      i = n.length,
      o = Math.min(r, i),
      a = new Array(r),
      s = 0;
    s < o;
    ++s
  )
    for (var l = t[s], c = n[s], u = l.length, f = (a[s] = new Array(u)), d, h = 0; h < u; ++h)
      (d = l[h] || c[h]) && (f[h] = d)
  for (; s < r; ++s) a[s] = t[s]
  return new Ot(a, this._parents, this._name, this._id)
}
function ZN(e) {
  return (e + '')
    .trim()
    .split(/^|\s+/)
    .every(function (t) {
      var n = t.indexOf('.')
      return (n >= 0 && (t = t.slice(0, n)), !t || t === 'start')
    })
}
function QN(e, t, n) {
  var r,
    i,
    o = ZN(t) ? Tc : pt
  return function () {
    var a = o(this, e),
      s = a.on
    ;(s !== r && (i = (r = s).copy()).on(t, n), (a.on = i))
  }
}
function JN(e, t) {
  var n = this._id
  return arguments.length < 2 ? lt(this.node(), n).on.on(e) : this.each(QN(n, e, t))
}
function eD(e) {
  return function () {
    var t = this.parentNode
    for (var n in this.__transition) if (+n !== e) return
    t && t.removeChild(this)
  }
}
function tD() {
  return this.on('end.remove', eD(this._id))
}
function nD(e) {
  var t = this._name,
    n = this._id
  typeof e != 'function' && (e = Cc(e))
  for (var r = this._groups, i = r.length, o = new Array(i), a = 0; a < i; ++a)
    for (var s = r[a], l = s.length, c = (o[a] = new Array(l)), u, f, d = 0; d < l; ++d)
      (u = s[d]) &&
        (f = e.call(u, u.__data__, d, s)) &&
        ('__data__' in u && (f.__data__ = u.__data__), (c[d] = f), zo(c[d], t, n, d, c, lt(u, n)))
  return new Ot(o, this._parents, t, n)
}
function rD(e) {
  var t = this._name,
    n = this._id
  typeof e != 'function' && (e = zv(e))
  for (var r = this._groups, i = r.length, o = [], a = [], s = 0; s < i; ++s)
    for (var l = r[s], c = l.length, u, f = 0; f < c; ++f)
      if ((u = l[f])) {
        for (var d = e.call(u, u.__data__, f, l), h, g = lt(u, n), p = 0, x = d.length; p < x; ++p)
          (h = d[p]) && zo(h, t, n, p, d, g)
        ;(o.push(d), a.push(u))
      }
  return new Ot(o, a, t, n)
}
var iD = zr.prototype.constructor
function oD() {
  return new iD(this._groups, this._parents)
}
function aD(e, t) {
  var n, r, i
  return function () {
    var o = Cn(this, e),
      a = (this.style.removeProperty(e), Cn(this, e))
    return o === a ? null : o === n && a === r ? i : (i = t((n = o), (r = a)))
  }
}
function rg(e) {
  return function () {
    this.style.removeProperty(e)
  }
}
function sD(e, t, n) {
  var r,
    i = n + '',
    o
  return function () {
    var a = Cn(this, e)
    return a === i ? null : a === r ? o : (o = t((r = a), n))
  }
}
function cD(e, t, n) {
  var r, i, o
  return function () {
    var a = Cn(this, e),
      s = n(this),
      l = s + ''
    return (
      s == null && (l = s = (this.style.removeProperty(e), Cn(this, e))),
      a === l ? null : a === r && l === i ? o : ((i = l), (o = t((r = a), s)))
    )
  }
}
function lD(e, t) {
  var n,
    r,
    i,
    o = 'style.' + t,
    a = 'end.' + o,
    s
  return function () {
    var l = pt(this, e),
      c = l.on,
      u = l.value[o] == null ? s || (s = rg(t)) : void 0
    ;((c !== n || i !== u) && (r = (n = c).copy()).on(a, (i = u)), (l.on = r))
  }
}
function uD(e, t, n) {
  var r = (e += '') == 'transform' ? Ww : ng
  return t == null
    ? this.styleTween(e, aD(e, r)).on('end.style.' + e, rg(e))
    : typeof t == 'function'
      ? this.styleTween(e, cD(e, r, Nc(this, 'style.' + e, t))).each(lD(this._id, e))
      : this.styleTween(e, sD(e, r, t), n).on('end.style.' + e, null)
}
function fD(e, t, n) {
  return function (r) {
    this.style.setProperty(e, t.call(this, r), n)
  }
}
function dD(e, t, n) {
  var r, i
  function o() {
    var a = t.apply(this, arguments)
    return (a !== i && (r = (i = a) && fD(e, a, n)), r)
  }
  return ((o._value = t), o)
}
function hD(e, t, n) {
  var r = 'style.' + (e += '')
  if (arguments.length < 2) return (r = this.tween(r)) && r._value
  if (t == null) return this.tween(r, null)
  if (typeof t != 'function') throw new Error()
  return this.tween(r, dD(e, t, n ?? ''))
}
function pD(e) {
  return function () {
    this.textContent = e
  }
}
function vD(e) {
  return function () {
    var t = e(this)
    this.textContent = t ?? ''
  }
}
function gD(e) {
  return this.tween(
    'text',
    typeof e == 'function' ? vD(Nc(this, 'text', e)) : pD(e == null ? '' : e + ''),
  )
}
function mD(e) {
  return function (t) {
    this.textContent = e.call(this, t)
  }
}
function yD(e) {
  var t, n
  function r() {
    var i = e.apply(this, arguments)
    return (i !== n && (t = (n = i) && mD(i)), t)
  }
  return ((r._value = e), r)
}
function xD(e) {
  var t = 'text'
  if (arguments.length < 1) return (t = this.tween(t)) && t._value
  if (e == null) return this.tween(t, null)
  if (typeof e != 'function') throw new Error()
  return this.tween(t, yD(e))
}
function bD() {
  for (
    var e = this._name, t = this._id, n = ig(), r = this._groups, i = r.length, o = 0;
    o < i;
    ++o
  )
    for (var a = r[o], s = a.length, l, c = 0; c < s; ++c)
      if ((l = a[c])) {
        var u = lt(l, t)
        zo(l, e, n, c, a, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease,
        })
      }
  return new Ot(r, this._parents, e, n)
}
function wD() {
  var e,
    t,
    n = this,
    r = n._id,
    i = n.size()
  return new Promise(function (o, a) {
    var s = { value: a },
      l = {
        value: function () {
          --i === 0 && o()
        },
      }
    ;(n.each(function () {
      var c = pt(this, r),
        u = c.on
      ;(u !== e &&
        ((t = (e = u).copy()), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(l)),
        (c.on = t))
    }),
      i === 0 && o())
  })
}
var PD = 0
function Ot(e, t, n, r) {
  ;((this._groups = e), (this._parents = t), (this._name = n), (this._id = r))
}
function ig() {
  return ++PD
}
var vt = zr.prototype
Ot.prototype = {
  constructor: Ot,
  select: nD,
  selectAll: rD,
  selectChild: vt.selectChild,
  selectChildren: vt.selectChildren,
  filter: GN,
  merge: qN,
  selection: oD,
  transition: bD,
  call: vt.call,
  nodes: vt.nodes,
  node: vt.node,
  size: vt.size,
  empty: vt.empty,
  each: vt.each,
  on: JN,
  attr: DN,
  attrTween: zN,
  style: uD,
  styleTween: hD,
  text: gD,
  textTween: xD,
  remove: tD,
  tween: AN,
  delay: HN,
  duration: WN,
  ease: YN,
  easeVarying: XN,
  end: wD,
  [Symbol.iterator]: vt[Symbol.iterator],
}
function SD(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2
}
var ED = { time: null, delay: 0, duration: 250, ease: SD }
function _D(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode)) throw new Error(`transition ${t} not found`)
  return n
}
function AD(e) {
  var t, n
  e instanceof Ot
    ? ((t = e._id), (e = e._name))
    : ((t = ig()), ((n = ED).time = Mc()), (e = e == null ? null : e + ''))
  for (var r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var a = r[o], s = a.length, l, c = 0; c < s; ++c)
      (l = a[c]) && zo(l, e, t, c, a, n || _D(l, t))
  return new Ot(r, this._parents, e, t)
}
zr.prototype.interrupt = SN
zr.prototype.transition = AD
const si = (e) => () => e
function OD(e, { sourceEvent: t, target: n, transform: r, dispatch: i }) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: i },
  })
}
function wt(e, t, n) {
  ;((this.k = e), (this.x = t), (this.y = n))
}
wt.prototype = {
  constructor: wt,
  scale: function (e) {
    return e === 1 ? this : new wt(this.k * e, this.x, this.y)
  },
  translate: function (e, t) {
    return (e === 0) & (t === 0) ? this : new wt(this.k, this.x + this.k * e, this.y + this.k * t)
  },
  apply: function (e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y]
  },
  applyX: function (e) {
    return e * this.k + this.x
  },
  applyY: function (e) {
    return e * this.k + this.y
  },
  invert: function (e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k]
  },
  invertX: function (e) {
    return (e - this.x) / this.k
  },
  invertY: function (e) {
    return (e - this.y) / this.k
  },
  rescaleX: function (e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e))
  },
  rescaleY: function (e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
  },
  toString: function () {
    return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')'
  },
}
var Ro = new wt(1, 0, 0)
og.prototype = wt.prototype
function og(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return Ro
  return e.__zoom
}
function fa(e) {
  e.stopImmediatePropagation()
}
function er(e) {
  ;(e.preventDefault(), e.stopImmediatePropagation())
}
function CD(e) {
  return (!e.ctrlKey || e.type === 'wheel') && !e.button
}
function kD() {
  var e = this
  return e instanceof SVGElement
    ? ((e = e.ownerSVGElement || e),
      e.hasAttribute('viewBox')
        ? ((e = e.viewBox.baseVal),
          [
            [e.x, e.y],
            [e.x + e.width, e.y + e.height],
          ])
        : [
            [0, 0],
            [e.width.baseVal.value, e.height.baseVal.value],
          ])
    : [
        [0, 0],
        [e.clientWidth, e.clientHeight],
      ]
}
function bf() {
  return this.__zoom || Ro
}
function MD(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 0.002) * (e.ctrlKey ? 10 : 1)
}
function TD() {
  return navigator.maxTouchPoints || 'ontouchstart' in this
}
function ND(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0],
    i = e.invertX(t[1][0]) - n[1][0],
    o = e.invertY(t[0][1]) - n[0][1],
    a = e.invertY(t[1][1]) - n[1][1]
  return e.translate(
    i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),
    a > o ? (o + a) / 2 : Math.min(0, o) || Math.max(0, a),
  )
}
function ag() {
  var e = CD,
    t = kD,
    n = ND,
    r = MD,
    i = TD,
    o = [0, 1 / 0],
    a = [
      [-1 / 0, -1 / 0],
      [1 / 0, 1 / 0],
    ],
    s = 250,
    l = hi,
    c = jo('start', 'zoom', 'end'),
    u,
    f,
    d,
    h = 500,
    g = 150,
    p = 0,
    x = 10
  function y(E) {
    E.property('__zoom', bf)
      .on('wheel.zoom', M, { passive: !1 })
      .on('mousedown.zoom', T)
      .on('dblclick.zoom', F)
      .filter(i)
      .on('touchstart.zoom', D)
      .on('touchmove.zoom', k)
      .on('touchend.zoom touchcancel.zoom', $)
      .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')
  }
  ;((y.transform = function (E, O, A, C) {
    var N = E.selection ? E.selection() : E
    ;(N.property('__zoom', bf),
      E !== N
        ? P(E, O, A, C)
        : N.interrupt().each(function () {
            S(this, arguments)
              .event(C)
              .start()
              .zoom(null, typeof O == 'function' ? O.apply(this, arguments) : O)
              .end()
          }))
  }),
    (y.scaleBy = function (E, O, A, C) {
      y.scaleTo(
        E,
        function () {
          var N = this.__zoom.k,
            I = typeof O == 'function' ? O.apply(this, arguments) : O
          return N * I
        },
        A,
        C,
      )
    }),
    (y.scaleTo = function (E, O, A, C) {
      y.transform(
        E,
        function () {
          var N = t.apply(this, arguments),
            I = this.__zoom,
            H = A == null ? b(N) : typeof A == 'function' ? A.apply(this, arguments) : A,
            V = I.invert(H),
            B = typeof O == 'function' ? O.apply(this, arguments) : O
          return n(m(w(I, B), H, V), N, a)
        },
        A,
        C,
      )
    }),
    (y.translateBy = function (E, O, A, C) {
      y.transform(
        E,
        function () {
          return n(
            this.__zoom.translate(
              typeof O == 'function' ? O.apply(this, arguments) : O,
              typeof A == 'function' ? A.apply(this, arguments) : A,
            ),
            t.apply(this, arguments),
            a,
          )
        },
        null,
        C,
      )
    }),
    (y.translateTo = function (E, O, A, C, N) {
      y.transform(
        E,
        function () {
          var I = t.apply(this, arguments),
            H = this.__zoom,
            V = C == null ? b(I) : typeof C == 'function' ? C.apply(this, arguments) : C
          return n(
            Ro.translate(V[0], V[1])
              .scale(H.k)
              .translate(
                typeof O == 'function' ? -O.apply(this, arguments) : -O,
                typeof A == 'function' ? -A.apply(this, arguments) : -A,
              ),
            I,
            a,
          )
        },
        C,
        N,
      )
    }))
  function w(E, O) {
    return ((O = Math.max(o[0], Math.min(o[1], O))), O === E.k ? E : new wt(O, E.x, E.y))
  }
  function m(E, O, A) {
    var C = O[0] - A[0] * E.k,
      N = O[1] - A[1] * E.k
    return C === E.x && N === E.y ? E : new wt(E.k, C, N)
  }
  function b(E) {
    return [(+E[0][0] + +E[1][0]) / 2, (+E[0][1] + +E[1][1]) / 2]
  }
  function P(E, O, A, C) {
    E.on('start.zoom', function () {
      S(this, arguments).event(C).start()
    })
      .on('interrupt.zoom end.zoom', function () {
        S(this, arguments).event(C).end()
      })
      .tween('zoom', function () {
        var N = this,
          I = arguments,
          H = S(N, I).event(C),
          V = t.apply(N, I),
          B = A == null ? b(V) : typeof A == 'function' ? A.apply(N, I) : A,
          Y = Math.max(V[1][0] - V[0][0], V[1][1] - V[0][1]),
          K = N.__zoom,
          G = typeof O == 'function' ? O.apply(N, I) : O,
          re = l(K.invert(B).concat(Y / K.k), G.invert(B).concat(Y / G.k))
        return function (q) {
          if (q === 1) q = G
          else {
            var W = re(q),
              j = Y / W[2]
            q = new wt(j, B[0] - W[0] * j, B[1] - W[1] * j)
          }
          H.zoom(null, q)
        }
      })
  }
  function S(E, O, A) {
    return (!A && E.__zooming) || new _(E, O)
  }
  function _(E, O) {
    ;((this.that = E),
      (this.args = O),
      (this.active = 0),
      (this.sourceEvent = null),
      (this.extent = t.apply(E, O)),
      (this.taps = 0))
  }
  _.prototype = {
    event: function (E) {
      return (E && (this.sourceEvent = E), this)
    },
    start: function () {
      return (++this.active === 1 && ((this.that.__zooming = this), this.emit('start')), this)
    },
    zoom: function (E, O) {
      return (
        this.mouse && E !== 'mouse' && (this.mouse[1] = O.invert(this.mouse[0])),
        this.touch0 && E !== 'touch' && (this.touch0[1] = O.invert(this.touch0[0])),
        this.touch1 && E !== 'touch' && (this.touch1[1] = O.invert(this.touch1[0])),
        (this.that.__zoom = O),
        this.emit('zoom'),
        this
      )
    },
    end: function () {
      return (--this.active === 0 && (delete this.that.__zooming, this.emit('end')), this)
    },
    emit: function (E) {
      var O = He(this.that).datum()
      c.call(
        E,
        this.that,
        new OD(E, {
          sourceEvent: this.sourceEvent,
          target: y,
          transform: this.that.__zoom,
          dispatch: c,
        }),
        O,
      )
    },
  }
  function M(E, ...O) {
    if (!e.apply(this, arguments)) return
    var A = S(this, O).event(E),
      C = this.__zoom,
      N = Math.max(o[0], Math.min(o[1], C.k * Math.pow(2, r.apply(this, arguments)))),
      I = nt(E)
    if (A.wheel)
      ((A.mouse[0][0] !== I[0] || A.mouse[0][1] !== I[1]) &&
        (A.mouse[1] = C.invert((A.mouse[0] = I))),
        clearTimeout(A.wheel))
    else {
      if (C.k === N) return
      ;((A.mouse = [I, C.invert(I)]), xi(this), A.start())
    }
    ;(er(E),
      (A.wheel = setTimeout(H, g)),
      A.zoom('mouse', n(m(w(C, N), A.mouse[0], A.mouse[1]), A.extent, a)))
    function H() {
      ;((A.wheel = null), A.end())
    }
  }
  function T(E, ...O) {
    if (d || !e.apply(this, arguments)) return
    var A = E.currentTarget,
      C = S(this, O, !0).event(E),
      N = He(E.view).on('mousemove.zoom', B, !0).on('mouseup.zoom', Y, !0),
      I = nt(E, A),
      H = E.clientX,
      V = E.clientY
    ;(Gv(E.view), fa(E), (C.mouse = [I, this.__zoom.invert(I)]), xi(this), C.start())
    function B(K) {
      if ((er(K), !C.moved)) {
        var G = K.clientX - H,
          re = K.clientY - V
        C.moved = G * G + re * re > p
      }
      C.event(K).zoom(
        'mouse',
        n(m(C.that.__zoom, (C.mouse[0] = nt(K, A)), C.mouse[1]), C.extent, a),
      )
    }
    function Y(K) {
      ;(N.on('mousemove.zoom mouseup.zoom', null), qv(K.view, C.moved), er(K), C.event(K).end())
    }
  }
  function F(E, ...O) {
    if (e.apply(this, arguments)) {
      var A = this.__zoom,
        C = nt(E.changedTouches ? E.changedTouches[0] : E, this),
        N = A.invert(C),
        I = A.k * (E.shiftKey ? 0.5 : 2),
        H = n(m(w(A, I), C, N), t.apply(this, O), a)
      ;(er(E),
        s > 0
          ? He(this).transition().duration(s).call(P, H, C, E)
          : He(this).call(y.transform, H, C, E))
    }
  }
  function D(E, ...O) {
    if (e.apply(this, arguments)) {
      var A = E.touches,
        C = A.length,
        N = S(this, O, E.changedTouches.length === C).event(E),
        I,
        H,
        V,
        B
      for (fa(E), H = 0; H < C; ++H)
        ((V = A[H]),
          (B = nt(V, this)),
          (B = [B, this.__zoom.invert(B), V.identifier]),
          N.touch0
            ? !N.touch1 && N.touch0[2] !== B[2] && ((N.touch1 = B), (N.taps = 0))
            : ((N.touch0 = B), (I = !0), (N.taps = 1 + !!u)))
      ;(u && (u = clearTimeout(u)),
        I &&
          (N.taps < 2 &&
            ((f = B[0]),
            (u = setTimeout(function () {
              u = null
            }, h))),
          xi(this),
          N.start()))
    }
  }
  function k(E, ...O) {
    if (this.__zooming) {
      var A = S(this, O).event(E),
        C = E.changedTouches,
        N = C.length,
        I,
        H,
        V,
        B
      for (er(E), I = 0; I < N; ++I)
        ((H = C[I]),
          (V = nt(H, this)),
          A.touch0 && A.touch0[2] === H.identifier
            ? (A.touch0[0] = V)
            : A.touch1 && A.touch1[2] === H.identifier && (A.touch1[0] = V))
      if (((H = A.that.__zoom), A.touch1)) {
        var Y = A.touch0[0],
          K = A.touch0[1],
          G = A.touch1[0],
          re = A.touch1[1],
          q = (q = G[0] - Y[0]) * q + (q = G[1] - Y[1]) * q,
          W = (W = re[0] - K[0]) * W + (W = re[1] - K[1]) * W
        ;((H = w(H, Math.sqrt(q / W))),
          (V = [(Y[0] + G[0]) / 2, (Y[1] + G[1]) / 2]),
          (B = [(K[0] + re[0]) / 2, (K[1] + re[1]) / 2]))
      } else if (A.touch0) ((V = A.touch0[0]), (B = A.touch0[1]))
      else return
      A.zoom('touch', n(m(H, V, B), A.extent, a))
    }
  }
  function $(E, ...O) {
    if (this.__zooming) {
      var A = S(this, O).event(E),
        C = E.changedTouches,
        N = C.length,
        I,
        H
      for (
        fa(E),
          d && clearTimeout(d),
          d = setTimeout(function () {
            d = null
          }, h),
          I = 0;
        I < N;
        ++I
      )
        ((H = C[I]),
          A.touch0 && A.touch0[2] === H.identifier
            ? delete A.touch0
            : A.touch1 && A.touch1[2] === H.identifier && delete A.touch1)
      if ((A.touch1 && !A.touch0 && ((A.touch0 = A.touch1), delete A.touch1), A.touch0))
        A.touch0[1] = this.__zoom.invert(A.touch0[0])
      else if (
        (A.end(), A.taps === 2 && ((H = nt(H, this)), Math.hypot(f[0] - H[0], f[1] - H[1]) < x))
      ) {
        var V = He(this).on('dblclick.zoom')
        V && V.apply(this, arguments)
      }
    }
  }
  return (
    (y.wheelDelta = function (E) {
      return arguments.length ? ((r = typeof E == 'function' ? E : si(+E)), y) : r
    }),
    (y.filter = function (E) {
      return arguments.length ? ((e = typeof E == 'function' ? E : si(!!E)), y) : e
    }),
    (y.touchable = function (E) {
      return arguments.length ? ((i = typeof E == 'function' ? E : si(!!E)), y) : i
    }),
    (y.extent = function (E) {
      return arguments.length
        ? ((t =
            typeof E == 'function'
              ? E
              : si([
                  [+E[0][0], +E[0][1]],
                  [+E[1][0], +E[1][1]],
                ])),
          y)
        : t
    }),
    (y.scaleExtent = function (E) {
      return arguments.length ? ((o[0] = +E[0]), (o[1] = +E[1]), y) : [o[0], o[1]]
    }),
    (y.translateExtent = function (E) {
      return arguments.length
        ? ((a[0][0] = +E[0][0]),
          (a[1][0] = +E[1][0]),
          (a[0][1] = +E[0][1]),
          (a[1][1] = +E[1][1]),
          y)
        : [
            [a[0][0], a[0][1]],
            [a[1][0], a[1][1]],
          ]
    }),
    (y.constrain = function (E) {
      return arguments.length ? ((n = E), y) : n
    }),
    (y.duration = function (E) {
      return arguments.length ? ((s = +E), y) : s
    }),
    (y.interpolate = function (E) {
      return arguments.length ? ((l = E), y) : l
    }),
    (y.on = function () {
      var E = c.on.apply(c, arguments)
      return E === c ? y : E
    }),
    (y.clickDistance = function (E) {
      return arguments.length ? ((p = (E = +E) * E), y) : Math.sqrt(p)
    }),
    (y.tapDistance = function (E) {
      return arguments.length ? ((x = +E), y) : x
    }),
    y
  )
}
const ht = {
    error001: () =>
      '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',
    error002: () =>
      "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
    error004: () =>
      'The React Flow parent container needs a width and a height to render the graph.',
    error005: () => 'Only child nodes can use a parent extent.',
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: (e) => `The old edge with id=${e} does not exist.`,
    error009: (e) => `Marker type "${e}" doesn't exist.`,
    error008: (e, { id: t, sourceHandle: n, targetHandle: r }) =>
      `Couldn't create edge for ${e} handle id: "${e === 'source' ? n : r}", edge id: ${t}.`,
    error010: () =>
      'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',
    error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
    error012: (e) =>
      `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
    error013: (e = 'react') =>
      `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
    error014: () =>
      'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',
    error015: () =>
      'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',
  },
  mr = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
  ],
  sg = ['Enter', ' ', 'Escape'],
  cg = {
    'node.a11yDescription.default':
      'Press enter or space to select a node. Press delete to remove it and escape to cancel.',
    'node.a11yDescription.keyboardDisabled':
      'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',
    'node.a11yDescription.ariaLiveMessage': ({ direction: e, x: t, y: n }) =>
      `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
    'edge.a11yDescription.default':
      'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',
    'controls.ariaLabel': 'Control Panel',
    'controls.zoomIn.ariaLabel': 'Zoom In',
    'controls.zoomOut.ariaLabel': 'Zoom Out',
    'controls.fitView.ariaLabel': 'Fit View',
    'controls.interactive.ariaLabel': 'Toggle Interactivity',
    'minimap.ariaLabel': 'Mini Map',
    'handle.ariaLabel': 'Handle',
  }
var Mn
;(function (e) {
  ;((e.Strict = 'strict'), (e.Loose = 'loose'))
})(Mn || (Mn = {}))
var en
;(function (e) {
  ;((e.Free = 'free'), (e.Vertical = 'vertical'), (e.Horizontal = 'horizontal'))
})(en || (en = {}))
var yr
;(function (e) {
  ;((e.Partial = 'partial'), (e.Full = 'full'))
})(yr || (yr = {}))
const lg = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
}
var Rt
;(function (e) {
  ;((e.Bezier = 'default'),
    (e.Straight = 'straight'),
    (e.Step = 'step'),
    (e.SmoothStep = 'smoothstep'),
    (e.SimpleBezier = 'simplebezier'))
})(Rt || (Rt = {}))
var no
;(function (e) {
  ;((e.Arrow = 'arrow'), (e.ArrowClosed = 'arrowclosed'))
})(no || (no = {}))
var ee
;(function (e) {
  ;((e.Left = 'left'), (e.Top = 'top'), (e.Right = 'right'), (e.Bottom = 'bottom'))
})(ee || (ee = {}))
const wf = { [ee.Left]: ee.Right, [ee.Right]: ee.Left, [ee.Top]: ee.Bottom, [ee.Bottom]: ee.Top }
function ug(e) {
  return e === null ? null : e ? 'valid' : 'invalid'
}
const fg = (e) => 'id' in e && 'source' in e && 'target' in e,
  DD = (e) => 'id' in e && 'position' in e && !('source' in e) && !('target' in e),
  Dc = (e) => 'id' in e && 'internals' in e && !('source' in e) && !('target' in e),
  Rr = (e, t = [0, 0]) => {
    const { width: n, height: r } = It(e),
      i = e.origin ?? t,
      o = n * i[0],
      a = r * i[1]
    return { x: e.position.x - o, y: e.position.y - a }
  },
  ID = (e, t = { nodeOrigin: [0, 0] }) => {
    if (e.length === 0) return { x: 0, y: 0, width: 0, height: 0 }
    const n = e.reduce(
      (r, i) => {
        const o = typeof i == 'string'
        let a = !t.nodeLookup && !o ? i : void 0
        t.nodeLookup && (a = o ? t.nodeLookup.get(i) : Dc(i) ? i : t.nodeLookup.get(i.id))
        const s = a ? ro(a, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 }
        return Bo(r, s)
      },
      { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 },
    )
    return Ho(n)
  },
  Br = (e, t = {}) => {
    let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 },
      r = !1
    return (
      e.forEach((i) => {
        ;(t.filter === void 0 || t.filter(i)) && ((n = Bo(n, ro(i))), (r = !0))
      }),
      r ? Ho(n) : { x: 0, y: 0, width: 0, height: 0 }
    )
  },
  Ic = (e, t, [n, r, i] = [0, 0, 1], o = !1, a = !1) => {
    const s = { ...Fr(t, [n, r, i]), width: t.width / i, height: t.height / i },
      l = []
    for (const c of e.values()) {
      const { measured: u, selectable: f = !0, hidden: d = !1 } = c
      if ((a && !f) || d) continue
      const h = u.width ?? c.width ?? c.initialWidth ?? null,
        g = u.height ?? c.height ?? c.initialHeight ?? null,
        p = xr(s, Nn(c)),
        x = (h ?? 0) * (g ?? 0),
        y = o && p > 0
      ;(!c.internals.handleBounds || y || p >= x || c.dragging) && l.push(c)
    }
    return l
  },
  jD = (e, t) => {
    const n = new Set()
    return (
      e.forEach((r) => {
        n.add(r.id)
      }),
      t.filter((r) => n.has(r.source) || n.has(r.target))
    )
  }
function $D(e, t) {
  const n = new Map(),
    r = t?.nodes ? new Set(t.nodes.map((i) => i.id)) : null
  return (
    e.forEach((i) => {
      i.measured.width &&
        i.measured.height &&
        (t?.includeHiddenNodes || !i.hidden) &&
        (!r || r.has(i.id)) &&
        n.set(i.id, i)
    }),
    n
  )
}
async function LD({ nodes: e, width: t, height: n, panZoom: r, minZoom: i, maxZoom: o }, a) {
  if (e.size === 0) return Promise.resolve(!0)
  const s = $D(e, a),
    l = Br(s),
    c = jc(l, t, n, a?.minZoom ?? i, a?.maxZoom ?? o, a?.padding ?? 0.1)
  return (
    await r.setViewport(c, { duration: a?.duration, ease: a?.ease, interpolate: a?.interpolate }),
    Promise.resolve(!0)
  )
}
function dg({
  nodeId: e,
  nextPosition: t,
  nodeLookup: n,
  nodeOrigin: r = [0, 0],
  nodeExtent: i,
  onError: o,
}) {
  const a = n.get(e),
    s = a.parentId ? n.get(a.parentId) : void 0,
    { x: l, y: c } = s ? s.internals.positionAbsolute : { x: 0, y: 0 },
    u = a.origin ?? r
  let f = a.extent || i
  if (a.extent === 'parent' && !a.expandParent)
    if (!s) o?.('005', ht.error005())
    else {
      const h = s.measured.width,
        g = s.measured.height
      h &&
        g &&
        (f = [
          [l, c],
          [l + h, c + g],
        ])
    }
  else
    s &&
      Dn(a.extent) &&
      (f = [
        [a.extent[0][0] + l, a.extent[0][1] + c],
        [a.extent[1][0] + l, a.extent[1][1] + c],
      ])
  const d = Dn(f) ? cn(t, f, a.measured) : t
  return (
    (a.measured.width === void 0 || a.measured.height === void 0) && o?.('015', ht.error015()),
    {
      position: {
        x: d.x - l + (a.measured.width ?? 0) * u[0],
        y: d.y - c + (a.measured.height ?? 0) * u[1],
      },
      positionAbsolute: d,
    }
  )
}
async function zD({
  nodesToRemove: e = [],
  edgesToRemove: t = [],
  nodes: n,
  edges: r,
  onBeforeDelete: i,
}) {
  const o = new Set(e.map((d) => d.id)),
    a = []
  for (const d of n) {
    if (d.deletable === !1) continue
    const h = o.has(d.id),
      g = !h && d.parentId && a.find((p) => p.id === d.parentId)
    ;(h || g) && a.push(d)
  }
  const s = new Set(t.map((d) => d.id)),
    l = r.filter((d) => d.deletable !== !1),
    u = jD(a, l)
  for (const d of l) s.has(d.id) && !u.find((g) => g.id === d.id) && u.push(d)
  if (!i) return { edges: u, nodes: a }
  const f = await i({ nodes: a, edges: u })
  return typeof f == 'boolean' ? (f ? { edges: u, nodes: a } : { edges: [], nodes: [] }) : f
}
const Tn = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n),
  cn = (e = { x: 0, y: 0 }, t, n) => ({
    x: Tn(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
    y: Tn(e.y, t[0][1], t[1][1] - (n?.height ?? 0)),
  })
function hg(e, t, n) {
  const { width: r, height: i } = It(n),
    { x: o, y: a } = n.internals.positionAbsolute
  return cn(
    e,
    [
      [o, a],
      [o + r, a + i],
    ],
    t,
  )
}
const Pf = (e, t, n) =>
    e < t ? Tn(Math.abs(e - t), 1, t) / t : e > n ? -Tn(Math.abs(e - n), 1, t) / t : 0,
  pg = (e, t, n = 15, r = 40) => {
    const i = Pf(e.x, r, t.width - r) * n,
      o = Pf(e.y, r, t.height - r) * n
    return [i, o]
  },
  Bo = (e, t) => ({
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2),
  }),
  as = ({ x: e, y: t, width: n, height: r }) => ({ x: e, y: t, x2: e + n, y2: t + r }),
  Ho = ({ x: e, y: t, x2: n, y2: r }) => ({ x: e, y: t, width: n - e, height: r - t }),
  Nn = (e, t = [0, 0]) => {
    const { x: n, y: r } = Dc(e) ? e.internals.positionAbsolute : Rr(e, t)
    return {
      x: n,
      y: r,
      width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
      height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0,
    }
  },
  ro = (e, t = [0, 0]) => {
    const { x: n, y: r } = Dc(e) ? e.internals.positionAbsolute : Rr(e, t)
    return {
      x: n,
      y: r,
      x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
      y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0),
    }
  },
  vg = (e, t) => Ho(Bo(as(e), as(t))),
  xr = (e, t) => {
    const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)),
      r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y))
    return Math.ceil(n * r)
  },
  Sf = (e) => ot(e.width) && ot(e.height) && ot(e.x) && ot(e.y),
  ot = (e) => !isNaN(e) && isFinite(e),
  RD = (e, t) => {},
  Hr = (e, t = [1, 1]) => ({ x: t[0] * Math.round(e.x / t[0]), y: t[1] * Math.round(e.y / t[1]) }),
  Fr = ({ x: e, y: t }, [n, r, i], o = !1, a = [1, 1]) => {
    const s = { x: (e - n) / i, y: (t - r) / i }
    return o ? Hr(s, a) : s
  },
  io = ({ x: e, y: t }, [n, r, i]) => ({ x: e * i + n, y: t * i + r })
function vn(e, t) {
  if (typeof e == 'number') return Math.floor((t - t / (1 + e)) * 0.5)
  if (typeof e == 'string' && e.endsWith('px')) {
    const n = parseFloat(e)
    if (!Number.isNaN(n)) return Math.floor(n)
  }
  if (typeof e == 'string' && e.endsWith('%')) {
    const n = parseFloat(e)
    if (!Number.isNaN(n)) return Math.floor(t * n * 0.01)
  }
  return (
    console.error(
      `[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`,
    ),
    0
  )
}
function BD(e, t, n) {
  if (typeof e == 'string' || typeof e == 'number') {
    const r = vn(e, n),
      i = vn(e, t)
    return { top: r, right: i, bottom: r, left: i, x: i * 2, y: r * 2 }
  }
  if (typeof e == 'object') {
    const r = vn(e.top ?? e.y ?? 0, n),
      i = vn(e.bottom ?? e.y ?? 0, n),
      o = vn(e.left ?? e.x ?? 0, t),
      a = vn(e.right ?? e.x ?? 0, t)
    return { top: r, right: a, bottom: i, left: o, x: o + a, y: r + i }
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 }
}
function HD(e, t, n, r, i, o) {
  const { x: a, y: s } = io(e, [t, n, r]),
    { x: l, y: c } = io({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]),
    u = i - l,
    f = o - c
  return { left: Math.floor(a), top: Math.floor(s), right: Math.floor(u), bottom: Math.floor(f) }
}
const jc = (e, t, n, r, i, o) => {
    const a = BD(o, t, n),
      s = (t - a.x) / e.width,
      l = (n - a.y) / e.height,
      c = Math.min(s, l),
      u = Tn(c, r, i),
      f = e.x + e.width / 2,
      d = e.y + e.height / 2,
      h = t / 2 - f * u,
      g = n / 2 - d * u,
      p = HD(e, h, g, u, t, n),
      x = {
        left: Math.min(p.left - a.left, 0),
        top: Math.min(p.top - a.top, 0),
        right: Math.min(p.right - a.right, 0),
        bottom: Math.min(p.bottom - a.bottom, 0),
      }
    return { x: h - x.left + x.right, y: g - x.top + x.bottom, zoom: u }
  },
  br = () => typeof navigator < 'u' && navigator?.userAgent?.indexOf('Mac') >= 0
function Dn(e) {
  return e != null && e !== 'parent'
}
function It(e) {
  return {
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0,
  }
}
function gg(e) {
  return (
    (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 &&
    (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0
  )
}
function mg(e, t = { width: 0, height: 0 }, n, r, i) {
  const o = { ...e },
    a = r.get(n)
  if (a) {
    const s = a.origin || i
    ;((o.x += a.internals.positionAbsolute.x - (t.width ?? 0) * s[0]),
      (o.y += a.internals.positionAbsolute.y - (t.height ?? 0) * s[1]))
  }
  return o
}
function Ef(e, t) {
  if (e.size !== t.size) return !1
  for (const n of e) if (!t.has(n)) return !1
  return !0
}
function FD() {
  let e, t
  return {
    promise: new Promise((r, i) => {
      ;((e = r), (t = i))
    }),
    resolve: e,
    reject: t,
  }
}
function VD(e) {
  return { ...cg, ...(e || {}) }
}
function ar(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: i }) {
  const { x: o, y: a } = at(e),
    s = Fr({ x: o - (i?.left ?? 0), y: a - (i?.top ?? 0) }, r),
    { x: l, y: c } = n ? Hr(s, t) : s
  return { xSnapped: l, ySnapped: c, ...s }
}
const $c = (e) => ({ width: e.offsetWidth, height: e.offsetHeight }),
  yg = (e) => e?.getRootNode?.() || window?.document,
  WD = ['INPUT', 'SELECT', 'TEXTAREA']
function xg(e) {
  const t = e.composedPath?.()?.[0] || e.target
  return t?.nodeType !== 1
    ? !1
    : WD.includes(t.nodeName) || t.hasAttribute('contenteditable') || !!t.closest('.nokey')
}
const bg = (e) => 'clientX' in e,
  at = (e, t) => {
    const n = bg(e),
      r = n ? e.clientX : e.touches?.[0].clientX,
      i = n ? e.clientY : e.touches?.[0].clientY
    return { x: r - (t?.left ?? 0), y: i - (t?.top ?? 0) }
  },
  _f = (e, t, n, r, i) => {
    const o = t.querySelectorAll(`.${e}`)
    return !o || !o.length
      ? null
      : Array.from(o).map((a) => {
          const s = a.getBoundingClientRect()
          return {
            id: a.getAttribute('data-handleid'),
            type: e,
            nodeId: i,
            position: a.getAttribute('data-handlepos'),
            x: (s.left - n.left) / r,
            y: (s.top - n.top) / r,
            ...$c(a),
          }
        })
  }
function wg({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: r,
  sourceControlX: i,
  sourceControlY: o,
  targetControlX: a,
  targetControlY: s,
}) {
  const l = e * 0.125 + i * 0.375 + a * 0.375 + n * 0.125,
    c = t * 0.125 + o * 0.375 + s * 0.375 + r * 0.125,
    u = Math.abs(l - e),
    f = Math.abs(c - t)
  return [l, c, u, f]
}
function ci(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e)
}
function Af({ pos: e, x1: t, y1: n, x2: r, y2: i, c: o }) {
  switch (e) {
    case ee.Left:
      return [t - ci(t - r, o), n]
    case ee.Right:
      return [t + ci(r - t, o), n]
    case ee.Top:
      return [t, n - ci(n - i, o)]
    case ee.Bottom:
      return [t, n + ci(i - n, o)]
  }
}
function Pg({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = ee.Bottom,
  targetX: r,
  targetY: i,
  targetPosition: o = ee.Top,
  curvature: a = 0.25,
}) {
  const [s, l] = Af({ pos: n, x1: e, y1: t, x2: r, y2: i, c: a }),
    [c, u] = Af({ pos: o, x1: r, y1: i, x2: e, y2: t, c: a }),
    [f, d, h, g] = wg({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: i,
      sourceControlX: s,
      sourceControlY: l,
      targetControlX: c,
      targetControlY: u,
    })
  return [`M${e},${t} C${s},${l} ${c},${u} ${r},${i}`, f, d, h, g]
}
function Sg({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const i = Math.abs(n - e) / 2,
    o = n < e ? n + i : n - i,
    a = Math.abs(r - t) / 2,
    s = r < t ? r + a : r - a
  return [o, s, i, a]
}
function KD({
  sourceNode: e,
  targetNode: t,
  selected: n = !1,
  zIndex: r,
  elevateOnSelect: i = !1,
}) {
  if (r !== void 0) return r
  const o = i && n ? 1e3 : 0,
    a = Math.max(
      e.parentId || (i && e.selected) ? e.internals.z : 0,
      t.parentId || (i && t.selected) ? t.internals.z : 0,
    )
  return o + a
}
function YD({ sourceNode: e, targetNode: t, width: n, height: r, transform: i }) {
  const o = Bo(ro(e), ro(t))
  ;(o.x === o.x2 && (o.x2 += 1), o.y === o.y2 && (o.y2 += 1))
  const a = { x: -i[0] / i[2], y: -i[1] / i[2], width: n / i[2], height: r / i[2] }
  return xr(a, Ho(o)) > 0
}
const UD = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) =>
    `xy-edge__${e}${t || ''}-${n}${r || ''}`,
  XD = (e, t) =>
    t.some(
      (n) =>
        n.source === e.source &&
        n.target === e.target &&
        (n.sourceHandle === e.sourceHandle || (!n.sourceHandle && !e.sourceHandle)) &&
        (n.targetHandle === e.targetHandle || (!n.targetHandle && !e.targetHandle)),
    ),
  GD = (e, t) => {
    if (!e.source || !e.target) return t
    let n
    return (
      fg(e) ? (n = { ...e }) : (n = { ...e, id: UD(e) }),
      XD(n, t)
        ? t
        : (n.sourceHandle === null && delete n.sourceHandle,
          n.targetHandle === null && delete n.targetHandle,
          t.concat(n))
    )
  }
function Eg({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [i, o, a, s] = Sg({ sourceX: e, sourceY: t, targetX: n, targetY: r })
  return [`M ${e},${t}L ${n},${r}`, i, o, a, s]
}
const Of = {
    [ee.Left]: { x: -1, y: 0 },
    [ee.Right]: { x: 1, y: 0 },
    [ee.Top]: { x: 0, y: -1 },
    [ee.Bottom]: { x: 0, y: 1 },
  },
  qD = ({ source: e, sourcePosition: t = ee.Bottom, target: n }) =>
    t === ee.Left || t === ee.Right
      ? e.x < n.x
        ? { x: 1, y: 0 }
        : { x: -1, y: 0 }
      : e.y < n.y
        ? { x: 0, y: 1 }
        : { x: 0, y: -1 },
  Cf = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
function ZD({
  source: e,
  sourcePosition: t = ee.Bottom,
  target: n,
  targetPosition: r = ee.Top,
  center: i,
  offset: o,
  stepPosition: a,
}) {
  const s = Of[t],
    l = Of[r],
    c = { x: e.x + s.x * o, y: e.y + s.y * o },
    u = { x: n.x + l.x * o, y: n.y + l.y * o },
    f = qD({ source: c, sourcePosition: t, target: u }),
    d = f.x !== 0 ? 'x' : 'y',
    h = f[d]
  let g = [],
    p,
    x
  const y = { x: 0, y: 0 },
    w = { x: 0, y: 0 },
    [, , m, b] = Sg({ sourceX: e.x, sourceY: e.y, targetX: n.x, targetY: n.y })
  if (s[d] * l[d] === -1) {
    d === 'x'
      ? ((p = i.x ?? c.x + (u.x - c.x) * a), (x = i.y ?? (c.y + u.y) / 2))
      : ((p = i.x ?? (c.x + u.x) / 2), (x = i.y ?? c.y + (u.y - c.y) * a))
    const S = [
        { x: p, y: c.y },
        { x: p, y: u.y },
      ],
      _ = [
        { x: c.x, y: x },
        { x: u.x, y: x },
      ]
    s[d] === h ? (g = d === 'x' ? S : _) : (g = d === 'x' ? _ : S)
  } else {
    const S = [{ x: c.x, y: u.y }],
      _ = [{ x: u.x, y: c.y }]
    if ((d === 'x' ? (g = s.x === h ? _ : S) : (g = s.y === h ? S : _), t === r)) {
      const k = Math.abs(e[d] - n[d])
      if (k <= o) {
        const $ = Math.min(o - 1, o - k)
        s[d] === h ? (y[d] = (c[d] > e[d] ? -1 : 1) * $) : (w[d] = (u[d] > n[d] ? -1 : 1) * $)
      }
    }
    if (t !== r) {
      const k = d === 'x' ? 'y' : 'x',
        $ = s[d] === l[k],
        E = c[k] > u[k],
        O = c[k] < u[k]
      ;((s[d] === 1 && ((!$ && E) || ($ && O))) || (s[d] !== 1 && ((!$ && O) || ($ && E)))) &&
        (g = d === 'x' ? S : _)
    }
    const M = { x: c.x + y.x, y: c.y + y.y },
      T = { x: u.x + w.x, y: u.y + w.y },
      F = Math.max(Math.abs(M.x - g[0].x), Math.abs(T.x - g[0].x)),
      D = Math.max(Math.abs(M.y - g[0].y), Math.abs(T.y - g[0].y))
    F >= D ? ((p = (M.x + T.x) / 2), (x = g[0].y)) : ((p = g[0].x), (x = (M.y + T.y) / 2))
  }
  return [[e, { x: c.x + y.x, y: c.y + y.y }, ...g, { x: u.x + w.x, y: u.y + w.y }, n], p, x, m, b]
}
function QD(e, t, n, r) {
  const i = Math.min(Cf(e, t) / 2, Cf(t, n) / 2, r),
    { x: o, y: a } = t
  if ((e.x === o && o === n.x) || (e.y === a && a === n.y)) return `L${o} ${a}`
  if (e.y === a) {
    const c = e.x < n.x ? -1 : 1,
      u = e.y < n.y ? 1 : -1
    return `L ${o + i * c},${a}Q ${o},${a} ${o},${a + i * u}`
  }
  const s = e.x < n.x ? 1 : -1,
    l = e.y < n.y ? -1 : 1
  return `L ${o},${a + i * l}Q ${o},${a} ${o + i * s},${a}`
}
function ss({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = ee.Bottom,
  targetX: r,
  targetY: i,
  targetPosition: o = ee.Top,
  borderRadius: a = 5,
  centerX: s,
  centerY: l,
  offset: c = 20,
  stepPosition: u = 0.5,
}) {
  const [f, d, h, g, p] = ZD({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: i },
    targetPosition: o,
    center: { x: s, y: l },
    offset: c,
    stepPosition: u,
  })
  return [
    f.reduce((y, w, m) => {
      let b = ''
      return (
        m > 0 && m < f.length - 1
          ? (b = QD(f[m - 1], w, f[m + 1], a))
          : (b = `${m === 0 ? 'M' : 'L'}${w.x} ${w.y}`),
        (y += b),
        y
      )
    }, ''),
    d,
    h,
    g,
    p,
  ]
}
function kf(e) {
  return (
    e &&
    !!(e.internals.handleBounds || e.handles?.length) &&
    !!(e.measured.width || e.width || e.initialWidth)
  )
}
function JD(e) {
  const { sourceNode: t, targetNode: n } = e
  if (!kf(t) || !kf(n)) return null
  const r = t.internals.handleBounds || Mf(t.handles),
    i = n.internals.handleBounds || Mf(n.handles),
    o = Tf(r?.source ?? [], e.sourceHandle),
    a = Tf(
      e.connectionMode === Mn.Strict
        ? (i?.target ?? [])
        : (i?.target ?? []).concat(i?.source ?? []),
      e.targetHandle,
    )
  if (!o || !a)
    return (
      e.onError?.(
        '008',
        ht.error008(o ? 'target' : 'source', {
          id: e.id,
          sourceHandle: e.sourceHandle,
          targetHandle: e.targetHandle,
        }),
      ),
      null
    )
  const s = o?.position || ee.Bottom,
    l = a?.position || ee.Top,
    c = wr(t, o, s),
    u = wr(n, a, l)
  return {
    sourceX: c.x,
    sourceY: c.y,
    targetX: u.x,
    targetY: u.y,
    sourcePosition: s,
    targetPosition: l,
  }
}
function Mf(e) {
  if (!e) return null
  const t = [],
    n = []
  for (const r of e)
    ((r.width = r.width ?? 1),
      (r.height = r.height ?? 1),
      r.type === 'source' ? t.push(r) : r.type === 'target' && n.push(r))
  return { source: t, target: n }
}
function wr(e, t, n = ee.Left, r = !1) {
  const i = (t?.x ?? 0) + e.internals.positionAbsolute.x,
    o = (t?.y ?? 0) + e.internals.positionAbsolute.y,
    { width: a, height: s } = t ?? It(e)
  if (r) return { x: i + a / 2, y: o + s / 2 }
  switch (t?.position ?? n) {
    case ee.Top:
      return { x: i + a / 2, y: o }
    case ee.Right:
      return { x: i + a, y: o + s / 2 }
    case ee.Bottom:
      return { x: i + a / 2, y: o + s }
    case ee.Left:
      return { x: i, y: o + s / 2 }
  }
}
function Tf(e, t) {
  return (e && (t ? e.find((n) => n.id === t) : e[0])) || null
}
function cs(e, t) {
  return e
    ? typeof e == 'string'
      ? e
      : `${t ? `${t}__` : ''}${Object.keys(e)
          .sort()
          .map((r) => `${r}=${e[r]}`)
          .join('&')}`
    : ''
}
function eI(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: i }) {
  const o = new Set()
  return e
    .reduce(
      (a, s) => (
        [s.markerStart || r, s.markerEnd || i].forEach((l) => {
          if (l && typeof l == 'object') {
            const c = cs(l, t)
            o.has(c) || (a.push({ id: c, color: l.color || n, ...l }), o.add(c))
          }
        }),
        a
      ),
      [],
    )
    .sort((a, s) => a.id.localeCompare(s.id))
}
const _g = 1e3,
  tI = 10,
  Lc = { nodeOrigin: [0, 0], nodeExtent: mr, elevateNodesOnSelect: !0, defaults: {} },
  nI = { ...Lc, checkEquality: !0 }
function zc(e, t) {
  const n = { ...e }
  for (const r in t) t[r] !== void 0 && (n[r] = t[r])
  return n
}
function rI(e, t, n) {
  const r = zc(Lc, n)
  for (const i of e.values())
    if (i.parentId) Rc(i, e, t, r)
    else {
      const o = Rr(i, r.nodeOrigin),
        a = Dn(i.extent) ? i.extent : r.nodeExtent,
        s = cn(o, a, It(i))
      i.internals.positionAbsolute = s
    }
}
function iI(e, t) {
  if (!e.handles) return e.measured ? t?.internals.handleBounds : void 0
  const n = [],
    r = []
  for (const i of e.handles) {
    const o = {
      id: i.id,
      width: i.width ?? 1,
      height: i.height ?? 1,
      nodeId: e.id,
      x: i.x,
      y: i.y,
      position: i.position,
      type: i.type,
    }
    i.type === 'source' ? n.push(o) : i.type === 'target' && r.push(o)
  }
  return { source: n, target: r }
}
function ls(e, t, n, r) {
  const i = zc(nI, r)
  let o = { i: -1 },
    a = e.length > 0
  const s = new Map(t),
    l = i?.elevateNodesOnSelect ? _g : 0
  ;(t.clear(), n.clear())
  for (const c of e) {
    let u = s.get(c.id)
    if (i.checkEquality && c === u?.internals.userNode) t.set(c.id, u)
    else {
      const f = Rr(c, i.nodeOrigin),
        d = Dn(c.extent) ? c.extent : i.nodeExtent,
        h = cn(f, d, It(c))
      ;((u = {
        ...i.defaults,
        ...c,
        measured: { width: c.measured?.width, height: c.measured?.height },
        internals: { positionAbsolute: h, handleBounds: iI(c, u), z: Ag(c, l), userNode: c },
      }),
        t.set(c.id, u))
    }
    ;((u.measured === void 0 || u.measured.width === void 0 || u.measured.height === void 0) &&
      !u.hidden &&
      (a = !1),
      c.parentId && Rc(u, t, n, r, o))
  }
  return a
}
function oI(e, t) {
  if (!e.parentId) return
  const n = t.get(e.parentId)
  n ? n.set(e.id, e) : t.set(e.parentId, new Map([[e.id, e]]))
}
function Rc(e, t, n, r, i) {
  const { elevateNodesOnSelect: o, nodeOrigin: a, nodeExtent: s } = zc(Lc, r),
    l = e.parentId,
    c = t.get(l)
  if (!c) {
    console.warn(
      `Parent node ${l} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`,
    )
    return
  }
  ;(oI(e, n),
    i &&
      !c.parentId &&
      c.internals.rootParentIndex === void 0 &&
      ((c.internals.rootParentIndex = ++i.i), (c.internals.z = c.internals.z + i.i * tI)),
    i && c.internals.rootParentIndex !== void 0 && (i.i = c.internals.rootParentIndex))
  const u = o ? _g : 0,
    { x: f, y: d, z: h } = aI(e, c, a, s, u),
    { positionAbsolute: g } = e.internals,
    p = f !== g.x || d !== g.y
  ;(p || h !== e.internals.z) &&
    t.set(e.id, {
      ...e,
      internals: { ...e.internals, positionAbsolute: p ? { x: f, y: d } : g, z: h },
    })
}
function Ag(e, t) {
  return (ot(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0)
}
function aI(e, t, n, r, i) {
  const { x: o, y: a } = t.internals.positionAbsolute,
    s = It(e),
    l = Rr(e, n),
    c = Dn(e.extent) ? cn(l, e.extent, s) : l
  let u = cn({ x: o + c.x, y: a + c.y }, r, s)
  e.extent === 'parent' && (u = hg(u, s, t))
  const f = Ag(e, i),
    d = t.internals.z ?? 0
  return { x: u.x, y: u.y, z: d >= f ? d + 1 : f }
}
function Bc(e, t, n, r = [0, 0]) {
  const i = [],
    o = new Map()
  for (const a of e) {
    const s = t.get(a.parentId)
    if (!s) continue
    const l = o.get(a.parentId)?.expandedRect ?? Nn(s),
      c = vg(l, a.rect)
    o.set(a.parentId, { expandedRect: c, parent: s })
  }
  return (
    o.size > 0 &&
      o.forEach(({ expandedRect: a, parent: s }, l) => {
        const c = s.internals.positionAbsolute,
          u = It(s),
          f = s.origin ?? r,
          d = a.x < c.x ? Math.round(Math.abs(c.x - a.x)) : 0,
          h = a.y < c.y ? Math.round(Math.abs(c.y - a.y)) : 0,
          g = Math.max(u.width, Math.round(a.width)),
          p = Math.max(u.height, Math.round(a.height)),
          x = (g - u.width) * f[0],
          y = (p - u.height) * f[1]
        ;((d > 0 || h > 0 || x || y) &&
          (i.push({
            id: l,
            type: 'position',
            position: { x: s.position.x - d + x, y: s.position.y - h + y },
          }),
          n.get(l)?.forEach((w) => {
            e.some((m) => m.id === w.id) ||
              i.push({
                id: w.id,
                type: 'position',
                position: { x: w.position.x + d, y: w.position.y + h },
              })
          })),
          (u.width < a.width || u.height < a.height || d || h) &&
            i.push({
              id: l,
              type: 'dimensions',
              setAttributes: !0,
              dimensions: { width: g + (d ? f[0] * d - x : 0), height: p + (h ? f[1] * h - y : 0) },
            }))
      }),
    i
  )
}
function sI(e, t, n, r, i, o) {
  const a = r?.querySelector('.xyflow__viewport')
  let s = !1
  if (!a) return { changes: [], updatedInternals: s }
  const l = [],
    c = window.getComputedStyle(a),
    { m22: u } = new window.DOMMatrixReadOnly(c.transform),
    f = []
  for (const d of e.values()) {
    const h = t.get(d.id)
    if (!h) continue
    if (h.hidden) {
      ;(t.set(h.id, { ...h, internals: { ...h.internals, handleBounds: void 0 } }), (s = !0))
      continue
    }
    const g = $c(d.nodeElement),
      p = h.measured.width !== g.width || h.measured.height !== g.height
    if (!!(g.width && g.height && (p || !h.internals.handleBounds || d.force))) {
      const y = d.nodeElement.getBoundingClientRect(),
        w = Dn(h.extent) ? h.extent : o
      let { positionAbsolute: m } = h.internals
      h.parentId && h.extent === 'parent'
        ? (m = hg(m, g, t.get(h.parentId)))
        : w && (m = cn(m, w, g))
      const b = {
        ...h,
        measured: g,
        internals: {
          ...h.internals,
          positionAbsolute: m,
          handleBounds: {
            source: _f('source', d.nodeElement, y, u, h.id),
            target: _f('target', d.nodeElement, y, u, h.id),
          },
        },
      }
      ;(t.set(h.id, b),
        h.parentId && Rc(b, t, n, { nodeOrigin: i }),
        (s = !0),
        p &&
          (l.push({ id: h.id, type: 'dimensions', dimensions: g }),
          h.expandParent &&
            h.parentId &&
            f.push({ id: h.id, parentId: h.parentId, rect: Nn(b, i) })))
    }
  }
  if (f.length > 0) {
    const d = Bc(f, t, n, i)
    l.push(...d)
  }
  return { changes: l, updatedInternals: s }
}
async function cI({ delta: e, panZoom: t, transform: n, translateExtent: r, width: i, height: o }) {
  if (!t || (!e.x && !e.y)) return Promise.resolve(!1)
  const a = await t.setViewportConstrained(
      { x: n[0] + e.x, y: n[1] + e.y, zoom: n[2] },
      [
        [0, 0],
        [i, o],
      ],
      r,
    ),
    s = !!a && (a.x !== n[0] || a.y !== n[1] || a.k !== n[2])
  return Promise.resolve(s)
}
function Nf(e, t, n, r, i, o) {
  let a = i
  const s = r.get(a) || new Map()
  ;(r.set(a, s.set(n, t)), (a = `${i}-${e}`))
  const l = r.get(a) || new Map()
  if ((r.set(a, l.set(n, t)), o)) {
    a = `${i}-${e}-${o}`
    const c = r.get(a) || new Map()
    r.set(a, c.set(n, t))
  }
}
function Og(e, t, n) {
  ;(e.clear(), t.clear())
  for (const r of n) {
    const { source: i, target: o, sourceHandle: a = null, targetHandle: s = null } = r,
      l = { edgeId: r.id, source: i, target: o, sourceHandle: a, targetHandle: s },
      c = `${i}-${a}--${o}-${s}`,
      u = `${o}-${s}--${i}-${a}`
    ;(Nf('source', l, u, e, i, a), Nf('target', l, c, e, o, s), t.set(r.id, r))
  }
}
function Cg(e, t) {
  if (!e.parentId) return !1
  const n = t.get(e.parentId)
  return n ? (n.selected ? !0 : Cg(n, t)) : !1
}
function Df(e, t, n) {
  let r = e
  do {
    if (r?.matches?.(t)) return !0
    if (r === n) return !1
    r = r?.parentElement
  } while (r)
  return !1
}
function lI(e, t, n, r) {
  const i = new Map()
  for (const [o, a] of e)
    if (
      (a.selected || a.id === r) &&
      (!a.parentId || !Cg(a, e)) &&
      (a.draggable || (t && typeof a.draggable > 'u'))
    ) {
      const s = e.get(o)
      s &&
        i.set(o, {
          id: o,
          position: s.position || { x: 0, y: 0 },
          distance: {
            x: n.x - s.internals.positionAbsolute.x,
            y: n.y - s.internals.positionAbsolute.y,
          },
          extent: s.extent,
          parentId: s.parentId,
          origin: s.origin,
          expandParent: s.expandParent,
          internals: { positionAbsolute: s.internals.positionAbsolute || { x: 0, y: 0 } },
          measured: { width: s.measured.width ?? 0, height: s.measured.height ?? 0 },
        })
    }
  return i
}
function da({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  const i = []
  for (const [a, s] of t) {
    const l = n.get(a)?.internals.userNode
    l && i.push({ ...l, position: s.position, dragging: r })
  }
  if (!e) return [i[0], i]
  const o = n.get(e)?.internals.userNode
  return [o ? { ...o, position: t.get(e)?.position || o.position, dragging: r } : i[0], i]
}
function uI({ dragItems: e, snapGrid: t, x: n, y: r }) {
  const i = e.values().next().value
  if (!i) return null
  const o = { x: n - i.distance.x, y: r - i.distance.y },
    a = Hr(o, t)
  return { x: a.x - o.x, y: a.y - o.y }
}
function fI({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: i }) {
  let o = { x: null, y: null },
    a = 0,
    s = new Map(),
    l = !1,
    c = { x: 0, y: 0 },
    u = null,
    f = !1,
    d = null,
    h = !1,
    g = !1,
    p = null
  function x({
    noDragClassName: w,
    handleSelector: m,
    domNode: b,
    isSelectable: P,
    nodeId: S,
    nodeClickDistance: _ = 0,
  }) {
    d = He(b)
    function M({ x: k, y: $ }) {
      const {
        nodeLookup: E,
        nodeExtent: O,
        snapGrid: A,
        snapToGrid: C,
        nodeOrigin: N,
        onNodeDrag: I,
        onSelectionDrag: H,
        onError: V,
        updateNodePositions: B,
      } = t()
      o = { x: k, y: $ }
      let Y = !1
      const K = s.size > 1,
        G = K && O ? as(Br(s)) : null,
        re = K && C ? uI({ dragItems: s, snapGrid: A, x: k, y: $ }) : null
      for (const [q, W] of s) {
        if (!E.has(q)) continue
        let j = { x: k - W.distance.x, y: $ - W.distance.y }
        C && (j = re ? { x: Math.round(j.x + re.x), y: Math.round(j.y + re.y) } : Hr(j, A))
        let U = null
        if (K && O && !W.extent && G) {
          const { positionAbsolute: Q } = W.internals,
            Z = Q.x - G.x + O[0][0],
            ne = Q.x + W.measured.width - G.x2 + O[1][0],
            ae = Q.y - G.y + O[0][1],
            ue = Q.y + W.measured.height - G.y2 + O[1][1]
          U = [
            [Z, ae],
            [ne, ue],
          ]
        }
        const { position: X, positionAbsolute: L } = dg({
          nodeId: q,
          nextPosition: j,
          nodeLookup: E,
          nodeExtent: U || O,
          nodeOrigin: N,
          onError: V,
        })
        ;((Y = Y || W.position.x !== X.x || W.position.y !== X.y),
          (W.position = X),
          (W.internals.positionAbsolute = L))
      }
      if (((g = g || Y), !!Y && (B(s, !0), p && (r || I || (!S && H))))) {
        const [q, W] = da({ nodeId: S, dragItems: s, nodeLookup: E })
        ;(r?.(p, s, q, W), I?.(p, q, W), S || H?.(p, W))
      }
    }
    async function T() {
      if (!u) return
      const { transform: k, panBy: $, autoPanSpeed: E, autoPanOnNodeDrag: O } = t()
      if (!O) {
        ;((l = !1), cancelAnimationFrame(a))
        return
      }
      const [A, C] = pg(c, u, E)
      ;((A !== 0 || C !== 0) &&
        ((o.x = (o.x ?? 0) - A / k[2]),
        (o.y = (o.y ?? 0) - C / k[2]),
        (await $({ x: A, y: C })) && M(o)),
        (a = requestAnimationFrame(T)))
    }
    function F(k) {
      const {
        nodeLookup: $,
        multiSelectionActive: E,
        nodesDraggable: O,
        transform: A,
        snapGrid: C,
        snapToGrid: N,
        selectNodesOnDrag: I,
        onNodeDragStart: H,
        onSelectionDragStart: V,
        unselectNodesAndEdges: B,
      } = t()
      ;((f = !0), (!I || !P) && !E && S && ($.get(S)?.selected || B()), P && I && S && e?.(S))
      const Y = ar(k.sourceEvent, { transform: A, snapGrid: C, snapToGrid: N, containerBounds: u })
      if (((o = Y), (s = lI($, O, Y, S)), s.size > 0 && (n || H || (!S && V)))) {
        const [K, G] = da({ nodeId: S, dragItems: s, nodeLookup: $ })
        ;(n?.(k.sourceEvent, s, K, G), H?.(k.sourceEvent, K, G), S || V?.(k.sourceEvent, G))
      }
    }
    const D = Zv()
      .clickDistance(_)
      .on('start', (k) => {
        const { domNode: $, nodeDragThreshold: E, transform: O, snapGrid: A, snapToGrid: C } = t()
        ;((u = $?.getBoundingClientRect() || null),
          (h = !1),
          (g = !1),
          (p = k.sourceEvent),
          E === 0 && F(k),
          (o = ar(k.sourceEvent, { transform: O, snapGrid: A, snapToGrid: C, containerBounds: u })),
          (c = at(k.sourceEvent, u)))
      })
      .on('drag', (k) => {
        const {
            autoPanOnNodeDrag: $,
            transform: E,
            snapGrid: O,
            snapToGrid: A,
            nodeDragThreshold: C,
            nodeLookup: N,
          } = t(),
          I = ar(k.sourceEvent, { transform: E, snapGrid: O, snapToGrid: A, containerBounds: u })
        if (
          ((p = k.sourceEvent),
          ((k.sourceEvent.type === 'touchmove' && k.sourceEvent.touches.length > 1) ||
            (S && !N.has(S))) &&
            (h = !0),
          !h)
        ) {
          if ((!l && $ && f && ((l = !0), T()), !f)) {
            const H = at(k.sourceEvent, u),
              V = H.x - c.x,
              B = H.y - c.y
            Math.sqrt(V * V + B * B) > C && F(k)
          }
          ;(o.x !== I.xSnapped || o.y !== I.ySnapped) &&
            s &&
            f &&
            ((c = at(k.sourceEvent, u)), M(I))
        }
      })
      .on('end', (k) => {
        if (!(!f || h) && ((l = !1), (f = !1), cancelAnimationFrame(a), s.size > 0)) {
          const {
            nodeLookup: $,
            updateNodePositions: E,
            onNodeDragStop: O,
            onSelectionDragStop: A,
          } = t()
          if ((g && (E(s, !1), (g = !1)), i || O || (!S && A))) {
            const [C, N] = da({ nodeId: S, dragItems: s, nodeLookup: $, dragging: !1 })
            ;(i?.(k.sourceEvent, s, C, N), O?.(k.sourceEvent, C, N), S || A?.(k.sourceEvent, N))
          }
        }
      })
      .filter((k) => {
        const $ = k.target
        return !k.button && (!w || !Df($, `.${w}`, b)) && (!m || Df($, m, b))
      })
    d.call(D)
  }
  function y() {
    d?.on('.drag', null)
  }
  return { update: x, destroy: y }
}
function dI(e, t, n) {
  const r = [],
    i = { x: e.x - n, y: e.y - n, width: n * 2, height: n * 2 }
  for (const o of t.values()) xr(i, Nn(o)) > 0 && r.push(o)
  return r
}
const hI = 250
function pI(e, t, n, r) {
  let i = [],
    o = 1 / 0
  const a = dI(e, n, t + hI)
  for (const s of a) {
    const l = [
      ...(s.internals.handleBounds?.source ?? []),
      ...(s.internals.handleBounds?.target ?? []),
    ]
    for (const c of l) {
      if (r.nodeId === c.nodeId && r.type === c.type && r.id === c.id) continue
      const { x: u, y: f } = wr(s, c, c.position, !0),
        d = Math.sqrt(Math.pow(u - e.x, 2) + Math.pow(f - e.y, 2))
      d > t ||
        (d < o ? ((i = [{ ...c, x: u, y: f }]), (o = d)) : d === o && i.push({ ...c, x: u, y: f }))
    }
  }
  if (!i.length) return null
  if (i.length > 1) {
    const s = r.type === 'source' ? 'target' : 'source'
    return i.find((l) => l.type === s) ?? i[0]
  }
  return i[0]
}
function kg(e, t, n, r, i, o = !1) {
  const a = r.get(e)
  if (!a) return null
  const s =
      i === 'strict'
        ? a.internals.handleBounds?.[t]
        : [
            ...(a.internals.handleBounds?.source ?? []),
            ...(a.internals.handleBounds?.target ?? []),
          ],
    l = (n ? s?.find((c) => c.id === n) : s?.[0]) ?? null
  return l && o ? { ...l, ...wr(a, l, l.position, !0) } : l
}
function Mg(e, t) {
  return (
    e ||
    (t?.classList.contains('target') ? 'target' : t?.classList.contains('source') ? 'source' : null)
  )
}
function vI(e, t) {
  let n = null
  return (t ? (n = !0) : e && !t && (n = !1), n)
}
const Tg = () => !0
function gI(
  e,
  {
    connectionMode: t,
    connectionRadius: n,
    handleId: r,
    nodeId: i,
    edgeUpdaterType: o,
    isTarget: a,
    domNode: s,
    nodeLookup: l,
    lib: c,
    autoPanOnConnect: u,
    flowId: f,
    panBy: d,
    cancelConnection: h,
    onConnectStart: g,
    onConnect: p,
    onConnectEnd: x,
    isValidConnection: y = Tg,
    onReconnectEnd: w,
    updateConnection: m,
    getTransform: b,
    getFromHandle: P,
    autoPanSpeed: S,
    dragThreshold: _ = 1,
    handleDomNode: M,
  },
) {
  const T = yg(e.target)
  let F = 0,
    D
  const { x: k, y: $ } = at(e),
    E = Mg(o, M),
    O = s?.getBoundingClientRect()
  let A = !1
  if (!O || !E) return
  const C = kg(i, E, r, l, t)
  if (!C) return
  let N = at(e, O),
    I = !1,
    H = null,
    V = !1,
    B = null
  function Y() {
    if (!u || !O) return
    const [X, L] = pg(N, O, S)
    ;(d({ x: X, y: L }), (F = requestAnimationFrame(Y)))
  }
  const K = { ...C, nodeId: i, type: E, position: C.position },
    G = l.get(i)
  let q = {
    inProgress: !0,
    isValid: null,
    from: wr(G, K, ee.Left, !0),
    fromHandle: K,
    fromPosition: K.position,
    fromNode: G,
    to: N,
    toHandle: null,
    toPosition: wf[K.position],
    toNode: null,
  }
  function W() {
    ;((A = !0), m(q), g?.(e, { nodeId: i, handleId: r, handleType: E }))
  }
  _ === 0 && W()
  function j(X) {
    if (!A) {
      const { x: ne, y: ae } = at(X),
        ue = ne - k,
        Ye = ae - $
      if (!(ue * ue + Ye * Ye > _ * _)) return
      W()
    }
    if (!P() || !K) {
      U(X)
      return
    }
    const L = b()
    ;((N = at(X, O)), (D = pI(Fr(N, L, !1, [1, 1]), n, l, K)), I || (Y(), (I = !0)))
    const Q = Ng(X, {
      handle: D,
      connectionMode: t,
      fromNodeId: i,
      fromHandleId: r,
      fromType: a ? 'target' : 'source',
      isValidConnection: y,
      doc: T,
      lib: c,
      flowId: f,
      nodeLookup: l,
    })
    ;((B = Q.handleDomNode), (H = Q.connection), (V = vI(!!D, Q.isValid)))
    const Z = {
      ...q,
      isValid: V,
      to: Q.toHandle && V ? io({ x: Q.toHandle.x, y: Q.toHandle.y }, L) : N,
      toHandle: Q.toHandle,
      toPosition: V && Q.toHandle ? Q.toHandle.position : wf[K.position],
      toNode: Q.toHandle ? l.get(Q.toHandle.nodeId) : null,
    }
    ;(V &&
      D &&
      q.toHandle &&
      Z.toHandle &&
      q.toHandle.type === Z.toHandle.type &&
      q.toHandle.nodeId === Z.toHandle.nodeId &&
      q.toHandle.id === Z.toHandle.id &&
      q.to.x === Z.to.x &&
      q.to.y === Z.to.y) ||
      (m(Z), (q = Z))
  }
  function U(X) {
    if (!('touches' in X && X.touches.length > 0)) {
      if (A) {
        ;(D || B) && H && V && p?.(H)
        const { inProgress: L, ...Q } = q,
          Z = { ...Q, toPosition: q.toHandle ? q.toPosition : null }
        ;(x?.(X, Z), o && w?.(X, Z))
      }
      ;(h(),
        cancelAnimationFrame(F),
        (I = !1),
        (V = !1),
        (H = null),
        (B = null),
        T.removeEventListener('mousemove', j),
        T.removeEventListener('mouseup', U),
        T.removeEventListener('touchmove', j),
        T.removeEventListener('touchend', U))
    }
  }
  ;(T.addEventListener('mousemove', j),
    T.addEventListener('mouseup', U),
    T.addEventListener('touchmove', j),
    T.addEventListener('touchend', U))
}
function Ng(
  e,
  {
    handle: t,
    connectionMode: n,
    fromNodeId: r,
    fromHandleId: i,
    fromType: o,
    doc: a,
    lib: s,
    flowId: l,
    isValidConnection: c = Tg,
    nodeLookup: u,
  },
) {
  const f = o === 'target',
    d = t
      ? a.querySelector(`.${s}-flow__handle[data-id="${l}-${t?.nodeId}-${t?.id}-${t?.type}"]`)
      : null,
    { x: h, y: g } = at(e),
    p = a.elementFromPoint(h, g),
    x = p?.classList.contains(`${s}-flow__handle`) ? p : d,
    y = { handleDomNode: x, isValid: !1, connection: null, toHandle: null }
  if (x) {
    const w = Mg(void 0, x),
      m = x.getAttribute('data-nodeid'),
      b = x.getAttribute('data-handleid'),
      P = x.classList.contains('connectable'),
      S = x.classList.contains('connectableend')
    if (!m || !w) return y
    const _ = {
      source: f ? m : r,
      sourceHandle: f ? b : i,
      target: f ? r : m,
      targetHandle: f ? i : b,
    }
    y.connection = _
    const T =
      P &&
      S &&
      (n === Mn.Strict ? (f && w === 'source') || (!f && w === 'target') : m !== r || b !== i)
    ;((y.isValid = T && c(_)), (y.toHandle = kg(m, w, b, u, n, !0)))
  }
  return y
}
const us = { onPointerDown: gI, isValid: Ng }
function mI({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const i = He(e)
  function o({
    translateExtent: s,
    width: l,
    height: c,
    zoomStep: u = 1,
    pannable: f = !0,
    zoomable: d = !0,
    inversePan: h = !1,
  }) {
    const g = (m) => {
      if (m.sourceEvent.type !== 'wheel' || !t) return
      const b = n(),
        P = m.sourceEvent.ctrlKey && br() ? 10 : 1,
        S =
          -m.sourceEvent.deltaY *
          (m.sourceEvent.deltaMode === 1 ? 0.05 : m.sourceEvent.deltaMode ? 1 : 0.002) *
          u,
        _ = b[2] * Math.pow(2, S * P)
      t.scaleTo(_)
    }
    let p = [0, 0]
    const x = (m) => {
        ;(m.sourceEvent.type === 'mousedown' || m.sourceEvent.type === 'touchstart') &&
          (p = [
            m.sourceEvent.clientX ?? m.sourceEvent.touches[0].clientX,
            m.sourceEvent.clientY ?? m.sourceEvent.touches[0].clientY,
          ])
      },
      y = (m) => {
        const b = n()
        if ((m.sourceEvent.type !== 'mousemove' && m.sourceEvent.type !== 'touchmove') || !t) return
        const P = [
            m.sourceEvent.clientX ?? m.sourceEvent.touches[0].clientX,
            m.sourceEvent.clientY ?? m.sourceEvent.touches[0].clientY,
          ],
          S = [P[0] - p[0], P[1] - p[1]]
        p = P
        const _ = r() * Math.max(b[2], Math.log(b[2])) * (h ? -1 : 1),
          M = { x: b[0] - S[0] * _, y: b[1] - S[1] * _ },
          T = [
            [0, 0],
            [l, c],
          ]
        t.setViewportConstrained({ x: M.x, y: M.y, zoom: b[2] }, T, s)
      },
      w = ag()
        .on('start', x)
        .on('zoom', f ? y : null)
        .on('zoom.wheel', d ? g : null)
    i.call(w, {})
  }
  function a() {
    i.on('zoom', null)
  }
  return { update: o, destroy: a, pointer: nt }
}
const Fo = (e) => ({ x: e.x, y: e.y, zoom: e.k }),
  ha = ({ x: e, y: t, zoom: n }) => Ro.translate(e, t).scale(n),
  mn = (e, t) => e.target.closest(`.${t}`),
  Dg = (e, t) => t === 2 && Array.isArray(e) && e.includes(2),
  yI = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2,
  pa = (e, t = 0, n = yI, r = () => {}) => {
    const i = typeof t == 'number' && t > 0
    return (i || r(), i ? e.transition().duration(t).ease(n).on('end', r) : e)
  },
  Ig = (e) => {
    const t = e.ctrlKey && br() ? 10 : 1
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 0.002) * t
  }
function xI({
  zoomPanValues: e,
  noWheelClassName: t,
  d3Selection: n,
  d3Zoom: r,
  panOnScrollMode: i,
  panOnScrollSpeed: o,
  zoomOnPinch: a,
  onPanZoomStart: s,
  onPanZoom: l,
  onPanZoomEnd: c,
}) {
  return (u) => {
    if (mn(u, t)) return (u.ctrlKey && u.preventDefault(), !1)
    ;(u.preventDefault(), u.stopImmediatePropagation())
    const f = n.property('__zoom').k || 1
    if (u.ctrlKey && a) {
      const x = nt(u),
        y = Ig(u),
        w = f * Math.pow(2, y)
      r.scaleTo(n, w, x, u)
      return
    }
    const d = u.deltaMode === 1 ? 20 : 1
    let h = i === en.Vertical ? 0 : u.deltaX * d,
      g = i === en.Horizontal ? 0 : u.deltaY * d
    ;(!br() && u.shiftKey && i !== en.Vertical && ((h = u.deltaY * d), (g = 0)),
      r.translateBy(n, -(h / f) * o, -(g / f) * o, { internal: !0 }))
    const p = Fo(n.property('__zoom'))
    ;(clearTimeout(e.panScrollTimeout),
      e.isPanScrolling
        ? (l?.(u, p),
          (e.panScrollTimeout = setTimeout(() => {
            ;(c?.(u, p), (e.isPanScrolling = !1))
          }, 150)))
        : ((e.isPanScrolling = !0), s?.(u, p)))
  }
}
function bI({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function (r, i) {
    const o = r.type === 'wheel',
      a = !t && o && !r.ctrlKey,
      s = mn(r, e)
    if ((r.ctrlKey && o && s && r.preventDefault(), a || s)) return null
    ;(r.preventDefault(), n.call(this, r, i))
  }
}
function wI({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    if (r.sourceEvent?.internal) return
    const i = Fo(r.transform)
    ;((e.mouseButton = r.sourceEvent?.button || 0),
      (e.isZoomingOrPanning = !0),
      (e.prevViewport = i),
      r.sourceEvent?.type === 'mousedown' && t(!0),
      n && n?.(r.sourceEvent, i))
  }
}
function PI({
  zoomPanValues: e,
  panOnDrag: t,
  onPaneContextMenu: n,
  onTransformChange: r,
  onPanZoom: i,
}) {
  return (o) => {
    ;((e.usedRightMouseButton = !!(n && Dg(t, e.mouseButton ?? 0))),
      o.sourceEvent?.sync || r([o.transform.x, o.transform.y, o.transform.k]),
      i && !o.sourceEvent?.internal && i?.(o.sourceEvent, Fo(o.transform)))
  }
}
function SI({
  zoomPanValues: e,
  panOnDrag: t,
  panOnScroll: n,
  onDraggingChange: r,
  onPanZoomEnd: i,
  onPaneContextMenu: o,
}) {
  return (a) => {
    if (
      !a.sourceEvent?.internal &&
      ((e.isZoomingOrPanning = !1),
      o &&
        Dg(t, e.mouseButton ?? 0) &&
        !e.usedRightMouseButton &&
        a.sourceEvent &&
        o(a.sourceEvent),
      (e.usedRightMouseButton = !1),
      r(!1),
      i)
    ) {
      const s = Fo(a.transform)
      ;((e.prevViewport = s),
        clearTimeout(e.timerId),
        (e.timerId = setTimeout(
          () => {
            i?.(a.sourceEvent, s)
          },
          n ? 150 : 0,
        )))
    }
  }
}
function EI({
  zoomActivationKeyPressed: e,
  zoomOnScroll: t,
  zoomOnPinch: n,
  panOnDrag: r,
  panOnScroll: i,
  zoomOnDoubleClick: o,
  userSelectionActive: a,
  noWheelClassName: s,
  noPanClassName: l,
  lib: c,
  connectionInProgress: u,
}) {
  return (f) => {
    const d = e || t,
      h = n && f.ctrlKey,
      g = f.type === 'wheel'
    if (
      f.button === 1 &&
      f.type === 'mousedown' &&
      (mn(f, `${c}-flow__node`) || mn(f, `${c}-flow__edge`))
    )
      return !0
    if (
      (!r && !d && !i && !o && !n) ||
      a ||
      (u && !g) ||
      (mn(f, s) && g) ||
      (mn(f, l) && (!g || (i && g && !e))) ||
      (!n && f.ctrlKey && g)
    )
      return !1
    if (!n && f.type === 'touchstart' && f.touches?.length > 1) return (f.preventDefault(), !1)
    if (
      (!d && !i && !h && g) ||
      (!r && (f.type === 'mousedown' || f.type === 'touchstart')) ||
      (Array.isArray(r) && !r.includes(f.button) && f.type === 'mousedown')
    )
      return !1
    const p = (Array.isArray(r) && r.includes(f.button)) || !f.button || f.button <= 1
    return (!f.ctrlKey || g) && p
  }
}
function _I({
  domNode: e,
  minZoom: t,
  maxZoom: n,
  paneClickDistance: r,
  translateExtent: i,
  viewport: o,
  onPanZoom: a,
  onPanZoomStart: s,
  onPanZoomEnd: l,
  onDraggingChange: c,
}) {
  const u = {
      isZoomingOrPanning: !1,
      usedRightMouseButton: !1,
      prevViewport: {},
      mouseButton: 0,
      timerId: void 0,
      panScrollTimeout: void 0,
      isPanScrolling: !1,
    },
    f = e.getBoundingClientRect(),
    d = ag()
      .clickDistance(!ot(r) || r < 0 ? 0 : r)
      .scaleExtent([t, n])
      .translateExtent(i),
    h = He(e).call(d)
  m(
    { x: o.x, y: o.y, zoom: Tn(o.zoom, t, n) },
    [
      [0, 0],
      [f.width, f.height],
    ],
    i,
  )
  const g = h.on('wheel.zoom'),
    p = h.on('dblclick.zoom')
  d.wheelDelta(Ig)
  function x(k, $) {
    return h
      ? new Promise((E) => {
          d?.interpolate($?.interpolate === 'linear' ? Pt : hi).transform(
            pa(h, $?.duration, $?.ease, () => E(!0)),
            k,
          )
        })
      : Promise.resolve(!1)
  }
  function y({
    noWheelClassName: k,
    noPanClassName: $,
    onPaneContextMenu: E,
    userSelectionActive: O,
    panOnScroll: A,
    panOnDrag: C,
    panOnScrollMode: N,
    panOnScrollSpeed: I,
    preventScrolling: H,
    zoomOnPinch: V,
    zoomOnScroll: B,
    zoomOnDoubleClick: Y,
    zoomActivationKeyPressed: K,
    lib: G,
    onTransformChange: re,
    connectionInProgress: q,
  }) {
    O && !u.isZoomingOrPanning && w()
    const j =
      A && !K && !O
        ? xI({
            zoomPanValues: u,
            noWheelClassName: k,
            d3Selection: h,
            d3Zoom: d,
            panOnScrollMode: N,
            panOnScrollSpeed: I,
            zoomOnPinch: V,
            onPanZoomStart: s,
            onPanZoom: a,
            onPanZoomEnd: l,
          })
        : bI({ noWheelClassName: k, preventScrolling: H, d3ZoomHandler: g })
    if ((h.on('wheel.zoom', j, { passive: !1 }), !O)) {
      const X = wI({ zoomPanValues: u, onDraggingChange: c, onPanZoomStart: s })
      d.on('start', X)
      const L = PI({
        zoomPanValues: u,
        panOnDrag: C,
        onPaneContextMenu: !!E,
        onPanZoom: a,
        onTransformChange: re,
      })
      d.on('zoom', L)
      const Q = SI({
        zoomPanValues: u,
        panOnDrag: C,
        panOnScroll: A,
        onPaneContextMenu: E,
        onPanZoomEnd: l,
        onDraggingChange: c,
      })
      d.on('end', Q)
    }
    const U = EI({
      zoomActivationKeyPressed: K,
      panOnDrag: C,
      zoomOnScroll: B,
      panOnScroll: A,
      zoomOnDoubleClick: Y,
      zoomOnPinch: V,
      userSelectionActive: O,
      noPanClassName: $,
      noWheelClassName: k,
      lib: G,
      connectionInProgress: q,
    })
    ;(d.filter(U), Y ? h.on('dblclick.zoom', p) : h.on('dblclick.zoom', null))
  }
  function w() {
    d.on('zoom', null)
  }
  async function m(k, $, E) {
    const O = ha(k),
      A = d?.constrain()(O, $, E)
    return (A && (await x(A)), new Promise((C) => C(A)))
  }
  async function b(k, $) {
    const E = ha(k)
    return (await x(E, $), new Promise((O) => O(E)))
  }
  function P(k) {
    if (h) {
      const $ = ha(k),
        E = h.property('__zoom')
      ;(E.k !== k.zoom || E.x !== k.x || E.y !== k.y) && d?.transform(h, $, null, { sync: !0 })
    }
  }
  function S() {
    const k = h ? og(h.node()) : { x: 0, y: 0, k: 1 }
    return { x: k.x, y: k.y, zoom: k.k }
  }
  function _(k, $) {
    return h
      ? new Promise((E) => {
          d?.interpolate($?.interpolate === 'linear' ? Pt : hi).scaleTo(
            pa(h, $?.duration, $?.ease, () => E(!0)),
            k,
          )
        })
      : Promise.resolve(!1)
  }
  function M(k, $) {
    return h
      ? new Promise((E) => {
          d?.interpolate($?.interpolate === 'linear' ? Pt : hi).scaleBy(
            pa(h, $?.duration, $?.ease, () => E(!0)),
            k,
          )
        })
      : Promise.resolve(!1)
  }
  function T(k) {
    d?.scaleExtent(k)
  }
  function F(k) {
    d?.translateExtent(k)
  }
  function D(k) {
    const $ = !ot(k) || k < 0 ? 0 : k
    d?.clickDistance($)
  }
  return {
    update: y,
    destroy: w,
    setViewport: b,
    setViewportConstrained: m,
    getViewport: S,
    scaleTo: _,
    scaleBy: M,
    setScaleExtent: T,
    setTranslateExtent: F,
    syncViewport: P,
    setClickDistance: D,
  }
}
var In
;(function (e) {
  ;((e.Line = 'line'), (e.Handle = 'handle'))
})(In || (In = {}))
function AI({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: i, affectsY: o }) {
  const a = e - t,
    s = n - r,
    l = [a > 0 ? 1 : a < 0 ? -1 : 0, s > 0 ? 1 : s < 0 ? -1 : 0]
  return (a && i && (l[0] = l[0] * -1), s && o && (l[1] = l[1] * -1), l)
}
function If(e) {
  const t = e.includes('right') || e.includes('left'),
    n = e.includes('bottom') || e.includes('top'),
    r = e.includes('left'),
    i = e.includes('top')
  return { isHorizontal: t, isVertical: n, affectsX: r, affectsY: i }
}
function jt(e, t) {
  return Math.max(0, t - e)
}
function $t(e, t) {
  return Math.max(0, e - t)
}
function li(e, t, n) {
  return Math.max(0, t - e, e - n)
}
function jf(e, t) {
  return e ? !t : t
}
function OI(e, t, n, r, i, o, a, s) {
  let { affectsX: l, affectsY: c } = t
  const { isHorizontal: u, isVertical: f } = t,
    d = u && f,
    { xSnapped: h, ySnapped: g } = n,
    { minWidth: p, maxWidth: x, minHeight: y, maxHeight: w } = r,
    { x: m, y: b, width: P, height: S, aspectRatio: _ } = e
  let M = Math.floor(u ? h - e.pointerX : 0),
    T = Math.floor(f ? g - e.pointerY : 0)
  const F = P + (l ? -M : M),
    D = S + (c ? -T : T),
    k = -o[0] * P,
    $ = -o[1] * S
  let E = li(F, p, x),
    O = li(D, y, w)
  if (a) {
    let N = 0,
      I = 0
    ;(l && M < 0 ? (N = jt(m + M + k, a[0][0])) : !l && M > 0 && (N = $t(m + F + k, a[1][0])),
      c && T < 0 ? (I = jt(b + T + $, a[0][1])) : !c && T > 0 && (I = $t(b + D + $, a[1][1])),
      (E = Math.max(E, N)),
      (O = Math.max(O, I)))
  }
  if (s) {
    let N = 0,
      I = 0
    ;(l && M > 0 ? (N = $t(m + M, s[0][0])) : !l && M < 0 && (N = jt(m + F, s[1][0])),
      c && T > 0 ? (I = $t(b + T, s[0][1])) : !c && T < 0 && (I = jt(b + D, s[1][1])),
      (E = Math.max(E, N)),
      (O = Math.max(O, I)))
  }
  if (i) {
    if (u) {
      const N = li(F / _, y, w) * _
      if (((E = Math.max(E, N)), a)) {
        let I = 0
        ;((!l && !c) || (l && !c && d)
          ? (I = $t(b + $ + F / _, a[1][1]) * _)
          : (I = jt(b + $ + (l ? M : -M) / _, a[0][1]) * _),
          (E = Math.max(E, I)))
      }
      if (s) {
        let I = 0
        ;((!l && !c) || (l && !c && d)
          ? (I = jt(b + F / _, s[1][1]) * _)
          : (I = $t(b + (l ? M : -M) / _, s[0][1]) * _),
          (E = Math.max(E, I)))
      }
    }
    if (f) {
      const N = li(D * _, p, x) / _
      if (((O = Math.max(O, N)), a)) {
        let I = 0
        ;((!l && !c) || (c && !l && d)
          ? (I = $t(m + D * _ + k, a[1][0]) / _)
          : (I = jt(m + (c ? T : -T) * _ + k, a[0][0]) / _),
          (O = Math.max(O, I)))
      }
      if (s) {
        let I = 0
        ;((!l && !c) || (c && !l && d)
          ? (I = jt(m + D * _, s[1][0]) / _)
          : (I = $t(m + (c ? T : -T) * _, s[0][0]) / _),
          (O = Math.max(O, I)))
      }
    }
  }
  ;((T = T + (T < 0 ? O : -O)),
    (M = M + (M < 0 ? E : -E)),
    i &&
      (d
        ? F > D * _
          ? (T = (jf(l, c) ? -M : M) / _)
          : (M = (jf(l, c) ? -T : T) * _)
        : u
          ? ((T = M / _), (c = l))
          : ((M = T * _), (l = c))))
  const A = l ? m + M : m,
    C = c ? b + T : b
  return {
    width: P + (l ? -M : M),
    height: S + (c ? -T : T),
    x: o[0] * M * (l ? -1 : 1) + A,
    y: o[1] * T * (c ? -1 : 1) + C,
  }
}
const jg = { width: 0, height: 0, x: 0, y: 0 },
  CI = { ...jg, pointerX: 0, pointerY: 0, aspectRatio: 1 }
function kI(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height],
  ]
}
function MI(e, t, n) {
  const r = t.position.x + e.position.x,
    i = t.position.y + e.position.y,
    o = e.measured.width ?? 0,
    a = e.measured.height ?? 0,
    s = n[0] * o,
    l = n[1] * a
  return [
    [r - s, i - l],
    [r + o - s, i + a - l],
  ]
}
function TI({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: i }) {
  const o = He(e)
  let a = {
    controlDirection: If('bottom-right'),
    boundaries: {
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_VALUE,
      maxHeight: Number.MAX_VALUE,
    },
    resizeDirection: void 0,
    keepAspectRatio: !1,
  }
  function s({
    controlPosition: c,
    boundaries: u,
    keepAspectRatio: f,
    resizeDirection: d,
    onResizeStart: h,
    onResize: g,
    onResizeEnd: p,
    shouldResize: x,
  }) {
    let y = { ...jg },
      w = { ...CI }
    a = { boundaries: u, resizeDirection: d, keepAspectRatio: f, controlDirection: If(c) }
    let m,
      b = null,
      P = [],
      S,
      _,
      M,
      T = !1
    const F = Zv()
      .on('start', (D) => {
        const {
          nodeLookup: k,
          transform: $,
          snapGrid: E,
          snapToGrid: O,
          nodeOrigin: A,
          paneDomNode: C,
        } = n()
        if (((m = k.get(t)), !m)) return
        b = C?.getBoundingClientRect() ?? null
        const { xSnapped: N, ySnapped: I } = ar(D.sourceEvent, {
          transform: $,
          snapGrid: E,
          snapToGrid: O,
          containerBounds: b,
        })
        ;((y = {
          width: m.measured.width ?? 0,
          height: m.measured.height ?? 0,
          x: m.position.x ?? 0,
          y: m.position.y ?? 0,
        }),
          (w = { ...y, pointerX: N, pointerY: I, aspectRatio: y.width / y.height }),
          (S = void 0),
          m.parentId &&
            (m.extent === 'parent' || m.expandParent) &&
            ((S = k.get(m.parentId)), (_ = S && m.extent === 'parent' ? kI(S) : void 0)),
          (P = []),
          (M = void 0))
        for (const [H, V] of k)
          if (
            V.parentId === t &&
            (P.push({ id: H, position: { ...V.position }, extent: V.extent }),
            V.extent === 'parent' || V.expandParent)
          ) {
            const B = MI(V, m, V.origin ?? A)
            M
              ? (M = [
                  [Math.min(B[0][0], M[0][0]), Math.min(B[0][1], M[0][1])],
                  [Math.max(B[1][0], M[1][0]), Math.max(B[1][1], M[1][1])],
                ])
              : (M = B)
          }
        h?.(D, { ...y })
      })
      .on('drag', (D) => {
        const { transform: k, snapGrid: $, snapToGrid: E, nodeOrigin: O } = n(),
          A = ar(D.sourceEvent, { transform: k, snapGrid: $, snapToGrid: E, containerBounds: b }),
          C = []
        if (!m) return
        const { x: N, y: I, width: H, height: V } = y,
          B = {},
          Y = m.origin ?? O,
          {
            width: K,
            height: G,
            x: re,
            y: q,
          } = OI(w, a.controlDirection, A, a.boundaries, a.keepAspectRatio, Y, _, M),
          W = K !== H,
          j = G !== V,
          U = re !== N && W,
          X = q !== I && j
        if (!U && !X && !W && !j) return
        if (
          (U || X || Y[0] === 1 || Y[1] === 1) &&
          ((B.x = U ? re : y.x), (B.y = X ? q : y.y), (y.x = B.x), (y.y = B.y), P.length > 0)
        ) {
          const ne = re - N,
            ae = q - I
          for (const ue of P)
            ((ue.position = {
              x: ue.position.x - ne + Y[0] * (K - H),
              y: ue.position.y - ae + Y[1] * (G - V),
            }),
              C.push(ue))
        }
        if (
          ((W || j) &&
            ((B.width =
              W && (!a.resizeDirection || a.resizeDirection === 'horizontal') ? K : y.width),
            (B.height =
              j && (!a.resizeDirection || a.resizeDirection === 'vertical') ? G : y.height),
            (y.width = B.width),
            (y.height = B.height)),
          S && m.expandParent)
        ) {
          const ne = Y[0] * (B.width ?? 0)
          B.x && B.x < ne && ((y.x = ne), (w.x = w.x - (B.x - ne)))
          const ae = Y[1] * (B.height ?? 0)
          B.y && B.y < ae && ((y.y = ae), (w.y = w.y - (B.y - ae)))
        }
        const L = AI({
            width: y.width,
            prevWidth: H,
            height: y.height,
            prevHeight: V,
            affectsX: a.controlDirection.affectsX,
            affectsY: a.controlDirection.affectsY,
          }),
          Q = { ...y, direction: L }
        x?.(D, Q) !== !1 && ((T = !0), g?.(D, Q), r(B, C))
      })
      .on('end', (D) => {
        T && (p?.(D, { ...y }), i?.({ ...y }), (T = !1))
      })
    o.call(F)
  }
  function l() {
    o.on('.drag', null)
  }
  return { update: s, destroy: l }
}
const Vo = v.createContext(null),
  NI = Vo.Provider,
  $g = ht.error001()
function ie(e, t) {
  const n = v.useContext(Vo)
  if (n === null) throw new Error($g)
  return Ty(n, e, t)
}
function fe() {
  const e = v.useContext(Vo)
  if (e === null) throw new Error($g)
  return v.useMemo(
    () => ({ getState: e.getState, setState: e.setState, subscribe: e.subscribe }),
    [e],
  )
}
const $f = { display: 'none' },
  DI = {
    position: 'absolute',
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: 'hidden',
    clip: 'rect(0px, 0px, 0px, 0px)',
    clipPath: 'inset(100%)',
  },
  Lg = 'react-flow__node-desc',
  zg = 'react-flow__edge-desc',
  II = 'react-flow__aria-live',
  jI = (e) => e.ariaLiveMessage,
  $I = (e) => e.ariaLabelConfig
function LI({ rfId: e }) {
  const t = ie(jI)
  return z.jsx('div', {
    id: `${II}-${e}`,
    'aria-live': 'assertive',
    'aria-atomic': 'true',
    style: DI,
    children: t,
  })
}
function zI({ rfId: e, disableKeyboardA11y: t }) {
  const n = ie($I)
  return z.jsxs(z.Fragment, {
    children: [
      z.jsx('div', {
        id: `${Lg}-${e}`,
        style: $f,
        children: t
          ? n['node.a11yDescription.default']
          : n['node.a11yDescription.keyboardDisabled'],
      }),
      z.jsx('div', { id: `${zg}-${e}`, style: $f, children: n['edge.a11yDescription.default'] }),
      !t && z.jsx(LI, { rfId: e }),
    ],
  })
}
const Wo = v.forwardRef(
  ({ position: e = 'top-left', children: t, className: n, style: r, ...i }, o) => {
    const a = `${e}`.split('-')
    return z.jsx('div', {
      className: ye(['react-flow__panel', n, ...a]),
      style: r,
      ref: o,
      ...i,
      children: t,
    })
  },
)
Wo.displayName = 'Panel'
function RI({ proOptions: e, position: t = 'bottom-right' }) {
  return e?.hideAttribution
    ? null
    : z.jsx(Wo, {
        position: t,
        className: 'react-flow__attribution',
        'data-message':
          'Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev',
        children: z.jsx('a', {
          href: 'https://reactflow.dev',
          target: '_blank',
          rel: 'noopener noreferrer',
          'aria-label': 'React Flow attribution',
          children: 'React Flow',
        }),
      })
}
const BI = (e) => {
    const t = [],
      n = []
    for (const [, r] of e.nodeLookup) r.selected && t.push(r.internals.userNode)
    for (const [, r] of e.edgeLookup) r.selected && n.push(r)
    return { selectedNodes: t, selectedEdges: n }
  },
  ui = (e) => e.id
function HI(e, t) {
  return (
    de(e.selectedNodes.map(ui), t.selectedNodes.map(ui)) &&
    de(e.selectedEdges.map(ui), t.selectedEdges.map(ui))
  )
}
function FI({ onSelectionChange: e }) {
  const t = fe(),
    { selectedNodes: n, selectedEdges: r } = ie(BI, HI)
  return (
    v.useEffect(() => {
      const i = { nodes: n, edges: r }
      ;(e?.(i), t.getState().onSelectionChangeHandlers.forEach((o) => o(i)))
    }, [n, r, e]),
    null
  )
}
const VI = (e) => !!e.onSelectionChangeHandlers
function WI({ onSelectionChange: e }) {
  const t = ie(VI)
  return e || t ? z.jsx(FI, { onSelectionChange: e }) : null
}
const Rg = [0, 0],
  KI = { x: 0, y: 0, zoom: 1 },
  YI = [
    'nodes',
    'edges',
    'defaultNodes',
    'defaultEdges',
    'onConnect',
    'onConnectStart',
    'onConnectEnd',
    'onClickConnectStart',
    'onClickConnectEnd',
    'nodesDraggable',
    'autoPanOnNodeFocus',
    'nodesConnectable',
    'nodesFocusable',
    'edgesFocusable',
    'edgesReconnectable',
    'elevateNodesOnSelect',
    'elevateEdgesOnSelect',
    'minZoom',
    'maxZoom',
    'nodeExtent',
    'onNodesChange',
    'onEdgesChange',
    'elementsSelectable',
    'connectionMode',
    'snapGrid',
    'snapToGrid',
    'translateExtent',
    'connectOnClick',
    'defaultEdgeOptions',
    'fitView',
    'fitViewOptions',
    'onNodesDelete',
    'onEdgesDelete',
    'onDelete',
    'onNodeDrag',
    'onNodeDragStart',
    'onNodeDragStop',
    'onSelectionDrag',
    'onSelectionDragStart',
    'onSelectionDragStop',
    'onMoveStart',
    'onMove',
    'onMoveEnd',
    'noPanClassName',
    'nodeOrigin',
    'autoPanOnConnect',
    'autoPanOnNodeDrag',
    'onError',
    'connectionRadius',
    'isValidConnection',
    'selectNodesOnDrag',
    'nodeDragThreshold',
    'connectionDragThreshold',
    'onBeforeDelete',
    'debug',
    'autoPanSpeed',
    'paneClickDistance',
    'ariaLabelConfig',
  ],
  Lf = [...YI, 'rfId'],
  UI = (e) => ({
    setNodes: e.setNodes,
    setEdges: e.setEdges,
    setMinZoom: e.setMinZoom,
    setMaxZoom: e.setMaxZoom,
    setTranslateExtent: e.setTranslateExtent,
    setNodeExtent: e.setNodeExtent,
    reset: e.reset,
    setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
    setPaneClickDistance: e.setPaneClickDistance,
  }),
  zf = {
    translateExtent: mr,
    nodeOrigin: Rg,
    minZoom: 0.5,
    maxZoom: 2,
    elementsSelectable: !0,
    noPanClassName: 'nopan',
    rfId: '1',
    paneClickDistance: 0,
  }
function XI(e) {
  const {
      setNodes: t,
      setEdges: n,
      setMinZoom: r,
      setMaxZoom: i,
      setTranslateExtent: o,
      setNodeExtent: a,
      reset: s,
      setDefaultNodesAndEdges: l,
      setPaneClickDistance: c,
    } = ie(UI, de),
    u = fe()
  v.useEffect(
    () => (
      l(e.defaultNodes, e.defaultEdges),
      () => {
        ;((f.current = zf), s())
      }
    ),
    [],
  )
  const f = v.useRef(zf)
  return (
    v.useEffect(
      () => {
        for (const d of Lf) {
          const h = e[d],
            g = f.current[d]
          h !== g &&
            (typeof e[d] > 'u' ||
              (d === 'nodes'
                ? t(h)
                : d === 'edges'
                  ? n(h)
                  : d === 'minZoom'
                    ? r(h)
                    : d === 'maxZoom'
                      ? i(h)
                      : d === 'translateExtent'
                        ? o(h)
                        : d === 'nodeExtent'
                          ? a(h)
                          : d === 'paneClickDistance'
                            ? c(h)
                            : d === 'ariaLabelConfig'
                              ? u.setState({ ariaLabelConfig: VD(h) })
                              : d === 'fitView'
                                ? u.setState({ fitViewQueued: h })
                                : d === 'fitViewOptions'
                                  ? u.setState({ fitViewOptions: h })
                                  : u.setState({ [d]: h })))
        }
        f.current = e
      },
      Lf.map((d) => e[d]),
    ),
    null
  )
}
function Rf() {
  return typeof window > 'u' || !window.matchMedia
    ? null
    : window.matchMedia('(prefers-color-scheme: dark)')
}
function GI(e) {
  const [t, n] = v.useState(e === 'system' ? null : e)
  return (
    v.useEffect(() => {
      if (e !== 'system') {
        n(e)
        return
      }
      const r = Rf(),
        i = () => n(r?.matches ? 'dark' : 'light')
      return (
        i(),
        r?.addEventListener('change', i),
        () => {
          r?.removeEventListener('change', i)
        }
      )
    }, [e]),
    t !== null ? t : Rf()?.matches ? 'dark' : 'light'
  )
}
const Bf = typeof document < 'u' ? document : null
function Pr(e = null, t = { target: Bf, actInsideInputWithModifier: !0 }) {
  const [n, r] = v.useState(!1),
    i = v.useRef(!1),
    o = v.useRef(new Set([])),
    [a, s] = v.useMemo(() => {
      if (e !== null) {
        const c = (Array.isArray(e) ? e : [e])
            .filter((f) => typeof f == 'string')
            .map((f) =>
              f
                .replace(
                  '+',
                  `
`,
                )
                .replace(
                  `

`,
                  `
+`,
                ).split(`
`),
            ),
          u = c.reduce((f, d) => f.concat(...d), [])
        return [c, u]
      }
      return [[], []]
    }, [e])
  return (
    v.useEffect(() => {
      const l = t?.target ?? Bf,
        c = t?.actInsideInputWithModifier ?? !0
      if (e !== null) {
        const u = (h) => {
            if (
              ((i.current = h.ctrlKey || h.metaKey || h.shiftKey || h.altKey),
              (!i.current || (i.current && !c)) && xg(h))
            )
              return !1
            const p = Ff(h.code, s)
            if ((o.current.add(h[p]), Hf(a, o.current, !1))) {
              const x = h.composedPath?.()?.[0] || h.target,
                y = x?.nodeName === 'BUTTON' || x?.nodeName === 'A'
              ;(t.preventDefault !== !1 && (i.current || !y) && h.preventDefault(), r(!0))
            }
          },
          f = (h) => {
            const g = Ff(h.code, s)
            ;(Hf(a, o.current, !0) ? (r(!1), o.current.clear()) : o.current.delete(h[g]),
              h.key === 'Meta' && o.current.clear(),
              (i.current = !1))
          },
          d = () => {
            ;(o.current.clear(), r(!1))
          }
        return (
          l?.addEventListener('keydown', u),
          l?.addEventListener('keyup', f),
          window.addEventListener('blur', d),
          window.addEventListener('contextmenu', d),
          () => {
            ;(l?.removeEventListener('keydown', u),
              l?.removeEventListener('keyup', f),
              window.removeEventListener('blur', d),
              window.removeEventListener('contextmenu', d))
          }
        )
      }
    }, [e, r]),
    n
  )
}
function Hf(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((i) => t.has(i)))
}
function Ff(e, t) {
  return t.includes(e) ? 'code' : 'key'
}
const qI = () => {
  const e = fe()
  return v.useMemo(
    () => ({
      zoomIn: (t) => {
        const { panZoom: n } = e.getState()
        return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1)
      },
      zoomOut: (t) => {
        const { panZoom: n } = e.getState()
        return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1)
      },
      zoomTo: (t, n) => {
        const { panZoom: r } = e.getState()
        return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1)
      },
      getZoom: () => e.getState().transform[2],
      setViewport: async (t, n) => {
        const {
          transform: [r, i, o],
          panZoom: a,
        } = e.getState()
        return a
          ? (await a.setViewport({ x: t.x ?? r, y: t.y ?? i, zoom: t.zoom ?? o }, n),
            Promise.resolve(!0))
          : Promise.resolve(!1)
      },
      getViewport: () => {
        const [t, n, r] = e.getState().transform
        return { x: t, y: n, zoom: r }
      },
      setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
      fitBounds: async (t, n) => {
        const { width: r, height: i, minZoom: o, maxZoom: a, panZoom: s } = e.getState(),
          l = jc(t, r, i, o, a, n?.padding ?? 0.1)
        return s
          ? (await s.setViewport(l, {
              duration: n?.duration,
              ease: n?.ease,
              interpolate: n?.interpolate,
            }),
            Promise.resolve(!0))
          : Promise.resolve(!1)
      },
      screenToFlowPosition: (t, n = {}) => {
        const { transform: r, snapGrid: i, snapToGrid: o, domNode: a } = e.getState()
        if (!a) return t
        const { x: s, y: l } = a.getBoundingClientRect(),
          c = { x: t.x - s, y: t.y - l },
          u = n.snapGrid ?? i,
          f = n.snapToGrid ?? o
        return Fr(c, r, f, u)
      },
      flowToScreenPosition: (t) => {
        const { transform: n, domNode: r } = e.getState()
        if (!r) return t
        const { x: i, y: o } = r.getBoundingClientRect(),
          a = io(t, n)
        return { x: a.x + i, y: a.y + o }
      },
    }),
    [],
  )
}
function Bg(e, t) {
  const n = [],
    r = new Map(),
    i = []
  for (const o of e)
    if (o.type === 'add') {
      i.push(o)
      continue
    } else if (o.type === 'remove' || o.type === 'replace') r.set(o.id, [o])
    else {
      const a = r.get(o.id)
      a ? a.push(o) : r.set(o.id, [o])
    }
  for (const o of t) {
    const a = r.get(o.id)
    if (!a) {
      n.push(o)
      continue
    }
    if (a[0].type === 'remove') continue
    if (a[0].type === 'replace') {
      n.push({ ...a[0].item })
      continue
    }
    const s = { ...o }
    for (const l of a) ZI(l, s)
    n.push(s)
  }
  return (
    i.length &&
      i.forEach((o) => {
        o.index !== void 0 ? n.splice(o.index, 0, { ...o.item }) : n.push({ ...o.item })
      }),
    n
  )
}
function ZI(e, t) {
  switch (e.type) {
    case 'select': {
      t.selected = e.selected
      break
    }
    case 'position': {
      ;(typeof e.position < 'u' && (t.position = e.position),
        typeof e.dragging < 'u' && (t.dragging = e.dragging))
      break
    }
    case 'dimensions': {
      ;(typeof e.dimensions < 'u' &&
        ((t.measured ??= {}),
        (t.measured.width = e.dimensions.width),
        (t.measured.height = e.dimensions.height),
        e.setAttributes &&
          ((e.setAttributes === !0 || e.setAttributes === 'width') &&
            (t.width = e.dimensions.width),
          (e.setAttributes === !0 || e.setAttributes === 'height') &&
            (t.height = e.dimensions.height))),
        typeof e.resizing == 'boolean' && (t.resizing = e.resizing))
      break
    }
  }
}
function Hg(e, t) {
  return Bg(e, t)
}
function Fg(e, t) {
  return Bg(e, t)
}
function Gt(e, t) {
  return { id: e, type: 'select', selected: t }
}
function yn(e, t = new Set(), n = !1) {
  const r = []
  for (const [i, o] of e) {
    const a = t.has(i)
    !(o.selected === void 0 && !a) &&
      o.selected !== a &&
      (n && (o.selected = a), r.push(Gt(o.id, a)))
  }
  return r
}
function Vf({ items: e = [], lookup: t }) {
  const n = [],
    r = new Map(e.map((i) => [i.id, i]))
  for (const [i, o] of e.entries()) {
    const a = t.get(o.id),
      s = a?.internals?.userNode ?? a
    ;(s !== void 0 && s !== o && n.push({ id: o.id, item: o, type: 'replace' }),
      s === void 0 && n.push({ item: o, type: 'add', index: i }))
  }
  for (const [i] of t) r.get(i) === void 0 && n.push({ id: i, type: 'remove' })
  return n
}
function Wf(e) {
  return { id: e.id, type: 'remove' }
}
const Kf = (e) => DD(e),
  QI = (e) => fg(e)
function Vg(e) {
  return v.forwardRef(e)
}
const JI = typeof window < 'u' ? v.useLayoutEffect : v.useEffect
function Yf(e) {
  const [t, n] = v.useState(BigInt(0)),
    [r] = v.useState(() => e2(() => n((i) => i + BigInt(1))))
  return (
    JI(() => {
      const i = r.get()
      i.length && (e(i), r.reset())
    }, [t]),
    r
  )
}
function e2(e) {
  let t = []
  return {
    get: () => t,
    reset: () => {
      t = []
    },
    push: (n) => {
      ;(t.push(n), e())
    },
  }
}
const Wg = v.createContext(null)
function t2({ children: e }) {
  const t = fe(),
    n = v.useCallback((s) => {
      const {
        nodes: l = [],
        setNodes: c,
        hasDefaultNodes: u,
        onNodesChange: f,
        nodeLookup: d,
        fitViewQueued: h,
      } = t.getState()
      let g = l
      for (const x of s) g = typeof x == 'function' ? x(g) : x
      const p = Vf({ items: g, lookup: d })
      ;(u && c(g),
        p.length > 0
          ? f?.(p)
          : h &&
            window.requestAnimationFrame(() => {
              const { fitViewQueued: x, nodes: y, setNodes: w } = t.getState()
              x && w(y)
            }))
    }, []),
    r = Yf(n),
    i = v.useCallback((s) => {
      const {
        edges: l = [],
        setEdges: c,
        hasDefaultEdges: u,
        onEdgesChange: f,
        edgeLookup: d,
      } = t.getState()
      let h = l
      for (const g of s) h = typeof g == 'function' ? g(h) : g
      u ? c(h) : f && f(Vf({ items: h, lookup: d }))
    }, []),
    o = Yf(i),
    a = v.useMemo(() => ({ nodeQueue: r, edgeQueue: o }), [])
  return z.jsx(Wg.Provider, { value: a, children: e })
}
function n2() {
  const e = v.useContext(Wg)
  if (!e) throw new Error('useBatchContext must be used within a BatchProvider')
  return e
}
const r2 = (e) => !!e.panZoom
function Hc() {
  const e = qI(),
    t = fe(),
    n = n2(),
    r = ie(r2),
    i = v.useMemo(() => {
      const o = (f) => t.getState().nodeLookup.get(f),
        a = (f) => {
          n.nodeQueue.push(f)
        },
        s = (f) => {
          n.edgeQueue.push(f)
        },
        l = (f) => {
          const { nodeLookup: d, nodeOrigin: h } = t.getState(),
            g = Kf(f) ? f : d.get(f.id),
            p = g.parentId ? mg(g.position, g.measured, g.parentId, d, h) : g.position,
            x = {
              ...g,
              position: p,
              width: g.measured?.width ?? g.width,
              height: g.measured?.height ?? g.height,
            }
          return Nn(x)
        },
        c = (f, d, h = { replace: !1 }) => {
          a((g) =>
            g.map((p) => {
              if (p.id === f) {
                const x = typeof d == 'function' ? d(p) : d
                return h.replace && Kf(x) ? x : { ...p, ...x }
              }
              return p
            }),
          )
        },
        u = (f, d, h = { replace: !1 }) => {
          s((g) =>
            g.map((p) => {
              if (p.id === f) {
                const x = typeof d == 'function' ? d(p) : d
                return h.replace && QI(x) ? x : { ...p, ...x }
              }
              return p
            }),
          )
        }
      return {
        getNodes: () => t.getState().nodes.map((f) => ({ ...f })),
        getNode: (f) => o(f)?.internals.userNode,
        getInternalNode: o,
        getEdges: () => {
          const { edges: f = [] } = t.getState()
          return f.map((d) => ({ ...d }))
        },
        getEdge: (f) => t.getState().edgeLookup.get(f),
        setNodes: a,
        setEdges: s,
        addNodes: (f) => {
          const d = Array.isArray(f) ? f : [f]
          n.nodeQueue.push((h) => [...h, ...d])
        },
        addEdges: (f) => {
          const d = Array.isArray(f) ? f : [f]
          n.edgeQueue.push((h) => [...h, ...d])
        },
        toObject: () => {
          const { nodes: f = [], edges: d = [], transform: h } = t.getState(),
            [g, p, x] = h
          return {
            nodes: f.map((y) => ({ ...y })),
            edges: d.map((y) => ({ ...y })),
            viewport: { x: g, y: p, zoom: x },
          }
        },
        deleteElements: async ({ nodes: f = [], edges: d = [] }) => {
          const {
              nodes: h,
              edges: g,
              onNodesDelete: p,
              onEdgesDelete: x,
              triggerNodeChanges: y,
              triggerEdgeChanges: w,
              onDelete: m,
              onBeforeDelete: b,
            } = t.getState(),
            { nodes: P, edges: S } = await zD({
              nodesToRemove: f,
              edgesToRemove: d,
              nodes: h,
              edges: g,
              onBeforeDelete: b,
            }),
            _ = S.length > 0,
            M = P.length > 0
          if (_) {
            const T = S.map(Wf)
            ;(x?.(S), w(T))
          }
          if (M) {
            const T = P.map(Wf)
            ;(p?.(P), y(T))
          }
          return ((M || _) && m?.({ nodes: P, edges: S }), { deletedNodes: P, deletedEdges: S })
        },
        getIntersectingNodes: (f, d = !0, h) => {
          const g = Sf(f),
            p = g ? f : l(f),
            x = h !== void 0
          return p
            ? (h || t.getState().nodes).filter((y) => {
                const w = t.getState().nodeLookup.get(y.id)
                if (w && !g && (y.id === f.id || !w.internals.positionAbsolute)) return !1
                const m = Nn(x ? y : w),
                  b = xr(m, p)
                return (d && b > 0) || b >= m.width * m.height || b >= p.width * p.height
              })
            : []
        },
        isNodeIntersecting: (f, d, h = !0) => {
          const p = Sf(f) ? f : l(f)
          if (!p) return !1
          const x = xr(p, d)
          return (h && x > 0) || x >= d.width * d.height || x >= p.width * p.height
        },
        updateNode: c,
        updateNodeData: (f, d, h = { replace: !1 }) => {
          c(
            f,
            (g) => {
              const p = typeof d == 'function' ? d(g) : d
              return h.replace ? { ...g, data: p } : { ...g, data: { ...g.data, ...p } }
            },
            h,
          )
        },
        updateEdge: u,
        updateEdgeData: (f, d, h = { replace: !1 }) => {
          u(
            f,
            (g) => {
              const p = typeof d == 'function' ? d(g) : d
              return h.replace ? { ...g, data: p } : { ...g, data: { ...g.data, ...p } }
            },
            h,
          )
        },
        getNodesBounds: (f) => {
          const { nodeLookup: d, nodeOrigin: h } = t.getState()
          return ID(f, { nodeLookup: d, nodeOrigin: h })
        },
        getHandleConnections: ({ type: f, id: d, nodeId: h }) =>
          Array.from(
            t
              .getState()
              .connectionLookup.get(`${h}-${f}${d ? `-${d}` : ''}`)
              ?.values() ?? [],
          ),
        getNodeConnections: ({ type: f, handleId: d, nodeId: h }) =>
          Array.from(
            t
              .getState()
              .connectionLookup.get(`${h}${f ? (d ? `-${f}-${d}` : `-${f}`) : ''}`)
              ?.values() ?? [],
          ),
        fitView: async (f) => {
          const d = t.getState().fitViewResolver ?? FD()
          return (
            t.setState({ fitViewQueued: !0, fitViewOptions: f, fitViewResolver: d }),
            n.nodeQueue.push((h) => [...h]),
            d.promise
          )
        },
      }
    }, [])
  return v.useMemo(() => ({ ...i, ...e, viewportInitialized: r }), [r])
}
const Uf = (e) => e.selected,
  i2 = typeof window < 'u' ? window : void 0
function o2({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = fe(),
    { deleteElements: r } = Hc(),
    i = Pr(e, { actInsideInputWithModifier: !1 }),
    o = Pr(t, { target: i2 })
  ;(v.useEffect(() => {
    if (i) {
      const { edges: a, nodes: s } = n.getState()
      ;(r({ nodes: s.filter(Uf), edges: a.filter(Uf) }), n.setState({ nodesSelectionActive: !1 }))
    }
  }, [i]),
    v.useEffect(() => {
      n.setState({ multiSelectionActive: o })
    }, [o]))
}
function a2(e) {
  const t = fe()
  v.useEffect(() => {
    const n = () => {
      if (!e.current || !(e.current.checkVisibility?.() ?? !0)) return !1
      const r = $c(e.current)
      ;((r.height === 0 || r.width === 0) && t.getState().onError?.('004', ht.error004()),
        t.setState({ width: r.width || 500, height: r.height || 500 }))
    }
    if (e.current) {
      ;(n(), window.addEventListener('resize', n))
      const r = new ResizeObserver(() => n())
      return (
        r.observe(e.current),
        () => {
          ;(window.removeEventListener('resize', n), r && e.current && r.unobserve(e.current))
        }
      )
    }
  }, [])
}
const Ko = { position: 'absolute', width: '100%', height: '100%', top: 0, left: 0 },
  s2 = (e) => ({
    userSelectionActive: e.userSelectionActive,
    lib: e.lib,
    connectionInProgress: e.connection.inProgress,
  })
function c2({
  onPaneContextMenu: e,
  zoomOnScroll: t = !0,
  zoomOnPinch: n = !0,
  panOnScroll: r = !1,
  panOnScrollSpeed: i = 0.5,
  panOnScrollMode: o = en.Free,
  zoomOnDoubleClick: a = !0,
  panOnDrag: s = !0,
  defaultViewport: l,
  translateExtent: c,
  minZoom: u,
  maxZoom: f,
  zoomActivationKeyCode: d,
  preventScrolling: h = !0,
  children: g,
  noWheelClassName: p,
  noPanClassName: x,
  onViewportChange: y,
  isControlledViewport: w,
  paneClickDistance: m,
}) {
  const b = fe(),
    P = v.useRef(null),
    { userSelectionActive: S, lib: _, connectionInProgress: M } = ie(s2, de),
    T = Pr(d),
    F = v.useRef()
  a2(P)
  const D = v.useCallback(
    (k) => {
      ;(y?.({ x: k[0], y: k[1], zoom: k[2] }), w || b.setState({ transform: k }))
    },
    [y, w],
  )
  return (
    v.useEffect(() => {
      if (P.current) {
        F.current = _I({
          domNode: P.current,
          minZoom: u,
          maxZoom: f,
          translateExtent: c,
          viewport: l,
          paneClickDistance: m,
          onDraggingChange: (O) => b.setState({ paneDragging: O }),
          onPanZoomStart: (O, A) => {
            const { onViewportChangeStart: C, onMoveStart: N } = b.getState()
            ;(N?.(O, A), C?.(A))
          },
          onPanZoom: (O, A) => {
            const { onViewportChange: C, onMove: N } = b.getState()
            ;(N?.(O, A), C?.(A))
          },
          onPanZoomEnd: (O, A) => {
            const { onViewportChangeEnd: C, onMoveEnd: N } = b.getState()
            ;(N?.(O, A), C?.(A))
          },
        })
        const { x: k, y: $, zoom: E } = F.current.getViewport()
        return (
          b.setState({
            panZoom: F.current,
            transform: [k, $, E],
            domNode: P.current.closest('.react-flow'),
          }),
          () => {
            F.current?.destroy()
          }
        )
      }
    }, []),
    v.useEffect(() => {
      F.current?.update({
        onPaneContextMenu: e,
        zoomOnScroll: t,
        zoomOnPinch: n,
        panOnScroll: r,
        panOnScrollSpeed: i,
        panOnScrollMode: o,
        zoomOnDoubleClick: a,
        panOnDrag: s,
        zoomActivationKeyPressed: T,
        preventScrolling: h,
        noPanClassName: x,
        userSelectionActive: S,
        noWheelClassName: p,
        lib: _,
        onTransformChange: D,
        connectionInProgress: M,
      })
    }, [e, t, n, r, i, o, a, s, T, h, x, S, p, _, D, M]),
    z.jsx('div', { className: 'react-flow__renderer', ref: P, style: Ko, children: g })
  )
}
const l2 = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect,
})
function u2() {
  const { userSelectionActive: e, userSelectionRect: t } = ie(l2, de)
  return e && t
    ? z.jsx('div', {
        className: 'react-flow__selection react-flow__container',
        style: { width: t.width, height: t.height, transform: `translate(${t.x}px, ${t.y}px)` },
      })
    : null
}
const va = (e, t) => (n) => {
    n.target === t.current && e?.(n)
  },
  f2 = (e) => ({
    userSelectionActive: e.userSelectionActive,
    elementsSelectable: e.elementsSelectable,
    connectionInProgress: e.connection.inProgress,
    dragging: e.paneDragging,
  })
function d2({
  isSelecting: e,
  selectionKeyPressed: t,
  selectionMode: n = yr.Full,
  panOnDrag: r,
  selectionOnDrag: i,
  onSelectionStart: o,
  onSelectionEnd: a,
  onPaneClick: s,
  onPaneContextMenu: l,
  onPaneScroll: c,
  onPaneMouseEnter: u,
  onPaneMouseMove: f,
  onPaneMouseLeave: d,
  children: h,
}) {
  const g = fe(),
    {
      userSelectionActive: p,
      elementsSelectable: x,
      dragging: y,
      connectionInProgress: w,
    } = ie(f2, de),
    m = x && (e || p),
    b = v.useRef(null),
    P = v.useRef(),
    S = v.useRef(new Set()),
    _ = v.useRef(new Set()),
    M = v.useRef(!1),
    T = v.useRef(!1),
    F = (N) => {
      if (M.current || w) {
        M.current = !1
        return
      }
      ;(s?.(N), g.getState().resetSelectedElements(), g.setState({ nodesSelectionActive: !1 }))
    },
    D = (N) => {
      if (Array.isArray(r) && r?.includes(2)) {
        N.preventDefault()
        return
      }
      l?.(N)
    },
    k = c ? (N) => c(N) : void 0,
    $ = (N) => {
      ;((i && b.current === N.target) || !i || t) && N.stopPropagation()
    },
    E = (N) => {
      const { resetSelectedElements: I, domNode: H } = g.getState()
      P.current = H?.getBoundingClientRect()
      const V = N.target !== b.current && !!N.target.closest('.nokey'),
        B = (i && b.current === N.target) || !i || t
      if (!x || !e || N.button !== 0 || !P.current || V || !B || !N.isPrimary) return
      ;(N.stopPropagation(),
        N.preventDefault(),
        N.target?.setPointerCapture?.(N.pointerId),
        (T.current = !0),
        (M.current = !1))
      const { x: Y, y: K } = at(N.nativeEvent, P.current)
      ;(I(),
        g.setState({
          userSelectionRect: { width: 0, height: 0, startX: Y, startY: K, x: Y, y: K },
        }),
        o?.(N))
    },
    O = (N) => {
      const {
        userSelectionRect: I,
        transform: H,
        nodeLookup: V,
        edgeLookup: B,
        connectionLookup: Y,
        triggerNodeChanges: K,
        triggerEdgeChanges: G,
        defaultEdgeOptions: re,
      } = g.getState()
      if (!P.current || !I) return
      M.current = !0
      const { x: q, y: W } = at(N.nativeEvent, P.current),
        { startX: j, startY: U } = I,
        X = {
          startX: j,
          startY: U,
          x: q < j ? q : j,
          y: W < U ? W : U,
          width: Math.abs(q - j),
          height: Math.abs(W - U),
        },
        L = S.current,
        Q = _.current
      ;((S.current = new Set(Ic(V, X, H, n === yr.Partial, !0).map((ne) => ne.id))),
        (_.current = new Set()))
      const Z = re?.selectable ?? !0
      for (const ne of S.current) {
        const ae = Y.get(ne)
        if (ae)
          for (const { edgeId: ue } of ae.values()) {
            const Ye = B.get(ue)
            Ye && (Ye.selectable ?? Z) && _.current.add(ue)
          }
      }
      if (!Ef(L, S.current)) {
        const ne = yn(V, S.current, !0)
        K(ne)
      }
      if (!Ef(Q, _.current)) {
        const ne = yn(B, _.current)
        G(ne)
      }
      g.setState({ userSelectionRect: X, userSelectionActive: !0, nodesSelectionActive: !1 })
    },
    A = (N) => {
      if (N.button !== 0 || !T.current) return
      N.target?.releasePointerCapture?.(N.pointerId)
      const { userSelectionRect: I } = g.getState()
      ;(!p && I && N.target === b.current && F?.(N),
        g.setState({
          userSelectionActive: !1,
          userSelectionRect: null,
          nodesSelectionActive: S.current.size > 0,
        }),
        a?.(N),
        (t || i) && (M.current = !1),
        (T.current = !1))
    },
    C = r === !0 || (Array.isArray(r) && r.includes(0))
  return z.jsxs('div', {
    className: ye(['react-flow__pane', { draggable: C, dragging: y, selection: e }]),
    onClick: m ? void 0 : va(F, b),
    onContextMenu: va(D, b),
    onWheel: va(k, b),
    onPointerEnter: m ? void 0 : u,
    onPointerMove: m ? O : f,
    onPointerUp: m ? A : void 0,
    onPointerDownCapture: m ? E : void 0,
    onClickCapture: m ? $ : void 0,
    onPointerLeave: d,
    ref: b,
    style: Ko,
    children: [h, z.jsx(u2, {})],
  })
}
function fs({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const {
      addSelectedNodes: i,
      unselectNodesAndEdges: o,
      multiSelectionActive: a,
      nodeLookup: s,
      onError: l,
    } = t.getState(),
    c = s.get(e)
  if (!c) {
    l?.('012', ht.error012(e))
    return
  }
  ;(t.setState({ nodesSelectionActive: !1 }),
    c.selected
      ? (n || (c.selected && a)) &&
        (o({ nodes: [c], edges: [] }), requestAnimationFrame(() => r?.current?.blur()))
      : i([e]))
}
function Kg({
  nodeRef: e,
  disabled: t = !1,
  noDragClassName: n,
  handleSelector: r,
  nodeId: i,
  isSelectable: o,
  nodeClickDistance: a,
}) {
  const s = fe(),
    [l, c] = v.useState(!1),
    u = v.useRef()
  return (
    v.useEffect(() => {
      u.current = fI({
        getStoreItems: () => s.getState(),
        onNodeMouseDown: (f) => {
          fs({ id: f, store: s, nodeRef: e })
        },
        onDragStart: () => {
          c(!0)
        },
        onDragStop: () => {
          c(!1)
        },
      })
    }, []),
    v.useEffect(() => {
      if (t) u.current?.destroy()
      else if (e.current)
        return (
          u.current?.update({
            noDragClassName: n,
            handleSelector: r,
            domNode: e.current,
            isSelectable: o,
            nodeId: i,
            nodeClickDistance: a,
          }),
          () => {
            u.current?.destroy()
          }
        )
    }, [n, r, t, o, e, i]),
    l
  )
}
const h2 = (e) => (t) => t.selected && (t.draggable || (e && typeof t.draggable > 'u'))
function Yg() {
  const e = fe()
  return v.useCallback((n) => {
    const {
        nodeExtent: r,
        snapToGrid: i,
        snapGrid: o,
        nodesDraggable: a,
        onError: s,
        updateNodePositions: l,
        nodeLookup: c,
        nodeOrigin: u,
      } = e.getState(),
      f = new Map(),
      d = h2(a),
      h = i ? o[0] : 5,
      g = i ? o[1] : 5,
      p = n.direction.x * h * n.factor,
      x = n.direction.y * g * n.factor
    for (const [, y] of c) {
      if (!d(y)) continue
      let w = { x: y.internals.positionAbsolute.x + p, y: y.internals.positionAbsolute.y + x }
      i && (w = Hr(w, o))
      const { position: m, positionAbsolute: b } = dg({
        nodeId: y.id,
        nextPosition: w,
        nodeLookup: c,
        nodeExtent: r,
        nodeOrigin: u,
        onError: s,
      })
      ;((y.position = m), (y.internals.positionAbsolute = b), f.set(y.id, y))
    }
    l(f)
  }, [])
}
const Fc = v.createContext(null),
  p2 = Fc.Provider
Fc.Consumer
const Ug = () => v.useContext(Fc),
  v2 = (e) => ({
    connectOnClick: e.connectOnClick,
    noPanClassName: e.noPanClassName,
    rfId: e.rfId,
  }),
  g2 = (e, t, n) => (r) => {
    const { connectionClickStartHandle: i, connectionMode: o, connection: a } = r,
      { fromHandle: s, toHandle: l, isValid: c } = a,
      u = l?.nodeId === e && l?.id === t && l?.type === n
    return {
      connectingFrom: s?.nodeId === e && s?.id === t && s?.type === n,
      connectingTo: u,
      clickConnecting: i?.nodeId === e && i?.id === t && i?.type === n,
      isPossibleEndHandle: o === Mn.Strict ? s?.type !== n : e !== s?.nodeId || t !== s?.id,
      connectionInProcess: !!s,
      clickConnectionInProcess: !!i,
      valid: u && c,
    }
  }
function m2(
  {
    type: e = 'source',
    position: t = ee.Top,
    isValidConnection: n,
    isConnectable: r = !0,
    isConnectableStart: i = !0,
    isConnectableEnd: o = !0,
    id: a,
    onConnect: s,
    children: l,
    className: c,
    onMouseDown: u,
    onTouchStart: f,
    ...d
  },
  h,
) {
  const g = a || null,
    p = e === 'target',
    x = fe(),
    y = Ug(),
    { connectOnClick: w, noPanClassName: m, rfId: b } = ie(v2, de),
    {
      connectingFrom: P,
      connectingTo: S,
      clickConnecting: _,
      isPossibleEndHandle: M,
      connectionInProcess: T,
      clickConnectionInProcess: F,
      valid: D,
    } = ie(g2(y, g, e), de)
  y || x.getState().onError?.('010', ht.error010())
  const k = (O) => {
      const { defaultEdgeOptions: A, onConnect: C, hasDefaultEdges: N } = x.getState(),
        I = { ...A, ...O }
      if (N) {
        const { edges: H, setEdges: V } = x.getState()
        V(GD(I, H))
      }
      ;(C?.(I), s?.(I))
    },
    $ = (O) => {
      if (!y) return
      const A = bg(O.nativeEvent)
      if (i && ((A && O.button === 0) || !A)) {
        const C = x.getState()
        us.onPointerDown(O.nativeEvent, {
          handleDomNode: O.currentTarget,
          autoPanOnConnect: C.autoPanOnConnect,
          connectionMode: C.connectionMode,
          connectionRadius: C.connectionRadius,
          domNode: C.domNode,
          nodeLookup: C.nodeLookup,
          lib: C.lib,
          isTarget: p,
          handleId: g,
          nodeId: y,
          flowId: C.rfId,
          panBy: C.panBy,
          cancelConnection: C.cancelConnection,
          onConnectStart: C.onConnectStart,
          onConnectEnd: C.onConnectEnd,
          updateConnection: C.updateConnection,
          onConnect: k,
          isValidConnection: n || C.isValidConnection,
          getTransform: () => x.getState().transform,
          getFromHandle: () => x.getState().connection.fromHandle,
          autoPanSpeed: C.autoPanSpeed,
          dragThreshold: C.connectionDragThreshold,
        })
      }
      A ? u?.(O) : f?.(O)
    },
    E = (O) => {
      const {
        onClickConnectStart: A,
        onClickConnectEnd: C,
        connectionClickStartHandle: N,
        connectionMode: I,
        isValidConnection: H,
        lib: V,
        rfId: B,
        nodeLookup: Y,
        connection: K,
      } = x.getState()
      if (!y || (!N && !i)) return
      if (!N) {
        ;(A?.(O.nativeEvent, { nodeId: y, handleId: g, handleType: e }),
          x.setState({ connectionClickStartHandle: { nodeId: y, type: e, id: g } }))
        return
      }
      const G = yg(O.target),
        re = n || H,
        { connection: q, isValid: W } = us.isValid(O.nativeEvent, {
          handle: { nodeId: y, id: g, type: e },
          connectionMode: I,
          fromNodeId: N.nodeId,
          fromHandleId: N.id || null,
          fromType: N.type,
          isValidConnection: re,
          flowId: B,
          doc: G,
          lib: V,
          nodeLookup: Y,
        })
      W && q && k(q)
      const j = structuredClone(K)
      ;(delete j.inProgress,
        (j.toPosition = j.toHandle ? j.toHandle.position : null),
        C?.(O, j),
        x.setState({ connectionClickStartHandle: null }))
    }
  return z.jsx('div', {
    'data-handleid': g,
    'data-nodeid': y,
    'data-handlepos': t,
    'data-id': `${b}-${y}-${g}-${e}`,
    className: ye([
      'react-flow__handle',
      `react-flow__handle-${t}`,
      'nodrag',
      m,
      c,
      {
        source: !p,
        target: p,
        connectable: r,
        connectablestart: i,
        connectableend: o,
        clickconnecting: _,
        connectingfrom: P,
        connectingto: S,
        valid: D,
        connectionindicator: r && (!T || M) && (T || F ? o : i),
      },
    ]),
    onMouseDown: $,
    onTouchStart: $,
    onClick: w ? E : void 0,
    ref: h,
    ...d,
    children: l,
  })
}
const oo = v.memo(Vg(m2))
function y2({ data: e, isConnectable: t, sourcePosition: n = ee.Bottom }) {
  return z.jsxs(z.Fragment, {
    children: [e?.label, z.jsx(oo, { type: 'source', position: n, isConnectable: t })],
  })
}
function x2({
  data: e,
  isConnectable: t,
  targetPosition: n = ee.Top,
  sourcePosition: r = ee.Bottom,
}) {
  return z.jsxs(z.Fragment, {
    children: [
      z.jsx(oo, { type: 'target', position: n, isConnectable: t }),
      e?.label,
      z.jsx(oo, { type: 'source', position: r, isConnectable: t }),
    ],
  })
}
function b2() {
  return null
}
function w2({ data: e, isConnectable: t, targetPosition: n = ee.Top }) {
  return z.jsxs(z.Fragment, {
    children: [z.jsx(oo, { type: 'target', position: n, isConnectable: t }), e?.label],
  })
}
const ao = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 },
  },
  Xf = { input: y2, default: x2, output: w2, group: b2 }
function P2(e) {
  return e.internals.handleBounds === void 0
    ? {
        width: e.width ?? e.initialWidth ?? e.style?.width,
        height: e.height ?? e.initialHeight ?? e.style?.height,
      }
    : { width: e.width ?? e.style?.width, height: e.height ?? e.style?.height }
}
const S2 = (e) => {
  const { width: t, height: n, x: r, y: i } = Br(e.nodeLookup, { filter: (o) => !!o.selected })
  return {
    width: ot(t) ? t : null,
    height: ot(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${i}px)`,
  }
}
function E2({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = fe(),
    { width: i, height: o, transformString: a, userSelectionActive: s } = ie(S2, de),
    l = Yg(),
    c = v.useRef(null)
  if (
    (v.useEffect(() => {
      n || c.current?.focus({ preventScroll: !0 })
    }, [n]),
    Kg({ nodeRef: c }),
    s || !i || !o)
  )
    return null
  const u = e
      ? (d) => {
          const h = r.getState().nodes.filter((g) => g.selected)
          e(d, h)
        }
      : void 0,
    f = (d) => {
      Object.prototype.hasOwnProperty.call(ao, d.key) &&
        (d.preventDefault(), l({ direction: ao[d.key], factor: d.shiftKey ? 4 : 1 }))
    }
  return z.jsx('div', {
    className: ye(['react-flow__nodesselection', 'react-flow__container', t]),
    style: { transform: a },
    children: z.jsx('div', {
      ref: c,
      className: 'react-flow__nodesselection-rect',
      onContextMenu: u,
      tabIndex: n ? void 0 : -1,
      onKeyDown: n ? void 0 : f,
      style: { width: i, height: o },
    }),
  })
}
const Gf = typeof window < 'u' ? window : void 0,
  _2 = (e) => ({
    nodesSelectionActive: e.nodesSelectionActive,
    userSelectionActive: e.userSelectionActive,
  })
function Xg({
  children: e,
  onPaneClick: t,
  onPaneMouseEnter: n,
  onPaneMouseMove: r,
  onPaneMouseLeave: i,
  onPaneContextMenu: o,
  onPaneScroll: a,
  paneClickDistance: s,
  deleteKeyCode: l,
  selectionKeyCode: c,
  selectionOnDrag: u,
  selectionMode: f,
  onSelectionStart: d,
  onSelectionEnd: h,
  multiSelectionKeyCode: g,
  panActivationKeyCode: p,
  zoomActivationKeyCode: x,
  elementsSelectable: y,
  zoomOnScroll: w,
  zoomOnPinch: m,
  panOnScroll: b,
  panOnScrollSpeed: P,
  panOnScrollMode: S,
  zoomOnDoubleClick: _,
  panOnDrag: M,
  defaultViewport: T,
  translateExtent: F,
  minZoom: D,
  maxZoom: k,
  preventScrolling: $,
  onSelectionContextMenu: E,
  noWheelClassName: O,
  noPanClassName: A,
  disableKeyboardA11y: C,
  onViewportChange: N,
  isControlledViewport: I,
}) {
  const { nodesSelectionActive: H, userSelectionActive: V } = ie(_2),
    B = Pr(c, { target: Gf }),
    Y = Pr(p, { target: Gf }),
    K = Y || M,
    G = Y || b,
    re = u && K !== !0,
    q = B || V || re
  return (
    o2({ deleteKeyCode: l, multiSelectionKeyCode: g }),
    z.jsx(c2, {
      onPaneContextMenu: o,
      elementsSelectable: y,
      zoomOnScroll: w,
      zoomOnPinch: m,
      panOnScroll: G,
      panOnScrollSpeed: P,
      panOnScrollMode: S,
      zoomOnDoubleClick: _,
      panOnDrag: !B && K,
      defaultViewport: T,
      translateExtent: F,
      minZoom: D,
      maxZoom: k,
      zoomActivationKeyCode: x,
      preventScrolling: $,
      noWheelClassName: O,
      noPanClassName: A,
      onViewportChange: N,
      isControlledViewport: I,
      paneClickDistance: s,
      children: z.jsxs(d2, {
        onSelectionStart: d,
        onSelectionEnd: h,
        onPaneClick: t,
        onPaneMouseEnter: n,
        onPaneMouseMove: r,
        onPaneMouseLeave: i,
        onPaneContextMenu: o,
        onPaneScroll: a,
        panOnDrag: K,
        isSelecting: !!q,
        selectionMode: f,
        selectionKeyPressed: B,
        selectionOnDrag: re,
        children: [
          e,
          H && z.jsx(E2, { onSelectionContextMenu: E, noPanClassName: A, disableKeyboardA11y: C }),
        ],
      }),
    })
  )
}
Xg.displayName = 'FlowRenderer'
const A2 = v.memo(Xg),
  O2 = (e) => (t) =>
    e
      ? Ic(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map(
          (n) => n.id,
        )
      : Array.from(t.nodeLookup.keys())
function C2(e) {
  return ie(v.useCallback(O2(e), [e]), de)
}
const k2 = (e) => e.updateNodeInternals
function M2() {
  const e = ie(k2),
    [t] = v.useState(() =>
      typeof ResizeObserver > 'u'
        ? null
        : new ResizeObserver((n) => {
            const r = new Map()
            ;(n.forEach((i) => {
              const o = i.target.getAttribute('data-id')
              r.set(o, { id: o, nodeElement: i.target, force: !0 })
            }),
              e(r))
          }),
    )
  return (
    v.useEffect(
      () => () => {
        t?.disconnect()
      },
      [t],
    ),
    t
  )
}
function T2({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const i = fe(),
    o = v.useRef(null),
    a = v.useRef(null),
    s = v.useRef(e.sourcePosition),
    l = v.useRef(e.targetPosition),
    c = v.useRef(t),
    u = n && !!e.internals.handleBounds
  return (
    v.useEffect(() => {
      o.current &&
        !e.hidden &&
        (!u || a.current !== o.current) &&
        (a.current && r?.unobserve(a.current), r?.observe(o.current), (a.current = o.current))
    }, [u, e.hidden]),
    v.useEffect(
      () => () => {
        a.current && (r?.unobserve(a.current), (a.current = null))
      },
      [],
    ),
    v.useEffect(() => {
      if (o.current) {
        const f = c.current !== t,
          d = s.current !== e.sourcePosition,
          h = l.current !== e.targetPosition
        ;(f || d || h) &&
          ((c.current = t),
          (s.current = e.sourcePosition),
          (l.current = e.targetPosition),
          i
            .getState()
            .updateNodeInternals(
              new Map([[e.id, { id: e.id, nodeElement: o.current, force: !0 }]]),
            ))
      }
    }, [e.id, t, e.sourcePosition, e.targetPosition]),
    o
  )
}
function N2({
  id: e,
  onClick: t,
  onMouseEnter: n,
  onMouseMove: r,
  onMouseLeave: i,
  onContextMenu: o,
  onDoubleClick: a,
  nodesDraggable: s,
  elementsSelectable: l,
  nodesConnectable: c,
  nodesFocusable: u,
  resizeObserver: f,
  noDragClassName: d,
  noPanClassName: h,
  disableKeyboardA11y: g,
  rfId: p,
  nodeTypes: x,
  nodeClickDistance: y,
  onError: w,
}) {
  const {
    node: m,
    internals: b,
    isParent: P,
  } = ie((W) => {
    const j = W.nodeLookup.get(e),
      U = W.parentLookup.has(e)
    return { node: j, internals: j.internals, isParent: U }
  }, de)
  let S = m.type || 'default',
    _ = x?.[S] || Xf[S]
  _ === void 0 && (w?.('003', ht.error003(S)), (S = 'default'), (_ = x?.default || Xf.default))
  const M = !!(m.draggable || (s && typeof m.draggable > 'u')),
    T = !!(m.selectable || (l && typeof m.selectable > 'u')),
    F = !!(m.connectable || (c && typeof m.connectable > 'u')),
    D = !!(m.focusable || (u && typeof m.focusable > 'u')),
    k = fe(),
    $ = gg(m),
    E = T2({ node: m, nodeType: S, hasDimensions: $, resizeObserver: f }),
    O = Kg({
      nodeRef: E,
      disabled: m.hidden || !M,
      noDragClassName: d,
      handleSelector: m.dragHandle,
      nodeId: e,
      isSelectable: T,
      nodeClickDistance: y,
    }),
    A = Yg()
  if (m.hidden) return null
  const C = It(m),
    N = P2(m),
    I = T || M || t || n || r || i,
    H = n ? (W) => n(W, { ...b.userNode }) : void 0,
    V = r ? (W) => r(W, { ...b.userNode }) : void 0,
    B = i ? (W) => i(W, { ...b.userNode }) : void 0,
    Y = o ? (W) => o(W, { ...b.userNode }) : void 0,
    K = a ? (W) => a(W, { ...b.userNode }) : void 0,
    G = (W) => {
      const { selectNodesOnDrag: j, nodeDragThreshold: U } = k.getState()
      ;(T && (!j || !M || U > 0) && fs({ id: e, store: k, nodeRef: E }),
        t && t(W, { ...b.userNode }))
    },
    re = (W) => {
      if (!(xg(W.nativeEvent) || g)) {
        if (sg.includes(W.key) && T) {
          const j = W.key === 'Escape'
          fs({ id: e, store: k, unselect: j, nodeRef: E })
        } else if (M && m.selected && Object.prototype.hasOwnProperty.call(ao, W.key)) {
          W.preventDefault()
          const { ariaLabelConfig: j } = k.getState()
          ;(k.setState({
            ariaLiveMessage: j['node.a11yDescription.ariaLiveMessage']({
              direction: W.key.replace('Arrow', '').toLowerCase(),
              x: ~~b.positionAbsolute.x,
              y: ~~b.positionAbsolute.y,
            }),
          }),
            A({ direction: ao[W.key], factor: W.shiftKey ? 4 : 1 }))
        }
      }
    },
    q = () => {
      if (g || !E.current?.matches(':focus-visible')) return
      const {
        transform: W,
        width: j,
        height: U,
        autoPanOnNodeFocus: X,
        setCenter: L,
      } = k.getState()
      if (!X) return
      Ic(new Map([[e, m]]), { x: 0, y: 0, width: j, height: U }, W, !0).length > 0 ||
        L(m.position.x + C.width / 2, m.position.y + C.height / 2, { zoom: W[2] })
    }
  return z.jsx('div', {
    className: ye([
      'react-flow__node',
      `react-flow__node-${S}`,
      { [h]: M },
      m.className,
      { selected: m.selected, selectable: T, parent: P, draggable: M, dragging: O },
    ]),
    ref: E,
    style: {
      zIndex: b.z,
      transform: `translate(${b.positionAbsolute.x}px,${b.positionAbsolute.y}px)`,
      pointerEvents: I ? 'all' : 'none',
      visibility: $ ? 'visible' : 'hidden',
      ...m.style,
      ...N,
    },
    'data-id': e,
    'data-testid': `rf__node-${e}`,
    onMouseEnter: H,
    onMouseMove: V,
    onMouseLeave: B,
    onContextMenu: Y,
    onClick: G,
    onDoubleClick: K,
    onKeyDown: D ? re : void 0,
    tabIndex: D ? 0 : void 0,
    onFocus: D ? q : void 0,
    role: m.ariaRole ?? (D ? 'group' : void 0),
    'aria-roledescription': 'node',
    'aria-describedby': g ? void 0 : `${Lg}-${p}`,
    'aria-label': m.ariaLabel,
    ...m.domAttributes,
    children: z.jsx(p2, {
      value: e,
      children: z.jsx(_, {
        id: e,
        data: m.data,
        type: S,
        positionAbsoluteX: b.positionAbsolute.x,
        positionAbsoluteY: b.positionAbsolute.y,
        selected: m.selected ?? !1,
        selectable: T,
        draggable: M,
        deletable: m.deletable ?? !0,
        isConnectable: F,
        sourcePosition: m.sourcePosition,
        targetPosition: m.targetPosition,
        dragging: O,
        dragHandle: m.dragHandle,
        zIndex: b.z,
        parentId: m.parentId,
        ...C,
      }),
    }),
  })
}
var D2 = v.memo(N2)
const I2 = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError,
})
function Gg(e) {
  const {
      nodesDraggable: t,
      nodesConnectable: n,
      nodesFocusable: r,
      elementsSelectable: i,
      onError: o,
    } = ie(I2, de),
    a = C2(e.onlyRenderVisibleElements),
    s = M2()
  return z.jsx('div', {
    className: 'react-flow__nodes',
    style: Ko,
    children: a.map((l) =>
      z.jsx(
        D2,
        {
          id: l,
          nodeTypes: e.nodeTypes,
          nodeExtent: e.nodeExtent,
          onClick: e.onNodeClick,
          onMouseEnter: e.onNodeMouseEnter,
          onMouseMove: e.onNodeMouseMove,
          onMouseLeave: e.onNodeMouseLeave,
          onContextMenu: e.onNodeContextMenu,
          onDoubleClick: e.onNodeDoubleClick,
          noDragClassName: e.noDragClassName,
          noPanClassName: e.noPanClassName,
          rfId: e.rfId,
          disableKeyboardA11y: e.disableKeyboardA11y,
          resizeObserver: s,
          nodesDraggable: t,
          nodesConnectable: n,
          nodesFocusable: r,
          elementsSelectable: i,
          nodeClickDistance: e.nodeClickDistance,
          onError: o,
        },
        l,
      ),
    ),
  })
}
Gg.displayName = 'NodeRenderer'
const j2 = v.memo(Gg)
function $2(e) {
  return ie(
    v.useCallback(
      (n) => {
        if (!e) return n.edges.map((i) => i.id)
        const r = []
        if (n.width && n.height)
          for (const i of n.edges) {
            const o = n.nodeLookup.get(i.source),
              a = n.nodeLookup.get(i.target)
            o &&
              a &&
              YD({
                sourceNode: o,
                targetNode: a,
                width: n.width,
                height: n.height,
                transform: n.transform,
              }) &&
              r.push(i.id)
          }
        return r
      },
      [e],
    ),
    de,
  )
}
const L2 = ({ color: e = 'none', strokeWidth: t = 1 }) => {
    const n = { strokeWidth: t, ...(e && { stroke: e }) }
    return z.jsx('polyline', {
      className: 'arrow',
      style: n,
      strokeLinecap: 'round',
      fill: 'none',
      strokeLinejoin: 'round',
      points: '-5,-4 0,0 -5,4',
    })
  },
  z2 = ({ color: e = 'none', strokeWidth: t = 1 }) => {
    const n = { strokeWidth: t, ...(e && { stroke: e, fill: e }) }
    return z.jsx('polyline', {
      className: 'arrowclosed',
      style: n,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      points: '-5,-4 0,0 -5,4 -5,-4',
    })
  },
  qf = { [no.Arrow]: L2, [no.ArrowClosed]: z2 }
function R2(e) {
  const t = fe()
  return v.useMemo(
    () =>
      Object.prototype.hasOwnProperty.call(qf, e)
        ? qf[e]
        : (t.getState().onError?.('009', ht.error009(e)), null),
    [e],
  )
}
const B2 = ({
    id: e,
    type: t,
    color: n,
    width: r = 12.5,
    height: i = 12.5,
    markerUnits: o = 'strokeWidth',
    strokeWidth: a,
    orient: s = 'auto-start-reverse',
  }) => {
    const l = R2(t)
    return l
      ? z.jsx('marker', {
          className: 'react-flow__arrowhead',
          id: e,
          markerWidth: `${r}`,
          markerHeight: `${i}`,
          viewBox: '-10 -10 20 20',
          markerUnits: o,
          orient: s,
          refX: '0',
          refY: '0',
          children: z.jsx(l, { color: n, strokeWidth: a }),
        })
      : null
  },
  qg = ({ defaultColor: e, rfId: t }) => {
    const n = ie((o) => o.edges),
      r = ie((o) => o.defaultEdgeOptions),
      i = v.useMemo(
        () =>
          eI(n, {
            id: t,
            defaultColor: e,
            defaultMarkerStart: r?.markerStart,
            defaultMarkerEnd: r?.markerEnd,
          }),
        [n, r, t, e],
      )
    return i.length
      ? z.jsx('svg', {
          className: 'react-flow__marker',
          'aria-hidden': 'true',
          children: z.jsx('defs', {
            children: i.map((o) =>
              z.jsx(
                B2,
                {
                  id: o.id,
                  type: o.type,
                  color: o.color,
                  width: o.width,
                  height: o.height,
                  markerUnits: o.markerUnits,
                  strokeWidth: o.strokeWidth,
                  orient: o.orient,
                },
                o.id,
              ),
            ),
          }),
        })
      : null
  }
qg.displayName = 'MarkerDefinitions'
var H2 = v.memo(qg)
function Zg({
  x: e,
  y: t,
  label: n,
  labelStyle: r,
  labelShowBg: i = !0,
  labelBgStyle: o,
  labelBgPadding: a = [2, 4],
  labelBgBorderRadius: s = 2,
  children: l,
  className: c,
  ...u
}) {
  const [f, d] = v.useState({ x: 1, y: 0, width: 0, height: 0 }),
    h = ye(['react-flow__edge-textwrapper', c]),
    g = v.useRef(null)
  return (
    v.useEffect(() => {
      if (g.current) {
        const p = g.current.getBBox()
        d({ x: p.x, y: p.y, width: p.width, height: p.height })
      }
    }, [n]),
    n
      ? z.jsxs('g', {
          transform: `translate(${e - f.width / 2} ${t - f.height / 2})`,
          className: h,
          visibility: f.width ? 'visible' : 'hidden',
          ...u,
          children: [
            i &&
              z.jsx('rect', {
                width: f.width + 2 * a[0],
                x: -a[0],
                y: -a[1],
                height: f.height + 2 * a[1],
                className: 'react-flow__edge-textbg',
                style: o,
                rx: s,
                ry: s,
              }),
            z.jsx('text', {
              className: 'react-flow__edge-text',
              y: f.height / 2,
              dy: '0.3em',
              ref: g,
              style: r,
              children: n,
            }),
            l,
          ],
        })
      : null
  )
}
Zg.displayName = 'EdgeText'
const F2 = v.memo(Zg)
function Yo({
  path: e,
  labelX: t,
  labelY: n,
  label: r,
  labelStyle: i,
  labelShowBg: o,
  labelBgStyle: a,
  labelBgPadding: s,
  labelBgBorderRadius: l,
  interactionWidth: c = 20,
  ...u
}) {
  return z.jsxs(z.Fragment, {
    children: [
      z.jsx('path', {
        ...u,
        d: e,
        fill: 'none',
        className: ye(['react-flow__edge-path', u.className]),
      }),
      c
        ? z.jsx('path', {
            d: e,
            fill: 'none',
            strokeOpacity: 0,
            strokeWidth: c,
            className: 'react-flow__edge-interaction',
          })
        : null,
      r && ot(t) && ot(n)
        ? z.jsx(F2, {
            x: t,
            y: n,
            label: r,
            labelStyle: i,
            labelShowBg: o,
            labelBgStyle: a,
            labelBgPadding: s,
            labelBgBorderRadius: l,
          })
        : null,
    ],
  })
}
function Zf({ pos: e, x1: t, y1: n, x2: r, y2: i }) {
  return e === ee.Left || e === ee.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + i)]
}
function Qg({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = ee.Bottom,
  targetX: r,
  targetY: i,
  targetPosition: o = ee.Top,
}) {
  const [a, s] = Zf({ pos: n, x1: e, y1: t, x2: r, y2: i }),
    [l, c] = Zf({ pos: o, x1: r, y1: i, x2: e, y2: t }),
    [u, f, d, h] = wg({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: i,
      sourceControlX: a,
      sourceControlY: s,
      targetControlX: l,
      targetControlY: c,
    })
  return [`M${e},${t} C${a},${s} ${l},${c} ${r},${i}`, u, f, d, h]
}
function Jg(e) {
  return v.memo(
    ({
      id: t,
      sourceX: n,
      sourceY: r,
      targetX: i,
      targetY: o,
      sourcePosition: a,
      targetPosition: s,
      label: l,
      labelStyle: c,
      labelShowBg: u,
      labelBgStyle: f,
      labelBgPadding: d,
      labelBgBorderRadius: h,
      style: g,
      markerEnd: p,
      markerStart: x,
      interactionWidth: y,
    }) => {
      const [w, m, b] = Qg({
          sourceX: n,
          sourceY: r,
          sourcePosition: a,
          targetX: i,
          targetY: o,
          targetPosition: s,
        }),
        P = e.isInternal ? void 0 : t
      return z.jsx(Yo, {
        id: P,
        path: w,
        labelX: m,
        labelY: b,
        label: l,
        labelStyle: c,
        labelShowBg: u,
        labelBgStyle: f,
        labelBgPadding: d,
        labelBgBorderRadius: h,
        style: g,
        markerEnd: p,
        markerStart: x,
        interactionWidth: y,
      })
    },
  )
}
const V2 = Jg({ isInternal: !1 }),
  em = Jg({ isInternal: !0 })
V2.displayName = 'SimpleBezierEdge'
em.displayName = 'SimpleBezierEdgeInternal'
function tm(e) {
  return v.memo(
    ({
      id: t,
      sourceX: n,
      sourceY: r,
      targetX: i,
      targetY: o,
      label: a,
      labelStyle: s,
      labelShowBg: l,
      labelBgStyle: c,
      labelBgPadding: u,
      labelBgBorderRadius: f,
      style: d,
      sourcePosition: h = ee.Bottom,
      targetPosition: g = ee.Top,
      markerEnd: p,
      markerStart: x,
      pathOptions: y,
      interactionWidth: w,
    }) => {
      const [m, b, P] = ss({
          sourceX: n,
          sourceY: r,
          sourcePosition: h,
          targetX: i,
          targetY: o,
          targetPosition: g,
          borderRadius: y?.borderRadius,
          offset: y?.offset,
          stepPosition: y?.stepPosition,
        }),
        S = e.isInternal ? void 0 : t
      return z.jsx(Yo, {
        id: S,
        path: m,
        labelX: b,
        labelY: P,
        label: a,
        labelStyle: s,
        labelShowBg: l,
        labelBgStyle: c,
        labelBgPadding: u,
        labelBgBorderRadius: f,
        style: d,
        markerEnd: p,
        markerStart: x,
        interactionWidth: w,
      })
    },
  )
}
const nm = tm({ isInternal: !1 }),
  rm = tm({ isInternal: !0 })
nm.displayName = 'SmoothStepEdge'
rm.displayName = 'SmoothStepEdgeInternal'
function im(e) {
  return v.memo(({ id: t, ...n }) => {
    const r = e.isInternal ? void 0 : t
    return z.jsx(nm, {
      ...n,
      id: r,
      pathOptions: v.useMemo(
        () => ({ borderRadius: 0, offset: n.pathOptions?.offset }),
        [n.pathOptions?.offset],
      ),
    })
  })
}
const W2 = im({ isInternal: !1 }),
  om = im({ isInternal: !0 })
W2.displayName = 'StepEdge'
om.displayName = 'StepEdgeInternal'
function am(e) {
  return v.memo(
    ({
      id: t,
      sourceX: n,
      sourceY: r,
      targetX: i,
      targetY: o,
      label: a,
      labelStyle: s,
      labelShowBg: l,
      labelBgStyle: c,
      labelBgPadding: u,
      labelBgBorderRadius: f,
      style: d,
      markerEnd: h,
      markerStart: g,
      interactionWidth: p,
    }) => {
      const [x, y, w] = Eg({ sourceX: n, sourceY: r, targetX: i, targetY: o }),
        m = e.isInternal ? void 0 : t
      return z.jsx(Yo, {
        id: m,
        path: x,
        labelX: y,
        labelY: w,
        label: a,
        labelStyle: s,
        labelShowBg: l,
        labelBgStyle: c,
        labelBgPadding: u,
        labelBgBorderRadius: f,
        style: d,
        markerEnd: h,
        markerStart: g,
        interactionWidth: p,
      })
    },
  )
}
const K2 = am({ isInternal: !1 }),
  sm = am({ isInternal: !0 })
K2.displayName = 'StraightEdge'
sm.displayName = 'StraightEdgeInternal'
function cm(e) {
  return v.memo(
    ({
      id: t,
      sourceX: n,
      sourceY: r,
      targetX: i,
      targetY: o,
      sourcePosition: a = ee.Bottom,
      targetPosition: s = ee.Top,
      label: l,
      labelStyle: c,
      labelShowBg: u,
      labelBgStyle: f,
      labelBgPadding: d,
      labelBgBorderRadius: h,
      style: g,
      markerEnd: p,
      markerStart: x,
      pathOptions: y,
      interactionWidth: w,
    }) => {
      const [m, b, P] = Pg({
          sourceX: n,
          sourceY: r,
          sourcePosition: a,
          targetX: i,
          targetY: o,
          targetPosition: s,
          curvature: y?.curvature,
        }),
        S = e.isInternal ? void 0 : t
      return z.jsx(Yo, {
        id: S,
        path: m,
        labelX: b,
        labelY: P,
        label: l,
        labelStyle: c,
        labelShowBg: u,
        labelBgStyle: f,
        labelBgPadding: d,
        labelBgBorderRadius: h,
        style: g,
        markerEnd: p,
        markerStart: x,
        interactionWidth: w,
      })
    },
  )
}
const Y2 = cm({ isInternal: !1 }),
  lm = cm({ isInternal: !0 })
Y2.displayName = 'BezierEdge'
lm.displayName = 'BezierEdgeInternal'
const Qf = { default: lm, straight: sm, step: om, smoothstep: rm, simplebezier: em },
  Jf = {
    sourceX: null,
    sourceY: null,
    targetX: null,
    targetY: null,
    sourcePosition: null,
    targetPosition: null,
  },
  U2 = (e, t, n) => (n === ee.Left ? e - t : n === ee.Right ? e + t : e),
  X2 = (e, t, n) => (n === ee.Top ? e - t : n === ee.Bottom ? e + t : e),
  ed = 'react-flow__edgeupdater'
function td({
  position: e,
  centerX: t,
  centerY: n,
  radius: r = 10,
  onMouseDown: i,
  onMouseEnter: o,
  onMouseOut: a,
  type: s,
}) {
  return z.jsx('circle', {
    onMouseDown: i,
    onMouseEnter: o,
    onMouseOut: a,
    className: ye([ed, `${ed}-${s}`]),
    cx: U2(t, r, e),
    cy: X2(n, r, e),
    r,
    stroke: 'transparent',
    fill: 'transparent',
  })
}
function G2({
  isReconnectable: e,
  reconnectRadius: t,
  edge: n,
  sourceX: r,
  sourceY: i,
  targetX: o,
  targetY: a,
  sourcePosition: s,
  targetPosition: l,
  onReconnect: c,
  onReconnectStart: u,
  onReconnectEnd: f,
  setReconnecting: d,
  setUpdateHover: h,
}) {
  const g = fe(),
    p = (b, P) => {
      if (b.button !== 0) return
      const {
          autoPanOnConnect: S,
          domNode: _,
          isValidConnection: M,
          connectionMode: T,
          connectionRadius: F,
          lib: D,
          onConnectStart: k,
          onConnectEnd: $,
          cancelConnection: E,
          nodeLookup: O,
          rfId: A,
          panBy: C,
          updateConnection: N,
        } = g.getState(),
        I = P.type === 'target',
        H = (Y, K) => {
          ;(d(!1), f?.(Y, n, P.type, K))
        },
        V = (Y) => c?.(n, Y),
        B = (Y, K) => {
          ;(d(!0), u?.(b, n, P.type), k?.(Y, K))
        }
      us.onPointerDown(b.nativeEvent, {
        autoPanOnConnect: S,
        connectionMode: T,
        connectionRadius: F,
        domNode: _,
        handleId: P.id,
        nodeId: P.nodeId,
        nodeLookup: O,
        isTarget: I,
        edgeUpdaterType: P.type,
        lib: D,
        flowId: A,
        cancelConnection: E,
        panBy: C,
        isValidConnection: M,
        onConnect: V,
        onConnectStart: B,
        onConnectEnd: $,
        onReconnectEnd: H,
        updateConnection: N,
        getTransform: () => g.getState().transform,
        getFromHandle: () => g.getState().connection.fromHandle,
        dragThreshold: g.getState().connectionDragThreshold,
        handleDomNode: b.currentTarget,
      })
    },
    x = (b) => p(b, { nodeId: n.target, id: n.targetHandle ?? null, type: 'target' }),
    y = (b) => p(b, { nodeId: n.source, id: n.sourceHandle ?? null, type: 'source' }),
    w = () => h(!0),
    m = () => h(!1)
  return z.jsxs(z.Fragment, {
    children: [
      (e === !0 || e === 'source') &&
        z.jsx(td, {
          position: s,
          centerX: r,
          centerY: i,
          radius: t,
          onMouseDown: x,
          onMouseEnter: w,
          onMouseOut: m,
          type: 'source',
        }),
      (e === !0 || e === 'target') &&
        z.jsx(td, {
          position: l,
          centerX: o,
          centerY: a,
          radius: t,
          onMouseDown: y,
          onMouseEnter: w,
          onMouseOut: m,
          type: 'target',
        }),
    ],
  })
}
function q2({
  id: e,
  edgesFocusable: t,
  edgesReconnectable: n,
  elementsSelectable: r,
  onClick: i,
  onDoubleClick: o,
  onContextMenu: a,
  onMouseEnter: s,
  onMouseMove: l,
  onMouseLeave: c,
  reconnectRadius: u,
  onReconnect: f,
  onReconnectStart: d,
  onReconnectEnd: h,
  rfId: g,
  edgeTypes: p,
  noPanClassName: x,
  onError: y,
  disableKeyboardA11y: w,
}) {
  let m = ie((L) => L.edgeLookup.get(e))
  const b = ie((L) => L.defaultEdgeOptions)
  m = b ? { ...b, ...m } : m
  let P = m.type || 'default',
    S = p?.[P] || Qf[P]
  S === void 0 && (y?.('011', ht.error011(P)), (P = 'default'), (S = p?.default || Qf.default))
  const _ = !!(m.focusable || (t && typeof m.focusable > 'u')),
    M = typeof f < 'u' && (m.reconnectable || (n && typeof m.reconnectable > 'u')),
    T = !!(m.selectable || (r && typeof m.selectable > 'u')),
    F = v.useRef(null),
    [D, k] = v.useState(!1),
    [$, E] = v.useState(!1),
    O = fe(),
    {
      zIndex: A,
      sourceX: C,
      sourceY: N,
      targetX: I,
      targetY: H,
      sourcePosition: V,
      targetPosition: B,
    } = ie(
      v.useCallback(
        (L) => {
          const Q = L.nodeLookup.get(m.source),
            Z = L.nodeLookup.get(m.target)
          if (!Q || !Z) return { zIndex: m.zIndex, ...Jf }
          const ne = JD({
            id: e,
            sourceNode: Q,
            targetNode: Z,
            sourceHandle: m.sourceHandle || null,
            targetHandle: m.targetHandle || null,
            connectionMode: L.connectionMode,
            onError: y,
          })
          return {
            zIndex: KD({
              selected: m.selected,
              zIndex: m.zIndex,
              sourceNode: Q,
              targetNode: Z,
              elevateOnSelect: L.elevateEdgesOnSelect,
            }),
            ...(ne || Jf),
          }
        },
        [m.source, m.target, m.sourceHandle, m.targetHandle, m.selected, m.zIndex],
      ),
      de,
    ),
    Y = v.useMemo(
      () => (m.markerStart ? `url('#${cs(m.markerStart, g)}')` : void 0),
      [m.markerStart, g],
    ),
    K = v.useMemo(() => (m.markerEnd ? `url('#${cs(m.markerEnd, g)}')` : void 0), [m.markerEnd, g])
  if (m.hidden || C === null || N === null || I === null || H === null) return null
  const G = (L) => {
      const {
        addSelectedEdges: Q,
        unselectNodesAndEdges: Z,
        multiSelectionActive: ne,
      } = O.getState()
      ;(T &&
        (O.setState({ nodesSelectionActive: !1 }),
        m.selected && ne ? (Z({ nodes: [], edges: [m] }), F.current?.blur()) : Q([e])),
        i && i(L, m))
    },
    re = o
      ? (L) => {
          o(L, { ...m })
        }
      : void 0,
    q = a
      ? (L) => {
          a(L, { ...m })
        }
      : void 0,
    W = s
      ? (L) => {
          s(L, { ...m })
        }
      : void 0,
    j = l
      ? (L) => {
          l(L, { ...m })
        }
      : void 0,
    U = c
      ? (L) => {
          c(L, { ...m })
        }
      : void 0,
    X = (L) => {
      if (!w && sg.includes(L.key) && T) {
        const { unselectNodesAndEdges: Q, addSelectedEdges: Z } = O.getState()
        L.key === 'Escape' ? (F.current?.blur(), Q({ edges: [m] })) : Z([e])
      }
    }
  return z.jsx('svg', {
    style: { zIndex: A },
    children: z.jsxs('g', {
      className: ye([
        'react-flow__edge',
        `react-flow__edge-${P}`,
        m.className,
        x,
        {
          selected: m.selected,
          animated: m.animated,
          inactive: !T && !i,
          updating: D,
          selectable: T,
        },
      ]),
      onClick: G,
      onDoubleClick: re,
      onContextMenu: q,
      onMouseEnter: W,
      onMouseMove: j,
      onMouseLeave: U,
      onKeyDown: _ ? X : void 0,
      tabIndex: _ ? 0 : void 0,
      role: m.ariaRole ?? (_ ? 'group' : 'img'),
      'aria-roledescription': 'edge',
      'data-id': e,
      'data-testid': `rf__edge-${e}`,
      'aria-label':
        m.ariaLabel === null ? void 0 : m.ariaLabel || `Edge from ${m.source} to ${m.target}`,
      'aria-describedby': _ ? `${zg}-${g}` : void 0,
      ref: F,
      ...m.domAttributes,
      children: [
        !$ &&
          z.jsx(S, {
            id: e,
            source: m.source,
            target: m.target,
            type: m.type,
            selected: m.selected,
            animated: m.animated,
            selectable: T,
            deletable: m.deletable ?? !0,
            label: m.label,
            labelStyle: m.labelStyle,
            labelShowBg: m.labelShowBg,
            labelBgStyle: m.labelBgStyle,
            labelBgPadding: m.labelBgPadding,
            labelBgBorderRadius: m.labelBgBorderRadius,
            sourceX: C,
            sourceY: N,
            targetX: I,
            targetY: H,
            sourcePosition: V,
            targetPosition: B,
            data: m.data,
            style: m.style,
            sourceHandleId: m.sourceHandle,
            targetHandleId: m.targetHandle,
            markerStart: Y,
            markerEnd: K,
            pathOptions: 'pathOptions' in m ? m.pathOptions : void 0,
            interactionWidth: m.interactionWidth,
          }),
        M &&
          z.jsx(G2, {
            edge: m,
            isReconnectable: M,
            reconnectRadius: u,
            onReconnect: f,
            onReconnectStart: d,
            onReconnectEnd: h,
            sourceX: C,
            sourceY: N,
            targetX: I,
            targetY: H,
            sourcePosition: V,
            targetPosition: B,
            setUpdateHover: k,
            setReconnecting: E,
          }),
      ],
    }),
  })
}
var Z2 = v.memo(q2)
const Q2 = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError,
})
function um({
  defaultMarkerColor: e,
  onlyRenderVisibleElements: t,
  rfId: n,
  edgeTypes: r,
  noPanClassName: i,
  onReconnect: o,
  onEdgeContextMenu: a,
  onEdgeMouseEnter: s,
  onEdgeMouseMove: l,
  onEdgeMouseLeave: c,
  onEdgeClick: u,
  reconnectRadius: f,
  onEdgeDoubleClick: d,
  onReconnectStart: h,
  onReconnectEnd: g,
  disableKeyboardA11y: p,
}) {
  const {
      edgesFocusable: x,
      edgesReconnectable: y,
      elementsSelectable: w,
      onError: m,
    } = ie(Q2, de),
    b = $2(t)
  return z.jsxs('div', {
    className: 'react-flow__edges',
    children: [
      z.jsx(H2, { defaultColor: e, rfId: n }),
      b.map((P) =>
        z.jsx(
          Z2,
          {
            id: P,
            edgesFocusable: x,
            edgesReconnectable: y,
            elementsSelectable: w,
            noPanClassName: i,
            onReconnect: o,
            onContextMenu: a,
            onMouseEnter: s,
            onMouseMove: l,
            onMouseLeave: c,
            onClick: u,
            reconnectRadius: f,
            onDoubleClick: d,
            onReconnectStart: h,
            onReconnectEnd: g,
            rfId: n,
            onError: m,
            edgeTypes: r,
            disableKeyboardA11y: p,
          },
          P,
        ),
      ),
    ],
  })
}
um.displayName = 'EdgeRenderer'
const J2 = v.memo(um),
  ej = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`
function tj({ children: e }) {
  const t = ie(ej)
  return z.jsx('div', {
    className: 'react-flow__viewport xyflow__viewport react-flow__container',
    style: { transform: t },
    children: e,
  })
}
function nj(e) {
  const t = Hc(),
    n = v.useRef(!1)
  v.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), (n.current = !0))
  }, [e, t.viewportInitialized])
}
const rj = (e) => e.panZoom?.syncViewport
function ij(e) {
  const t = ie(rj),
    n = fe()
  return (
    v.useEffect(() => {
      e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }))
    }, [e, t]),
    null
  )
}
function oj(e) {
  return e.connection.inProgress
    ? { ...e.connection, to: Fr(e.connection.to, e.transform) }
    : { ...e.connection }
}
function aj(e) {
  return oj
}
function sj(e) {
  const t = aj()
  return ie(t, de)
}
const cj = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height,
})
function lj({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: i, width: o, height: a, isValid: s, inProgress: l } = ie(cj, de)
  return !(o && i && l)
    ? null
    : z.jsx('svg', {
        style: e,
        width: o,
        height: a,
        className: 'react-flow__connectionline react-flow__container',
        children: z.jsx('g', {
          className: ye(['react-flow__connection', ug(s)]),
          children: z.jsx(fm, { style: t, type: n, CustomComponent: r, isValid: s }),
        }),
      })
}
const fm = ({ style: e, type: t = Rt.Bezier, CustomComponent: n, isValid: r }) => {
  const {
    inProgress: i,
    from: o,
    fromNode: a,
    fromHandle: s,
    fromPosition: l,
    to: c,
    toNode: u,
    toHandle: f,
    toPosition: d,
  } = sj()
  if (!i) return
  if (n)
    return z.jsx(n, {
      connectionLineType: t,
      connectionLineStyle: e,
      fromNode: a,
      fromHandle: s,
      fromX: o.x,
      fromY: o.y,
      toX: c.x,
      toY: c.y,
      fromPosition: l,
      toPosition: d,
      connectionStatus: ug(r),
      toNode: u,
      toHandle: f,
    })
  let h = ''
  const g = {
    sourceX: o.x,
    sourceY: o.y,
    sourcePosition: l,
    targetX: c.x,
    targetY: c.y,
    targetPosition: d,
  }
  switch (t) {
    case Rt.Bezier:
      ;[h] = Pg(g)
      break
    case Rt.SimpleBezier:
      ;[h] = Qg(g)
      break
    case Rt.Step:
      ;[h] = ss({ ...g, borderRadius: 0 })
      break
    case Rt.SmoothStep:
      ;[h] = ss(g)
      break
    default:
      ;[h] = Eg(g)
  }
  return z.jsx('path', { d: h, fill: 'none', className: 'react-flow__connection-path', style: e })
}
fm.displayName = 'ConnectionLine'
const uj = {}
function nd(e = uj) {
  ;(v.useRef(e), fe(), v.useEffect(() => {}, [e]))
}
function fj() {
  ;(fe(), v.useRef(!1), v.useEffect(() => {}, []))
}
function dm({
  nodeTypes: e,
  edgeTypes: t,
  onInit: n,
  onNodeClick: r,
  onEdgeClick: i,
  onNodeDoubleClick: o,
  onEdgeDoubleClick: a,
  onNodeMouseEnter: s,
  onNodeMouseMove: l,
  onNodeMouseLeave: c,
  onNodeContextMenu: u,
  onSelectionContextMenu: f,
  onSelectionStart: d,
  onSelectionEnd: h,
  connectionLineType: g,
  connectionLineStyle: p,
  connectionLineComponent: x,
  connectionLineContainerStyle: y,
  selectionKeyCode: w,
  selectionOnDrag: m,
  selectionMode: b,
  multiSelectionKeyCode: P,
  panActivationKeyCode: S,
  zoomActivationKeyCode: _,
  deleteKeyCode: M,
  onlyRenderVisibleElements: T,
  elementsSelectable: F,
  defaultViewport: D,
  translateExtent: k,
  minZoom: $,
  maxZoom: E,
  preventScrolling: O,
  defaultMarkerColor: A,
  zoomOnScroll: C,
  zoomOnPinch: N,
  panOnScroll: I,
  panOnScrollSpeed: H,
  panOnScrollMode: V,
  zoomOnDoubleClick: B,
  panOnDrag: Y,
  onPaneClick: K,
  onPaneMouseEnter: G,
  onPaneMouseMove: re,
  onPaneMouseLeave: q,
  onPaneScroll: W,
  onPaneContextMenu: j,
  paneClickDistance: U,
  nodeClickDistance: X,
  onEdgeContextMenu: L,
  onEdgeMouseEnter: Q,
  onEdgeMouseMove: Z,
  onEdgeMouseLeave: ne,
  reconnectRadius: ae,
  onReconnect: ue,
  onReconnectStart: Ye,
  onReconnectEnd: Vr,
  noDragClassName: Wr,
  noWheelClassName: Kr,
  noPanClassName: Vn,
  disableKeyboardA11y: Wn,
  nodeExtent: Uo,
  rfId: Yr,
  viewport: dn,
  onViewportChange: Kn,
}) {
  return (
    nd(e),
    nd(t),
    fj(),
    nj(n),
    ij(dn),
    z.jsx(A2, {
      onPaneClick: K,
      onPaneMouseEnter: G,
      onPaneMouseMove: re,
      onPaneMouseLeave: q,
      onPaneContextMenu: j,
      onPaneScroll: W,
      paneClickDistance: U,
      deleteKeyCode: M,
      selectionKeyCode: w,
      selectionOnDrag: m,
      selectionMode: b,
      onSelectionStart: d,
      onSelectionEnd: h,
      multiSelectionKeyCode: P,
      panActivationKeyCode: S,
      zoomActivationKeyCode: _,
      elementsSelectable: F,
      zoomOnScroll: C,
      zoomOnPinch: N,
      zoomOnDoubleClick: B,
      panOnScroll: I,
      panOnScrollSpeed: H,
      panOnScrollMode: V,
      panOnDrag: Y,
      defaultViewport: D,
      translateExtent: k,
      minZoom: $,
      maxZoom: E,
      onSelectionContextMenu: f,
      preventScrolling: O,
      noDragClassName: Wr,
      noWheelClassName: Kr,
      noPanClassName: Vn,
      disableKeyboardA11y: Wn,
      onViewportChange: Kn,
      isControlledViewport: !!dn,
      children: z.jsxs(tj, {
        children: [
          z.jsx(J2, {
            edgeTypes: t,
            onEdgeClick: i,
            onEdgeDoubleClick: a,
            onReconnect: ue,
            onReconnectStart: Ye,
            onReconnectEnd: Vr,
            onlyRenderVisibleElements: T,
            onEdgeContextMenu: L,
            onEdgeMouseEnter: Q,
            onEdgeMouseMove: Z,
            onEdgeMouseLeave: ne,
            reconnectRadius: ae,
            defaultMarkerColor: A,
            noPanClassName: Vn,
            disableKeyboardA11y: Wn,
            rfId: Yr,
          }),
          z.jsx(lj, { style: p, type: g, component: x, containerStyle: y }),
          z.jsx('div', { className: 'react-flow__edgelabel-renderer' }),
          z.jsx(j2, {
            nodeTypes: e,
            onNodeClick: r,
            onNodeDoubleClick: o,
            onNodeMouseEnter: s,
            onNodeMouseMove: l,
            onNodeMouseLeave: c,
            onNodeContextMenu: u,
            nodeClickDistance: X,
            onlyRenderVisibleElements: T,
            noPanClassName: Vn,
            noDragClassName: Wr,
            disableKeyboardA11y: Wn,
            nodeExtent: Uo,
            rfId: Yr,
          }),
          z.jsx('div', { className: 'react-flow__viewport-portal' }),
        ],
      }),
    })
  )
}
dm.displayName = 'GraphView'
const dj = v.memo(dm),
  rd = ({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: i,
    height: o,
    fitView: a,
    fitViewOptions: s,
    minZoom: l = 0.5,
    maxZoom: c = 2,
    nodeOrigin: u,
    nodeExtent: f,
  } = {}) => {
    const d = new Map(),
      h = new Map(),
      g = new Map(),
      p = new Map(),
      x = r ?? t ?? [],
      y = n ?? e ?? [],
      w = u ?? [0, 0],
      m = f ?? mr
    Og(g, p, x)
    const b = ls(y, d, h, { nodeOrigin: w, nodeExtent: m, elevateNodesOnSelect: !1 })
    let P = [0, 0, 1]
    if (a && i && o) {
      const S = Br(d, {
          filter: (F) => !!((F.width || F.initialWidth) && (F.height || F.initialHeight)),
        }),
        { x: _, y: M, zoom: T } = jc(S, i, o, l, c, s?.padding ?? 0.1)
      P = [_, M, T]
    }
    return {
      rfId: '1',
      width: i ?? 0,
      height: o ?? 0,
      transform: P,
      nodes: y,
      nodesInitialized: b,
      nodeLookup: d,
      parentLookup: h,
      edges: x,
      edgeLookup: p,
      connectionLookup: g,
      onNodesChange: null,
      onEdgesChange: null,
      hasDefaultNodes: n !== void 0,
      hasDefaultEdges: r !== void 0,
      panZoom: null,
      minZoom: l,
      maxZoom: c,
      translateExtent: mr,
      nodeExtent: m,
      nodesSelectionActive: !1,
      userSelectionActive: !1,
      userSelectionRect: null,
      connectionMode: Mn.Strict,
      domNode: null,
      paneDragging: !1,
      noPanClassName: 'nopan',
      nodeOrigin: w,
      nodeDragThreshold: 1,
      connectionDragThreshold: 1,
      snapGrid: [15, 15],
      snapToGrid: !1,
      nodesDraggable: !0,
      nodesConnectable: !0,
      nodesFocusable: !0,
      edgesFocusable: !0,
      edgesReconnectable: !0,
      elementsSelectable: !0,
      elevateNodesOnSelect: !0,
      elevateEdgesOnSelect: !1,
      selectNodesOnDrag: !0,
      multiSelectionActive: !1,
      fitViewQueued: a ?? !1,
      fitViewOptions: s,
      fitViewResolver: null,
      connection: { ...lg },
      connectionClickStartHandle: null,
      connectOnClick: !0,
      ariaLiveMessage: '',
      autoPanOnConnect: !0,
      autoPanOnNodeDrag: !0,
      autoPanOnNodeFocus: !0,
      autoPanSpeed: 15,
      connectionRadius: 20,
      onError: RD,
      isValidConnection: void 0,
      onSelectionChangeHandlers: [],
      lib: 'react',
      debug: !1,
      ariaLabelConfig: cg,
    }
  },
  hj = ({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: i,
    height: o,
    fitView: a,
    fitViewOptions: s,
    minZoom: l,
    maxZoom: c,
    nodeOrigin: u,
    nodeExtent: f,
  }) =>
    Ny((d, h) => {
      async function g() {
        const {
          nodeLookup: p,
          panZoom: x,
          fitViewOptions: y,
          fitViewResolver: w,
          width: m,
          height: b,
          minZoom: P,
          maxZoom: S,
        } = h()
        x &&
          (await LD({ nodes: p, width: m, height: b, panZoom: x, minZoom: P, maxZoom: S }, y),
          w?.resolve(!0),
          d({ fitViewResolver: null }))
      }
      return {
        ...rd({
          nodes: e,
          edges: t,
          width: i,
          height: o,
          fitView: a,
          fitViewOptions: s,
          minZoom: l,
          maxZoom: c,
          nodeOrigin: u,
          nodeExtent: f,
          defaultNodes: n,
          defaultEdges: r,
        }),
        setNodes: (p) => {
          const {
              nodeLookup: x,
              parentLookup: y,
              nodeOrigin: w,
              elevateNodesOnSelect: m,
              fitViewQueued: b,
            } = h(),
            P = ls(p, x, y, {
              nodeOrigin: w,
              nodeExtent: f,
              elevateNodesOnSelect: m,
              checkEquality: !0,
            })
          b && P
            ? (g(), d({ nodes: p, nodesInitialized: P, fitViewQueued: !1, fitViewOptions: void 0 }))
            : d({ nodes: p, nodesInitialized: P })
        },
        setEdges: (p) => {
          const { connectionLookup: x, edgeLookup: y } = h()
          ;(Og(x, y, p), d({ edges: p }))
        },
        setDefaultNodesAndEdges: (p, x) => {
          if (p) {
            const { setNodes: y } = h()
            ;(y(p), d({ hasDefaultNodes: !0 }))
          }
          if (x) {
            const { setEdges: y } = h()
            ;(y(x), d({ hasDefaultEdges: !0 }))
          }
        },
        updateNodeInternals: (p) => {
          const {
              triggerNodeChanges: x,
              nodeLookup: y,
              parentLookup: w,
              domNode: m,
              nodeOrigin: b,
              nodeExtent: P,
              debug: S,
              fitViewQueued: _,
            } = h(),
            { changes: M, updatedInternals: T } = sI(p, y, w, m, b, P)
          T &&
            (rI(y, w, { nodeOrigin: b, nodeExtent: P }),
            _ ? (g(), d({ fitViewQueued: !1, fitViewOptions: void 0 })) : d({}),
            M?.length > 0 && (S && console.log('React Flow: trigger node changes', M), x?.(M)))
        },
        updateNodePositions: (p, x = !1) => {
          const y = [],
            w = [],
            { nodeLookup: m, triggerNodeChanges: b } = h()
          for (const [P, S] of p) {
            const _ = m.get(P),
              M = !!(_?.expandParent && _?.parentId && S?.position),
              T = {
                id: P,
                type: 'position',
                position: M
                  ? { x: Math.max(0, S.position.x), y: Math.max(0, S.position.y) }
                  : S.position,
                dragging: x,
              }
            ;(M &&
              _.parentId &&
              y.push({
                id: P,
                parentId: _.parentId,
                rect: {
                  ...S.internals.positionAbsolute,
                  width: S.measured.width ?? 0,
                  height: S.measured.height ?? 0,
                },
              }),
              w.push(T))
          }
          if (y.length > 0) {
            const { parentLookup: P, nodeOrigin: S } = h(),
              _ = Bc(y, m, P, S)
            w.push(..._)
          }
          b(w)
        },
        triggerNodeChanges: (p) => {
          const { onNodesChange: x, setNodes: y, nodes: w, hasDefaultNodes: m, debug: b } = h()
          if (p?.length) {
            if (m) {
              const P = Hg(p, w)
              y(P)
            }
            ;(b && console.log('React Flow: trigger node changes', p), x?.(p))
          }
        },
        triggerEdgeChanges: (p) => {
          const { onEdgesChange: x, setEdges: y, edges: w, hasDefaultEdges: m, debug: b } = h()
          if (p?.length) {
            if (m) {
              const P = Fg(p, w)
              y(P)
            }
            ;(b && console.log('React Flow: trigger edge changes', p), x?.(p))
          }
        },
        addSelectedNodes: (p) => {
          const {
            multiSelectionActive: x,
            edgeLookup: y,
            nodeLookup: w,
            triggerNodeChanges: m,
            triggerEdgeChanges: b,
          } = h()
          if (x) {
            const P = p.map((S) => Gt(S, !0))
            m(P)
            return
          }
          ;(m(yn(w, new Set([...p]), !0)), b(yn(y)))
        },
        addSelectedEdges: (p) => {
          const {
            multiSelectionActive: x,
            edgeLookup: y,
            nodeLookup: w,
            triggerNodeChanges: m,
            triggerEdgeChanges: b,
          } = h()
          if (x) {
            const P = p.map((S) => Gt(S, !0))
            b(P)
            return
          }
          ;(b(yn(y, new Set([...p]))), m(yn(w, new Set(), !0)))
        },
        unselectNodesAndEdges: ({ nodes: p, edges: x } = {}) => {
          const {
              edges: y,
              nodes: w,
              nodeLookup: m,
              triggerNodeChanges: b,
              triggerEdgeChanges: P,
            } = h(),
            S = p || w,
            _ = x || y,
            M = S.map((F) => {
              const D = m.get(F.id)
              return (D && (D.selected = !1), Gt(F.id, !1))
            }),
            T = _.map((F) => Gt(F.id, !1))
          ;(b(M), P(T))
        },
        setMinZoom: (p) => {
          const { panZoom: x, maxZoom: y } = h()
          ;(x?.setScaleExtent([p, y]), d({ minZoom: p }))
        },
        setMaxZoom: (p) => {
          const { panZoom: x, minZoom: y } = h()
          ;(x?.setScaleExtent([y, p]), d({ maxZoom: p }))
        },
        setTranslateExtent: (p) => {
          ;(h().panZoom?.setTranslateExtent(p), d({ translateExtent: p }))
        },
        setPaneClickDistance: (p) => {
          h().panZoom?.setClickDistance(p)
        },
        resetSelectedElements: () => {
          const {
            edges: p,
            nodes: x,
            triggerNodeChanges: y,
            triggerEdgeChanges: w,
            elementsSelectable: m,
          } = h()
          if (!m) return
          const b = x.reduce((S, _) => (_.selected ? [...S, Gt(_.id, !1)] : S), []),
            P = p.reduce((S, _) => (_.selected ? [...S, Gt(_.id, !1)] : S), [])
          ;(y(b), w(P))
        },
        setNodeExtent: (p) => {
          const {
            nodes: x,
            nodeLookup: y,
            parentLookup: w,
            nodeOrigin: m,
            elevateNodesOnSelect: b,
            nodeExtent: P,
          } = h()
          ;(p[0][0] === P[0][0] &&
            p[0][1] === P[0][1] &&
            p[1][0] === P[1][0] &&
            p[1][1] === P[1][1]) ||
            (ls(x, y, w, {
              nodeOrigin: m,
              nodeExtent: p,
              elevateNodesOnSelect: b,
              checkEquality: !1,
            }),
            d({ nodeExtent: p }))
        },
        panBy: (p) => {
          const { transform: x, width: y, height: w, panZoom: m, translateExtent: b } = h()
          return cI({ delta: p, panZoom: m, transform: x, translateExtent: b, width: y, height: w })
        },
        setCenter: async (p, x, y) => {
          const { width: w, height: m, maxZoom: b, panZoom: P } = h()
          if (!P) return Promise.resolve(!1)
          const S = typeof y?.zoom < 'u' ? y.zoom : b
          return (
            await P.setViewport(
              { x: w / 2 - p * S, y: m / 2 - x * S, zoom: S },
              { duration: y?.duration, ease: y?.ease, interpolate: y?.interpolate },
            ),
            Promise.resolve(!0)
          )
        },
        cancelConnection: () => {
          d({ connection: { ...lg } })
        },
        updateConnection: (p) => {
          d({ connection: p })
        },
        reset: () => d({ ...rd() }),
      }
    }, Object.is)
function pj({
  initialNodes: e,
  initialEdges: t,
  defaultNodes: n,
  defaultEdges: r,
  initialWidth: i,
  initialHeight: o,
  initialMinZoom: a,
  initialMaxZoom: s,
  initialFitViewOptions: l,
  fitView: c,
  nodeOrigin: u,
  nodeExtent: f,
  children: d,
}) {
  const [h] = v.useState(() =>
    hj({
      nodes: e,
      edges: t,
      defaultNodes: n,
      defaultEdges: r,
      width: i,
      height: o,
      fitView: c,
      minZoom: a,
      maxZoom: s,
      fitViewOptions: l,
      nodeOrigin: u,
      nodeExtent: f,
    }),
  )
  return z.jsx(NI, { value: h, children: z.jsx(t2, { children: d }) })
}
function vj({
  children: e,
  nodes: t,
  edges: n,
  defaultNodes: r,
  defaultEdges: i,
  width: o,
  height: a,
  fitView: s,
  fitViewOptions: l,
  minZoom: c,
  maxZoom: u,
  nodeOrigin: f,
  nodeExtent: d,
}) {
  return v.useContext(Vo)
    ? z.jsx(z.Fragment, { children: e })
    : z.jsx(pj, {
        initialNodes: t,
        initialEdges: n,
        defaultNodes: r,
        defaultEdges: i,
        initialWidth: o,
        initialHeight: a,
        fitView: s,
        initialFitViewOptions: l,
        initialMinZoom: c,
        initialMaxZoom: u,
        nodeOrigin: f,
        nodeExtent: d,
        children: e,
      })
}
const gj = { width: '100%', height: '100%', overflow: 'hidden', position: 'relative', zIndex: 0 }
function mj(
  {
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    className: i,
    nodeTypes: o,
    edgeTypes: a,
    onNodeClick: s,
    onEdgeClick: l,
    onInit: c,
    onMove: u,
    onMoveStart: f,
    onMoveEnd: d,
    onConnect: h,
    onConnectStart: g,
    onConnectEnd: p,
    onClickConnectStart: x,
    onClickConnectEnd: y,
    onNodeMouseEnter: w,
    onNodeMouseMove: m,
    onNodeMouseLeave: b,
    onNodeContextMenu: P,
    onNodeDoubleClick: S,
    onNodeDragStart: _,
    onNodeDrag: M,
    onNodeDragStop: T,
    onNodesDelete: F,
    onEdgesDelete: D,
    onDelete: k,
    onSelectionChange: $,
    onSelectionDragStart: E,
    onSelectionDrag: O,
    onSelectionDragStop: A,
    onSelectionContextMenu: C,
    onSelectionStart: N,
    onSelectionEnd: I,
    onBeforeDelete: H,
    connectionMode: V,
    connectionLineType: B = Rt.Bezier,
    connectionLineStyle: Y,
    connectionLineComponent: K,
    connectionLineContainerStyle: G,
    deleteKeyCode: re = 'Backspace',
    selectionKeyCode: q = 'Shift',
    selectionOnDrag: W = !1,
    selectionMode: j = yr.Full,
    panActivationKeyCode: U = 'Space',
    multiSelectionKeyCode: X = br() ? 'Meta' : 'Control',
    zoomActivationKeyCode: L = br() ? 'Meta' : 'Control',
    snapToGrid: Q,
    snapGrid: Z,
    onlyRenderVisibleElements: ne = !1,
    selectNodesOnDrag: ae,
    nodesDraggable: ue,
    autoPanOnNodeFocus: Ye,
    nodesConnectable: Vr,
    nodesFocusable: Wr,
    nodeOrigin: Kr = Rg,
    edgesFocusable: Vn,
    edgesReconnectable: Wn,
    elementsSelectable: Uo = !0,
    defaultViewport: Yr = KI,
    minZoom: dn = 0.5,
    maxZoom: Kn = 2,
    translateExtent: Vc = mr,
    preventScrolling: mm = !0,
    nodeExtent: Xo,
    defaultMarkerColor: ym = '#b1b1b7',
    zoomOnScroll: xm = !0,
    zoomOnPinch: bm = !0,
    panOnScroll: wm = !1,
    panOnScrollSpeed: Pm = 0.5,
    panOnScrollMode: Sm = en.Free,
    zoomOnDoubleClick: Em = !0,
    panOnDrag: _m = !0,
    onPaneClick: Am,
    onPaneMouseEnter: Om,
    onPaneMouseMove: Cm,
    onPaneMouseLeave: km,
    onPaneScroll: Mm,
    onPaneContextMenu: Tm,
    paneClickDistance: Wc = 0,
    nodeClickDistance: Nm = 0,
    children: Dm,
    onReconnect: Im,
    onReconnectStart: jm,
    onReconnectEnd: $m,
    onEdgeContextMenu: Lm,
    onEdgeDoubleClick: zm,
    onEdgeMouseEnter: Rm,
    onEdgeMouseMove: Bm,
    onEdgeMouseLeave: Hm,
    reconnectRadius: Fm = 10,
    onNodesChange: Vm,
    onEdgesChange: Wm,
    noDragClassName: Km = 'nodrag',
    noWheelClassName: Ym = 'nowheel',
    noPanClassName: Kc = 'nopan',
    fitView: Yc,
    fitViewOptions: Uc,
    connectOnClick: Um,
    attributionPosition: Xm,
    proOptions: Gm,
    defaultEdgeOptions: qm,
    elevateNodesOnSelect: Zm,
    elevateEdgesOnSelect: Qm,
    disableKeyboardA11y: Xc = !1,
    autoPanOnConnect: Jm,
    autoPanOnNodeDrag: ey,
    autoPanSpeed: ty,
    connectionRadius: ny,
    isValidConnection: ry,
    onError: iy,
    style: oy,
    id: Gc,
    nodeDragThreshold: ay,
    connectionDragThreshold: sy,
    viewport: cy,
    onViewportChange: ly,
    width: uy,
    height: fy,
    colorMode: dy = 'light',
    debug: hy,
    onScroll: qc,
    ariaLabelConfig: py,
    ...vy
  },
  gy,
) {
  const Go = Gc || '1',
    my = GI(dy),
    yy = v.useCallback(
      (Zc) => {
        ;(Zc.currentTarget.scrollTo({ top: 0, left: 0, behavior: 'instant' }), qc?.(Zc))
      },
      [qc],
    )
  return z.jsx('div', {
    'data-testid': 'rf__wrapper',
    ...vy,
    onScroll: yy,
    style: { ...oy, ...gj },
    ref: gy,
    className: ye(['react-flow', i, my]),
    id: Gc,
    role: 'application',
    children: z.jsxs(vj, {
      nodes: e,
      edges: t,
      width: uy,
      height: fy,
      fitView: Yc,
      fitViewOptions: Uc,
      minZoom: dn,
      maxZoom: Kn,
      nodeOrigin: Kr,
      nodeExtent: Xo,
      children: [
        z.jsx(dj, {
          onInit: c,
          onNodeClick: s,
          onEdgeClick: l,
          onNodeMouseEnter: w,
          onNodeMouseMove: m,
          onNodeMouseLeave: b,
          onNodeContextMenu: P,
          onNodeDoubleClick: S,
          nodeTypes: o,
          edgeTypes: a,
          connectionLineType: B,
          connectionLineStyle: Y,
          connectionLineComponent: K,
          connectionLineContainerStyle: G,
          selectionKeyCode: q,
          selectionOnDrag: W,
          selectionMode: j,
          deleteKeyCode: re,
          multiSelectionKeyCode: X,
          panActivationKeyCode: U,
          zoomActivationKeyCode: L,
          onlyRenderVisibleElements: ne,
          defaultViewport: Yr,
          translateExtent: Vc,
          minZoom: dn,
          maxZoom: Kn,
          preventScrolling: mm,
          zoomOnScroll: xm,
          zoomOnPinch: bm,
          zoomOnDoubleClick: Em,
          panOnScroll: wm,
          panOnScrollSpeed: Pm,
          panOnScrollMode: Sm,
          panOnDrag: _m,
          onPaneClick: Am,
          onPaneMouseEnter: Om,
          onPaneMouseMove: Cm,
          onPaneMouseLeave: km,
          onPaneScroll: Mm,
          onPaneContextMenu: Tm,
          paneClickDistance: Wc,
          nodeClickDistance: Nm,
          onSelectionContextMenu: C,
          onSelectionStart: N,
          onSelectionEnd: I,
          onReconnect: Im,
          onReconnectStart: jm,
          onReconnectEnd: $m,
          onEdgeContextMenu: Lm,
          onEdgeDoubleClick: zm,
          onEdgeMouseEnter: Rm,
          onEdgeMouseMove: Bm,
          onEdgeMouseLeave: Hm,
          reconnectRadius: Fm,
          defaultMarkerColor: ym,
          noDragClassName: Km,
          noWheelClassName: Ym,
          noPanClassName: Kc,
          rfId: Go,
          disableKeyboardA11y: Xc,
          nodeExtent: Xo,
          viewport: cy,
          onViewportChange: ly,
        }),
        z.jsx(XI, {
          nodes: e,
          edges: t,
          defaultNodes: n,
          defaultEdges: r,
          onConnect: h,
          onConnectStart: g,
          onConnectEnd: p,
          onClickConnectStart: x,
          onClickConnectEnd: y,
          nodesDraggable: ue,
          autoPanOnNodeFocus: Ye,
          nodesConnectable: Vr,
          nodesFocusable: Wr,
          edgesFocusable: Vn,
          edgesReconnectable: Wn,
          elementsSelectable: Uo,
          elevateNodesOnSelect: Zm,
          elevateEdgesOnSelect: Qm,
          minZoom: dn,
          maxZoom: Kn,
          nodeExtent: Xo,
          onNodesChange: Vm,
          onEdgesChange: Wm,
          snapToGrid: Q,
          snapGrid: Z,
          connectionMode: V,
          translateExtent: Vc,
          connectOnClick: Um,
          defaultEdgeOptions: qm,
          fitView: Yc,
          fitViewOptions: Uc,
          onNodesDelete: F,
          onEdgesDelete: D,
          onDelete: k,
          onNodeDragStart: _,
          onNodeDrag: M,
          onNodeDragStop: T,
          onSelectionDrag: O,
          onSelectionDragStart: E,
          onSelectionDragStop: A,
          onMove: u,
          onMoveStart: f,
          onMoveEnd: d,
          noPanClassName: Kc,
          nodeOrigin: Kr,
          rfId: Go,
          autoPanOnConnect: Jm,
          autoPanOnNodeDrag: ey,
          autoPanSpeed: ty,
          onError: iy,
          connectionRadius: ny,
          isValidConnection: ry,
          selectNodesOnDrag: ae,
          nodeDragThreshold: ay,
          connectionDragThreshold: sy,
          onBeforeDelete: H,
          paneClickDistance: Wc,
          debug: hy,
          ariaLabelConfig: py,
        }),
        z.jsx(WI, { onSelectionChange: $ }),
        Dm,
        z.jsx(RI, { proOptions: Gm, position: Xm }),
        z.jsx(zI, { rfId: Go, disableKeyboardA11y: Xc }),
      ],
    }),
  })
}
var F$ = Vg(mj)
function V$(e) {
  const [t, n] = v.useState(e),
    r = v.useCallback((i) => n((o) => Hg(i, o)), [])
  return [t, n, r]
}
function W$(e) {
  const [t, n] = v.useState(e),
    r = v.useCallback((i) => n((o) => Fg(i, o)), [])
  return [t, n, r]
}
function yj({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return z.jsx('path', {
    strokeWidth: t,
    d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`,
    className: ye(['react-flow__background-pattern', n, r]),
  })
}
function xj({ radius: e, className: t }) {
  return z.jsx('circle', {
    cx: e,
    cy: e,
    r: e,
    className: ye(['react-flow__background-pattern', 'dots', t]),
  })
}
var Vt
;(function (e) {
  ;((e.Lines = 'lines'), (e.Dots = 'dots'), (e.Cross = 'cross'))
})(Vt || (Vt = {}))
const bj = { [Vt.Dots]: 1, [Vt.Lines]: 1, [Vt.Cross]: 6 },
  wj = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` })
function hm({
  id: e,
  variant: t = Vt.Dots,
  gap: n = 20,
  size: r,
  lineWidth: i = 1,
  offset: o = 0,
  color: a,
  bgColor: s,
  style: l,
  className: c,
  patternClassName: u,
}) {
  const f = v.useRef(null),
    { transform: d, patternId: h } = ie(wj, de),
    g = r || bj[t],
    p = t === Vt.Dots,
    x = t === Vt.Cross,
    y = Array.isArray(n) ? n : [n, n],
    w = [y[0] * d[2] || 1, y[1] * d[2] || 1],
    m = g * d[2],
    b = Array.isArray(o) ? o : [o, o],
    P = x ? [m, m] : w,
    S = [b[0] * d[2] || 1 + P[0] / 2, b[1] * d[2] || 1 + P[1] / 2],
    _ = `${h}${e || ''}`
  return z.jsxs('svg', {
    className: ye(['react-flow__background', c]),
    style: {
      ...l,
      ...Ko,
      '--xy-background-color-props': s,
      '--xy-background-pattern-color-props': a,
    },
    ref: f,
    'data-testid': 'rf__background',
    children: [
      z.jsx('pattern', {
        id: _,
        x: d[0] % w[0],
        y: d[1] % w[1],
        width: w[0],
        height: w[1],
        patternUnits: 'userSpaceOnUse',
        patternTransform: `translate(-${S[0]},-${S[1]})`,
        children: p
          ? z.jsx(xj, { radius: m / 2, className: u })
          : z.jsx(yj, { dimensions: P, lineWidth: i, variant: t, className: u }),
      }),
      z.jsx('rect', { x: '0', y: '0', width: '100%', height: '100%', fill: `url(#${_})` }),
    ],
  })
}
hm.displayName = 'Background'
const K$ = v.memo(hm)
function Pj() {
  return z.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 32 32',
    children: z.jsx('path', {
      d: 'M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z',
    }),
  })
}
function Sj() {
  return z.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 32 5',
    children: z.jsx('path', { d: 'M0 0h32v4.2H0z' }),
  })
}
function Ej() {
  return z.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 32 30',
    children: z.jsx('path', {
      d: 'M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z',
    }),
  })
}
function _j() {
  return z.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 25 32',
    children: z.jsx('path', {
      d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z',
    }),
  })
}
function Aj() {
  return z.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 25 32',
    children: z.jsx('path', {
      d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z',
    }),
  })
}
function fi({ children: e, className: t, ...n }) {
  return z.jsx('button', {
    type: 'button',
    className: ye(['react-flow__controls-button', t]),
    ...n,
    children: e,
  })
}
const Oj = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom,
  ariaLabelConfig: e.ariaLabelConfig,
})
function pm({
  style: e,
  showZoom: t = !0,
  showFitView: n = !0,
  showInteractive: r = !0,
  fitViewOptions: i,
  onZoomIn: o,
  onZoomOut: a,
  onFitView: s,
  onInteractiveChange: l,
  className: c,
  children: u,
  position: f = 'bottom-left',
  orientation: d = 'vertical',
  'aria-label': h,
}) {
  const g = fe(),
    { isInteractive: p, minZoomReached: x, maxZoomReached: y, ariaLabelConfig: w } = ie(Oj, de),
    { zoomIn: m, zoomOut: b, fitView: P } = Hc(),
    S = () => {
      ;(m(), o?.())
    },
    _ = () => {
      ;(b(), a?.())
    },
    M = () => {
      ;(P(i), s?.())
    },
    T = () => {
      ;(g.setState({ nodesDraggable: !p, nodesConnectable: !p, elementsSelectable: !p }), l?.(!p))
    },
    F = d === 'horizontal' ? 'horizontal' : 'vertical'
  return z.jsxs(Wo, {
    className: ye(['react-flow__controls', F, c]),
    position: f,
    style: e,
    'data-testid': 'rf__controls',
    'aria-label': h ?? w['controls.ariaLabel'],
    children: [
      t &&
        z.jsxs(z.Fragment, {
          children: [
            z.jsx(fi, {
              onClick: S,
              className: 'react-flow__controls-zoomin',
              title: w['controls.zoomIn.ariaLabel'],
              'aria-label': w['controls.zoomIn.ariaLabel'],
              disabled: y,
              children: z.jsx(Pj, {}),
            }),
            z.jsx(fi, {
              onClick: _,
              className: 'react-flow__controls-zoomout',
              title: w['controls.zoomOut.ariaLabel'],
              'aria-label': w['controls.zoomOut.ariaLabel'],
              disabled: x,
              children: z.jsx(Sj, {}),
            }),
          ],
        }),
      n &&
        z.jsx(fi, {
          className: 'react-flow__controls-fitview',
          onClick: M,
          title: w['controls.fitView.ariaLabel'],
          'aria-label': w['controls.fitView.ariaLabel'],
          children: z.jsx(Ej, {}),
        }),
      r &&
        z.jsx(fi, {
          className: 'react-flow__controls-interactive',
          onClick: T,
          title: w['controls.interactive.ariaLabel'],
          'aria-label': w['controls.interactive.ariaLabel'],
          children: p ? z.jsx(Aj, {}) : z.jsx(_j, {}),
        }),
      u,
    ],
  })
}
pm.displayName = 'Controls'
const Y$ = v.memo(pm)
function Cj({
  id: e,
  x: t,
  y: n,
  width: r,
  height: i,
  style: o,
  color: a,
  strokeColor: s,
  strokeWidth: l,
  className: c,
  borderRadius: u,
  shapeRendering: f,
  selected: d,
  onClick: h,
}) {
  const { background: g, backgroundColor: p } = o || {},
    x = a || g || p
  return z.jsx('rect', {
    className: ye(['react-flow__minimap-node', { selected: d }, c]),
    x: t,
    y: n,
    rx: u,
    ry: u,
    width: r,
    height: i,
    style: { fill: x, stroke: s, strokeWidth: l },
    shapeRendering: f,
    onClick: h ? (y) => h(y, e) : void 0,
  })
}
const kj = v.memo(Cj),
  Mj = (e) => e.nodes.map((t) => t.id),
  ga = (e) => (e instanceof Function ? e : () => e)
function Tj({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = '',
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: i,
  nodeComponent: o = kj,
  onClick: a,
}) {
  const s = ie(Mj, de),
    l = ga(t),
    c = ga(e),
    u = ga(n),
    f = typeof window > 'u' || window.chrome ? 'crispEdges' : 'geometricPrecision'
  return z.jsx(z.Fragment, {
    children: s.map((d) =>
      z.jsx(
        Dj,
        {
          id: d,
          nodeColorFunc: l,
          nodeStrokeColorFunc: c,
          nodeClassNameFunc: u,
          nodeBorderRadius: r,
          nodeStrokeWidth: i,
          NodeComponent: o,
          onClick: a,
          shapeRendering: f,
        },
        d,
      ),
    ),
  })
}
function Nj({
  id: e,
  nodeColorFunc: t,
  nodeStrokeColorFunc: n,
  nodeClassNameFunc: r,
  nodeBorderRadius: i,
  nodeStrokeWidth: o,
  shapeRendering: a,
  NodeComponent: s,
  onClick: l,
}) {
  const {
    node: c,
    x: u,
    y: f,
    width: d,
    height: h,
  } = ie((g) => {
    const { internals: p } = g.nodeLookup.get(e),
      x = p.userNode,
      { x: y, y: w } = p.positionAbsolute,
      { width: m, height: b } = It(x)
    return { node: x, x: y, y: w, width: m, height: b }
  }, de)
  return !c || c.hidden || !gg(c)
    ? null
    : z.jsx(s, {
        x: u,
        y: f,
        width: d,
        height: h,
        style: c.style,
        selected: !!c.selected,
        className: r(c),
        color: t(c),
        borderRadius: i,
        strokeColor: n(c),
        strokeWidth: o,
        shapeRendering: a,
        onClick: l,
        id: c.id,
      })
}
const Dj = v.memo(Nj)
var Ij = v.memo(Tj)
const jj = 200,
  $j = 150,
  Lj = (e) => !e.hidden,
  zj = (e) => {
    const t = {
      x: -e.transform[0] / e.transform[2],
      y: -e.transform[1] / e.transform[2],
      width: e.width / e.transform[2],
      height: e.height / e.transform[2],
    }
    return {
      viewBB: t,
      boundingRect: e.nodeLookup.size > 0 ? vg(Br(e.nodeLookup, { filter: Lj }), t) : t,
      rfId: e.rfId,
      panZoom: e.panZoom,
      translateExtent: e.translateExtent,
      flowWidth: e.width,
      flowHeight: e.height,
      ariaLabelConfig: e.ariaLabelConfig,
    }
  },
  Rj = 'react-flow__minimap-desc'
function vm({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: i = '',
  nodeBorderRadius: o = 5,
  nodeStrokeWidth: a,
  nodeComponent: s,
  bgColor: l,
  maskColor: c,
  maskStrokeColor: u,
  maskStrokeWidth: f,
  position: d = 'bottom-right',
  onClick: h,
  onNodeClick: g,
  pannable: p = !1,
  zoomable: x = !1,
  ariaLabel: y,
  inversePan: w,
  zoomStep: m = 1,
  offsetScale: b = 5,
}) {
  const P = fe(),
    S = v.useRef(null),
    {
      boundingRect: _,
      viewBB: M,
      rfId: T,
      panZoom: F,
      translateExtent: D,
      flowWidth: k,
      flowHeight: $,
      ariaLabelConfig: E,
    } = ie(zj, de),
    O = e?.width ?? jj,
    A = e?.height ?? $j,
    C = _.width / O,
    N = _.height / A,
    I = Math.max(C, N),
    H = I * O,
    V = I * A,
    B = b * I,
    Y = _.x - (H - _.width) / 2 - B,
    K = _.y - (V - _.height) / 2 - B,
    G = H + B * 2,
    re = V + B * 2,
    q = `${Rj}-${T}`,
    W = v.useRef(0),
    j = v.useRef()
  ;((W.current = I),
    v.useEffect(() => {
      if (S.current && F)
        return (
          (j.current = mI({
            domNode: S.current,
            panZoom: F,
            getTransform: () => P.getState().transform,
            getViewScale: () => W.current,
          })),
          () => {
            j.current?.destroy()
          }
        )
    }, [F]),
    v.useEffect(() => {
      j.current?.update({
        translateExtent: D,
        width: k,
        height: $,
        inversePan: w,
        pannable: p,
        zoomStep: m,
        zoomable: x,
      })
    }, [p, x, w, m, D, k, $]))
  const U = h
      ? (Q) => {
          const [Z, ne] = j.current?.pointer(Q) || [0, 0]
          h(Q, { x: Z, y: ne })
        }
      : void 0,
    X = g
      ? v.useCallback((Q, Z) => {
          const ne = P.getState().nodeLookup.get(Z).internals.userNode
          g(Q, ne)
        }, [])
      : void 0,
    L = y ?? E['minimap.ariaLabel']
  return z.jsx(Wo, {
    position: d,
    style: {
      ...e,
      '--xy-minimap-background-color-props': typeof l == 'string' ? l : void 0,
      '--xy-minimap-mask-background-color-props': typeof c == 'string' ? c : void 0,
      '--xy-minimap-mask-stroke-color-props': typeof u == 'string' ? u : void 0,
      '--xy-minimap-mask-stroke-width-props': typeof f == 'number' ? f * I : void 0,
      '--xy-minimap-node-background-color-props': typeof r == 'string' ? r : void 0,
      '--xy-minimap-node-stroke-color-props': typeof n == 'string' ? n : void 0,
      '--xy-minimap-node-stroke-width-props': typeof a == 'number' ? a : void 0,
    },
    className: ye(['react-flow__minimap', t]),
    'data-testid': 'rf__minimap',
    children: z.jsxs('svg', {
      width: O,
      height: A,
      viewBox: `${Y} ${K} ${G} ${re}`,
      className: 'react-flow__minimap-svg',
      role: 'img',
      'aria-labelledby': q,
      ref: S,
      onClick: U,
      children: [
        L && z.jsx('title', { id: q, children: L }),
        z.jsx(Ij, {
          onClick: X,
          nodeColor: r,
          nodeStrokeColor: n,
          nodeBorderRadius: o,
          nodeClassName: i,
          nodeStrokeWidth: a,
          nodeComponent: s,
        }),
        z.jsx('path', {
          className: 'react-flow__minimap-mask',
          d: `M${Y - B},${K - B}h${G + B * 2}v${re + B * 2}h${-G - B * 2}z
        M${M.x},${M.y}h${M.width}v${M.height}h${-M.width}z`,
          fillRule: 'evenodd',
          pointerEvents: 'none',
        }),
      ],
    }),
  })
}
vm.displayName = 'MiniMap'
v.memo(vm)
const Bj = (e) => (t) => (e ? `${Math.max(1 / t.transform[2], 1)}` : void 0),
  Hj = { [In.Line]: 'right', [In.Handle]: 'bottom-right' }
function Fj({
  nodeId: e,
  position: t,
  variant: n = In.Handle,
  className: r,
  style: i = void 0,
  children: o,
  color: a,
  minWidth: s = 10,
  minHeight: l = 10,
  maxWidth: c = Number.MAX_VALUE,
  maxHeight: u = Number.MAX_VALUE,
  keepAspectRatio: f = !1,
  resizeDirection: d,
  autoScale: h = !0,
  shouldResize: g,
  onResizeStart: p,
  onResize: x,
  onResizeEnd: y,
}) {
  const w = Ug(),
    m = typeof e == 'string' ? e : w,
    b = fe(),
    P = v.useRef(null),
    S = n === In.Handle,
    _ = ie(v.useCallback(Bj(S && h), [S, h]), de),
    M = v.useRef(null),
    T = t ?? Hj[n]
  v.useEffect(() => {
    if (!(!P.current || !m))
      return (
        M.current ||
          (M.current = TI({
            domNode: P.current,
            nodeId: m,
            getStoreItems: () => {
              const {
                nodeLookup: D,
                transform: k,
                snapGrid: $,
                snapToGrid: E,
                nodeOrigin: O,
                domNode: A,
              } = b.getState()
              return {
                nodeLookup: D,
                transform: k,
                snapGrid: $,
                snapToGrid: E,
                nodeOrigin: O,
                paneDomNode: A,
              }
            },
            onChange: (D, k) => {
              const {
                  triggerNodeChanges: $,
                  nodeLookup: E,
                  parentLookup: O,
                  nodeOrigin: A,
                } = b.getState(),
                C = [],
                N = { x: D.x, y: D.y },
                I = E.get(m)
              if (I && I.expandParent && I.parentId) {
                const H = I.origin ?? A,
                  V = D.width ?? I.measured.width ?? 0,
                  B = D.height ?? I.measured.height ?? 0,
                  Y = {
                    id: I.id,
                    parentId: I.parentId,
                    rect: {
                      width: V,
                      height: B,
                      ...mg(
                        { x: D.x ?? I.position.x, y: D.y ?? I.position.y },
                        { width: V, height: B },
                        I.parentId,
                        E,
                        H,
                      ),
                    },
                  },
                  K = Bc([Y], E, O, A)
                ;(C.push(...K),
                  (N.x = D.x ? Math.max(H[0] * V, D.x) : void 0),
                  (N.y = D.y ? Math.max(H[1] * B, D.y) : void 0))
              }
              if (N.x !== void 0 && N.y !== void 0) {
                const H = { id: m, type: 'position', position: { ...N } }
                C.push(H)
              }
              if (D.width !== void 0 && D.height !== void 0) {
                const V = {
                  id: m,
                  type: 'dimensions',
                  resizing: !0,
                  setAttributes: d ? (d === 'horizontal' ? 'width' : 'height') : !0,
                  dimensions: { width: D.width, height: D.height },
                }
                C.push(V)
              }
              for (const H of k) {
                const V = { ...H, type: 'position' }
                C.push(V)
              }
              $(C)
            },
            onEnd: ({ width: D, height: k }) => {
              const $ = {
                id: m,
                type: 'dimensions',
                resizing: !1,
                dimensions: { width: D, height: k },
              }
              b.getState().triggerNodeChanges([$])
            },
          })),
        M.current.update({
          controlPosition: T,
          boundaries: { minWidth: s, minHeight: l, maxWidth: c, maxHeight: u },
          keepAspectRatio: f,
          resizeDirection: d,
          onResizeStart: p,
          onResize: x,
          onResizeEnd: y,
          shouldResize: g,
        }),
        () => {
          M.current?.destroy()
        }
      )
  }, [T, s, l, c, u, f, p, x, y, g])
  const F = T.split('-')
  return z.jsx('div', {
    className: ye(['react-flow__resize-control', 'nodrag', ...F, n, r]),
    ref: P,
    style: { ...i, scale: _, ...(a && { [S ? 'backgroundColor' : 'borderColor']: a }) },
    children: o,
  })
}
v.memo(Fj)
function Vj(e) {
  var t = 0,
    n = e.children,
    r = n && n.length
  if (!r) t = 1
  else for (; --r >= 0; ) t += n[r].value
  e.value = t
}
function Wj() {
  return this.eachAfter(Vj)
}
function Kj(e, t) {
  let n = -1
  for (const r of this) e.call(t, r, ++n, this)
  return this
}
function Yj(e, t) {
  for (var n = this, r = [n], i, o, a = -1; (n = r.pop()); )
    if ((e.call(t, n, ++a, this), (i = n.children)))
      for (o = i.length - 1; o >= 0; --o) r.push(i[o])
  return this
}
function Uj(e, t) {
  for (var n = this, r = [n], i = [], o, a, s, l = -1; (n = r.pop()); )
    if ((i.push(n), (o = n.children))) for (a = 0, s = o.length; a < s; ++a) r.push(o[a])
  for (; (n = i.pop()); ) e.call(t, n, ++l, this)
  return this
}
function Xj(e, t) {
  let n = -1
  for (const r of this) if (e.call(t, r, ++n, this)) return r
}
function Gj(e) {
  return this.eachAfter(function (t) {
    for (var n = +e(t.data) || 0, r = t.children, i = r && r.length; --i >= 0; ) n += r[i].value
    t.value = n
  })
}
function qj(e) {
  return this.eachBefore(function (t) {
    t.children && t.children.sort(e)
  })
}
function Zj(e) {
  for (var t = this, n = Qj(t, e), r = [t]; t !== n; ) ((t = t.parent), r.push(t))
  for (var i = r.length; e !== n; ) (r.splice(i, 0, e), (e = e.parent))
  return r
}
function Qj(e, t) {
  if (e === t) return e
  var n = e.ancestors(),
    r = t.ancestors(),
    i = null
  for (e = n.pop(), t = r.pop(); e === t; ) ((i = e), (e = n.pop()), (t = r.pop()))
  return i
}
function Jj() {
  for (var e = this, t = [e]; (e = e.parent); ) t.push(e)
  return t
}
function e$() {
  return Array.from(this)
}
function t$() {
  var e = []
  return (
    this.eachBefore(function (t) {
      t.children || e.push(t)
    }),
    e
  )
}
function n$() {
  var e = this,
    t = []
  return (
    e.each(function (n) {
      n !== e && t.push({ source: n.parent, target: n })
    }),
    t
  )
}
function* r$() {
  var e = this,
    t,
    n = [e],
    r,
    i,
    o
  do
    for (t = n.reverse(), n = []; (e = t.pop()); )
      if ((yield e, (r = e.children))) for (i = 0, o = r.length; i < o; ++i) n.push(r[i])
  while (n.length)
}
function gm(e, t) {
  e instanceof Map ? ((e = [void 0, e]), t === void 0 && (t = a$)) : t === void 0 && (t = o$)
  for (var n = new Sr(e), r, i = [n], o, a, s, l; (r = i.pop()); )
    if ((a = t(r.data)) && (l = (a = Array.from(a)).length))
      for (r.children = a, s = l - 1; s >= 0; --s)
        (i.push((o = a[s] = new Sr(a[s]))), (o.parent = r), (o.depth = r.depth + 1))
  return n.eachBefore(c$)
}
function i$() {
  return gm(this).eachBefore(s$)
}
function o$(e) {
  return e.children
}
function a$(e) {
  return Array.isArray(e) ? e[1] : null
}
function s$(e) {
  ;(e.data.value !== void 0 && (e.value = e.data.value), (e.data = e.data.data))
}
function c$(e) {
  var t = 0
  do e.height = t
  while ((e = e.parent) && e.height < ++t)
}
function Sr(e) {
  ;((this.data = e), (this.depth = this.height = 0), (this.parent = null))
}
Sr.prototype = gm.prototype = {
  constructor: Sr,
  count: Wj,
  each: Kj,
  eachAfter: Uj,
  eachBefore: Yj,
  find: Xj,
  sum: Gj,
  sort: qj,
  path: Zj,
  ancestors: Jj,
  descendants: e$,
  leaves: t$,
  links: n$,
  copy: i$,
  [Symbol.iterator]: r$,
}
function l$(e, t) {
  return e.parent === t.parent ? 1 : 2
}
function ma(e) {
  var t = e.children
  return t ? t[0] : e.t
}
function ya(e) {
  var t = e.children
  return t ? t[t.length - 1] : e.t
}
function u$(e, t, n) {
  var r = n / (t.i - e.i)
  ;((t.c -= r), (t.s += n), (e.c += r), (t.z += n), (t.m += n))
}
function f$(e) {
  for (var t = 0, n = 0, r = e.children, i = r.length, o; --i >= 0; )
    ((o = r[i]), (o.z += t), (o.m += t), (t += o.s + (n += o.c)))
}
function d$(e, t, n) {
  return e.a.parent === t.parent ? e.a : n
}
function bi(e, t) {
  ;((this._ = e),
    (this.parent = null),
    (this.children = null),
    (this.A = null),
    (this.a = this),
    (this.z = 0),
    (this.m = 0),
    (this.c = 0),
    (this.s = 0),
    (this.t = null),
    (this.i = t))
}
bi.prototype = Object.create(Sr.prototype)
function h$(e) {
  for (var t = new bi(e, 0), n, r = [t], i, o, a, s; (n = r.pop()); )
    if ((o = n._.children))
      for (n.children = new Array((s = o.length)), a = s - 1; a >= 0; --a)
        (r.push((i = n.children[a] = new bi(o[a], a))), (i.parent = n))
  return (((t.parent = new bi(null, 0)).children = [t]), t)
}
function U$() {
  var e = l$,
    t = 1,
    n = 1,
    r = null
  function i(c) {
    var u = h$(c)
    if ((u.eachAfter(o), (u.parent.m = -u.z), u.eachBefore(a), r)) c.eachBefore(l)
    else {
      var f = c,
        d = c,
        h = c
      c.eachBefore(function (w) {
        ;(w.x < f.x && (f = w), w.x > d.x && (d = w), w.depth > h.depth && (h = w))
      })
      var g = f === d ? 1 : e(f, d) / 2,
        p = g - f.x,
        x = t / (d.x + g + p),
        y = n / (h.depth || 1)
      c.eachBefore(function (w) {
        ;((w.x = (w.x + p) * x), (w.y = w.depth * y))
      })
    }
    return c
  }
  function o(c) {
    var u = c.children,
      f = c.parent.children,
      d = c.i ? f[c.i - 1] : null
    if (u) {
      f$(c)
      var h = (u[0].z + u[u.length - 1].z) / 2
      d ? ((c.z = d.z + e(c._, d._)), (c.m = c.z - h)) : (c.z = h)
    } else d && (c.z = d.z + e(c._, d._))
    c.parent.A = s(c, d, c.parent.A || f[0])
  }
  function a(c) {
    ;((c._.x = c.z + c.parent.m), (c.m += c.parent.m))
  }
  function s(c, u, f) {
    if (u) {
      for (
        var d = c, h = c, g = u, p = d.parent.children[0], x = d.m, y = h.m, w = g.m, m = p.m, b;
        (g = ya(g)), (d = ma(d)), g && d;

      )
        ((p = ma(p)),
          (h = ya(h)),
          (h.a = c),
          (b = g.z + w - d.z - x + e(g._, d._)),
          b > 0 && (u$(d$(g, c, f), c, b), (x += b), (y += b)),
          (w += g.m),
          (x += d.m),
          (m += p.m),
          (y += h.m))
      ;(g && !ya(h) && ((h.t = g), (h.m += w - y)),
        d && !ma(p) && ((p.t = d), (p.m += x - m), (f = c)))
    }
    return f
  }
  function l(c) {
    ;((c.x *= t), (c.y = c.depth * n))
  }
  return (
    (i.separation = function (c) {
      return arguments.length ? ((e = c), i) : e
    }),
    (i.size = function (c) {
      return arguments.length ? ((r = !1), (t = +c[0]), (n = +c[1]), i) : r ? null : [t, n]
    }),
    (i.nodeSize = function (c) {
      return arguments.length ? ((r = !0), (t = +c[0]), (n = +c[1]), i) : r ? [t, n] : null
    }),
    i
  )
}
export {
  x$ as A,
  f1 as B,
  Ro as C,
  ag as D,
  He as E,
  nt as F,
  Zv as G,
  HC as H,
  Sk as I,
  V$ as J,
  W$ as K,
  _s as L,
  no as M,
  GD as N,
  F$ as O,
  ee as P,
  K$ as Q,
  Y$ as R,
  H$ as S,
  S$ as T,
  gm as U,
  U$ as V,
  Ik as X,
  Kk as Y,
  XP as a,
  ih as b,
  _h as c,
  UP as d,
  w$ as e,
  GP as f,
  Rl as g,
  x1 as h,
  h1 as i,
  vh as j,
  A1 as k,
  d1 as l,
  WP as m,
  Eh as n,
  rh as o,
  g$ as p,
  _1 as q,
  E1 as r,
  VP as s,
  YP as t,
  b$ as u,
  KP as v,
  m$ as w,
  b1 as x,
  O1 as y,
  y$ as z,
}
//# sourceMappingURL=visualization-vendor-f5uYUx4I.js.map
