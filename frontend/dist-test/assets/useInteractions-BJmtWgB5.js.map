{"version":3,"file":"useInteractions-BJmtWgB5.js","sources":["../../src/services/interaction-api.ts","../../src/hooks/useInteractions.ts"],"sourcesContent":["/**\n * Interaction Note API Client\n * Part of: 027-contact-directory Phase 7 implementation\n *\n * Typed API client for interaction note operations using Supabase Edge Functions.\n * Handles authentication, error handling, and response parsing for interaction history tracking.\n */\n\nimport { supabase } from '@/lib/supabase';\nimport type { Database } from '../types/contact-directory.types';\n\n// Get Supabase URL for Edge Functions\nconst supabaseUrl = import.meta.env.VITE_SUPABASE_URL;\n\nif (!supabaseUrl) {\n  throw new Error('Missing VITE_SUPABASE_URL environment variable');\n}\n\n// Type definitions from database\ntype InteractionNote = Database['public']['Tables']['cd_interaction_notes']['Row'];\ntype InteractionNoteInsert = Database['public']['Tables']['cd_interaction_notes']['Insert'];\ntype InteractionNoteUpdate = Database['public']['Tables']['cd_interaction_notes']['Update'];\n\n/**\n * Interaction Note Response (with populated data)\n */\nexport interface InteractionNoteResponse extends InteractionNote {\n  contact?: {\n    id: string;\n    full_name: string;\n    organization?: {\n      name: string;\n    };\n  };\n  attendee_contacts?: Array<{\n    id: string;\n    full_name: string;\n  }>;\n}\n\n/**\n * Create Interaction Note Parameters\n */\nexport interface CreateInteractionNoteParams {\n  contact_id: string;\n  date: string; // ISO date string (YYYY-MM-DD)\n  type: 'meeting' | 'email' | 'call' | 'conference' | 'other';\n  details: string;\n  attendees?: string[]; // Array of contact IDs\n  attachments?: string[]; // Array of file paths in Supabase Storage\n}\n\n/**\n * Search Interaction Notes Parameters\n */\nexport interface SearchInteractionNotesParams {\n  query?: string; // Full-text search in details\n  contact_id?: string; // Filter by contact\n  type?: string; // Filter by interaction type\n  date_from?: string; // ISO date string\n  date_to?: string; // ISO date string\n  limit?: number; // Pagination limit (default: 50)\n  offset?: number; // Pagination offset (default: 0)\n}\n\n/**\n * Search Response\n */\nexport interface InteractionNotesSearchResponse {\n  notes: InteractionNoteResponse[];\n  total: number;\n  limit: number;\n  offset: number;\n}\n\n/**\n * API Error\n */\nexport class InteractionAPIError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'InteractionAPIError';\n  }\n}\n\n/**\n * Get authorization headers with current user's JWT token\n */\nasync function getAuthHeaders(): Promise<HeadersInit> {\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new InteractionAPIError('Not authenticated', 401);\n  }\n\n  return {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${session.access_token}`,\n  };\n}\n\n/**\n * Handle Edge Function responses\n */\nasync function handleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    let errorMessage = `Request failed with status ${response.status}`;\n    try {\n      const errorData = await response.json();\n      errorMessage = errorData.error || errorData.message || errorMessage;\n    } catch {\n      // Ignore JSON parse errors\n    }\n    throw new InteractionAPIError(errorMessage, response.status);\n  }\n\n  try {\n    return await response.json();\n  } catch (error) {\n    throw new InteractionAPIError('Failed to parse response', response.status, error);\n  }\n}\n\n/**\n * Create a new interaction note\n */\nexport async function createNote(\n  params: CreateInteractionNoteParams\n): Promise<InteractionNoteResponse> {\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(`${supabaseUrl}/functions/v1/interaction-notes-create`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(params),\n  });\n\n  return handleResponse<InteractionNoteResponse>(response);\n}\n\n/**\n * Get interaction notes for a specific contact\n */\nexport async function getNotesForContact(contactId: string): Promise<InteractionNoteResponse[]> {\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(\n    `${supabaseUrl}/functions/v1/interaction-notes-list?contact_id=${contactId}`,\n    {\n      method: 'GET',\n      headers,\n    }\n  );\n\n  const data = await handleResponse<{ notes: InteractionNoteResponse[] }>(response);\n  return data.notes;\n}\n\n/**\n * Search interaction notes with filters\n */\nexport async function searchNotes(\n  params: SearchInteractionNotesParams = {}\n): Promise<InteractionNotesSearchResponse> {\n  const headers = await getAuthHeaders();\n\n  // Build query string from params\n  const queryParams = new URLSearchParams();\n  Object.entries(params).forEach(([key, value]) => {\n    if (value !== undefined && value !== null) {\n      queryParams.append(key, String(value));\n    }\n  });\n\n  const response = await fetch(\n    `${supabaseUrl}/functions/v1/interaction-notes-search?${queryParams.toString()}`,\n    {\n      method: 'GET',\n      headers,\n    }\n  );\n\n  return handleResponse<InteractionNotesSearchResponse>(response);\n}\n\n/**\n * Update an existing interaction note\n */\nexport async function updateNote(\n  id: string,\n  updates: Partial<InteractionNoteUpdate>\n): Promise<InteractionNoteResponse> {\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(`${supabaseUrl}/functions/v1/interaction-notes-update`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ id, ...updates }),\n  });\n\n  return handleResponse<InteractionNoteResponse>(response);\n}\n\n/**\n * Delete an interaction note\n */\nexport async function deleteNote(id: string): Promise<void> {\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(`${supabaseUrl}/functions/v1/interaction-notes-delete`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ id }),\n  });\n\n  await handleResponse<{ success: boolean }>(response);\n}\n\n/**\n * Upload attachment to Supabase Storage\n * Returns the storage path for the uploaded file\n */\nexport async function uploadAttachment(\n  contactId: string,\n  noteId: string,\n  file: File\n): Promise<string> {\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new InteractionAPIError('Not authenticated', 401);\n  }\n\n  // Generate unique filename to avoid collisions\n  const timestamp = Date.now();\n  const sanitizedFilename = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');\n  const filePath = `contacts/interactions/${contactId}/${noteId}/${timestamp}_${sanitizedFilename}`;\n\n  const { data, error } = await supabase.storage.from('contact-files').upload(filePath, file, {\n    cacheControl: '3600',\n    upsert: false,\n  });\n\n  if (error) {\n    throw new InteractionAPIError(`Failed to upload file: ${error.message}`, 500, error);\n  }\n\n  return data.path;\n}\n\n/**\n * Get public URL for attachment\n */\nexport async function getAttachmentUrl(path: string): Promise<string> {\n  const { data } = supabase.storage.from('contact-files').getPublicUrl(path);\n  return data.publicUrl;\n}\n\n/**\n * Download attachment\n * Returns a Blob of the file\n */\nexport async function downloadAttachment(path: string): Promise<Blob> {\n  const { data, error } = await supabase.storage.from('contact-files').download(path);\n\n  if (error) {\n    throw new InteractionAPIError(`Failed to download file: ${error.message}`, 500, error);\n  }\n\n  return data;\n}\n\n/**\n * Delete attachment from storage\n */\nexport async function deleteAttachment(path: string): Promise<void> {\n  const { error } = await supabase.storage.from('contact-files').remove([path]);\n\n  if (error) {\n    throw new InteractionAPIError(`Failed to delete file: ${error.message}`, 500, error);\n  }\n}\n\n/**\n * Get interaction notes (direct Supabase query - fallback method)\n * Used when Edge Function is unavailable\n */\nexport async function getNotesForContactDirect(\n  contactId: string\n): Promise<InteractionNoteResponse[]> {\n  const { data, error } = await supabase\n    .from('cd_interaction_notes')\n    .select(\n      `\n      *,\n      contact:cd_contacts!contact_id (\n        id,\n        full_name,\n        organization:cd_organizations (name)\n      )\n    `\n    )\n    .eq('contact_id', contactId)\n    .order('date', { ascending: false });\n\n  if (error) {\n    throw new InteractionAPIError(error.message, 500, error);\n  }\n\n  return data || [];\n}\n","/**\n * Interaction Note Hooks\n * Part of: 027-contact-directory Phase 7 implementation\n *\n * TanStack Query hooks for interaction note operations with automatic caching,\n * invalidation, and optimistic updates.\n */\n\nimport {\n  useMutation,\n  useQuery,\n  useQueryClient,\n  type UseQueryOptions,\n} from '@tanstack/react-query';\nimport {\n  createNote,\n  getNotesForContact,\n  searchNotes,\n  updateNote,\n  deleteNote,\n  uploadAttachment,\n  downloadAttachment,\n  type InteractionNoteResponse,\n  type CreateInteractionNoteParams,\n  type SearchInteractionNotesParams,\n  type InteractionNotesSearchResponse,\n  InteractionAPIError,\n} from '@/services/interaction-api';\nimport { toast } from 'sonner';\nimport { useTranslation } from 'react-i18next';\n\n/**\n * Query Keys Factory\n */\nexport const interactionKeys = {\n  all: ['interactions'] as const,\n  lists: () => [...interactionKeys.all, 'list'] as const,\n  list: (contactId: string) => [...interactionKeys.lists(), contactId] as const,\n  searches: () => [...interactionKeys.all, 'search'] as const,\n  search: (params?: SearchInteractionNotesParams) =>\n    [...interactionKeys.searches(), { params }] as const,\n  details: () => [...interactionKeys.all, 'detail'] as const,\n  detail: (id: string) => [...interactionKeys.details(), id] as const,\n};\n\n/**\n * Hook to fetch interaction notes for a contact\n */\nexport function useInteractionNotes(\n  contactId: string,\n  options?: Omit<\n    UseQueryOptions<InteractionNoteResponse[], InteractionAPIError>,\n    'queryKey' | 'queryFn'\n  >\n) {\n  return useQuery({\n    queryKey: interactionKeys.list(contactId),\n    queryFn: () => getNotesForContact(contactId),\n    enabled: !!contactId,\n    ...options,\n  });\n}\n\n/**\n * Hook to search interaction notes with filters\n */\nexport function useSearchNotes(\n  params?: SearchInteractionNotesParams,\n  options?: Omit<\n    UseQueryOptions<InteractionNotesSearchResponse, InteractionAPIError>,\n    'queryKey' | 'queryFn'\n  >\n) {\n  return useQuery({\n    queryKey: interactionKeys.search(params),\n    queryFn: () => searchNotes(params),\n    ...options,\n  });\n}\n\n/**\n * Hook to create a new interaction note\n */\nexport function useCreateNote() {\n  const queryClient = useQueryClient();\n  const { t } = useTranslation('contacts');\n\n  return useMutation({\n    mutationFn: async (params: CreateInteractionNoteParams) => {\n      return await createNote(params);\n    },\n    onSuccess: (data, variables) => {\n      // Invalidate the contact's interaction list\n      queryClient.invalidateQueries({ queryKey: interactionKeys.list(variables.contact_id) });\n\n      // Invalidate all search queries\n      queryClient.invalidateQueries({ queryKey: interactionKeys.searches() });\n\n      toast.success(\n        t('contactDirectory.interactions.hooks.note_created_success', {\n          type: t(`contactDirectory.interactions.types.${data.type}`),\n        })\n      );\n    },\n    onError: (error: InteractionAPIError) => {\n      toast.error(\n        t('contactDirectory.interactions.hooks.note_created_error', { error: error.message })\n      );\n    },\n  });\n}\n\n/**\n * Hook to update an existing interaction note\n */\nexport function useUpdateNote() {\n  const queryClient = useQueryClient();\n  const { t } = useTranslation('contacts');\n\n  return useMutation({\n    mutationFn: ({\n      id,\n      contactId,\n      updates,\n    }: {\n      id: string;\n      contactId: string;\n      updates: Partial<CreateInteractionNoteParams>;\n    }) => updateNote(id, updates),\n    onMutate: async ({ id, contactId, updates }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: interactionKeys.list(contactId) });\n\n      // Snapshot previous value for rollback\n      const previousNotes = queryClient.getQueryData<InteractionNoteResponse[]>(\n        interactionKeys.list(contactId)\n      );\n\n      // Optimistically update cache\n      if (previousNotes) {\n        const updatedNotes = previousNotes.map((note) =>\n          note.id === id\n            ? {\n                ...note,\n                ...updates,\n                updated_at: new Date().toISOString(),\n              }\n            : note\n        );\n        queryClient.setQueryData<InteractionNoteResponse[]>(\n          interactionKeys.list(contactId),\n          updatedNotes\n        );\n      }\n\n      return { previousNotes, contactId };\n    },\n    onSuccess: (data, variables) => {\n      // Invalidate queries to refetch with server data\n      queryClient.invalidateQueries({ queryKey: interactionKeys.list(variables.contactId) });\n      queryClient.invalidateQueries({ queryKey: interactionKeys.searches() });\n\n      toast.success(t('contactDirectory.interactions.hooks.note_updated_success'));\n    },\n    onError: (error: InteractionAPIError, variables, context) => {\n      // Rollback on error\n      if (context?.previousNotes && context?.contactId) {\n        queryClient.setQueryData(interactionKeys.list(context.contactId), context.previousNotes);\n      }\n      toast.error(\n        t('contactDirectory.interactions.hooks.note_updated_error', { error: error.message })\n      );\n    },\n  });\n}\n\n/**\n * Hook to delete an interaction note\n */\nexport function useDeleteNote() {\n  const queryClient = useQueryClient();\n  const { t } = useTranslation('contacts');\n\n  return useMutation({\n    mutationFn: ({ id, contactId }: { id: string; contactId: string }) => deleteNote(id),\n    onMutate: async ({ id, contactId }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: interactionKeys.list(contactId) });\n\n      // Snapshot previous value for rollback\n      const previousNotes = queryClient.getQueryData<InteractionNoteResponse[]>(\n        interactionKeys.list(contactId)\n      );\n\n      // Optimistically remove from cache\n      if (previousNotes) {\n        const filteredNotes = previousNotes.filter((note) => note.id !== id);\n        queryClient.setQueryData<InteractionNoteResponse[]>(\n          interactionKeys.list(contactId),\n          filteredNotes\n        );\n      }\n\n      return { previousNotes, contactId };\n    },\n    onSuccess: (_, variables) => {\n      // Invalidate queries to refetch\n      queryClient.invalidateQueries({ queryKey: interactionKeys.list(variables.contactId) });\n      queryClient.invalidateQueries({ queryKey: interactionKeys.searches() });\n\n      toast.success(t('contactDirectory.interactions.hooks.note_deleted_success'));\n    },\n    onError: (error: InteractionAPIError, variables, context) => {\n      // Rollback on error\n      if (context?.previousNotes && context?.contactId) {\n        queryClient.setQueryData(interactionKeys.list(context.contactId), context.previousNotes);\n      }\n      toast.error(\n        t('contactDirectory.interactions.hooks.note_deleted_error', { error: error.message })\n      );\n    },\n  });\n}\n\n/**\n * Hook to upload an attachment\n */\nexport function useUploadAttachment() {\n  const { t } = useTranslation('contacts');\n\n  return useMutation({\n    mutationFn: async ({\n      contactId,\n      noteId,\n      file,\n    }: {\n      contactId: string;\n      noteId: string;\n      file: File;\n    }) => {\n      return await uploadAttachment(contactId, noteId, file);\n    },\n    onSuccess: () => {\n      toast.success(t('contactDirectory.interactions.hooks.attachment_uploaded_success'));\n    },\n    onError: (error: InteractionAPIError) => {\n      toast.error(\n        t('contactDirectory.interactions.hooks.attachment_upload_error', { error: error.message })\n      );\n    },\n  });\n}\n\n/**\n * Hook to download an attachment\n */\nexport function useDownloadAttachment() {\n  const { t } = useTranslation('contacts');\n\n  return useMutation({\n    mutationFn: async ({ path, filename }: { path: string; filename: string }) => {\n      const blob = await downloadAttachment(path);\n      return { blob, filename };\n    },\n    onSuccess: ({ blob, filename }) => {\n      // Trigger browser download\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = filename;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n\n      toast.success(t('contactDirectory.interactions.hooks.attachment_downloaded_success'));\n    },\n    onError: (error: InteractionAPIError) => {\n      toast.error(\n        t('contactDirectory.interactions.hooks.attachment_download_error', {\n          error: error.message,\n        })\n      );\n    },\n  });\n}\n\n/**\n * Hook to invalidate all interaction queries\n * Useful after batch operations or external changes\n */\nexport function useInvalidateInteractions() {\n  const queryClient = useQueryClient();\n\n  return (contactId?: string) => {\n    if (contactId) {\n      queryClient.invalidateQueries({ queryKey: interactionKeys.list(contactId) });\n    } else {\n      queryClient.invalidateQueries({ queryKey: interactionKeys.all });\n    }\n  };\n}\n\n/**\n * Hook to prefetch interaction notes for a contact\n * Useful for hover cards or preloading before navigation\n */\nexport function usePrefetchInteractionNotes() {\n  const queryClient = useQueryClient();\n\n  return (contactId: string) => {\n    queryClient.prefetchQuery({\n      queryKey: interactionKeys.list(contactId),\n      queryFn: () => getNotesForContact(contactId),\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    });\n  };\n}\n"],"names":["supabaseUrl","InteractionAPIError","message","statusCode","details","getAuthHeaders","session","supabase","handleResponse","response","errorMessage","errorData","error","createNote","params","headers","getNotesForContact","contactId","searchNotes","queryParams","key","value","deleteNote","id","uploadAttachment","noteId","file","timestamp","sanitizedFilename","filePath","data","downloadAttachment","path","interactionKeys","useInteractionNotes","options","useQuery","useSearchNotes","useCreateNote","queryClient","useQueryClient","t","useTranslation","useMutation","variables","toast","useDeleteNote","previousNotes","filteredNotes","note","_","context","useUploadAttachment","useDownloadAttachment","filename","blob","url","link"],"mappings":"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"}