{"version":3,"file":"useIntelligence-BMjousVq.js","sources":["../../src/services/intelligence-api.ts","../../src/hooks/useIntelligence.ts"],"sourcesContent":["/**\n * Intelligence API Service\n * Feature: 029-dynamic-country-intelligence\n *\n * Type-safe API client for intelligence operations.\n * Handles authentication, request/response validation, and error handling.\n *\n * @see specs/029-dynamic-country-intelligence/api-contracts/openapi.yaml\n */\n\nimport { supabase } from '@/lib/supabase'\n\n// ============================================================================\n// Type Definitions (mirrored from Zod schemas)\n// ============================================================================\n\nexport type IntelligenceType = 'economic' | 'political' | 'security' | 'bilateral' | 'general'\nexport type RefreshStatus = 'fresh' | 'stale' | 'refreshing' | 'error' | 'expired'\nexport type Priority = 'low' | 'normal' | 'high'\nexport type Language = 'en' | 'ar'\n\nexport interface DataSourceMetadata {\n  source: string\n  endpoint?: string\n  retrieved_at: string\n  confidence?: number\n}\n\nexport interface AnythingLLMMetadata {\n  model?: string\n  tokens_used?: number\n  sources_cited?: string[]\n}\n\nexport interface IntelligenceReport {\n  id: string\n  entity_id: string\n  entity_type: 'country' | 'organization' | 'forum' | 'topic' | 'working_group'\n  intelligence_type: IntelligenceType\n  title: string\n  title_ar?: string\n  content: string\n  content_ar?: string\n  confidence_score: number\n  refresh_status: RefreshStatus\n  cache_expires_at: string\n  cache_created_at: string\n  last_refreshed_at: string\n  is_expired: boolean\n  time_until_expiry_hours?: number\n  data_sources_metadata: DataSourceMetadata[]\n  metrics?: Record<string, string> | null // Key indicators (GDP growth, inflation, etc.)\n  anythingllm_workspace_id?: string\n  anythingllm_query?: string\n  anythingllm_response_metadata?: AnythingLLMMetadata\n  version: number\n  created_at: string\n  updated_at: string\n}\n\nexport interface GetIntelligenceParams {\n  entity_id: string\n  intelligence_type?: IntelligenceType\n  include_stale?: boolean\n  language?: Language\n}\n\nexport interface GetIntelligenceResponse {\n  success: true\n  data: IntelligenceReport[]\n  meta: {\n    total_count: number\n    fresh_count: number\n    stale_count: number\n  }\n}\n\nexport interface RefreshIntelligenceParams {\n  entity_id: string\n  intelligence_types?: IntelligenceType[]\n  force?: boolean\n  priority?: Priority\n}\n\nexport interface RefreshIntelligenceResponse {\n  success: true\n  data: {\n    refresh_id: string\n    status: 'initiated' | 'in_progress' | 'completed' | 'failed'\n    entity_id: string\n    intelligence_types: IntelligenceType[]\n    triggered_by: string\n    triggered_at: string\n    estimated_completion?: string\n  }\n  message_en: string\n  message_ar: string\n}\n\nexport interface IntelligenceAPIError extends Error {\n  status: number\n  code: string\n  message: string\n  message_ar?: string\n  details?: Record<string, unknown>\n  correlation_id?: string\n}\n\n// ============================================================================\n// API Configuration\n// ============================================================================\n\nconst SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL\nconst FUNCTIONS_URL = `${SUPABASE_URL}/functions/v1`\n\n/**\n * Gets the current user's JWT token for API authentication\n */\nasync function getAuthToken(): Promise<string> {\n  const {\n    data: { session },\n    error,\n  } = await supabase.auth.getSession()\n\n  if (error || !session) {\n    throw new Error('Authentication required. Please log in.')\n  }\n\n  return session.access_token\n}\n\n/**\n * Creates a standardized API error from response\n */\nasync function createAPIError(response: Response): Promise<IntelligenceAPIError> {\n  let errorData\n\n  try {\n    errorData = await response.json()\n  } catch {\n    errorData = {\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message_en: response.statusText || 'An unknown error occurred',\n        message_ar: 'حدث خطأ غير معروف',\n      },\n    }\n  }\n\n  const error = new Error(\n    errorData.error?.message_en || 'API request failed',\n  ) as IntelligenceAPIError\n  error.status = response.status\n  error.code = errorData.error?.code || 'UNKNOWN_ERROR'\n  error.message_ar = errorData.error?.message_ar\n  error.details = errorData.error?.details\n  error.correlation_id = errorData.error?.correlation_id\n\n  return error\n}\n\n// ============================================================================\n// API Functions\n// ============================================================================\n\n/**\n * Fetches intelligence data for an entity\n *\n * @param params - Query parameters\n * @returns Intelligence reports with metadata\n * @throws IntelligenceAPIError on failure\n *\n * @example\n * ```ts\n * const intelligence = await getIntelligence({\n *   entity_id: '550e8400-e29b-41d4-a716-446655440000',\n *   intelligence_type: 'economic',\n *   language: 'en'\n * });\n * ```\n */\nexport async function getIntelligence(\n  params: GetIntelligenceParams,\n): Promise<GetIntelligenceResponse> {\n  try {\n    const token = await getAuthToken()\n\n    // Build query string\n    const queryParams = new URLSearchParams({\n      entity_id: params.entity_id,\n      ...(params.intelligence_type && { intelligence_type: params.intelligence_type }),\n      ...(params.include_stale !== undefined && {\n        include_stale: String(params.include_stale),\n      }),\n      ...(params.language && { language: params.language }),\n    })\n\n    const response = await fetch(`${FUNCTIONS_URL}/intelligence-get?${queryParams}`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n    })\n\n    if (!response.ok) {\n      throw await createAPIError(response)\n    }\n\n    const data: GetIntelligenceResponse = await response.json()\n    return data\n  } catch (error) {\n    if (error instanceof Error && 'status' in error) {\n      throw error as IntelligenceAPIError\n    }\n\n    // Wrap unexpected errors\n    const apiError = new Error('Failed to fetch intelligence data') as IntelligenceAPIError\n    apiError.status = 500\n    apiError.code = 'FETCH_ERROR'\n    throw apiError\n  }\n}\n\n/**\n * Triggers manual intelligence refresh\n *\n * @param params - Refresh parameters\n * @returns Refresh operation status\n * @throws IntelligenceAPIError on failure (including 409 for concurrent refresh)\n *\n * @example\n * ```ts\n * const result = await refreshIntelligence({\n *   entity_id: '550e8400-e29b-41d4-a716-446655440000',\n *   intelligence_types: ['economic', 'political'],\n *   priority: 'high'\n * });\n * ```\n */\nexport async function refreshIntelligence(\n  params: RefreshIntelligenceParams,\n): Promise<RefreshIntelligenceResponse> {\n  try {\n    const token = await getAuthToken()\n\n    // TEMPORARY: Using intelligence-refresh-v2 to bypass caching issues\n    const response = await fetch(`${FUNCTIONS_URL}/intelligence-refresh-v2`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(params),\n    })\n\n    if (!response.ok) {\n      throw await createAPIError(response)\n    }\n\n    const data: RefreshIntelligenceResponse = await response.json()\n    return data\n  } catch (error) {\n    if (error instanceof Error && 'status' in error) {\n      throw error as IntelligenceAPIError\n    }\n\n    const apiError = new Error('Failed to refresh intelligence data') as IntelligenceAPIError\n    apiError.status = 500\n    apiError.code = 'REFRESH_ERROR'\n    throw apiError\n  }\n}\n\n/**\n * Fetches a single intelligence report by entity and type\n *\n * Convenience function that wraps getIntelligence for single-type queries.\n *\n * @param entityId - Entity UUID\n * @param intelligenceType - Intelligence type to fetch\n * @param language - Preferred language\n * @returns Single intelligence report or undefined if not found\n *\n * @example\n * ```ts\n * const economicIntel = await getIntelligenceByType(\n *   '550e8400-e29b-41d4-a716-446655440000',\n *   'economic',\n *   'en'\n * );\n * ```\n */\nexport async function getIntelligenceByType(\n  entityId: string,\n  intelligenceType: IntelligenceType,\n  language: Language = 'en',\n): Promise<IntelligenceReport | undefined> {\n  const response = await getIntelligence({\n    entity_id: entityId,\n    intelligence_type: intelligenceType,\n    language,\n  })\n\n  return response.data[0]\n}\n\n/**\n * Fetches all intelligence types for an entity\n *\n * @param entityId - Entity UUID\n * @param language - Preferred language\n * @returns All intelligence reports for the entity\n *\n * @example\n * ```ts\n * const allIntelligence = await getAllIntelligence(\n *   '550e8400-e29b-41d4-a716-446655440000',\n *   'en'\n * );\n * ```\n */\nexport async function getAllIntelligence(\n  entityId: string,\n  language: Language = 'en',\n): Promise<GetIntelligenceResponse> {\n  return getIntelligence({\n    entity_id: entityId,\n    include_stale: true,\n    language,\n  })\n}\n\n/**\n * Refreshes a specific intelligence type\n *\n * Convenience function for selective refresh of a single type.\n *\n * @param entityId - Entity UUID\n * @param intelligenceType - Intelligence type to refresh\n * @param options - Optional refresh options\n * @returns Refresh operation status\n *\n * @example\n * ```ts\n * await refreshIntelligenceType(\n *   '550e8400-e29b-41d4-a716-446655440000',\n *   'economic',\n *   { priority: 'high', force: true }\n * );\n * ```\n */\nexport async function refreshIntelligenceType(\n  entityId: string,\n  intelligenceType: IntelligenceType,\n  options?: {\n    force?: boolean\n    priority?: Priority\n  },\n): Promise<RefreshIntelligenceResponse> {\n  return refreshIntelligence({\n    entity_id: entityId,\n    intelligence_types: [intelligenceType],\n    force: options?.force,\n    priority: options?.priority,\n  })\n}\n\n/**\n * Checks if intelligence data is stale for an entity\n *\n * @param entityId - Entity UUID\n * @returns True if any intelligence is expired or stale\n *\n * @example\n * ```ts\n * const isStale = await isIntelligenceStale(\n *   '550e8400-e29b-41d4-a716-446655440000'\n * );\n *\n * if (isStale) {\n *   // Prompt user to refresh\n * }\n * ```\n */\nexport async function isIntelligenceStale(entityId: string): Promise<boolean> {\n  try {\n    const response = await getIntelligence({\n      entity_id: entityId,\n      include_stale: true,\n    })\n\n    return response.data.some((report) => report.is_expired || report.refresh_status === 'stale')\n  } catch (error) {\n    console.error('Failed to check intelligence staleness:', error)\n    return false\n  }\n}\n\n/**\n * Gets intelligence types that need refresh\n *\n * @param entityId - Entity UUID\n * @returns Array of intelligence types with expired cache\n *\n * @example\n * ```ts\n * const staleTypes = await getStaleIntelligenceTypes(\n *   '550e8400-e29b-41d4-a716-446655440000'\n * );\n *\n * if (staleTypes.length > 0) {\n *   await refreshIntelligence({\n *     entity_id: entityId,\n *     intelligence_types: staleTypes\n *   });\n * }\n * ```\n */\nexport async function getStaleIntelligenceTypes(entityId: string): Promise<IntelligenceType[]> {\n  try {\n    const response = await getIntelligence({\n      entity_id: entityId,\n      include_stale: true,\n    })\n\n    return response.data\n      .filter((report) => report.is_expired || report.refresh_status === 'stale')\n      .map((report) => report.intelligence_type)\n  } catch (error) {\n    console.error('Failed to get stale intelligence types:', error)\n    return []\n  }\n}\n","/**\n * Intelligence Hooks\n * Feature: 029-dynamic-country-intelligence\n *\n * TanStack Query hooks for dynamic country intelligence operations.\n * Provides automatic caching with TTL-based stale-while-revalidate pattern,\n * manual refresh capabilities, and optimistic updates.\n *\n * @see specs/029-dynamic-country-intelligence/spec.md\n * @see specs/029-dynamic-country-intelligence/api-contracts/openapi.yaml\n */\n\nimport React from 'react'\nimport {\n  useMutation,\n  useQuery,\n  useQueryClient,\n  type UseQueryOptions,\n  type UseMutationOptions,\n} from '@tanstack/react-query'\nimport {\n  getIntelligence,\n  refreshIntelligence,\n  type GetIntelligenceParams,\n  type RefreshIntelligenceParams,\n  type IntelligenceReport,\n  type GetIntelligenceResponse,\n  type RefreshIntelligenceResponse,\n  IntelligenceAPIError,\n} from '@/services/intelligence-api'\nimport { toast } from 'sonner'\nimport { useTranslation } from 'react-i18next'\n\n// ============================================================================\n// Query Keys Factory\n// ============================================================================\n\n/**\n * Hierarchical query keys for intelligence data\n * Enables granular cache invalidation and prefetching\n */\nexport const intelligenceKeys = {\n  all: ['intelligence'] as const,\n  lists: () => [...intelligenceKeys.all, 'list'] as const,\n  list: (params: GetIntelligenceParams) => [...intelligenceKeys.lists(), params] as const,\n  details: () => [...intelligenceKeys.all, 'detail'] as const,\n  detail: (entityId: string, intelligenceType?: string) =>\n    [...intelligenceKeys.details(), entityId, intelligenceType] as const,\n  forEntity: (entityId: string) => [...intelligenceKeys.all, 'entity', entityId] as const,\n}\n\n// ============================================================================\n// Query Hooks\n// ============================================================================\n\n/**\n * Get refetch interval based on intelligence type TTL\n * TTL strategy:\n * - economic: 6 hours (quarterly data updates)\n * - political: 1 hour (volatile, time-sensitive)\n * - security: 30 minutes (dynamic threat landscape)\n * - bilateral: 12 hours (stable agreements)\n * - general: 6 hours (default)\n */\nfunction getRefetchInterval(intelligenceType?: string): number | false {\n  if (!intelligenceType) return false // Disable auto-refresh for multi-type queries\n\n  const TTL_INTERVALS = {\n    economic: 6 * 60 * 60 * 1000, // 6 hours\n    political: 60 * 60 * 1000, // 1 hour\n    security: 30 * 60 * 1000, // 30 minutes\n    bilateral: 12 * 60 * 60 * 1000, // 12 hours\n    general: 6 * 60 * 60 * 1000, // 6 hours (default)\n  }\n\n  return TTL_INTERVALS[intelligenceType as keyof typeof TTL_INTERVALS] || false\n}\n\n/**\n * Hook to fetch intelligence data for an entity\n *\n * Features:\n * - Automatic caching with configurable TTL\n * - Stale-while-revalidate pattern (shows cached data while fetching fresh)\n * - Background refresh when cache expires (TTL-based)\n * - Supports filtering by intelligence type\n * - Multilingual content (English/Arabic)\n * - Silent background updates (no loading indicators)\n * - Auto-refresh based on intelligence type TTL\n * - Non-intrusive notifications when fresh data arrives\n *\n * @example\n * ```tsx\n * const { data, isLoading, isStale } = useIntelligence({\n *   entity_id: countryId,\n *   intelligence_type: 'economic',\n *   language: 'en',\n *   enableBackgroundNotifications: true\n * });\n * ```\n *\n * @param params - Query parameters (entity_id required)\n * @param options - TanStack Query options for customization\n */\nexport function useIntelligence(\n  params: GetIntelligenceParams & { enableBackgroundNotifications?: boolean },\n  options?: Omit<\n    UseQueryOptions<GetIntelligenceResponse, IntelligenceAPIError>,\n    'queryKey' | 'queryFn'\n  >,\n) {\n  const { i18n, t } = useTranslation()\n  const queryClient = useQueryClient()\n  const { enableBackgroundNotifications = false, ...queryParams } = params\n\n  // Auto-detect language from i18next if not provided\n  const finalQueryParams: GetIntelligenceParams = {\n    ...queryParams,\n    language: queryParams.language || (i18n.language as 'en' | 'ar'),\n  }\n\n  // Calculate refetch interval based on intelligence type\n  const refetchInterval = getRefetchInterval(params.intelligence_type)\n\n  // Track previous data hash to detect actual data changes\n  const previousDataRef = React.useRef<string | null>(null)\n\n  const query = useQuery({\n    queryKey: intelligenceKeys.list(finalQueryParams),\n    queryFn: () => getIntelligence(finalQueryParams),\n    // Stale-while-revalidate: show cached data immediately, refetch in background\n    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes\n    gcTime: 60 * 60 * 1000, // Keep in cache for 1 hour (formerly cacheTime)\n    refetchOnMount: 'always', // Always check for updates on mount\n    refetchOnWindowFocus: true, // Refetch when user returns to tab\n    refetchOnReconnect: true, // Refetch when network reconnects\n    refetchInterval, // Auto-refresh based on TTL (T069-T070)\n    refetchIntervalInBackground: false, // Only refetch when tab is active (T071)\n    retry: (failureCount, error) => {\n      // Retry on network errors, but not on 404/403\n      if (error.status === 404 || error.status === 403) {\n        return false\n      }\n      return failureCount < 3\n    },\n    ...options,\n  })\n\n  // Show non-intrusive notification when background refresh brings fresh data (T072)\n  React.useEffect(() => {\n    if (!enableBackgroundNotifications || !query.data) return\n\n    const currentDataHash = JSON.stringify(\n      query.data.data.map((d) => ({\n        id: d.id,\n        version: d.version,\n        last_refreshed_at: d.last_refreshed_at,\n      })),\n    )\n\n    // Check if data actually changed (not just initial load)\n    if (previousDataRef.current && previousDataRef.current !== currentDataHash) {\n      const intelligenceTypeLabel = params.intelligence_type\n        ? t(`intelligence.types.${params.intelligence_type}`, params.intelligence_type)\n        : t('intelligence.types.all', 'intelligence')\n\n      // Non-intrusive info toast (T072)\n      toast.info(\n        t('intelligence.backgroundRefresh.success', `Fresh {{type}} data is now available`, {\n          type: intelligenceTypeLabel,\n        }),\n        {\n          duration: 3000,\n          dismissible: true,\n        },\n      )\n    }\n\n    previousDataRef.current = currentDataHash\n  }, [query.data, enableBackgroundNotifications, params.intelligence_type, t])\n\n  return query\n}\n\n/**\n * Hook to fetch a single intelligence report by entity and type\n *\n * Convenience wrapper around useIntelligence for single-type queries.\n *\n * @example\n * ```tsx\n * const { data: economicIntel } = useIntelligenceByType(\n *   countryId,\n *   'economic'\n * );\n * ```\n */\nexport function useIntelligenceByType(\n  entityId: string,\n  intelligenceType: 'economic' | 'political' | 'security' | 'bilateral' | 'general',\n  options?: Omit<\n    UseQueryOptions<IntelligenceReport | undefined, IntelligenceAPIError>,\n    'queryKey' | 'queryFn'\n  >,\n) {\n  const { i18n } = useTranslation()\n\n  return useQuery({\n    queryKey: intelligenceKeys.detail(entityId, intelligenceType),\n    queryFn: async () => {\n      const response = await getIntelligence({\n        entity_id: entityId,\n        intelligence_type: intelligenceType,\n        language: i18n.language as 'en' | 'ar',\n      })\n      // Return first item or undefined\n      return response.data[0]\n    },\n    staleTime: 5 * 60 * 1000,\n    gcTime: 60 * 60 * 1000,\n    ...options,\n  })\n}\n\n/**\n * Hook to fetch all intelligence types for an entity\n *\n * Fetches economic, political, security, and bilateral intelligence in a single query.\n *\n * @example\n * ```tsx\n * const { data, isLoading } = useAllIntelligence(countryId);\n * // data contains all intelligence types with meta information\n * ```\n */\nexport function useAllIntelligence(\n  entityId: string,\n  options?: Omit<\n    UseQueryOptions<GetIntelligenceResponse, IntelligenceAPIError>,\n    'queryKey' | 'queryFn'\n  >,\n) {\n  const { i18n } = useTranslation()\n\n  return useQuery({\n    queryKey: intelligenceKeys.forEntity(entityId),\n    queryFn: () =>\n      getIntelligence({\n        entity_id: entityId,\n        include_stale: true,\n        language: i18n.language as 'en' | 'ar',\n      }),\n    staleTime: 5 * 60 * 1000,\n    gcTime: 60 * 60 * 1000,\n    ...options,\n  })\n}\n\n// ============================================================================\n// Mutation Hooks\n// ============================================================================\n\n/**\n * Hook to manually refresh intelligence data\n *\n * Features:\n * - Optimistic updates (shows loading state immediately)\n * - Automatic cache invalidation on success\n * - Toast notifications for user feedback\n * - Handles concurrent refresh conflicts (409)\n * - Graceful degradation when AnythingLLM unavailable (503)\n *\n * @example\n * ```tsx\n * const { mutate: refresh, isPending } = useRefreshIntelligence();\n *\n * const handleRefresh = () => {\n *   refresh({\n *     entity_id: countryId,\n *     intelligence_types: ['economic', 'political'],\n *     priority: 'high'\n *   });\n * };\n * ```\n *\n * @param options - TanStack Query mutation options\n */\nexport function useRefreshIntelligence(\n  options?: UseMutationOptions<\n    RefreshIntelligenceResponse,\n    IntelligenceAPIError,\n    RefreshIntelligenceParams\n  >,\n) {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation()\n\n  return useMutation({\n    mutationFn: (params: RefreshIntelligenceParams) => refreshIntelligence(params),\n\n    onMutate: async (params) => {\n      // Cancel outgoing queries for this entity\n      await queryClient.cancelQueries({\n        queryKey: intelligenceKeys.forEntity(params.entity_id),\n      })\n\n      // Snapshot current data\n      const previousData = queryClient.getQueryData<GetIntelligenceResponse>(\n        intelligenceKeys.forEntity(params.entity_id),\n      )\n\n      // Optimistic update: mark intelligence as \"refreshing\"\n      if (previousData) {\n        const updatedData = {\n          ...previousData,\n          data: previousData.data.map((item) => {\n            const shouldUpdate =\n              !params.intelligence_types ||\n              params.intelligence_types.includes(item.intelligence_type)\n\n            return shouldUpdate ? { ...item, refresh_status: 'refreshing' as const } : item\n          }),\n        }\n\n        queryClient.setQueryData(intelligenceKeys.forEntity(params.entity_id), updatedData)\n      }\n\n      // Show loading toast\n      const toastId = toast.loading(\n        t('intelligence.refresh.loading', 'Refreshing intelligence data...'),\n      )\n\n      return { previousData, toastId }\n    },\n\n    onSuccess: (data, params, context) => {\n      // Dismiss loading toast\n      if (context?.toastId) {\n        toast.dismiss(context.toastId)\n      }\n\n      // Show success toast\n      toast.success(t('intelligence.refresh.success', data.message_en))\n\n      // Add small delay to allow database transaction to fully commit\n      // before refetching (prevents race condition with 404 errors)\n      setTimeout(() => {\n        // Invalidate and refetch intelligence data\n        queryClient.invalidateQueries({\n          queryKey: intelligenceKeys.forEntity(params.entity_id),\n        })\n\n        // Also invalidate specific type queries if selective refresh\n        if (params.intelligence_types) {\n          params.intelligence_types.forEach((type) => {\n            queryClient.invalidateQueries({\n              queryKey: intelligenceKeys.detail(params.entity_id, type),\n            })\n          })\n        }\n\n        // Force refetch to ensure data updates immediately\n        queryClient.refetchQueries({\n          queryKey: intelligenceKeys.forEntity(params.entity_id),\n        })\n      }, 1000) // Wait 1 second for database commit\n    },\n\n    onError: (error, params, context) => {\n      // Dismiss loading toast\n      if (context?.toastId) {\n        toast.dismiss(context.toastId)\n      }\n\n      // Rollback optimistic update\n      if (context?.previousData) {\n        queryClient.setQueryData(intelligenceKeys.forEntity(params.entity_id), context.previousData)\n      }\n\n      // Handle specific error cases\n      if (error.status === 409) {\n        // Refresh already in progress\n        toast.warning(\n          t('intelligence.refresh.conflict', 'A refresh is already in progress. Please wait.'),\n        )\n      } else if (error.status === 503) {\n        // AnythingLLM unavailable\n        toast.error(\n          t(\n            'intelligence.refresh.serviceUnavailable',\n            'Intelligence service is temporarily unavailable. Cached data remains accessible.',\n          ),\n        )\n      } else {\n        // Generic error\n        toast.error(t('intelligence.refresh.error', `Failed to refresh: ${error.message}`))\n      }\n    },\n\n    ...options,\n  })\n}\n\n/**\n * Hook to refresh a specific intelligence type\n *\n * Convenience wrapper for selective refresh of a single intelligence type.\n *\n * @example\n * ```tsx\n * const { mutate: refreshEconomic } = useRefreshIntelligenceType();\n *\n * refreshEconomic({\n *   entity_id: countryId,\n *   intelligence_type: 'economic'\n * });\n * ```\n */\nexport function useRefreshIntelligenceType(\n  options?: UseMutationOptions<\n    RefreshIntelligenceResponse,\n    IntelligenceAPIError,\n    {\n      entity_id: string\n      intelligence_type: 'economic' | 'political' | 'security' | 'bilateral'\n      force?: boolean\n      priority?: 'low' | 'normal' | 'high'\n    }\n  >,\n) {\n  const refreshMutation = useRefreshIntelligence()\n\n  return useMutation({\n    mutationFn: (params) =>\n      refreshIntelligence({\n        entity_id: params.entity_id,\n        intelligence_types: [params.intelligence_type],\n        force: params.force,\n        priority: params.priority,\n      }),\n    ...options,\n  })\n}\n\n// ============================================================================\n// Utility Hooks\n// ============================================================================\n\n/**\n * Hook to prefetch intelligence data (useful for hover effects, navigation)\n *\n * @example\n * ```tsx\n * const prefetchIntelligence = usePrefetchIntelligence();\n *\n * <Link\n *   to={`/dossiers/${countryId}`}\n *   onMouseEnter={() => prefetchIntelligence(countryId)}\n * >\n * ```\n */\nexport function usePrefetchIntelligence() {\n  const queryClient = useQueryClient()\n  const { i18n } = useTranslation()\n\n  return (entityId: string) => {\n    queryClient.prefetchQuery({\n      queryKey: intelligenceKeys.forEntity(entityId),\n      queryFn: () =>\n        getIntelligence({\n          entity_id: entityId,\n          language: i18n.language as 'en' | 'ar',\n        }),\n      staleTime: 5 * 60 * 1000,\n    })\n  }\n}\n\n/**\n * Hook to invalidate all intelligence queries (useful after bulk operations)\n *\n * @example\n * ```tsx\n * const invalidateAllIntelligence = useInvalidateAllIntelligence();\n *\n * const handleBulkRefresh = async () => {\n *   await bulkRefreshAPI();\n *   invalidateAllIntelligence();\n * };\n * ```\n */\nexport function useInvalidateAllIntelligence() {\n  const queryClient = useQueryClient()\n\n  return () => {\n    queryClient.invalidateQueries({ queryKey: intelligenceKeys.all })\n  }\n}\n\n/**\n * Hook to check if intelligence data is stale\n *\n * Returns true if any intelligence report for the entity has expired cache.\n *\n * @example\n * ```tsx\n * const isStale = useIntelligenceStaleStatus(countryId);\n *\n * {isStale && <Badge>Outdated Data</Badge>}\n * ```\n */\nexport function useIntelligenceStaleStatus(entityId: string): boolean {\n  const { data } = useAllIntelligence(entityId, {\n    enabled: !!entityId,\n  })\n\n  if (!data) return false\n\n  return data.data.some((report) => report.is_expired || report.refresh_status === 'stale')\n}\n\n/**\n * Hook to get intelligence refresh status\n *\n * Returns the refresh status for all intelligence types.\n *\n * @example\n * ```tsx\n * const status = useIntelligenceRefreshStatus(countryId);\n *\n * {status.isRefreshing && <Spinner />}\n * {status.hasErrors && <Alert>Some intelligence failed to refresh</Alert>}\n * ```\n */\nexport function useIntelligenceRefreshStatus(entityId: string) {\n  const { data } = useAllIntelligence(entityId, {\n    enabled: !!entityId,\n  })\n\n  if (!data) {\n    return {\n      isRefreshing: false,\n      hasErrors: false,\n      hasFresh: false,\n      hasStale: false,\n    }\n  }\n\n  return {\n    isRefreshing: data.data.some((r) => r.refresh_status === 'refreshing'),\n    hasErrors: data.data.some((r) => r.refresh_status === 'error'),\n    hasFresh: data.data.some((r) => r.refresh_status === 'fresh'),\n    hasStale: data.data.some((r) => r.refresh_status === 'stale' || r.is_expired),\n  }\n}\n\n// ============================================================================\n// Type Re-exports for Convenience\n// ============================================================================\n\nexport type {\n  IntelligenceReport,\n  GetIntelligenceResponse,\n  RefreshIntelligenceResponse,\n  GetIntelligenceParams,\n  RefreshIntelligenceParams,\n} from '@/services/intelligence-api'\n"],"names":["SUPABASE_URL","FUNCTIONS_URL","getAuthToken","session","error","supabase","createAPIError","response","errorData","getIntelligence","params","token","queryParams","apiError","refreshIntelligence","intelligenceKeys","entityId","intelligenceType","useAllIntelligence","options","i18n","useTranslation","useQuery","useRefreshIntelligence","queryClient","useQueryClient","useMutation","previousData","updatedData","item","toastId","toast","data","context","type","usePrefetchIntelligence"],"mappings":"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"}