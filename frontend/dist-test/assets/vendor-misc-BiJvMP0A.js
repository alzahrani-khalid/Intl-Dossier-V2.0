import {
  r as Y,
  f as kr,
  a as Ei,
  h as Ph,
  s as ud,
  i as q_,
  R as ut,
  j as Cn,
  c as xe,
  d as W_,
} from './react-vendor-Buoak6m3.js'
import {
  b as K_,
  d as G_,
  a as X_,
  c as Y_,
  e as Z_,
  f as J_,
  i as Q_,
  g as tk,
  l as ek,
  h as nk,
  o as rk,
  p as ik,
  j as sk,
  q as ok,
  k as ak,
  r as lk,
  s as ck,
  m as uk,
  n as fk,
  t as dk,
  u as hk,
  v as pk,
  w as mk,
  x as gk,
  y as yk,
  z as bk,
  A as vk,
  B as wk,
  C as ys,
  D as L2,
  E as _m,
  F as F2,
  G as xk,
} from './visualization-vendor-f5uYUx4I.js'
var B2 = { exports: {} },
  z2 = {}
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (e) {
  function n(v, x) {
    var _ = v.length
    v.push(x)
    t: for (; 0 < _; ) {
      var S = (_ - 1) >>> 1,
        A = v[S]
      if (0 < i(A, x)) ((v[S] = x), (v[_] = A), (_ = S))
      else break t
    }
  }
  function t(v) {
    return v.length === 0 ? null : v[0]
  }
  function r(v) {
    if (v.length === 0) return null
    var x = v[0],
      _ = v.pop()
    if (_ !== x) {
      v[0] = _
      t: for (var S = 0, A = v.length, j = A >>> 1; S < j; ) {
        var L = 2 * (S + 1) - 1,
          H = v[L],
          U = L + 1,
          K = v[U]
        if (0 > i(H, _))
          U < A && 0 > i(K, H)
            ? ((v[S] = K), (v[U] = _), (S = U))
            : ((v[S] = H), (v[L] = _), (S = L))
        else if (U < A && 0 > i(K, _)) ((v[S] = K), (v[U] = _), (S = U))
        else break t
      }
    }
    return x
  }
  function i(v, x) {
    var _ = v.sortIndex - x.sortIndex
    return _ !== 0 ? _ : v.id - x.id
  }
  if (
    ((e.unstable_now = void 0),
    typeof performance == 'object' && typeof performance.now == 'function')
  ) {
    var s = performance
    e.unstable_now = function () {
      return s.now()
    }
  } else {
    var o = Date,
      a = o.now()
    e.unstable_now = function () {
      return o.now() - a
    }
  }
  var l = [],
    c = [],
    u = 1,
    f = null,
    d = 3,
    h = !1,
    p = !1,
    g = !1,
    m = !1,
    y = typeof setTimeout == 'function' ? setTimeout : null,
    b = typeof clearTimeout == 'function' ? clearTimeout : null,
    w = typeof setImmediate < 'u' ? setImmediate : null
  function C(v) {
    for (var x = t(c); x !== null; ) {
      if (x.callback === null) r(c)
      else if (x.startTime <= v) (r(c), (x.sortIndex = x.expirationTime), n(l, x))
      else break
      x = t(c)
    }
  }
  function T(v) {
    if (((g = !1), C(v), !p))
      if (t(l) !== null) ((p = !0), I || ((I = !0), F()))
      else {
        var x = t(c)
        x !== null && k(T, x.startTime - v)
      }
  }
  var I = !1,
    B = -1,
    E = 5,
    O = -1
  function P() {
    return m ? !0 : !(e.unstable_now() - O < E)
  }
  function $() {
    if (((m = !1), I)) {
      var v = e.unstable_now()
      O = v
      var x = !0
      try {
        t: {
          ;((p = !1), g && ((g = !1), b(B), (B = -1)), (h = !0))
          var _ = d
          try {
            e: {
              for (C(v), f = t(l); f !== null && !(f.expirationTime > v && P()); ) {
                var S = f.callback
                if (typeof S == 'function') {
                  ;((f.callback = null), (d = f.priorityLevel))
                  var A = S(f.expirationTime <= v)
                  if (((v = e.unstable_now()), typeof A == 'function')) {
                    ;((f.callback = A), C(v), (x = !0))
                    break e
                  }
                  ;(f === t(l) && r(l), C(v))
                } else r(l)
                f = t(l)
              }
              if (f !== null) x = !0
              else {
                var j = t(c)
                ;(j !== null && k(T, j.startTime - v), (x = !1))
              }
            }
            break t
          } finally {
            ;((f = null), (d = _), (h = !1))
          }
          x = void 0
        }
      } finally {
        x ? F() : (I = !1)
      }
    }
  }
  var F
  if (typeof w == 'function')
    F = function () {
      w($)
    }
  else if (typeof MessageChannel < 'u') {
    var M = new MessageChannel(),
      R = M.port2
    ;((M.port1.onmessage = $),
      (F = function () {
        R.postMessage(null)
      }))
  } else
    F = function () {
      y($, 0)
    }
  function k(v, x) {
    B = y(function () {
      v(e.unstable_now())
    }, x)
  }
  ;((e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (v) {
      v.callback = null
    }),
    (e.unstable_forceFrameRate = function (v) {
      0 > v || 125 < v
        ? console.error(
            'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
          )
        : (E = 0 < v ? Math.floor(1e3 / v) : 5)
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return d
    }),
    (e.unstable_next = function (v) {
      switch (d) {
        case 1:
        case 2:
        case 3:
          var x = 3
          break
        default:
          x = d
      }
      var _ = d
      d = x
      try {
        return v()
      } finally {
        d = _
      }
    }),
    (e.unstable_requestPaint = function () {
      m = !0
    }),
    (e.unstable_runWithPriority = function (v, x) {
      switch (v) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          v = 3
      }
      var _ = d
      d = v
      try {
        return x()
      } finally {
        d = _
      }
    }),
    (e.unstable_scheduleCallback = function (v, x, _) {
      var S = e.unstable_now()
      switch (
        (typeof _ == 'object' && _ !== null
          ? ((_ = _.delay), (_ = typeof _ == 'number' && 0 < _ ? S + _ : S))
          : (_ = S),
        v)
      ) {
        case 1:
          var A = -1
          break
        case 2:
          A = 250
          break
        case 5:
          A = 1073741823
          break
        case 4:
          A = 1e4
          break
        default:
          A = 5e3
      }
      return (
        (A = _ + A),
        (v = {
          id: u++,
          callback: x,
          priorityLevel: v,
          startTime: _,
          expirationTime: A,
          sortIndex: -1,
        }),
        _ > S
          ? ((v.sortIndex = _),
            n(c, v),
            t(l) === null && v === t(c) && (g ? (b(B), (B = -1)) : (g = !0), k(T, _ - S)))
          : ((v.sortIndex = A), n(l, v), p || h || ((p = !0), I || ((I = !0), F()))),
        v
      )
    }),
    (e.unstable_shouldYield = P),
    (e.unstable_wrapCallback = function (v) {
      var x = d
      return function () {
        var _ = d
        d = x
        try {
          return v.apply(this, arguments)
        } finally {
          d = _
        }
      }
    }))
})(z2)
B2.exports = z2
var kK = B2.exports
const mo = new WeakMap(),
  Oc = new WeakMap(),
  qc = { current: [] }
let fd = !1,
  Ca = 0
const ma = new Set(),
  Kl = new Map()
function $2(e) {
  const n = Array.from(e).sort((t, r) =>
    t instanceof go && t.options.deps.includes(r)
      ? 1
      : r instanceof go && r.options.deps.includes(t)
        ? -1
        : 0,
  )
  for (const t of n) {
    if (qc.current.includes(t)) continue
    ;(qc.current.push(t), t.recompute())
    const r = Oc.get(t)
    if (r)
      for (const i of r) {
        const s = mo.get(i)
        s && $2(s)
      }
  }
}
function Sk(e) {
  const n = { prevVal: e.prevState, currentVal: e.state }
  for (const t of e.listeners) t(n)
}
function _k(e) {
  const n = { prevVal: e.prevState, currentVal: e.state }
  for (const t of e.listeners) t(n)
}
function V2(e) {
  if ((Ca > 0 && !Kl.has(e) && Kl.set(e, e.prevState), ma.add(e), !(Ca > 0) && !fd))
    try {
      for (fd = !0; ma.size > 0; ) {
        const n = Array.from(ma)
        ma.clear()
        for (const t of n) {
          const r = Kl.get(t) ?? t.prevState
          ;((t.prevState = r), Sk(t))
        }
        for (const t of n) {
          const r = mo.get(t)
          r && (qc.current.push(t), $2(r))
        }
        for (const t of n) {
          const r = mo.get(t)
          if (r) for (const i of r) _k(i)
        }
      }
    } finally {
      ;((fd = !1), (qc.current = []), Kl.clear())
    }
}
function Ma(e) {
  Ca++
  try {
    e()
  } finally {
    if ((Ca--, Ca === 0)) {
      const n = ma.values().next().value
      n && V2(n)
    }
  }
}
function kk(e) {
  return typeof e == 'function'
}
class Nh {
  constructor(n, t) {
    ;((this.listeners = new Set()),
      (this.subscribe = (r) => {
        var i, s
        this.listeners.add(r)
        const o =
          (s = (i = this.options) == null ? void 0 : i.onSubscribe) == null
            ? void 0
            : s.call(i, r, this)
        return () => {
          ;(this.listeners.delete(r), o?.())
        }
      }),
      (this.prevState = n),
      (this.state = n),
      (this.options = t))
  }
  setState(n) {
    var t, r, i
    ;((this.prevState = this.state),
      (t = this.options) != null && t.updateFn
        ? (this.state = this.options.updateFn(this.prevState)(n))
        : kk(n)
          ? (this.state = n(this.prevState))
          : (this.state = n),
      (i = (r = this.options) == null ? void 0 : r.onUpdate) == null || i.call(r),
      V2(this))
  }
}
class go {
  constructor(n) {
    ;((this.listeners = new Set()),
      (this._subscriptions = []),
      (this.lastSeenDepValues = []),
      (this.getDepVals = () => {
        const t = this.options.deps.length,
          r = new Array(t),
          i = new Array(t)
        for (let s = 0; s < t; s++) {
          const o = this.options.deps[s]
          ;((r[s] = o.prevState), (i[s] = o.state))
        }
        return (
          (this.lastSeenDepValues = i),
          { prevDepVals: r, currDepVals: i, prevVal: this.prevState ?? void 0 }
        )
      }),
      (this.recompute = () => {
        var t, r
        this.prevState = this.state
        const i = this.getDepVals()
        ;((this.state = this.options.fn(i)), (r = (t = this.options).onUpdate) == null || r.call(t))
      }),
      (this.checkIfRecalculationNeededDeeply = () => {
        for (const s of this.options.deps) s instanceof go && s.checkIfRecalculationNeededDeeply()
        let t = !1
        const r = this.lastSeenDepValues,
          { currDepVals: i } = this.getDepVals()
        for (let s = 0; s < i.length; s++)
          if (i[s] !== r[s]) {
            t = !0
            break
          }
        t && this.recompute()
      }),
      (this.mount = () => (
        this.registerOnGraph(),
        this.checkIfRecalculationNeededDeeply(),
        () => {
          this.unregisterFromGraph()
          for (const t of this._subscriptions) t()
        }
      )),
      (this.subscribe = (t) => {
        var r, i
        this.listeners.add(t)
        const s = (i = (r = this.options).onSubscribe) == null ? void 0 : i.call(r, t, this)
        return () => {
          ;(this.listeners.delete(t), s?.())
        }
      }),
      (this.options = n),
      (this.state = n.fn({
        prevDepVals: void 0,
        prevVal: void 0,
        currDepVals: this.getDepVals().currDepVals,
      })))
  }
  registerOnGraph(n = this.options.deps) {
    for (const t of n)
      if (t instanceof go) (t.registerOnGraph(), this.registerOnGraph(t.options.deps))
      else if (t instanceof Nh) {
        let r = mo.get(t)
        ;(r || ((r = new Set()), mo.set(t, r)), r.add(this))
        let i = Oc.get(this)
        ;(i || ((i = new Set()), Oc.set(this, i)), i.add(t))
      }
  }
  unregisterFromGraph(n = this.options.deps) {
    for (const t of n)
      if (t instanceof go) this.unregisterFromGraph(t.options.deps)
      else if (t instanceof Nh) {
        const r = mo.get(t)
        r && r.delete(this)
        const i = Oc.get(this)
        i && i.delete(t)
      }
  }
}
const Ni = '__TSR_index',
  Xg = 'popstate',
  Yg = 'beforeunload'
function Ck(e) {
  let n = e.getLocation()
  const t = new Set(),
    r = (o) => {
      ;((n = e.getLocation()), t.forEach((a) => a({ location: n, action: o })))
    },
    i = (o) => {
      ;(e.notifyOnIndexChange ?? !0) ? r(o) : (n = e.getLocation())
    },
    s = async ({ task: o, navigateOpts: a, ...l }) => {
      if (a?.ignoreBlocker ?? !1) {
        o()
        return
      }
      const u = e.getBlockers?.() ?? [],
        f = l.type === 'PUSH' || l.type === 'REPLACE'
      if (typeof document < 'u' && u.length && f)
        for (const d of u) {
          const h = Wc(l.path, l.state)
          if (await d.blockerFn({ currentLocation: n, nextLocation: h, action: l.type })) {
            e.onBlocked?.()
            return
          }
        }
      o()
    }
  return {
    get location() {
      return n
    },
    get length() {
      return e.getLength()
    },
    subscribers: t,
    subscribe: (o) => (
      t.add(o),
      () => {
        t.delete(o)
      }
    ),
    push: (o, a, l) => {
      const c = n.state[Ni]
      ;((a = Zg(c + 1, a)),
        s({
          task: () => {
            ;(e.pushState(o, a), r({ type: 'PUSH' }))
          },
          navigateOpts: l,
          type: 'PUSH',
          path: o,
          state: a,
        }))
    },
    replace: (o, a, l) => {
      const c = n.state[Ni]
      ;((a = Zg(c, a)),
        s({
          task: () => {
            ;(e.replaceState(o, a), r({ type: 'REPLACE' }))
          },
          navigateOpts: l,
          type: 'REPLACE',
          path: o,
          state: a,
        }))
    },
    go: (o, a) => {
      s({
        task: () => {
          ;(e.go(o), i({ type: 'GO', index: o }))
        },
        navigateOpts: a,
        type: 'GO',
      })
    },
    back: (o) => {
      s({
        task: () => {
          ;(e.back(o?.ignoreBlocker ?? !1), i({ type: 'BACK' }))
        },
        navigateOpts: o,
        type: 'BACK',
      })
    },
    forward: (o) => {
      s({
        task: () => {
          ;(e.forward(o?.ignoreBlocker ?? !1), i({ type: 'FORWARD' }))
        },
        navigateOpts: o,
        type: 'FORWARD',
      })
    },
    canGoBack: () => n.state[Ni] !== 0,
    createHref: (o) => e.createHref(o),
    block: (o) => {
      if (!e.setBlockers) return () => {}
      const a = e.getBlockers?.() ?? []
      return (
        e.setBlockers([...a, o]),
        () => {
          const l = e.getBlockers?.() ?? []
          e.setBlockers?.(l.filter((c) => c !== o))
        }
      )
    },
    flush: () => e.flush?.(),
    destroy: () => e.destroy?.(),
    notify: r,
  }
}
function Zg(e, n) {
  n || (n = {})
  const t = km()
  return { ...n, key: t, __TSR_key: t, [Ni]: e }
}
function Mk(e) {
  const n = typeof document < 'u' ? window : void 0,
    t = n.history.pushState,
    r = n.history.replaceState
  let i = []
  const s = () => i,
    o = (E) => (i = E),
    a = (E) => E,
    l = () => Wc(`${n.location.pathname}${n.location.search}${n.location.hash}`, n.history.state)
  if (!n.history.state?.__TSR_key && !n.history.state?.key) {
    const E = km()
    n.history.replaceState({ [Ni]: 0, key: E, __TSR_key: E }, '')
  }
  let c = l(),
    u,
    f = !1,
    d = !1,
    h = !1,
    p = !1
  const g = () => c
  let m, y
  const b = () => {
      m &&
        ((B._ignoreSubscribers = !0),
        (m.isPush ? n.history.pushState : n.history.replaceState)(m.state, '', m.href),
        (B._ignoreSubscribers = !1),
        (m = void 0),
        (y = void 0),
        (u = void 0))
    },
    w = (E, O, P) => {
      const $ = a(O)
      ;(y || (u = c),
        (c = Wc(O, P)),
        (m = { href: $, state: P, isPush: m?.isPush || E === 'push' }),
        y || (y = Promise.resolve().then(() => b())))
    },
    C = (E) => {
      ;((c = l()), B.notify({ type: E }))
    },
    T = async () => {
      if (d) {
        d = !1
        return
      }
      const E = l(),
        O = E.state[Ni] - c.state[Ni],
        P = O === 1,
        $ = O === -1,
        F = (!P && !$) || f
      f = !1
      const M = F ? 'GO' : $ ? 'BACK' : 'FORWARD',
        R = F ? { type: 'GO', index: O } : { type: $ ? 'BACK' : 'FORWARD' }
      if (h) h = !1
      else {
        const k = s()
        if (typeof document < 'u' && k.length) {
          for (const v of k)
            if (await v.blockerFn({ currentLocation: c, nextLocation: E, action: M })) {
              ;((d = !0), n.history.go(1), B.notify(R))
              return
            }
        }
      }
      ;((c = l()), B.notify(R))
    },
    I = (E) => {
      if (p) {
        p = !1
        return
      }
      let O = !1
      const P = s()
      if (typeof document < 'u' && P.length)
        for (const $ of P) {
          const F = $.enableBeforeUnload ?? !0
          if (F === !0) {
            O = !0
            break
          }
          if (typeof F == 'function' && F() === !0) {
            O = !0
            break
          }
        }
      if (O) return (E.preventDefault(), (E.returnValue = ''))
    },
    B = Ck({
      getLocation: g,
      getLength: () => n.history.length,
      pushState: (E, O) => w('push', E, O),
      replaceState: (E, O) => w('replace', E, O),
      back: (E) => (E && (h = !0), (p = !0), n.history.back()),
      forward: (E) => {
        ;(E && (h = !0), (p = !0), n.history.forward())
      },
      go: (E) => {
        ;((f = !0), n.history.go(E))
      },
      createHref: (E) => a(E),
      flush: b,
      destroy: () => {
        ;((n.history.pushState = t),
          (n.history.replaceState = r),
          n.removeEventListener(Yg, I, { capture: !0 }),
          n.removeEventListener(Xg, T))
      },
      onBlocked: () => {
        u && c !== u && (c = u)
      },
      getBlockers: s,
      setBlockers: o,
      notifyOnIndexChange: !1,
    })
  return (
    n.addEventListener(Yg, I, { capture: !0 }),
    n.addEventListener(Xg, T),
    (n.history.pushState = function (...E) {
      const O = t.apply(n.history, E)
      return (B._ignoreSubscribers || C('PUSH'), O)
    }),
    (n.history.replaceState = function (...E) {
      const O = r.apply(n.history, E)
      return (B._ignoreSubscribers || C('REPLACE'), O)
    }),
    B
  )
}
function Wc(e, n) {
  const t = e.indexOf('#'),
    r = e.indexOf('?'),
    i = km()
  return {
    href: e,
    pathname: e.substring(0, t > 0 ? (r > 0 ? Math.min(t, r) : t) : r > 0 ? r : e.length),
    hash: t > -1 ? e.substring(t) : '',
    search: r > -1 ? e.slice(r, t === -1 ? void 0 : t) : '',
    state: n || { [Ni]: 0, key: i, __TSR_key: i },
  }
}
function km() {
  return (Math.random() + 1).toString(36).substring(7)
}
function Ih(e) {
  return e[e.length - 1]
}
function Ek(e) {
  return typeof e == 'function'
}
function Ea(e, n) {
  return Ek(e) ? e(n) : e
}
const Tk = Object.prototype.hasOwnProperty
function dr(e, n) {
  if (e === n) return e
  const t = n,
    r = t1(e) && t1(t)
  if (!r && !(Kc(e) && Kc(t))) return t
  const i = r ? e : Jg(e)
  if (!i) return t
  const s = r ? t : Jg(t)
  if (!s) return t
  const o = i.length,
    a = s.length,
    l = r ? new Array(a) : {}
  let c = 0
  for (let u = 0; u < a; u++) {
    const f = r ? u : s[u],
      d = e[f],
      h = t[f]
    if (d === h) {
      ;((l[f] = d), (r ? u < o : Tk.call(e, f)) && c++)
      continue
    }
    if (d === null || h === null || typeof d != 'object' || typeof h != 'object') {
      l[f] = h
      continue
    }
    const p = dr(d, h)
    ;((l[f] = p), p === d && c++)
  }
  return o === a && c === o ? e : l
}
function Jg(e) {
  const n = [],
    t = Object.getOwnPropertyNames(e)
  for (const i of t) {
    if (!Object.prototype.propertyIsEnumerable.call(e, i)) return !1
    n.push(i)
  }
  const r = Object.getOwnPropertySymbols(e)
  for (const i of r) {
    if (!Object.prototype.propertyIsEnumerable.call(e, i)) return !1
    n.push(i)
  }
  return n
}
function Kc(e) {
  if (!Qg(e)) return !1
  const n = e.constructor
  if (typeof n > 'u') return !0
  const t = n.prototype
  return !(!Qg(t) || !t.hasOwnProperty('isPrototypeOf'))
}
function Qg(e) {
  return Object.prototype.toString.call(e) === '[object Object]'
}
function t1(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}
function yo(e, n, t) {
  if (e === n) return !0
  if (typeof e != typeof n) return !1
  if (Array.isArray(e) && Array.isArray(n)) {
    if (e.length !== n.length) return !1
    for (let r = 0, i = e.length; r < i; r++) if (!yo(e[r], n[r], t)) return !1
    return !0
  }
  if (Kc(e) && Kc(n)) {
    const r = t?.ignoreUndefined ?? !0
    if (t?.partial) {
      for (const o in n) if ((!r || n[o] !== void 0) && !yo(e[o], n[o], t)) return !1
      return !0
    }
    let i = 0
    if (!r) i = Object.keys(e).length
    else for (const o in e) e[o] !== void 0 && i++
    let s = 0
    for (const o in n) if ((!r || n[o] !== void 0) && (s++, s > i || !yo(e[o], n[o], t))) return !1
    return i === s
  }
  return !1
}
function Ga(e) {
  let n, t
  const r = new Promise((i, s) => {
    ;((n = i), (t = s))
  })
  return (
    (r.status = 'pending'),
    (r.resolve = (i) => {
      ;((r.status = 'resolved'), (r.value = i), n(i), e?.(i))
    }),
    (r.reject = (i) => {
      ;((r.status = 'rejected'), t(i))
    }),
    r
  )
}
function CK(e) {
  return typeof e?.message != 'string'
    ? !1
    : e.message.startsWith('Failed to fetch dynamically imported module') ||
        e.message.startsWith('error loading dynamically imported module') ||
        e.message.startsWith('Importing a module script failed')
}
function Ii(e) {
  return !!(e && typeof e == 'object' && typeof e.then == 'function')
}
var Ak = 'Invariant failed'
function Gc(e, n) {
  if (!e) throw new Error(Ak)
}
const pr = '__root__',
  Or = 0,
  As = 1,
  Eo = 2,
  To = 3
function Zr(e) {
  return Cm(e.filter((n) => n !== void 0).join('/'))
}
function Cm(e) {
  return e.replace(/\/{2,}/g, '/')
}
function Mm(e) {
  return e === '/' ? e : e.replace(/^\/{1,}/, '')
}
function bo(e) {
  return e === '/' ? e : e.replace(/\/{1,}$/, '')
}
function Pc(e) {
  return bo(Mm(e))
}
function e1(e, n) {
  return e?.endsWith('/') && e !== '/' && e !== `${n}/` ? e.slice(0, -1) : e
}
function MK(e, n, t) {
  return e1(e, t) === e1(n, t)
}
function Rk(e) {
  const { type: n, value: t } = e
  if (n === Or) return t
  const { prefixSegment: r, suffixSegment: i } = e
  if (n === As) {
    const s = t.substring(1)
    if (r && i) return `${r}{$${s}}${i}`
    if (r) return `${r}{$${s}}`
    if (i) return `{$${s}}${i}`
  }
  if (n === To) {
    const s = t.substring(1)
    return r && i ? `${r}{-$${s}}${i}` : r ? `${r}{-$${s}}` : i ? `{-$${s}}${i}` : `{-$${s}}`
  }
  if (n === Eo) {
    if (r && i) return `${r}{$}${i}`
    if (r) return `${r}{$}`
    if (i) return `{$}${i}`
  }
  return t
}
function Ok({ base: e, to: n, trailingSlash: t = 'never', parseCache: r }) {
  let i = H2(e, r).slice()
  const s = bf(n, r)
  i.length > 1 && Ih(i)?.value === '/' && i.pop()
  for (let l = 0, c = s.length; l < c; l++) {
    const u = s[l],
      f = u.value
    f === '/'
      ? l
        ? l === c - 1 && i.push(u)
        : (i = [u])
      : f === '..'
        ? i.pop()
        : f === '.' || i.push(u)
  }
  i.length > 1 &&
    (Ih(i).value === '/'
      ? t === 'never' && i.pop()
      : t === 'always' && i.push({ type: Or, value: '/' }))
  const o = i.map(Rk)
  return Zr(o)
}
const H2 = (e, n) => U2(e, n, !0),
  bf = (e, n) => U2(e, n, !1),
  U2 = (e, n, t) => {
    if (!e) return []
    const r = n?.get(e)
    if (r) return r
    const i = Lk(e, t)
    return (n?.set(e, i), i)
  },
  Pk = /^\$.{1,}$/,
  Nk = /^(.*?)\{(\$[a-zA-Z_$][a-zA-Z0-9_$]*)\}(.*)$/,
  Ik = /^(.*?)\{-(\$[a-zA-Z_$][a-zA-Z0-9_$]*)\}(.*)$/,
  Dk = /^\$$/,
  jk = /^(.*?)\{\$\}(.*)$/
function Lk(e, n) {
  e = Cm(e)
  const t = []
  if ((e.slice(0, 1) === '/' && ((e = e.substring(1)), t.push({ type: Or, value: '/' })), !e))
    return t
  const r = e.split('/').filter(Boolean)
  return (
    t.push(
      ...r.map((i) => {
        const s = !n && i !== pr && i.slice(-1) === '_' ? i.slice(0, -1) : i,
          o = s.match(jk)
        if (o) {
          const c = o[1],
            u = o[2]
          return { type: Eo, value: '$', prefixSegment: c || void 0, suffixSegment: u || void 0 }
        }
        const a = s.match(Ik)
        if (a) {
          const c = a[1],
            u = a[2],
            f = a[3]
          return { type: To, value: u, prefixSegment: c || void 0, suffixSegment: f || void 0 }
        }
        const l = s.match(Nk)
        if (l) {
          const c = l[1],
            u = l[2],
            f = l[3]
          return { type: As, value: '' + u, prefixSegment: c || void 0, suffixSegment: f || void 0 }
        }
        if (Pk.test(s)) {
          const c = s.substring(1)
          return { type: As, value: '$' + c, prefixSegment: void 0, suffixSegment: void 0 }
        }
        return Dk.test(s)
          ? { type: Eo, value: '$', prefixSegment: void 0, suffixSegment: void 0 }
          : {
              type: Or,
              value: s.includes('%25')
                ? s
                    .split('%25')
                    .map((c) => decodeURI(c))
                    .join('%25')
                : decodeURI(s),
            }
      }),
    ),
    e.slice(-1) === '/' && ((e = e.substring(1)), t.push({ type: Or, value: '/' })),
    t
  )
}
function Gl({
  path: e,
  params: n,
  leaveWildcards: t,
  leaveParams: r,
  decodeCharMap: i,
  parseCache: s,
}) {
  const o = bf(e, s)
  function a(f) {
    const d = n[f],
      h = typeof d == 'string'
    return f === '*' || f === '_splat' ? (h ? encodeURI(d) : d) : h ? Fk(d, i) : d
  }
  let l = !1
  const c = {},
    u = Zr(
      o.map((f) => {
        if (f.type === Or) return f.value
        if (f.type === Eo) {
          ;((c._splat = n._splat), (c['*'] = n._splat))
          const d = f.prefixSegment || '',
            h = f.suffixSegment || ''
          if (!('_splat' in n))
            return ((l = !0), t ? `${d}${f.value}${h}` : d || h ? `${d}${h}` : void 0)
          const p = a('_splat')
          return t ? `${d}${f.value}${p ?? ''}${h}` : `${d}${p}${h}`
        }
        if (f.type === As) {
          const d = f.value.substring(1)
          ;(!l && !(d in n) && (l = !0), (c[d] = n[d]))
          const h = f.prefixSegment || '',
            p = f.suffixSegment || ''
          if (r) {
            const g = a(f.value)
            return `${h}${f.value}${g ?? ''}${p}`
          }
          return `${h}${a(d) ?? 'undefined'}${p}`
        }
        if (f.type === To) {
          const d = f.value.substring(1),
            h = f.prefixSegment || '',
            p = f.suffixSegment || ''
          if (!(d in n) || n[d] == null) return t ? `${h}${d}${p}` : h || p ? `${h}${p}` : void 0
          if (((c[d] = n[d]), r)) {
            const g = a(f.value)
            return `${h}${f.value}${g ?? ''}${p}`
          }
          return t ? `${h}${d}${a(d) ?? ''}${p}` : `${h}${a(d) ?? ''}${p}`
        }
        return f.value
      }),
    )
  return { usedParams: c, interpolatedPath: u, isMissingParams: l }
}
function Fk(e, n) {
  let t = encodeURIComponent(e)
  if (n) for (const [r, i] of n) t = t.replaceAll(r, i)
  return t
}
function Dh(e, n, t) {
  const r = Bk(e, n, t)
  if (!(n.to && !r)) return r ?? {}
}
function Bk(e, { to: n, fuzzy: t, caseSensitive: r }, i) {
  const s = n,
    o = H2(e.startsWith('/') ? e : `/${e}`, i),
    a = bf(s.startsWith('/') ? s : `/${s}`, i),
    l = {}
  return zk(o, a, l, t, r) ? l : void 0
}
function zk(e, n, t, r, i) {
  let s = 0,
    o = 0
  for (; s < e.length || o < n.length; ) {
    const a = e[s],
      l = n[o]
    if (l) {
      if (l.type === Eo) {
        const c = e.slice(s)
        let u
        if (l.prefixSegment || l.suffixSegment) {
          if (!a) return !1
          const f = l.prefixSegment || '',
            d = l.suffixSegment || '',
            h = a.value
          if (
            ('prefixSegment' in l && !h.startsWith(f)) ||
            ('suffixSegment' in l && !e[e.length - 1]?.value.endsWith(d))
          )
            return !1
          let p = decodeURI(Zr(c.map((g) => g.value)))
          ;(f && p.startsWith(f) && (p = p.slice(f.length)),
            d && p.endsWith(d) && (p = p.slice(0, p.length - d.length)),
            (u = p))
        } else u = decodeURI(Zr(c.map((f) => f.value)))
        return ((t['*'] = u), (t._splat = u), !0)
      }
      if (l.type === Or) {
        if (l.value === '/' && !a?.value) {
          o++
          continue
        }
        if (a) {
          if (i) {
            if (l.value !== a.value) return !1
          } else if (l.value.toLowerCase() !== a.value.toLowerCase()) return !1
          ;(s++, o++)
          continue
        } else return !1
      }
      if (l.type === As) {
        if (!a || a.value === '/') return !1
        let c = '',
          u = !1
        if (l.prefixSegment || l.suffixSegment) {
          const f = l.prefixSegment || '',
            d = l.suffixSegment || '',
            h = a.value
          if ((f && !h.startsWith(f)) || (d && !h.endsWith(d))) return !1
          let p = h
          ;(f && p.startsWith(f) && (p = p.slice(f.length)),
            d && p.endsWith(d) && (p = p.slice(0, p.length - d.length)),
            (c = decodeURIComponent(p)),
            (u = !0))
        } else ((c = decodeURIComponent(a.value)), (u = !0))
        ;(u && ((t[l.value.substring(1)] = c), s++), o++)
        continue
      }
      if (l.type === To) {
        if (!a) {
          o++
          continue
        }
        if (a.value === '/') {
          o++
          continue
        }
        let c = '',
          u = !1
        if (l.prefixSegment || l.suffixSegment) {
          const f = l.prefixSegment || '',
            d = l.suffixSegment || '',
            h = a.value
          if ((!f || h.startsWith(f)) && (!d || h.endsWith(d))) {
            let p = h
            ;(f && p.startsWith(f) && (p = p.slice(f.length)),
              d && p.endsWith(d) && (p = p.slice(0, p.length - d.length)),
              (c = decodeURIComponent(p)),
              (u = !0))
          }
        } else {
          let f = !0
          for (let d = o + 1; d < n.length; d++) {
            const h = n[d]
            if (h?.type === Or && h.value === a.value) {
              f = !1
              break
            }
            if (h?.type === As || h?.type === Eo) {
              e.length < n.length && (f = !1)
              break
            }
          }
          f && ((c = decodeURIComponent(a.value)), (u = !0))
        }
        ;(u && ((t[l.value.substring(1)] = c), s++), o++)
        continue
      }
    }
    if (s < e.length && o >= n.length)
      return ((t['**'] = Zr(e.slice(s).map((c) => c.value))), !!r && n[n.length - 1]?.value !== '/')
    if (o < n.length && s >= e.length) {
      for (let c = o; c < n.length; c++) if (n[c]?.type !== To) return !1
      break
    }
    break
  }
  return !0
}
const $k = 0.75,
  Vk = 1,
  Hk = 0.5,
  Uk = 0.4,
  qk = 0.25,
  Wk = 0.2,
  Kk = 0.05,
  Gk = 0.02,
  Xk = 0.01,
  n1 = 2e-4,
  r1 = 1e-4
function i1(e, n) {
  return e.prefixSegment && e.suffixSegment
    ? n + Kk + n1 * e.prefixSegment.length + r1 * e.suffixSegment.length
    : e.prefixSegment
      ? n + Gk + n1 * e.prefixSegment.length
      : e.suffixSegment
        ? n + Xk + r1 * e.suffixSegment.length
        : n
}
function Yk(e) {
  const n = []
  return (
    e.forEach((r, i) => {
      if (r.isRoot || !r.path) return
      const s = Mm(r.fullPath)
      let o = bf(s),
        a = 0
      for (; o.length > a + 1 && o[a]?.value === '/'; ) a++
      a > 0 && (o = o.slice(a))
      let l = 0,
        c = !1
      const u = o.map((f, d) => {
        if (f.value === '/') return $k
        if (f.type === Or) return Vk
        let h
        f.type === As ? (h = Hk) : f.type === To ? ((h = Uk), l++) : (h = qk)
        for (let p = d + 1; p < o.length; p++) {
          const g = o[p]
          if (g.type === Or && g.value !== '/') return ((c = !0), i1(f, h + Wk))
        }
        return i1(f, h)
      })
      n.push({
        child: r,
        trimmed: s,
        parsed: o,
        index: i,
        scores: u,
        optionalParamCount: l,
        hasStaticAfter: c,
      })
    }),
    n
      .sort((r, i) => {
        const s = Math.min(r.scores.length, i.scores.length)
        for (let o = 0; o < s; o++)
          if (r.scores[o] !== i.scores[o]) return i.scores[o] - r.scores[o]
        if (r.scores.length !== i.scores.length) {
          if (r.optionalParamCount !== i.optionalParamCount) {
            if (r.hasStaticAfter === i.hasStaticAfter)
              return r.optionalParamCount - i.optionalParamCount
            if (r.hasStaticAfter && !i.hasStaticAfter) return -1
            if (!r.hasStaticAfter && i.hasStaticAfter) return 1
          }
          return i.scores.length - r.scores.length
        }
        for (let o = 0; o < s; o++)
          if (r.parsed[o].value !== i.parsed[o].value)
            return r.parsed[o].value > i.parsed[o].value ? 1 : -1
        return r.index - i.index
      })
      .map((r, i) => ((r.child.rank = i), r.child))
  )
}
function Zk({ routeTree: e, initRoute: n }) {
  const t = {},
    r = {},
    i = (o) => {
      o.forEach((a, l) => {
        n?.(a, l)
        const c = t[a.id]
        if (
          (Gc(!c, `Duplicate routes found with id: ${String(a.id)}`),
          (t[a.id] = a),
          !a.isRoot && a.path)
        ) {
          const f = bo(a.fullPath)
          ;(!r[f] || a.fullPath.endsWith('/')) && (r[f] = a)
        }
        const u = a.children
        u?.length && i(u)
      })
    }
  i([e])
  const s = Yk(Object.values(t))
  return { routesById: t, routesByPath: r, flatRoutes: s }
}
function Ao(e) {
  return !!e?.isNotFound
}
function Jk() {
  try {
    if (typeof window < 'u' && typeof window.sessionStorage == 'object')
      return window.sessionStorage
  } catch {}
}
const jh = 'tsr-scroll-restoration-v1_3',
  Qk = (e, n) => {
    let t
    return (...r) => {
      t ||
        (t = setTimeout(() => {
          ;(e(...r), (t = null))
        }, n))
    }
  }
function t8() {
  const e = Jk()
  if (!e) return null
  const n = e.getItem(jh)
  let t = n ? JSON.parse(n) : {}
  return { state: t, set: (r) => ((t = Ea(r, t) || t), e.setItem(jh, JSON.stringify(t))) }
}
const Xl = t8(),
  e8 = (e) => e.state.__TSR_key || e.href
function n8(e) {
  const n = []
  let t
  for (; (t = e.parentNode); )
    (n.push(`${e.tagName}:nth-child(${Array.prototype.indexOf.call(t.children, e) + 1})`), (e = t))
  return `${n.reverse().join(' > ')}`.toLowerCase()
}
let Xc = !1
function r8({
  storageKey: e,
  key: n,
  behavior: t,
  shouldScrollRestoration: r,
  scrollToTopSelectors: i,
  location: s,
}) {
  let o
  try {
    o = JSON.parse(sessionStorage.getItem(e) || '{}')
  } catch (c) {
    console.error(c)
    return
  }
  const a = n || window.history.state?.__TSR_key,
    l = o[a]
  Xc = !0
  t: {
    if (r && l && Object.keys(l).length > 0) {
      for (const f in l) {
        const d = l[f]
        if (f === 'window') window.scrollTo({ top: d.scrollY, left: d.scrollX, behavior: t })
        else if (f) {
          const h = document.querySelector(f)
          h && ((h.scrollLeft = d.scrollX), (h.scrollTop = d.scrollY))
        }
      }
      break t
    }
    const c = (s ?? window.location).hash.split('#', 2)[1]
    if (c) {
      const f = window.history.state?.__hashScrollIntoViewOptions ?? !0
      if (f) {
        const d = document.getElementById(c)
        d && d.scrollIntoView(f)
      }
      break t
    }
    const u = { top: 0, left: 0, behavior: t }
    if ((window.scrollTo(u), i))
      for (const f of i) {
        if (f === 'window') continue
        const d = typeof f == 'function' ? f() : document.querySelector(f)
        d && d.scrollTo(u)
      }
  }
  Xc = !1
}
function i8(e, n) {
  if (
    (!Xl && !e.isServer) ||
    ((e.options.scrollRestoration ?? !1) && (e.isScrollRestoring = !0),
    e.isServer || e.isScrollRestorationSetup || !Xl)
  )
    return
  ;((e.isScrollRestorationSetup = !0), (Xc = !1))
  const r = e.options.getScrollRestorationKey || e8
  window.history.scrollRestoration = 'manual'
  const i = (s) => {
    if (Xc || !e.isScrollRestoring) return
    let o = ''
    if (s.target === document || s.target === window) o = 'window'
    else {
      const l = s.target.getAttribute('data-scroll-restoration-id')
      l ? (o = `[data-scroll-restoration-id="${l}"]`) : (o = n8(s.target))
    }
    const a = r(e.state.location)
    Xl.set((l) => {
      const c = (l[a] ||= {}),
        u = (c[o] ||= {})
      if (o === 'window') ((u.scrollX = window.scrollX || 0), (u.scrollY = window.scrollY || 0))
      else if (o) {
        const f = document.querySelector(o)
        f && ((u.scrollX = f.scrollLeft || 0), (u.scrollY = f.scrollTop || 0))
      }
      return l
    })
  }
  ;(typeof document < 'u' && document.addEventListener('scroll', Qk(i, 100), !0),
    e.subscribe('onRendered', (s) => {
      const o = r(s.toLocation)
      if (!e.resetNextScroll) {
        e.resetNextScroll = !0
        return
      }
      ;(typeof e.options.scrollRestoration == 'function' &&
        !e.options.scrollRestoration({ location: e.latestLocation })) ||
        (r8({
          storageKey: jh,
          key: o,
          behavior: e.options.scrollRestorationBehavior,
          shouldScrollRestoration: e.isScrollRestoring,
          scrollToTopSelectors: e.options.scrollToTopSelectors,
          location: e.history.location,
        }),
        e.isScrollRestoring && Xl.set((a) => ((a[o] ||= {}), a)))
    }))
}
function EK(e) {
  if (typeof document < 'u' && document.querySelector) {
    const n = e.state.location.state.__hashScrollIntoViewOptions ?? !0
    if (n && e.state.location.hash !== '') {
      const t = document.getElementById(e.state.location.hash)
      t && t.scrollIntoView(n)
    }
  }
}
function s8(e, n = String) {
  const t = new URLSearchParams()
  for (const r in e) {
    const i = e[r]
    i !== void 0 && t.set(r, n(i))
  }
  return t.toString()
}
function dd(e) {
  return e ? (e === 'false' ? !1 : e === 'true' ? !0 : +e * 0 === 0 && +e + '' === e ? +e : e) : ''
}
function o8(e) {
  const n = new URLSearchParams(e),
    t = {}
  for (const [r, i] of n.entries()) {
    const s = t[r]
    s == null ? (t[r] = dd(i)) : Array.isArray(s) ? s.push(dd(i)) : (t[r] = [s, dd(i)])
  }
  return t
}
const a8 = c8(JSON.parse),
  l8 = u8(JSON.stringify, JSON.parse)
function c8(e) {
  return (n) => {
    n[0] === '?' && (n = n.substring(1))
    const t = o8(n)
    for (const r in t) {
      const i = t[r]
      if (typeof i == 'string')
        try {
          t[r] = e(i)
        } catch {}
    }
    return t
  }
}
function u8(e, n) {
  const t = typeof n == 'function'
  function r(i) {
    if (typeof i == 'object' && i !== null)
      try {
        return e(i)
      } catch {}
    else if (t && typeof i == 'string')
      try {
        return (n(i), e(i))
      } catch {}
    return i
  }
  return (i) => {
    const s = s8(i, r)
    return s ? `?${s}` : ''
  }
}
function f8(e) {
  if (
    ((e.statusCode = e.statusCode || e.code || 307), !e.reloadDocument && typeof e.href == 'string')
  )
    try {
      ;(new URL(e.href), (e.reloadDocument = !0))
    } catch {}
  const n = new Headers(e.headers)
  e.href && n.get('Location') === null && n.set('Location', e.href)
  const t = new Response(null, { status: e.statusCode, headers: n })
  if (((t.options = e), e.throw)) throw t
  return t
}
function Xr(e) {
  return e instanceof Response && !!e.options
}
function d8(e) {
  const n = new Map()
  let t, r
  const i = (s) => {
    s.next &&
      (s.prev
        ? ((s.prev.next = s.next),
          (s.next.prev = s.prev),
          (s.next = void 0),
          r && ((r.next = s), (s.prev = r)))
        : ((s.next.prev = void 0),
          (t = s.next),
          (s.next = void 0),
          r && ((s.prev = r), (r.next = s))),
      (r = s))
  }
  return {
    get(s) {
      const o = n.get(s)
      if (o) return (i(o), o.value)
    },
    set(s, o) {
      if (n.size >= e && t) {
        const l = t
        ;(n.delete(l.key),
          l.next && ((t = l.next), (l.next.prev = void 0)),
          l === r && (r = void 0))
      }
      const a = n.get(s)
      if (a) ((a.value = o), i(a))
      else {
        const l = { key: s, value: o, prev: r }
        ;(r && (r.next = l), (r = l), t || (t = l), n.set(s, l))
      }
    },
  }
}
const Nc = (e) => {
    if (!e.rendered) return ((e.rendered = !0), e.onReady?.())
  },
  vf = (e, n) => !!(e.preload && !e.router.state.matches.some((t) => t.id === n)),
  q2 = (e, n) => {
    const t = e.router.routesById[n.routeId ?? ''] ?? e.router.routeTree
    ;(!t.options.notFoundComponent &&
      e.router.options?.defaultNotFoundComponent &&
      (t.options.notFoundComponent = e.router.options.defaultNotFoundComponent),
      Gc(t.options.notFoundComponent))
    const r = e.matches.find((i) => i.routeId === t.id)
    ;(Gc(r, 'Could not find match for route: ' + t.id),
      e.updateMatch(r.id, (i) => ({ ...i, status: 'notFound', error: n, isFetching: !1 })),
      n.routerCode === 'BEFORE_LOAD' && t.parentRoute && ((n.routeId = t.parentRoute.id), q2(e, n)))
  },
  Ti = (e, n, t) => {
    if (!(!Xr(t) && !Ao(t))) {
      if (Xr(t) && t.redirectHandled && !t.options.reloadDocument) throw t
      if (n) {
        ;(n._nonReactive.beforeLoadPromise?.resolve(),
          n._nonReactive.loaderPromise?.resolve(),
          (n._nonReactive.beforeLoadPromise = void 0),
          (n._nonReactive.loaderPromise = void 0))
        const r = Xr(t) ? 'redirected' : 'notFound'
        ;(e.updateMatch(n.id, (i) => ({ ...i, status: r, isFetching: !1, error: t })),
          Ao(t) && !t.routeId && (t.routeId = n.routeId),
          n._nonReactive.loadPromise?.resolve())
      }
      throw Xr(t)
        ? ((e.rendered = !0),
          (t.options._fromLocation = e.location),
          (t.redirectHandled = !0),
          (t = e.router.resolveRedirect(t)),
          t)
        : (q2(e, t), t)
    }
  },
  W2 = (e, n) => {
    const t = e.router.getMatch(n)
    return !!(
      (!e.router.isServer && t._nonReactive.dehydrated) ||
      (e.router.isServer && t.ssr === !1)
    )
  },
  sa = (e, n, t, r) => {
    const { id: i, routeId: s } = e.matches[n],
      o = e.router.looseRoutesById[s]
    if (t instanceof Promise) throw t
    ;((t.routerCode = r), (e.firstBadMatchIndex ??= n), Ti(e, e.router.getMatch(i), t))
    try {
      o.options.onError?.(t)
    } catch (a) {
      ;((t = a), Ti(e, e.router.getMatch(i), t))
    }
    e.updateMatch(
      i,
      (a) => (
        a._nonReactive.beforeLoadPromise?.resolve(),
        (a._nonReactive.beforeLoadPromise = void 0),
        a._nonReactive.loadPromise?.resolve(),
        {
          ...a,
          error: t,
          status: 'error',
          isFetching: !1,
          updatedAt: Date.now(),
          abortController: new AbortController(),
        }
      ),
    )
  },
  h8 = (e, n, t, r) => {
    const i = e.router.getMatch(n),
      s = e.matches[t - 1]?.id,
      o = s ? e.router.getMatch(s) : void 0
    if (e.router.isShell()) {
      i.ssr = n === pr
      return
    }
    if (o?.ssr === !1) {
      i.ssr = !1
      return
    }
    const a = (h) => (h === !0 && o?.ssr === 'data-only' ? 'data-only' : h),
      l = e.router.options.defaultSsr ?? !0
    if (r.options.ssr === void 0) {
      i.ssr = a(l)
      return
    }
    if (typeof r.options.ssr != 'function') {
      i.ssr = a(r.options.ssr)
      return
    }
    const { search: c, params: u } = i,
      f = {
        search: Yl(c, i.searchError),
        params: Yl(u, i.paramsError),
        location: e.location,
        matches: e.matches.map((h) => ({
          index: h.index,
          pathname: h.pathname,
          fullPath: h.fullPath,
          staticData: h.staticData,
          id: h.id,
          routeId: h.routeId,
          search: Yl(h.search, h.searchError),
          params: Yl(h.params, h.paramsError),
          ssr: h.ssr,
        })),
      },
      d = r.options.ssr(f)
    if (Ii(d))
      return d.then((h) => {
        i.ssr = a(h ?? l)
      })
    i.ssr = a(d ?? l)
  },
  K2 = (e, n, t, r) => {
    if (r._nonReactive.pendingTimeout !== void 0) return
    const i = t.options.pendingMs ?? e.router.options.defaultPendingMs
    if (
      !!(
        e.onReady &&
        !e.router.isServer &&
        !vf(e, n) &&
        (t.options.loader || t.options.beforeLoad || Y2(t)) &&
        typeof i == 'number' &&
        i !== 1 / 0 &&
        (t.options.pendingComponent ?? e.router.options?.defaultPendingComponent)
      )
    ) {
      const o = setTimeout(() => {
        Nc(e)
      }, i)
      r._nonReactive.pendingTimeout = o
    }
  },
  p8 = (e, n, t) => {
    const r = e.router.getMatch(n)
    if (!r._nonReactive.beforeLoadPromise && !r._nonReactive.loaderPromise) return
    K2(e, n, t, r)
    const i = () => {
      const s = e.router.getMatch(n)
      s.preload && (s.status === 'redirected' || s.status === 'notFound') && Ti(e, s, s.error)
    }
    return r._nonReactive.beforeLoadPromise ? r._nonReactive.beforeLoadPromise.then(i) : i()
  },
  m8 = (e, n, t, r) => {
    const i = e.router.getMatch(n),
      s = i._nonReactive.loadPromise
    i._nonReactive.loadPromise = Ga(() => {
      s?.resolve()
    })
    const { paramsError: o, searchError: a } = i
    ;(o && sa(e, t, o, 'PARSE_PARAMS'), a && sa(e, t, a, 'VALIDATE_SEARCH'), K2(e, n, r, i))
    const l = new AbortController(),
      c = e.matches[t - 1]?.id,
      d = {
        ...((c ? e.router.getMatch(c) : void 0)?.context ?? e.router.options.context ?? void 0),
        ...i.__routeContext,
      }
    let h = !1
    const p = () => {
        h ||
          ((h = !0),
          e.updateMatch(n, (B) => ({
            ...B,
            isFetching: 'beforeLoad',
            fetchCount: B.fetchCount + 1,
            abortController: l,
            context: d,
          })))
      },
      g = () => {
        ;(i._nonReactive.beforeLoadPromise?.resolve(),
          (i._nonReactive.beforeLoadPromise = void 0),
          e.updateMatch(n, (B) => ({ ...B, isFetching: !1 })))
      }
    if (!r.options.beforeLoad) {
      Ma(() => {
        ;(p(), g())
      })
      return
    }
    i._nonReactive.beforeLoadPromise = Ga()
    const { search: m, params: y, cause: b } = i,
      w = vf(e, n),
      C = {
        search: m,
        abortController: l,
        params: y,
        preload: w,
        context: d,
        location: e.location,
        navigate: (B) => e.router.navigate({ ...B, _fromLocation: e.location }),
        buildLocation: e.router.buildLocation,
        cause: w ? 'preload' : b,
        matches: e.matches,
        ...e.router.options.additionalContext,
      },
      T = (B) => {
        if (B === void 0) {
          Ma(() => {
            ;(p(), g())
          })
          return
        }
        ;((Xr(B) || Ao(B)) && (p(), sa(e, t, B, 'BEFORE_LOAD')),
          Ma(() => {
            ;(p(),
              e.updateMatch(n, (E) => ({
                ...E,
                __beforeLoadContext: B,
                context: { ...E.context, ...B },
              })),
              g())
          }))
      }
    let I
    try {
      if (((I = r.options.beforeLoad(C)), Ii(I)))
        return (
          p(),
          I.catch((B) => {
            sa(e, t, B, 'BEFORE_LOAD')
          }).then(T)
        )
    } catch (B) {
      ;(p(), sa(e, t, B, 'BEFORE_LOAD'))
    }
    T(I)
  },
  g8 = (e, n) => {
    const { id: t, routeId: r } = e.matches[n],
      i = e.router.looseRoutesById[r],
      s = () => {
        if (e.router.isServer) {
          const l = h8(e, t, n, i)
          if (Ii(l)) return l.then(a)
        }
        return a()
      },
      o = () => m8(e, t, n, i),
      a = () => {
        if (W2(e, t)) return
        const l = p8(e, t, i)
        return Ii(l) ? l.then(o) : o()
      }
    return s()
  },
  Ta = (e, n, t) => {
    const r = e.router.getMatch(n)
    if (!r || (!t.options.head && !t.options.scripts && !t.options.headers)) return
    const i = { matches: e.matches, match: r, params: r.params, loaderData: r.loaderData }
    return Promise.all([t.options.head?.(i), t.options.scripts?.(i), t.options.headers?.(i)]).then(
      ([s, o, a]) => {
        const l = s?.meta,
          c = s?.links,
          u = s?.scripts,
          f = s?.styles
        return { meta: l, links: c, headScripts: u, headers: a, scripts: o, styles: f }
      },
    )
  },
  G2 = (e, n, t, r) => {
    const i = e.matchPromises[t - 1],
      { params: s, loaderDeps: o, abortController: a, context: l, cause: c } = e.router.getMatch(n),
      u = vf(e, n)
    return {
      params: s,
      deps: o,
      preload: !!u,
      parentMatchPromise: i,
      abortController: a,
      context: l,
      location: e.location,
      navigate: (f) => e.router.navigate({ ...f, _fromLocation: e.location }),
      cause: u ? 'preload' : c,
      route: r,
      ...e.router.options.additionalContext,
    }
  },
  s1 = async (e, n, t, r) => {
    try {
      const i = e.router.getMatch(n)
      try {
        ;(!e.router.isServer || i.ssr === !0) && X2(r)
        const s = r.options.loader?.(G2(e, n, t, r)),
          o = r.options.loader && Ii(s)
        if (
          (!!(
            o ||
            r._lazyPromise ||
            r._componentsPromise ||
            r.options.head ||
            r.options.scripts ||
            r.options.headers ||
            i._nonReactive.minPendingPromise
          ) && e.updateMatch(n, (f) => ({ ...f, isFetching: 'loader' })),
          r.options.loader)
        ) {
          const f = o ? await s : s
          ;(Ti(e, e.router.getMatch(n), f),
            f !== void 0 && e.updateMatch(n, (d) => ({ ...d, loaderData: f })))
        }
        r._lazyPromise && (await r._lazyPromise)
        const l = Ta(e, n, r),
          c = l ? await l : void 0,
          u = i._nonReactive.minPendingPromise
        ;(u && (await u),
          r._componentsPromise && (await r._componentsPromise),
          e.updateMatch(n, (f) => ({
            ...f,
            error: void 0,
            status: 'success',
            isFetching: !1,
            updatedAt: Date.now(),
            ...c,
          })))
      } catch (s) {
        let o = s
        const a = i._nonReactive.minPendingPromise
        ;(a && (await a), Ti(e, e.router.getMatch(n), s))
        try {
          r.options.onError?.(s)
        } catch (u) {
          ;((o = u), Ti(e, e.router.getMatch(n), u))
        }
        const l = Ta(e, n, r),
          c = l ? await l : void 0
        e.updateMatch(n, (u) => ({ ...u, error: o, status: 'error', isFetching: !1, ...c }))
      }
    } catch (i) {
      const s = e.router.getMatch(n)
      if (s) {
        const o = Ta(e, n, r)
        if (o) {
          const a = await o
          e.updateMatch(n, (l) => ({ ...l, ...a }))
        }
        s._nonReactive.loaderPromise = void 0
      }
      Ti(e, s, i)
    }
  },
  y8 = async (e, n) => {
    const { id: t, routeId: r } = e.matches[n]
    let i = !1,
      s = !1
    const o = e.router.looseRoutesById[r]
    if (W2(e, t)) {
      if (e.router.isServer) {
        const c = Ta(e, t, o)
        if (c) {
          const u = await c
          e.updateMatch(t, (f) => ({ ...f, ...u }))
        }
        return e.router.getMatch(t)
      }
    } else {
      const c = e.router.getMatch(t)
      if (c._nonReactive.loaderPromise) {
        if (c.status === 'success' && !e.sync && !c.preload) return c
        await c._nonReactive.loaderPromise
        const u = e.router.getMatch(t)
        u.error && Ti(e, u, u.error)
      } else {
        const u = Date.now() - c.updatedAt,
          f = vf(e, t),
          d = f
            ? (o.options.preloadStaleTime ?? e.router.options.defaultPreloadStaleTime ?? 3e4)
            : (o.options.staleTime ?? e.router.options.defaultStaleTime ?? 0),
          h = o.options.shouldReload,
          p = typeof h == 'function' ? h(G2(e, t, n, o)) : h,
          g = !!f && !e.router.state.matches.some((w) => w.id === t),
          m = e.router.getMatch(t)
        ;((m._nonReactive.loaderPromise = Ga()),
          g !== m.preload && e.updateMatch(t, (w) => ({ ...w, preload: g })))
        const { status: y, invalid: b } = m
        if (((i = y === 'success' && (b || (p ?? u > d))), !(f && o.options.preload === !1)))
          if (i && !e.sync)
            ((s = !0),
              (async () => {
                try {
                  await s1(e, t, n, o)
                  const w = e.router.getMatch(t)
                  ;(w._nonReactive.loaderPromise?.resolve(),
                    w._nonReactive.loadPromise?.resolve(),
                    (w._nonReactive.loaderPromise = void 0))
                } catch (w) {
                  Xr(w) && (await e.router.navigate(w.options))
                }
              })())
          else if (y !== 'success' || (i && e.sync)) await s1(e, t, n, o)
          else {
            const w = Ta(e, t, o)
            if (w) {
              const C = await w
              e.updateMatch(t, (T) => ({ ...T, ...C }))
            }
          }
      }
    }
    const a = e.router.getMatch(t)
    ;(s || (a._nonReactive.loaderPromise?.resolve(), a._nonReactive.loadPromise?.resolve()),
      clearTimeout(a._nonReactive.pendingTimeout),
      (a._nonReactive.pendingTimeout = void 0),
      s || (a._nonReactive.loaderPromise = void 0),
      (a._nonReactive.dehydrated = void 0))
    const l = s ? a.isFetching : !1
    return l !== a.isFetching || a.invalid !== !1
      ? (e.updateMatch(t, (c) => ({ ...c, isFetching: l, invalid: !1 })), e.router.getMatch(t))
      : a
  }
async function o1(e) {
  const n = Object.assign(e, { matchPromises: [] })
  !n.router.isServer && n.router.state.matches.some((t) => t._forcePending) && Nc(n)
  try {
    for (let i = 0; i < n.matches.length; i++) {
      const s = g8(n, i)
      Ii(s) && (await s)
    }
    const t = n.firstBadMatchIndex ?? n.matches.length
    for (let i = 0; i < t; i++) n.matchPromises.push(y8(n, i))
    await Promise.all(n.matchPromises)
    const r = Nc(n)
    Ii(r) && (await r)
  } catch (t) {
    if (Ao(t) && !n.preload) {
      const r = Nc(n)
      throw (Ii(r) && (await r), t)
    }
    if (Xr(t)) throw t
  }
  return n.matches
}
async function X2(e) {
  if (
    (!e._lazyLoaded &&
      e._lazyPromise === void 0 &&
      (e.lazyFn
        ? (e._lazyPromise = e.lazyFn().then((n) => {
            const { id: t, ...r } = n.options
            ;(Object.assign(e.options, r), (e._lazyLoaded = !0), (e._lazyPromise = void 0))
          }))
        : (e._lazyLoaded = !0)),
    !e._componentsLoaded && e._componentsPromise === void 0)
  ) {
    const n = () => {
      const t = []
      for (const r of Z2) {
        const i = e.options[r]?.preload
        i && t.push(i())
      }
      if (t.length)
        return Promise.all(t).then(() => {
          ;((e._componentsLoaded = !0), (e._componentsPromise = void 0))
        })
      ;((e._componentsLoaded = !0), (e._componentsPromise = void 0))
    }
    e._componentsPromise = e._lazyPromise ? e._lazyPromise.then(n) : n()
  }
  return e._componentsPromise
}
function Yl(e, n) {
  return n ? { status: 'error', error: n } : { status: 'success', value: e }
}
function Y2(e) {
  for (const n of Z2) if (e.options[n]?.preload) return !0
  return !1
}
const Z2 = ['component', 'errorComponent', 'pendingComponent', 'notFoundComponent']
function b8(e) {
  return {
    input: ({ url: n }) => {
      for (const t of e) n = J2(t, n)
      return n
    },
    output: ({ url: n }) => {
      for (let t = e.length - 1; t >= 0; t--) n = Q2(e[t], n)
      return n
    },
  }
}
function v8(e) {
  const n = Pc(e.basepath),
    t = `/${n}`,
    r = `${t}/`,
    i = e.caseSensitive ? t : t.toLowerCase(),
    s = e.caseSensitive ? r : r.toLowerCase()
  return {
    input: ({ url: o }) => {
      const a = e.caseSensitive ? o.pathname : o.pathname.toLowerCase()
      return (
        a === i ? (o.pathname = '/') : a.startsWith(s) && (o.pathname = o.pathname.slice(t.length)),
        o
      )
    },
    output: ({ url: o }) => ((o.pathname = Zr(['/', n, o.pathname])), o),
  }
}
function J2(e, n) {
  const t = e?.input?.({ url: n })
  if (t) {
    if (typeof t == 'string') return new URL(t)
    if (t instanceof URL) return t
  }
  return n
}
function Q2(e, n) {
  const t = e?.output?.({ url: n })
  if (t) {
    if (typeof t == 'string') return new URL(t)
    if (t instanceof URL) return t
  }
  return n
}
function hd(e) {
  const n = e.resolvedLocation,
    t = e.location,
    r = n?.pathname !== t.pathname,
    i = n?.href !== t.href,
    s = n?.hash !== t.hash
  return { fromLocation: n, toLocation: t, pathChanged: r, hrefChanged: i, hashChanged: s }
}
class TK {
  constructor(n) {
    ;((this.tempLocationKey = `${Math.round(Math.random() * 1e7)}`),
      (this.resetNextScroll = !0),
      (this.shouldViewTransition = void 0),
      (this.isViewTransitionTypesSupported = void 0),
      (this.subscribers = new Set()),
      (this.isScrollRestoring = !1),
      (this.isScrollRestorationSetup = !1),
      (this.startTransition = (t) => t()),
      (this.update = (t) => {
        t.notFoundRoute &&
          console.warn(
            'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.',
          )
        const r = this.options,
          i = this.basepath ?? r?.basepath ?? '/',
          s = this.basepath === void 0,
          o = r?.rewrite
        ;((this.options = { ...r, ...t }),
          (this.isServer = this.options.isServer ?? typeof document > 'u'),
          (this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters
            ? new Map(
                this.options.pathParamsAllowedCharacters.map((d) => [encodeURIComponent(d), d]),
              )
            : void 0),
          (!this.history || (this.options.history && this.options.history !== this.history)) &&
            (this.options.history
              ? (this.history = this.options.history)
              : this.isServer || (this.history = Mk())),
          (this.origin = this.options.origin),
          this.origin ||
            (this.isServer ? (this.origin = 'http://localhost') : (this.origin = window.origin)),
          this.history && this.updateLatestLocation(),
          this.options.routeTree !== this.routeTree &&
            ((this.routeTree = this.options.routeTree), this.buildRouteTree()),
          !this.__store &&
            this.latestLocation &&
            ((this.__store = new Nh(x8(this.latestLocation), {
              onUpdate: () => {
                this.__store.state = {
                  ...this.state,
                  cachedMatches: this.state.cachedMatches.filter(
                    (d) => !['redirected'].includes(d.status),
                  ),
                }
              },
            })),
            i8(this)))
        let a = !1
        const l = this.options.basepath ?? '/',
          c = this.options.rewrite
        if (s || i !== l || o !== c) {
          this.basepath = l
          const d = []
          ;(Pc(l) !== '' && d.push(v8({ basepath: l })),
            c && d.push(c),
            (this.rewrite = d.length === 0 ? void 0 : d.length === 1 ? d[0] : b8(d)),
            this.history && this.updateLatestLocation(),
            (a = !0))
        }
        ;(a &&
          this.__store &&
          (this.__store.state = { ...this.state, location: this.latestLocation }),
          typeof window < 'u' &&
            'CSS' in window &&
            typeof window.CSS?.supports == 'function' &&
            (this.isViewTransitionTypesSupported = window.CSS.supports(
              'selector(:active-view-transition-type(a)',
            )))
      }),
      (this.updateLatestLocation = () => {
        this.latestLocation = this.parseLocation(this.history.location, this.latestLocation)
      }),
      (this.buildRouteTree = () => {
        const {
          routesById: t,
          routesByPath: r,
          flatRoutes: i,
        } = Zk({
          routeTree: this.routeTree,
          initRoute: (o, a) => {
            o.init({ originalIndex: a })
          },
        })
        ;((this.routesById = t), (this.routesByPath = r), (this.flatRoutes = i))
        const s = this.options.notFoundRoute
        s && (s.init({ originalIndex: 99999999999 }), (this.routesById[s.id] = s))
      }),
      (this.subscribe = (t, r) => {
        const i = { eventType: t, fn: r }
        return (
          this.subscribers.add(i),
          () => {
            this.subscribers.delete(i)
          }
        )
      }),
      (this.emit = (t) => {
        this.subscribers.forEach((r) => {
          r.eventType === t.type && r.fn(t)
        })
      }),
      (this.parseLocation = (t, r) => {
        const i = ({ href: l, state: c }) => {
            const u = new URL(l, this.origin),
              f = J2(this.rewrite, u),
              d = this.options.parseSearch(f.search),
              h = this.options.stringifySearch(d)
            f.search = h
            const p = f.href.replace(f.origin, ''),
              { pathname: g, hash: m } = f
            return {
              href: p,
              publicHref: l,
              url: f.href,
              pathname: g,
              searchStr: h,
              search: dr(r?.search, d),
              hash: m.split('#').reverse()[0] ?? '',
              state: dr(r?.state, c),
            }
          },
          s = i(t),
          { __tempLocation: o, __tempKey: a } = s.state
        if (o && (!a || a === this.tempLocationKey)) {
          const l = i(o)
          return (
            (l.state.key = s.state.key),
            (l.state.__TSR_key = s.state.__TSR_key),
            delete l.state.__tempLocation,
            { ...l, maskedLocation: s }
          )
        }
        return s
      }),
      (this.resolvePathWithBase = (t, r) =>
        Ok({
          base: t,
          to: Cm(r),
          trailingSlash: this.options.trailingSlash,
          parseCache: this.parsePathnameCache,
        })),
      (this.matchRoutes = (t, r, i) =>
        typeof t == 'string'
          ? this.matchRoutesInternal({ pathname: t, search: r }, i)
          : this.matchRoutesInternal(t, r)),
      (this.parsePathnameCache = d8(1e3)),
      (this.getMatchedRoutes = (t, r) =>
        S8({
          pathname: t,
          routePathname: r,
          caseSensitive: this.options.caseSensitive,
          routesByPath: this.routesByPath,
          routesById: this.routesById,
          flatRoutes: this.flatRoutes,
          parseCache: this.parsePathnameCache,
        })),
      (this.cancelMatch = (t) => {
        const r = this.getMatch(t)
        r &&
          (r.abortController.abort(),
          clearTimeout(r._nonReactive.pendingTimeout),
          (r._nonReactive.pendingTimeout = void 0))
      }),
      (this.cancelMatches = () => {
        this.state.pendingMatches?.forEach((t) => {
          this.cancelMatch(t.id)
        })
      }),
      (this.buildLocation = (t) => {
        const r = (s = {}) => {
            const o = s._fromLocation || this.latestLocation,
              a = this.matchRoutes(o, { _buildLocation: !0 }),
              l = Ih(a)
            s.from
            const c = s.unsafeRelative === 'path' ? o.pathname : (s.from ?? l.fullPath),
              u = this.resolvePathWithBase(c, '.'),
              f = l.search,
              d = { ...l.params },
              h = s.to ? this.resolvePathWithBase(u, `${s.to}`) : this.resolvePathWithBase(u, '.'),
              p =
                s.params === !1 || s.params === null
                  ? {}
                  : (s.params ?? !0) === !0
                    ? d
                    : Object.assign(d, Ea(s.params, d)),
              g = Gl({ path: h, params: p, parseCache: this.parsePathnameCache }).interpolatedPath,
              m = this.matchRoutes(g, void 0, { _buildLocation: !0 }).map(
                (P) => this.looseRoutesById[P.routeId],
              )
            if (Object.keys(p).length > 0)
              for (const P of m) {
                const $ = P.options.params?.stringify ?? P.options.stringifyParams
                $ && Object.assign(p, $(p))
              }
            const y = Gl({
              path: h,
              params: p,
              leaveWildcards: !1,
              leaveParams: t.leaveParams,
              decodeCharMap: this.pathParamsDecodeCharMap,
              parseCache: this.parsePathnameCache,
            }).interpolatedPath
            let b = f
            if (t._includeValidateSearch && this.options.search?.strict) {
              const P = {}
              ;(m.forEach(($) => {
                if ($.options.validateSearch)
                  try {
                    Object.assign(P, Lh($.options.validateSearch, { ...P, ...b }))
                  } catch {}
              }),
                (b = P))
            }
            ;((b = _8({
              search: b,
              dest: s,
              destRoutes: m,
              _includeValidateSearch: t._includeValidateSearch,
            })),
              (b = dr(f, b)))
            const w = this.options.stringifySearch(b),
              C = s.hash === !0 ? o.hash : s.hash ? Ea(s.hash, o.hash) : void 0,
              T = C ? `#${C}` : ''
            let I = s.state === !0 ? o.state : s.state ? Ea(s.state, o.state) : {}
            I = dr(o.state, I)
            const B = `${y}${w}${T}`,
              E = new URL(B, this.origin),
              O = Q2(this.rewrite, E)
            return {
              publicHref: O.pathname + O.search + O.hash,
              href: B,
              url: O.href,
              pathname: y,
              search: b,
              searchStr: w,
              state: I,
              hash: C ?? '',
              unmaskOnReload: s.unmaskOnReload,
            }
          },
          i = (s = {}, o) => {
            const a = r(s)
            let l = o ? r(o) : void 0
            if (!l) {
              let c = {}
              const u = this.options.routeMasks?.find((f) => {
                const d = Dh(
                  a.pathname,
                  { to: f.from, caseSensitive: !1, fuzzy: !1 },
                  this.parsePathnameCache,
                )
                return d ? ((c = d), !0) : !1
              })
              if (u) {
                const { from: f, ...d } = u
                ;((o = { from: t.from, ...d, params: c }), (l = r(o)))
              }
            }
            return (l && (a.maskedLocation = l), a)
          }
        return t.mask ? i(t, { from: t.from, ...t.mask }) : i(t)
      }),
      (this.commitLocation = ({ viewTransition: t, ignoreBlocker: r, ...i }) => {
        const s = () => {
            const l = ['key', '__TSR_key', '__TSR_index', '__hashScrollIntoViewOptions']
            l.forEach((u) => {
              i.state[u] = this.latestLocation.state[u]
            })
            const c = yo(i.state, this.latestLocation.state)
            return (
              l.forEach((u) => {
                delete i.state[u]
              }),
              c
            )
          },
          o = bo(this.latestLocation.href) === bo(i.href),
          a = this.commitLocationPromise
        if (
          ((this.commitLocationPromise = Ga(() => {
            a?.resolve()
          })),
          o && s())
        )
          this.load()
        else {
          let { maskedLocation: l, hashScrollIntoView: c, ...u } = i
          ;(l &&
            ((u = {
              ...l,
              state: {
                ...l.state,
                __tempKey: void 0,
                __tempLocation: {
                  ...u,
                  search: u.searchStr,
                  state: {
                    ...u.state,
                    __tempKey: void 0,
                    __tempLocation: void 0,
                    __TSR_key: void 0,
                    key: void 0,
                  },
                },
              },
            }),
            (u.unmaskOnReload ?? this.options.unmaskOnReload ?? !1) &&
              (u.state.__tempKey = this.tempLocationKey)),
            (u.state.__hashScrollIntoViewOptions =
              c ?? this.options.defaultHashScrollIntoView ?? !0),
            (this.shouldViewTransition = t),
            this.history[i.replace ? 'replace' : 'push'](u.publicHref, u.state, {
              ignoreBlocker: r,
            }))
        }
        return (
          (this.resetNextScroll = i.resetScroll ?? !0),
          this.history.subscribers.size || this.load(),
          this.commitLocationPromise
        )
      }),
      (this.buildAndCommitLocation = ({
        replace: t,
        resetScroll: r,
        hashScrollIntoView: i,
        viewTransition: s,
        ignoreBlocker: o,
        href: a,
        ...l
      } = {}) => {
        if (a) {
          const u = this.history.location.state.__TSR_index,
            f = Wc(a, { __TSR_index: t ? u : u + 1 })
          ;((l.to = f.pathname),
            (l.search = this.options.parseSearch(f.search)),
            (l.hash = f.hash.slice(1)))
        }
        const c = this.buildLocation({ ...l, _includeValidateSearch: !0 })
        return this.commitLocation({
          ...c,
          viewTransition: s,
          replace: t,
          resetScroll: r,
          hashScrollIntoView: i,
          ignoreBlocker: o,
        })
      }),
      (this.navigate = ({ to: t, reloadDocument: r, href: i, ...s }) => {
        if (!r && i)
          try {
            ;(new URL(`${i}`), (r = !0))
          } catch {}
        return r
          ? (i || (i = this.buildLocation({ to: t, ...s }).url),
            s.replace ? window.location.replace(i) : (window.location.href = i),
            Promise.resolve())
          : this.buildAndCommitLocation({ ...s, href: i, to: t, _isNavigate: !0 })
      }),
      (this.beforeLoad = () => {
        if ((this.cancelMatches(), this.updateLatestLocation(), this.isServer)) {
          const r = this.buildLocation({
              to: this.latestLocation.pathname,
              search: !0,
              params: !0,
              hash: !0,
              state: !0,
              _includeValidateSearch: !0,
            }),
            i = (s) => {
              try {
                return encodeURI(decodeURI(s))
              } catch {
                return s
              }
            }
          if (Pc(i(this.latestLocation.href)) !== Pc(i(r.href))) throw f8({ href: r.href })
        }
        const t = this.matchRoutes(this.latestLocation)
        this.__store.setState((r) => ({
          ...r,
          status: 'pending',
          statusCode: 200,
          isLoading: !0,
          location: this.latestLocation,
          pendingMatches: t,
          cachedMatches: r.cachedMatches.filter((i) => !t.some((s) => s.id === i.id)),
        }))
      }),
      (this.load = async (t) => {
        let r, i, s
        for (
          s = new Promise((o) => {
            this.startTransition(async () => {
              try {
                this.beforeLoad()
                const a = this.latestLocation,
                  l = this.state.resolvedLocation
                ;(this.state.redirect ||
                  this.emit({
                    type: 'onBeforeNavigate',
                    ...hd({ resolvedLocation: l, location: a }),
                  }),
                  this.emit({ type: 'onBeforeLoad', ...hd({ resolvedLocation: l, location: a }) }),
                  await o1({
                    router: this,
                    sync: t?.sync,
                    matches: this.state.pendingMatches,
                    location: a,
                    updateMatch: this.updateMatch,
                    onReady: async () => {
                      this.startViewTransition(async () => {
                        let c, u, f
                        ;(Ma(() => {
                          ;(this.__store.setState((d) => {
                            const h = d.matches,
                              p = d.pendingMatches || d.matches
                            return (
                              (c = h.filter((g) => !p.some((m) => m.id === g.id))),
                              (u = p.filter((g) => !h.some((m) => m.id === g.id))),
                              (f = h.filter((g) => p.some((m) => m.id === g.id))),
                              {
                                ...d,
                                isLoading: !1,
                                loadedAt: Date.now(),
                                matches: p,
                                pendingMatches: void 0,
                                cachedMatches: [
                                  ...d.cachedMatches,
                                  ...c.filter((g) => g.status !== 'error'),
                                ],
                              }
                            )
                          }),
                            this.clearExpiredCache())
                        }),
                          [
                            [c, 'onLeave'],
                            [u, 'onEnter'],
                            [f, 'onStay'],
                          ].forEach(([d, h]) => {
                            d.forEach((p) => {
                              this.looseRoutesById[p.routeId].options[h]?.(p)
                            })
                          }))
                      })
                    },
                  }))
              } catch (a) {
                ;(Xr(a)
                  ? ((r = a),
                    this.isServer ||
                      this.navigate({ ...r.options, replace: !0, ignoreBlocker: !0 }))
                  : Ao(a) && (i = a),
                  this.__store.setState((l) => ({
                    ...l,
                    statusCode: r
                      ? r.status
                      : i
                        ? 404
                        : l.matches.some((c) => c.status === 'error')
                          ? 500
                          : 200,
                    redirect: r,
                  })))
              }
              ;(this.latestLoadPromise === s &&
                (this.commitLocationPromise?.resolve(),
                (this.latestLoadPromise = void 0),
                (this.commitLocationPromise = void 0)),
                o())
            })
          }),
            this.latestLoadPromise = s,
            await s;
          this.latestLoadPromise && s !== this.latestLoadPromise;

        )
          await this.latestLoadPromise
        this.hasNotFoundMatch() && this.__store.setState((o) => ({ ...o, statusCode: 404 }))
      }),
      (this.startViewTransition = (t) => {
        const r = this.shouldViewTransition ?? this.options.defaultViewTransition
        if (
          (delete this.shouldViewTransition,
          r &&
            typeof document < 'u' &&
            'startViewTransition' in document &&
            typeof document.startViewTransition == 'function')
        ) {
          let i
          if (typeof r == 'object' && this.isViewTransitionTypesSupported) {
            const s = this.latestLocation,
              o = this.state.resolvedLocation,
              a =
                typeof r.types == 'function'
                  ? r.types(hd({ resolvedLocation: o, location: s }))
                  : r.types
            i = { update: t, types: a }
          } else i = t
          document.startViewTransition(i)
        } else t()
      }),
      (this.updateMatch = (t, r) => {
        const i = this.state.pendingMatches?.some((s) => s.id === t)
          ? 'pendingMatches'
          : this.state.matches.some((s) => s.id === t)
            ? 'matches'
            : this.state.cachedMatches.some((s) => s.id === t)
              ? 'cachedMatches'
              : ''
        i &&
          this.__store.setState((s) => ({ ...s, [i]: s[i]?.map((o) => (o.id === t ? r(o) : o)) }))
      }),
      (this.getMatch = (t) => {
        const r = (i) => i.id === t
        return (
          this.state.cachedMatches.find(r) ??
          this.state.pendingMatches?.find(r) ??
          this.state.matches.find(r)
        )
      }),
      (this.invalidate = (t) => {
        const r = (i) =>
          (t?.filter?.(i) ?? !0)
            ? {
                ...i,
                invalid: !0,
                ...(t?.forcePending || i.status === 'error'
                  ? { status: 'pending', error: void 0 }
                  : void 0),
              }
            : i
        return (
          this.__store.setState((i) => ({
            ...i,
            matches: i.matches.map(r),
            cachedMatches: i.cachedMatches.map(r),
            pendingMatches: i.pendingMatches?.map(r),
          })),
          (this.shouldViewTransition = !1),
          this.load({ sync: t?.sync })
        )
      }),
      (this.resolveRedirect = (t) => {
        if (!t.options.href) {
          const r = this.buildLocation(t.options)
          let i = r.url
          ;(this.origin && i.startsWith(this.origin) && (i = i.replace(this.origin, '') || '/'),
            (t.options.href = r.href),
            t.headers.set('Location', i))
        }
        return (t.headers.get('Location') || t.headers.set('Location', t.options.href), t)
      }),
      (this.clearCache = (t) => {
        const r = t?.filter
        r !== void 0
          ? this.__store.setState((i) => ({
              ...i,
              cachedMatches: i.cachedMatches.filter((s) => !r(s)),
            }))
          : this.__store.setState((i) => ({ ...i, cachedMatches: [] }))
      }),
      (this.clearExpiredCache = () => {
        const t = (r) => {
          const i = this.looseRoutesById[r.routeId]
          if (!i.options.loader) return !0
          const s =
            (r.preload
              ? (i.options.preloadGcTime ?? this.options.defaultPreloadGcTime)
              : (i.options.gcTime ?? this.options.defaultGcTime)) ?? 5 * 60 * 1e3
          return r.status === 'error' ? !0 : Date.now() - r.updatedAt >= s
        }
        this.clearCache({ filter: t })
      }),
      (this.loadRouteChunk = X2),
      (this.preloadRoute = async (t) => {
        const r = this.buildLocation(t)
        let i = this.matchRoutes(r, { throwOnError: !0, preload: !0, dest: t })
        const s = new Set(
            [...this.state.matches, ...(this.state.pendingMatches ?? [])].map((a) => a.id),
          ),
          o = new Set([...s, ...this.state.cachedMatches.map((a) => a.id)])
        Ma(() => {
          i.forEach((a) => {
            o.has(a.id) ||
              this.__store.setState((l) => ({ ...l, cachedMatches: [...l.cachedMatches, a] }))
          })
        })
        try {
          return (
            (i = await o1({
              router: this,
              matches: i,
              location: r,
              preload: !0,
              updateMatch: (a, l) => {
                s.has(a) ? (i = i.map((c) => (c.id === a ? l(c) : c))) : this.updateMatch(a, l)
              },
            })),
            i
          )
        } catch (a) {
          if (Xr(a))
            return a.options.reloadDocument
              ? void 0
              : await this.preloadRoute({ ...a.options, _fromLocation: r })
          Ao(a) || console.error(a)
          return
        }
      }),
      (this.matchRoute = (t, r) => {
        const i = {
            ...t,
            to: t.to ? this.resolvePathWithBase(t.from || '', t.to) : void 0,
            params: t.params || {},
            leaveParams: !0,
          },
          s = this.buildLocation(i)
        if (r?.pending && this.state.status !== 'pending') return !1
        const a = (r?.pending === void 0 ? !this.state.isLoading : r.pending)
            ? this.latestLocation
            : this.state.resolvedLocation || this.state.location,
          l = Dh(a.pathname, { ...r, to: s.pathname }, this.parsePathnameCache)
        return !l || (t.params && !yo(l, t.params, { partial: !0 }))
          ? !1
          : l && (r?.includeSearch ?? !0)
            ? yo(a.search, s.search, { partial: !0 })
              ? l
              : !1
            : l
      }),
      (this.hasNotFoundMatch = () =>
        this.__store.state.matches.some((t) => t.status === 'notFound' || t.globalNotFound)),
      this.update({
        defaultPreloadDelay: 50,
        defaultPendingMs: 1e3,
        defaultPendingMinMs: 500,
        context: void 0,
        ...n,
        caseSensitive: n.caseSensitive ?? !1,
        notFoundMode: n.notFoundMode ?? 'fuzzy',
        stringifySearch: n.stringifySearch ?? l8,
        parseSearch: n.parseSearch ?? a8,
      }),
      typeof document < 'u' && (self.__TSR_ROUTER__ = this))
  }
  isShell() {
    return !!this.options.isShell
  }
  isPrerendering() {
    return !!this.options.isPrerendering
  }
  get state() {
    return this.__store.state
  }
  get looseRoutesById() {
    return this.routesById
  }
  matchRoutesInternal(n, t) {
    const {
      foundRoute: r,
      matchedRoutes: i,
      routeParams: s,
    } = this.getMatchedRoutes(n.pathname, t?.dest?.to)
    let o = !1
    ;(r ? r.path !== '/' && s['**'] : bo(n.pathname)) &&
      (this.options.notFoundRoute ? i.push(this.options.notFoundRoute) : (o = !0))
    const a = (() => {
        if (o) {
          if (this.options.notFoundMode !== 'root')
            for (let u = i.length - 1; u >= 0; u--) {
              const f = i[u]
              if (f.children) return f.id
            }
          return pr
        }
      })(),
      l = [],
      c = (u) =>
        u?.id ? (u.context ?? this.options.context ?? void 0) : (this.options.context ?? void 0)
    return (
      i.forEach((u, f) => {
        const d = l[f - 1],
          [h, p, g] = (() => {
            const F = d?.search ?? n.search,
              M = d?._strictSearch ?? void 0
            try {
              const R = Lh(u.options.validateSearch, { ...F }) ?? void 0
              return [{ ...F, ...R }, { ...M, ...R }, void 0]
            } catch (R) {
              let k = R
              if ((R instanceof Yc || (k = new Yc(R.message, { cause: R })), t?.throwOnError))
                throw k
              return [F, {}, k]
            }
          })(),
          m = u.options.loaderDeps?.({ search: h }) ?? '',
          y = m ? JSON.stringify(m) : '',
          { interpolatedPath: b, usedParams: w } = Gl({
            path: u.fullPath,
            params: s,
            decodeCharMap: this.pathParamsDecodeCharMap,
          }),
          C =
            Gl({
              path: u.id,
              params: s,
              leaveWildcards: !0,
              decodeCharMap: this.pathParamsDecodeCharMap,
              parseCache: this.parsePathnameCache,
            }).interpolatedPath + y,
          T = this.getMatch(C),
          I = this.state.matches.find((F) => F.routeId === u.id),
          B = T?._strictParams ?? w
        let E
        if (!T) {
          const F = u.options.params?.parse ?? u.options.parseParams
          if (F)
            try {
              Object.assign(B, F(B))
            } catch (M) {
              if (((E = new w8(M.message, { cause: M })), t?.throwOnError)) throw E
            }
        }
        Object.assign(s, B)
        const O = I ? 'stay' : 'enter'
        let P
        if (T)
          P = {
            ...T,
            cause: O,
            params: I ? dr(I.params, s) : s,
            _strictParams: B,
            search: dr(I ? I.search : T.search, h),
            _strictSearch: p,
          }
        else {
          const F =
            u.options.loader || u.options.beforeLoad || u.lazyFn || Y2(u) ? 'pending' : 'success'
          P = {
            id: C,
            index: f,
            routeId: u.id,
            params: I ? dr(I.params, s) : s,
            _strictParams: B,
            pathname: b,
            updatedAt: Date.now(),
            search: I ? dr(I.search, h) : h,
            _strictSearch: p,
            searchError: void 0,
            status: F,
            isFetching: !1,
            error: void 0,
            paramsError: E,
            __routeContext: void 0,
            _nonReactive: { loadPromise: Ga() },
            __beforeLoadContext: void 0,
            context: {},
            abortController: new AbortController(),
            fetchCount: 0,
            cause: O,
            loaderDeps: I ? dr(I.loaderDeps, m) : m,
            invalid: !1,
            preload: !1,
            links: void 0,
            scripts: void 0,
            headScripts: void 0,
            meta: void 0,
            staticData: u.options.staticData || {},
            fullPath: u.fullPath,
          }
        }
        ;(t?.preload || (P.globalNotFound = a === u.id), (P.searchError = g))
        const $ = c(d)
        ;((P.context = { ...$, ...P.__routeContext, ...P.__beforeLoadContext }), l.push(P))
      }),
      l.forEach((u, f) => {
        const d = this.looseRoutesById[u.routeId]
        if (!this.getMatch(u.id) && t?._buildLocation !== !0) {
          const p = l[f - 1],
            g = c(p)
          if (d.options.context) {
            const m = {
              deps: u.loaderDeps,
              params: u.params,
              context: g ?? {},
              location: n,
              navigate: (y) => this.navigate({ ...y, _fromLocation: n }),
              buildLocation: this.buildLocation,
              cause: u.cause,
              abortController: u.abortController,
              preload: !!u.preload,
              matches: l,
            }
            u.__routeContext = d.options.context(m) ?? void 0
          }
          u.context = { ...g, ...u.__routeContext, ...u.__beforeLoadContext }
        }
      }),
      l
    )
  }
}
class Yc extends Error {}
class w8 extends Error {}
function x8(e) {
  return {
    loadedAt: 0,
    isLoading: !1,
    isTransitioning: !1,
    status: 'idle',
    resolvedLocation: void 0,
    location: e,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    statusCode: 200,
  }
}
function Lh(e, n) {
  if (e == null) return {}
  if ('~standard' in e) {
    const t = e['~standard'].validate(n)
    if (t instanceof Promise) throw new Yc('Async validation not supported')
    if (t.issues) throw new Yc(JSON.stringify(t.issues, void 0, 2), { cause: t })
    return t.value
  }
  return 'parse' in e ? e.parse(n) : typeof e == 'function' ? e(n) : {}
}
function S8({
  pathname: e,
  routePathname: n,
  caseSensitive: t,
  routesByPath: r,
  routesById: i,
  flatRoutes: s,
  parseCache: o,
}) {
  let a = {}
  const l = bo(e),
    c = (h) => Dh(l, { to: h.fullPath, caseSensitive: h.options?.caseSensitive ?? t, fuzzy: !0 }, o)
  let u = n !== void 0 ? r[n] : void 0
  if (u) a = c(u)
  else {
    let h
    for (const p of s) {
      const g = c(p)
      if (g)
        if (p.path !== '/' && g['**']) h || (h = { foundRoute: p, routeParams: g })
        else {
          ;((u = p), (a = g))
          break
        }
    }
    !u && h && ((u = h.foundRoute), (a = h.routeParams))
  }
  let f = u || i[pr]
  const d = [f]
  for (; f.parentRoute; ) ((f = f.parentRoute), d.push(f))
  return (d.reverse(), { matchedRoutes: d, routeParams: a, foundRoute: u })
}
function _8({ search: e, dest: n, destRoutes: t, _includeValidateSearch: r }) {
  const i =
      t.reduce((a, l) => {
        const c = []
        if ('search' in l.options)
          l.options.search?.middlewares && c.push(...l.options.search.middlewares)
        else if (l.options.preSearchFilters || l.options.postSearchFilters) {
          const u = ({ search: f, next: d }) => {
            let h = f
            'preSearchFilters' in l.options &&
              l.options.preSearchFilters &&
              (h = l.options.preSearchFilters.reduce((g, m) => m(g), f))
            const p = d(h)
            return 'postSearchFilters' in l.options && l.options.postSearchFilters
              ? l.options.postSearchFilters.reduce((g, m) => m(g), p)
              : p
          }
          c.push(u)
        }
        if (r && l.options.validateSearch) {
          const u = ({ search: f, next: d }) => {
            const h = d(f)
            try {
              return { ...h, ...(Lh(l.options.validateSearch, h) ?? void 0) }
            } catch {
              return h
            }
          }
          c.push(u)
        }
        return a.concat(c)
      }, []) ?? [],
    s = ({ search: a }) => (n.search ? (n.search === !0 ? a : Ea(n.search, a)) : {})
  i.push(s)
  const o = (a, l) => {
    if (a >= i.length) return l
    const c = i[a]
    return c({ search: l, next: (f) => o(a + 1, f) })
  }
  return o(0, e)
}
const AK = 'Error preloading route! '
class k8 {
  constructor(n) {
    if (
      ((this.init = (t) => {
        this.originalIndex = t.originalIndex
        const r = this.options,
          i = !r?.path && !r?.id
        ;((this.parentRoute = this.options.getParentRoute?.()),
          i ? (this._path = pr) : this.parentRoute || Gc(!1))
        let s = i ? pr : r?.path
        s && s !== '/' && (s = Mm(s))
        const o = r?.id || s
        let a = i ? pr : Zr([this.parentRoute.id === pr ? '' : this.parentRoute.id, o])
        ;(s === pr && (s = '/'), a !== pr && (a = Zr(['/', a])))
        const l = a === pr ? '/' : Zr([this.parentRoute.fullPath, s])
        ;((this._path = s), (this._id = a), (this._fullPath = l), (this._to = l))
      }),
      (this.clone = (t) => {
        ;((this._path = t._path),
          (this._id = t._id),
          (this._fullPath = t._fullPath),
          (this._to = t._to),
          (this.options.getParentRoute = t.options.getParentRoute),
          (this.children = t.children))
      }),
      (this.addChildren = (t) => this._addFileChildren(t)),
      (this._addFileChildren = (t) => (
        Array.isArray(t) && (this.children = t),
        typeof t == 'object' && t !== null && (this.children = Object.values(t)),
        this
      )),
      (this._addFileTypes = () => this),
      (this.updateLoader = (t) => (Object.assign(this.options, t), this)),
      (this.update = (t) => (Object.assign(this.options, t), this)),
      (this.lazy = (t) => ((this.lazyFn = t), this)),
      (this.options = n || {}),
      (this.isRoot = !n?.getParentRoute),
      n?.id && n?.path)
    )
      throw new Error("Route cannot have both an 'id' and a 'path' option.")
  }
  get to() {
    return this._to
  }
  get id() {
    return this._id
  }
  get path() {
    return this._path
  }
  get fullPath() {
    return this._fullPath
  }
}
class RK extends k8 {
  constructor(n) {
    super(n)
  }
}
function OK(e, n) {}
var tw = { exports: {} },
  ew = {},
  nw = { exports: {} },
  rw = {}
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ro = Y
function C8(e, n) {
  return (e === n && (e !== 0 || 1 / e === 1 / n)) || (e !== e && n !== n)
}
var M8 = typeof Object.is == 'function' ? Object.is : C8,
  E8 = Ro.useState,
  T8 = Ro.useEffect,
  A8 = Ro.useLayoutEffect,
  R8 = Ro.useDebugValue
function O8(e, n) {
  var t = n(),
    r = E8({ inst: { value: t, getSnapshot: n } }),
    i = r[0].inst,
    s = r[1]
  return (
    A8(
      function () {
        ;((i.value = t), (i.getSnapshot = n), pd(i) && s({ inst: i }))
      },
      [e, t, n],
    ),
    T8(
      function () {
        return (
          pd(i) && s({ inst: i }),
          e(function () {
            pd(i) && s({ inst: i })
          })
        )
      },
      [e],
    ),
    R8(t),
    t
  )
}
function pd(e) {
  var n = e.getSnapshot
  e = e.value
  try {
    var t = n()
    return !M8(e, t)
  } catch {
    return !0
  }
}
function P8(e, n) {
  return n()
}
var N8 =
  typeof window > 'u' || typeof window.document > 'u' || typeof window.document.createElement > 'u'
    ? P8
    : O8
rw.useSyncExternalStore = Ro.useSyncExternalStore !== void 0 ? Ro.useSyncExternalStore : N8
nw.exports = rw
var Em = nw.exports
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var wf = Y,
  I8 = Em
function D8(e, n) {
  return (e === n && (e !== 0 || 1 / e === 1 / n)) || (e !== e && n !== n)
}
var j8 = typeof Object.is == 'function' ? Object.is : D8,
  L8 = I8.useSyncExternalStore,
  F8 = wf.useRef,
  B8 = wf.useEffect,
  z8 = wf.useMemo,
  $8 = wf.useDebugValue
ew.useSyncExternalStoreWithSelector = function (e, n, t, r, i) {
  var s = F8(null)
  if (s.current === null) {
    var o = { hasValue: !1, value: null }
    s.current = o
  } else o = s.current
  s = z8(
    function () {
      function l(h) {
        if (!c) {
          if (((c = !0), (u = h), (h = r(h)), i !== void 0 && o.hasValue)) {
            var p = o.value
            if (i(p, h)) return (f = p)
          }
          return (f = h)
        }
        if (((p = f), j8(u, h))) return p
        var g = r(h)
        return i !== void 0 && i(p, g) ? ((u = h), p) : ((u = h), (f = g))
      }
      var c = !1,
        u,
        f,
        d = t === void 0 ? null : t
      return [
        function () {
          return l(n())
        },
        d === null
          ? void 0
          : function () {
              return l(d())
            },
      ]
    },
    [n, t, r, i],
  )
  var a = L8(e, s[0], s[1])
  return (
    B8(
      function () {
        ;((o.hasValue = !0), (o.value = a))
      },
      [a],
    ),
    $8(a),
    a
  )
}
tw.exports = ew
var Tm = tw.exports
const iw = kr(Tm)
function PK(e, n = (t) => t) {
  return Tm.useSyncExternalStoreWithSelector(
    e.subscribe,
    () => e.state,
    () => e.state,
    n,
    V8,
  )
}
function V8(e, n) {
  if (Object.is(e, n)) return !0
  if (typeof e != 'object' || e === null || typeof n != 'object' || n === null) return !1
  if (e instanceof Map && n instanceof Map) {
    if (e.size !== n.size) return !1
    for (const [r, i] of e) if (!n.has(r) || !Object.is(i, n.get(r))) return !1
    return !0
  }
  if (e instanceof Set && n instanceof Set) {
    if (e.size !== n.size) return !1
    for (const r of e) if (!n.has(r)) return !1
    return !0
  }
  if (e instanceof Date && n instanceof Date) return e.getTime() === n.getTime()
  const t = a1(e)
  if (t.length !== a1(n).length) return !1
  for (let r = 0; r < t.length; r++)
    if (!Object.prototype.hasOwnProperty.call(n, t[r]) || !Object.is(e[t[r]], n[t[r]])) return !1
  return !0
}
function a1(e) {
  return Object.keys(e).concat(Object.getOwnPropertySymbols(e))
}
var qo = class {
    constructor() {
      ;((this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this)))
    }
    subscribe(e) {
      return (
        this.listeners.add(e),
        this.onSubscribe(),
        () => {
          ;(this.listeners.delete(e), this.onUnsubscribe())
        }
      )
    }
    hasListeners() {
      return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  H8 = {
    setTimeout: (e, n) => setTimeout(e, n),
    clearTimeout: (e) => clearTimeout(e),
    setInterval: (e, n) => setInterval(e, n),
    clearInterval: (e) => clearInterval(e),
  },
  U8 = class {
    #t = H8
    #e = !1
    setTimeoutProvider(e) {
      this.#t = e
    }
    setTimeout(e, n) {
      return this.#t.setTimeout(e, n)
    }
    clearTimeout(e) {
      this.#t.clearTimeout(e)
    }
    setInterval(e, n) {
      return this.#t.setInterval(e, n)
    }
    clearInterval(e) {
      this.#t.clearInterval(e)
    }
  },
  ls = new U8()
function q8(e) {
  setTimeout(e, 0)
}
var Oo = typeof window > 'u' || 'Deno' in globalThis
function tr() {}
function W8(e, n) {
  return typeof e == 'function' ? e(n) : e
}
function Fh(e) {
  return typeof e == 'number' && e >= 0 && e !== 1 / 0
}
function sw(e, n) {
  return Math.max(e + (n || 0) - Date.now(), 0)
}
function Di(e, n) {
  return typeof e == 'function' ? e(n) : e
}
function er(e, n) {
  return typeof e == 'function' ? e(n) : e
}
function l1(e, n) {
  const { type: t = 'all', exact: r, fetchStatus: i, predicate: s, queryKey: o, stale: a } = e
  if (o) {
    if (r) {
      if (n.queryHash !== Am(o, n.options)) return !1
    } else if (!Xa(n.queryKey, o)) return !1
  }
  if (t !== 'all') {
    const l = n.isActive()
    if ((t === 'active' && !l) || (t === 'inactive' && l)) return !1
  }
  return !(
    (typeof a == 'boolean' && n.isStale() !== a) ||
    (i && i !== n.state.fetchStatus) ||
    (s && !s(n))
  )
}
function c1(e, n) {
  const { exact: t, status: r, predicate: i, mutationKey: s } = e
  if (s) {
    if (!n.options.mutationKey) return !1
    if (t) {
      if (Rs(n.options.mutationKey) !== Rs(s)) return !1
    } else if (!Xa(n.options.mutationKey, s)) return !1
  }
  return !((r && n.state.status !== r) || (i && !i(n)))
}
function Am(e, n) {
  return (n?.queryKeyHashFn || Rs)(e)
}
function Rs(e) {
  return JSON.stringify(e, (n, t) =>
    Bh(t)
      ? Object.keys(t)
          .sort()
          .reduce((r, i) => ((r[i] = t[i]), r), {})
      : t,
  )
}
function Xa(e, n) {
  return e === n
    ? !0
    : typeof e != typeof n
      ? !1
      : e && n && typeof e == 'object' && typeof n == 'object'
        ? Object.keys(n).every((t) => Xa(e[t], n[t]))
        : !1
}
var K8 = Object.prototype.hasOwnProperty
function ow(e, n) {
  if (e === n) return e
  const t = u1(e) && u1(n)
  if (!t && !(Bh(e) && Bh(n))) return n
  const i = (t ? e : Object.keys(e)).length,
    s = t ? n : Object.keys(n),
    o = s.length,
    a = t ? new Array(o) : {}
  let l = 0
  for (let c = 0; c < o; c++) {
    const u = t ? c : s[c],
      f = e[u],
      d = n[u]
    if (f === d) {
      ;((a[u] = f), (t ? c < i : K8.call(e, u)) && l++)
      continue
    }
    if (f === null || d === null || typeof f != 'object' || typeof d != 'object') {
      a[u] = d
      continue
    }
    const h = ow(f, d)
    ;((a[u] = h), h === f && l++)
  }
  return i === o && l === i ? e : a
}
function Zc(e, n) {
  if (!n || Object.keys(e).length !== Object.keys(n).length) return !1
  for (const t in e) if (e[t] !== n[t]) return !1
  return !0
}
function u1(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}
function Bh(e) {
  if (!f1(e)) return !1
  const n = e.constructor
  if (n === void 0) return !0
  const t = n.prototype
  return !(
    !f1(t) ||
    !t.hasOwnProperty('isPrototypeOf') ||
    Object.getPrototypeOf(e) !== Object.prototype
  )
}
function f1(e) {
  return Object.prototype.toString.call(e) === '[object Object]'
}
function G8(e) {
  return new Promise((n) => {
    ls.setTimeout(n, e)
  })
}
function zh(e, n, t) {
  return typeof t.structuralSharing == 'function'
    ? t.structuralSharing(e, n)
    : t.structuralSharing !== !1
      ? ow(e, n)
      : n
}
function X8(e, n, t = 0) {
  const r = [...e, n]
  return t && r.length > t ? r.slice(1) : r
}
function Y8(e, n, t = 0) {
  const r = [n, ...e]
  return t && r.length > t ? r.slice(0, -1) : r
}
var Rm = Symbol()
function aw(e, n) {
  return !e.queryFn && n?.initialPromise
    ? () => n.initialPromise
    : !e.queryFn || e.queryFn === Rm
      ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`))
      : e.queryFn
}
function NK(e, n) {
  return typeof e == 'function' ? e(...n) : !!e
}
var Z8 = class extends qo {
    #t
    #e
    #n
    constructor() {
      ;(super(),
        (this.#n = (e) => {
          if (!Oo && window.addEventListener) {
            const n = () => e()
            return (
              window.addEventListener('visibilitychange', n, !1),
              () => {
                window.removeEventListener('visibilitychange', n)
              }
            )
          }
        }))
    }
    onSubscribe() {
      this.#e || this.setEventListener(this.#n)
    }
    onUnsubscribe() {
      this.hasListeners() || (this.#e?.(), (this.#e = void 0))
    }
    setEventListener(e) {
      ;((this.#n = e),
        this.#e?.(),
        (this.#e = e((n) => {
          typeof n == 'boolean' ? this.setFocused(n) : this.onFocus()
        })))
    }
    setFocused(e) {
      this.#t !== e && ((this.#t = e), this.onFocus())
    }
    onFocus() {
      const e = this.isFocused()
      this.listeners.forEach((n) => {
        n(e)
      })
    }
    isFocused() {
      return typeof this.#t == 'boolean'
        ? this.#t
        : globalThis.document?.visibilityState !== 'hidden'
    }
  },
  Om = new Z8()
function $h() {
  let e, n
  const t = new Promise((i, s) => {
    ;((e = i), (n = s))
  })
  ;((t.status = 'pending'), t.catch(() => {}))
  function r(i) {
    ;(Object.assign(t, i), delete t.resolve, delete t.reject)
  }
  return (
    (t.resolve = (i) => {
      ;(r({ status: 'fulfilled', value: i }), e(i))
    }),
    (t.reject = (i) => {
      ;(r({ status: 'rejected', reason: i }), n(i))
    }),
    t
  )
}
var J8 = q8
function Q8() {
  let e = [],
    n = 0,
    t = (a) => {
      a()
    },
    r = (a) => {
      a()
    },
    i = J8
  const s = (a) => {
      n
        ? e.push(a)
        : i(() => {
            t(a)
          })
    },
    o = () => {
      const a = e
      ;((e = []),
        a.length &&
          i(() => {
            r(() => {
              a.forEach((l) => {
                t(l)
              })
            })
          }))
    }
  return {
    batch: (a) => {
      let l
      n++
      try {
        l = a()
      } finally {
        ;(n--, n || o())
      }
      return l
    },
    batchCalls:
      (a) =>
      (...l) => {
        s(() => {
          a(...l)
        })
      },
    schedule: s,
    setNotifyFunction: (a) => {
      t = a
    },
    setBatchNotifyFunction: (a) => {
      r = a
    },
    setScheduler: (a) => {
      i = a
    },
  }
}
var vn = Q8(),
  tC = class extends qo {
    #t = !0
    #e
    #n
    constructor() {
      ;(super(),
        (this.#n = (e) => {
          if (!Oo && window.addEventListener) {
            const n = () => e(!0),
              t = () => e(!1)
            return (
              window.addEventListener('online', n, !1),
              window.addEventListener('offline', t, !1),
              () => {
                ;(window.removeEventListener('online', n), window.removeEventListener('offline', t))
              }
            )
          }
        }))
    }
    onSubscribe() {
      this.#e || this.setEventListener(this.#n)
    }
    onUnsubscribe() {
      this.hasListeners() || (this.#e?.(), (this.#e = void 0))
    }
    setEventListener(e) {
      ;((this.#n = e), this.#e?.(), (this.#e = e(this.setOnline.bind(this))))
    }
    setOnline(e) {
      this.#t !== e &&
        ((this.#t = e),
        this.listeners.forEach((t) => {
          t(e)
        }))
    }
    isOnline() {
      return this.#t
    }
  },
  Jc = new tC()
function eC(e) {
  return Math.min(1e3 * 2 ** e, 3e4)
}
function lw(e) {
  return (e ?? 'online') === 'online' ? Jc.isOnline() : !0
}
var Vh = class extends Error {
  constructor(e) {
    ;(super('CancelledError'), (this.revert = e?.revert), (this.silent = e?.silent))
  }
}
function cw(e) {
  let n = !1,
    t = 0,
    r
  const i = $h(),
    s = () => i.status !== 'pending',
    o = (g) => {
      if (!s()) {
        const m = new Vh(g)
        ;(d(m), e.onCancel?.(m))
      }
    },
    a = () => {
      n = !0
    },
    l = () => {
      n = !1
    },
    c = () => Om.isFocused() && (e.networkMode === 'always' || Jc.isOnline()) && e.canRun(),
    u = () => lw(e.networkMode) && e.canRun(),
    f = (g) => {
      s() || (r?.(), i.resolve(g))
    },
    d = (g) => {
      s() || (r?.(), i.reject(g))
    },
    h = () =>
      new Promise((g) => {
        ;((r = (m) => {
          ;(s() || c()) && g(m)
        }),
          e.onPause?.())
      }).then(() => {
        ;((r = void 0), s() || e.onContinue?.())
      }),
    p = () => {
      if (s()) return
      let g
      const m = t === 0 ? e.initialPromise : void 0
      try {
        g = m ?? e.fn()
      } catch (y) {
        g = Promise.reject(y)
      }
      Promise.resolve(g)
        .then(f)
        .catch((y) => {
          if (s()) return
          const b = e.retry ?? (Oo ? 0 : 3),
            w = e.retryDelay ?? eC,
            C = typeof w == 'function' ? w(t, y) : w,
            T = b === !0 || (typeof b == 'number' && t < b) || (typeof b == 'function' && b(t, y))
          if (n || !T) {
            d(y)
            return
          }
          ;(t++,
            e.onFail?.(t, y),
            G8(C)
              .then(() => (c() ? void 0 : h()))
              .then(() => {
                n ? d(y) : p()
              }))
        })
    }
  return {
    promise: i,
    status: () => i.status,
    cancel: o,
    continue: () => (r?.(), i),
    cancelRetry: a,
    continueRetry: l,
    canStart: u,
    start: () => (u() ? p() : h().then(p), i),
  }
}
var uw = class {
    #t
    destroy() {
      this.clearGcTimeout()
    }
    scheduleGc() {
      ;(this.clearGcTimeout(),
        Fh(this.gcTime) &&
          (this.#t = ls.setTimeout(() => {
            this.optionalRemove()
          }, this.gcTime)))
    }
    updateGcTime(e) {
      this.gcTime = Math.max(this.gcTime || 0, e ?? (Oo ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
      this.#t && (ls.clearTimeout(this.#t), (this.#t = void 0))
    }
  },
  nC = class extends uw {
    #t
    #e
    #n
    #i
    #r
    #o
    #a
    constructor(e) {
      ;(super(),
        (this.#a = !1),
        (this.#o = e.defaultOptions),
        this.setOptions(e.options),
        (this.observers = []),
        (this.#i = e.client),
        (this.#n = this.#i.getQueryCache()),
        (this.queryKey = e.queryKey),
        (this.queryHash = e.queryHash),
        (this.#t = d1(this.options)),
        (this.state = e.state ?? this.#t),
        this.scheduleGc())
    }
    get meta() {
      return this.options.meta
    }
    get promise() {
      return this.#r?.promise
    }
    setOptions(e) {
      if (
        ((this.options = { ...this.#o, ...e }),
        this.updateGcTime(this.options.gcTime),
        this.state && this.state.data === void 0)
      ) {
        const n = d1(this.options)
        n.data !== void 0 &&
          (this.setData(n.data, { updatedAt: n.dataUpdatedAt, manual: !0 }), (this.#t = n))
      }
    }
    optionalRemove() {
      !this.observers.length && this.state.fetchStatus === 'idle' && this.#n.remove(this)
    }
    setData(e, n) {
      const t = zh(this.state.data, e, this.options)
      return (
        this.#s({ data: t, type: 'success', dataUpdatedAt: n?.updatedAt, manual: n?.manual }),
        t
      )
    }
    setState(e, n) {
      this.#s({ type: 'setState', state: e, setStateOptions: n })
    }
    cancel(e) {
      const n = this.#r?.promise
      return (this.#r?.cancel(e), n ? n.then(tr).catch(tr) : Promise.resolve())
    }
    destroy() {
      ;(super.destroy(), this.cancel({ silent: !0 }))
    }
    reset() {
      ;(this.destroy(), this.setState(this.#t))
    }
    isActive() {
      return this.observers.some((e) => er(e.options.enabled, this) !== !1)
    }
    isDisabled() {
      return this.getObserversCount() > 0
        ? !this.isActive()
        : this.options.queryFn === Rm ||
            this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStatic() {
      return this.getObserversCount() > 0
        ? this.observers.some((e) => Di(e.options.staleTime, this) === 'static')
        : !1
    }
    isStale() {
      return this.getObserversCount() > 0
        ? this.observers.some((e) => e.getCurrentResult().isStale)
        : this.state.data === void 0 || this.state.isInvalidated
    }
    isStaleByTime(e = 0) {
      return this.state.data === void 0
        ? !0
        : e === 'static'
          ? !1
          : this.state.isInvalidated
            ? !0
            : !sw(this.state.dataUpdatedAt, e)
    }
    onFocus() {
      ;(this.observers.find((n) => n.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }),
        this.#r?.continue())
    }
    onOnline() {
      ;(this.observers.find((n) => n.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }),
        this.#r?.continue())
    }
    addObserver(e) {
      this.observers.includes(e) ||
        (this.observers.push(e),
        this.clearGcTimeout(),
        this.#n.notify({ type: 'observerAdded', query: this, observer: e }))
    }
    removeObserver(e) {
      this.observers.includes(e) &&
        ((this.observers = this.observers.filter((n) => n !== e)),
        this.observers.length ||
          (this.#r && (this.#a ? this.#r.cancel({ revert: !0 }) : this.#r.cancelRetry()),
          this.scheduleGc()),
        this.#n.notify({ type: 'observerRemoved', query: this, observer: e }))
    }
    getObserversCount() {
      return this.observers.length
    }
    invalidate() {
      this.state.isInvalidated || this.#s({ type: 'invalidate' })
    }
    async fetch(e, n) {
      if (this.state.fetchStatus !== 'idle' && this.#r?.status() !== 'rejected') {
        if (this.state.data !== void 0 && n?.cancelRefetch) this.cancel({ silent: !0 })
        else if (this.#r) return (this.#r.continueRetry(), this.#r.promise)
      }
      if ((e && this.setOptions(e), !this.options.queryFn)) {
        const a = this.observers.find((l) => l.options.queryFn)
        a && this.setOptions(a.options)
      }
      const t = new AbortController(),
        r = (a) => {
          Object.defineProperty(a, 'signal', {
            enumerable: !0,
            get: () => ((this.#a = !0), t.signal),
          })
        },
        i = () => {
          const a = aw(this.options, n),
            c = (() => {
              const u = { client: this.#i, queryKey: this.queryKey, meta: this.meta }
              return (r(u), u)
            })()
          return (
            (this.#a = !1),
            this.options.persister ? this.options.persister(a, c, this) : a(c)
          )
        },
        o = (() => {
          const a = {
            fetchOptions: n,
            options: this.options,
            queryKey: this.queryKey,
            client: this.#i,
            state: this.state,
            fetchFn: i,
          }
          return (r(a), a)
        })()
      ;(this.options.behavior?.onFetch(o, this),
        (this.#e = this.state),
        (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== o.fetchOptions?.meta) &&
          this.#s({ type: 'fetch', meta: o.fetchOptions?.meta }),
        (this.#r = cw({
          initialPromise: n?.initialPromise,
          fn: o.fetchFn,
          onCancel: (a) => {
            ;(a instanceof Vh && a.revert && this.setState({ ...this.#e, fetchStatus: 'idle' }),
              t.abort())
          },
          onFail: (a, l) => {
            this.#s({ type: 'failed', failureCount: a, error: l })
          },
          onPause: () => {
            this.#s({ type: 'pause' })
          },
          onContinue: () => {
            this.#s({ type: 'continue' })
          },
          retry: o.options.retry,
          retryDelay: o.options.retryDelay,
          networkMode: o.options.networkMode,
          canRun: () => !0,
        })))
      try {
        const a = await this.#r.start()
        if (a === void 0) throw new Error(`${this.queryHash} data is undefined`)
        return (
          this.setData(a),
          this.#n.config.onSuccess?.(a, this),
          this.#n.config.onSettled?.(a, this.state.error, this),
          a
        )
      } catch (a) {
        if (a instanceof Vh) {
          if (a.silent) return this.#r.promise
          if (a.revert) {
            if (this.state.data === void 0) throw a
            return this.state.data
          }
        }
        throw (
          this.#s({ type: 'error', error: a }),
          this.#n.config.onError?.(a, this),
          this.#n.config.onSettled?.(this.state.data, a, this),
          a
        )
      } finally {
        this.scheduleGc()
      }
    }
    #s(e) {
      const n = (t) => {
        switch (e.type) {
          case 'failed':
            return { ...t, fetchFailureCount: e.failureCount, fetchFailureReason: e.error }
          case 'pause':
            return { ...t, fetchStatus: 'paused' }
          case 'continue':
            return { ...t, fetchStatus: 'fetching' }
          case 'fetch':
            return { ...t, ...fw(t.data, this.options), fetchMeta: e.meta ?? null }
          case 'success':
            const r = {
              ...t,
              data: e.data,
              dataUpdateCount: t.dataUpdateCount + 1,
              dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: !1,
              status: 'success',
              ...(!e.manual && {
                fetchStatus: 'idle',
                fetchFailureCount: 0,
                fetchFailureReason: null,
              }),
            }
            return ((this.#e = e.manual ? r : void 0), r)
          case 'error':
            const i = e.error
            return {
              ...t,
              error: i,
              errorUpdateCount: t.errorUpdateCount + 1,
              errorUpdatedAt: Date.now(),
              fetchFailureCount: t.fetchFailureCount + 1,
              fetchFailureReason: i,
              fetchStatus: 'idle',
              status: 'error',
            }
          case 'invalidate':
            return { ...t, isInvalidated: !0 }
          case 'setState':
            return { ...t, ...e.state }
        }
      }
      ;((this.state = n(this.state)),
        vn.batch(() => {
          ;(this.observers.forEach((t) => {
            t.onQueryUpdate()
          }),
            this.#n.notify({ query: this, type: 'updated', action: e }))
        }))
    }
  }
function fw(e, n) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: lw(n.networkMode) ? 'fetching' : 'paused',
    ...(e === void 0 && { error: null, status: 'pending' }),
  }
}
function d1(e) {
  const n = typeof e.initialData == 'function' ? e.initialData() : e.initialData,
    t = n !== void 0,
    r = t
      ? typeof e.initialDataUpdatedAt == 'function'
        ? e.initialDataUpdatedAt()
        : e.initialDataUpdatedAt
      : 0
  return {
    data: n,
    dataUpdateCount: 0,
    dataUpdatedAt: t ? (r ?? Date.now()) : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: t ? 'success' : 'pending',
    fetchStatus: 'idle',
  }
}
var rC = class extends qo {
  constructor(e, n) {
    ;(super(),
      (this.options = n),
      (this.#t = e),
      (this.#s = null),
      (this.#a = $h()),
      this.bindMethods(),
      this.setOptions(n))
  }
  #t
  #e = void 0
  #n = void 0
  #i = void 0
  #r
  #o
  #a
  #s
  #m
  #d
  #h
  #c
  #u
  #l
  #p = new Set()
  bindMethods() {
    this.refetch = this.refetch.bind(this)
  }
  onSubscribe() {
    this.listeners.size === 1 &&
      (this.#e.addObserver(this),
      h1(this.#e, this.options) ? this.#f() : this.updateResult(),
      this.#v())
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy()
  }
  shouldFetchOnReconnect() {
    return Hh(this.#e, this.options, this.options.refetchOnReconnect)
  }
  shouldFetchOnWindowFocus() {
    return Hh(this.#e, this.options, this.options.refetchOnWindowFocus)
  }
  destroy() {
    ;((this.listeners = new Set()), this.#w(), this.#x(), this.#e.removeObserver(this))
  }
  setOptions(e) {
    const n = this.options,
      t = this.#e
    if (
      ((this.options = this.#t.defaultQueryOptions(e)),
      this.options.enabled !== void 0 &&
        typeof this.options.enabled != 'boolean' &&
        typeof this.options.enabled != 'function' &&
        typeof er(this.options.enabled, this.#e) != 'boolean')
    )
      throw new Error('Expected enabled to be a boolean or a callback that returns a boolean')
    ;(this.#S(),
      this.#e.setOptions(this.options),
      n._defaulted &&
        !Zc(this.options, n) &&
        this.#t
          .getQueryCache()
          .notify({ type: 'observerOptionsUpdated', query: this.#e, observer: this }))
    const r = this.hasListeners()
    ;(r && p1(this.#e, t, this.options, n) && this.#f(),
      this.updateResult(),
      r &&
        (this.#e !== t ||
          er(this.options.enabled, this.#e) !== er(n.enabled, this.#e) ||
          Di(this.options.staleTime, this.#e) !== Di(n.staleTime, this.#e)) &&
        this.#g())
    const i = this.#y()
    r &&
      (this.#e !== t ||
        er(this.options.enabled, this.#e) !== er(n.enabled, this.#e) ||
        i !== this.#l) &&
      this.#b(i)
  }
  getOptimisticResult(e) {
    const n = this.#t.getQueryCache().build(this.#t, e),
      t = this.createResult(n, e)
    return (sC(this, t) && ((this.#i = t), (this.#o = this.options), (this.#r = this.#e.state)), t)
  }
  getCurrentResult() {
    return this.#i
  }
  trackResult(e, n) {
    return new Proxy(e, {
      get: (t, r) => (
        this.trackProp(r),
        n?.(r),
        r === 'promise' &&
          (this.trackProp('data'),
          !this.options.experimental_prefetchInRender &&
            this.#a.status === 'pending' &&
            this.#a.reject(new Error('experimental_prefetchInRender feature flag is not enabled'))),
        Reflect.get(t, r)
      ),
    })
  }
  trackProp(e) {
    this.#p.add(e)
  }
  getCurrentQuery() {
    return this.#e
  }
  refetch({ ...e } = {}) {
    return this.fetch({ ...e })
  }
  fetchOptimistic(e) {
    const n = this.#t.defaultQueryOptions(e),
      t = this.#t.getQueryCache().build(this.#t, n)
    return t.fetch().then(() => this.createResult(t, n))
  }
  fetch(e) {
    return this.#f({ ...e, cancelRefetch: e.cancelRefetch ?? !0 }).then(
      () => (this.updateResult(), this.#i),
    )
  }
  #f(e) {
    this.#S()
    let n = this.#e.fetch(this.options, e)
    return (e?.throwOnError || (n = n.catch(tr)), n)
  }
  #g() {
    this.#w()
    const e = Di(this.options.staleTime, this.#e)
    if (Oo || this.#i.isStale || !Fh(e)) return
    const t = sw(this.#i.dataUpdatedAt, e) + 1
    this.#c = ls.setTimeout(() => {
      this.#i.isStale || this.updateResult()
    }, t)
  }
  #y() {
    return (
      (typeof this.options.refetchInterval == 'function'
        ? this.options.refetchInterval(this.#e)
        : this.options.refetchInterval) ?? !1
    )
  }
  #b(e) {
    ;(this.#x(),
      (this.#l = e),
      !(Oo || er(this.options.enabled, this.#e) === !1 || !Fh(this.#l) || this.#l === 0) &&
        (this.#u = ls.setInterval(() => {
          ;(this.options.refetchIntervalInBackground || Om.isFocused()) && this.#f()
        }, this.#l)))
  }
  #v() {
    ;(this.#g(), this.#b(this.#y()))
  }
  #w() {
    this.#c && (ls.clearTimeout(this.#c), (this.#c = void 0))
  }
  #x() {
    this.#u && (ls.clearInterval(this.#u), (this.#u = void 0))
  }
  createResult(e, n) {
    const t = this.#e,
      r = this.options,
      i = this.#i,
      s = this.#r,
      o = this.#o,
      l = e !== t ? e.state : this.#n,
      { state: c } = e
    let u = { ...c },
      f = !1,
      d
    if (n._optimisticResults) {
      const E = this.hasListeners(),
        O = !E && h1(e, n),
        P = E && p1(e, t, n, r)
      ;((O || P) && (u = { ...u, ...fw(c.data, e.options) }),
        n._optimisticResults === 'isRestoring' && (u.fetchStatus = 'idle'))
    }
    let { error: h, errorUpdatedAt: p, status: g } = u
    d = u.data
    let m = !1
    if (n.placeholderData !== void 0 && d === void 0 && g === 'pending') {
      let E
      ;(i?.isPlaceholderData && n.placeholderData === o?.placeholderData
        ? ((E = i.data), (m = !0))
        : (E =
            typeof n.placeholderData == 'function'
              ? n.placeholderData(this.#h?.state.data, this.#h)
              : n.placeholderData),
        E !== void 0 && ((g = 'success'), (d = zh(i?.data, E, n)), (f = !0)))
    }
    if (n.select && d !== void 0 && !m)
      if (i && d === s?.data && n.select === this.#m) d = this.#d
      else
        try {
          ;((this.#m = n.select),
            (d = n.select(d)),
            (d = zh(i?.data, d, n)),
            (this.#d = d),
            (this.#s = null))
        } catch (E) {
          this.#s = E
        }
    this.#s && ((h = this.#s), (d = this.#d), (p = Date.now()), (g = 'error'))
    const y = u.fetchStatus === 'fetching',
      b = g === 'pending',
      w = g === 'error',
      C = b && y,
      T = d !== void 0,
      B = {
        status: g,
        fetchStatus: u.fetchStatus,
        isPending: b,
        isSuccess: g === 'success',
        isError: w,
        isInitialLoading: C,
        isLoading: C,
        data: d,
        dataUpdatedAt: u.dataUpdatedAt,
        error: h,
        errorUpdatedAt: p,
        failureCount: u.fetchFailureCount,
        failureReason: u.fetchFailureReason,
        errorUpdateCount: u.errorUpdateCount,
        isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
        isFetchedAfterMount:
          u.dataUpdateCount > l.dataUpdateCount || u.errorUpdateCount > l.errorUpdateCount,
        isFetching: y,
        isRefetching: y && !b,
        isLoadingError: w && !T,
        isPaused: u.fetchStatus === 'paused',
        isPlaceholderData: f,
        isRefetchError: w && T,
        isStale: Pm(e, n),
        refetch: this.refetch,
        promise: this.#a,
        isEnabled: er(n.enabled, e) !== !1,
      }
    if (this.options.experimental_prefetchInRender) {
      const E = ($) => {
          B.status === 'error' ? $.reject(B.error) : B.data !== void 0 && $.resolve(B.data)
        },
        O = () => {
          const $ = (this.#a = B.promise = $h())
          E($)
        },
        P = this.#a
      switch (P.status) {
        case 'pending':
          e.queryHash === t.queryHash && E(P)
          break
        case 'fulfilled':
          ;(B.status === 'error' || B.data !== P.value) && O()
          break
        case 'rejected':
          ;(B.status !== 'error' || B.error !== P.reason) && O()
          break
      }
    }
    return B
  }
  updateResult() {
    const e = this.#i,
      n = this.createResult(this.#e, this.options)
    if (
      ((this.#r = this.#e.state),
      (this.#o = this.options),
      this.#r.data !== void 0 && (this.#h = this.#e),
      Zc(n, e))
    )
      return
    this.#i = n
    const t = () => {
      if (!e) return !0
      const { notifyOnChangeProps: r } = this.options,
        i = typeof r == 'function' ? r() : r
      if (i === 'all' || (!i && !this.#p.size)) return !0
      const s = new Set(i ?? this.#p)
      return (
        this.options.throwOnError && s.add('error'),
        Object.keys(this.#i).some((o) => {
          const a = o
          return this.#i[a] !== e[a] && s.has(a)
        })
      )
    }
    this.#_({ listeners: t() })
  }
  #S() {
    const e = this.#t.getQueryCache().build(this.#t, this.options)
    if (e === this.#e) return
    const n = this.#e
    ;((this.#e = e),
      (this.#n = e.state),
      this.hasListeners() && (n?.removeObserver(this), e.addObserver(this)))
  }
  onQueryUpdate() {
    ;(this.updateResult(), this.hasListeners() && this.#v())
  }
  #_(e) {
    vn.batch(() => {
      ;(e.listeners &&
        this.listeners.forEach((n) => {
          n(this.#i)
        }),
        this.#t.getQueryCache().notify({ query: this.#e, type: 'observerResultsUpdated' }))
    })
  }
}
function iC(e, n) {
  return (
    er(n.enabled, e) !== !1 &&
    e.state.data === void 0 &&
    !(e.state.status === 'error' && n.retryOnMount === !1)
  )
}
function h1(e, n) {
  return iC(e, n) || (e.state.data !== void 0 && Hh(e, n, n.refetchOnMount))
}
function Hh(e, n, t) {
  if (er(n.enabled, e) !== !1 && Di(n.staleTime, e) !== 'static') {
    const r = typeof t == 'function' ? t(e) : t
    return r === 'always' || (r !== !1 && Pm(e, n))
  }
  return !1
}
function p1(e, n, t, r) {
  return (
    (e !== n || er(r.enabled, e) === !1) && (!t.suspense || e.state.status !== 'error') && Pm(e, t)
  )
}
function Pm(e, n) {
  return er(n.enabled, e) !== !1 && e.isStaleByTime(Di(n.staleTime, e))
}
function sC(e, n) {
  return !Zc(e.getCurrentResult(), n)
}
function Qc(e) {
  return {
    onFetch: (n, t) => {
      const r = n.options,
        i = n.fetchOptions?.meta?.fetchMore?.direction,
        s = n.state.data?.pages || [],
        o = n.state.data?.pageParams || []
      let a = { pages: [], pageParams: [] },
        l = 0
      const c = async () => {
        let u = !1
        const f = (p) => {
            Object.defineProperty(p, 'signal', {
              enumerable: !0,
              get: () => (
                n.signal.aborted
                  ? (u = !0)
                  : n.signal.addEventListener('abort', () => {
                      u = !0
                    }),
                n.signal
              ),
            })
          },
          d = aw(n.options, n.fetchOptions),
          h = async (p, g, m) => {
            if (u) return Promise.reject()
            if (g == null && p.pages.length) return Promise.resolve(p)
            const b = (() => {
                const I = {
                  client: n.client,
                  queryKey: n.queryKey,
                  pageParam: g,
                  direction: m ? 'backward' : 'forward',
                  meta: n.options.meta,
                }
                return (f(I), I)
              })(),
              w = await d(b),
              { maxPages: C } = n.options,
              T = m ? Y8 : X8
            return { pages: T(p.pages, w, C), pageParams: T(p.pageParams, g, C) }
          }
        if (i && s.length) {
          const p = i === 'backward',
            g = p ? dw : Uh,
            m = { pages: s, pageParams: o },
            y = g(r, m)
          a = await h(m, y, p)
        } else {
          const p = e ?? s.length
          do {
            const g = l === 0 ? (o[0] ?? r.initialPageParam) : Uh(r, a)
            if (l > 0 && g == null) break
            ;((a = await h(a, g)), l++)
          } while (l < p)
        }
        return a
      }
      n.options.persister
        ? (n.fetchFn = () =>
            n.options.persister?.(
              c,
              { client: n.client, queryKey: n.queryKey, meta: n.options.meta, signal: n.signal },
              t,
            ))
        : (n.fetchFn = c)
    },
  }
}
function Uh(e, { pages: n, pageParams: t }) {
  const r = n.length - 1
  return n.length > 0 ? e.getNextPageParam(n[r], n, t[r], t) : void 0
}
function dw(e, { pages: n, pageParams: t }) {
  return n.length > 0 ? e.getPreviousPageParam?.(n[0], n, t[0], t) : void 0
}
function oC(e, n) {
  return n ? Uh(e, n) != null : !1
}
function aC(e, n) {
  return !n || !e.getPreviousPageParam ? !1 : dw(e, n) != null
}
var IK = class extends rC {
    constructor(e, n) {
      super(e, n)
    }
    bindMethods() {
      ;(super.bindMethods(),
        (this.fetchNextPage = this.fetchNextPage.bind(this)),
        (this.fetchPreviousPage = this.fetchPreviousPage.bind(this)))
    }
    setOptions(e) {
      super.setOptions({ ...e, behavior: Qc() })
    }
    getOptimisticResult(e) {
      return ((e.behavior = Qc()), super.getOptimisticResult(e))
    }
    fetchNextPage(e) {
      return this.fetch({ ...e, meta: { fetchMore: { direction: 'forward' } } })
    }
    fetchPreviousPage(e) {
      return this.fetch({ ...e, meta: { fetchMore: { direction: 'backward' } } })
    }
    createResult(e, n) {
      const { state: t } = e,
        r = super.createResult(e, n),
        { isFetching: i, isRefetching: s, isError: o, isRefetchError: a } = r,
        l = t.fetchMeta?.fetchMore?.direction,
        c = o && l === 'forward',
        u = i && l === 'forward',
        f = o && l === 'backward',
        d = i && l === 'backward'
      return {
        ...r,
        fetchNextPage: this.fetchNextPage,
        fetchPreviousPage: this.fetchPreviousPage,
        hasNextPage: oC(n, t.data),
        hasPreviousPage: aC(n, t.data),
        isFetchNextPageError: c,
        isFetchingNextPage: u,
        isFetchPreviousPageError: f,
        isFetchingPreviousPage: d,
        isRefetchError: a && !c && !f,
        isRefetching: s && !u && !d,
      }
    }
  },
  lC = class extends uw {
    #t
    #e
    #n
    #i
    constructor(e) {
      ;(super(),
        (this.#t = e.client),
        (this.mutationId = e.mutationId),
        (this.#n = e.mutationCache),
        (this.#e = []),
        (this.state = e.state || hw()),
        this.setOptions(e.options),
        this.scheduleGc())
    }
    setOptions(e) {
      ;((this.options = e), this.updateGcTime(this.options.gcTime))
    }
    get meta() {
      return this.options.meta
    }
    addObserver(e) {
      this.#e.includes(e) ||
        (this.#e.push(e),
        this.clearGcTimeout(),
        this.#n.notify({ type: 'observerAdded', mutation: this, observer: e }))
    }
    removeObserver(e) {
      ;((this.#e = this.#e.filter((n) => n !== e)),
        this.scheduleGc(),
        this.#n.notify({ type: 'observerRemoved', mutation: this, observer: e }))
    }
    optionalRemove() {
      this.#e.length || (this.state.status === 'pending' ? this.scheduleGc() : this.#n.remove(this))
    }
    continue() {
      return this.#i?.continue() ?? this.execute(this.state.variables)
    }
    async execute(e) {
      const n = () => {
          this.#r({ type: 'continue' })
        },
        t = { client: this.#t, meta: this.options.meta, mutationKey: this.options.mutationKey }
      this.#i = cw({
        fn: () =>
          this.options.mutationFn
            ? this.options.mutationFn(e, t)
            : Promise.reject(new Error('No mutationFn found')),
        onFail: (s, o) => {
          this.#r({ type: 'failed', failureCount: s, error: o })
        },
        onPause: () => {
          this.#r({ type: 'pause' })
        },
        onContinue: n,
        retry: this.options.retry ?? 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => this.#n.canRun(this),
      })
      const r = this.state.status === 'pending',
        i = !this.#i.canStart()
      try {
        if (r) n()
        else {
          ;(this.#r({ type: 'pending', variables: e, isPaused: i }),
            await this.#n.config.onMutate?.(e, this, t))
          const o = await this.options.onMutate?.(e, t)
          o !== this.state.context &&
            this.#r({ type: 'pending', context: o, variables: e, isPaused: i })
        }
        const s = await this.#i.start()
        return (
          await this.#n.config.onSuccess?.(s, e, this.state.context, this, t),
          await this.options.onSuccess?.(s, e, this.state.context, t),
          await this.#n.config.onSettled?.(
            s,
            null,
            this.state.variables,
            this.state.context,
            this,
            t,
          ),
          await this.options.onSettled?.(s, null, e, this.state.context, t),
          this.#r({ type: 'success', data: s }),
          s
        )
      } catch (s) {
        try {
          throw (
            await this.#n.config.onError?.(s, e, this.state.context, this, t),
            await this.options.onError?.(s, e, this.state.context, t),
            await this.#n.config.onSettled?.(
              void 0,
              s,
              this.state.variables,
              this.state.context,
              this,
              t,
            ),
            await this.options.onSettled?.(void 0, s, e, this.state.context, t),
            s
          )
        } finally {
          this.#r({ type: 'error', error: s })
        }
      } finally {
        this.#n.runNext(this)
      }
    }
    #r(e) {
      const n = (t) => {
        switch (e.type) {
          case 'failed':
            return { ...t, failureCount: e.failureCount, failureReason: e.error }
          case 'pause':
            return { ...t, isPaused: !0 }
          case 'continue':
            return { ...t, isPaused: !1 }
          case 'pending':
            return {
              ...t,
              context: e.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: e.isPaused,
              status: 'pending',
              variables: e.variables,
              submittedAt: Date.now(),
            }
          case 'success':
            return {
              ...t,
              data: e.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: 'success',
              isPaused: !1,
            }
          case 'error':
            return {
              ...t,
              data: void 0,
              error: e.error,
              failureCount: t.failureCount + 1,
              failureReason: e.error,
              isPaused: !1,
              status: 'error',
            }
        }
      }
      ;((this.state = n(this.state)),
        vn.batch(() => {
          ;(this.#e.forEach((t) => {
            t.onMutationUpdate(e)
          }),
            this.#n.notify({ mutation: this, type: 'updated', action: e }))
        }))
    }
  }
function hw() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: 'idle',
    variables: void 0,
    submittedAt: 0,
  }
}
var cC = class extends qo {
  constructor(e = {}) {
    ;(super(), (this.config = e), (this.#t = new Set()), (this.#e = new Map()), (this.#n = 0))
  }
  #t
  #e
  #n
  build(e, n, t) {
    const r = new lC({
      client: e,
      mutationCache: this,
      mutationId: ++this.#n,
      options: e.defaultMutationOptions(n),
      state: t,
    })
    return (this.add(r), r)
  }
  add(e) {
    this.#t.add(e)
    const n = Zl(e)
    if (typeof n == 'string') {
      const t = this.#e.get(n)
      t ? t.push(e) : this.#e.set(n, [e])
    }
    this.notify({ type: 'added', mutation: e })
  }
  remove(e) {
    if (this.#t.delete(e)) {
      const n = Zl(e)
      if (typeof n == 'string') {
        const t = this.#e.get(n)
        if (t)
          if (t.length > 1) {
            const r = t.indexOf(e)
            r !== -1 && t.splice(r, 1)
          } else t[0] === e && this.#e.delete(n)
      }
    }
    this.notify({ type: 'removed', mutation: e })
  }
  canRun(e) {
    const n = Zl(e)
    if (typeof n == 'string') {
      const r = this.#e.get(n)?.find((i) => i.state.status === 'pending')
      return !r || r === e
    } else return !0
  }
  runNext(e) {
    const n = Zl(e)
    return typeof n == 'string'
      ? (this.#e
          .get(n)
          ?.find((r) => r !== e && r.state.isPaused)
          ?.continue() ?? Promise.resolve())
      : Promise.resolve()
  }
  clear() {
    vn.batch(() => {
      ;(this.#t.forEach((e) => {
        this.notify({ type: 'removed', mutation: e })
      }),
        this.#t.clear(),
        this.#e.clear())
    })
  }
  getAll() {
    return Array.from(this.#t)
  }
  find(e) {
    const n = { exact: !0, ...e }
    return this.getAll().find((t) => c1(n, t))
  }
  findAll(e = {}) {
    return this.getAll().filter((n) => c1(e, n))
  }
  notify(e) {
    vn.batch(() => {
      this.listeners.forEach((n) => {
        n(e)
      })
    })
  }
  resumePausedMutations() {
    const e = this.getAll().filter((n) => n.state.isPaused)
    return vn.batch(() => Promise.all(e.map((n) => n.continue().catch(tr))))
  }
}
function Zl(e) {
  return e.options.scope?.id
}
var DK = class extends qo {
    #t
    #e = void 0
    #n
    #i
    constructor(n, t) {
      ;(super(), (this.#t = n), this.setOptions(t), this.bindMethods(), this.#r())
    }
    bindMethods() {
      ;((this.mutate = this.mutate.bind(this)), (this.reset = this.reset.bind(this)))
    }
    setOptions(n) {
      const t = this.options
      ;((this.options = this.#t.defaultMutationOptions(n)),
        Zc(this.options, t) ||
          this.#t
            .getMutationCache()
            .notify({ type: 'observerOptionsUpdated', mutation: this.#n, observer: this }),
        t?.mutationKey &&
        this.options.mutationKey &&
        Rs(t.mutationKey) !== Rs(this.options.mutationKey)
          ? this.reset()
          : this.#n?.state.status === 'pending' && this.#n.setOptions(this.options))
    }
    onUnsubscribe() {
      this.hasListeners() || this.#n?.removeObserver(this)
    }
    onMutationUpdate(n) {
      ;(this.#r(), this.#o(n))
    }
    getCurrentResult() {
      return this.#e
    }
    reset() {
      ;(this.#n?.removeObserver(this), (this.#n = void 0), this.#r(), this.#o())
    }
    mutate(n, t) {
      return (
        (this.#i = t),
        this.#n?.removeObserver(this),
        (this.#n = this.#t.getMutationCache().build(this.#t, this.options)),
        this.#n.addObserver(this),
        this.#n.execute(n)
      )
    }
    #r() {
      const n = this.#n?.state ?? hw()
      this.#e = {
        ...n,
        isPending: n.status === 'pending',
        isSuccess: n.status === 'success',
        isError: n.status === 'error',
        isIdle: n.status === 'idle',
        mutate: this.mutate,
        reset: this.reset,
      }
    }
    #o(n) {
      vn.batch(() => {
        if (this.#i && this.hasListeners()) {
          const t = this.#e.variables,
            r = this.#e.context,
            i = { client: this.#t, meta: this.options.meta, mutationKey: this.options.mutationKey }
          n?.type === 'success'
            ? (this.#i.onSuccess?.(n.data, t, r, i), this.#i.onSettled?.(n.data, null, t, r, i))
            : n?.type === 'error' &&
              (this.#i.onError?.(n.error, t, r, i), this.#i.onSettled?.(void 0, n.error, t, r, i))
        }
        this.listeners.forEach((t) => {
          t(this.#e)
        })
      })
    }
  },
  uC = class extends qo {
    constructor(e = {}) {
      ;(super(), (this.config = e), (this.#t = new Map()))
    }
    #t
    build(e, n, t) {
      const r = n.queryKey,
        i = n.queryHash ?? Am(r, n)
      let s = this.get(i)
      return (
        s ||
          ((s = new nC({
            client: e,
            queryKey: r,
            queryHash: i,
            options: e.defaultQueryOptions(n),
            state: t,
            defaultOptions: e.getQueryDefaults(r),
          })),
          this.add(s)),
        s
      )
    }
    add(e) {
      this.#t.has(e.queryHash) ||
        (this.#t.set(e.queryHash, e), this.notify({ type: 'added', query: e }))
    }
    remove(e) {
      const n = this.#t.get(e.queryHash)
      n &&
        (e.destroy(),
        n === e && this.#t.delete(e.queryHash),
        this.notify({ type: 'removed', query: e }))
    }
    clear() {
      vn.batch(() => {
        this.getAll().forEach((e) => {
          this.remove(e)
        })
      })
    }
    get(e) {
      return this.#t.get(e)
    }
    getAll() {
      return [...this.#t.values()]
    }
    find(e) {
      const n = { exact: !0, ...e }
      return this.getAll().find((t) => l1(n, t))
    }
    findAll(e = {}) {
      const n = this.getAll()
      return Object.keys(e).length > 0 ? n.filter((t) => l1(e, t)) : n
    }
    notify(e) {
      vn.batch(() => {
        this.listeners.forEach((n) => {
          n(e)
        })
      })
    }
    onFocus() {
      vn.batch(() => {
        this.getAll().forEach((e) => {
          e.onFocus()
        })
      })
    }
    onOnline() {
      vn.batch(() => {
        this.getAll().forEach((e) => {
          e.onOnline()
        })
      })
    }
  },
  LK = class {
    #t
    #e
    #n
    #i
    #r
    #o
    #a
    #s
    constructor(e = {}) {
      ;((this.#t = e.queryCache || new uC()),
        (this.#e = e.mutationCache || new cC()),
        (this.#n = e.defaultOptions || {}),
        (this.#i = new Map()),
        (this.#r = new Map()),
        (this.#o = 0))
    }
    mount() {
      ;(this.#o++,
        this.#o === 1 &&
          ((this.#a = Om.subscribe(async (e) => {
            e && (await this.resumePausedMutations(), this.#t.onFocus())
          })),
          (this.#s = Jc.subscribe(async (e) => {
            e && (await this.resumePausedMutations(), this.#t.onOnline())
          }))))
    }
    unmount() {
      ;(this.#o--,
        this.#o === 0 && (this.#a?.(), (this.#a = void 0), this.#s?.(), (this.#s = void 0)))
    }
    isFetching(e) {
      return this.#t.findAll({ ...e, fetchStatus: 'fetching' }).length
    }
    isMutating(e) {
      return this.#e.findAll({ ...e, status: 'pending' }).length
    }
    getQueryData(e) {
      const n = this.defaultQueryOptions({ queryKey: e })
      return this.#t.get(n.queryHash)?.state.data
    }
    ensureQueryData(e) {
      const n = this.defaultQueryOptions(e),
        t = this.#t.build(this, n),
        r = t.state.data
      return r === void 0
        ? this.fetchQuery(e)
        : (e.revalidateIfStale && t.isStaleByTime(Di(n.staleTime, t)) && this.prefetchQuery(n),
          Promise.resolve(r))
    }
    getQueriesData(e) {
      return this.#t.findAll(e).map(({ queryKey: n, state: t }) => {
        const r = t.data
        return [n, r]
      })
    }
    setQueryData(e, n, t) {
      const r = this.defaultQueryOptions({ queryKey: e }),
        s = this.#t.get(r.queryHash)?.state.data,
        o = W8(n, s)
      if (o !== void 0) return this.#t.build(this, r).setData(o, { ...t, manual: !0 })
    }
    setQueriesData(e, n, t) {
      return vn.batch(() =>
        this.#t.findAll(e).map(({ queryKey: r }) => [r, this.setQueryData(r, n, t)]),
      )
    }
    getQueryState(e) {
      const n = this.defaultQueryOptions({ queryKey: e })
      return this.#t.get(n.queryHash)?.state
    }
    removeQueries(e) {
      const n = this.#t
      vn.batch(() => {
        n.findAll(e).forEach((t) => {
          n.remove(t)
        })
      })
    }
    resetQueries(e, n) {
      const t = this.#t
      return vn.batch(
        () => (
          t.findAll(e).forEach((r) => {
            r.reset()
          }),
          this.refetchQueries({ type: 'active', ...e }, n)
        ),
      )
    }
    cancelQueries(e, n = {}) {
      const t = { revert: !0, ...n },
        r = vn.batch(() => this.#t.findAll(e).map((i) => i.cancel(t)))
      return Promise.all(r).then(tr).catch(tr)
    }
    invalidateQueries(e, n = {}) {
      return vn.batch(
        () => (
          this.#t.findAll(e).forEach((t) => {
            t.invalidate()
          }),
          e?.refetchType === 'none'
            ? Promise.resolve()
            : this.refetchQueries({ ...e, type: e?.refetchType ?? e?.type ?? 'active' }, n)
        ),
      )
    }
    refetchQueries(e, n = {}) {
      const t = { ...n, cancelRefetch: n.cancelRefetch ?? !0 },
        r = vn.batch(() =>
          this.#t
            .findAll(e)
            .filter((i) => !i.isDisabled() && !i.isStatic())
            .map((i) => {
              let s = i.fetch(void 0, t)
              return (
                t.throwOnError || (s = s.catch(tr)),
                i.state.fetchStatus === 'paused' ? Promise.resolve() : s
              )
            }),
        )
      return Promise.all(r).then(tr)
    }
    fetchQuery(e) {
      const n = this.defaultQueryOptions(e)
      n.retry === void 0 && (n.retry = !1)
      const t = this.#t.build(this, n)
      return t.isStaleByTime(Di(n.staleTime, t)) ? t.fetch(n) : Promise.resolve(t.state.data)
    }
    prefetchQuery(e) {
      return this.fetchQuery(e).then(tr).catch(tr)
    }
    fetchInfiniteQuery(e) {
      return ((e.behavior = Qc(e.pages)), this.fetchQuery(e))
    }
    prefetchInfiniteQuery(e) {
      return this.fetchInfiniteQuery(e).then(tr).catch(tr)
    }
    ensureInfiniteQueryData(e) {
      return ((e.behavior = Qc(e.pages)), this.ensureQueryData(e))
    }
    resumePausedMutations() {
      return Jc.isOnline() ? this.#e.resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
      return this.#t
    }
    getMutationCache() {
      return this.#e
    }
    getDefaultOptions() {
      return this.#n
    }
    setDefaultOptions(e) {
      this.#n = e
    }
    setQueryDefaults(e, n) {
      this.#i.set(Rs(e), { queryKey: e, defaultOptions: n })
    }
    getQueryDefaults(e) {
      const n = [...this.#i.values()],
        t = {}
      return (
        n.forEach((r) => {
          Xa(e, r.queryKey) && Object.assign(t, r.defaultOptions)
        }),
        t
      )
    }
    setMutationDefaults(e, n) {
      this.#r.set(Rs(e), { mutationKey: e, defaultOptions: n })
    }
    getMutationDefaults(e) {
      const n = [...this.#r.values()],
        t = {}
      return (
        n.forEach((r) => {
          Xa(e, r.mutationKey) && Object.assign(t, r.defaultOptions)
        }),
        t
      )
    }
    defaultQueryOptions(e) {
      if (e._defaulted) return e
      const n = { ...this.#n.queries, ...this.getQueryDefaults(e.queryKey), ...e, _defaulted: !0 }
      return (
        n.queryHash || (n.queryHash = Am(n.queryKey, n)),
        n.refetchOnReconnect === void 0 && (n.refetchOnReconnect = n.networkMode !== 'always'),
        n.throwOnError === void 0 && (n.throwOnError = !!n.suspense),
        !n.networkMode && n.persister && (n.networkMode = 'offlineFirst'),
        n.queryFn === Rm && (n.enabled = !1),
        n
      )
    }
    defaultMutationOptions(e) {
      return e?._defaulted
        ? e
        : {
            ...this.#n.mutations,
            ...(e?.mutationKey && this.getMutationDefaults(e.mutationKey)),
            ...e,
            _defaulted: !0,
          }
    }
    clear() {
      ;(this.#t.clear(), this.#e.clear())
    }
  }
let fC = { data: '' },
  dC = (e) => {
    if (typeof window == 'object') {
      let n =
        (e ? e.querySelector('#_goober') : window._goober) ||
        Object.assign(document.createElement('style'), { innerHTML: ' ', id: '_goober' })
      return (
        (n.nonce = window.__nonce__),
        n.parentNode || (e || document.head).appendChild(n),
        n.firstChild
      )
    }
    return e || fC
  },
  hC = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
  pC = /\/\*[^]*?\*\/|  +/g,
  m1 = /\n+/g,
  _i = (e, n) => {
    let t = '',
      r = '',
      i = ''
    for (let s in e) {
      let o = e[s]
      s[0] == '@'
        ? s[1] == 'i'
          ? (t = s + ' ' + o + ';')
          : (r += s[1] == 'f' ? _i(o, s) : s + '{' + _i(o, s[1] == 'k' ? '' : n) + '}')
        : typeof o == 'object'
          ? (r += _i(
              o,
              n
                ? n.replace(/([^,])+/g, (a) =>
                    s.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) =>
                      /&/.test(l) ? l.replace(/&/g, a) : a ? a + ' ' + l : l,
                    ),
                  )
                : s,
            ))
          : o != null &&
            ((s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, '-$&').toLowerCase()),
            (i += _i.p ? _i.p(s, o) : s + ':' + o + ';'))
    }
    return t + (n && i ? n + '{' + i + '}' : i) + r
  },
  $r = {},
  pw = (e) => {
    if (typeof e == 'object') {
      let n = ''
      for (let t in e) n += t + pw(e[t])
      return n
    }
    return e
  },
  mC = (e, n, t, r, i) => {
    let s = pw(e),
      o =
        $r[s] ||
        ($r[s] = ((l) => {
          let c = 0,
            u = 11
          for (; c < l.length; ) u = (101 * u + l.charCodeAt(c++)) >>> 0
          return 'go' + u
        })(s))
    if (!$r[o]) {
      let l =
        s !== e
          ? e
          : ((c) => {
              let u,
                f,
                d = [{}]
              for (; (u = hC.exec(c.replace(pC, ''))); )
                u[4]
                  ? d.shift()
                  : u[3]
                    ? ((f = u[3].replace(m1, ' ').trim()), d.unshift((d[0][f] = d[0][f] || {})))
                    : (d[0][u[1]] = u[2].replace(m1, ' ').trim())
              return d[0]
            })(e)
      $r[o] = _i(i ? { ['@keyframes ' + o]: l } : l, t ? '' : '.' + o)
    }
    let a = t && $r.g ? $r.g : null
    return (
      t && ($r.g = $r[o]),
      ((l, c, u, f) => {
        f
          ? (c.data = c.data.replace(f, l))
          : c.data.indexOf(l) === -1 && (c.data = u ? l + c.data : c.data + l)
      })($r[o], n, r, a),
      o
    )
  },
  gC = (e, n, t) =>
    e.reduce((r, i, s) => {
      let o = n[s]
      if (o && o.call) {
        let a = o(t),
          l = (a && a.props && a.props.className) || (/^go/.test(a) && a)
        o = l ? '.' + l : a && typeof a == 'object' ? (a.props ? '' : _i(a, '')) : a === !1 ? '' : a
      }
      return r + i + (o ?? '')
    }, '')
function Nm(e) {
  let n = this || {},
    t = e.call ? e(n.p) : e
  return mC(
    t.unshift
      ? t.raw
        ? gC(t, [].slice.call(arguments, 1), n.p)
        : t.reduce((r, i) => Object.assign(r, i && i.call ? i(n.p) : i), {})
      : t,
    dC(n.target),
    n.g,
    n.o,
    n.k,
  )
}
let mw, qh, Wh
Nm.bind({ g: 1 })
let FK = Nm.bind({ k: 1 })
function BK(e, n, t, r) {
  ;((_i.p = n), (mw = e), (qh = t), (Wh = r))
}
function zK(e, n) {
  let t = this || {}
  return function () {
    let r = arguments
    function i(s, o) {
      let a = Object.assign({}, s),
        l = a.className || i.className
      ;((t.p = Object.assign({ theme: qh && qh() }, a)),
        (t.o = / *go\d+/.test(l)),
        (a.className = Nm.apply(t, r) + (l ? ' ' + l : '')))
      let c = e
      return (e[0] && ((c = a.as || e), delete a.as), Wh && c[0] && Wh(a), mw(c, a))
    }
    return i
  }
}
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yC = (e) => e.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase(),
  bC = (e) =>
    e.replace(/^([A-Z])|[\s-_]+(\w)/g, (n, t, r) => (r ? r.toUpperCase() : t.toLowerCase())),
  g1 = (e) => {
    const n = bC(e)
    return n.charAt(0).toUpperCase() + n.slice(1)
  },
  gw = (...e) =>
    e
      .filter((n, t, r) => !!n && n.trim() !== '' && r.indexOf(n) === t)
      .join(' ')
      .trim(),
  vC = (e) => {
    for (const n in e) if (n.startsWith('aria-') || n === 'role' || n === 'title') return !0
  }
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var wC = {
  xmlns: 'http://www.w3.org/2000/svg',
  width: 24,
  height: 24,
  viewBox: '0 0 24 24',
  fill: 'none',
  stroke: 'currentColor',
  strokeWidth: 2,
  strokeLinecap: 'round',
  strokeLinejoin: 'round',
}
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const xC = Y.forwardRef(
  (
    {
      color: e = 'currentColor',
      size: n = 24,
      strokeWidth: t = 2,
      absoluteStrokeWidth: r,
      className: i = '',
      children: s,
      iconNode: o,
      ...a
    },
    l,
  ) =>
    Y.createElement(
      'svg',
      {
        ref: l,
        ...wC,
        width: n,
        height: n,
        stroke: e,
        strokeWidth: r ? (Number(t) * 24) / Number(n) : t,
        className: gw('lucide', i),
        ...(!s && !vC(a) && { 'aria-hidden': 'true' }),
        ...a,
      },
      [...o.map(([c, u]) => Y.createElement(c, u)), ...(Array.isArray(s) ? s : [s])],
    ),
)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const lt = (e, n) => {
  const t = Y.forwardRef(({ className: r, ...i }, s) =>
    Y.createElement(xC, {
      ref: s,
      iconNode: n,
      className: gw(`lucide-${yC(g1(e))}`, `lucide-${e}`, r),
      ...i,
    }),
  )
  return ((t.displayName = g1(e)), t)
}
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const SC = [
    [
      'path',
      {
        d: 'M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2',
        key: '169zse',
      },
    ],
  ],
  $K = lt('activity', SC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const _C = [
    ['rect', { width: '20', height: '5', x: '2', y: '3', rx: '1', key: '1wp1u1' }],
    ['path', { d: 'M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8', key: '1s80jp' }],
    ['path', { d: 'M10 12h4', key: 'a56b0p' }],
  ],
  VK = lt('archive', _C)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const kC = [
    ['path', { d: 'M12 17V3', key: '1cwfxf' }],
    ['path', { d: 'm6 11 6 6 6-6', key: '12ii2o' }],
    ['path', { d: 'M19 21H5', key: '150jfl' }],
  ],
  HK = lt('arrow-down-to-line', kC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const CC = [
    ['path', { d: 'M12 5v14', key: 's699le' }],
    ['path', { d: 'm19 12-7 7-7-7', key: '1idqje' }],
  ],
  UK = lt('arrow-down', CC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const MC = [
    ['path', { d: 'm12 19-7-7 7-7', key: '1l729n' }],
    ['path', { d: 'M19 12H5', key: 'x3x0zl' }],
  ],
  qK = lt('arrow-left', MC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const EC = [
    ['path', { d: 'M5 12h14', key: '1ays0h' }],
    ['path', { d: 'm12 5 7 7-7 7', key: 'xquz4c' }],
  ],
  WK = lt('arrow-right', EC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const TC = [
    ['path', { d: 'm21 16-4 4-4-4', key: 'f6ql7i' }],
    ['path', { d: 'M17 20V4', key: '1ejh1v' }],
    ['path', { d: 'm3 8 4-4 4 4', key: '11wl7u' }],
    ['path', { d: 'M7 4v16', key: '1glfcx' }],
  ],
  KK = lt('arrow-up-down', TC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const AC = [
    ['path', { d: 'm18 9-6-6-6 6', key: 'kcunyi' }],
    ['path', { d: 'M12 3v14', key: '7cf3v8' }],
    ['path', { d: 'M5 21h14', key: '11awu3' }],
  ],
  GK = lt('arrow-up-from-line', AC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const RC = [
    ['path', { d: 'M7 7h10v10', key: '1tivn9' }],
    ['path', { d: 'M7 17 17 7', key: '1vkiza' }],
  ],
  XK = lt('arrow-up-right', RC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const OC = [
    ['path', { d: 'm5 12 7-7 7 7', key: 'hav0vg' }],
    ['path', { d: 'M12 19V5', key: 'x0mq9r' }],
  ],
  YK = lt('arrow-up', OC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const PC = [
    ['circle', { cx: '12', cy: '12', r: '4', key: '4exip2' }],
    ['path', { d: 'M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8', key: '7n84p3' }],
  ],
  ZK = lt('at-sign', PC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const NC = [
    [
      'path',
      {
        d: 'm15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526',
        key: '1yiouv',
      },
    ],
    ['circle', { cx: '12', cy: '8', r: '6', key: '1vp47v' }],
  ],
  JK = lt('award', NC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const IC = [
    ['path', { d: 'M10.268 21a2 2 0 0 0 3.464 0', key: 'vwvbt9' }],
    [
      'path',
      {
        d: 'M17 17H4a1 1 0 0 1-.74-1.673C4.59 13.956 6 12.499 6 8a6 6 0 0 1 .258-1.742',
        key: '178tsu',
      },
    ],
    ['path', { d: 'm2 2 20 20', key: '1ooewy' }],
    ['path', { d: 'M8.668 3.01A6 6 0 0 1 18 8c0 2.687.77 4.653 1.707 6.05', key: '1hqiys' }],
  ],
  QK = lt('bell-off', IC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const DC = [
    ['path', { d: 'M10.268 21a2 2 0 0 0 3.464 0', key: 'vwvbt9' }],
    [
      'path',
      {
        d: 'M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326',
        key: '11g9vi',
      },
    ],
  ],
  tG = lt('bell', DC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const jC = [
    [
      'path',
      {
        d: 'M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20',
        key: 'k3hazp',
      },
    ],
  ],
  eG = lt('book', jC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const LC = [
    ['path', { d: 'm19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z', key: '1fy3hk' }],
  ],
  nG = lt('bookmark', LC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const FC = [
    ['path', { d: 'M12 8V4H8', key: 'hb8ula' }],
    ['rect', { width: '16', height: '12', x: '4', y: '8', rx: '2', key: 'enze0r' }],
    ['path', { d: 'M2 14h2', key: 'vft8re' }],
    ['path', { d: 'M20 14h2', key: '4cs60a' }],
    ['path', { d: 'M15 13v2', key: '1xurst' }],
    ['path', { d: 'M9 13v2', key: 'rq6x2g' }],
  ],
  rG = lt('bot', FC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const BC = [
    ['path', { d: 'M12 18V5', key: 'adv99a' }],
    ['path', { d: 'M15 13a4.17 4.17 0 0 1-3-4 4.17 4.17 0 0 1-3 4', key: '1e3is1' }],
    ['path', { d: 'M17.598 6.5A3 3 0 1 0 12 5a3 3 0 1 0-5.598 1.5', key: '1gqd8o' }],
    ['path', { d: 'M17.997 5.125a4 4 0 0 1 2.526 5.77', key: 'iwvgf7' }],
    ['path', { d: 'M18 18a4 4 0 0 0 2-7.464', key: 'efp6ie' }],
    ['path', { d: 'M19.967 17.483A4 4 0 1 1 12 18a4 4 0 1 1-7.967-.517', key: '1gq6am' }],
    ['path', { d: 'M6 18a4 4 0 0 1-2-7.464', key: 'k1g0md' }],
    ['path', { d: 'M6.003 5.125a4 4 0 0 0-2.526 5.77', key: 'q97ue3' }],
  ],
  iG = lt('brain', BC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const zC = [
    ['path', { d: 'M12 12h.01', key: '1mp3jc' }],
    ['path', { d: 'M16 6V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2', key: '1ksdt3' }],
    ['path', { d: 'M22 13a18.15 18.15 0 0 1-20 0', key: '12hx5q' }],
    ['rect', { width: '20', height: '14', x: '2', y: '6', rx: '2', key: 'i6l2r4' }],
  ],
  sG = lt('briefcase-business', zC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const $C = [
    ['path', { d: 'M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16', key: 'jecpp' }],
    ['rect', { width: '20', height: '14', x: '2', y: '6', rx: '2', key: 'i6l2r4' }],
  ],
  oG = lt('briefcase', $C)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const VC = [
    ['path', { d: 'M12 20v-9', key: '1qisl0' }],
    ['path', { d: 'M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z', key: 'uouzyp' }],
    ['path', { d: 'M14.12 3.88 16 2', key: 'qol33r' }],
    ['path', { d: 'M21 21a4 4 0 0 0-3.81-4', key: '1b0z45' }],
    ['path', { d: 'M21 5a4 4 0 0 1-3.55 3.97', key: '5cxbf6' }],
    ['path', { d: 'M22 13h-4', key: '1jl80f' }],
    ['path', { d: 'M3 21a4 4 0 0 1 3.81-4', key: '1fjd4g' }],
    ['path', { d: 'M3 5a4 4 0 0 0 3.55 3.97', key: '1d7oge' }],
    ['path', { d: 'M6 13H2', key: '82j7cp' }],
    ['path', { d: 'm8 2 1.88 1.88', key: 'fmnt4t' }],
    ['path', { d: 'M9 7.13V6a3 3 0 1 1 6 0v1.13', key: '1vgav8' }],
  ],
  aG = lt('bug', VC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const HC = [
    ['path', { d: 'M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z', key: '1b4qmf' }],
    ['path', { d: 'M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2', key: 'i71pzd' }],
    ['path', { d: 'M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2', key: '10jefs' }],
    ['path', { d: 'M10 6h4', key: '1itunk' }],
    ['path', { d: 'M10 10h4', key: 'tcdvrf' }],
    ['path', { d: 'M10 14h4', key: 'kelpxr' }],
    ['path', { d: 'M10 18h4', key: '1ulq68' }],
  ],
  lG = lt('building-2', HC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const UC = [
    ['path', { d: 'M12 10h.01', key: '1nrarc' }],
    ['path', { d: 'M12 14h.01', key: '1etili' }],
    ['path', { d: 'M12 6h.01', key: '1vi96p' }],
    ['path', { d: 'M16 10h.01', key: '1m94wz' }],
    ['path', { d: 'M16 14h.01', key: '1gbofw' }],
    ['path', { d: 'M16 6h.01', key: '1x0f13' }],
    ['path', { d: 'M8 10h.01', key: '19clt8' }],
    ['path', { d: 'M8 14h.01', key: '6423bh' }],
    ['path', { d: 'M8 6h.01', key: '1dz90k' }],
    ['path', { d: 'M9 22v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3', key: 'cabbwy' }],
    ['rect', { x: '4', y: '2', width: '16', height: '20', rx: '2', key: '1uxh74' }],
  ],
  cG = lt('building', UC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const qC = [
    ['path', { d: 'M8 2v4', key: '1cmpym' }],
    ['path', { d: 'M16 2v4', key: '4m81vk' }],
    ['rect', { width: '18', height: '18', x: '3', y: '4', rx: '2', key: '1hopcy' }],
    ['path', { d: 'M3 10h18', key: '8toen8' }],
    ['path', { d: 'M8 14h.01', key: '6423bh' }],
    ['path', { d: 'M12 14h.01', key: '1etili' }],
    ['path', { d: 'M16 14h.01', key: '1gbofw' }],
    ['path', { d: 'M8 18h.01', key: 'lrp35t' }],
    ['path', { d: 'M12 18h.01', key: 'mhygvu' }],
    ['path', { d: 'M16 18h.01', key: 'kzsmim' }],
  ],
  uG = lt('calendar-days', qC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const WC = [
    ['path', { d: 'M16 19h6', key: 'xwg31i' }],
    ['path', { d: 'M16 2v4', key: '4m81vk' }],
    ['path', { d: 'M19 16v6', key: 'tddt3s' }],
    [
      'path',
      { d: 'M21 12.598V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8.5', key: '1glfrc' },
    ],
    ['path', { d: 'M3 10h18', key: '8toen8' }],
    ['path', { d: 'M8 2v4', key: '1cmpym' }],
  ],
  fG = lt('calendar-plus', WC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const KC = [
    ['path', { d: 'M8 2v4', key: '1cmpym' }],
    ['path', { d: 'M16 2v4', key: '4m81vk' }],
    ['rect', { width: '18', height: '18', x: '3', y: '4', rx: '2', key: '1hopcy' }],
    ['path', { d: 'M3 10h18', key: '8toen8' }],
  ],
  dG = lt('calendar', KC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const GC = [
    [
      'path',
      {
        d: 'M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z',
        key: '18u6gg',
      },
    ],
    ['circle', { cx: '12', cy: '13', r: '3', key: '1vg3eu' }],
  ],
  hG = lt('camera', GC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const XC = [
    [
      'path',
      {
        d: 'M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2',
        key: '5owen',
      },
    ],
    ['circle', { cx: '7', cy: '17', r: '2', key: 'u2ysq9' }],
    ['path', { d: 'M9 17h6', key: 'r8uit2' }],
    ['circle', { cx: '17', cy: '17', r: '2', key: 'axvx0g' }],
  ],
  pG = lt('car', XC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const YC = [
    ['path', { d: 'M3 3v16a2 2 0 0 0 2 2h16', key: 'c24i48' }],
    ['path', { d: 'M18 17V9', key: '2bz60n' }],
    ['path', { d: 'M13 17V5', key: '1frdt8' }],
    ['path', { d: 'M8 17v-3', key: '17ska0' }],
  ],
  mG = lt('chart-column', YC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ZC = [
    ['path', { d: 'M5 21v-6', key: '1hz6c0' }],
    ['path', { d: 'M12 21V3', key: '1lcnhd' }],
    ['path', { d: 'M19 21V9', key: 'unv183' }],
  ],
  gG = lt('chart-no-axes-column', ZC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const JC = [
    [
      'path',
      {
        d: 'M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.998.398-.998.95v8a1 1 0 0 0 1 1z',
        key: 'pzmjnu',
      },
    ],
    ['path', { d: 'M21.21 15.89A10 10 0 1 1 8 2.83', key: 'k2fpak' }],
  ],
  yG = lt('chart-pie', JC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const QC = [['path', { d: 'M20 6 9 17l-5-5', key: '1gmf2c' }]],
  bG = lt('check', QC)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const tM = [['path', { d: 'm6 9 6 6 6-6', key: 'qrunsl' }]],
  vG = lt('chevron-down', tM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const eM = [['path', { d: 'm15 18-6-6 6-6', key: '1wnfg3' }]],
  wG = lt('chevron-left', eM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const nM = [['path', { d: 'm9 18 6-6-6-6', key: 'mthhwq' }]],
  xG = lt('chevron-right', nM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const rM = [['path', { d: 'm18 15-6-6-6 6', key: '153udz' }]],
  SG = lt('chevron-up', rM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const iM = [
    ['path', { d: 'm11 17-5-5 5-5', key: '13zhaf' }],
    ['path', { d: 'm18 17-5-5 5-5', key: 'h8a8et' }],
  ],
  _G = lt('chevrons-left', iM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const sM = [
    ['path', { d: 'm6 17 5-5-5-5', key: 'xnjwq' }],
    ['path', { d: 'm13 17 5-5-5-5', key: '17xmmf' }],
  ],
  kG = lt('chevrons-right', sM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const oM = [
    ['path', { d: 'm7 15 5 5 5-5', key: '1hf1tw' }],
    ['path', { d: 'm7 9 5-5 5 5', key: 'sgt6xg' }],
  ],
  CG = lt('chevrons-up-down', oM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const aM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['line', { x1: '12', x2: '12', y1: '8', y2: '12', key: '1pkeuh' }],
    ['line', { x1: '12', x2: '12.01', y1: '16', y2: '16', key: '4dfq90' }],
  ],
  MG = lt('circle-alert', aM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const lM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['path', { d: 'm16 12-4-4-4 4', key: '177agl' }],
    ['path', { d: 'M12 16V8', key: '1sbj14' }],
  ],
  EG = lt('circle-arrow-up', lM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const cM = [
    ['path', { d: 'M21.801 10A10 10 0 1 1 17 3.335', key: 'yps3ct' }],
    ['path', { d: 'm9 11 3 3L22 4', key: '1pflzl' }],
  ],
  TG = lt('circle-check-big', cM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const uM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['path', { d: 'm9 12 2 2 4-4', key: 'dzmm74' }],
  ],
  AG = lt('circle-check', uM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const fM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['path', { d: 'M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3', key: '1u773s' }],
    ['path', { d: 'M12 17h.01', key: 'p32p05' }],
  ],
  RG = lt('circle-question-mark', fM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const dM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['circle', { cx: '12', cy: '10', r: '3', key: 'ilqhr7' }],
    ['path', { d: 'M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662', key: '154egf' }],
  ],
  OG = lt('circle-user', dM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const hM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['path', { d: 'm15 9-6 6', key: '1uzhvr' }],
    ['path', { d: 'm9 9 6 6', key: 'z0biqf' }],
  ],
  PG = lt('circle-x', hM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const pM = [['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }]],
  NG = lt('circle', pM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const mM = [
    ['rect', { width: '8', height: '4', x: '8', y: '2', rx: '1', ry: '1', key: 'tgr4d6' }],
    [
      'path',
      {
        d: 'M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2',
        key: '116196',
      },
    ],
    ['path', { d: 'M12 11h4', key: '1jrz19' }],
    ['path', { d: 'M12 16h4', key: 'n85exb' }],
    ['path', { d: 'M8 11h.01', key: '1dfujw' }],
    ['path', { d: 'M8 16h.01', key: '18s6g9' }],
  ],
  IG = lt('clipboard-list', mM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const gM = [
    ['path', { d: 'M12 6v6l4 2', key: 'mmk7yg' }],
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
  ],
  DG = lt('clock', gM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yM = [
    ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }],
    ['path', { d: 'M9 3v18', key: 'fh3hqa' }],
    ['path', { d: 'M15 3v18', key: '14nvp0' }],
  ],
  jG = lt('columns-3', yM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const bM = [
    ['rect', { width: '14', height: '14', x: '8', y: '8', rx: '2', ry: '2', key: '17jyea' }],
    ['path', { d: 'M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2', key: 'zix9uf' }],
  ],
  LG = lt('copy', bM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const vM = [
    ['rect', { width: '20', height: '14', x: '2', y: '5', rx: '2', key: 'ynyp8z' }],
    ['line', { x1: '2', x2: '22', y1: '10', y2: '10', key: '1b3vmo' }],
  ],
  FG = lt('credit-card', vM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const wM = [
    ['ellipse', { cx: '12', cy: '5', rx: '9', ry: '3', key: 'msslwz' }],
    ['path', { d: 'M3 5V19A9 3 0 0 0 21 19V5', key: '1wlel7' }],
    ['path', { d: 'M3 12A9 3 0 0 0 21 12', key: 'mv7ke4' }],
  ],
  BG = lt('database', wM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const xM = [
    ['line', { x1: '12', x2: '12', y1: '2', y2: '22', key: '7eqyqh' }],
    ['path', { d: 'M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6', key: '1b0p4s' }],
  ],
  zG = lt('dollar-sign', xM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const SM = [
    ['path', { d: 'M12 15V3', key: 'm9g1x1' }],
    ['path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4', key: 'ih7n3h' }],
    ['path', { d: 'm7 10 5 5 5-5', key: 'brsn70' }],
  ],
  $G = lt('download', SM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const _M = [
    ['path', { d: 'M21.54 15H17a2 2 0 0 0-2 2v4.54', key: '1djwo0' }],
    [
      'path',
      {
        d: 'M7 3.34V5a3 3 0 0 0 3 3a2 2 0 0 1 2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.1.9-2 2-2h3.17',
        key: '1tzkfa',
      },
    ],
    [
      'path',
      { d: 'M11 21.95V18a2 2 0 0 0-2-2a2 2 0 0 1-2-2v-1a2 2 0 0 0-2-2H2.05', key: '14pb5j' },
    ],
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
  ],
  VG = lt('earth', _M)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const kM = [
    ['circle', { cx: '12', cy: '12', r: '1', key: '41hilf' }],
    ['circle', { cx: '12', cy: '5', r: '1', key: 'gxeob9' }],
    ['circle', { cx: '12', cy: '19', r: '1', key: 'lyex9k' }],
  ],
  HG = lt('ellipsis-vertical', kM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const CM = [
    ['circle', { cx: '12', cy: '12', r: '1', key: '41hilf' }],
    ['circle', { cx: '19', cy: '12', r: '1', key: '1wjl8i' }],
    ['circle', { cx: '5', cy: '12', r: '1', key: '1pcz8c' }],
  ],
  UG = lt('ellipsis', CM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const MM = [
    ['path', { d: 'M15 3h6v6', key: '1q9fwt' }],
    ['path', { d: 'M10 14 21 3', key: 'gplh6r' }],
    ['path', { d: 'M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6', key: 'a6xqqp' }],
  ],
  qG = lt('external-link', MM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const EM = [
    [
      'path',
      {
        d: 'M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49',
        key: 'ct8e1f',
      },
    ],
    ['path', { d: 'M14.084 14.158a3 3 0 0 1-4.242-4.242', key: '151rxh' }],
    [
      'path',
      {
        d: 'M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143',
        key: '13bj9a',
      },
    ],
    ['path', { d: 'm2 2 20 20', key: '1ooewy' }],
  ],
  WG = lt('eye-off', EM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const TM = [
    [
      'path',
      {
        d: 'M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0',
        key: '1nclc0',
      },
    ],
    ['circle', { cx: '12', cy: '12', r: '3', key: '1v7zrd' }],
  ],
  KG = lt('eye', TM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const AM = [
    ['path', { d: 'M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z', key: '1rqfz7' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
    ['path', { d: 'M8 18v-2', key: 'qcmpov' }],
    ['path', { d: 'M12 18v-4', key: 'q1q25u' }],
    ['path', { d: 'M16 18v-6', key: '15y0np' }],
  ],
  GG = lt('file-chart-column-increasing', AM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const RM = [
    ['path', { d: 'M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z', key: '1rqfz7' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
    ['path', { d: 'm9 15 2 2 4-4', key: '1grp1n' }],
  ],
  XG = lt('file-check', RM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const OM = [
    ['path', { d: 'M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z', key: '1rqfz7' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
    [
      'path',
      { d: 'M10 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1', key: '1oajmo' },
    ],
    [
      'path',
      { d: 'M14 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1', key: 'mpwhp6' },
    ],
  ],
  YG = lt('file-json', OM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const PM = [
    ['path', { d: 'M12.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v9.5', key: '1couwa' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
    [
      'path',
      {
        d: 'M13.378 15.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z',
        key: '1y4qbx',
      },
    ],
  ],
  ZG = lt('file-pen', PM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const NM = [
    ['path', { d: 'M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z', key: '1rqfz7' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
    ['path', { d: 'M8 13h2', key: 'yr2amv' }],
    ['path', { d: 'M14 13h2', key: 'un5t4a' }],
    ['path', { d: 'M8 17h2', key: '2yhykz' }],
    ['path', { d: 'M14 17h2', key: '10kma7' }],
  ],
  JG = lt('file-spreadsheet', NM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const IM = [
    ['path', { d: 'M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z', key: '1rqfz7' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
    ['path', { d: 'M10 9H8', key: 'b1mrlr' }],
    ['path', { d: 'M16 13H8', key: 't4e002' }],
    ['path', { d: 'M16 17H8', key: 'z1uh3a' }],
  ],
  QG = lt('file-text', IM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const DM = [
    ['path', { d: 'M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4', key: '1pf5j1' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
    ['path', { d: 'm8 12.5-5 5', key: 'b853mi' }],
    ['path', { d: 'm3 12.5 5 5', key: '1qls4r' }],
  ],
  tX = lt('file-x-2', DM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const jM = [
    ['path', { d: 'M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z', key: '1rqfz7' }],
    ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],
  ],
  eX = lt('file', jM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const LM = [
    [
      'path',
      {
        d: 'M4 22V4a1 1 0 0 1 .4-.8A6 6 0 0 1 8 2c3 0 5 2 7.333 2q2 0 3.067-.8A1 1 0 0 1 20 4v10a1 1 0 0 1-.4.8A6 6 0 0 1 16 16c-3 0-5-2-8-2a6 6 0 0 0-4 1.528',
        key: '1jaruq',
      },
    ],
  ],
  nX = lt('flag', LM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const FM = [
    [
      'path',
      {
        d: 'm6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2',
        key: 'usdka0',
      },
    ],
  ],
  rX = lt('folder-open', FM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const BM = [
    ['path', { d: 'M12 10v6', key: '1bos4e' }],
    ['path', { d: 'M9 13h6', key: '1uhe8q' }],
    [
      'path',
      {
        d: 'M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z',
        key: '1kt360',
      },
    ],
  ],
  iX = lt('folder-plus', BM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const zM = [
    [
      'path',
      {
        d: 'M20 10a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-2.5a1 1 0 0 1-.8-.4l-.9-1.2A1 1 0 0 0 15 3h-2a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1Z',
        key: 'hod4my',
      },
    ],
    [
      'path',
      {
        d: 'M20 21a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1h-2.9a1 1 0 0 1-.88-.55l-.42-.85a1 1 0 0 0-.92-.6H13a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1Z',
        key: 'w4yl2u',
      },
    ],
    ['path', { d: 'M3 5a2 2 0 0 0 2 2h3', key: 'f2jnh7' }],
    ['path', { d: 'M3 3v13a2 2 0 0 0 2 2h3', key: 'k8epm1' }],
  ],
  sX = lt('folder-tree', zM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const $M = [
    [
      'path',
      {
        d: 'M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z',
        key: '1kt360',
      },
    ],
  ],
  oX = lt('folder', $M)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const VM = [
    [
      'path',
      {
        d: 'M10 20a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341L21.74 4.67A1 1 0 0 0 21 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14z',
        key: 'sc7q7i',
      },
    ],
  ],
  aX = lt('funnel', VM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const HM = [
    ['circle', { cx: '18', cy: '18', r: '3', key: '1xkwt0' }],
    ['circle', { cx: '6', cy: '6', r: '3', key: '1lh9wr' }],
    ['path', { d: 'M13 6h3a2 2 0 0 1 2 2v7', key: '1yeb86' }],
    ['path', { d: 'M11 18H8a2 2 0 0 1-2-2V9', key: '19pyzm' }],
  ],
  lX = lt('git-compare', HM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const UM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['path', { d: 'M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20', key: '13o1zl' }],
    ['path', { d: 'M2 12h20', key: '9i4pu4' }],
  ],
  cX = lt('globe', UM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const qM = [
    ['circle', { cx: '9', cy: '12', r: '1', key: '1vctgf' }],
    ['circle', { cx: '9', cy: '5', r: '1', key: 'hp0tcf' }],
    ['circle', { cx: '9', cy: '19', r: '1', key: 'fkjjf6' }],
    ['circle', { cx: '15', cy: '12', r: '1', key: '1tmaij' }],
    ['circle', { cx: '15', cy: '5', r: '1', key: '19l28e' }],
    ['circle', { cx: '15', cy: '19', r: '1', key: 'f4zoj3' }],
  ],
  uX = lt('grip-vertical', qM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const WM = [
    ['path', { d: 'm11 17 2 2a1 1 0 1 0 3-3', key: 'efffak' }],
    [
      'path',
      {
        d: 'm14 14 2.5 2.5a1 1 0 1 0 3-3l-3.88-3.88a3 3 0 0 0-4.24 0l-.88.88a1 1 0 1 1-3-3l2.81-2.81a5.79 5.79 0 0 1 7.06-.87l.47.28a2 2 0 0 0 1.42.25L21 4',
        key: '9pr0kb',
      },
    ],
    ['path', { d: 'm21 3 1 11h-2', key: '1tisrp' }],
    ['path', { d: 'M3 3 2 14l6.5 6.5a1 1 0 1 0 3-3', key: '1uvwmv' }],
    ['path', { d: 'M3 4h8', key: '1ep09j' }],
  ],
  fX = lt('handshake', WM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const KM = [
    ['line', { x1: '4', x2: '20', y1: '9', y2: '9', key: '4lhtct' }],
    ['line', { x1: '4', x2: '20', y1: '15', y2: '15', key: 'vyu0kd' }],
    ['line', { x1: '10', x2: '8', y1: '3', y2: '21', key: '1ggp8o' }],
    ['line', { x1: '16', x2: '14', y1: '3', y2: '21', key: 'weycgp' }],
  ],
  dX = lt('hash', KM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const GM = [
    ['path', { d: 'M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8', key: '1357e3' }],
    ['path', { d: 'M3 3v5h5', key: '1xhq8a' }],
    ['path', { d: 'M12 7v5l4 2', key: '1fdv2h' }],
  ],
  hX = lt('history', GM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const XM = [
    ['path', { d: 'M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8', key: '5wwlr5' }],
    [
      'path',
      {
        d: 'M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z',
        key: 'r6nss1',
      },
    ],
  ],
  pX = lt('house', XM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const YM = [
    ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', ry: '2', key: '1m3agn' }],
    ['circle', { cx: '9', cy: '9', r: '2', key: 'af1f0g' }],
    ['path', { d: 'm21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21', key: '1xmnt7' }],
  ],
  mX = lt('image', YM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ZM = [
    ['polyline', { points: '22 12 16 12 14 15 10 15 8 12 2 12', key: 'o97t9d' }],
    [
      'path',
      {
        d: 'M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z',
        key: 'oot6mr',
      },
    ],
  ],
  gX = lt('inbox', ZM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const JM = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['path', { d: 'M12 16v-4', key: '1dtifu' }],
    ['path', { d: 'M12 8h.01', key: 'e9boi3' }],
  ],
  yX = lt('info', JM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const QM = [
    [
      'path',
      { d: 'm15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4', key: 'g0fldk' },
    ],
    ['path', { d: 'm21 2-9.6 9.6', key: '1j0ho8' }],
    ['circle', { cx: '7.5', cy: '15.5', r: '5.5', key: 'yqb3hr' }],
  ],
  bX = lt('key', QM)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const t7 = [
    ['path', { d: 'm5 8 6 6', key: '1wu5hv' }],
    ['path', { d: 'm4 14 6-6 2-3', key: '1k1g8d' }],
    ['path', { d: 'M2 5h12', key: 'or177f' }],
    ['path', { d: 'M7 2h1', key: '1t2jsx' }],
    ['path', { d: 'm22 22-5-10-5 10', key: 'don7ne' }],
    ['path', { d: 'M14 18h6', key: '1m8k6r' }],
  ],
  vX = lt('languages', t7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const e7 = [
    ['rect', { width: '7', height: '7', x: '3', y: '3', rx: '1', key: '1g98yp' }],
    ['rect', { width: '7', height: '7', x: '14', y: '3', rx: '1', key: '6d4xhi' }],
    ['rect', { width: '7', height: '7', x: '14', y: '14', rx: '1', key: 'nxv5o0' }],
    ['rect', { width: '7', height: '7', x: '3', y: '14', rx: '1', key: '1bb6yr' }],
  ],
  wX = lt('layout-grid', e7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const n7 = [
    ['rect', { width: '7', height: '9', x: '3', y: '3', rx: '1', key: '10lvy0' }],
    ['rect', { width: '7', height: '5', x: '14', y: '3', rx: '1', key: '16une8' }],
    ['rect', { width: '7', height: '9', x: '14', y: '12', rx: '1', key: '1hutg5' }],
    ['rect', { width: '7', height: '5', x: '3', y: '16', rx: '1', key: 'ldoo1y' }],
  ],
  xX = lt('layout-dashboard', n7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const r7 = [
    ['rect', { width: '7', height: '7', x: '3', y: '3', rx: '1', key: '1g98yp' }],
    ['rect', { width: '7', height: '7', x: '3', y: '14', rx: '1', key: '1bb6yr' }],
    ['path', { d: 'M14 4h7', key: '3xa0d5' }],
    ['path', { d: 'M14 9h7', key: '1icrd9' }],
    ['path', { d: 'M14 15h7', key: '1mj8o2' }],
    ['path', { d: 'M14 20h7', key: '11slyb' }],
  ],
  SX = lt('layout-list', r7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const i7 = [
    [
      'path',
      {
        d: 'M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5',
        key: '1gvzjb',
      },
    ],
    ['path', { d: 'M9 18h6', key: 'x1upvd' }],
    ['path', { d: 'M10 22h4', key: 'ceow96' }],
  ],
  _X = lt('lightbulb', i7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const s7 = [
    ['path', { d: 'M9 17H7A5 5 0 0 1 7 7h2', key: '8i5ue5' }],
    ['path', { d: 'M15 7h2a5 5 0 1 1 0 10h-2', key: '1b9ql8' }],
    ['line', { x1: '8', x2: '16', y1: '12', y2: '12', key: '1jonct' }],
  ],
  kX = lt('link-2', s7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const o7 = [
    ['path', { d: 'M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71', key: '1cjeqo' }],
    ['path', { d: 'M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71', key: '19qd67' }],
  ],
  CX = lt('link', o7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const a7 = [
    ['path', { d: 'M13 5h8', key: 'a7qcls' }],
    ['path', { d: 'M13 12h8', key: 'h98zly' }],
    ['path', { d: 'M13 19h8', key: 'c3s6r1' }],
    ['path', { d: 'm3 17 2 2 4-4', key: '1jhpwq' }],
    ['path', { d: 'm3 7 2 2 4-4', key: '1obspn' }],
  ],
  MX = lt('list-checks', a7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const l7 = [
    ['path', { d: 'M13 5h8', key: 'a7qcls' }],
    ['path', { d: 'M13 12h8', key: 'h98zly' }],
    ['path', { d: 'M13 19h8', key: 'c3s6r1' }],
    ['path', { d: 'm3 17 2 2 4-4', key: '1jhpwq' }],
    ['rect', { x: '3', y: '4', width: '6', height: '6', rx: '1', key: 'cif1o7' }],
  ],
  EX = lt('list-todo', l7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const c7 = [
    ['path', { d: 'M3 5h.01', key: '18ugdj' }],
    ['path', { d: 'M3 12h.01', key: 'nlz23k' }],
    ['path', { d: 'M3 19h.01', key: 'noohij' }],
    ['path', { d: 'M8 5h13', key: '1pao27' }],
    ['path', { d: 'M8 12h13', key: '1za7za' }],
    ['path', { d: 'M8 19h13', key: 'm83p4d' }],
  ],
  TX = lt('list', c7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const u7 = [['path', { d: 'M21 12a9 9 0 1 1-6.219-8.56', key: '13zald' }]],
  AX = lt('loader-circle', u7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const f7 = [
    ['rect', { width: '18', height: '11', x: '3', y: '11', rx: '2', ry: '2', key: '1w4ew1' }],
    ['path', { d: 'M7 11V7a5 5 0 0 1 9.9-1', key: '1mm8w8' }],
  ],
  RX = lt('lock-open', f7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const d7 = [
    ['rect', { width: '18', height: '11', x: '3', y: '11', rx: '2', ry: '2', key: '1w4ew1' }],
    ['path', { d: 'M7 11V7a5 5 0 0 1 10 0v4', key: 'fwvmzm' }],
  ],
  OX = lt('lock', d7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const h7 = [
    ['path', { d: 'm16 17 5-5-5-5', key: '1bji2h' }],
    ['path', { d: 'M21 12H9', key: 'dn1m92' }],
    ['path', { d: 'M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4', key: '1uf3rs' }],
  ],
  PX = lt('log-out', h7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const p7 = [
    ['path', { d: 'm22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7', key: '132q7q' }],
    ['rect', { x: '2', y: '4', width: '20', height: '16', rx: '2', key: 'izxlao' }],
  ],
  NX = lt('mail', p7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const m7 = [
    [
      'path',
      {
        d: 'M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0',
        key: '1r0f0z',
      },
    ],
    ['circle', { cx: '12', cy: '10', r: '3', key: 'ilqhr7' }],
  ],
  IX = lt('map-pin', m7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const g7 = [
    ['path', { d: 'M15 3h6v6', key: '1q9fwt' }],
    ['path', { d: 'm21 3-7 7', key: '1l2asr' }],
    ['path', { d: 'm3 21 7-7', key: 'tjx5ai' }],
    ['path', { d: 'M9 21H3v-6', key: 'wtvkvv' }],
  ],
  DX = lt('maximize-2', g7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const y7 = [
    ['path', { d: 'M4 5h16', key: '1tepv9' }],
    ['path', { d: 'M4 12h16', key: '1lakjw' }],
    ['path', { d: 'M4 19h16', key: '1djgab' }],
  ],
  jX = lt('menu', y7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const b7 = [
    [
      'path',
      {
        d: 'M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719',
        key: '1sd12s',
      },
    ],
  ],
  LX = lt('message-circle', b7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const v7 = [
    [
      'path',
      {
        d: 'M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z',
        key: '18887p',
      },
    ],
  ],
  FX = lt('message-square', v7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const w7 = [
    ['path', { d: 'm14 10 7-7', key: 'oa77jy' }],
    ['path', { d: 'M20 10h-6V4', key: 'mjg0md' }],
    ['path', { d: 'm3 21 7-7', key: 'tjx5ai' }],
    ['path', { d: 'M4 14h6v6', key: 'rmj7iw' }],
  ],
  BX = lt('minimize-2', w7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const x7 = [['path', { d: 'M5 12h14', key: '1ays0h' }]],
  zX = lt('minus', x7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const S7 = [
    [
      'path',
      {
        d: 'M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401',
        key: 'kfwtm',
      },
    ],
  ],
  $X = lt('moon', S7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const _7 = [
    ['path', { d: 'M12 2v20', key: 't6zp3m' }],
    ['path', { d: 'm15 19-3 3-3-3', key: '11eu04' }],
    ['path', { d: 'm19 9 3 3-3 3', key: '1mg7y2' }],
    ['path', { d: 'M2 12h20', key: '9i4pu4' }],
    ['path', { d: 'm5 9-3 3 3 3', key: 'j64kie' }],
    ['path', { d: 'm9 5 3-3 3 3', key: 'l8vdw6' }],
  ],
  VX = lt('move', _7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const k7 = [
    ['rect', { x: '16', y: '16', width: '6', height: '6', rx: '1', key: '4q2zg0' }],
    ['rect', { x: '2', y: '16', width: '6', height: '6', rx: '1', key: '8cvhb9' }],
    ['rect', { x: '9', y: '2', width: '6', height: '6', rx: '1', key: '1egb70' }],
    ['path', { d: 'M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3', key: '1jsf9p' }],
    ['path', { d: 'M12 12V8', key: '2874zd' }],
  ],
  HX = lt('network', k7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const C7 = [
    [
      'path',
      {
        d: 'M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z',
        key: '1a0edw',
      },
    ],
    ['path', { d: 'M12 22V12', key: 'd0xqtd' }],
    ['polyline', { points: '3.29 7 12 12 20.71 7', key: 'ousv84' }],
    ['path', { d: 'm7.5 4.27 9 5.15', key: '1c824w' }],
  ],
  UX = lt('package', C7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const M7 = [
    [
      'path',
      {
        d: 'M12 22a1 1 0 0 1 0-20 10 9 0 0 1 10 9 5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z',
        key: 'e79jfc',
      },
    ],
    ['circle', { cx: '13.5', cy: '6.5', r: '.5', fill: 'currentColor', key: '1okk4w' }],
    ['circle', { cx: '17.5', cy: '10.5', r: '.5', fill: 'currentColor', key: 'f64h9f' }],
    ['circle', { cx: '6.5', cy: '12.5', r: '.5', fill: 'currentColor', key: 'qy21gx' }],
    ['circle', { cx: '8.5', cy: '7.5', r: '.5', fill: 'currentColor', key: 'fotxhn' }],
  ],
  qX = lt('palette', M7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const E7 = [
    [
      'path',
      {
        d: 'm16 6-8.414 8.586a2 2 0 0 0 2.829 2.829l8.414-8.586a4 4 0 1 0-5.657-5.657l-8.379 8.551a6 6 0 1 0 8.485 8.485l8.379-8.551',
        key: '1miecu',
      },
    ],
  ],
  WX = lt('paperclip', E7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const T7 = [
    ['path', { d: 'M13 21h8', key: '1jsn5i' }],
    [
      'path',
      {
        d: 'M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z',
        key: '1a8usu',
      },
    ],
  ],
  KX = lt('pen-line', T7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const A7 = [
    [
      'path',
      {
        d: 'M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z',
        key: 'nt11vn',
      },
    ],
    [
      'path',
      {
        d: 'm18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18',
        key: '15qc1e',
      },
    ],
    ['path', { d: 'm2.3 2.3 7.286 7.286', key: '1wuzzi' }],
    ['circle', { cx: '11', cy: '11', r: '2', key: 'xmgehs' }],
  ],
  GX = lt('pen-tool', A7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const R7 = [
    [
      'path',
      {
        d: 'M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z',
        key: '1a8usu',
      },
    ],
  ],
  XX = lt('pen', R7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const O7 = [
    [
      'path',
      {
        d: 'M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z',
        key: '1a8usu',
      },
    ],
    ['path', { d: 'm15 5 4 4', key: '1mk7zo' }],
  ],
  YX = lt('pencil', O7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const P7 = [
    [
      'path',
      {
        d: 'M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384',
        key: '9njp5v',
      },
    ],
  ],
  ZX = lt('phone', P7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const N7 = [
    [
      'path',
      {
        d: 'M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z',
        key: '10ikf1',
      },
    ],
  ],
  JX = lt('play', N7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const I7 = [
    ['path', { d: 'M5 12h14', key: '1ays0h' }],
    ['path', { d: 'M12 5v14', key: 's699le' }],
  ],
  QX = lt('plus', I7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const D7 = [
    [
      'path',
      {
        d: 'M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2',
        key: '143wyd',
      },
    ],
    ['path', { d: 'M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6', key: '1itne7' }],
    ['rect', { x: '6', y: '14', width: '12', height: '8', rx: '1', key: '1ue0tg' }],
  ],
  tY = lt('printer', D7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const j7 = [
    [
      'path',
      {
        d: 'M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z',
        key: 'rib7q0',
      },
    ],
    [
      'path',
      {
        d: 'M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z',
        key: '1ymkrd',
      },
    ],
  ],
  eY = lt('quote', j7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const L7 = [
    ['path', { d: 'M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8', key: '14sxne' }],
    ['path', { d: 'M3 3v5h5', key: '1xhq8a' }],
    ['path', { d: 'M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16', key: '1hlbsb' }],
    ['path', { d: 'M16 16h5v5', key: 'ccwih5' }],
  ],
  nY = lt('refresh-ccw', L7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const F7 = [
    ['path', { d: 'M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8', key: 'v9h5vc' }],
    ['path', { d: 'M21 3v5h-5', key: '1q7to0' }],
    ['path', { d: 'M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16', key: '3uifl3' }],
    ['path', { d: 'M8 16H3v5', key: '1cv678' }],
  ],
  rY = lt('refresh-cw', F7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const B7 = [
    ['path', { d: 'M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8', key: '1357e3' }],
    ['path', { d: 'M3 3v5h5', key: '1xhq8a' }],
  ],
  iY = lt('rotate-ccw', B7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const z7 = [
    [
      'path',
      {
        d: 'M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z',
        key: '1c8476',
      },
    ],
    ['path', { d: 'M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7', key: '1ydtos' }],
    ['path', { d: 'M7 3v4a1 1 0 0 0 1 1h7', key: 't51u73' }],
  ],
  sY = lt('save', z7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const $7 = [
    ['path', { d: 'm16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z', key: '7g6ntu' }],
    ['path', { d: 'm2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z', key: 'ijws7r' }],
    ['path', { d: 'M7 21h10', key: '1b0cd5' }],
    ['path', { d: 'M12 3v18', key: '108xh3' }],
    ['path', { d: 'M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2', key: '3gwbw2' }],
  ],
  oY = lt('scale', $7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const V7 = [
    ['path', { d: 'M3 7V5a2 2 0 0 1 2-2h2', key: 'aa7l1z' }],
    ['path', { d: 'M17 3h2a2 2 0 0 1 2 2v2', key: '4qcy5o' }],
    ['path', { d: 'M21 17v2a2 2 0 0 1-2 2h-2', key: '6vwrx8' }],
    ['path', { d: 'M7 21H5a2 2 0 0 1-2-2v-2', key: 'ioqczr' }],
  ],
  aY = lt('scan', V7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const H7 = [
    ['path', { d: 'M15 12h-5', key: 'r7krc0' }],
    ['path', { d: 'M15 8h-5', key: '1khuty' }],
    ['path', { d: 'M19 17V5a2 2 0 0 0-2-2H4', key: 'zz82l3' }],
    [
      'path',
      {
        d: 'M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3',
        key: '1ph1d7',
      },
    ],
  ],
  lY = lt('scroll-text', H7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const U7 = [
    ['path', { d: 'm13.5 8.5-5 5', key: '1cs55j' }],
    ['path', { d: 'm8.5 8.5 5 5', key: 'a8mexj' }],
    ['circle', { cx: '11', cy: '11', r: '8', key: '4ej97u' }],
    ['path', { d: 'm21 21-4.3-4.3', key: '1qie3q' }],
  ],
  cY = lt('search-x', U7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const q7 = [
    ['path', { d: 'm21 21-4.34-4.34', key: '14j7rj' }],
    ['circle', { cx: '11', cy: '11', r: '8', key: '4ej97u' }],
  ],
  uY = lt('search', q7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const W7 = [
    [
      'path',
      {
        d: 'M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z',
        key: '1ffxy3',
      },
    ],
    ['path', { d: 'm21.854 2.147-10.94 10.939', key: '12cjpa' }],
  ],
  fY = lt('send', W7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const K7 = [
    [
      'path',
      {
        d: 'M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915',
        key: '1i5ecw',
      },
    ],
    ['circle', { cx: '12', cy: '12', r: '3', key: '1v7zrd' }],
  ],
  dY = lt('settings', K7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const G7 = [
    [
      'path',
      {
        d: 'M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z',
        key: 'oel41y',
      },
    ],
    ['path', { d: 'M12 8v4', key: '1got3b' }],
    ['path', { d: 'M12 16h.01', key: '1drbdi' }],
  ],
  hY = lt('shield-alert', G7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const X7 = [
    [
      'path',
      {
        d: 'M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z',
        key: 'oel41y',
      },
    ],
    ['path', { d: 'm9 12 2 2 4-4', key: 'dzmm74' }],
  ],
  pY = lt('shield-check', X7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Y7 = [
    [
      'path',
      {
        d: 'M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z',
        key: 'oel41y',
      },
    ],
  ],
  mY = lt('shield', Y7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Z7 = [
    ['path', { d: 'M2 20h.01', key: '4haj6o' }],
    ['path', { d: 'M7 20v-4', key: 'j294jx' }],
    ['path', { d: 'M12 20v-8', key: 'i3yub9' }],
    ['path', { d: 'M17 20V8', key: '1tkaf5' }],
    ['path', { d: 'M22 4v16', key: 'sih9yq' }],
  ],
  gY = lt('signal', Z7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const J7 = [
    ['path', { d: 'M10 5H3', key: '1qgfaw' }],
    ['path', { d: 'M12 19H3', key: 'yhmn1j' }],
    ['path', { d: 'M14 3v4', key: '1sua03' }],
    ['path', { d: 'M16 17v4', key: '1q0r14' }],
    ['path', { d: 'M21 12h-9', key: '1o4lsq' }],
    ['path', { d: 'M21 19h-5', key: '1rlt1p' }],
    ['path', { d: 'M21 5h-7', key: '1oszz2' }],
    ['path', { d: 'M8 10v4', key: 'tgpxqk' }],
    ['path', { d: 'M8 12H3', key: 'a7s4jb' }],
  ],
  yY = lt('sliders-horizontal', J7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Q7 = [
    ['path', { d: 'M10 8h4', key: '1sr2af' }],
    ['path', { d: 'M12 21v-9', key: '17s77i' }],
    ['path', { d: 'M12 8V3', key: '13r4qs' }],
    ['path', { d: 'M17 16h4', key: 'h1uq16' }],
    ['path', { d: 'M19 12V3', key: 'o1uvq1' }],
    ['path', { d: 'M19 21v-5', key: 'qua636' }],
    ['path', { d: 'M3 14h4', key: 'bcjad9' }],
    ['path', { d: 'M5 10V3', key: 'cb8scm' }],
    ['path', { d: 'M5 21v-7', key: '1w1uti' }],
  ],
  bY = lt('sliders-vertical', Q7)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const t9 = [
    ['rect', { width: '14', height: '20', x: '5', y: '2', rx: '2', ry: '2', key: '1yt0o3' }],
    ['path', { d: 'M12 18h.01', key: 'mhygvu' }],
  ],
  vY = lt('smartphone', t9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const e9 = [
    [
      'path',
      {
        d: 'M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z',
        key: '1s2grr',
      },
    ],
    ['path', { d: 'M20 2v4', key: '1rf3ol' }],
    ['path', { d: 'M22 4h-4', key: 'gwowj6' }],
    ['circle', { cx: '4', cy: '20', r: '2', key: '6kqj1y' }],
  ],
  wY = lt('sparkles', e9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const n9 = [
    [
      'path',
      { d: 'M21 10.656V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.344', key: '2acyp4' },
    ],
    ['path', { d: 'm9 11 3 3L22 4', key: '1pflzl' }],
  ],
  xY = lt('square-check-big', n9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const r9 = [
    ['path', { d: 'M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7', key: '1m0v6g' }],
    [
      'path',
      {
        d: 'M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z',
        key: 'ohrbg2',
      },
    ],
  ],
  SY = lt('square-pen', r9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const i9 = [['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }]],
  _Y = lt('square', i9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const s9 = [
    [
      'path',
      {
        d: 'M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z',
        key: 'r04s7s',
      },
    ],
  ],
  kY = lt('star', s9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const o9 = [
    ['circle', { cx: '12', cy: '12', r: '4', key: '4exip2' }],
    ['path', { d: 'M12 2v2', key: 'tus03m' }],
    ['path', { d: 'M12 20v2', key: '1lh1kg' }],
    ['path', { d: 'm4.93 4.93 1.41 1.41', key: '149t6j' }],
    ['path', { d: 'm17.66 17.66 1.41 1.41', key: 'ptbguv' }],
    ['path', { d: 'M2 12h2', key: '1t8f8n' }],
    ['path', { d: 'M20 12h2', key: '1q8mjw' }],
    ['path', { d: 'm6.34 17.66-1.41 1.41', key: '1m8zz5' }],
    ['path', { d: 'm19.07 4.93-1.41 1.41', key: '1shlcs' }],
  ],
  CY = lt('sun', o9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const a9 = [
    ['path', { d: 'M12 3v18', key: '108xh3' }],
    ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }],
    ['path', { d: 'M3 9h18', key: '1pudct' }],
    ['path', { d: 'M3 15h18', key: '5xshup' }],
  ],
  MY = lt('table', a9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const l9 = [
    [
      'path',
      {
        d: 'M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z',
        key: 'vktsd0',
      },
    ],
    ['circle', { cx: '7.5', cy: '7.5', r: '.5', fill: 'currentColor', key: 'kqv944' }],
  ],
  EY = lt('tag', l9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const c9 = [
    [
      'path',
      {
        d: 'M13.172 2a2 2 0 0 1 1.414.586l6.71 6.71a2.4 2.4 0 0 1 0 3.408l-4.592 4.592a2.4 2.4 0 0 1-3.408 0l-6.71-6.71A2 2 0 0 1 6 9.172V3a1 1 0 0 1 1-1z',
        key: '16rjxf',
      },
    ],
    [
      'path',
      { d: 'M2 7v6.172a2 2 0 0 0 .586 1.414l6.71 6.71a2.4 2.4 0 0 0 3.191.193', key: '178nd4' },
    ],
    ['circle', { cx: '10.5', cy: '6.5', r: '.5', fill: 'currentColor', key: '12ikhr' }],
  ],
  TY = lt('tags', c9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const u9 = [
    ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],
    ['circle', { cx: '12', cy: '12', r: '6', key: '1vlfrh' }],
    ['circle', { cx: '12', cy: '12', r: '2', key: '1c9p78' }],
  ],
  AY = lt('target', u9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const f9 = [
    ['path', { d: 'M17 14V2', key: '8ymqnk' }],
    [
      'path',
      {
        d: 'M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z',
        key: 'm61m77',
      },
    ],
  ],
  RY = lt('thumbs-down', f9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const d9 = [
    ['path', { d: 'M7 10v12', key: '1qc93n' }],
    [
      'path',
      {
        d: 'M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z',
        key: 'emmmcr',
      },
    ],
  ],
  OY = lt('thumbs-up', d9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const h9 = [
    [
      'path',
      {
        d: 'M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z',
        key: 'qn84l0',
      },
    ],
    ['path', { d: 'M13 5v2', key: 'dyzc3o' }],
    ['path', { d: 'M13 17v2', key: '1ont0d' }],
    ['path', { d: 'M13 11v2', key: '1wjjxi' }],
  ],
  PY = lt('ticket', h9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const p9 = [
    ['circle', { cx: '9', cy: '12', r: '3', key: 'u3jwor' }],
    ['rect', { width: '20', height: '14', x: '2', y: '5', rx: '7', key: 'g7kal2' }],
  ],
  NY = lt('toggle-left', p9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const m9 = [
    ['circle', { cx: '15', cy: '12', r: '3', key: '1afu0r' }],
    ['rect', { width: '20', height: '14', x: '2', y: '5', rx: '7', key: 'g7kal2' }],
  ],
  IY = lt('toggle-right', m9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const g9 = [
    ['path', { d: 'M10 11v6', key: 'nco0om' }],
    ['path', { d: 'M14 11v6', key: 'outv1u' }],
    ['path', { d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6', key: 'miytrc' }],
    ['path', { d: 'M3 6h18', key: 'd0wm0j' }],
    ['path', { d: 'M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2', key: 'e791ji' }],
  ],
  DY = lt('trash-2', g9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const y9 = [
    ['path', { d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6', key: 'miytrc' }],
    ['path', { d: 'M3 6h18', key: 'd0wm0j' }],
    ['path', { d: 'M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2', key: 'e791ji' }],
  ],
  jY = lt('trash', y9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const b9 = [
    ['path', { d: 'M16 17h6v-6', key: 't6n2it' }],
    ['path', { d: 'm22 17-8.5-8.5-5 5L2 7', key: 'x473p' }],
  ],
  LY = lt('trending-down', b9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const v9 = [
    ['path', { d: 'M16 7h6v6', key: 'box55l' }],
    ['path', { d: 'm22 7-8.5 8.5-5-5L2 17', key: '1t1m79' }],
  ],
  FY = lt('trending-up', v9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const w9 = [
    [
      'path',
      {
        d: 'm21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3',
        key: 'wmoenq',
      },
    ],
    ['path', { d: 'M12 9v4', key: 'juzpu7' }],
    ['path', { d: 'M12 17h.01', key: 'p32p05' }],
  ],
  BY = lt('triangle-alert', w9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const x9 = [
    [
      'path',
      {
        d: 'm18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71',
        key: 'yqzxt4',
      },
    ],
    [
      'path',
      {
        d: 'm5.17 11.75-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71',
        key: '4qinb0',
      },
    ],
    ['line', { x1: '8', x2: '8', y1: '2', y2: '5', key: '1041cp' }],
    ['line', { x1: '2', x2: '5', y1: '8', y2: '8', key: '14m1p5' }],
    ['line', { x1: '16', x2: '16', y1: '19', y2: '22', key: 'rzdirn' }],
    ['line', { x1: '19', x2: '22', y1: '16', y2: '16', key: 'ox905f' }],
  ],
  zY = lt('unlink', x9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const S9 = [
    ['path', { d: 'M12 3v12', key: '1x0j5s' }],
    ['path', { d: 'm17 8-5-5-5 5', key: '7q97r8' }],
    ['path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4', key: 'ih7n3h' }],
  ],
  $Y = lt('upload', S9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const _9 = [
    ['path', { d: 'm16 11 2 2 4-4', key: '9rsbq5' }],
    ['path', { d: 'M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2', key: '1yyitq' }],
    ['circle', { cx: '9', cy: '7', r: '4', key: 'nufk8' }],
  ],
  VY = lt('user-check', _9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const k9 = [
    ['path', { d: 'M10 15H6a4 4 0 0 0-4 4v2', key: '1nfge6' }],
    ['path', { d: 'm14.305 16.53.923-.382', key: '1itpsq' }],
    ['path', { d: 'm15.228 13.852-.923-.383', key: 'eplpkm' }],
    ['path', { d: 'm16.852 12.228-.383-.923', key: '13v3q0' }],
    ['path', { d: 'm16.852 17.772-.383.924', key: '1i8mnm' }],
    ['path', { d: 'm19.148 12.228.383-.923', key: '1q8j1v' }],
    ['path', { d: 'm19.53 18.696-.382-.924', key: 'vk1qj3' }],
    ['path', { d: 'm20.772 13.852.924-.383', key: 'n880s0' }],
    ['path', { d: 'm20.772 16.148.924.383', key: '1g6xey' }],
    ['circle', { cx: '18', cy: '15', r: '3', key: 'gjjjvw' }],
    ['circle', { cx: '9', cy: '7', r: '4', key: 'nufk8' }],
  ],
  HY = lt('user-cog', k9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const C9 = [
    ['path', { d: 'M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2', key: '1yyitq' }],
    ['circle', { cx: '9', cy: '7', r: '4', key: 'nufk8' }],
    ['line', { x1: '19', x2: '19', y1: '8', y2: '14', key: '1bvyxn' }],
    ['line', { x1: '22', x2: '16', y1: '11', y2: '11', key: '1shjgl' }],
  ],
  UY = lt('user-plus', C9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const M9 = [
    ['path', { d: 'M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2', key: '975kel' }],
    ['circle', { cx: '12', cy: '7', r: '4', key: '17ys0d' }],
  ],
  qY = lt('user', M9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const E9 = [
    ['path', { d: 'M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2', key: '1yyitq' }],
    ['path', { d: 'M16 3.128a4 4 0 0 1 0 7.744', key: '16gr8j' }],
    ['path', { d: 'M22 21v-2a4 4 0 0 0-3-3.87', key: 'kshegd' }],
    ['circle', { cx: '9', cy: '7', r: '4', key: 'nufk8' }],
  ],
  WY = lt('users', E9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const T9 = [
    ['path', { d: 'M18 21a8 8 0 0 0-16 0', key: '3ypg7q' }],
    ['circle', { cx: '10', cy: '8', r: '5', key: 'o932ke' }],
    ['path', { d: 'M22 20c0-3.37-2-6.5-4-8a5 5 0 0 0-.45-8.3', key: '10s06x' }],
  ],
  KY = lt('users-round', T9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const A9 = [
    [
      'path',
      {
        d: 'm16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5',
        key: 'ftymec',
      },
    ],
    ['rect', { x: '2', y: '6', width: '14', height: '12', rx: '2', key: '158x01' }],
  ],
  GY = lt('video', A9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const R9 = [
    ['path', { d: 'M12 20h.01', key: 'zekei9' }],
    ['path', { d: 'M8.5 16.429a5 5 0 0 1 7 0', key: '1bycff' }],
    ['path', { d: 'M5 12.859a10 10 0 0 1 5.17-2.69', key: '1dl1wf' }],
    ['path', { d: 'M19 12.859a10 10 0 0 0-2.007-1.523', key: '4k23kn' }],
    ['path', { d: 'M2 8.82a15 15 0 0 1 4.177-2.643', key: '1grhjp' }],
    ['path', { d: 'M22 8.82a15 15 0 0 0-11.288-3.764', key: 'z3jwby' }],
    ['path', { d: 'm2 2 20 20', key: '1ooewy' }],
  ],
  XY = lt('wifi-off', R9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const O9 = [
    ['path', { d: 'M12 20h.01', key: 'zekei9' }],
    ['path', { d: 'M2 8.82a15 15 0 0 1 20 0', key: 'dnpr2z' }],
    ['path', { d: 'M5 12.859a10 10 0 0 1 14 0', key: '1x1e6c' }],
    ['path', { d: 'M8.5 16.429a5 5 0 0 1 7 0', key: '1bycff' }],
  ],
  YY = lt('wifi', O9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const P9 = [
    [
      'path',
      {
        d: 'M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.106-3.105c.32-.322.863-.22.983.218a6 6 0 0 1-8.259 7.057l-7.91 7.91a1 1 0 0 1-2.999-3l7.91-7.91a6 6 0 0 1 7.057-8.259c.438.12.54.662.219.984z',
        key: '1ngwbx',
      },
    ],
  ],
  ZY = lt('wrench', P9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const N9 = [
    ['path', { d: 'M18 6 6 18', key: '1bl5f8' }],
    ['path', { d: 'm6 6 12 12', key: 'd8bk6v' }],
  ],
  JY = lt('x', N9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const I9 = [
    [
      'path',
      {
        d: 'M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z',
        key: '1xq2db',
      },
    ],
  ],
  QY = lt('zap', I9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const D9 = [
    ['circle', { cx: '11', cy: '11', r: '8', key: '4ej97u' }],
    ['line', { x1: '21', x2: '16.65', y1: '21', y2: '16.65', key: '13gj7c' }],
    ['line', { x1: '11', x2: '11', y1: '8', y2: '14', key: '1vmskp' }],
    ['line', { x1: '8', x2: '14', y1: '11', y2: '11', key: 'durymu' }],
  ],
  tZ = lt('zoom-in', D9)
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const j9 = [
    ['circle', { cx: '11', cy: '11', r: '8', key: '4ej97u' }],
    ['line', { x1: '21', x2: '16.65', y1: '21', y2: '16.65', key: '13gj7c' }],
    ['line', { x1: '8', x2: '14', y1: '11', y2: '11', key: 'durymu' }],
  ],
  eZ = lt('zoom-out', j9)
function yw(e) {
  var n,
    t,
    r = ''
  if (typeof e == 'string' || typeof e == 'number') r += e
  else if (typeof e == 'object')
    if (Array.isArray(e)) {
      var i = e.length
      for (n = 0; n < i; n++) e[n] && (t = yw(e[n])) && (r && (r += ' '), (r += t))
    } else for (t in e) e[t] && (r && (r += ' '), (r += t))
  return r
}
function L9() {
  for (var e, n, t = 0, r = '', i = arguments.length; t < i; t++)
    (e = arguments[t]) && (n = yw(e)) && (r && (r += ' '), (r += n))
  return r
}
const y1 = (e) => (typeof e == 'boolean' ? `${e}` : e === 0 ? '0' : e),
  b1 = L9,
  nZ = (e, n) => (t) => {
    var r
    if (n?.variants == null) return b1(e, t?.class, t?.className)
    const { variants: i, defaultVariants: s } = n,
      o = Object.keys(i).map((c) => {
        const u = t?.[c],
          f = s?.[c]
        if (u === null) return null
        const d = y1(u) || y1(f)
        return i[c][d]
      }),
      a =
        t &&
        Object.entries(t).reduce((c, u) => {
          let [f, d] = u
          return (d === void 0 || (c[f] = d), c)
        }, {}),
      l =
        n == null || (r = n.compoundVariants) === null || r === void 0
          ? void 0
          : r.reduce((c, u) => {
              let { class: f, className: d, ...h } = u
              return Object.entries(h).every((p) => {
                let [g, m] = p
                return Array.isArray(m) ? m.includes({ ...s, ...a }[g]) : { ...s, ...a }[g] === m
              })
                ? [...c, f, d]
                : c
            }, [])
    return b1(e, o, l, t?.class, t?.className)
  },
  Im = '-',
  F9 = (e) => {
    const n = z9(e),
      { conflictingClassGroups: t, conflictingClassGroupModifiers: r } = e
    return {
      getClassGroupId: (o) => {
        const a = o.split(Im)
        return (a[0] === '' && a.length !== 1 && a.shift(), bw(a, n) || B9(o))
      },
      getConflictingClassGroupIds: (o, a) => {
        const l = t[o] || []
        return a && r[o] ? [...l, ...r[o]] : l
      },
    }
  },
  bw = (e, n) => {
    if (e.length === 0) return n.classGroupId
    const t = e[0],
      r = n.nextPart.get(t),
      i = r ? bw(e.slice(1), r) : void 0
    if (i) return i
    if (n.validators.length === 0) return
    const s = e.join(Im)
    return n.validators.find(({ validator: o }) => o(s))?.classGroupId
  },
  v1 = /^\[(.+)\]$/,
  B9 = (e) => {
    if (v1.test(e)) {
      const n = v1.exec(e)[1],
        t = n?.substring(0, n.indexOf(':'))
      if (t) return 'arbitrary..' + t
    }
  },
  z9 = (e) => {
    const { theme: n, prefix: t } = e,
      r = { nextPart: new Map(), validators: [] }
    return (
      V9(Object.entries(e.classGroups), t).forEach(([s, o]) => {
        Kh(o, r, s, n)
      }),
      r
    )
  },
  Kh = (e, n, t, r) => {
    e.forEach((i) => {
      if (typeof i == 'string') {
        const s = i === '' ? n : w1(n, i)
        s.classGroupId = t
        return
      }
      if (typeof i == 'function') {
        if ($9(i)) {
          Kh(i(r), n, t, r)
          return
        }
        n.validators.push({ validator: i, classGroupId: t })
        return
      }
      Object.entries(i).forEach(([s, o]) => {
        Kh(o, w1(n, s), t, r)
      })
    })
  },
  w1 = (e, n) => {
    let t = e
    return (
      n.split(Im).forEach((r) => {
        ;(t.nextPart.has(r) || t.nextPart.set(r, { nextPart: new Map(), validators: [] }),
          (t = t.nextPart.get(r)))
      }),
      t
    )
  },
  $9 = (e) => e.isThemeGetter,
  V9 = (e, n) =>
    n
      ? e.map(([t, r]) => {
          const i = r.map((s) =>
            typeof s == 'string'
              ? n + s
              : typeof s == 'object'
                ? Object.fromEntries(Object.entries(s).map(([o, a]) => [n + o, a]))
                : s,
          )
          return [t, i]
        })
      : e,
  H9 = (e) => {
    if (e < 1) return { get: () => {}, set: () => {} }
    let n = 0,
      t = new Map(),
      r = new Map()
    const i = (s, o) => {
      ;(t.set(s, o), n++, n > e && ((n = 0), (r = t), (t = new Map())))
    }
    return {
      get(s) {
        let o = t.get(s)
        if (o !== void 0) return o
        if ((o = r.get(s)) !== void 0) return (i(s, o), o)
      },
      set(s, o) {
        t.has(s) ? t.set(s, o) : i(s, o)
      },
    }
  },
  vw = '!',
  U9 = (e) => {
    const { separator: n, experimentalParseClassName: t } = e,
      r = n.length === 1,
      i = n[0],
      s = n.length,
      o = (a) => {
        const l = []
        let c = 0,
          u = 0,
          f
        for (let m = 0; m < a.length; m++) {
          let y = a[m]
          if (c === 0) {
            if (y === i && (r || a.slice(m, m + s) === n)) {
              ;(l.push(a.slice(u, m)), (u = m + s))
              continue
            }
            if (y === '/') {
              f = m
              continue
            }
          }
          y === '[' ? c++ : y === ']' && c--
        }
        const d = l.length === 0 ? a : a.substring(u),
          h = d.startsWith(vw),
          p = h ? d.substring(1) : d,
          g = f && f > u ? f - u : void 0
        return {
          modifiers: l,
          hasImportantModifier: h,
          baseClassName: p,
          maybePostfixModifierPosition: g,
        }
      }
    return t ? (a) => t({ className: a, parseClassName: o }) : o
  },
  q9 = (e) => {
    if (e.length <= 1) return e
    const n = []
    let t = []
    return (
      e.forEach((r) => {
        r[0] === '[' ? (n.push(...t.sort(), r), (t = [])) : t.push(r)
      }),
      n.push(...t.sort()),
      n
    )
  },
  W9 = (e) => ({ cache: H9(e.cacheSize), parseClassName: U9(e), ...F9(e) }),
  K9 = /\s+/,
  G9 = (e, n) => {
    const { parseClassName: t, getClassGroupId: r, getConflictingClassGroupIds: i } = n,
      s = [],
      o = e.trim().split(K9)
    let a = ''
    for (let l = o.length - 1; l >= 0; l -= 1) {
      const c = o[l],
        {
          modifiers: u,
          hasImportantModifier: f,
          baseClassName: d,
          maybePostfixModifierPosition: h,
        } = t(c)
      let p = !!h,
        g = r(p ? d.substring(0, h) : d)
      if (!g) {
        if (!p) {
          a = c + (a.length > 0 ? ' ' + a : a)
          continue
        }
        if (((g = r(d)), !g)) {
          a = c + (a.length > 0 ? ' ' + a : a)
          continue
        }
        p = !1
      }
      const m = q9(u).join(':'),
        y = f ? m + vw : m,
        b = y + g
      if (s.includes(b)) continue
      s.push(b)
      const w = i(g, p)
      for (let C = 0; C < w.length; ++C) {
        const T = w[C]
        s.push(y + T)
      }
      a = c + (a.length > 0 ? ' ' + a : a)
    }
    return a
  }
function X9() {
  let e = 0,
    n,
    t,
    r = ''
  for (; e < arguments.length; ) (n = arguments[e++]) && (t = ww(n)) && (r && (r += ' '), (r += t))
  return r
}
const ww = (e) => {
  if (typeof e == 'string') return e
  let n,
    t = ''
  for (let r = 0; r < e.length; r++) e[r] && (n = ww(e[r])) && (t && (t += ' '), (t += n))
  return t
}
function Y9(e, ...n) {
  let t,
    r,
    i,
    s = o
  function o(l) {
    const c = n.reduce((u, f) => f(u), e())
    return ((t = W9(c)), (r = t.cache.get), (i = t.cache.set), (s = a), a(l))
  }
  function a(l) {
    const c = r(l)
    if (c) return c
    const u = G9(l, t)
    return (i(l, u), u)
  }
  return function () {
    return s(X9.apply(null, arguments))
  }
}
const Ie = (e) => {
    const n = (t) => t[e] || []
    return ((n.isThemeGetter = !0), n)
  },
  xw = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  Z9 = /^\d+\/\d+$/,
  J9 = new Set(['px', 'full', 'screen']),
  Q9 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  tE =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  eE = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
  nE = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  rE =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  Vr = (e) => vo(e) || J9.has(e) || Z9.test(e),
  fi = (e) => Wo(e, 'length', fE),
  vo = (e) => !!e && !Number.isNaN(Number(e)),
  md = (e) => Wo(e, 'number', vo),
  oa = (e) => !!e && Number.isInteger(Number(e)),
  iE = (e) => e.endsWith('%') && vo(e.slice(0, -1)),
  pe = (e) => xw.test(e),
  di = (e) => Q9.test(e),
  sE = new Set(['length', 'size', 'percentage']),
  oE = (e) => Wo(e, sE, Sw),
  aE = (e) => Wo(e, 'position', Sw),
  lE = new Set(['image', 'url']),
  cE = (e) => Wo(e, lE, hE),
  uE = (e) => Wo(e, '', dE),
  aa = () => !0,
  Wo = (e, n, t) => {
    const r = xw.exec(e)
    return r ? (r[1] ? (typeof n == 'string' ? r[1] === n : n.has(r[1])) : t(r[2])) : !1
  },
  fE = (e) => tE.test(e) && !eE.test(e),
  Sw = () => !1,
  dE = (e) => nE.test(e),
  hE = (e) => rE.test(e),
  pE = () => {
    const e = Ie('colors'),
      n = Ie('spacing'),
      t = Ie('blur'),
      r = Ie('brightness'),
      i = Ie('borderColor'),
      s = Ie('borderRadius'),
      o = Ie('borderSpacing'),
      a = Ie('borderWidth'),
      l = Ie('contrast'),
      c = Ie('grayscale'),
      u = Ie('hueRotate'),
      f = Ie('invert'),
      d = Ie('gap'),
      h = Ie('gradientColorStops'),
      p = Ie('gradientColorStopPositions'),
      g = Ie('inset'),
      m = Ie('margin'),
      y = Ie('opacity'),
      b = Ie('padding'),
      w = Ie('saturate'),
      C = Ie('scale'),
      T = Ie('sepia'),
      I = Ie('skew'),
      B = Ie('space'),
      E = Ie('translate'),
      O = () => ['auto', 'contain', 'none'],
      P = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'],
      $ = () => ['auto', pe, n],
      F = () => [pe, n],
      M = () => ['', Vr, fi],
      R = () => ['auto', vo, pe],
      k = () => [
        'bottom',
        'center',
        'left',
        'left-bottom',
        'left-top',
        'right',
        'right-bottom',
        'right-top',
        'top',
      ],
      v = () => ['solid', 'dashed', 'dotted', 'double', 'none'],
      x = () => [
        'normal',
        'multiply',
        'screen',
        'overlay',
        'darken',
        'lighten',
        'color-dodge',
        'color-burn',
        'hard-light',
        'soft-light',
        'difference',
        'exclusion',
        'hue',
        'saturation',
        'color',
        'luminosity',
      ],
      _ = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'],
      S = () => ['', '0', pe],
      A = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'],
      j = () => [vo, pe]
    return {
      cacheSize: 500,
      separator: ':',
      theme: {
        colors: [aa],
        spacing: [Vr, fi],
        blur: ['none', '', di, pe],
        brightness: j(),
        borderColor: [e],
        borderRadius: ['none', '', 'full', di, pe],
        borderSpacing: F(),
        borderWidth: M(),
        contrast: j(),
        grayscale: S(),
        hueRotate: j(),
        invert: S(),
        gap: F(),
        gradientColorStops: [e],
        gradientColorStopPositions: [iE, fi],
        inset: $(),
        margin: $(),
        opacity: j(),
        padding: F(),
        saturate: j(),
        scale: j(),
        sepia: S(),
        skew: j(),
        space: F(),
        translate: F(),
      },
      classGroups: {
        aspect: [{ aspect: ['auto', 'square', 'video', pe] }],
        container: ['container'],
        columns: [{ columns: [di] }],
        'break-after': [{ 'break-after': A() }],
        'break-before': [{ 'break-before': A() }],
        'break-inside': [{ 'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column'] }],
        'box-decoration': [{ 'box-decoration': ['slice', 'clone'] }],
        box: [{ box: ['border', 'content'] }],
        display: [
          'block',
          'inline-block',
          'inline',
          'flex',
          'inline-flex',
          'table',
          'inline-table',
          'table-caption',
          'table-cell',
          'table-column',
          'table-column-group',
          'table-footer-group',
          'table-header-group',
          'table-row-group',
          'table-row',
          'flow-root',
          'grid',
          'inline-grid',
          'contents',
          'list-item',
          'hidden',
        ],
        float: [{ float: ['right', 'left', 'none', 'start', 'end'] }],
        clear: [{ clear: ['left', 'right', 'both', 'none', 'start', 'end'] }],
        isolation: ['isolate', 'isolation-auto'],
        'object-fit': [{ object: ['contain', 'cover', 'fill', 'none', 'scale-down'] }],
        'object-position': [{ object: [...k(), pe] }],
        overflow: [{ overflow: P() }],
        'overflow-x': [{ 'overflow-x': P() }],
        'overflow-y': [{ 'overflow-y': P() }],
        overscroll: [{ overscroll: O() }],
        'overscroll-x': [{ 'overscroll-x': O() }],
        'overscroll-y': [{ 'overscroll-y': O() }],
        position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],
        inset: [{ inset: [g] }],
        'inset-x': [{ 'inset-x': [g] }],
        'inset-y': [{ 'inset-y': [g] }],
        start: [{ start: [g] }],
        end: [{ end: [g] }],
        top: [{ top: [g] }],
        right: [{ right: [g] }],
        bottom: [{ bottom: [g] }],
        left: [{ left: [g] }],
        visibility: ['visible', 'invisible', 'collapse'],
        z: [{ z: ['auto', oa, pe] }],
        basis: [{ basis: $() }],
        'flex-direction': [{ flex: ['row', 'row-reverse', 'col', 'col-reverse'] }],
        'flex-wrap': [{ flex: ['wrap', 'wrap-reverse', 'nowrap'] }],
        flex: [{ flex: ['1', 'auto', 'initial', 'none', pe] }],
        grow: [{ grow: S() }],
        shrink: [{ shrink: S() }],
        order: [{ order: ['first', 'last', 'none', oa, pe] }],
        'grid-cols': [{ 'grid-cols': [aa] }],
        'col-start-end': [{ col: ['auto', { span: ['full', oa, pe] }, pe] }],
        'col-start': [{ 'col-start': R() }],
        'col-end': [{ 'col-end': R() }],
        'grid-rows': [{ 'grid-rows': [aa] }],
        'row-start-end': [{ row: ['auto', { span: [oa, pe] }, pe] }],
        'row-start': [{ 'row-start': R() }],
        'row-end': [{ 'row-end': R() }],
        'grid-flow': [{ 'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense'] }],
        'auto-cols': [{ 'auto-cols': ['auto', 'min', 'max', 'fr', pe] }],
        'auto-rows': [{ 'auto-rows': ['auto', 'min', 'max', 'fr', pe] }],
        gap: [{ gap: [d] }],
        'gap-x': [{ 'gap-x': [d] }],
        'gap-y': [{ 'gap-y': [d] }],
        'justify-content': [{ justify: ['normal', ..._()] }],
        'justify-items': [{ 'justify-items': ['start', 'end', 'center', 'stretch'] }],
        'justify-self': [{ 'justify-self': ['auto', 'start', 'end', 'center', 'stretch'] }],
        'align-content': [{ content: ['normal', ..._(), 'baseline'] }],
        'align-items': [{ items: ['start', 'end', 'center', 'baseline', 'stretch'] }],
        'align-self': [{ self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline'] }],
        'place-content': [{ 'place-content': [..._(), 'baseline'] }],
        'place-items': [{ 'place-items': ['start', 'end', 'center', 'baseline', 'stretch'] }],
        'place-self': [{ 'place-self': ['auto', 'start', 'end', 'center', 'stretch'] }],
        p: [{ p: [b] }],
        px: [{ px: [b] }],
        py: [{ py: [b] }],
        ps: [{ ps: [b] }],
        pe: [{ pe: [b] }],
        pt: [{ pt: [b] }],
        pr: [{ pr: [b] }],
        pb: [{ pb: [b] }],
        pl: [{ pl: [b] }],
        m: [{ m: [m] }],
        mx: [{ mx: [m] }],
        my: [{ my: [m] }],
        ms: [{ ms: [m] }],
        me: [{ me: [m] }],
        mt: [{ mt: [m] }],
        mr: [{ mr: [m] }],
        mb: [{ mb: [m] }],
        ml: [{ ml: [m] }],
        'space-x': [{ 'space-x': [B] }],
        'space-x-reverse': ['space-x-reverse'],
        'space-y': [{ 'space-y': [B] }],
        'space-y-reverse': ['space-y-reverse'],
        w: [{ w: ['auto', 'min', 'max', 'fit', 'svw', 'lvw', 'dvw', pe, n] }],
        'min-w': [{ 'min-w': [pe, n, 'min', 'max', 'fit'] }],
        'max-w': [
          { 'max-w': [pe, n, 'none', 'full', 'min', 'max', 'fit', 'prose', { screen: [di] }, di] },
        ],
        h: [{ h: [pe, n, 'auto', 'min', 'max', 'fit', 'svh', 'lvh', 'dvh'] }],
        'min-h': [{ 'min-h': [pe, n, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh'] }],
        'max-h': [{ 'max-h': [pe, n, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh'] }],
        size: [{ size: [pe, n, 'auto', 'min', 'max', 'fit'] }],
        'font-size': [{ text: ['base', di, fi] }],
        'font-smoothing': ['antialiased', 'subpixel-antialiased'],
        'font-style': ['italic', 'not-italic'],
        'font-weight': [
          {
            font: [
              'thin',
              'extralight',
              'light',
              'normal',
              'medium',
              'semibold',
              'bold',
              'extrabold',
              'black',
              md,
            ],
          },
        ],
        'font-family': [{ font: [aa] }],
        'fvn-normal': ['normal-nums'],
        'fvn-ordinal': ['ordinal'],
        'fvn-slashed-zero': ['slashed-zero'],
        'fvn-figure': ['lining-nums', 'oldstyle-nums'],
        'fvn-spacing': ['proportional-nums', 'tabular-nums'],
        'fvn-fraction': ['diagonal-fractions', 'stacked-fractions'],
        tracking: [{ tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', pe] }],
        'line-clamp': [{ 'line-clamp': ['none', vo, md] }],
        leading: [{ leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', Vr, pe] }],
        'list-image': [{ 'list-image': ['none', pe] }],
        'list-style-type': [{ list: ['none', 'disc', 'decimal', pe] }],
        'list-style-position': [{ list: ['inside', 'outside'] }],
        'placeholder-color': [{ placeholder: [e] }],
        'placeholder-opacity': [{ 'placeholder-opacity': [y] }],
        'text-alignment': [{ text: ['left', 'center', 'right', 'justify', 'start', 'end'] }],
        'text-color': [{ text: [e] }],
        'text-opacity': [{ 'text-opacity': [y] }],
        'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],
        'text-decoration-style': [{ decoration: [...v(), 'wavy'] }],
        'text-decoration-thickness': [{ decoration: ['auto', 'from-font', Vr, fi] }],
        'underline-offset': [{ 'underline-offset': ['auto', Vr, pe] }],
        'text-decoration-color': [{ decoration: [e] }],
        'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],
        'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],
        'text-wrap': [{ text: ['wrap', 'nowrap', 'balance', 'pretty'] }],
        indent: [{ indent: F() }],
        'vertical-align': [
          {
            align: [
              'baseline',
              'top',
              'middle',
              'bottom',
              'text-top',
              'text-bottom',
              'sub',
              'super',
              pe,
            ],
          },
        ],
        whitespace: [
          { whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces'] },
        ],
        break: [{ break: ['normal', 'words', 'all', 'keep'] }],
        hyphens: [{ hyphens: ['none', 'manual', 'auto'] }],
        content: [{ content: ['none', pe] }],
        'bg-attachment': [{ bg: ['fixed', 'local', 'scroll'] }],
        'bg-clip': [{ 'bg-clip': ['border', 'padding', 'content', 'text'] }],
        'bg-opacity': [{ 'bg-opacity': [y] }],
        'bg-origin': [{ 'bg-origin': ['border', 'padding', 'content'] }],
        'bg-position': [{ bg: [...k(), aE] }],
        'bg-repeat': [{ bg: ['no-repeat', { repeat: ['', 'x', 'y', 'round', 'space'] }] }],
        'bg-size': [{ bg: ['auto', 'cover', 'contain', oE] }],
        'bg-image': [
          { bg: ['none', { 'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'] }, cE] },
        ],
        'bg-color': [{ bg: [e] }],
        'gradient-from-pos': [{ from: [p] }],
        'gradient-via-pos': [{ via: [p] }],
        'gradient-to-pos': [{ to: [p] }],
        'gradient-from': [{ from: [h] }],
        'gradient-via': [{ via: [h] }],
        'gradient-to': [{ to: [h] }],
        rounded: [{ rounded: [s] }],
        'rounded-s': [{ 'rounded-s': [s] }],
        'rounded-e': [{ 'rounded-e': [s] }],
        'rounded-t': [{ 'rounded-t': [s] }],
        'rounded-r': [{ 'rounded-r': [s] }],
        'rounded-b': [{ 'rounded-b': [s] }],
        'rounded-l': [{ 'rounded-l': [s] }],
        'rounded-ss': [{ 'rounded-ss': [s] }],
        'rounded-se': [{ 'rounded-se': [s] }],
        'rounded-ee': [{ 'rounded-ee': [s] }],
        'rounded-es': [{ 'rounded-es': [s] }],
        'rounded-tl': [{ 'rounded-tl': [s] }],
        'rounded-tr': [{ 'rounded-tr': [s] }],
        'rounded-br': [{ 'rounded-br': [s] }],
        'rounded-bl': [{ 'rounded-bl': [s] }],
        'border-w': [{ border: [a] }],
        'border-w-x': [{ 'border-x': [a] }],
        'border-w-y': [{ 'border-y': [a] }],
        'border-w-s': [{ 'border-s': [a] }],
        'border-w-e': [{ 'border-e': [a] }],
        'border-w-t': [{ 'border-t': [a] }],
        'border-w-r': [{ 'border-r': [a] }],
        'border-w-b': [{ 'border-b': [a] }],
        'border-w-l': [{ 'border-l': [a] }],
        'border-opacity': [{ 'border-opacity': [y] }],
        'border-style': [{ border: [...v(), 'hidden'] }],
        'divide-x': [{ 'divide-x': [a] }],
        'divide-x-reverse': ['divide-x-reverse'],
        'divide-y': [{ 'divide-y': [a] }],
        'divide-y-reverse': ['divide-y-reverse'],
        'divide-opacity': [{ 'divide-opacity': [y] }],
        'divide-style': [{ divide: v() }],
        'border-color': [{ border: [i] }],
        'border-color-x': [{ 'border-x': [i] }],
        'border-color-y': [{ 'border-y': [i] }],
        'border-color-s': [{ 'border-s': [i] }],
        'border-color-e': [{ 'border-e': [i] }],
        'border-color-t': [{ 'border-t': [i] }],
        'border-color-r': [{ 'border-r': [i] }],
        'border-color-b': [{ 'border-b': [i] }],
        'border-color-l': [{ 'border-l': [i] }],
        'divide-color': [{ divide: [i] }],
        'outline-style': [{ outline: ['', ...v()] }],
        'outline-offset': [{ 'outline-offset': [Vr, pe] }],
        'outline-w': [{ outline: [Vr, fi] }],
        'outline-color': [{ outline: [e] }],
        'ring-w': [{ ring: M() }],
        'ring-w-inset': ['ring-inset'],
        'ring-color': [{ ring: [e] }],
        'ring-opacity': [{ 'ring-opacity': [y] }],
        'ring-offset-w': [{ 'ring-offset': [Vr, fi] }],
        'ring-offset-color': [{ 'ring-offset': [e] }],
        shadow: [{ shadow: ['', 'inner', 'none', di, uE] }],
        'shadow-color': [{ shadow: [aa] }],
        opacity: [{ opacity: [y] }],
        'mix-blend': [{ 'mix-blend': [...x(), 'plus-lighter', 'plus-darker'] }],
        'bg-blend': [{ 'bg-blend': x() }],
        filter: [{ filter: ['', 'none'] }],
        blur: [{ blur: [t] }],
        brightness: [{ brightness: [r] }],
        contrast: [{ contrast: [l] }],
        'drop-shadow': [{ 'drop-shadow': ['', 'none', di, pe] }],
        grayscale: [{ grayscale: [c] }],
        'hue-rotate': [{ 'hue-rotate': [u] }],
        invert: [{ invert: [f] }],
        saturate: [{ saturate: [w] }],
        sepia: [{ sepia: [T] }],
        'backdrop-filter': [{ 'backdrop-filter': ['', 'none'] }],
        'backdrop-blur': [{ 'backdrop-blur': [t] }],
        'backdrop-brightness': [{ 'backdrop-brightness': [r] }],
        'backdrop-contrast': [{ 'backdrop-contrast': [l] }],
        'backdrop-grayscale': [{ 'backdrop-grayscale': [c] }],
        'backdrop-hue-rotate': [{ 'backdrop-hue-rotate': [u] }],
        'backdrop-invert': [{ 'backdrop-invert': [f] }],
        'backdrop-opacity': [{ 'backdrop-opacity': [y] }],
        'backdrop-saturate': [{ 'backdrop-saturate': [w] }],
        'backdrop-sepia': [{ 'backdrop-sepia': [T] }],
        'border-collapse': [{ border: ['collapse', 'separate'] }],
        'border-spacing': [{ 'border-spacing': [o] }],
        'border-spacing-x': [{ 'border-spacing-x': [o] }],
        'border-spacing-y': [{ 'border-spacing-y': [o] }],
        'table-layout': [{ table: ['auto', 'fixed'] }],
        caption: [{ caption: ['top', 'bottom'] }],
        transition: [
          { transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', pe] },
        ],
        duration: [{ duration: j() }],
        ease: [{ ease: ['linear', 'in', 'out', 'in-out', pe] }],
        delay: [{ delay: j() }],
        animate: [{ animate: ['none', 'spin', 'ping', 'pulse', 'bounce', pe] }],
        transform: [{ transform: ['', 'gpu', 'none'] }],
        scale: [{ scale: [C] }],
        'scale-x': [{ 'scale-x': [C] }],
        'scale-y': [{ 'scale-y': [C] }],
        rotate: [{ rotate: [oa, pe] }],
        'translate-x': [{ 'translate-x': [E] }],
        'translate-y': [{ 'translate-y': [E] }],
        'skew-x': [{ 'skew-x': [I] }],
        'skew-y': [{ 'skew-y': [I] }],
        'transform-origin': [
          {
            origin: [
              'center',
              'top',
              'top-right',
              'right',
              'bottom-right',
              'bottom',
              'bottom-left',
              'left',
              'top-left',
              pe,
            ],
          },
        ],
        accent: [{ accent: ['auto', e] }],
        appearance: [{ appearance: ['none', 'auto'] }],
        cursor: [
          {
            cursor: [
              'auto',
              'default',
              'pointer',
              'wait',
              'text',
              'move',
              'help',
              'not-allowed',
              'none',
              'context-menu',
              'progress',
              'cell',
              'crosshair',
              'vertical-text',
              'alias',
              'copy',
              'no-drop',
              'grab',
              'grabbing',
              'all-scroll',
              'col-resize',
              'row-resize',
              'n-resize',
              'e-resize',
              's-resize',
              'w-resize',
              'ne-resize',
              'nw-resize',
              'se-resize',
              'sw-resize',
              'ew-resize',
              'ns-resize',
              'nesw-resize',
              'nwse-resize',
              'zoom-in',
              'zoom-out',
              pe,
            ],
          },
        ],
        'caret-color': [{ caret: [e] }],
        'pointer-events': [{ 'pointer-events': ['none', 'auto'] }],
        resize: [{ resize: ['none', 'y', 'x', ''] }],
        'scroll-behavior': [{ scroll: ['auto', 'smooth'] }],
        'scroll-m': [{ 'scroll-m': F() }],
        'scroll-mx': [{ 'scroll-mx': F() }],
        'scroll-my': [{ 'scroll-my': F() }],
        'scroll-ms': [{ 'scroll-ms': F() }],
        'scroll-me': [{ 'scroll-me': F() }],
        'scroll-mt': [{ 'scroll-mt': F() }],
        'scroll-mr': [{ 'scroll-mr': F() }],
        'scroll-mb': [{ 'scroll-mb': F() }],
        'scroll-ml': [{ 'scroll-ml': F() }],
        'scroll-p': [{ 'scroll-p': F() }],
        'scroll-px': [{ 'scroll-px': F() }],
        'scroll-py': [{ 'scroll-py': F() }],
        'scroll-ps': [{ 'scroll-ps': F() }],
        'scroll-pe': [{ 'scroll-pe': F() }],
        'scroll-pt': [{ 'scroll-pt': F() }],
        'scroll-pr': [{ 'scroll-pr': F() }],
        'scroll-pb': [{ 'scroll-pb': F() }],
        'scroll-pl': [{ 'scroll-pl': F() }],
        'snap-align': [{ snap: ['start', 'end', 'center', 'align-none'] }],
        'snap-stop': [{ snap: ['normal', 'always'] }],
        'snap-type': [{ snap: ['none', 'x', 'y', 'both'] }],
        'snap-strictness': [{ snap: ['mandatory', 'proximity'] }],
        touch: [{ touch: ['auto', 'none', 'manipulation'] }],
        'touch-x': [{ 'touch-pan': ['x', 'left', 'right'] }],
        'touch-y': [{ 'touch-pan': ['y', 'up', 'down'] }],
        'touch-pz': ['touch-pinch-zoom'],
        select: [{ select: ['none', 'text', 'all', 'auto'] }],
        'will-change': [{ 'will-change': ['auto', 'scroll', 'contents', 'transform', pe] }],
        fill: [{ fill: [e, 'none'] }],
        'stroke-w': [{ stroke: [Vr, fi, md] }],
        stroke: [{ stroke: [e, 'none'] }],
        sr: ['sr-only', 'not-sr-only'],
        'forced-color-adjust': [{ 'forced-color-adjust': ['auto', 'none'] }],
      },
      conflictingClassGroups: {
        overflow: ['overflow-x', 'overflow-y'],
        overscroll: ['overscroll-x', 'overscroll-y'],
        inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],
        'inset-x': ['right', 'left'],
        'inset-y': ['top', 'bottom'],
        flex: ['basis', 'grow', 'shrink'],
        gap: ['gap-x', 'gap-y'],
        p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],
        px: ['pr', 'pl'],
        py: ['pt', 'pb'],
        m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],
        mx: ['mr', 'ml'],
        my: ['mt', 'mb'],
        size: ['w', 'h'],
        'font-size': ['leading'],
        'fvn-normal': [
          'fvn-ordinal',
          'fvn-slashed-zero',
          'fvn-figure',
          'fvn-spacing',
          'fvn-fraction',
        ],
        'fvn-ordinal': ['fvn-normal'],
        'fvn-slashed-zero': ['fvn-normal'],
        'fvn-figure': ['fvn-normal'],
        'fvn-spacing': ['fvn-normal'],
        'fvn-fraction': ['fvn-normal'],
        'line-clamp': ['display', 'overflow'],
        rounded: [
          'rounded-s',
          'rounded-e',
          'rounded-t',
          'rounded-r',
          'rounded-b',
          'rounded-l',
          'rounded-ss',
          'rounded-se',
          'rounded-ee',
          'rounded-es',
          'rounded-tl',
          'rounded-tr',
          'rounded-br',
          'rounded-bl',
        ],
        'rounded-s': ['rounded-ss', 'rounded-es'],
        'rounded-e': ['rounded-se', 'rounded-ee'],
        'rounded-t': ['rounded-tl', 'rounded-tr'],
        'rounded-r': ['rounded-tr', 'rounded-br'],
        'rounded-b': ['rounded-br', 'rounded-bl'],
        'rounded-l': ['rounded-tl', 'rounded-bl'],
        'border-spacing': ['border-spacing-x', 'border-spacing-y'],
        'border-w': [
          'border-w-s',
          'border-w-e',
          'border-w-t',
          'border-w-r',
          'border-w-b',
          'border-w-l',
        ],
        'border-w-x': ['border-w-r', 'border-w-l'],
        'border-w-y': ['border-w-t', 'border-w-b'],
        'border-color': [
          'border-color-s',
          'border-color-e',
          'border-color-t',
          'border-color-r',
          'border-color-b',
          'border-color-l',
        ],
        'border-color-x': ['border-color-r', 'border-color-l'],
        'border-color-y': ['border-color-t', 'border-color-b'],
        'scroll-m': [
          'scroll-mx',
          'scroll-my',
          'scroll-ms',
          'scroll-me',
          'scroll-mt',
          'scroll-mr',
          'scroll-mb',
          'scroll-ml',
        ],
        'scroll-mx': ['scroll-mr', 'scroll-ml'],
        'scroll-my': ['scroll-mt', 'scroll-mb'],
        'scroll-p': [
          'scroll-px',
          'scroll-py',
          'scroll-ps',
          'scroll-pe',
          'scroll-pt',
          'scroll-pr',
          'scroll-pb',
          'scroll-pl',
        ],
        'scroll-px': ['scroll-pr', 'scroll-pl'],
        'scroll-py': ['scroll-pt', 'scroll-pb'],
        touch: ['touch-x', 'touch-y', 'touch-pz'],
        'touch-x': ['touch'],
        'touch-y': ['touch'],
        'touch-pz': ['touch'],
      },
      conflictingClassGroupModifiers: { 'font-size': ['leading'] },
    }
  },
  rZ = Y9(pE)
var tu = function () {
  return (
    (tu =
      Object.assign ||
      function (n) {
        for (var t, r = 1, i = arguments.length; r < i; r++) {
          t = arguments[r]
          for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (n[s] = t[s])
        }
        return n
      }),
    tu.apply(this, arguments)
  )
}
function mE(e, n) {
  var t = {}
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && n.indexOf(r) < 0 && (t[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      n.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (t[r[i]] = e[r[i]])
  return t
}
function Vs(e, n, t, r) {
  function i(s) {
    return s instanceof t
      ? s
      : new t(function (o) {
          o(s)
        })
  }
  return new (t || (t = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u))
      } catch (f) {
        o(f)
      }
    }
    function l(u) {
      try {
        c(r.throw(u))
      } catch (f) {
        o(f)
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l)
    }
    c((r = r.apply(e, n || [])).next())
  })
}
function iZ(e, n, t) {
  if (t || arguments.length === 2)
    for (var r = 0, i = n.length, s; r < i; r++)
      (s || !(r in n)) && (s || (s = Array.prototype.slice.call(n, 0, r)), (s[r] = n[r]))
  return e.concat(s || Array.prototype.slice.call(n))
}
function gd(e, n) {
  return (typeof e == 'function' ? e(n) : e && (e.current = n), e)
}
function gE(e, n) {
  var t = Y.useState(function () {
    return {
      value: e,
      callback: n,
      facade: {
        get current() {
          return t.value
        },
        set current(r) {
          var i = t.value
          i !== r && ((t.value = r), t.callback(r, i))
        },
      },
    }
  })[0]
  return ((t.callback = n), t.facade)
}
var yE = typeof window < 'u' ? Y.useLayoutEffect : Y.useEffect,
  x1 = new WeakMap()
function sZ(e, n) {
  var t = gE(null, function (r) {
    return e.forEach(function (i) {
      return gd(i, r)
    })
  })
  return (
    yE(
      function () {
        var r = x1.get(t)
        if (r) {
          var i = new Set(r),
            s = new Set(e),
            o = t.current
          ;(i.forEach(function (a) {
            s.has(a) || gd(a, null)
          }),
            s.forEach(function (a) {
              i.has(a) || gd(a, o)
            }))
        }
        x1.set(t, e)
      },
      [e],
    ),
    t
  )
}
function bE(e) {
  return e
}
function vE(e, n) {
  n === void 0 && (n = bE)
  var t = [],
    r = !1,
    i = {
      read: function () {
        if (r)
          throw new Error(
            'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.',
          )
        return t.length ? t[t.length - 1] : e
      },
      useMedium: function (s) {
        var o = n(s, r)
        return (
          t.push(o),
          function () {
            t = t.filter(function (a) {
              return a !== o
            })
          }
        )
      },
      assignSyncMedium: function (s) {
        for (r = !0; t.length; ) {
          var o = t
          ;((t = []), o.forEach(s))
        }
        t = {
          push: function (a) {
            return s(a)
          },
          filter: function () {
            return t
          },
        }
      },
      assignMedium: function (s) {
        r = !0
        var o = []
        if (t.length) {
          var a = t
          ;((t = []), a.forEach(s), (o = t))
        }
        var l = function () {
            var u = o
            ;((o = []), u.forEach(s))
          },
          c = function () {
            return Promise.resolve().then(l)
          }
        ;(c(),
          (t = {
            push: function (u) {
              ;(o.push(u), c())
            },
            filter: function (u) {
              return ((o = o.filter(u)), t)
            },
          }))
      },
    }
  return i
}
function oZ(e) {
  e === void 0 && (e = {})
  var n = vE(null)
  return ((n.options = tu({ async: !0, ssr: !1 }, e)), n)
}
var _w = function (e) {
  var n = e.sideCar,
    t = mE(e, ['sideCar'])
  if (!n) throw new Error('Sidecar: please provide `sideCar` property to import the right car')
  var r = n.read()
  if (!r) throw new Error('Sidecar medium not found')
  return Y.createElement(r, tu({}, t))
}
_w.isSideCarExport = !0
function aZ(e, n) {
  return (e.useMedium(n), _w)
}
var lZ = function () {
    if (typeof __webpack_nonce__ < 'u') return __webpack_nonce__
  },
  wE = function (e) {
    if (typeof document > 'u') return null
    var n = Array.isArray(e) ? e[0] : e
    return n.ownerDocument.body
  },
  Xs = new WeakMap(),
  Jl = new WeakMap(),
  Ql = {},
  yd = 0,
  kw = function (e) {
    return e && (e.host || kw(e.parentNode))
  },
  xE = function (e, n) {
    return n
      .map(function (t) {
        if (e.contains(t)) return t
        var r = kw(t)
        return r && e.contains(r)
          ? r
          : (console.error('aria-hidden', t, 'in not contained inside', e, '. Doing nothing'), null)
      })
      .filter(function (t) {
        return !!t
      })
  },
  SE = function (e, n, t, r) {
    var i = xE(n, Array.isArray(e) ? e : [e])
    Ql[t] || (Ql[t] = new WeakMap())
    var s = Ql[t],
      o = [],
      a = new Set(),
      l = new Set(i),
      c = function (f) {
        !f || a.has(f) || (a.add(f), c(f.parentNode))
      }
    i.forEach(c)
    var u = function (f) {
      !f ||
        l.has(f) ||
        Array.prototype.forEach.call(f.children, function (d) {
          if (a.has(d)) u(d)
          else
            try {
              var h = d.getAttribute(r),
                p = h !== null && h !== 'false',
                g = (Xs.get(d) || 0) + 1,
                m = (s.get(d) || 0) + 1
              ;(Xs.set(d, g),
                s.set(d, m),
                o.push(d),
                g === 1 && p && Jl.set(d, !0),
                m === 1 && d.setAttribute(t, 'true'),
                p || d.setAttribute(r, 'true'))
            } catch (y) {
              console.error('aria-hidden: cannot operate on ', d, y)
            }
        })
    }
    return (
      u(n),
      a.clear(),
      yd++,
      function () {
        ;(o.forEach(function (f) {
          var d = Xs.get(f) - 1,
            h = s.get(f) - 1
          ;(Xs.set(f, d),
            s.set(f, h),
            d || (Jl.has(f) || f.removeAttribute(r), Jl.delete(f)),
            h || f.removeAttribute(t))
        }),
          yd--,
          yd || ((Xs = new WeakMap()), (Xs = new WeakMap()), (Jl = new WeakMap()), (Ql = {})))
      }
    )
  },
  cZ = function (e, n, t) {
    t === void 0 && (t = 'data-aria-hidden')
    var r = Array.from(Array.isArray(e) ? e : [e]),
      i = wE(e)
    return i
      ? (r.push.apply(r, Array.from(i.querySelectorAll('[aria-live], script'))),
        SE(r, i, t, 'aria-hidden'))
      : function () {
          return null
        }
  }
const _E = ['top', 'right', 'bottom', 'left'],
  Vi = Math.min,
  zn = Math.max,
  eu = Math.round,
  tc = Math.floor,
  Pr = (e) => ({ x: e, y: e }),
  kE = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
  CE = { start: 'end', end: 'start' }
function Gh(e, n, t) {
  return zn(e, Vi(n, t))
}
function ei(e, n) {
  return typeof e == 'function' ? e(n) : e
}
function ni(e) {
  return e.split('-')[0]
}
function Ko(e) {
  return e.split('-')[1]
}
function Dm(e) {
  return e === 'x' ? 'y' : 'x'
}
function jm(e) {
  return e === 'y' ? 'height' : 'width'
}
const ME = new Set(['top', 'bottom'])
function Tr(e) {
  return ME.has(ni(e)) ? 'y' : 'x'
}
function Lm(e) {
  return Dm(Tr(e))
}
function EE(e, n, t) {
  t === void 0 && (t = !1)
  const r = Ko(e),
    i = Lm(e),
    s = jm(i)
  let o =
    i === 'x' ? (r === (t ? 'end' : 'start') ? 'right' : 'left') : r === 'start' ? 'bottom' : 'top'
  return (n.reference[s] > n.floating[s] && (o = nu(o)), [o, nu(o)])
}
function TE(e) {
  const n = nu(e)
  return [Xh(e), n, Xh(n)]
}
function Xh(e) {
  return e.replace(/start|end/g, (n) => CE[n])
}
const S1 = ['left', 'right'],
  _1 = ['right', 'left'],
  AE = ['top', 'bottom'],
  RE = ['bottom', 'top']
function OE(e, n, t) {
  switch (e) {
    case 'top':
    case 'bottom':
      return t ? (n ? _1 : S1) : n ? S1 : _1
    case 'left':
    case 'right':
      return n ? AE : RE
    default:
      return []
  }
}
function PE(e, n, t, r) {
  const i = Ko(e)
  let s = OE(ni(e), t === 'start', r)
  return (i && ((s = s.map((o) => o + '-' + i)), n && (s = s.concat(s.map(Xh)))), s)
}
function nu(e) {
  return e.replace(/left|right|bottom|top/g, (n) => kE[n])
}
function NE(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e }
}
function Cw(e) {
  return typeof e != 'number' ? NE(e) : { top: e, right: e, bottom: e, left: e }
}
function ru(e) {
  const { x: n, y: t, width: r, height: i } = e
  return { width: r, height: i, top: t, left: n, right: n + r, bottom: t + i, x: n, y: t }
}
function k1(e, n, t) {
  let { reference: r, floating: i } = e
  const s = Tr(n),
    o = Lm(n),
    a = jm(o),
    l = ni(n),
    c = s === 'y',
    u = r.x + r.width / 2 - i.width / 2,
    f = r.y + r.height / 2 - i.height / 2,
    d = r[a] / 2 - i[a] / 2
  let h
  switch (l) {
    case 'top':
      h = { x: u, y: r.y - i.height }
      break
    case 'bottom':
      h = { x: u, y: r.y + r.height }
      break
    case 'right':
      h = { x: r.x + r.width, y: f }
      break
    case 'left':
      h = { x: r.x - i.width, y: f }
      break
    default:
      h = { x: r.x, y: r.y }
  }
  switch (Ko(n)) {
    case 'start':
      h[o] -= d * (t && c ? -1 : 1)
      break
    case 'end':
      h[o] += d * (t && c ? -1 : 1)
      break
  }
  return h
}
const IE = async (e, n, t) => {
  const { placement: r = 'bottom', strategy: i = 'absolute', middleware: s = [], platform: o } = t,
    a = s.filter(Boolean),
    l = await (o.isRTL == null ? void 0 : o.isRTL(n))
  let c = await o.getElementRects({ reference: e, floating: n, strategy: i }),
    { x: u, y: f } = k1(c, r, l),
    d = r,
    h = {},
    p = 0
  for (let g = 0; g < a.length; g++) {
    const { name: m, fn: y } = a[g],
      {
        x: b,
        y: w,
        data: C,
        reset: T,
      } = await y({
        x: u,
        y: f,
        initialPlacement: r,
        placement: d,
        strategy: i,
        middlewareData: h,
        rects: c,
        platform: o,
        elements: { reference: e, floating: n },
      })
    ;((u = b ?? u),
      (f = w ?? f),
      (h = { ...h, [m]: { ...h[m], ...C } }),
      T &&
        p <= 50 &&
        (p++,
        typeof T == 'object' &&
          (T.placement && (d = T.placement),
          T.rects &&
            (c =
              T.rects === !0
                ? await o.getElementRects({ reference: e, floating: n, strategy: i })
                : T.rects),
          ({ x: u, y: f } = k1(c, d, l))),
        (g = -1)))
  }
  return { x: u, y: f, placement: d, strategy: i, middlewareData: h }
}
async function Ya(e, n) {
  var t
  n === void 0 && (n = {})
  const { x: r, y: i, platform: s, rects: o, elements: a, strategy: l } = e,
    {
      boundary: c = 'clippingAncestors',
      rootBoundary: u = 'viewport',
      elementContext: f = 'floating',
      altBoundary: d = !1,
      padding: h = 0,
    } = ei(n, e),
    p = Cw(h),
    m = a[d ? (f === 'floating' ? 'reference' : 'floating') : f],
    y = ru(
      await s.getClippingRect({
        element:
          (t = await (s.isElement == null ? void 0 : s.isElement(m))) == null || t
            ? m
            : m.contextElement ||
              (await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating))),
        boundary: c,
        rootBoundary: u,
        strategy: l,
      }),
    ),
    b =
      f === 'floating'
        ? { x: r, y: i, width: o.floating.width, height: o.floating.height }
        : o.reference,
    w = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)),
    C = (await (s.isElement == null ? void 0 : s.isElement(w)))
      ? (await (s.getScale == null ? void 0 : s.getScale(w))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    T = ru(
      s.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: b,
            offsetParent: w,
            strategy: l,
          })
        : b,
    )
  return {
    top: (y.top - T.top + p.top) / C.y,
    bottom: (T.bottom - y.bottom + p.bottom) / C.y,
    left: (y.left - T.left + p.left) / C.x,
    right: (T.right - y.right + p.right) / C.x,
  }
}
const DE = (e) => ({
    name: 'arrow',
    options: e,
    async fn(n) {
      const { x: t, y: r, placement: i, rects: s, platform: o, elements: a, middlewareData: l } = n,
        { element: c, padding: u = 0 } = ei(e, n) || {}
      if (c == null) return {}
      const f = Cw(u),
        d = { x: t, y: r },
        h = Lm(i),
        p = jm(h),
        g = await o.getDimensions(c),
        m = h === 'y',
        y = m ? 'top' : 'left',
        b = m ? 'bottom' : 'right',
        w = m ? 'clientHeight' : 'clientWidth',
        C = s.reference[p] + s.reference[h] - d[h] - s.floating[p],
        T = d[h] - s.reference[h],
        I = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c))
      let B = I ? I[w] : 0
      ;(!B || !(await (o.isElement == null ? void 0 : o.isElement(I)))) &&
        (B = a.floating[w] || s.floating[p])
      const E = C / 2 - T / 2,
        O = B / 2 - g[p] / 2 - 1,
        P = Vi(f[y], O),
        $ = Vi(f[b], O),
        F = P,
        M = B - g[p] - $,
        R = B / 2 - g[p] / 2 + E,
        k = Gh(F, R, M),
        v =
          !l.arrow &&
          Ko(i) != null &&
          R !== k &&
          s.reference[p] / 2 - (R < F ? P : $) - g[p] / 2 < 0,
        x = v ? (R < F ? R - F : R - M) : 0
      return {
        [h]: d[h] + x,
        data: { [h]: k, centerOffset: R - k - x, ...(v && { alignmentOffset: x }) },
        reset: v,
      }
    },
  }),
  jE = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'flip',
        options: e,
        async fn(n) {
          var t, r
          const {
              placement: i,
              middlewareData: s,
              rects: o,
              initialPlacement: a,
              platform: l,
              elements: c,
            } = n,
            {
              mainAxis: u = !0,
              crossAxis: f = !0,
              fallbackPlacements: d,
              fallbackStrategy: h = 'bestFit',
              fallbackAxisSideDirection: p = 'none',
              flipAlignment: g = !0,
              ...m
            } = ei(e, n)
          if ((t = s.arrow) != null && t.alignmentOffset) return {}
          const y = ni(i),
            b = Tr(a),
            w = ni(a) === a,
            C = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
            T = d || (w || !g ? [nu(a)] : TE(a)),
            I = p !== 'none'
          !d && I && T.push(...PE(a, g, p, C))
          const B = [a, ...T],
            E = await Ya(n, m),
            O = []
          let P = ((r = s.flip) == null ? void 0 : r.overflows) || []
          if ((u && O.push(E[y]), f)) {
            const R = EE(i, o, C)
            O.push(E[R[0]], E[R[1]])
          }
          if (((P = [...P, { placement: i, overflows: O }]), !O.every((R) => R <= 0))) {
            var $, F
            const R = ((($ = s.flip) == null ? void 0 : $.index) || 0) + 1,
              k = B[R]
            if (
              k &&
              (!(f === 'alignment' ? b !== Tr(k) : !1) ||
                P.every((_) => (Tr(_.placement) === b ? _.overflows[0] > 0 : !0)))
            )
              return { data: { index: R, overflows: P }, reset: { placement: k } }
            let v =
              (F = P.filter((x) => x.overflows[0] <= 0).sort(
                (x, _) => x.overflows[1] - _.overflows[1],
              )[0]) == null
                ? void 0
                : F.placement
            if (!v)
              switch (h) {
                case 'bestFit': {
                  var M
                  const x =
                    (M = P.filter((_) => {
                      if (I) {
                        const S = Tr(_.placement)
                        return S === b || S === 'y'
                      }
                      return !0
                    })
                      .map((_) => [
                        _.placement,
                        _.overflows.filter((S) => S > 0).reduce((S, A) => S + A, 0),
                      ])
                      .sort((_, S) => _[1] - S[1])[0]) == null
                      ? void 0
                      : M[0]
                  x && (v = x)
                  break
                }
                case 'initialPlacement':
                  v = a
                  break
              }
            if (i !== v) return { reset: { placement: v } }
          }
          return {}
        },
      }
    )
  }
function C1(e, n) {
  return {
    top: e.top - n.height,
    right: e.right - n.width,
    bottom: e.bottom - n.height,
    left: e.left - n.width,
  }
}
function M1(e) {
  return _E.some((n) => e[n] >= 0)
}
const LE = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'hide',
        options: e,
        async fn(n) {
          const { rects: t } = n,
            { strategy: r = 'referenceHidden', ...i } = ei(e, n)
          switch (r) {
            case 'referenceHidden': {
              const s = await Ya(n, { ...i, elementContext: 'reference' }),
                o = C1(s, t.reference)
              return { data: { referenceHiddenOffsets: o, referenceHidden: M1(o) } }
            }
            case 'escaped': {
              const s = await Ya(n, { ...i, altBoundary: !0 }),
                o = C1(s, t.floating)
              return { data: { escapedOffsets: o, escaped: M1(o) } }
            }
            default:
              return {}
          }
        },
      }
    )
  },
  Mw = new Set(['left', 'top'])
async function FE(e, n) {
  const { placement: t, platform: r, elements: i } = e,
    s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
    o = ni(t),
    a = Ko(t),
    l = Tr(t) === 'y',
    c = Mw.has(o) ? -1 : 1,
    u = s && l ? -1 : 1,
    f = ei(n, e)
  let {
    mainAxis: d,
    crossAxis: h,
    alignmentAxis: p,
  } = typeof f == 'number'
    ? { mainAxis: f, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: f.mainAxis || 0, crossAxis: f.crossAxis || 0, alignmentAxis: f.alignmentAxis }
  return (
    a && typeof p == 'number' && (h = a === 'end' ? p * -1 : p),
    l ? { x: h * u, y: d * c } : { x: d * c, y: h * u }
  )
}
const BE = function (e) {
    return (
      e === void 0 && (e = 0),
      {
        name: 'offset',
        options: e,
        async fn(n) {
          var t, r
          const { x: i, y: s, placement: o, middlewareData: a } = n,
            l = await FE(n, e)
          return o === ((t = a.offset) == null ? void 0 : t.placement) &&
            (r = a.arrow) != null &&
            r.alignmentOffset
            ? {}
            : { x: i + l.x, y: s + l.y, data: { ...l, placement: o } }
        },
      }
    )
  },
  zE = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'shift',
        options: e,
        async fn(n) {
          const { x: t, y: r, placement: i } = n,
            {
              mainAxis: s = !0,
              crossAxis: o = !1,
              limiter: a = {
                fn: (m) => {
                  let { x: y, y: b } = m
                  return { x: y, y: b }
                },
              },
              ...l
            } = ei(e, n),
            c = { x: t, y: r },
            u = await Ya(n, l),
            f = Tr(ni(i)),
            d = Dm(f)
          let h = c[d],
            p = c[f]
          if (s) {
            const m = d === 'y' ? 'top' : 'left',
              y = d === 'y' ? 'bottom' : 'right',
              b = h + u[m],
              w = h - u[y]
            h = Gh(b, h, w)
          }
          if (o) {
            const m = f === 'y' ? 'top' : 'left',
              y = f === 'y' ? 'bottom' : 'right',
              b = p + u[m],
              w = p - u[y]
            p = Gh(b, p, w)
          }
          const g = a.fn({ ...n, [d]: h, [f]: p })
          return { ...g, data: { x: g.x - t, y: g.y - r, enabled: { [d]: s, [f]: o } } }
        },
      }
    )
  },
  $E = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        options: e,
        fn(n) {
          const { x: t, y: r, placement: i, rects: s, middlewareData: o } = n,
            { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = ei(e, n),
            u = { x: t, y: r },
            f = Tr(i),
            d = Dm(f)
          let h = u[d],
            p = u[f]
          const g = ei(a, n),
            m =
              typeof g == 'number'
                ? { mainAxis: g, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...g }
          if (l) {
            const w = d === 'y' ? 'height' : 'width',
              C = s.reference[d] - s.floating[w] + m.mainAxis,
              T = s.reference[d] + s.reference[w] - m.mainAxis
            h < C ? (h = C) : h > T && (h = T)
          }
          if (c) {
            var y, b
            const w = d === 'y' ? 'width' : 'height',
              C = Mw.has(ni(i)),
              T =
                s.reference[f] -
                s.floating[w] +
                ((C && ((y = o.offset) == null ? void 0 : y[f])) || 0) +
                (C ? 0 : m.crossAxis),
              I =
                s.reference[f] +
                s.reference[w] +
                (C ? 0 : ((b = o.offset) == null ? void 0 : b[f]) || 0) -
                (C ? m.crossAxis : 0)
            p < T ? (p = T) : p > I && (p = I)
          }
          return { [d]: h, [f]: p }
        },
      }
    )
  },
  VE = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'size',
        options: e,
        async fn(n) {
          var t, r
          const { placement: i, rects: s, platform: o, elements: a } = n,
            { apply: l = () => {}, ...c } = ei(e, n),
            u = await Ya(n, c),
            f = ni(i),
            d = Ko(i),
            h = Tr(i) === 'y',
            { width: p, height: g } = s.floating
          let m, y
          f === 'top' || f === 'bottom'
            ? ((m = f),
              (y =
                d === ((await (o.isRTL == null ? void 0 : o.isRTL(a.floating))) ? 'start' : 'end')
                  ? 'left'
                  : 'right'))
            : ((y = f), (m = d === 'end' ? 'top' : 'bottom'))
          const b = g - u.top - u.bottom,
            w = p - u.left - u.right,
            C = Vi(g - u[m], b),
            T = Vi(p - u[y], w),
            I = !n.middlewareData.shift
          let B = C,
            E = T
          if (
            ((t = n.middlewareData.shift) != null && t.enabled.x && (E = w),
            (r = n.middlewareData.shift) != null && r.enabled.y && (B = b),
            I && !d)
          ) {
            const P = zn(u.left, 0),
              $ = zn(u.right, 0),
              F = zn(u.top, 0),
              M = zn(u.bottom, 0)
            h
              ? (E = p - 2 * (P !== 0 || $ !== 0 ? P + $ : zn(u.left, u.right)))
              : (B = g - 2 * (F !== 0 || M !== 0 ? F + M : zn(u.top, u.bottom)))
          }
          await l({ ...n, availableWidth: E, availableHeight: B })
          const O = await o.getDimensions(a.floating)
          return p !== O.width || g !== O.height ? { reset: { rects: !0 } } : {}
        },
      }
    )
  }
function xf() {
  return typeof window < 'u'
}
function Go(e) {
  return Ew(e) ? (e.nodeName || '').toLowerCase() : '#document'
}
function Hn(e) {
  var n
  return (e == null || (n = e.ownerDocument) == null ? void 0 : n.defaultView) || window
}
function Br(e) {
  var n
  return (n = (Ew(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : n.documentElement
}
function Ew(e) {
  return xf() ? e instanceof Node || e instanceof Hn(e).Node : !1
}
function wr(e) {
  return xf() ? e instanceof Element || e instanceof Hn(e).Element : !1
}
function Dr(e) {
  return xf() ? e instanceof HTMLElement || e instanceof Hn(e).HTMLElement : !1
}
function E1(e) {
  return !xf() || typeof ShadowRoot > 'u'
    ? !1
    : e instanceof ShadowRoot || e instanceof Hn(e).ShadowRoot
}
const HE = new Set(['inline', 'contents'])
function kl(e) {
  const { overflow: n, overflowX: t, overflowY: r, display: i } = xr(e)
  return /auto|scroll|overlay|hidden|clip/.test(n + r + t) && !HE.has(i)
}
const UE = new Set(['table', 'td', 'th'])
function qE(e) {
  return UE.has(Go(e))
}
const WE = [':popover-open', ':modal']
function Sf(e) {
  return WE.some((n) => {
    try {
      return e.matches(n)
    } catch {
      return !1
    }
  })
}
const KE = ['transform', 'translate', 'scale', 'rotate', 'perspective'],
  GE = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'],
  XE = ['paint', 'layout', 'strict', 'content']
function Fm(e) {
  const n = Bm(),
    t = wr(e) ? xr(e) : e
  return (
    KE.some((r) => (t[r] ? t[r] !== 'none' : !1)) ||
    (t.containerType ? t.containerType !== 'normal' : !1) ||
    (!n && (t.backdropFilter ? t.backdropFilter !== 'none' : !1)) ||
    (!n && (t.filter ? t.filter !== 'none' : !1)) ||
    GE.some((r) => (t.willChange || '').includes(r)) ||
    XE.some((r) => (t.contain || '').includes(r))
  )
}
function YE(e) {
  let n = Hi(e)
  for (; Dr(n) && !Po(n); ) {
    if (Fm(n)) return n
    if (Sf(n)) return null
    n = Hi(n)
  }
  return null
}
function Bm() {
  return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none')
}
const ZE = new Set(['html', 'body', '#document'])
function Po(e) {
  return ZE.has(Go(e))
}
function xr(e) {
  return Hn(e).getComputedStyle(e)
}
function _f(e) {
  return wr(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.scrollX, scrollTop: e.scrollY }
}
function Hi(e) {
  if (Go(e) === 'html') return e
  const n = e.assignedSlot || e.parentNode || (E1(e) && e.host) || Br(e)
  return E1(n) ? n.host : n
}
function Tw(e) {
  const n = Hi(e)
  return Po(n) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : Dr(n) && kl(n) ? n : Tw(n)
}
function Za(e, n, t) {
  var r
  ;(n === void 0 && (n = []), t === void 0 && (t = !0))
  const i = Tw(e),
    s = i === ((r = e.ownerDocument) == null ? void 0 : r.body),
    o = Hn(i)
  if (s) {
    const a = Yh(o)
    return n.concat(o, o.visualViewport || [], kl(i) ? i : [], a && t ? Za(a) : [])
  }
  return n.concat(i, Za(i, [], t))
}
function Yh(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function Aw(e) {
  const n = xr(e)
  let t = parseFloat(n.width) || 0,
    r = parseFloat(n.height) || 0
  const i = Dr(e),
    s = i ? e.offsetWidth : t,
    o = i ? e.offsetHeight : r,
    a = eu(t) !== s || eu(r) !== o
  return (a && ((t = s), (r = o)), { width: t, height: r, $: a })
}
function zm(e) {
  return wr(e) ? e : e.contextElement
}
function wo(e) {
  const n = zm(e)
  if (!Dr(n)) return Pr(1)
  const t = n.getBoundingClientRect(),
    { width: r, height: i, $: s } = Aw(n)
  let o = (s ? eu(t.width) : t.width) / r,
    a = (s ? eu(t.height) : t.height) / i
  return (
    (!o || !Number.isFinite(o)) && (o = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    { x: o, y: a }
  )
}
const JE = Pr(0)
function Rw(e) {
  const n = Hn(e)
  return !Bm() || !n.visualViewport
    ? JE
    : { x: n.visualViewport.offsetLeft, y: n.visualViewport.offsetTop }
}
function QE(e, n, t) {
  return (n === void 0 && (n = !1), !t || (n && t !== Hn(e)) ? !1 : n)
}
function Os(e, n, t, r) {
  ;(n === void 0 && (n = !1), t === void 0 && (t = !1))
  const i = e.getBoundingClientRect(),
    s = zm(e)
  let o = Pr(1)
  n && (r ? wr(r) && (o = wo(r)) : (o = wo(e)))
  const a = QE(s, t, r) ? Rw(s) : Pr(0)
  let l = (i.left + a.x) / o.x,
    c = (i.top + a.y) / o.y,
    u = i.width / o.x,
    f = i.height / o.y
  if (s) {
    const d = Hn(s),
      h = r && wr(r) ? Hn(r) : r
    let p = d,
      g = Yh(p)
    for (; g && r && h !== p; ) {
      const m = wo(g),
        y = g.getBoundingClientRect(),
        b = xr(g),
        w = y.left + (g.clientLeft + parseFloat(b.paddingLeft)) * m.x,
        C = y.top + (g.clientTop + parseFloat(b.paddingTop)) * m.y
      ;((l *= m.x),
        (c *= m.y),
        (u *= m.x),
        (f *= m.y),
        (l += w),
        (c += C),
        (p = Hn(g)),
        (g = Yh(p)))
    }
  }
  return ru({ width: u, height: f, x: l, y: c })
}
function kf(e, n) {
  const t = _f(e).scrollLeft
  return n ? n.left + t : Os(Br(e)).left + t
}
function Ow(e, n) {
  const t = e.getBoundingClientRect(),
    r = t.left + n.scrollLeft - kf(e, t),
    i = t.top + n.scrollTop
  return { x: r, y: i }
}
function tT(e) {
  let { elements: n, rect: t, offsetParent: r, strategy: i } = e
  const s = i === 'fixed',
    o = Br(r),
    a = n ? Sf(n.floating) : !1
  if (r === o || (a && s)) return t
  let l = { scrollLeft: 0, scrollTop: 0 },
    c = Pr(1)
  const u = Pr(0),
    f = Dr(r)
  if ((f || (!f && !s)) && ((Go(r) !== 'body' || kl(o)) && (l = _f(r)), Dr(r))) {
    const h = Os(r)
    ;((c = wo(r)), (u.x = h.x + r.clientLeft), (u.y = h.y + r.clientTop))
  }
  const d = o && !f && !s ? Ow(o, l) : Pr(0)
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - l.scrollLeft * c.x + u.x + d.x,
    y: t.y * c.y - l.scrollTop * c.y + u.y + d.y,
  }
}
function eT(e) {
  return Array.from(e.getClientRects())
}
function nT(e) {
  const n = Br(e),
    t = _f(e),
    r = e.ownerDocument.body,
    i = zn(n.scrollWidth, n.clientWidth, r.scrollWidth, r.clientWidth),
    s = zn(n.scrollHeight, n.clientHeight, r.scrollHeight, r.clientHeight)
  let o = -t.scrollLeft + kf(e)
  const a = -t.scrollTop
  return (
    xr(r).direction === 'rtl' && (o += zn(n.clientWidth, r.clientWidth) - i),
    { width: i, height: s, x: o, y: a }
  )
}
const T1 = 25
function rT(e, n) {
  const t = Hn(e),
    r = Br(e),
    i = t.visualViewport
  let s = r.clientWidth,
    o = r.clientHeight,
    a = 0,
    l = 0
  if (i) {
    ;((s = i.width), (o = i.height))
    const u = Bm()
    ;(!u || (u && n === 'fixed')) && ((a = i.offsetLeft), (l = i.offsetTop))
  }
  const c = kf(r)
  if (c <= 0) {
    const u = r.ownerDocument,
      f = u.body,
      d = getComputedStyle(f),
      h =
        (u.compatMode === 'CSS1Compat' && parseFloat(d.marginLeft) + parseFloat(d.marginRight)) ||
        0,
      p = Math.abs(r.clientWidth - f.clientWidth - h)
    p <= T1 && (s -= p)
  } else c <= T1 && (s += c)
  return { width: s, height: o, x: a, y: l }
}
const iT = new Set(['absolute', 'fixed'])
function sT(e, n) {
  const t = Os(e, !0, n === 'fixed'),
    r = t.top + e.clientTop,
    i = t.left + e.clientLeft,
    s = Dr(e) ? wo(e) : Pr(1),
    o = e.clientWidth * s.x,
    a = e.clientHeight * s.y,
    l = i * s.x,
    c = r * s.y
  return { width: o, height: a, x: l, y: c }
}
function A1(e, n, t) {
  let r
  if (n === 'viewport') r = rT(e, t)
  else if (n === 'document') r = nT(Br(e))
  else if (wr(n)) r = sT(n, t)
  else {
    const i = Rw(e)
    r = { x: n.x - i.x, y: n.y - i.y, width: n.width, height: n.height }
  }
  return ru(r)
}
function Pw(e, n) {
  const t = Hi(e)
  return t === n || !wr(t) || Po(t) ? !1 : xr(t).position === 'fixed' || Pw(t, n)
}
function oT(e, n) {
  const t = n.get(e)
  if (t) return t
  let r = Za(e, [], !1).filter((a) => wr(a) && Go(a) !== 'body'),
    i = null
  const s = xr(e).position === 'fixed'
  let o = s ? Hi(e) : e
  for (; wr(o) && !Po(o); ) {
    const a = xr(o),
      l = Fm(o)
    ;(!l && a.position === 'fixed' && (i = null),
      (
        s
          ? !l && !i
          : (!l && a.position === 'static' && !!i && iT.has(i.position)) ||
            (kl(o) && !l && Pw(e, o))
      )
        ? (r = r.filter((u) => u !== o))
        : (i = a),
      (o = Hi(o)))
  }
  return (n.set(e, r), r)
}
function aT(e) {
  let { element: n, boundary: t, rootBoundary: r, strategy: i } = e
  const o = [...(t === 'clippingAncestors' ? (Sf(n) ? [] : oT(n, this._c)) : [].concat(t)), r],
    a = o[0],
    l = o.reduce(
      (c, u) => {
        const f = A1(n, u, i)
        return (
          (c.top = zn(f.top, c.top)),
          (c.right = Vi(f.right, c.right)),
          (c.bottom = Vi(f.bottom, c.bottom)),
          (c.left = zn(f.left, c.left)),
          c
        )
      },
      A1(n, a, i),
    )
  return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top }
}
function lT(e) {
  const { width: n, height: t } = Aw(e)
  return { width: n, height: t }
}
function cT(e, n, t) {
  const r = Dr(n),
    i = Br(n),
    s = t === 'fixed',
    o = Os(e, !0, s, n)
  let a = { scrollLeft: 0, scrollTop: 0 }
  const l = Pr(0)
  function c() {
    l.x = kf(i)
  }
  if (r || (!r && !s))
    if (((Go(n) !== 'body' || kl(i)) && (a = _f(n)), r)) {
      const h = Os(n, !0, s, n)
      ;((l.x = h.x + n.clientLeft), (l.y = h.y + n.clientTop))
    } else i && c()
  s && !r && i && c()
  const u = i && !r && !s ? Ow(i, a) : Pr(0),
    f = o.left + a.scrollLeft - l.x - u.x,
    d = o.top + a.scrollTop - l.y - u.y
  return { x: f, y: d, width: o.width, height: o.height }
}
function bd(e) {
  return xr(e).position === 'static'
}
function R1(e, n) {
  if (!Dr(e) || xr(e).position === 'fixed') return null
  if (n) return n(e)
  let t = e.offsetParent
  return (Br(e) === t && (t = t.ownerDocument.body), t)
}
function Nw(e, n) {
  const t = Hn(e)
  if (Sf(e)) return t
  if (!Dr(e)) {
    let i = Hi(e)
    for (; i && !Po(i); ) {
      if (wr(i) && !bd(i)) return i
      i = Hi(i)
    }
    return t
  }
  let r = R1(e, n)
  for (; r && qE(r) && bd(r); ) r = R1(r, n)
  return r && Po(r) && bd(r) && !Fm(r) ? t : r || YE(e) || t
}
const uT = async function (e) {
  const n = this.getOffsetParent || Nw,
    t = this.getDimensions,
    r = await t(e.floating)
  return {
    reference: cT(e.reference, await n(e.floating), e.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  }
}
function fT(e) {
  return xr(e).direction === 'rtl'
}
const dT = {
  convertOffsetParentRelativeRectToViewportRelativeRect: tT,
  getDocumentElement: Br,
  getClippingRect: aT,
  getOffsetParent: Nw,
  getElementRects: uT,
  getClientRects: eT,
  getDimensions: lT,
  getScale: wo,
  isElement: wr,
  isRTL: fT,
}
function Iw(e, n) {
  return e.x === n.x && e.y === n.y && e.width === n.width && e.height === n.height
}
function hT(e, n) {
  let t = null,
    r
  const i = Br(e)
  function s() {
    var a
    ;(clearTimeout(r), (a = t) == null || a.disconnect(), (t = null))
  }
  function o(a, l) {
    ;(a === void 0 && (a = !1), l === void 0 && (l = 1), s())
    const c = e.getBoundingClientRect(),
      { left: u, top: f, width: d, height: h } = c
    if ((a || n(), !d || !h)) return
    const p = tc(f),
      g = tc(i.clientWidth - (u + d)),
      m = tc(i.clientHeight - (f + h)),
      y = tc(u),
      w = {
        rootMargin: -p + 'px ' + -g + 'px ' + -m + 'px ' + -y + 'px',
        threshold: zn(0, Vi(1, l)) || 1,
      }
    let C = !0
    function T(I) {
      const B = I[0].intersectionRatio
      if (B !== l) {
        if (!C) return o()
        B
          ? o(!1, B)
          : (r = setTimeout(() => {
              o(!1, 1e-7)
            }, 1e3))
      }
      ;(B === 1 && !Iw(c, e.getBoundingClientRect()) && o(), (C = !1))
    }
    try {
      t = new IntersectionObserver(T, { ...w, root: i.ownerDocument })
    } catch {
      t = new IntersectionObserver(T, w)
    }
    t.observe(e)
  }
  return (o(!0), s)
}
function uZ(e, n, t, r) {
  r === void 0 && (r = {})
  const {
      ancestorScroll: i = !0,
      ancestorResize: s = !0,
      elementResize: o = typeof ResizeObserver == 'function',
      layoutShift: a = typeof IntersectionObserver == 'function',
      animationFrame: l = !1,
    } = r,
    c = zm(e),
    u = i || s ? [...(c ? Za(c) : []), ...Za(n)] : []
  u.forEach((y) => {
    ;(i && y.addEventListener('scroll', t, { passive: !0 }), s && y.addEventListener('resize', t))
  })
  const f = c && a ? hT(c, t) : null
  let d = -1,
    h = null
  o &&
    ((h = new ResizeObserver((y) => {
      let [b] = y
      ;(b &&
        b.target === c &&
        h &&
        (h.unobserve(n),
        cancelAnimationFrame(d),
        (d = requestAnimationFrame(() => {
          var w
          ;(w = h) == null || w.observe(n)
        }))),
        t())
    })),
    c && !l && h.observe(c),
    h.observe(n))
  let p,
    g = l ? Os(e) : null
  l && m()
  function m() {
    const y = Os(e)
    ;(g && !Iw(g, y) && t(), (g = y), (p = requestAnimationFrame(m)))
  }
  return (
    t(),
    () => {
      var y
      ;(u.forEach((b) => {
        ;(i && b.removeEventListener('scroll', t), s && b.removeEventListener('resize', t))
      }),
        f?.(),
        (y = h) == null || y.disconnect(),
        (h = null),
        l && cancelAnimationFrame(p))
    }
  )
}
const pT = BE,
  mT = zE,
  gT = jE,
  yT = VE,
  bT = LE,
  O1 = DE,
  vT = $E,
  wT = (e, n, t) => {
    const r = new Map(),
      i = { platform: dT, ...t },
      s = { ...i.platform, _c: r }
    return IE(e, n, { ...i, platform: s })
  }
var xT = typeof document < 'u',
  ST = function () {},
  Ic = xT ? Y.useLayoutEffect : ST
function iu(e, n) {
  if (e === n) return !0
  if (typeof e != typeof n) return !1
  if (typeof e == 'function' && e.toString() === n.toString()) return !0
  let t, r, i
  if (e && n && typeof e == 'object') {
    if (Array.isArray(e)) {
      if (((t = e.length), t !== n.length)) return !1
      for (r = t; r-- !== 0; ) if (!iu(e[r], n[r])) return !1
      return !0
    }
    if (((i = Object.keys(e)), (t = i.length), t !== Object.keys(n).length)) return !1
    for (r = t; r-- !== 0; ) if (!{}.hasOwnProperty.call(n, i[r])) return !1
    for (r = t; r-- !== 0; ) {
      const s = i[r]
      if (!(s === '_owner' && e.$$typeof) && !iu(e[s], n[s])) return !1
    }
    return !0
  }
  return e !== e && n !== n
}
function Dw(e) {
  return typeof window > 'u' ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function P1(e, n) {
  const t = Dw(e)
  return Math.round(n * t) / t
}
function vd(e) {
  const n = Y.useRef(e)
  return (
    Ic(() => {
      n.current = e
    }),
    n
  )
}
function fZ(e) {
  e === void 0 && (e = {})
  const {
      placement: n = 'bottom',
      strategy: t = 'absolute',
      middleware: r = [],
      platform: i,
      elements: { reference: s, floating: o } = {},
      transform: a = !0,
      whileElementsMounted: l,
      open: c,
    } = e,
    [u, f] = Y.useState({
      x: 0,
      y: 0,
      strategy: t,
      placement: n,
      middlewareData: {},
      isPositioned: !1,
    }),
    [d, h] = Y.useState(r)
  iu(d, r) || h(r)
  const [p, g] = Y.useState(null),
    [m, y] = Y.useState(null),
    b = Y.useCallback((_) => {
      _ !== I.current && ((I.current = _), g(_))
    }, []),
    w = Y.useCallback((_) => {
      _ !== B.current && ((B.current = _), y(_))
    }, []),
    C = s || p,
    T = o || m,
    I = Y.useRef(null),
    B = Y.useRef(null),
    E = Y.useRef(u),
    O = l != null,
    P = vd(l),
    $ = vd(i),
    F = vd(c),
    M = Y.useCallback(() => {
      if (!I.current || !B.current) return
      const _ = { placement: n, strategy: t, middleware: d }
      ;($.current && (_.platform = $.current),
        wT(I.current, B.current, _).then((S) => {
          const A = { ...S, isPositioned: F.current !== !1 }
          R.current &&
            !iu(E.current, A) &&
            ((E.current = A),
            Ei.flushSync(() => {
              f(A)
            }))
        }))
    }, [d, n, t, $, F])
  Ic(() => {
    c === !1 &&
      E.current.isPositioned &&
      ((E.current.isPositioned = !1), f((_) => ({ ..._, isPositioned: !1 })))
  }, [c])
  const R = Y.useRef(!1)
  ;(Ic(
    () => (
      (R.current = !0),
      () => {
        R.current = !1
      }
    ),
    [],
  ),
    Ic(() => {
      if ((C && (I.current = C), T && (B.current = T), C && T)) {
        if (P.current) return P.current(C, T, M)
        M()
      }
    }, [C, T, M, P, O]))
  const k = Y.useMemo(
      () => ({ reference: I, floating: B, setReference: b, setFloating: w }),
      [b, w],
    ),
    v = Y.useMemo(() => ({ reference: C, floating: T }), [C, T]),
    x = Y.useMemo(() => {
      const _ = { position: t, left: 0, top: 0 }
      if (!v.floating) return _
      const S = P1(v.floating, u.x),
        A = P1(v.floating, u.y)
      return a
        ? {
            ..._,
            transform: 'translate(' + S + 'px, ' + A + 'px)',
            ...(Dw(v.floating) >= 1.5 && { willChange: 'transform' }),
          }
        : { position: t, left: S, top: A }
    }, [t, a, v.floating, u.x, u.y])
  return Y.useMemo(
    () => ({ ...u, update: M, refs: k, elements: v, floatingStyles: x }),
    [u, M, k, v, x],
  )
}
const _T = (e) => {
    function n(t) {
      return {}.hasOwnProperty.call(t, 'current')
    }
    return {
      name: 'arrow',
      options: e,
      fn(t) {
        const { element: r, padding: i } = typeof e == 'function' ? e(t) : e
        return r && n(r)
          ? r.current != null
            ? O1({ element: r.current, padding: i }).fn(t)
            : {}
          : r
            ? O1({ element: r, padding: i }).fn(t)
            : {}
      },
    }
  },
  dZ = (e, n) => ({ ...pT(e), options: [e, n] }),
  hZ = (e, n) => ({ ...mT(e), options: [e, n] }),
  pZ = (e, n) => ({ ...vT(e), options: [e, n] }),
  mZ = (e, n) => ({ ...gT(e), options: [e, n] }),
  gZ = (e, n) => ({ ...yT(e), options: [e, n] }),
  yZ = (e, n) => ({ ...bT(e), options: [e, n] }),
  bZ = (e, n) => ({ ..._T(e), options: [e, n] }),
  N1 = (e, n, t) => {
    if (e && 'reportValidity' in e) {
      const r = Ph(t, n)
      ;(e.setCustomValidity((r && r.message) || ''), e.reportValidity())
    }
  },
  jw = (e, n) => {
    for (const t in n.fields) {
      const r = n.fields[t]
      r && r.ref && 'reportValidity' in r.ref
        ? N1(r.ref, t, e)
        : r.refs && r.refs.forEach((i) => N1(i, t, e))
    }
  },
  kT = (e, n) => {
    n.shouldUseNativeValidation && jw(e, n)
    const t = {}
    for (const r in e) {
      const i = Ph(n.fields, r),
        s = Object.assign(e[r] || {}, { ref: i && i.ref })
      if (CT(n.names || Object.keys(e), r)) {
        const o = Object.assign({}, Ph(t, r))
        ;(ud(o, 'root', s), ud(t, r, o))
      } else ud(t, r, s)
    }
    return t
  },
  CT = (e, n) => e.some((t) => t.startsWith(n + '.'))
var MT = function (e, n) {
    for (var t = {}; e.length; ) {
      var r = e[0],
        i = r.code,
        s = r.message,
        o = r.path.join('.')
      if (!t[o])
        if ('unionErrors' in r) {
          var a = r.unionErrors[0].errors[0]
          t[o] = { message: a.message, type: a.code }
        } else t[o] = { message: s, type: i }
      if (
        ('unionErrors' in r &&
          r.unionErrors.forEach(function (u) {
            return u.errors.forEach(function (f) {
              return e.push(f)
            })
          }),
        n)
      ) {
        var l = t[o].types,
          c = l && l[r.code]
        t[o] = q_(o, n, t, i, c ? [].concat(c, r.message) : r.message)
      }
      e.shift()
    }
    return t
  },
  vZ = function (e, n, t) {
    return (
      t === void 0 && (t = {}),
      function (r, i, s) {
        try {
          return Promise.resolve(
            (function (o, a) {
              try {
                var l = Promise.resolve(e[t.mode === 'sync' ? 'parse' : 'parseAsync'](r, n)).then(
                  function (c) {
                    return (
                      s.shouldUseNativeValidation && jw({}, s),
                      { errors: {}, values: t.raw ? r : c }
                    )
                  },
                )
              } catch (c) {
                return a(c)
              }
              return l && l.then ? l.then(void 0, a) : l
            })(0, function (o) {
              if (
                (function (a) {
                  return Array.isArray(a?.errors)
                })(o)
              )
                return {
                  values: {},
                  errors: kT(
                    MT(o.errors, !s.shouldUseNativeValidation && s.criteriaMode === 'all'),
                    s,
                  ),
                }
              throw o
            }),
          )
        } catch (o) {
          return Promise.reject(o)
        }
      }
    )
  }
function ET(e, n, t = 'long') {
  return new Intl.DateTimeFormat('en-US', { hour: 'numeric', timeZone: e, timeZoneName: t })
    .format(n)
    .split(/\s/g)
    .slice(2)
    .join(' ')
}
const TT = {},
  ga = {}
function cs(e, n) {
  try {
    const r = (TT[e] ||= new Intl.DateTimeFormat('en-US', {
      timeZone: e,
      timeZoneName: 'longOffset',
    }).format)(n).split('GMT')[1]
    return r in ga ? ga[r] : I1(r, r.split(':'))
  } catch {
    if (e in ga) return ga[e]
    const t = e?.match(AT)
    return t ? I1(e, t.slice(1)) : NaN
  }
}
const AT = /([+-]\d\d):?(\d\d)?/
function I1(e, n) {
  const t = +(n[0] || 0),
    r = +(n[1] || 0),
    i = +(n[2] || 0) / 60
  return (ga[e] = t * 60 + r > 0 ? t * 60 + r + i : t * 60 - r - i)
}
class Ar extends Date {
  constructor(...n) {
    ;(super(),
      n.length > 1 && typeof n[n.length - 1] == 'string' && (this.timeZone = n.pop()),
      (this.internal = new Date()),
      isNaN(cs(this.timeZone, this))
        ? this.setTime(NaN)
        : n.length
          ? typeof n[0] == 'number' &&
            (n.length === 1 || (n.length === 2 && typeof n[1] != 'number'))
            ? this.setTime(n[0])
            : typeof n[0] == 'string'
              ? this.setTime(+new Date(n[0]))
              : n[0] instanceof Date
                ? this.setTime(+n[0])
                : (this.setTime(+new Date(...n)), Lw(this), Zh(this))
          : this.setTime(Date.now()))
  }
  static tz(n, ...t) {
    return t.length ? new Ar(...t, n) : new Ar(Date.now(), n)
  }
  withTimeZone(n) {
    return new Ar(+this, n)
  }
  getTimezoneOffset() {
    const n = -cs(this.timeZone, this)
    return n > 0 ? Math.floor(n) : Math.ceil(n)
  }
  setTime(n) {
    return (Date.prototype.setTime.apply(this, arguments), Zh(this), +this)
  }
  [Symbol.for('constructDateFrom')](n) {
    return new Ar(+new Date(n), this.timeZone)
  }
}
const D1 = /^(get|set)(?!UTC)/
Object.getOwnPropertyNames(Date.prototype).forEach((e) => {
  if (!D1.test(e)) return
  const n = e.replace(D1, '$1UTC')
  Ar.prototype[n] &&
    (e.startsWith('get')
      ? (Ar.prototype[e] = function () {
          return this.internal[n]()
        })
      : ((Ar.prototype[e] = function () {
          return (Date.prototype[n].apply(this.internal, arguments), RT(this), +this)
        }),
        (Ar.prototype[n] = function () {
          return (Date.prototype[n].apply(this, arguments), Zh(this), +this)
        })))
})
function Zh(e) {
  ;(e.internal.setTime(+e),
    e.internal.setUTCSeconds(e.internal.getUTCSeconds() - Math.round(-cs(e.timeZone, e) * 60)))
}
function RT(e) {
  ;(Date.prototype.setFullYear.call(
    e,
    e.internal.getUTCFullYear(),
    e.internal.getUTCMonth(),
    e.internal.getUTCDate(),
  ),
    Date.prototype.setHours.call(
      e,
      e.internal.getUTCHours(),
      e.internal.getUTCMinutes(),
      e.internal.getUTCSeconds(),
      e.internal.getUTCMilliseconds(),
    ),
    Lw(e))
}
function Lw(e) {
  const n = cs(e.timeZone, e),
    t = n > 0 ? Math.floor(n) : Math.ceil(n),
    r = new Date(+e)
  r.setUTCHours(r.getUTCHours() - 1)
  const i = -new Date(+e).getTimezoneOffset(),
    s = -new Date(+r).getTimezoneOffset(),
    o = i - s,
    a = Date.prototype.getHours.apply(e) !== e.internal.getUTCHours()
  o && a && e.internal.setUTCMinutes(e.internal.getUTCMinutes() + o)
  const l = i - t
  l && Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + l)
  const c = new Date(+e)
  c.setUTCSeconds(0)
  const u = i > 0 ? c.getSeconds() : (c.getSeconds() - 60) % 60,
    f = Math.round(-(cs(e.timeZone, e) * 60)) % 60
  ;(f || u) &&
    (e.internal.setUTCSeconds(e.internal.getUTCSeconds() + f),
    Date.prototype.setUTCSeconds.call(e, Date.prototype.getUTCSeconds.call(e) + f + u))
  const d = cs(e.timeZone, e),
    h = d > 0 ? Math.floor(d) : Math.ceil(d),
    g = -new Date(+e).getTimezoneOffset() - h,
    m = h !== t,
    y = g - l
  if (m && y) {
    Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + y)
    const b = cs(e.timeZone, e),
      w = b > 0 ? Math.floor(b) : Math.ceil(b),
      C = h - w
    C &&
      (e.internal.setUTCMinutes(e.internal.getUTCMinutes() + C),
      Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + C))
  }
}
class ya extends Ar {
  static tz(n, ...t) {
    return t.length ? new ya(...t, n) : new ya(Date.now(), n)
  }
  toISOString() {
    const [n, t, r] = this.tzComponents(),
      i = `${n}${t}:${r}`
    return this.internal.toISOString().slice(0, -1) + i
  }
  toString() {
    return `${this.toDateString()} ${this.toTimeString()}`
  }
  toDateString() {
    const [n, t, r, i] = this.internal.toUTCString().split(' ')
    return `${n?.slice(0, -1)} ${r} ${t} ${i}`
  }
  toTimeString() {
    const n = this.internal.toUTCString().split(' ')[4],
      [t, r, i] = this.tzComponents()
    return `${n} GMT${t}${r}${i} (${ET(this.timeZone, this)})`
  }
  toLocaleString(n, t) {
    return Date.prototype.toLocaleString.call(this, n, {
      ...t,
      timeZone: t?.timeZone || this.timeZone,
    })
  }
  toLocaleDateString(n, t) {
    return Date.prototype.toLocaleDateString.call(this, n, {
      ...t,
      timeZone: t?.timeZone || this.timeZone,
    })
  }
  toLocaleTimeString(n, t) {
    return Date.prototype.toLocaleTimeString.call(this, n, {
      ...t,
      timeZone: t?.timeZone || this.timeZone,
    })
  }
  tzComponents() {
    const n = this.getTimezoneOffset(),
      t = n > 0 ? '-' : '+',
      r = String(Math.floor(Math.abs(n) / 60)).padStart(2, '0'),
      i = String(Math.abs(n) % 60).padStart(2, '0')
    return [t, r, i]
  }
  withTimeZone(n) {
    return new ya(+this, n)
  }
  [Symbol.for('constructDateFrom')](n) {
    return new ya(+new Date(n), this.timeZone)
  }
}
function OT(e) {
  if (typeof document > 'u') return
  let n = document.head || document.getElementsByTagName('head')[0],
    t = document.createElement('style')
  ;((t.type = 'text/css'),
    n.appendChild(t),
    t.styleSheet ? (t.styleSheet.cssText = e) : t.appendChild(document.createTextNode(e)))
}
Array(12).fill(0)
let Jh = 1
class PT {
  constructor() {
    ;((this.subscribe = (n) => (
      this.subscribers.push(n),
      () => {
        const t = this.subscribers.indexOf(n)
        this.subscribers.splice(t, 1)
      }
    )),
      (this.publish = (n) => {
        this.subscribers.forEach((t) => t(n))
      }),
      (this.addToast = (n) => {
        ;(this.publish(n), (this.toasts = [...this.toasts, n]))
      }),
      (this.create = (n) => {
        var t
        const { message: r, ...i } = n,
          s =
            typeof n?.id == 'number' || ((t = n.id) == null ? void 0 : t.length) > 0 ? n.id : Jh++,
          o = this.toasts.find((l) => l.id === s),
          a = n.dismissible === void 0 ? !0 : n.dismissible
        return (
          this.dismissedToasts.has(s) && this.dismissedToasts.delete(s),
          o
            ? (this.toasts = this.toasts.map((l) =>
                l.id === s
                  ? (this.publish({ ...l, ...n, id: s, title: r }),
                    { ...l, ...n, id: s, dismissible: a, title: r })
                  : l,
              ))
            : this.addToast({ title: r, ...i, dismissible: a, id: s }),
          s
        )
      }),
      (this.dismiss = (n) => (
        n
          ? (this.dismissedToasts.add(n),
            requestAnimationFrame(() => this.subscribers.forEach((t) => t({ id: n, dismiss: !0 }))))
          : this.toasts.forEach((t) => {
              this.subscribers.forEach((r) => r({ id: t.id, dismiss: !0 }))
            }),
        n
      )),
      (this.message = (n, t) => this.create({ ...t, message: n })),
      (this.error = (n, t) => this.create({ ...t, message: n, type: 'error' })),
      (this.success = (n, t) => this.create({ ...t, type: 'success', message: n })),
      (this.info = (n, t) => this.create({ ...t, type: 'info', message: n })),
      (this.warning = (n, t) => this.create({ ...t, type: 'warning', message: n })),
      (this.loading = (n, t) => this.create({ ...t, type: 'loading', message: n })),
      (this.promise = (n, t) => {
        if (!t) return
        let r
        t.loading !== void 0 &&
          (r = this.create({
            ...t,
            promise: n,
            type: 'loading',
            message: t.loading,
            description: typeof t.description != 'function' ? t.description : void 0,
          }))
        const i = Promise.resolve(n instanceof Function ? n() : n)
        let s = r !== void 0,
          o
        const a = i
            .then(async (c) => {
              if (((o = ['resolve', c]), ut.isValidElement(c)))
                ((s = !1), this.create({ id: r, type: 'default', message: c }))
              else if (IT(c) && !c.ok) {
                s = !1
                const f =
                    typeof t.error == 'function'
                      ? await t.error(`HTTP error! status: ${c.status}`)
                      : t.error,
                  d =
                    typeof t.description == 'function'
                      ? await t.description(`HTTP error! status: ${c.status}`)
                      : t.description,
                  p = typeof f == 'object' && !ut.isValidElement(f) ? f : { message: f }
                this.create({ id: r, type: 'error', description: d, ...p })
              } else if (c instanceof Error) {
                s = !1
                const f = typeof t.error == 'function' ? await t.error(c) : t.error,
                  d = typeof t.description == 'function' ? await t.description(c) : t.description,
                  p = typeof f == 'object' && !ut.isValidElement(f) ? f : { message: f }
                this.create({ id: r, type: 'error', description: d, ...p })
              } else if (t.success !== void 0) {
                s = !1
                const f = typeof t.success == 'function' ? await t.success(c) : t.success,
                  d = typeof t.description == 'function' ? await t.description(c) : t.description,
                  p = typeof f == 'object' && !ut.isValidElement(f) ? f : { message: f }
                this.create({ id: r, type: 'success', description: d, ...p })
              }
            })
            .catch(async (c) => {
              if (((o = ['reject', c]), t.error !== void 0)) {
                s = !1
                const u = typeof t.error == 'function' ? await t.error(c) : t.error,
                  f = typeof t.description == 'function' ? await t.description(c) : t.description,
                  h = typeof u == 'object' && !ut.isValidElement(u) ? u : { message: u }
                this.create({ id: r, type: 'error', description: f, ...h })
              }
            })
            .finally(() => {
              ;(s && (this.dismiss(r), (r = void 0)), t.finally == null || t.finally.call(t))
            }),
          l = () =>
            new Promise((c, u) => a.then(() => (o[0] === 'reject' ? u(o[1]) : c(o[1]))).catch(u))
        return typeof r != 'string' && typeof r != 'number'
          ? { unwrap: l }
          : Object.assign(r, { unwrap: l })
      }),
      (this.custom = (n, t) => {
        const r = t?.id || Jh++
        return (this.create({ jsx: n(r), id: r, ...t }), r)
      }),
      (this.getActiveToasts = () => this.toasts.filter((n) => !this.dismissedToasts.has(n.id))),
      (this.subscribers = []),
      (this.toasts = []),
      (this.dismissedToasts = new Set()))
  }
}
const Qn = new PT(),
  NT = (e, n) => {
    const t = n?.id || Jh++
    return (Qn.addToast({ title: e, ...n, id: t }), t)
  },
  IT = (e) =>
    e &&
    typeof e == 'object' &&
    'ok' in e &&
    typeof e.ok == 'boolean' &&
    'status' in e &&
    typeof e.status == 'number',
  DT = NT,
  jT = () => Qn.toasts,
  LT = () => Qn.getActiveToasts(),
  wZ = Object.assign(
    DT,
    {
      success: Qn.success,
      info: Qn.info,
      warning: Qn.warning,
      error: Qn.error,
      custom: Qn.custom,
      message: Qn.message,
      promise: Qn.promise,
      dismiss: Qn.dismiss,
      loading: Qn.loading,
    },
    { getHistory: jT, getToasts: LT },
  )
OT(
  "[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}",
)
const j1 = (e) => {
    let n
    const t = new Set(),
      r = (c, u) => {
        const f = typeof c == 'function' ? c(n) : c
        if (!Object.is(f, n)) {
          const d = n
          ;((n = (u ?? (typeof f != 'object' || f === null)) ? f : Object.assign({}, n, f)),
            t.forEach((h) => h(n, d)))
        }
      },
      i = () => n,
      a = {
        setState: r,
        getState: i,
        getInitialState: () => l,
        subscribe: (c) => (t.add(c), () => t.delete(c)),
      },
      l = (n = e(r, i, a))
    return a
  },
  FT = (e) => (e ? j1(e) : j1),
  BT = (e) => e
function zT(e, n = BT) {
  const t = ut.useSyncExternalStore(
    e.subscribe,
    ut.useCallback(() => n(e.getState()), [e, n]),
    ut.useCallback(() => n(e.getInitialState()), [e, n]),
  )
  return (ut.useDebugValue(t), t)
}
const L1 = (e) => {
    const n = FT(e),
      t = (r) => zT(n, r)
    return (Object.assign(t, n), t)
  },
  xZ = (e) => (e ? L1(e) : L1),
  $T = (e) => (n, t, r) => {
    const i = r.subscribe
    return (
      (r.subscribe = (o, a, l) => {
        let c = o
        if (a) {
          const u = l?.equalityFn || Object.is
          let f = o(r.getState())
          ;((c = (d) => {
            const h = o(d)
            if (!u(f, h)) {
              const p = f
              a((f = h), p)
            }
          }),
            l?.fireImmediately && a(f, f))
        }
        return i(c)
      }),
      e(n, t, r)
    )
  },
  SZ = $T
function VT(e, n) {
  let t
  try {
    t = e()
  } catch {
    return
  }
  return {
    getItem: (i) => {
      var s
      const o = (l) => (l === null ? null : JSON.parse(l, void 0)),
        a = (s = t.getItem(i)) != null ? s : null
      return a instanceof Promise ? a.then(o) : o(a)
    },
    setItem: (i, s) => t.setItem(i, JSON.stringify(s, void 0)),
    removeItem: (i) => t.removeItem(i),
  }
}
const Qh = (e) => (n) => {
    try {
      const t = e(n)
      return t instanceof Promise
        ? t
        : {
            then(r) {
              return Qh(r)(t)
            },
            catch(r) {
              return this
            },
          }
    } catch (t) {
      return {
        then(r) {
          return this
        },
        catch(r) {
          return Qh(r)(t)
        },
      }
    }
  },
  HT = (e, n) => (t, r, i) => {
    let s = {
        storage: VT(() => localStorage),
        partialize: (g) => g,
        version: 0,
        merge: (g, m) => ({ ...m, ...g }),
        ...n,
      },
      o = !1
    const a = new Set(),
      l = new Set()
    let c = s.storage
    if (!c)
      return e(
        (...g) => {
          ;(console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`,
          ),
            t(...g))
        },
        r,
        i,
      )
    const u = () => {
        const g = s.partialize({ ...r() })
        return c.setItem(s.name, { state: g, version: s.version })
      },
      f = i.setState
    i.setState = (g, m) => (f(g, m), u())
    const d = e((...g) => (t(...g), u()), r, i)
    i.getInitialState = () => d
    let h
    const p = () => {
      var g, m
      if (!c) return
      ;((o = !1),
        a.forEach((b) => {
          var w
          return b((w = r()) != null ? w : d)
        }))
      const y =
        ((m = s.onRehydrateStorage) == null ? void 0 : m.call(s, (g = r()) != null ? g : d)) ||
        void 0
      return Qh(c.getItem.bind(c))(s.name)
        .then((b) => {
          if (b)
            if (typeof b.version == 'number' && b.version !== s.version) {
              if (s.migrate) {
                const w = s.migrate(b.state, b.version)
                return w instanceof Promise ? w.then((C) => [!0, C]) : [!0, w]
              }
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided",
              )
            } else return [!1, b.state]
          return [!1, void 0]
        })
        .then((b) => {
          var w
          const [C, T] = b
          if (((h = s.merge(T, (w = r()) != null ? w : d)), t(h, !0), C)) return u()
        })
        .then(() => {
          ;(y?.(h, void 0), (h = r()), (o = !0), l.forEach((b) => b(h)))
        })
        .catch((b) => {
          y?.(void 0, b)
        })
    }
    return (
      (i.persist = {
        setOptions: (g) => {
          ;((s = { ...s, ...g }), g.storage && (c = g.storage))
        },
        clearStorage: () => {
          c?.removeItem(s.name)
        },
        getOptions: () => s,
        rehydrate: () => p(),
        hasHydrated: () => o,
        onHydrate: (g) => (
          a.add(g),
          () => {
            a.delete(g)
          }
        ),
        onFinishHydration: (g) => (
          l.add(g),
          () => {
            l.delete(g)
          }
        ),
      }),
      s.skipHydration || p(),
      h || d
    )
  },
  _Z = HT
function Ys(e, n, t) {
  let r = t.initialDeps ?? [],
    i
  function s() {
    var o, a, l, c
    let u
    t.key && (o = t.debug) != null && o.call(t) && (u = Date.now())
    const f = e()
    if (!(f.length !== r.length || f.some((p, g) => r[g] !== p))) return i
    r = f
    let h
    if (
      (t.key && (a = t.debug) != null && a.call(t) && (h = Date.now()),
      (i = n(...f)),
      t.key && (l = t.debug) != null && l.call(t))
    ) {
      const p = Math.round((Date.now() - u) * 100) / 100,
        g = Math.round((Date.now() - h) * 100) / 100,
        m = g / 16,
        y = (b, w) => {
          for (b = String(b); b.length < w; ) b = ' ' + b
          return b
        }
      console.info(
        `%c ${y(g, 5)} /${y(p, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * m, 120))}deg 100% 31%);`,
        t?.key,
      )
    }
    return ((c = t?.onChange) == null || c.call(t, i), i)
  }
  return (
    (s.updateDeps = (o) => {
      r = o
    }),
    s
  )
}
function F1(e, n) {
  if (e === void 0) throw new Error('Unexpected undefined')
  return e
}
const UT = (e, n) => Math.abs(e - n) < 1.01,
  qT = (e, n, t) => {
    let r
    return function (...i) {
      ;(e.clearTimeout(r), (r = e.setTimeout(() => n.apply(this, i), t)))
    }
  },
  B1 = (e) => {
    const { offsetWidth: n, offsetHeight: t } = e
    return { width: n, height: t }
  },
  WT = (e) => e,
  KT = (e) => {
    const n = Math.max(e.startIndex - e.overscan, 0),
      t = Math.min(e.endIndex + e.overscan, e.count - 1),
      r = []
    for (let i = n; i <= t; i++) r.push(i)
    return r
  },
  GT = (e, n) => {
    const t = e.scrollElement
    if (!t) return
    const r = e.targetWindow
    if (!r) return
    const i = (o) => {
      const { width: a, height: l } = o
      n({ width: Math.round(a), height: Math.round(l) })
    }
    if ((i(B1(t)), !r.ResizeObserver)) return () => {}
    const s = new r.ResizeObserver((o) => {
      const a = () => {
        const l = o[0]
        if (l?.borderBoxSize) {
          const c = l.borderBoxSize[0]
          if (c) {
            i({ width: c.inlineSize, height: c.blockSize })
            return
          }
        }
        i(B1(t))
      }
      e.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(a) : a()
    })
    return (
      s.observe(t, { box: 'border-box' }),
      () => {
        s.unobserve(t)
      }
    )
  },
  z1 = { passive: !0 },
  $1 = typeof window > 'u' ? !0 : 'onscrollend' in window,
  XT = (e, n) => {
    const t = e.scrollElement
    if (!t) return
    const r = e.targetWindow
    if (!r) return
    let i = 0
    const s =
        e.options.useScrollendEvent && $1
          ? () => {}
          : qT(
              r,
              () => {
                n(i, !1)
              },
              e.options.isScrollingResetDelay,
            ),
      o = (u) => () => {
        const { horizontal: f, isRtl: d } = e.options
        ;((i = f ? t.scrollLeft * ((d && -1) || 1) : t.scrollTop), s(), n(i, u))
      },
      a = o(!0),
      l = o(!1)
    ;(l(), t.addEventListener('scroll', a, z1))
    const c = e.options.useScrollendEvent && $1
    return (
      c && t.addEventListener('scrollend', l, z1),
      () => {
        ;(t.removeEventListener('scroll', a), c && t.removeEventListener('scrollend', l))
      }
    )
  },
  YT = (e, n, t) => {
    if (n?.borderBoxSize) {
      const r = n.borderBoxSize[0]
      if (r) return Math.round(r[t.options.horizontal ? 'inlineSize' : 'blockSize'])
    }
    return e[t.options.horizontal ? 'offsetWidth' : 'offsetHeight']
  },
  ZT = (e, { adjustments: n = 0, behavior: t }, r) => {
    var i, s
    const o = e + n
    ;(s = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null ||
      s.call(i, { [r.options.horizontal ? 'left' : 'top']: o, behavior: t })
  }
class JT {
  constructor(n) {
    ;((this.unsubs = []),
      (this.scrollElement = null),
      (this.targetWindow = null),
      (this.isScrolling = !1),
      (this.measurementsCache = []),
      (this.itemSizeCache = new Map()),
      (this.pendingMeasuredCacheIndexes = []),
      (this.scrollRect = null),
      (this.scrollOffset = null),
      (this.scrollDirection = null),
      (this.scrollAdjustments = 0),
      (this.elementsCache = new Map()),
      (this.observer = (() => {
        let t = null
        const r = () =>
          t ||
          (!this.targetWindow || !this.targetWindow.ResizeObserver
            ? null
            : (t = new this.targetWindow.ResizeObserver((i) => {
                i.forEach((s) => {
                  const o = () => {
                    this._measureElement(s.target, s)
                  }
                  this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(o) : o()
                })
              })))
        return {
          disconnect: () => {
            var i
            ;((i = r()) == null || i.disconnect(), (t = null))
          },
          observe: (i) => {
            var s
            return (s = r()) == null ? void 0 : s.observe(i, { box: 'border-box' })
          },
          unobserve: (i) => {
            var s
            return (s = r()) == null ? void 0 : s.unobserve(i)
          },
        }
      })()),
      (this.range = null),
      (this.setOptions = (t) => {
        ;(Object.entries(t).forEach(([r, i]) => {
          typeof i > 'u' && delete t[r]
        }),
          (this.options = {
            debug: !1,
            initialOffset: 0,
            overscan: 1,
            paddingStart: 0,
            paddingEnd: 0,
            scrollPaddingStart: 0,
            scrollPaddingEnd: 0,
            horizontal: !1,
            getItemKey: WT,
            rangeExtractor: KT,
            onChange: () => {},
            measureElement: YT,
            initialRect: { width: 0, height: 0 },
            scrollMargin: 0,
            gap: 0,
            indexAttribute: 'data-index',
            initialMeasurementsCache: [],
            lanes: 1,
            isScrollingResetDelay: 150,
            enabled: !0,
            isRtl: !1,
            useScrollendEvent: !1,
            useAnimationFrameWithResizeObserver: !1,
            ...t,
          }))
      }),
      (this.notify = (t) => {
        var r, i
        ;(i = (r = this.options).onChange) == null || i.call(r, this, t)
      }),
      (this.maybeNotify = Ys(
        () => (
          this.calculateRange(),
          [
            this.isScrolling,
            this.range ? this.range.startIndex : null,
            this.range ? this.range.endIndex : null,
          ]
        ),
        (t) => {
          this.notify(t)
        },
        {
          key: !1,
          debug: () => this.options.debug,
          initialDeps: [
            this.isScrolling,
            this.range ? this.range.startIndex : null,
            this.range ? this.range.endIndex : null,
          ],
        },
      )),
      (this.cleanup = () => {
        ;(this.unsubs.filter(Boolean).forEach((t) => t()),
          (this.unsubs = []),
          this.observer.disconnect(),
          (this.scrollElement = null),
          (this.targetWindow = null))
      }),
      (this._didMount = () => () => {
        this.cleanup()
      }),
      (this._willUpdate = () => {
        var t
        const r = this.options.enabled ? this.options.getScrollElement() : null
        if (this.scrollElement !== r) {
          if ((this.cleanup(), !r)) {
            this.maybeNotify()
            return
          }
          ;((this.scrollElement = r),
            this.scrollElement && 'ownerDocument' in this.scrollElement
              ? (this.targetWindow = this.scrollElement.ownerDocument.defaultView)
              : (this.targetWindow =
                  ((t = this.scrollElement) == null ? void 0 : t.window) ?? null),
            this.elementsCache.forEach((i) => {
              this.observer.observe(i)
            }),
            this._scrollToOffset(this.getScrollOffset(), { adjustments: void 0, behavior: void 0 }),
            this.unsubs.push(
              this.options.observeElementRect(this, (i) => {
                ;((this.scrollRect = i), this.maybeNotify())
              }),
            ),
            this.unsubs.push(
              this.options.observeElementOffset(this, (i, s) => {
                ;((this.scrollAdjustments = 0),
                  (this.scrollDirection = s
                    ? this.getScrollOffset() < i
                      ? 'forward'
                      : 'backward'
                    : null),
                  (this.scrollOffset = i),
                  (this.isScrolling = s),
                  this.maybeNotify())
              }),
            ))
        }
      }),
      (this.getSize = () =>
        this.options.enabled
          ? ((this.scrollRect = this.scrollRect ?? this.options.initialRect),
            this.scrollRect[this.options.horizontal ? 'width' : 'height'])
          : ((this.scrollRect = null), 0)),
      (this.getScrollOffset = () =>
        this.options.enabled
          ? ((this.scrollOffset =
              this.scrollOffset ??
              (typeof this.options.initialOffset == 'function'
                ? this.options.initialOffset()
                : this.options.initialOffset)),
            this.scrollOffset)
          : ((this.scrollOffset = null), 0)),
      (this.getFurthestMeasurement = (t, r) => {
        const i = new Map(),
          s = new Map()
        for (let o = r - 1; o >= 0; o--) {
          const a = t[o]
          if (i.has(a.lane)) continue
          const l = s.get(a.lane)
          if (
            (l == null || a.end > l.end ? s.set(a.lane, a) : a.end < l.end && i.set(a.lane, !0),
            i.size === this.options.lanes)
          )
            break
        }
        return s.size === this.options.lanes
          ? Array.from(s.values()).sort((o, a) =>
              o.end === a.end ? o.index - a.index : o.end - a.end,
            )[0]
          : void 0
      }),
      (this.getMeasurementOptions = Ys(
        () => [
          this.options.count,
          this.options.paddingStart,
          this.options.scrollMargin,
          this.options.getItemKey,
          this.options.enabled,
        ],
        (t, r, i, s, o) => (
          (this.pendingMeasuredCacheIndexes = []),
          { count: t, paddingStart: r, scrollMargin: i, getItemKey: s, enabled: o }
        ),
        { key: !1 },
      )),
      (this.getMeasurements = Ys(
        () => [this.getMeasurementOptions(), this.itemSizeCache],
        ({ count: t, paddingStart: r, scrollMargin: i, getItemKey: s, enabled: o }, a) => {
          if (!o) return ((this.measurementsCache = []), this.itemSizeCache.clear(), [])
          this.measurementsCache.length === 0 &&
            ((this.measurementsCache = this.options.initialMeasurementsCache),
            this.measurementsCache.forEach((u) => {
              this.itemSizeCache.set(u.key, u.size)
            }))
          const l =
            this.pendingMeasuredCacheIndexes.length > 0
              ? Math.min(...this.pendingMeasuredCacheIndexes)
              : 0
          this.pendingMeasuredCacheIndexes = []
          const c = this.measurementsCache.slice(0, l)
          for (let u = l; u < t; u++) {
            const f = s(u),
              d = this.options.lanes === 1 ? c[u - 1] : this.getFurthestMeasurement(c, u),
              h = d ? d.end + this.options.gap : r + i,
              p = a.get(f),
              g = typeof p == 'number' ? p : this.options.estimateSize(u),
              m = h + g,
              y = d ? d.lane : u % this.options.lanes
            c[u] = { index: u, start: h, size: g, end: m, key: f, lane: y }
          }
          return ((this.measurementsCache = c), c)
        },
        { key: !1, debug: () => this.options.debug },
      )),
      (this.calculateRange = Ys(
        () => [this.getMeasurements(), this.getSize(), this.getScrollOffset(), this.options.lanes],
        (t, r, i, s) =>
          (this.range =
            t.length > 0 && r > 0
              ? QT({ measurements: t, outerSize: r, scrollOffset: i, lanes: s })
              : null),
        { key: !1, debug: () => this.options.debug },
      )),
      (this.getVirtualIndexes = Ys(
        () => {
          let t = null,
            r = null
          const i = this.calculateRange()
          return (
            i && ((t = i.startIndex), (r = i.endIndex)),
            this.maybeNotify.updateDeps([this.isScrolling, t, r]),
            [this.options.rangeExtractor, this.options.overscan, this.options.count, t, r]
          )
        },
        (t, r, i, s, o) =>
          s === null || o === null ? [] : t({ startIndex: s, endIndex: o, overscan: r, count: i }),
        { key: !1, debug: () => this.options.debug },
      )),
      (this.indexFromElement = (t) => {
        const r = this.options.indexAttribute,
          i = t.getAttribute(r)
        return i
          ? parseInt(i, 10)
          : (console.warn(`Missing attribute name '${r}={index}' on measured element.`), -1)
      }),
      (this._measureElement = (t, r) => {
        const i = this.indexFromElement(t),
          s = this.measurementsCache[i]
        if (!s) return
        const o = s.key,
          a = this.elementsCache.get(o)
        ;(a !== t &&
          (a && this.observer.unobserve(a), this.observer.observe(t), this.elementsCache.set(o, t)),
          t.isConnected && this.resizeItem(i, this.options.measureElement(t, r, this)))
      }),
      (this.resizeItem = (t, r) => {
        const i = this.measurementsCache[t]
        if (!i) return
        const s = this.itemSizeCache.get(i.key) ?? i.size,
          o = r - s
        o !== 0 &&
          ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0
            ? this.shouldAdjustScrollPositionOnItemSizeChange(i, o, this)
            : i.start < this.getScrollOffset() + this.scrollAdjustments) &&
            this._scrollToOffset(this.getScrollOffset(), {
              adjustments: (this.scrollAdjustments += o),
              behavior: void 0,
            }),
          this.pendingMeasuredCacheIndexes.push(i.index),
          (this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, r))),
          this.notify(!1))
      }),
      (this.measureElement = (t) => {
        if (!t) {
          this.elementsCache.forEach((r, i) => {
            r.isConnected || (this.observer.unobserve(r), this.elementsCache.delete(i))
          })
          return
        }
        this._measureElement(t, void 0)
      }),
      (this.getVirtualItems = Ys(
        () => [this.getVirtualIndexes(), this.getMeasurements()],
        (t, r) => {
          const i = []
          for (let s = 0, o = t.length; s < o; s++) {
            const a = t[s],
              l = r[a]
            i.push(l)
          }
          return i
        },
        { key: !1, debug: () => this.options.debug },
      )),
      (this.getVirtualItemForOffset = (t) => {
        const r = this.getMeasurements()
        if (r.length !== 0) return F1(r[Fw(0, r.length - 1, (i) => F1(r[i]).start, t)])
      }),
      (this.getOffsetForAlignment = (t, r, i = 0) => {
        const s = this.getSize(),
          o = this.getScrollOffset()
        ;(r === 'auto' && (r = t >= o + s ? 'end' : 'start'),
          r === 'center' ? (t += (i - s) / 2) : r === 'end' && (t -= s))
        const a = this.getTotalSize() + this.options.scrollMargin - s
        return Math.max(Math.min(a, t), 0)
      }),
      (this.getOffsetForIndex = (t, r = 'auto') => {
        t = Math.max(0, Math.min(t, this.options.count - 1))
        const i = this.measurementsCache[t]
        if (!i) return
        const s = this.getSize(),
          o = this.getScrollOffset()
        if (r === 'auto')
          if (i.end >= o + s - this.options.scrollPaddingEnd) r = 'end'
          else if (i.start <= o + this.options.scrollPaddingStart) r = 'start'
          else return [o, r]
        const a =
          r === 'end'
            ? i.end + this.options.scrollPaddingEnd
            : i.start - this.options.scrollPaddingStart
        return [this.getOffsetForAlignment(a, r, i.size), r]
      }),
      (this.isDynamicMode = () => this.elementsCache.size > 0),
      (this.scrollToOffset = (t, { align: r = 'start', behavior: i } = {}) => {
        ;(i === 'smooth' &&
          this.isDynamicMode() &&
          console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.'),
          this._scrollToOffset(this.getOffsetForAlignment(t, r), {
            adjustments: void 0,
            behavior: i,
          }))
      }),
      (this.scrollToIndex = (t, { align: r = 'auto', behavior: i } = {}) => {
        ;(i === 'smooth' &&
          this.isDynamicMode() &&
          console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.'),
          (t = Math.max(0, Math.min(t, this.options.count - 1))))
        let s = 0
        const o = 10,
          a = (c) => {
            if (!this.targetWindow) return
            const u = this.getOffsetForIndex(t, c)
            if (!u) {
              console.warn('Failed to get offset for index:', t)
              return
            }
            const [f, d] = u
            ;(this._scrollToOffset(f, { adjustments: void 0, behavior: i }),
              this.targetWindow.requestAnimationFrame(() => {
                const h = this.getScrollOffset(),
                  p = this.getOffsetForIndex(t, d)
                if (!p) {
                  console.warn('Failed to get offset for index:', t)
                  return
                }
                UT(p[0], h) || l(d)
              }))
          },
          l = (c) => {
            this.targetWindow &&
              (s++,
              s < o
                ? this.targetWindow.requestAnimationFrame(() => a(c))
                : console.warn(`Failed to scroll to index ${t} after ${o} attempts.`))
          }
        a(r)
      }),
      (this.scrollBy = (t, { behavior: r } = {}) => {
        ;(r === 'smooth' &&
          this.isDynamicMode() &&
          console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.'),
          this._scrollToOffset(this.getScrollOffset() + t, { adjustments: void 0, behavior: r }))
      }),
      (this.getTotalSize = () => {
        var t
        const r = this.getMeasurements()
        let i
        if (r.length === 0) i = this.options.paddingStart
        else if (this.options.lanes === 1) i = ((t = r[r.length - 1]) == null ? void 0 : t.end) ?? 0
        else {
          const s = Array(this.options.lanes).fill(null)
          let o = r.length - 1
          for (; o >= 0 && s.some((a) => a === null); ) {
            const a = r[o]
            ;(s[a.lane] === null && (s[a.lane] = a.end), o--)
          }
          i = Math.max(...s.filter((a) => a !== null))
        }
        return Math.max(i - this.options.scrollMargin + this.options.paddingEnd, 0)
      }),
      (this._scrollToOffset = (t, { adjustments: r, behavior: i }) => {
        this.options.scrollToFn(t, { behavior: i, adjustments: r }, this)
      }),
      (this.measure = () => {
        ;((this.itemSizeCache = new Map()), this.notify(!1))
      }),
      this.setOptions(n))
  }
}
const Fw = (e, n, t, r) => {
  for (; e <= n; ) {
    const i = ((e + n) / 2) | 0,
      s = t(i)
    if (s < r) e = i + 1
    else if (s > r) n = i - 1
    else return i
  }
  return e > 0 ? e - 1 : 0
}
function QT({ measurements: e, outerSize: n, scrollOffset: t, lanes: r }) {
  const i = e.length - 1,
    s = (l) => e[l].start
  if (e.length <= r) return { startIndex: 0, endIndex: i }
  let o = Fw(0, i, s, t),
    a = o
  if (r === 1) for (; a < i && e[a].end < t + n; ) a++
  else if (r > 1) {
    const l = Array(r).fill(0)
    for (; a < i && l.some((u) => u < t + n); ) {
      const u = e[a]
      ;((l[u.lane] = u.end), a++)
    }
    const c = Array(r).fill(t + n)
    for (; o >= 0 && c.some((u) => u >= t); ) {
      const u = e[o]
      ;((c[u.lane] = u.start), o--)
    }
    ;((o = Math.max(0, o - (o % r))), (a = Math.min(i, a + (r - 1 - (a % r)))))
  }
  return { startIndex: o, endIndex: a }
}
const V1 = typeof document < 'u' ? Y.useLayoutEffect : Y.useEffect
function tA(e) {
  const n = Y.useReducer(() => ({}), {})[1],
    t = {
      ...e,
      onChange: (i, s) => {
        var o
        ;(s ? Ei.flushSync(n) : n(), (o = e.onChange) == null || o.call(e, i, s))
      },
    },
    [r] = Y.useState(() => new JT(t))
  return (r.setOptions(t), V1(() => r._didMount(), []), V1(() => r._willUpdate()), r)
}
function kZ(e) {
  return tA({ observeElementRect: GT, observeElementOffset: XT, scrollToFn: ZT, ...e })
}
const $m = Y.createContext({})
function Vm(e) {
  const n = Y.useRef(null)
  return (n.current === null && (n.current = e()), n.current)
}
const Hm = typeof window < 'u',
  Bw = Hm ? Y.useLayoutEffect : Y.useEffect,
  Cf = Y.createContext(null)
function Um(e, n) {
  e.indexOf(n) === -1 && e.push(n)
}
function qm(e, n) {
  const t = e.indexOf(n)
  t > -1 && e.splice(t, 1)
}
const ri = (e, n, t) => (t > n ? n : t < e ? e : t)
let Wm = () => {}
const ii = {},
  zw = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e)
function $w(e) {
  return typeof e == 'object' && e !== null
}
const Vw = (e) => /^0[^.\s]+$/u.test(e)
function Km(e) {
  let n
  return () => (n === void 0 && (n = e()), n)
}
const ar = (e) => e,
  eA = (e, n) => (t) => n(e(t)),
  Cl = (...e) => e.reduce(eA),
  Ja = (e, n, t) => {
    const r = n - e
    return r === 0 ? 1 : (t - e) / r
  }
class Gm {
  constructor() {
    this.subscriptions = []
  }
  add(n) {
    return (Um(this.subscriptions, n), () => qm(this.subscriptions, n))
  }
  notify(n, t, r) {
    const i = this.subscriptions.length
    if (i)
      if (i === 1) this.subscriptions[0](n, t, r)
      else
        for (let s = 0; s < i; s++) {
          const o = this.subscriptions[s]
          o && o(n, t, r)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
const Nr = (e) => e * 1e3,
  sr = (e) => e / 1e3
function Hw(e, n) {
  return n ? e * (1e3 / n) : 0
}
const Uw = (e, n, t) => (((1 - 3 * t + 3 * n) * e + (3 * t - 6 * n)) * e + 3 * n) * e,
  nA = 1e-7,
  rA = 12
function iA(e, n, t, r, i) {
  let s,
    o,
    a = 0
  do ((o = n + (t - n) / 2), (s = Uw(o, r, i) - e), s > 0 ? (t = o) : (n = o))
  while (Math.abs(s) > nA && ++a < rA)
  return o
}
function Ml(e, n, t, r) {
  if (e === n && t === r) return ar
  const i = (s) => iA(s, 0, 1, e, t)
  return (s) => (s === 0 || s === 1 ? s : Uw(i(s), n, r))
}
const qw = (e) => (n) => (n <= 0.5 ? e(2 * n) / 2 : (2 - e(2 * (1 - n))) / 2),
  Ww = (e) => (n) => 1 - e(1 - n),
  Kw = Ml(0.33, 1.53, 0.69, 0.99),
  Xm = Ww(Kw),
  Gw = qw(Xm),
  Xw = (e) => ((e *= 2) < 1 ? 0.5 * Xm(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1)))),
  Ym = (e) => 1 - Math.sin(Math.acos(e)),
  Yw = Ww(Ym),
  Zw = qw(Ym),
  sA = Ml(0.42, 0, 1, 1),
  oA = Ml(0, 0, 0.58, 1),
  Jw = Ml(0.42, 0, 0.58, 1),
  aA = (e) => Array.isArray(e) && typeof e[0] != 'number',
  Qw = (e) => Array.isArray(e) && typeof e[0] == 'number',
  lA = {
    linear: ar,
    easeIn: sA,
    easeInOut: Jw,
    easeOut: oA,
    circIn: Ym,
    circInOut: Zw,
    circOut: Yw,
    backIn: Xm,
    backInOut: Gw,
    backOut: Kw,
    anticipate: Xw,
  },
  cA = (e) => typeof e == 'string',
  H1 = (e) => {
    if (Qw(e)) {
      Wm(e.length === 4)
      const [n, t, r, i] = e
      return Ml(n, t, r, i)
    } else if (cA(e)) return lA[e]
    return e
  },
  ec = [
    'setup',
    'read',
    'resolveKeyframes',
    'preUpdate',
    'update',
    'preRender',
    'render',
    'postRender',
  ]
function uA(e, n) {
  let t = new Set(),
    r = new Set(),
    i = !1,
    s = !1
  const o = new WeakSet()
  let a = { delta: 0, timestamp: 0, isProcessing: !1 }
  function l(u) {
    ;(o.has(u) && (c.schedule(u), e()), u(a))
  }
  const c = {
    schedule: (u, f = !1, d = !1) => {
      const p = d && i ? t : r
      return (f && o.add(u), p.has(u) || p.add(u), u)
    },
    cancel: (u) => {
      ;(r.delete(u), o.delete(u))
    },
    process: (u) => {
      if (((a = u), i)) {
        s = !0
        return
      }
      ;((i = !0),
        ([t, r] = [r, t]),
        t.forEach(l),
        t.clear(),
        (i = !1),
        s && ((s = !1), c.process(u)))
    },
  }
  return c
}
const fA = 40
function tx(e, n) {
  let t = !1,
    r = !0
  const i = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (t = !0),
    o = ec.reduce((w, C) => ((w[C] = uA(s)), w), {}),
    {
      setup: a,
      read: l,
      resolveKeyframes: c,
      preUpdate: u,
      update: f,
      preRender: d,
      render: h,
      postRender: p,
    } = o,
    g = () => {
      const w = ii.useManualTiming ? i.timestamp : performance.now()
      ;((t = !1),
        ii.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(w - i.timestamp, fA), 1)),
        (i.timestamp = w),
        (i.isProcessing = !0),
        a.process(i),
        l.process(i),
        c.process(i),
        u.process(i),
        f.process(i),
        d.process(i),
        h.process(i),
        p.process(i),
        (i.isProcessing = !1),
        t && n && ((r = !1), e(g)))
    },
    m = () => {
      ;((t = !0), (r = !0), i.isProcessing || e(g))
    }
  return {
    schedule: ec.reduce((w, C) => {
      const T = o[C]
      return ((w[C] = (I, B = !1, E = !1) => (t || m(), T.schedule(I, B, E))), w)
    }, {}),
    cancel: (w) => {
      for (let C = 0; C < ec.length; C++) o[ec[C]].cancel(w)
    },
    state: i,
    steps: o,
  }
}
const {
  schedule: Fe,
  cancel: Ui,
  state: bn,
  steps: wd,
} = tx(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : ar, !0)
let Dc
function dA() {
  Dc = void 0
}
const Ln = {
    now: () => (
      Dc === void 0 &&
        Ln.set(bn.isProcessing || ii.useManualTiming ? bn.timestamp : performance.now()),
      Dc
    ),
    set: (e) => {
      ;((Dc = e), queueMicrotask(dA))
    },
  },
  ex = (e) => (n) => typeof n == 'string' && n.startsWith(e),
  Zm = ex('--'),
  hA = ex('var(--'),
  Jm = (e) => (hA(e) ? pA.test(e.split('/*')[0].trim()) : !1),
  pA = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  Xo = { test: (e) => typeof e == 'number', parse: parseFloat, transform: (e) => e },
  Qa = { ...Xo, transform: (e) => ri(0, 1, e) },
  nc = { ...Xo, default: 1 },
  Aa = (e) => Math.round(e * 1e5) / 1e5,
  Qm = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
function mA(e) {
  return e == null
}
const gA =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  t0 = (e, n) => (t) =>
    !!(
      (typeof t == 'string' && gA.test(t) && t.startsWith(e)) ||
      (n && !mA(t) && Object.prototype.hasOwnProperty.call(t, n))
    ),
  nx = (e, n, t) => (r) => {
    if (typeof r != 'string') return r
    const [i, s, o, a] = r.match(Qm)
    return {
      [e]: parseFloat(i),
      [n]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    }
  },
  yA = (e) => ri(0, 255, e),
  xd = { ...Xo, transform: (e) => Math.round(yA(e)) },
  us = {
    test: t0('rgb', 'red'),
    parse: nx('red', 'green', 'blue'),
    transform: ({ red: e, green: n, blue: t, alpha: r = 1 }) =>
      'rgba(' +
      xd.transform(e) +
      ', ' +
      xd.transform(n) +
      ', ' +
      xd.transform(t) +
      ', ' +
      Aa(Qa.transform(r)) +
      ')',
  }
function bA(e) {
  let n = '',
    t = '',
    r = '',
    i = ''
  return (
    e.length > 5
      ? ((n = e.substring(1, 3)),
        (t = e.substring(3, 5)),
        (r = e.substring(5, 7)),
        (i = e.substring(7, 9)))
      : ((n = e.substring(1, 2)),
        (t = e.substring(2, 3)),
        (r = e.substring(3, 4)),
        (i = e.substring(4, 5)),
        (n += n),
        (t += t),
        (r += r),
        (i += i)),
    {
      red: parseInt(n, 16),
      green: parseInt(t, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1,
    }
  )
}
const tp = { test: t0('#'), parse: bA, transform: us.transform },
  El = (e) => ({
    test: (n) => typeof n == 'string' && n.endsWith(e) && n.split(' ').length === 1,
    parse: parseFloat,
    transform: (n) => `${n}${e}`,
  }),
  mi = El('deg'),
  Ir = El('%'),
  se = El('px'),
  vA = El('vh'),
  wA = El('vw'),
  U1 = { ...Ir, parse: (e) => Ir.parse(e) / 100, transform: (e) => Ir.transform(e * 100) },
  ao = {
    test: t0('hsl', 'hue'),
    parse: nx('hue', 'saturation', 'lightness'),
    transform: ({ hue: e, saturation: n, lightness: t, alpha: r = 1 }) =>
      'hsla(' +
      Math.round(e) +
      ', ' +
      Ir.transform(Aa(n)) +
      ', ' +
      Ir.transform(Aa(t)) +
      ', ' +
      Aa(Qa.transform(r)) +
      ')',
  },
  Ze = {
    test: (e) => us.test(e) || tp.test(e) || ao.test(e),
    parse: (e) => (us.test(e) ? us.parse(e) : ao.test(e) ? ao.parse(e) : tp.parse(e)),
    transform: (e) =>
      typeof e == 'string' ? e : e.hasOwnProperty('red') ? us.transform(e) : ao.transform(e),
    getAnimatableNone: (e) => {
      const n = Ze.parse(e)
      return ((n.alpha = 0), Ze.transform(n))
    },
  },
  xA =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
function SA(e) {
  return (
    isNaN(e) && typeof e == 'string' && (e.match(Qm)?.length || 0) + (e.match(xA)?.length || 0) > 0
  )
}
const rx = 'number',
  ix = 'color',
  _A = 'var',
  kA = 'var(',
  q1 = '${}',
  CA =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu
function tl(e) {
  const n = e.toString(),
    t = [],
    r = { color: [], number: [], var: [] },
    i = []
  let s = 0
  const a = n
    .replace(
      CA,
      (l) => (
        Ze.test(l)
          ? (r.color.push(s), i.push(ix), t.push(Ze.parse(l)))
          : l.startsWith(kA)
            ? (r.var.push(s), i.push(_A), t.push(l))
            : (r.number.push(s), i.push(rx), t.push(parseFloat(l))),
        ++s,
        q1
      ),
    )
    .split(q1)
  return { values: t, split: a, indexes: r, types: i }
}
function sx(e) {
  return tl(e).values
}
function ox(e) {
  const { split: n, types: t } = tl(e),
    r = n.length
  return (i) => {
    let s = ''
    for (let o = 0; o < r; o++)
      if (((s += n[o]), i[o] !== void 0)) {
        const a = t[o]
        a === rx ? (s += Aa(i[o])) : a === ix ? (s += Ze.transform(i[o])) : (s += i[o])
      }
    return s
  }
}
const MA = (e) => (typeof e == 'number' ? 0 : Ze.test(e) ? Ze.getAnimatableNone(e) : e)
function EA(e) {
  const n = sx(e)
  return ox(e)(n.map(MA))
}
const qi = { test: SA, parse: sx, createTransformer: ox, getAnimatableNone: EA }
function Sd(e, n, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? e + (n - e) * 6 * t : t < 1 / 2 ? n : t < 2 / 3 ? e + (n - e) * (2 / 3 - t) * 6 : e
  )
}
function TA({ hue: e, saturation: n, lightness: t, alpha: r }) {
  ;((e /= 360), (n /= 100), (t /= 100))
  let i = 0,
    s = 0,
    o = 0
  if (!n) i = s = o = t
  else {
    const a = t < 0.5 ? t * (1 + n) : t + n - t * n,
      l = 2 * t - a
    ;((i = Sd(l, a, e + 1 / 3)), (s = Sd(l, a, e)), (o = Sd(l, a, e - 1 / 3)))
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: r,
  }
}
function su(e, n) {
  return (t) => (t > 0 ? n : e)
}
const Ve = (e, n, t) => e + (n - e) * t,
  _d = (e, n, t) => {
    const r = e * e,
      i = t * (n * n - r) + r
    return i < 0 ? 0 : Math.sqrt(i)
  },
  AA = [tp, us, ao],
  RA = (e) => AA.find((n) => n.test(e))
function W1(e) {
  const n = RA(e)
  if (!n) return !1
  let t = n.parse(e)
  return (n === ao && (t = TA(t)), t)
}
const K1 = (e, n) => {
    const t = W1(e),
      r = W1(n)
    if (!t || !r) return su(e, n)
    const i = { ...t }
    return (s) => (
      (i.red = _d(t.red, r.red, s)),
      (i.green = _d(t.green, r.green, s)),
      (i.blue = _d(t.blue, r.blue, s)),
      (i.alpha = Ve(t.alpha, r.alpha, s)),
      us.transform(i)
    )
  },
  ep = new Set(['none', 'hidden'])
function OA(e, n) {
  return ep.has(e) ? (t) => (t <= 0 ? e : n) : (t) => (t >= 1 ? n : e)
}
function PA(e, n) {
  return (t) => Ve(e, n, t)
}
function e0(e) {
  return typeof e == 'number'
    ? PA
    : typeof e == 'string'
      ? Jm(e)
        ? su
        : Ze.test(e)
          ? K1
          : DA
      : Array.isArray(e)
        ? ax
        : typeof e == 'object'
          ? Ze.test(e)
            ? K1
            : NA
          : su
}
function ax(e, n) {
  const t = [...e],
    r = t.length,
    i = e.map((s, o) => e0(s)(s, n[o]))
  return (s) => {
    for (let o = 0; o < r; o++) t[o] = i[o](s)
    return t
  }
}
function NA(e, n) {
  const t = { ...e, ...n },
    r = {}
  for (const i in t) e[i] !== void 0 && n[i] !== void 0 && (r[i] = e0(e[i])(e[i], n[i]))
  return (i) => {
    for (const s in r) t[s] = r[s](i)
    return t
  }
}
function IA(e, n) {
  const t = [],
    r = { color: 0, var: 0, number: 0 }
  for (let i = 0; i < n.values.length; i++) {
    const s = n.types[i],
      o = e.indexes[s][r[s]],
      a = e.values[o] ?? 0
    ;((t[i] = a), r[s]++)
  }
  return t
}
const DA = (e, n) => {
  const t = qi.createTransformer(n),
    r = tl(e),
    i = tl(n)
  return r.indexes.var.length === i.indexes.var.length &&
    r.indexes.color.length === i.indexes.color.length &&
    r.indexes.number.length >= i.indexes.number.length
    ? (ep.has(e) && !i.values.length) || (ep.has(n) && !r.values.length)
      ? OA(e, n)
      : Cl(ax(IA(r, i), i.values), t)
    : su(e, n)
}
function lx(e, n, t) {
  return typeof e == 'number' && typeof n == 'number' && typeof t == 'number'
    ? Ve(e, n, t)
    : e0(e)(e, n)
}
const jA = (e) => {
    const n = ({ timestamp: t }) => e(t)
    return {
      start: (t = !0) => Fe.update(n, t),
      stop: () => Ui(n),
      now: () => (bn.isProcessing ? bn.timestamp : Ln.now()),
    }
  },
  cx = (e, n, t = 10) => {
    let r = ''
    const i = Math.max(Math.round(n / t), 2)
    for (let s = 0; s < i; s++) r += Math.round(e(s / (i - 1)) * 1e4) / 1e4 + ', '
    return `linear(${r.substring(0, r.length - 2)})`
  },
  ou = 2e4
function n0(e) {
  let n = 0
  const t = 50
  let r = e.next(n)
  for (; !r.done && n < ou; ) ((n += t), (r = e.next(n)))
  return n >= ou ? 1 / 0 : n
}
function LA(e, n = 100, t) {
  const r = t({ ...e, keyframes: [0, n] }),
    i = Math.min(n0(r), ou)
  return { type: 'keyframes', ease: (s) => r.next(i * s).value / n, duration: sr(i) }
}
const FA = 5
function ux(e, n, t) {
  const r = Math.max(n - FA, 0)
  return Hw(t - e(r), n - r)
}
const Ue = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  kd = 0.001
function BA({
  duration: e = Ue.duration,
  bounce: n = Ue.bounce,
  velocity: t = Ue.velocity,
  mass: r = Ue.mass,
}) {
  let i,
    s,
    o = 1 - n
  ;((o = ri(Ue.minDamping, Ue.maxDamping, o)),
    (e = ri(Ue.minDuration, Ue.maxDuration, sr(e))),
    o < 1
      ? ((i = (c) => {
          const u = c * o,
            f = u * e,
            d = u - t,
            h = np(c, o),
            p = Math.exp(-f)
          return kd - (d / h) * p
        }),
        (s = (c) => {
          const f = c * o * e,
            d = f * t + t,
            h = Math.pow(o, 2) * Math.pow(c, 2) * e,
            p = Math.exp(-f),
            g = np(Math.pow(c, 2), o)
          return ((-i(c) + kd > 0 ? -1 : 1) * ((d - h) * p)) / g
        }))
      : ((i = (c) => {
          const u = Math.exp(-c * e),
            f = (c - t) * e + 1
          return -kd + u * f
        }),
        (s = (c) => {
          const u = Math.exp(-c * e),
            f = (t - c) * (e * e)
          return u * f
        })))
  const a = 5 / e,
    l = $A(i, s, a)
  if (((e = Nr(e)), isNaN(l))) return { stiffness: Ue.stiffness, damping: Ue.damping, duration: e }
  {
    const c = Math.pow(l, 2) * r
    return { stiffness: c, damping: o * 2 * Math.sqrt(r * c), duration: e }
  }
}
const zA = 12
function $A(e, n, t) {
  let r = t
  for (let i = 1; i < zA; i++) r = r - e(r) / n(r)
  return r
}
function np(e, n) {
  return e * Math.sqrt(1 - n * n)
}
const VA = ['duration', 'bounce'],
  HA = ['stiffness', 'damping', 'mass']
function G1(e, n) {
  return n.some((t) => e[t] !== void 0)
}
function UA(e) {
  let n = {
    velocity: Ue.velocity,
    stiffness: Ue.stiffness,
    damping: Ue.damping,
    mass: Ue.mass,
    isResolvedFromDuration: !1,
    ...e,
  }
  if (!G1(e, HA) && G1(e, VA))
    if (e.visualDuration) {
      const t = e.visualDuration,
        r = (2 * Math.PI) / (t * 1.2),
        i = r * r,
        s = 2 * ri(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i)
      n = { ...n, mass: Ue.mass, stiffness: i, damping: s }
    } else {
      const t = BA(e)
      ;((n = { ...n, ...t, mass: Ue.mass }), (n.isResolvedFromDuration = !0))
    }
  return n
}
function au(e = Ue.visualDuration, n = Ue.bounce) {
  const t = typeof e != 'object' ? { visualDuration: e, keyframes: [0, 1], bounce: n } : e
  let { restSpeed: r, restDelta: i } = t
  const s = t.keyframes[0],
    o = t.keyframes[t.keyframes.length - 1],
    a = { done: !1, value: s },
    {
      stiffness: l,
      damping: c,
      mass: u,
      duration: f,
      velocity: d,
      isResolvedFromDuration: h,
    } = UA({ ...t, velocity: -sr(t.velocity || 0) }),
    p = d || 0,
    g = c / (2 * Math.sqrt(l * u)),
    m = o - s,
    y = sr(Math.sqrt(l / u)),
    b = Math.abs(m) < 5
  ;(r || (r = b ? Ue.restSpeed.granular : Ue.restSpeed.default),
    i || (i = b ? Ue.restDelta.granular : Ue.restDelta.default))
  let w
  if (g < 1) {
    const T = np(y, g)
    w = (I) => {
      const B = Math.exp(-g * y * I)
      return o - B * (((p + g * y * m) / T) * Math.sin(T * I) + m * Math.cos(T * I))
    }
  } else if (g === 1) w = (T) => o - Math.exp(-y * T) * (m + (p + y * m) * T)
  else {
    const T = y * Math.sqrt(g * g - 1)
    w = (I) => {
      const B = Math.exp(-g * y * I),
        E = Math.min(T * I, 300)
      return o - (B * ((p + g * y * m) * Math.sinh(E) + T * m * Math.cosh(E))) / T
    }
  }
  const C = {
    calculatedDuration: (h && f) || null,
    next: (T) => {
      const I = w(T)
      if (h) a.done = T >= f
      else {
        let B = T === 0 ? p : 0
        g < 1 && (B = T === 0 ? Nr(p) : ux(w, T, I))
        const E = Math.abs(B) <= r,
          O = Math.abs(o - I) <= i
        a.done = E && O
      }
      return ((a.value = a.done ? o : I), a)
    },
    toString: () => {
      const T = Math.min(n0(C), ou),
        I = cx((B) => C.next(T * B).value, T, 30)
      return T + 'ms ' + I
    },
    toTransition: () => {},
  }
  return C
}
au.applyToOptions = (e) => {
  const n = LA(e, 100, au)
  return ((e.ease = n.ease), (e.duration = Nr(n.duration)), (e.type = 'keyframes'), e)
}
function rp({
  keyframes: e,
  velocity: n = 0,
  power: t = 0.8,
  timeConstant: r = 325,
  bounceDamping: i = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: l,
  restDelta: c = 0.5,
  restSpeed: u,
}) {
  const f = e[0],
    d = { done: !1, value: f },
    h = (E) => (a !== void 0 && E < a) || (l !== void 0 && E > l),
    p = (E) => (a === void 0 ? l : l === void 0 || Math.abs(a - E) < Math.abs(l - E) ? a : l)
  let g = t * n
  const m = f + g,
    y = o === void 0 ? m : o(m)
  y !== m && (g = y - f)
  const b = (E) => -g * Math.exp(-E / r),
    w = (E) => y + b(E),
    C = (E) => {
      const O = b(E),
        P = w(E)
      ;((d.done = Math.abs(O) <= c), (d.value = d.done ? y : P))
    }
  let T, I
  const B = (E) => {
    h(d.value) &&
      ((T = E),
      (I = au({
        keyframes: [d.value, p(d.value)],
        velocity: ux(w, E, d.value),
        damping: i,
        stiffness: s,
        restDelta: c,
        restSpeed: u,
      })))
  }
  return (
    B(0),
    {
      calculatedDuration: null,
      next: (E) => {
        let O = !1
        return (
          !I && T === void 0 && ((O = !0), C(E), B(E)),
          T !== void 0 && E >= T ? I.next(E - T) : (!O && C(E), d)
        )
      },
    }
  )
}
function qA(e, n, t) {
  const r = [],
    i = t || ii.mix || lx,
    s = e.length - 1
  for (let o = 0; o < s; o++) {
    let a = i(e[o], e[o + 1])
    if (n) {
      const l = Array.isArray(n) ? n[o] || ar : n
      a = Cl(l, a)
    }
    r.push(a)
  }
  return r
}
function WA(e, n, { clamp: t = !0, ease: r, mixer: i } = {}) {
  const s = e.length
  if ((Wm(s === n.length), s === 1)) return () => n[0]
  if (s === 2 && n[0] === n[1]) return () => n[1]
  const o = e[0] === e[1]
  e[0] > e[s - 1] && ((e = [...e].reverse()), (n = [...n].reverse()))
  const a = qA(n, r, i),
    l = a.length,
    c = (u) => {
      if (o && u < e[0]) return n[0]
      let f = 0
      if (l > 1) for (; f < e.length - 2 && !(u < e[f + 1]); f++);
      const d = Ja(e[f], e[f + 1], u)
      return a[f](d)
    }
  return t ? (u) => c(ri(e[0], e[s - 1], u)) : c
}
function KA(e, n) {
  const t = e[e.length - 1]
  for (let r = 1; r <= n; r++) {
    const i = Ja(0, n, r)
    e.push(Ve(t, 1, i))
  }
}
function GA(e) {
  const n = [0]
  return (KA(n, e.length - 1), n)
}
function XA(e, n) {
  return e.map((t) => t * n)
}
function YA(e, n) {
  return e.map(() => n || Jw).splice(0, e.length - 1)
}
function Ra({ duration: e = 300, keyframes: n, times: t, ease: r = 'easeInOut' }) {
  const i = aA(r) ? r.map(H1) : H1(r),
    s = { done: !1, value: n[0] },
    o = XA(t && t.length === n.length ? t : GA(n), e),
    a = WA(o, n, { ease: Array.isArray(i) ? i : YA(n, i) })
  return { calculatedDuration: e, next: (l) => ((s.value = a(l)), (s.done = l >= e), s) }
}
const ZA = (e) => e !== null
function r0(e, { repeat: n, repeatType: t = 'loop' }, r, i = 1) {
  const s = e.filter(ZA),
    a = i < 0 || (n && t !== 'loop' && n % 2 === 1) ? 0 : s.length - 1
  return !a || r === void 0 ? s[a] : r
}
const JA = { decay: rp, inertia: rp, tween: Ra, keyframes: Ra, spring: au }
function fx(e) {
  typeof e.type == 'string' && (e.type = JA[e.type])
}
class i0 {
  constructor() {
    this.updateFinished()
  }
  get finished() {
    return this._finished
  }
  updateFinished() {
    this._finished = new Promise((n) => {
      this.resolve = n
    })
  }
  notifyFinished() {
    this.resolve()
  }
  then(n, t) {
    return this.finished.then(n, t)
  }
}
const QA = (e) => e / 100
class s0 extends i0 {
  constructor(n) {
    ;(super(),
      (this.state = 'idle'),
      (this.startTime = null),
      (this.isStopped = !1),
      (this.currentTime = 0),
      (this.holdTime = null),
      (this.playbackSpeed = 1),
      (this.stop = () => {
        const { motionValue: t } = this.options
        ;(t && t.updatedAt !== Ln.now() && this.tick(Ln.now()),
          (this.isStopped = !0),
          this.state !== 'idle' && (this.teardown(), this.options.onStop?.()))
      }),
      (this.options = n),
      this.initAnimation(),
      this.play(),
      n.autoplay === !1 && this.pause())
  }
  initAnimation() {
    const { options: n } = this
    fx(n)
    const { type: t = Ra, repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: o = 0 } = n
    let { keyframes: a } = n
    const l = t || Ra
    l !== Ra &&
      typeof a[0] != 'number' &&
      ((this.mixKeyframes = Cl(QA, lx(a[0], a[1]))), (a = [0, 100]))
    const c = l({ ...n, keyframes: a })
    ;(s === 'mirror' &&
      (this.mirroredGenerator = l({ ...n, keyframes: [...a].reverse(), velocity: -o })),
      c.calculatedDuration === null && (c.calculatedDuration = n0(c)))
    const { calculatedDuration: u } = c
    ;((this.calculatedDuration = u),
      (this.resolvedDuration = u + i),
      (this.totalDuration = this.resolvedDuration * (r + 1) - i),
      (this.generator = c))
  }
  updateTime(n) {
    const t = Math.round(n - this.startTime) * this.playbackSpeed
    this.holdTime !== null ? (this.currentTime = this.holdTime) : (this.currentTime = t)
  }
  tick(n, t = !1) {
    const {
      generator: r,
      totalDuration: i,
      mixKeyframes: s,
      mirroredGenerator: o,
      resolvedDuration: a,
      calculatedDuration: l,
    } = this
    if (this.startTime === null) return r.next(0)
    const {
      delay: c = 0,
      keyframes: u,
      repeat: f,
      repeatType: d,
      repeatDelay: h,
      type: p,
      onUpdate: g,
      finalKeyframe: m,
    } = this.options
    ;(this.speed > 0
      ? (this.startTime = Math.min(this.startTime, n))
      : this.speed < 0 && (this.startTime = Math.min(n - i / this.speed, this.startTime)),
      t ? (this.currentTime = n) : this.updateTime(n))
    const y = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1),
      b = this.playbackSpeed >= 0 ? y < 0 : y > i
    ;((this.currentTime = Math.max(y, 0)),
      this.state === 'finished' && this.holdTime === null && (this.currentTime = i))
    let w = this.currentTime,
      C = r
    if (f) {
      const E = Math.min(this.currentTime, i) / a
      let O = Math.floor(E),
        P = E % 1
      ;(!P && E >= 1 && (P = 1),
        P === 1 && O--,
        (O = Math.min(O, f + 1)),
        !!(O % 2) &&
          (d === 'reverse' ? ((P = 1 - P), h && (P -= h / a)) : d === 'mirror' && (C = o)),
        (w = ri(0, 1, P) * a))
    }
    const T = b ? { done: !1, value: u[0] } : C.next(w)
    s && (T.value = s(T.value))
    let { done: I } = T
    !b &&
      l !== null &&
      (I = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0)
    const B =
      this.holdTime === null && (this.state === 'finished' || (this.state === 'running' && I))
    return (
      B && p !== rp && (T.value = r0(u, this.options, m, this.speed)),
      g && g(T.value),
      B && this.finish(),
      T
    )
  }
  then(n, t) {
    return this.finished.then(n, t)
  }
  get duration() {
    return sr(this.calculatedDuration)
  }
  get iterationDuration() {
    const { delay: n = 0 } = this.options || {}
    return this.duration + sr(n)
  }
  get time() {
    return sr(this.currentTime)
  }
  set time(n) {
    ;((n = Nr(n)),
      (this.currentTime = n),
      this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0
        ? (this.holdTime = n)
        : this.driver && (this.startTime = this.driver.now() - n / this.playbackSpeed),
      this.driver?.start(!1))
  }
  get speed() {
    return this.playbackSpeed
  }
  set speed(n) {
    this.updateTime(Ln.now())
    const t = this.playbackSpeed !== n
    ;((this.playbackSpeed = n), t && (this.time = sr(this.currentTime)))
  }
  play() {
    if (this.isStopped) return
    const { driver: n = jA, startTime: t } = this.options
    ;(this.driver || (this.driver = n((i) => this.tick(i))), this.options.onPlay?.())
    const r = this.driver.now()
    ;(this.state === 'finished'
      ? (this.updateFinished(), (this.startTime = r))
      : this.holdTime !== null
        ? (this.startTime = r - this.holdTime)
        : this.startTime || (this.startTime = t ?? r),
      this.state === 'finished' && this.speed < 0 && (this.startTime += this.calculatedDuration),
      (this.holdTime = null),
      (this.state = 'running'),
      this.driver.start())
  }
  pause() {
    ;((this.state = 'paused'), this.updateTime(Ln.now()), (this.holdTime = this.currentTime))
  }
  complete() {
    ;(this.state !== 'running' && this.play(), (this.state = 'finished'), (this.holdTime = null))
  }
  finish() {
    ;(this.notifyFinished(),
      this.teardown(),
      (this.state = 'finished'),
      this.options.onComplete?.())
  }
  cancel() {
    ;((this.holdTime = null),
      (this.startTime = 0),
      this.tick(0),
      this.teardown(),
      this.options.onCancel?.())
  }
  teardown() {
    ;((this.state = 'idle'), this.stopDriver(), (this.startTime = this.holdTime = null))
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0))
  }
  sample(n) {
    return ((this.startTime = 0), this.tick(n, !0))
  }
  attachTimeline(n) {
    return (
      this.options.allowFlatten &&
        ((this.options.type = 'keyframes'), (this.options.ease = 'linear'), this.initAnimation()),
      this.driver?.stop(),
      n.observe(this)
    )
  }
}
function tR(e) {
  for (let n = 1; n < e.length; n++) e[n] ?? (e[n] = e[n - 1])
}
const fs = (e) => (e * 180) / Math.PI,
  ip = (e) => {
    const n = fs(Math.atan2(e[1], e[0]))
    return sp(n)
  },
  eR = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
    rotate: ip,
    rotateZ: ip,
    skewX: (e) => fs(Math.atan(e[1])),
    skewY: (e) => fs(Math.atan(e[2])),
    skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2,
  },
  sp = (e) => ((e = e % 360), e < 0 && (e += 360), e),
  X1 = ip,
  Y1 = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]),
  Z1 = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]),
  nR = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: Y1,
    scaleY: Z1,
    scale: (e) => (Y1(e) + Z1(e)) / 2,
    rotateX: (e) => sp(fs(Math.atan2(e[6], e[5]))),
    rotateY: (e) => sp(fs(Math.atan2(-e[2], e[0]))),
    rotateZ: X1,
    rotate: X1,
    skewX: (e) => fs(Math.atan(e[4])),
    skewY: (e) => fs(Math.atan(e[1])),
    skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2,
  }
function op(e) {
  return e.includes('scale') ? 1 : 0
}
function ap(e, n) {
  if (!e || e === 'none') return op(n)
  const t = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u)
  let r, i
  if (t) ((r = nR), (i = t))
  else {
    const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u)
    ;((r = eR), (i = a))
  }
  if (!i) return op(n)
  const s = r[n],
    o = i[1].split(',').map(iR)
  return typeof s == 'function' ? s(o) : o[s]
}
const rR = (e, n) => {
  const { transform: t = 'none' } = getComputedStyle(e)
  return ap(t, n)
}
function iR(e) {
  return parseFloat(e.trim())
}
const Yo = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ],
  Zo = new Set(Yo),
  J1 = (e) => e === Xo || e === se,
  sR = new Set(['x', 'y', 'z']),
  oR = Yo.filter((e) => !sR.has(e))
function aR(e) {
  const n = []
  return (
    oR.forEach((t) => {
      const r = e.getValue(t)
      r !== void 0 && (n.push([t, r.get()]), r.set(t.startsWith('scale') ? 1 : 0))
    }),
    n
  )
}
const bs = {
  width: ({ x: e }, { paddingLeft: n = '0', paddingRight: t = '0' }) =>
    e.max - e.min - parseFloat(n) - parseFloat(t),
  height: ({ y: e }, { paddingTop: n = '0', paddingBottom: t = '0' }) =>
    e.max - e.min - parseFloat(n) - parseFloat(t),
  top: (e, { top: n }) => parseFloat(n),
  left: (e, { left: n }) => parseFloat(n),
  bottom: ({ y: e }, { top: n }) => parseFloat(n) + (e.max - e.min),
  right: ({ x: e }, { left: n }) => parseFloat(n) + (e.max - e.min),
  x: (e, { transform: n }) => ap(n, 'x'),
  y: (e, { transform: n }) => ap(n, 'y'),
}
bs.translateX = bs.x
bs.translateY = bs.y
const vs = new Set()
let lp = !1,
  cp = !1,
  up = !1
function dx() {
  if (cp) {
    const e = Array.from(vs).filter((r) => r.needsMeasurement),
      n = new Set(e.map((r) => r.element)),
      t = new Map()
    ;(n.forEach((r) => {
      const i = aR(r)
      i.length && (t.set(r, i), r.render())
    }),
      e.forEach((r) => r.measureInitialState()),
      n.forEach((r) => {
        r.render()
        const i = t.get(r)
        i &&
          i.forEach(([s, o]) => {
            r.getValue(s)?.set(o)
          })
      }),
      e.forEach((r) => r.measureEndState()),
      e.forEach((r) => {
        r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY)
      }))
  }
  ;((cp = !1), (lp = !1), vs.forEach((e) => e.complete(up)), vs.clear())
}
function hx() {
  vs.forEach((e) => {
    ;(e.readKeyframes(), e.needsMeasurement && (cp = !0))
  })
}
function lR() {
  ;((up = !0), hx(), dx(), (up = !1))
}
class o0 {
  constructor(n, t, r, i, s, o = !1) {
    ;((this.state = 'pending'),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.unresolvedKeyframes = [...n]),
      (this.onComplete = t),
      (this.name = r),
      (this.motionValue = i),
      (this.element = s),
      (this.isAsync = o))
  }
  scheduleResolve() {
    ;((this.state = 'scheduled'),
      this.isAsync
        ? (vs.add(this), lp || ((lp = !0), Fe.read(hx), Fe.resolveKeyframes(dx)))
        : (this.readKeyframes(), this.complete()))
  }
  readKeyframes() {
    const { unresolvedKeyframes: n, name: t, element: r, motionValue: i } = this
    if (n[0] === null) {
      const s = i?.get(),
        o = n[n.length - 1]
      if (s !== void 0) n[0] = s
      else if (r && t) {
        const a = r.readValue(t, o)
        a != null && (n[0] = a)
      }
      ;(n[0] === void 0 && (n[0] = o), i && s === void 0 && i.set(n[0]))
    }
    tR(n)
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(n = !1) {
    ;((this.state = 'complete'),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, n),
      vs.delete(this))
  }
  cancel() {
    this.state === 'scheduled' && (vs.delete(this), (this.state = 'pending'))
  }
  resume() {
    this.state === 'pending' && this.scheduleResolve()
  }
}
const cR = (e) => e.startsWith('--')
function uR(e, n, t) {
  cR(n) ? e.style.setProperty(n, t) : (e.style[n] = t)
}
const fR = Km(() => window.ScrollTimeline !== void 0),
  dR = {}
function hR(e, n) {
  const t = Km(e)
  return () => dR[n] ?? t()
}
const px = hR(() => {
    try {
      document.createElement('div').animate({ opacity: 0 }, { easing: 'linear(0, 1)' })
    } catch {
      return !1
    }
    return !0
  }, 'linearEasing'),
  ba = ([e, n, t, r]) => `cubic-bezier(${e}, ${n}, ${t}, ${r})`,
  Q1 = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: ba([0, 0.65, 0.55, 1]),
    circOut: ba([0.55, 0, 1, 0.45]),
    backIn: ba([0.31, 0.01, 0.66, -0.59]),
    backOut: ba([0.33, 1.53, 0.69, 0.99]),
  }
function mx(e, n) {
  if (e)
    return typeof e == 'function'
      ? px()
        ? cx(e, n)
        : 'ease-out'
      : Qw(e)
        ? ba(e)
        : Array.isArray(e)
          ? e.map((t) => mx(t, n) || Q1.easeOut)
          : Q1[e]
}
function pR(
  e,
  n,
  t,
  {
    delay: r = 0,
    duration: i = 300,
    repeat: s = 0,
    repeatType: o = 'loop',
    ease: a = 'easeOut',
    times: l,
  } = {},
  c = void 0,
) {
  const u = { [n]: t }
  l && (u.offset = l)
  const f = mx(a, i)
  Array.isArray(f) && (u.easing = f)
  const d = {
    delay: r,
    duration: i,
    easing: Array.isArray(f) ? 'linear' : f,
    fill: 'both',
    iterations: s + 1,
    direction: o === 'reverse' ? 'alternate' : 'normal',
  }
  return (c && (d.pseudoElement = c), e.animate(u, d))
}
function gx(e) {
  return typeof e == 'function' && 'applyToOptions' in e
}
function mR({ type: e, ...n }) {
  return gx(e) && px()
    ? e.applyToOptions(n)
    : (n.duration ?? (n.duration = 300), n.ease ?? (n.ease = 'easeOut'), n)
}
class gR extends i0 {
  constructor(n) {
    if ((super(), (this.finishedTime = null), (this.isStopped = !1), !n)) return
    const {
      element: t,
      name: r,
      keyframes: i,
      pseudoElement: s,
      allowFlatten: o = !1,
      finalKeyframe: a,
      onComplete: l,
    } = n
    ;((this.isPseudoElement = !!s),
      (this.allowFlatten = o),
      (this.options = n),
      Wm(typeof n.type != 'string'))
    const c = mR(n)
    ;((this.animation = pR(t, r, i, c, s)),
      c.autoplay === !1 && this.animation.pause(),
      (this.animation.onfinish = () => {
        if (((this.finishedTime = this.time), !s)) {
          const u = r0(i, this.options, a, this.speed)
          ;(this.updateMotionValue ? this.updateMotionValue(u) : uR(t, r, u),
            this.animation.cancel())
        }
        ;(l?.(), this.notifyFinished())
      }))
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === 'finished' && this.updateFinished())
  }
  pause() {
    this.animation.pause()
  }
  complete() {
    this.animation.finish?.()
  }
  cancel() {
    try {
      this.animation.cancel()
    } catch {}
  }
  stop() {
    if (this.isStopped) return
    this.isStopped = !0
    const { state: n } = this
    n === 'idle' ||
      n === 'finished' ||
      (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
      this.isPseudoElement || this.cancel())
  }
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.()
  }
  get duration() {
    const n = this.animation.effect?.getComputedTiming?.().duration || 0
    return sr(Number(n))
  }
  get iterationDuration() {
    const { delay: n = 0 } = this.options || {}
    return this.duration + sr(n)
  }
  get time() {
    return sr(Number(this.animation.currentTime) || 0)
  }
  set time(n) {
    ;((this.finishedTime = null), (this.animation.currentTime = Nr(n)))
  }
  get speed() {
    return this.animation.playbackRate
  }
  set speed(n) {
    ;(n < 0 && (this.finishedTime = null), (this.animation.playbackRate = n))
  }
  get state() {
    return this.finishedTime !== null ? 'finished' : this.animation.playState
  }
  get startTime() {
    return Number(this.animation.startTime)
  }
  set startTime(n) {
    this.animation.startTime = n
  }
  attachTimeline({ timeline: n, observe: t }) {
    return (
      this.allowFlatten && this.animation.effect?.updateTiming({ easing: 'linear' }),
      (this.animation.onfinish = null),
      n && fR() ? ((this.animation.timeline = n), ar) : t(this)
    )
  }
}
const yx = { anticipate: Xw, backInOut: Gw, circInOut: Zw }
function yR(e) {
  return e in yx
}
function bR(e) {
  typeof e.ease == 'string' && yR(e.ease) && (e.ease = yx[e.ease])
}
const ty = 10
class vR extends gR {
  constructor(n) {
    ;(bR(n), fx(n), super(n), n.startTime && (this.startTime = n.startTime), (this.options = n))
  }
  updateMotionValue(n) {
    const { motionValue: t, onUpdate: r, onComplete: i, element: s, ...o } = this.options
    if (!t) return
    if (n !== void 0) {
      t.set(n)
      return
    }
    const a = new s0({ ...o, autoplay: !1 }),
      l = Nr(this.finishedTime ?? this.time)
    ;(t.setWithVelocity(a.sample(l - ty).value, a.sample(l).value, ty), a.stop())
  }
}
const ey = (e, n) =>
  n === 'zIndex'
    ? !1
    : !!(
        typeof e == 'number' ||
        Array.isArray(e) ||
        (typeof e == 'string' && (qi.test(e) || e === '0') && !e.startsWith('url('))
      )
function wR(e) {
  const n = e[0]
  if (e.length === 1) return !0
  for (let t = 0; t < e.length; t++) if (e[t] !== n) return !0
}
function xR(e, n, t, r) {
  const i = e[0]
  if (i === null) return !1
  if (n === 'display' || n === 'visibility') return !0
  const s = e[e.length - 1],
    o = ey(i, n),
    a = ey(s, n)
  return !o || !a ? !1 : wR(e) || ((t === 'spring' || gx(t)) && r)
}
function fp(e) {
  ;((e.duration = 0), (e.type = 'keyframes'))
}
const SR = new Set(['opacity', 'clipPath', 'filter', 'transform']),
  _R = Km(() => Object.hasOwnProperty.call(Element.prototype, 'animate'))
function kR(e) {
  const { motionValue: n, name: t, repeatDelay: r, repeatType: i, damping: s, type: o } = e
  if (!(n?.owner?.current instanceof HTMLElement)) return !1
  const { onUpdate: l, transformTemplate: c } = n.owner.getProps()
  return (
    _R() &&
    t &&
    SR.has(t) &&
    (t !== 'transform' || !c) &&
    !l &&
    !r &&
    i !== 'mirror' &&
    s !== 0 &&
    o !== 'inertia'
  )
}
const CR = 40
class MR extends i0 {
  constructor({
    autoplay: n = !0,
    delay: t = 0,
    type: r = 'keyframes',
    repeat: i = 0,
    repeatDelay: s = 0,
    repeatType: o = 'loop',
    keyframes: a,
    name: l,
    motionValue: c,
    element: u,
    ...f
  }) {
    ;(super(),
      (this.stop = () => {
        ;(this._animation && (this._animation.stop(), this.stopTimeline?.()),
          this.keyframeResolver?.cancel())
      }),
      (this.createdAt = Ln.now()))
    const d = {
        autoplay: n,
        delay: t,
        type: r,
        repeat: i,
        repeatDelay: s,
        repeatType: o,
        name: l,
        motionValue: c,
        element: u,
        ...f,
      },
      h = u?.KeyframeResolver || o0
    ;((this.keyframeResolver = new h(
      a,
      (p, g, m) => this.onKeyframesResolved(p, g, d, !m),
      l,
      c,
      u,
    )),
      this.keyframeResolver?.scheduleResolve())
  }
  onKeyframesResolved(n, t, r, i) {
    this.keyframeResolver = void 0
    const { name: s, type: o, velocity: a, delay: l, isHandoff: c, onUpdate: u } = r
    ;((this.resolvedAt = Ln.now()),
      xR(n, s, o, a) ||
        ((ii.instantAnimations || !l) && u?.(r0(n, r, t)),
        (n[0] = n[n.length - 1]),
        fp(r),
        (r.repeat = 0)))
    const d = {
        startTime: i
          ? this.resolvedAt
            ? this.resolvedAt - this.createdAt > CR
              ? this.resolvedAt
              : this.createdAt
            : this.createdAt
          : void 0,
        finalKeyframe: t,
        ...r,
        keyframes: n,
      },
      h = !c && kR(d) ? new vR({ ...d, element: d.motionValue.owner.current }) : new s0(d)
    ;(h.finished.then(() => this.notifyFinished()).catch(ar),
      this.pendingTimeline &&
        ((this.stopTimeline = h.attachTimeline(this.pendingTimeline)),
        (this.pendingTimeline = void 0)),
      (this._animation = h))
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished
  }
  then(n, t) {
    return this.finished.finally(n).then(() => {})
  }
  get animation() {
    return (this._animation || (this.keyframeResolver?.resume(), lR()), this._animation)
  }
  get duration() {
    return this.animation.duration
  }
  get iterationDuration() {
    return this.animation.iterationDuration
  }
  get time() {
    return this.animation.time
  }
  set time(n) {
    this.animation.time = n
  }
  get speed() {
    return this.animation.speed
  }
  get state() {
    return this.animation.state
  }
  set speed(n) {
    this.animation.speed = n
  }
  get startTime() {
    return this.animation.startTime
  }
  attachTimeline(n) {
    return (
      this._animation
        ? (this.stopTimeline = this.animation.attachTimeline(n))
        : (this.pendingTimeline = n),
      () => this.stop()
    )
  }
  play() {
    this.animation.play()
  }
  pause() {
    this.animation.pause()
  }
  complete() {
    this.animation.complete()
  }
  cancel() {
    ;(this._animation && this.animation.cancel(), this.keyframeResolver?.cancel())
  }
}
const ER = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
function TR(e) {
  const n = ER.exec(e)
  if (!n) return [,]
  const [, t, r, i] = n
  return [`--${t ?? r}`, i]
}
function bx(e, n, t = 1) {
  const [r, i] = TR(e)
  if (!r) return
  const s = window.getComputedStyle(n).getPropertyValue(r)
  if (s) {
    const o = s.trim()
    return zw(o) ? parseFloat(o) : o
  }
  return Jm(i) ? bx(i, n, t + 1) : i
}
function a0(e, n) {
  return e?.[n] ?? e?.default ?? e
}
const vx = new Set(['width', 'height', 'top', 'left', 'right', 'bottom', ...Yo]),
  AR = { test: (e) => e === 'auto', parse: (e) => e },
  wx = (e) => (n) => n.test(e),
  xx = [Xo, se, Ir, mi, wA, vA, AR],
  ny = (e) => xx.find(wx(e))
function RR(e) {
  return typeof e == 'number' ? e === 0 : e !== null ? e === 'none' || e === '0' || Vw(e) : !0
}
const OR = new Set(['brightness', 'contrast', 'saturate', 'opacity'])
function PR(e) {
  const [n, t] = e.slice(0, -1).split('(')
  if (n === 'drop-shadow') return e
  const [r] = t.match(Qm) || []
  if (!r) return e
  const i = t.replace(r, '')
  let s = OR.has(n) ? 1 : 0
  return (r !== t && (s *= 100), n + '(' + s + i + ')')
}
const NR = /\b([a-z-]*)\(.*?\)/gu,
  dp = {
    ...qi,
    getAnimatableNone: (e) => {
      const n = e.match(NR)
      return n ? n.map(PR).join(' ') : e
    },
  },
  ry = { ...Xo, transform: Math.round },
  IR = {
    rotate: mi,
    rotateX: mi,
    rotateY: mi,
    rotateZ: mi,
    scale: nc,
    scaleX: nc,
    scaleY: nc,
    scaleZ: nc,
    skew: mi,
    skewX: mi,
    skewY: mi,
    distance: se,
    translateX: se,
    translateY: se,
    translateZ: se,
    x: se,
    y: se,
    z: se,
    perspective: se,
    transformPerspective: se,
    opacity: Qa,
    originX: U1,
    originY: U1,
    originZ: se,
  },
  l0 = {
    borderWidth: se,
    borderTopWidth: se,
    borderRightWidth: se,
    borderBottomWidth: se,
    borderLeftWidth: se,
    borderRadius: se,
    radius: se,
    borderTopLeftRadius: se,
    borderTopRightRadius: se,
    borderBottomRightRadius: se,
    borderBottomLeftRadius: se,
    width: se,
    maxWidth: se,
    height: se,
    maxHeight: se,
    top: se,
    right: se,
    bottom: se,
    left: se,
    padding: se,
    paddingTop: se,
    paddingRight: se,
    paddingBottom: se,
    paddingLeft: se,
    margin: se,
    marginTop: se,
    marginRight: se,
    marginBottom: se,
    marginLeft: se,
    backgroundPositionX: se,
    backgroundPositionY: se,
    ...IR,
    zIndex: ry,
    fillOpacity: Qa,
    strokeOpacity: Qa,
    numOctaves: ry,
  },
  DR = {
    ...l0,
    color: Ze,
    backgroundColor: Ze,
    outlineColor: Ze,
    fill: Ze,
    stroke: Ze,
    borderColor: Ze,
    borderTopColor: Ze,
    borderRightColor: Ze,
    borderBottomColor: Ze,
    borderLeftColor: Ze,
    filter: dp,
    WebkitFilter: dp,
  },
  Sx = (e) => DR[e]
function _x(e, n) {
  let t = Sx(e)
  return (t !== dp && (t = qi), t.getAnimatableNone ? t.getAnimatableNone(n) : void 0)
}
const jR = new Set(['auto', 'none', '0'])
function LR(e, n, t) {
  let r = 0,
    i
  for (; r < e.length && !i; ) {
    const s = e[r]
    ;(typeof s == 'string' && !jR.has(s) && tl(s).values.length && (i = e[r]), r++)
  }
  if (i && t) for (const s of n) e[s] = _x(t, i)
}
class FR extends o0 {
  constructor(n, t, r, i, s) {
    super(n, t, r, i, s, !0)
  }
  readKeyframes() {
    const { unresolvedKeyframes: n, element: t, name: r } = this
    if (!t || !t.current) return
    super.readKeyframes()
    for (let l = 0; l < n.length; l++) {
      let c = n[l]
      if (typeof c == 'string' && ((c = c.trim()), Jm(c))) {
        const u = bx(c, t.current)
        ;(u !== void 0 && (n[l] = u), l === n.length - 1 && (this.finalKeyframe = c))
      }
    }
    if ((this.resolveNoneKeyframes(), !vx.has(r) || n.length !== 2)) return
    const [i, s] = n,
      o = ny(i),
      a = ny(s)
    if (o !== a)
      if (J1(o) && J1(a))
        for (let l = 0; l < n.length; l++) {
          const c = n[l]
          typeof c == 'string' && (n[l] = parseFloat(c))
        }
      else bs[r] && (this.needsMeasurement = !0)
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: n, name: t } = this,
      r = []
    for (let i = 0; i < n.length; i++) (n[i] === null || RR(n[i])) && r.push(i)
    r.length && LR(n, r, t)
  }
  measureInitialState() {
    const { element: n, unresolvedKeyframes: t, name: r } = this
    if (!n || !n.current) return
    ;(r === 'height' && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = bs[r](n.measureViewportBox(), window.getComputedStyle(n.current))),
      (t[0] = this.measuredOrigin))
    const i = t[t.length - 1]
    i !== void 0 && n.getValue(r, i).jump(i, !1)
  }
  measureEndState() {
    const { element: n, name: t, unresolvedKeyframes: r } = this
    if (!n || !n.current) return
    const i = n.getValue(t)
    i && i.jump(this.measuredOrigin, !1)
    const s = r.length - 1,
      o = r[s]
    ;((r[s] = bs[t](n.measureViewportBox(), window.getComputedStyle(n.current))),
      o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o),
      this.removedTransforms?.length &&
        this.removedTransforms.forEach(([a, l]) => {
          n.getValue(a).set(l)
        }),
      this.resolveNoneKeyframes())
  }
}
function BR(e, n, t) {
  if (e instanceof EventTarget) return [e]
  if (typeof e == 'string') {
    let r = document
    const i = t?.[e] ?? r.querySelectorAll(e)
    return i ? Array.from(i) : []
  }
  return Array.from(e)
}
const kx = (e, n) => (n && typeof e == 'number' ? n.transform(e) : e)
function Cx(e) {
  return $w(e) && 'offsetHeight' in e
}
const iy = 30,
  zR = (e) => !isNaN(parseFloat(e))
class $R {
  constructor(n, t = {}) {
    ;((this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (r) => {
        const i = Ln.now()
        if (
          (this.updatedAt !== i && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(r),
          this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        )
          for (const s of this.dependents) s.dirty()
      }),
      (this.hasAnimated = !1),
      this.setCurrent(n),
      (this.owner = t.owner))
  }
  setCurrent(n) {
    ;((this.current = n),
      (this.updatedAt = Ln.now()),
      this.canTrackVelocity === null && n !== void 0 && (this.canTrackVelocity = zR(this.current)))
  }
  setPrevFrameValue(n = this.current) {
    ;((this.prevFrameValue = n), (this.prevUpdatedAt = this.updatedAt))
  }
  onChange(n) {
    return this.on('change', n)
  }
  on(n, t) {
    this.events[n] || (this.events[n] = new Gm())
    const r = this.events[n].add(t)
    return n === 'change'
      ? () => {
          ;(r(),
            Fe.read(() => {
              this.events.change.getSize() || this.stop()
            }))
        }
      : r
  }
  clearListeners() {
    for (const n in this.events) this.events[n].clear()
  }
  attach(n, t) {
    ;((this.passiveEffect = n), (this.stopPassiveEffect = t))
  }
  set(n) {
    this.passiveEffect ? this.passiveEffect(n, this.updateAndNotify) : this.updateAndNotify(n)
  }
  setWithVelocity(n, t, r) {
    ;(this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = n),
      (this.prevUpdatedAt = this.updatedAt - r))
  }
  jump(n, t = !0) {
    ;(this.updateAndNotify(n),
      (this.prev = n),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect())
  }
  dirty() {
    this.events.change?.notify(this.current)
  }
  addDependent(n) {
    ;(this.dependents || (this.dependents = new Set()), this.dependents.add(n))
  }
  removeDependent(n) {
    this.dependents && this.dependents.delete(n)
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    const n = Ln.now()
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || n - this.updatedAt > iy)
      return 0
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, iy)
    return Hw(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
  }
  start(n) {
    return (
      this.stop(),
      new Promise((t) => {
        ;((this.hasAnimated = !0),
          (this.animation = n(t)),
          this.events.animationStart && this.events.animationStart.notify())
      }).then(() => {
        ;(this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation())
      })
    )
  }
  stop() {
    ;(this.animation &&
      (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation())
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    ;(this.dependents?.clear(),
      this.events.destroy?.notify(),
      this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect())
  }
}
function No(e, n) {
  return new $R(e, n)
}
const { schedule: c0 } = tx(queueMicrotask, !1),
  hr = { x: !1, y: !1 }
function Mx() {
  return hr.x || hr.y
}
function VR(e) {
  return e === 'x' || e === 'y'
    ? hr[e]
      ? null
      : ((hr[e] = !0),
        () => {
          hr[e] = !1
        })
    : hr.x || hr.y
      ? null
      : ((hr.x = hr.y = !0),
        () => {
          hr.x = hr.y = !1
        })
}
function Ex(e, n) {
  const t = BR(e),
    r = new AbortController(),
    i = { passive: !0, ...n, signal: r.signal }
  return [t, i, () => r.abort()]
}
function sy(e) {
  return !(e.pointerType === 'touch' || Mx())
}
function HR(e, n, t = {}) {
  const [r, i, s] = Ex(e, t),
    o = (a) => {
      if (!sy(a)) return
      const { target: l } = a,
        c = n(l, a)
      if (typeof c != 'function' || !l) return
      const u = (f) => {
        sy(f) && (c(f), l.removeEventListener('pointerleave', u))
      }
      l.addEventListener('pointerleave', u, i)
    }
  return (
    r.forEach((a) => {
      a.addEventListener('pointerenter', o, i)
    }),
    s
  )
}
const Tx = (e, n) => (n ? (e === n ? !0 : Tx(e, n.parentElement)) : !1),
  u0 = (e) =>
    e.pointerType === 'mouse' ? typeof e.button != 'number' || e.button <= 0 : e.isPrimary !== !1,
  UR = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'])
function qR(e) {
  return UR.has(e.tagName) || e.tabIndex !== -1
}
const jc = new WeakSet()
function oy(e) {
  return (n) => {
    n.key === 'Enter' && e(n)
  }
}
function Cd(e, n) {
  e.dispatchEvent(new PointerEvent('pointer' + n, { isPrimary: !0, bubbles: !0 }))
}
const WR = (e, n) => {
  const t = e.currentTarget
  if (!t) return
  const r = oy(() => {
    if (jc.has(t)) return
    Cd(t, 'down')
    const i = oy(() => {
        Cd(t, 'up')
      }),
      s = () => Cd(t, 'cancel')
    ;(t.addEventListener('keyup', i, n), t.addEventListener('blur', s, n))
  })
  ;(t.addEventListener('keydown', r, n),
    t.addEventListener('blur', () => t.removeEventListener('keydown', r), n))
}
function ay(e) {
  return u0(e) && !Mx()
}
function KR(e, n, t = {}) {
  const [r, i, s] = Ex(e, t),
    o = (a) => {
      const l = a.currentTarget
      if (!ay(a)) return
      jc.add(l)
      const c = n(l, a),
        u = (h, p) => {
          ;(window.removeEventListener('pointerup', f),
            window.removeEventListener('pointercancel', d),
            jc.has(l) && jc.delete(l),
            ay(h) && typeof c == 'function' && c(h, { success: p }))
        },
        f = (h) => {
          u(h, l === window || l === document || t.useGlobalTarget || Tx(l, h.target))
        },
        d = (h) => {
          u(h, !1)
        }
      ;(window.addEventListener('pointerup', f, i), window.addEventListener('pointercancel', d, i))
    }
  return (
    r.forEach((a) => {
      ;((t.useGlobalTarget ? window : a).addEventListener('pointerdown', o, i),
        Cx(a) &&
          (a.addEventListener('focus', (c) => WR(c, i)),
          !qR(a) && !a.hasAttribute('tabindex') && (a.tabIndex = 0)))
    }),
    s
  )
}
function Ax(e) {
  return $w(e) && 'ownerSVGElement' in e
}
function GR(e) {
  return Ax(e) && e.tagName === 'svg'
}
const Mn = (e) => !!(e && e.getVelocity),
  XR = [...xx, Ze, qi],
  YR = (e) => XR.find(wx(e)),
  f0 = Y.createContext({ transformPagePoint: (e) => e, isStatic: !1, reducedMotion: 'never' })
function ly(e, n) {
  if (typeof e == 'function') return e(n)
  e != null && (e.current = n)
}
function ZR(...e) {
  return (n) => {
    let t = !1
    const r = e.map((i) => {
      const s = ly(i, n)
      return (!t && typeof s == 'function' && (t = !0), s)
    })
    if (t)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const s = r[i]
          typeof s == 'function' ? s() : ly(e[i], null)
        }
      }
  }
}
function JR(...e) {
  return Y.useCallback(ZR(...e), e)
}
class QR extends Y.Component {
  getSnapshotBeforeUpdate(n) {
    const t = this.props.childRef.current
    if (t && n.isPresent && !this.props.isPresent) {
      const r = t.offsetParent,
        i = (Cx(r) && r.offsetWidth) || 0,
        s = this.props.sizeRef.current
      ;((s.height = t.offsetHeight || 0),
        (s.width = t.offsetWidth || 0),
        (s.top = t.offsetTop),
        (s.left = t.offsetLeft),
        (s.right = i - s.width - s.left))
    }
    return null
  }
  componentDidUpdate() {}
  render() {
    return this.props.children
  }
}
function tO({ children: e, isPresent: n, anchorX: t, root: r }) {
  const i = Y.useId(),
    s = Y.useRef(null),
    o = Y.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }),
    { nonce: a } = Y.useContext(f0),
    l = JR(s, e?.ref)
  return (
    Y.useInsertionEffect(() => {
      const { width: c, height: u, top: f, left: d, right: h } = o.current
      if (n || !s.current || !c || !u) return
      const p = t === 'left' ? `left: ${d}` : `right: ${h}`
      s.current.dataset.motionPopId = i
      const g = document.createElement('style')
      a && (g.nonce = a)
      const m = r ?? document.head
      return (
        m.appendChild(g),
        g.sheet &&
          g.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${c}px !important;
            height: ${u}px !important;
            ${p}px !important;
            top: ${f}px !important;
          }
        `),
        () => {
          m.contains(g) && m.removeChild(g)
        }
      )
    }, [n]),
    Cn.jsx(QR, { isPresent: n, childRef: s, sizeRef: o, children: Y.cloneElement(e, { ref: l }) })
  )
}
const eO = ({
  children: e,
  initial: n,
  isPresent: t,
  onExitComplete: r,
  custom: i,
  presenceAffectsLayout: s,
  mode: o,
  anchorX: a,
  root: l,
}) => {
  const c = Vm(nO),
    u = Y.useId()
  let f = !0,
    d = Y.useMemo(
      () => (
        (f = !1),
        {
          id: u,
          initial: n,
          isPresent: t,
          custom: i,
          onExitComplete: (h) => {
            c.set(h, !0)
            for (const p of c.values()) if (!p) return
            r && r()
          },
          register: (h) => (c.set(h, !1), () => c.delete(h)),
        }
      ),
      [t, c, r],
    )
  return (
    s && f && (d = { ...d }),
    Y.useMemo(() => {
      c.forEach((h, p) => c.set(p, !1))
    }, [t]),
    Y.useEffect(() => {
      !t && !c.size && r && r()
    }, [t]),
    o === 'popLayout' && (e = Cn.jsx(tO, { isPresent: t, anchorX: a, root: l, children: e })),
    Cn.jsx(Cf.Provider, { value: d, children: e })
  )
}
function nO() {
  return new Map()
}
function Rx(e = !0) {
  const n = Y.useContext(Cf)
  if (n === null) return [!0, null]
  const { isPresent: t, onExitComplete: r, register: i } = n,
    s = Y.useId()
  Y.useEffect(() => {
    if (e) return i(s)
  }, [e])
  const o = Y.useCallback(() => e && r && r(s), [s, r, e])
  return !t && r ? [!1, o] : [!0]
}
const rc = (e) => e.key || ''
function cy(e) {
  const n = []
  return (
    Y.Children.forEach(e, (t) => {
      Y.isValidElement(t) && n.push(t)
    }),
    n
  )
}
const CZ = ({
    children: e,
    custom: n,
    initial: t = !0,
    onExitComplete: r,
    presenceAffectsLayout: i = !0,
    mode: s = 'sync',
    propagate: o = !1,
    anchorX: a = 'left',
    root: l,
  }) => {
    const [c, u] = Rx(o),
      f = Y.useMemo(() => cy(e), [e]),
      d = o && !c ? [] : f.map(rc),
      h = Y.useRef(!0),
      p = Y.useRef(f),
      g = Vm(() => new Map()),
      [m, y] = Y.useState(f),
      [b, w] = Y.useState(f)
    Bw(() => {
      ;((h.current = !1), (p.current = f))
      for (let I = 0; I < b.length; I++) {
        const B = rc(b[I])
        d.includes(B) ? g.delete(B) : g.get(B) !== !0 && g.set(B, !1)
      }
    }, [b, d.length, d.join('-')])
    const C = []
    if (f !== m) {
      let I = [...f]
      for (let B = 0; B < b.length; B++) {
        const E = b[B],
          O = rc(E)
        d.includes(O) || (I.splice(B, 0, E), C.push(E))
      }
      return (s === 'wait' && C.length && (I = C), w(cy(I)), y(f), null)
    }
    const { forceRender: T } = Y.useContext($m)
    return Cn.jsx(Cn.Fragment, {
      children: b.map((I) => {
        const B = rc(I),
          E = o && !c ? !1 : f === b || d.includes(B),
          O = () => {
            if (g.has(B)) g.set(B, !0)
            else return
            let P = !0
            ;(g.forEach(($) => {
              $ || (P = !1)
            }),
              P && (T?.(), w(p.current), o && u?.(), r && r()))
          }
        return Cn.jsx(
          eO,
          {
            isPresent: E,
            initial: !h.current || t ? void 0 : !1,
            custom: n,
            presenceAffectsLayout: i,
            mode: s,
            root: l,
            onExitComplete: E ? void 0 : O,
            anchorX: a,
            children: I,
          },
          B,
        )
      }),
    })
  },
  Ox = Y.createContext({ strict: !1 }),
  uy = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  },
  Io = {}
for (const e in uy) Io[e] = { isEnabled: (n) => uy[e].some((t) => !!n[t]) }
function rO(e) {
  for (const n in e) Io[n] = { ...Io[n], ...e[n] }
}
const iO = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport',
])
function lu(e) {
  return (
    e.startsWith('while') ||
    (e.startsWith('drag') && e !== 'draggable') ||
    e.startsWith('layout') ||
    e.startsWith('onTap') ||
    e.startsWith('onPan') ||
    e.startsWith('onLayout') ||
    iO.has(e)
  )
}
let Px = (e) => !lu(e)
function sO(e) {
  typeof e == 'function' && (Px = (n) => (n.startsWith('on') ? !lu(n) : e(n)))
}
try {
  sO(require('@emotion/is-prop-valid').default)
} catch {}
function oO(e, n, t) {
  const r = {}
  for (const i in e)
    (i === 'values' && typeof e.values == 'object') ||
      ((Px(i) ||
        (t === !0 && lu(i)) ||
        (!n && !lu(i)) ||
        (e.draggable && i.startsWith('onDrag'))) &&
        (r[i] = e[i]))
  return r
}
const Mf = Y.createContext({})
function Ef(e) {
  return e !== null && typeof e == 'object' && typeof e.start == 'function'
}
function el(e) {
  return typeof e == 'string' || Array.isArray(e)
}
const d0 = ['animate', 'whileInView', 'whileFocus', 'whileHover', 'whileTap', 'whileDrag', 'exit'],
  h0 = ['initial', ...d0]
function Tf(e) {
  return Ef(e.animate) || h0.some((n) => el(e[n]))
}
function Nx(e) {
  return !!(Tf(e) || e.variants)
}
function aO(e, n) {
  if (Tf(e)) {
    const { initial: t, animate: r } = e
    return { initial: t === !1 || el(t) ? t : void 0, animate: el(r) ? r : void 0 }
  }
  return e.inherit !== !1 ? n : {}
}
function lO(e) {
  const { initial: n, animate: t } = aO(e, Y.useContext(Mf))
  return Y.useMemo(() => ({ initial: n, animate: t }), [fy(n), fy(t)])
}
function fy(e) {
  return Array.isArray(e) ? e.join(' ') : e
}
const nl = {}
function cO(e) {
  for (const n in e) ((nl[n] = e[n]), Zm(n) && (nl[n].isCSSVariable = !0))
}
function Ix(e, { layout: n, layoutId: t }) {
  return (
    Zo.has(e) || e.startsWith('origin') || ((n || t !== void 0) && (!!nl[e] || e === 'opacity'))
  )
}
const uO = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ',
    transformPerspective: 'perspective',
  },
  fO = Yo.length
function dO(e, n, t) {
  let r = '',
    i = !0
  for (let s = 0; s < fO; s++) {
    const o = Yo[s],
      a = e[o]
    if (a === void 0) continue
    let l = !0
    if (
      (typeof a == 'number'
        ? (l = a === (o.startsWith('scale') ? 1 : 0))
        : (l = parseFloat(a) === 0),
      !l || t)
    ) {
      const c = kx(a, l0[o])
      if (!l) {
        i = !1
        const u = uO[o] || o
        r += `${u}(${c}) `
      }
      t && (n[o] = c)
    }
  }
  return ((r = r.trim()), t ? (r = t(n, i ? '' : r)) : i && (r = 'none'), r)
}
function p0(e, n, t) {
  const { style: r, vars: i, transformOrigin: s } = e
  let o = !1,
    a = !1
  for (const l in n) {
    const c = n[l]
    if (Zo.has(l)) {
      o = !0
      continue
    } else if (Zm(l)) {
      i[l] = c
      continue
    } else {
      const u = kx(c, l0[l])
      l.startsWith('origin') ? ((a = !0), (s[l] = u)) : (r[l] = u)
    }
  }
  if (
    (n.transform ||
      (o || t ? (r.transform = dO(n, e.transform, t)) : r.transform && (r.transform = 'none')),
    a)
  ) {
    const { originX: l = '50%', originY: c = '50%', originZ: u = 0 } = s
    r.transformOrigin = `${l} ${c} ${u}`
  }
}
const m0 = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} })
function Dx(e, n, t) {
  for (const r in n) !Mn(n[r]) && !Ix(r, t) && (e[r] = n[r])
}
function hO({ transformTemplate: e }, n) {
  return Y.useMemo(() => {
    const t = m0()
    return (p0(t, n, e), Object.assign({}, t.vars, t.style))
  }, [n])
}
function pO(e, n) {
  const t = e.style || {},
    r = {}
  return (Dx(r, t, e), Object.assign(r, hO(e, n)), r)
}
function mO(e, n) {
  const t = {},
    r = pO(e, n)
  return (
    e.drag &&
      e.dragListener !== !1 &&
      ((t.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = 'none'),
      (r.touchAction = e.drag === !0 ? 'none' : `pan-${e.drag === 'x' ? 'y' : 'x'}`)),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (t.tabIndex = 0),
    (t.style = r),
    t
  )
}
const gO = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  yO = { offset: 'strokeDashoffset', array: 'strokeDasharray' }
function bO(e, n, t = 1, r = 0, i = !0) {
  e.pathLength = 1
  const s = i ? gO : yO
  e[s.offset] = se.transform(-r)
  const o = se.transform(n),
    a = se.transform(t)
  e[s.array] = `${o} ${a}`
}
function jx(
  e,
  { attrX: n, attrY: t, attrScale: r, pathLength: i, pathSpacing: s = 1, pathOffset: o = 0, ...a },
  l,
  c,
  u,
) {
  if ((p0(e, a, c), l)) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox)
    return
  }
  ;((e.attrs = e.style), (e.style = {}))
  const { attrs: f, style: d } = e
  ;(f.transform && ((d.transform = f.transform), delete f.transform),
    (d.transform || f.transformOrigin) &&
      ((d.transformOrigin = f.transformOrigin ?? '50% 50%'), delete f.transformOrigin),
    d.transform && ((d.transformBox = u?.transformBox ?? 'fill-box'), delete f.transformBox),
    n !== void 0 && (f.x = n),
    t !== void 0 && (f.y = t),
    r !== void 0 && (f.scale = r),
    i !== void 0 && bO(f, i, s, o, !1))
}
const Lx = () => ({ ...m0(), attrs: {} }),
  Fx = (e) => typeof e == 'string' && e.toLowerCase() === 'svg'
function vO(e, n, t, r) {
  const i = Y.useMemo(() => {
    const s = Lx()
    return (jx(s, n, Fx(r), e.transformTemplate, e.style), { ...s.attrs, style: { ...s.style } })
  }, [n])
  if (e.style) {
    const s = {}
    ;(Dx(s, e.style, e), (i.style = { ...s, ...i.style }))
  }
  return i
}
const wO = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
]
function g0(e) {
  return typeof e != 'string' || e.includes('-') ? !1 : !!(wO.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
function xO(e, n, t, { latestValues: r }, i, s = !1) {
  const a = (g0(e) ? vO : mO)(n, r, i, e),
    l = oO(n, typeof e == 'string', s),
    c = e !== Y.Fragment ? { ...l, ...a, ref: t } : {},
    { children: u } = n,
    f = Y.useMemo(() => (Mn(u) ? u.get() : u), [u])
  return Y.createElement(e, { ...c, children: f })
}
function dy(e) {
  const n = [{}, {}]
  return (
    e?.values.forEach((t, r) => {
      ;((n[0][r] = t.get()), (n[1][r] = t.getVelocity()))
    }),
    n
  )
}
function y0(e, n, t, r) {
  if (typeof n == 'function') {
    const [i, s] = dy(r)
    n = n(t !== void 0 ? t : e.custom, i, s)
  }
  if ((typeof n == 'string' && (n = e.variants && e.variants[n]), typeof n == 'function')) {
    const [i, s] = dy(r)
    n = n(t !== void 0 ? t : e.custom, i, s)
  }
  return n
}
function Lc(e) {
  return Mn(e) ? e.get() : e
}
function SO({ scrapeMotionValuesFromProps: e, createRenderState: n }, t, r, i) {
  return { latestValues: _O(t, r, i, e), renderState: n() }
}
function _O(e, n, t, r) {
  const i = {},
    s = r(e, {})
  for (const d in s) i[d] = Lc(s[d])
  let { initial: o, animate: a } = e
  const l = Tf(e),
    c = Nx(e)
  n &&
    c &&
    !l &&
    e.inherit !== !1 &&
    (o === void 0 && (o = n.initial), a === void 0 && (a = n.animate))
  let u = t ? t.initial === !1 : !1
  u = u || o === !1
  const f = u ? a : o
  if (f && typeof f != 'boolean' && !Ef(f)) {
    const d = Array.isArray(f) ? f : [f]
    for (let h = 0; h < d.length; h++) {
      const p = y0(e, d[h])
      if (p) {
        const { transitionEnd: g, transition: m, ...y } = p
        for (const b in y) {
          let w = y[b]
          if (Array.isArray(w)) {
            const C = u ? w.length - 1 : 0
            w = w[C]
          }
          w !== null && (i[b] = w)
        }
        for (const b in g) i[b] = g[b]
      }
    }
  }
  return i
}
const Bx = (e) => (n, t) => {
  const r = Y.useContext(Mf),
    i = Y.useContext(Cf),
    s = () => SO(e, n, r, i)
  return t ? s() : Vm(s)
}
function b0(e, n, t) {
  const { style: r } = e,
    i = {}
  for (const s in r)
    (Mn(r[s]) || (n.style && Mn(n.style[s])) || Ix(s, e) || t?.getValue(s)?.liveStyle !== void 0) &&
      (i[s] = r[s])
  return i
}
const kO = Bx({ scrapeMotionValuesFromProps: b0, createRenderState: m0 })
function zx(e, n, t) {
  const r = b0(e, n, t)
  for (const i in e)
    if (Mn(e[i]) || Mn(n[i])) {
      const s = Yo.indexOf(i) !== -1 ? 'attr' + i.charAt(0).toUpperCase() + i.substring(1) : i
      r[s] = e[i]
    }
  return r
}
const CO = Bx({ scrapeMotionValuesFromProps: zx, createRenderState: Lx }),
  MO = Symbol.for('motionComponentSymbol')
function lo(e) {
  return e && typeof e == 'object' && Object.prototype.hasOwnProperty.call(e, 'current')
}
function EO(e, n, t) {
  return Y.useCallback(
    (r) => {
      ;(r && e.onMount && e.onMount(r),
        n && (r ? n.mount(r) : n.unmount()),
        t && (typeof t == 'function' ? t(r) : lo(t) && (t.current = r)))
    },
    [n],
  )
}
const v0 = (e) => e.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
  TO = 'framerAppearId',
  $x = 'data-' + v0(TO),
  Vx = Y.createContext({})
function AO(e, n, t, r, i) {
  const { visualElement: s } = Y.useContext(Mf),
    o = Y.useContext(Ox),
    a = Y.useContext(Cf),
    l = Y.useContext(f0).reducedMotion,
    c = Y.useRef(null)
  ;((r = r || o.renderer),
    !c.current &&
      r &&
      (c.current = r(e, {
        visualState: n,
        parent: s,
        props: t,
        presenceContext: a,
        blockInitialAnimation: a ? a.initial === !1 : !1,
        reducedMotionConfig: l,
      })))
  const u = c.current,
    f = Y.useContext(Vx)
  u && !u.projection && i && (u.type === 'html' || u.type === 'svg') && RO(c.current, t, i, f)
  const d = Y.useRef(!1)
  Y.useInsertionEffect(() => {
    u && d.current && u.update(t, a)
  })
  const h = t[$x],
    p = Y.useRef(
      !!h && !window.MotionHandoffIsComplete?.(h) && window.MotionHasOptimisedAnimation?.(h),
    )
  return (
    Bw(() => {
      u &&
        ((d.current = !0),
        (window.MotionIsMounted = !0),
        u.updateFeatures(),
        u.scheduleRenderMicrotask(),
        p.current && u.animationState && u.animationState.animateChanges())
    }),
    Y.useEffect(() => {
      u &&
        (!p.current && u.animationState && u.animationState.animateChanges(),
        p.current &&
          (queueMicrotask(() => {
            window.MotionHandoffMarkAsComplete?.(h)
          }),
          (p.current = !1)),
        (u.enteringChildren = void 0))
    }),
    u
  )
}
function RO(e, n, t, r) {
  const {
    layoutId: i,
    layout: s,
    drag: o,
    dragConstraints: a,
    layoutScroll: l,
    layoutRoot: c,
    layoutCrossfade: u,
  } = n
  ;((e.projection = new t(e.latestValues, n['data-framer-portal-id'] ? void 0 : Hx(e.parent))),
    e.projection.setOptions({
      layoutId: i,
      layout: s,
      alwaysMeasureLayout: !!o || (a && lo(a)),
      visualElement: e,
      animationType: typeof s == 'string' ? s : 'both',
      initialPromotionConfig: r,
      crossfade: u,
      layoutScroll: l,
      layoutRoot: c,
    }))
}
function Hx(e) {
  if (e) return e.options.allowProjection !== !1 ? e.projection : Hx(e.parent)
}
function Md(e, { forwardMotionProps: n = !1 } = {}, t, r) {
  t && rO(t)
  const i = g0(e) ? CO : kO
  function s(a, l) {
    let c
    const u = { ...Y.useContext(f0), ...a, layoutId: OO(a) },
      { isStatic: f } = u,
      d = lO(a),
      h = i(a, f)
    if (!f && Hm) {
      PO()
      const p = NO(u)
      ;((c = p.MeasureLayout), (d.visualElement = AO(e, h, u, r, p.ProjectionNode)))
    }
    return Cn.jsxs(Mf.Provider, {
      value: d,
      children: [
        c && d.visualElement ? Cn.jsx(c, { visualElement: d.visualElement, ...u }) : null,
        xO(e, a, EO(h, d.visualElement, l), h, f, n),
      ],
    })
  }
  s.displayName = `motion.${typeof e == 'string' ? e : `create(${e.displayName ?? e.name ?? ''})`}`
  const o = Y.forwardRef(s)
  return ((o[MO] = e), o)
}
function OO({ layoutId: e }) {
  const n = Y.useContext($m).id
  return n && e !== void 0 ? n + '-' + e : e
}
function PO(e, n) {
  Y.useContext(Ox).strict
}
function NO(e) {
  const { drag: n, layout: t } = Io
  if (!n && !t) return {}
  const r = { ...n, ...t }
  return {
    MeasureLayout: n?.isEnabled(e) || t?.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode,
  }
}
function IO(e, n) {
  if (typeof Proxy > 'u') return Md
  const t = new Map(),
    r = (s, o) => Md(s, o, e, n),
    i = (s, o) => r(s, o)
  return new Proxy(i, {
    get: (s, o) => (o === 'create' ? r : (t.has(o) || t.set(o, Md(o, void 0, e, n)), t.get(o))),
  })
}
function Ux({ top: e, left: n, right: t, bottom: r }) {
  return { x: { min: n, max: t }, y: { min: e, max: r } }
}
function DO({ x: e, y: n }) {
  return { top: n.min, right: e.max, bottom: n.max, left: e.min }
}
function jO(e, n) {
  if (!n) return e
  const t = n({ x: e.left, y: e.top }),
    r = n({ x: e.right, y: e.bottom })
  return { top: t.y, left: t.x, bottom: r.y, right: r.x }
}
function Ed(e) {
  return e === void 0 || e === 1
}
function hp({ scale: e, scaleX: n, scaleY: t }) {
  return !Ed(e) || !Ed(n) || !Ed(t)
}
function ns(e) {
  return hp(e) || qx(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}
function qx(e) {
  return hy(e.x) || hy(e.y)
}
function hy(e) {
  return e && e !== '0%'
}
function cu(e, n, t) {
  const r = e - t,
    i = n * r
  return t + i
}
function py(e, n, t, r, i) {
  return (i !== void 0 && (e = cu(e, i, r)), cu(e, t, r) + n)
}
function pp(e, n = 0, t = 1, r, i) {
  ;((e.min = py(e.min, n, t, r, i)), (e.max = py(e.max, n, t, r, i)))
}
function Wx(e, { x: n, y: t }) {
  ;(pp(e.x, n.translate, n.scale, n.originPoint), pp(e.y, t.translate, t.scale, t.originPoint))
}
const my = 0.999999999999,
  gy = 1.0000000000001
function LO(e, n, t, r = !1) {
  const i = t.length
  if (!i) return
  n.x = n.y = 1
  let s, o
  for (let a = 0; a < i; a++) {
    ;((s = t[a]), (o = s.projectionDelta))
    const { visualElement: l } = s.options
    ;(l && l.props.style && l.props.style.display === 'contents') ||
      (r &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        uo(e, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((n.x *= o.x.scale), (n.y *= o.y.scale), Wx(e, o)),
      r && ns(s.latestValues) && uo(e, s.latestValues))
  }
  ;(n.x < gy && n.x > my && (n.x = 1), n.y < gy && n.y > my && (n.y = 1))
}
function co(e, n) {
  ;((e.min = e.min + n), (e.max = e.max + n))
}
function yy(e, n, t, r, i = 0.5) {
  const s = Ve(e.min, e.max, i)
  pp(e, n, t, s, r)
}
function uo(e, n) {
  ;(yy(e.x, n.x, n.scaleX, n.scale, n.originX), yy(e.y, n.y, n.scaleY, n.scale, n.originY))
}
function Kx(e, n) {
  return Ux(jO(e.getBoundingClientRect(), n))
}
function FO(e, n, t) {
  const r = Kx(e, t),
    { scroll: i } = n
  return (i && (co(r.x, i.offset.x), co(r.y, i.offset.y)), r)
}
const by = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  fo = () => ({ x: by(), y: by() }),
  vy = () => ({ min: 0, max: 0 }),
  Ye = () => ({ x: vy(), y: vy() }),
  mp = { current: null },
  Gx = { current: !1 }
function BO() {
  if (((Gx.current = !0), !!Hm))
    if (window.matchMedia) {
      const e = window.matchMedia('(prefers-reduced-motion)'),
        n = () => (mp.current = e.matches)
      ;(e.addEventListener('change', n), n())
    } else mp.current = !1
}
const zO = new WeakMap()
function $O(e, n, t) {
  for (const r in n) {
    const i = n[r],
      s = t[r]
    if (Mn(i)) e.addValue(r, i)
    else if (Mn(s)) e.addValue(r, No(i, { owner: e }))
    else if (s !== i)
      if (e.hasValue(r)) {
        const o = e.getValue(r)
        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i)
      } else {
        const o = e.getStaticValue(r)
        e.addValue(r, No(o !== void 0 ? o : i, { owner: e }))
      }
  }
  for (const r in t) n[r] === void 0 && e.removeValue(r)
  return n
}
const wy = [
  'AnimationStart',
  'AnimationComplete',
  'Update',
  'BeforeLayoutMeasure',
  'LayoutMeasure',
  'LayoutAnimationStart',
  'LayoutAnimationComplete',
]
class VO {
  scrapeMotionValuesFromProps(n, t, r) {
    return {}
  }
  constructor(
    {
      parent: n,
      props: t,
      presenceContext: r,
      reducedMotionConfig: i,
      blockInitialAnimation: s,
      visualState: o,
    },
    a = {},
  ) {
    ;((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = o0),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const d = Ln.now()
        this.renderScheduledAt < d && ((this.renderScheduledAt = d), Fe.render(this.render, !1, !0))
      }))
    const { latestValues: l, renderState: c } = o
    ;((this.latestValues = l),
      (this.baseTarget = { ...l }),
      (this.initialValues = t.initial ? { ...l } : {}),
      (this.renderState = c),
      (this.parent = n),
      (this.props = t),
      (this.presenceContext = r),
      (this.depth = n ? n.depth + 1 : 0),
      (this.reducedMotionConfig = i),
      (this.options = a),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = Tf(t)),
      (this.isVariantNode = Nx(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(n && n.current)))
    const { willChange: u, ...f } = this.scrapeMotionValuesFromProps(t, {}, this)
    for (const d in f) {
      const h = f[d]
      l[d] !== void 0 && Mn(h) && h.set(l[d])
    }
  }
  mount(n) {
    ;((this.current = n),
      zO.set(n, this),
      this.projection && !this.projection.instance && this.projection.mount(n),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, r) => this.bindToMotionValue(r, t)),
      Gx.current || BO(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? !1
          : this.reducedMotionConfig === 'always'
            ? !0
            : mp.current),
      this.parent?.addChild(this),
      this.update(this.props, this.presenceContext))
  }
  unmount() {
    ;(this.projection && this.projection.unmount(),
      Ui(this.notifyUpdate),
      Ui(this.render),
      this.valueSubscriptions.forEach((n) => n()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent?.removeChild(this))
    for (const n in this.events) this.events[n].clear()
    for (const n in this.features) {
      const t = this.features[n]
      t && (t.unmount(), (t.isMounted = !1))
    }
    this.current = null
  }
  addChild(n) {
    ;(this.children.add(n),
      this.enteringChildren ?? (this.enteringChildren = new Set()),
      this.enteringChildren.add(n))
  }
  removeChild(n) {
    ;(this.children.delete(n), this.enteringChildren && this.enteringChildren.delete(n))
  }
  bindToMotionValue(n, t) {
    this.valueSubscriptions.has(n) && this.valueSubscriptions.get(n)()
    const r = Zo.has(n)
    r && this.onBindTransform && this.onBindTransform()
    const i = t.on('change', (o) => {
      ;((this.latestValues[n] = o),
        this.props.onUpdate && Fe.preRender(this.notifyUpdate),
        r && this.projection && (this.projection.isTransformDirty = !0),
        this.scheduleRender())
    })
    let s
    ;(window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, n, t)),
      this.valueSubscriptions.set(n, () => {
        ;(i(), s && s(), t.owner && t.stop())
      }))
  }
  sortNodePosition(n) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== n.type
      ? 0
      : this.sortInstanceNodePosition(this.current, n.current)
  }
  updateFeatures() {
    let n = 'animation'
    for (n in Io) {
      const t = Io[n]
      if (!t) continue
      const { isEnabled: r, Feature: i } = t
      if (
        (!this.features[n] && i && r(this.props) && (this.features[n] = new i(this)),
        this.features[n])
      ) {
        const s = this.features[n]
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0))
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props)
  }
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ye()
  }
  getStaticValue(n) {
    return this.latestValues[n]
  }
  setStaticValue(n, t) {
    this.latestValues[n] = t
  }
  update(n, t) {
    ;((n.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = n),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t))
    for (let r = 0; r < wy.length; r++) {
      const i = wy[r]
      this.propEventSubscriptions[i] &&
        (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i])
      const s = 'on' + i,
        o = n[s]
      o && (this.propEventSubscriptions[i] = this.on(i, o))
    }
    ;((this.prevMotionValues = $O(
      this,
      this.scrapeMotionValuesFromProps(n, this.prevProps, this),
      this.prevMotionValues,
    )),
      this.handleChildMotionValue && this.handleChildMotionValue())
  }
  getProps() {
    return this.props
  }
  getVariant(n) {
    return this.props.variants ? this.props.variants[n] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
  }
  addVariantChild(n) {
    const t = this.getClosestVariantNode()
    if (t) return (t.variantChildren && t.variantChildren.add(n), () => t.variantChildren.delete(n))
  }
  addValue(n, t) {
    const r = this.values.get(n)
    t !== r &&
      (r && this.removeValue(n),
      this.bindToMotionValue(n, t),
      this.values.set(n, t),
      (this.latestValues[n] = t.get()))
  }
  removeValue(n) {
    this.values.delete(n)
    const t = this.valueSubscriptions.get(n)
    ;(t && (t(), this.valueSubscriptions.delete(n)),
      delete this.latestValues[n],
      this.removeValueFromRenderState(n, this.renderState))
  }
  hasValue(n) {
    return this.values.has(n)
  }
  getValue(n, t) {
    if (this.props.values && this.props.values[n]) return this.props.values[n]
    let r = this.values.get(n)
    return (
      r === void 0 &&
        t !== void 0 &&
        ((r = No(t === null ? void 0 : t, { owner: this })), this.addValue(n, r)),
      r
    )
  }
  readValue(n, t) {
    let r =
      this.latestValues[n] !== void 0 || !this.current
        ? this.latestValues[n]
        : (this.getBaseTargetFromProps(this.props, n) ??
          this.readValueFromInstance(this.current, n, this.options))
    return (
      r != null &&
        (typeof r == 'string' && (zw(r) || Vw(r))
          ? (r = parseFloat(r))
          : !YR(r) && qi.test(t) && (r = _x(n, t)),
        this.setBaseTarget(n, Mn(r) ? r.get() : r)),
      Mn(r) ? r.get() : r
    )
  }
  setBaseTarget(n, t) {
    this.baseTarget[n] = t
  }
  getBaseTarget(n) {
    const { initial: t } = this.props
    let r
    if (typeof t == 'string' || typeof t == 'object') {
      const s = y0(this.props, t, this.presenceContext?.custom)
      s && (r = s[n])
    }
    if (t && r !== void 0) return r
    const i = this.getBaseTargetFromProps(this.props, n)
    return i !== void 0 && !Mn(i)
      ? i
      : this.initialValues[n] !== void 0 && r === void 0
        ? void 0
        : this.baseTarget[n]
  }
  on(n, t) {
    return (this.events[n] || (this.events[n] = new Gm()), this.events[n].add(t))
  }
  notify(n, ...t) {
    this.events[n] && this.events[n].notify(...t)
  }
  scheduleRenderMicrotask() {
    c0.render(this.render)
  }
}
class Xx extends VO {
  constructor() {
    ;(super(...arguments), (this.KeyframeResolver = FR))
  }
  sortInstanceNodePosition(n, t) {
    return n.compareDocumentPosition(t) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(n, t) {
    return n.style ? n.style[t] : void 0
  }
  removeValueFromRenderState(n, { vars: t, style: r }) {
    ;(delete t[n], delete r[n])
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription)
    const { children: n } = this.props
    Mn(n) &&
      (this.childSubscription = n.on('change', (t) => {
        this.current && (this.current.textContent = `${t}`)
      }))
  }
}
function Yx(e, { style: n, vars: t }, r, i) {
  const s = e.style
  let o
  for (o in n) s[o] = n[o]
  i?.applyProjectionStyles(s, r)
  for (o in t) s.setProperty(o, t[o])
}
function HO(e) {
  return window.getComputedStyle(e)
}
class UO extends Xx {
  constructor() {
    ;(super(...arguments), (this.type = 'html'), (this.renderInstance = Yx))
  }
  readValueFromInstance(n, t) {
    if (Zo.has(t)) return this.projection?.isProjecting ? op(t) : rR(n, t)
    {
      const r = HO(n),
        i = (Zm(t) ? r.getPropertyValue(t) : r[t]) || 0
      return typeof i == 'string' ? i.trim() : i
    }
  }
  measureInstanceViewportBox(n, { transformPagePoint: t }) {
    return Kx(n, t)
  }
  build(n, t, r) {
    p0(n, t, r.transformTemplate)
  }
  scrapeMotionValuesFromProps(n, t, r) {
    return b0(n, t, r)
  }
}
const Zx = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
])
function qO(e, n, t, r) {
  Yx(e, n, void 0, r)
  for (const i in n.attrs) e.setAttribute(Zx.has(i) ? i : v0(i), n.attrs[i])
}
class WO extends Xx {
  constructor() {
    ;(super(...arguments),
      (this.type = 'svg'),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = Ye))
  }
  getBaseTargetFromProps(n, t) {
    return n[t]
  }
  readValueFromInstance(n, t) {
    if (Zo.has(t)) {
      const r = Sx(t)
      return (r && r.default) || 0
    }
    return ((t = Zx.has(t) ? t : v0(t)), n.getAttribute(t))
  }
  scrapeMotionValuesFromProps(n, t, r) {
    return zx(n, t, r)
  }
  build(n, t, r) {
    jx(n, t, this.isSVGTag, r.transformTemplate, r.style)
  }
  renderInstance(n, t, r, i) {
    qO(n, t, r, i)
  }
  mount(n) {
    ;((this.isSVGTag = Fx(n.tagName)), super.mount(n))
  }
}
const KO = (e, n) => (g0(e) ? new WO(n) : new UO(n, { allowProjection: e !== Y.Fragment }))
function xo(e, n, t) {
  const r = e.getProps()
  return y0(r, n, t !== void 0 ? t : r.custom, e)
}
const gp = (e) => Array.isArray(e)
function GO(e, n, t) {
  e.hasValue(n) ? e.getValue(n).set(t) : e.addValue(n, No(t))
}
function XO(e) {
  return gp(e) ? e[e.length - 1] || 0 : e
}
function YO(e, n) {
  const t = xo(e, n)
  let { transitionEnd: r = {}, transition: i = {}, ...s } = t || {}
  s = { ...s, ...r }
  for (const o in s) {
    const a = XO(s[o])
    GO(e, o, a)
  }
}
function ZO(e) {
  return !!(Mn(e) && e.add)
}
function yp(e, n) {
  const t = e.getValue('willChange')
  if (ZO(t)) return t.add(n)
  if (!t && ii.WillChange) {
    const r = new ii.WillChange('auto')
    ;(e.addValue('willChange', r), r.add(n))
  }
}
function Jx(e) {
  return e.props[$x]
}
const JO = (e) => e !== null
function QO(e, { repeat: n, repeatType: t = 'loop' }, r) {
  const i = e.filter(JO),
    s = n && t !== 'loop' && n % 2 === 1 ? 0 : i.length - 1
  return i[s]
}
const tP = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  eP = (e) => ({
    type: 'spring',
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  nP = { type: 'keyframes', duration: 0.8 },
  rP = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  iP = (e, { keyframes: n }) =>
    n.length > 2 ? nP : Zo.has(e) ? (e.startsWith('scale') ? eP(n[1]) : tP) : rP
function sP({
  when: e,
  delay: n,
  delayChildren: t,
  staggerChildren: r,
  staggerDirection: i,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: l,
  elapsed: c,
  ...u
}) {
  return !!Object.keys(u).length
}
const w0 =
  (e, n, t, r = {}, i, s) =>
  (o) => {
    const a = a0(r, e) || {},
      l = a.delay || r.delay || 0
    let { elapsed: c = 0 } = r
    c = c - Nr(l)
    const u = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: 'easeOut',
      velocity: n.getVelocity(),
      ...a,
      delay: -c,
      onUpdate: (d) => {
        ;(n.set(d), a.onUpdate && a.onUpdate(d))
      },
      onComplete: () => {
        ;(o(), a.onComplete && a.onComplete())
      },
      name: e,
      motionValue: n,
      element: s ? void 0 : i,
    }
    ;(sP(a) || Object.assign(u, iP(e, u)),
      u.duration && (u.duration = Nr(u.duration)),
      u.repeatDelay && (u.repeatDelay = Nr(u.repeatDelay)),
      u.from !== void 0 && (u.keyframes[0] = u.from))
    let f = !1
    if (
      ((u.type === !1 || (u.duration === 0 && !u.repeatDelay)) &&
        (fp(u), u.delay === 0 && (f = !0)),
      (ii.instantAnimations || ii.skipAnimations) && ((f = !0), fp(u), (u.delay = 0)),
      (u.allowFlatten = !a.type && !a.ease),
      f && !s && n.get() !== void 0)
    ) {
      const d = QO(u.keyframes, a)
      if (d !== void 0) {
        Fe.update(() => {
          ;(u.onUpdate(d), u.onComplete())
        })
        return
      }
    }
    return a.isSync ? new s0(u) : new MR(u)
  }
function oP({ protectedKeys: e, needsAnimating: n }, t) {
  const r = e.hasOwnProperty(t) && n[t] !== !0
  return ((n[t] = !1), r)
}
function Qx(e, n, { delay: t = 0, transitionOverride: r, type: i } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: o, ...a } = n
  r && (s = r)
  const l = [],
    c = i && e.animationState && e.animationState.getState()[i]
  for (const u in a) {
    const f = e.getValue(u, e.latestValues[u] ?? null),
      d = a[u]
    if (d === void 0 || (c && oP(c, u))) continue
    const h = { delay: t, ...a0(s || {}, u) },
      p = f.get()
    if (p !== void 0 && !f.isAnimating && !Array.isArray(d) && d === p && !h.velocity) continue
    let g = !1
    if (window.MotionHandoffAnimation) {
      const y = Jx(e)
      if (y) {
        const b = window.MotionHandoffAnimation(y, u, Fe)
        b !== null && ((h.startTime = b), (g = !0))
      }
    }
    ;(yp(e, u), f.start(w0(u, f, d, e.shouldReduceMotion && vx.has(u) ? { type: !1 } : h, e, g)))
    const m = f.animation
    m && l.push(m)
  }
  return (
    o &&
      Promise.all(l).then(() => {
        Fe.update(() => {
          o && YO(e, o)
        })
      }),
    l
  )
}
function t3(e, n, t, r = 0, i = 1) {
  const s = Array.from(e)
      .sort((c, u) => c.sortNodePosition(u))
      .indexOf(n),
    o = e.size,
    a = (o - 1) * r
  return typeof t == 'function' ? t(s, o) : i === 1 ? s * r : a - s * r
}
function bp(e, n, t = {}) {
  const r = xo(e, n, t.type === 'exit' ? e.presenceContext?.custom : void 0)
  let { transition: i = e.getDefaultTransition() || {} } = r || {}
  t.transitionOverride && (i = t.transitionOverride)
  const s = r ? () => Promise.all(Qx(e, r, t)) : () => Promise.resolve(),
    o =
      e.variantChildren && e.variantChildren.size
        ? (l = 0) => {
            const { delayChildren: c = 0, staggerChildren: u, staggerDirection: f } = i
            return aP(e, n, l, c, u, f, t)
          }
        : () => Promise.resolve(),
    { when: a } = i
  if (a) {
    const [l, c] = a === 'beforeChildren' ? [s, o] : [o, s]
    return l().then(() => c())
  } else return Promise.all([s(), o(t.delay)])
}
function aP(e, n, t = 0, r = 0, i = 0, s = 1, o) {
  const a = []
  for (const l of e.variantChildren)
    (l.notify('AnimationStart', n),
      a.push(
        bp(l, n, {
          ...o,
          delay: t + (typeof r == 'function' ? 0 : r) + t3(e.variantChildren, l, r, i, s),
        }).then(() => l.notify('AnimationComplete', n)),
      ))
  return Promise.all(a)
}
function lP(e, n, t = {}) {
  e.notify('AnimationStart', n)
  let r
  if (Array.isArray(n)) {
    const i = n.map((s) => bp(e, s, t))
    r = Promise.all(i)
  } else if (typeof n == 'string') r = bp(e, n, t)
  else {
    const i = typeof n == 'function' ? xo(e, n, t.custom) : n
    r = Promise.all(Qx(e, i, t))
  }
  return r.then(() => {
    e.notify('AnimationComplete', n)
  })
}
function e3(e, n) {
  if (!Array.isArray(n)) return !1
  const t = n.length
  if (t !== e.length) return !1
  for (let r = 0; r < t; r++) if (n[r] !== e[r]) return !1
  return !0
}
const cP = h0.length
function n3(e) {
  if (!e) return
  if (!e.isControllingVariants) {
    const t = e.parent ? n3(e.parent) || {} : {}
    return (e.props.initial !== void 0 && (t.initial = e.props.initial), t)
  }
  const n = {}
  for (let t = 0; t < cP; t++) {
    const r = h0[t],
      i = e.props[r]
    ;(el(i) || i === !1) && (n[r] = i)
  }
  return n
}
const uP = [...d0].reverse(),
  fP = d0.length
function dP(e) {
  return (n) => Promise.all(n.map(({ animation: t, options: r }) => lP(e, t, r)))
}
function hP(e) {
  let n = dP(e),
    t = xy(),
    r = !0
  const i = (l) => (c, u) => {
    const f = xo(e, u, l === 'exit' ? e.presenceContext?.custom : void 0)
    if (f) {
      const { transition: d, transitionEnd: h, ...p } = f
      c = { ...c, ...p, ...h }
    }
    return c
  }
  function s(l) {
    n = l(e)
  }
  function o(l) {
    const { props: c } = e,
      u = n3(e.parent) || {},
      f = [],
      d = new Set()
    let h = {},
      p = 1 / 0
    for (let m = 0; m < fP; m++) {
      const y = uP[m],
        b = t[y],
        w = c[y] !== void 0 ? c[y] : u[y],
        C = el(w),
        T = y === l ? b.isActive : null
      T === !1 && (p = m)
      let I = w === u[y] && w !== c[y] && C
      if (
        (I && r && e.manuallyAnimateOnMount && (I = !1),
        (b.protectedKeys = { ...h }),
        (!b.isActive && T === null) || (!w && !b.prevProp) || Ef(w) || typeof w == 'boolean')
      )
        continue
      const B = pP(b.prevProp, w)
      let E = B || (y === l && b.isActive && !I && C) || (m > p && C),
        O = !1
      const P = Array.isArray(w) ? w : [w]
      let $ = P.reduce(i(y), {})
      T === !1 && ($ = {})
      const { prevResolvedValues: F = {} } = b,
        M = { ...F, ...$ },
        R = (x) => {
          ;((E = !0), d.has(x) && ((O = !0), d.delete(x)), (b.needsAnimating[x] = !0))
          const _ = e.getValue(x)
          _ && (_.liveStyle = !1)
        }
      for (const x in M) {
        const _ = $[x],
          S = F[x]
        if (h.hasOwnProperty(x)) continue
        let A = !1
        ;(gp(_) && gp(S) ? (A = !e3(_, S)) : (A = _ !== S),
          A
            ? _ != null
              ? R(x)
              : d.add(x)
            : _ !== void 0 && d.has(x)
              ? R(x)
              : (b.protectedKeys[x] = !0))
      }
      ;((b.prevProp = w),
        (b.prevResolvedValues = $),
        b.isActive && (h = { ...h, ...$ }),
        r && e.blockInitialAnimation && (E = !1))
      const k = I && B
      E &&
        (!k || O) &&
        f.push(
          ...P.map((x) => {
            const _ = { type: y }
            if (typeof x == 'string' && r && !k && e.manuallyAnimateOnMount && e.parent) {
              const { parent: S } = e,
                A = xo(S, x)
              if (S.enteringChildren && A) {
                const { delayChildren: j } = A.transition || {}
                _.delay = t3(S.enteringChildren, e, j)
              }
            }
            return { animation: x, options: _ }
          }),
        )
    }
    if (d.size) {
      const m = {}
      if (typeof c.initial != 'boolean') {
        const y = xo(e, Array.isArray(c.initial) ? c.initial[0] : c.initial)
        y && y.transition && (m.transition = y.transition)
      }
      ;(d.forEach((y) => {
        const b = e.getBaseTarget(y),
          w = e.getValue(y)
        ;(w && (w.liveStyle = !0), (m[y] = b ?? null))
      }),
        f.push({ animation: m }))
    }
    let g = !!f.length
    return (
      r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1),
      (r = !1),
      g ? n(f) : Promise.resolve()
    )
  }
  function a(l, c) {
    if (t[l].isActive === c) return Promise.resolve()
    ;(e.variantChildren?.forEach((f) => f.animationState?.setActive(l, c)), (t[l].isActive = c))
    const u = o(l)
    for (const f in t) t[f].protectedKeys = {}
    return u
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
    reset: () => {
      t = xy()
    },
  }
}
function pP(e, n) {
  return typeof n == 'string' ? n !== e : Array.isArray(n) ? !e3(n, e) : !1
}
function ts(e = !1) {
  return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} }
}
function xy() {
  return {
    animate: ts(!0),
    whileInView: ts(),
    whileHover: ts(),
    whileTap: ts(),
    whileDrag: ts(),
    whileFocus: ts(),
    exit: ts(),
  }
}
class Xi {
  constructor(n) {
    ;((this.isMounted = !1), (this.node = n))
  }
  update() {}
}
class mP extends Xi {
  constructor(n) {
    ;(super(n), n.animationState || (n.animationState = hP(n)))
  }
  updateAnimationControlsSubscription() {
    const { animate: n } = this.node.getProps()
    Ef(n) && (this.unmountControls = n.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: n } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {}
    n !== t && this.updateAnimationControlsSubscription()
  }
  unmount() {
    ;(this.node.animationState.reset(), this.unmountControls?.())
  }
}
let gP = 0
class yP extends Xi {
  constructor() {
    ;(super(...arguments), (this.id = gP++))
  }
  update() {
    if (!this.node.presenceContext) return
    const { isPresent: n, onExitComplete: t } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || n === r) return
    const i = this.node.animationState.setActive('exit', !n)
    t &&
      !n &&
      i.then(() => {
        t(this.id)
      })
  }
  mount() {
    const { register: n, onExitComplete: t } = this.node.presenceContext || {}
    ;(t && t(this.id), n && (this.unmount = n(this.id)))
  }
  unmount() {}
}
const bP = { animation: { Feature: mP }, exit: { Feature: yP } }
function rl(e, n, t, r = { passive: !0 }) {
  return (e.addEventListener(n, t, r), () => e.removeEventListener(n, t))
}
function Tl(e) {
  return { point: { x: e.pageX, y: e.pageY } }
}
const vP = (e) => (n) => u0(n) && e(n, Tl(n))
function Oa(e, n, t, r) {
  return rl(e, n, vP(t), r)
}
const r3 = 1e-4,
  wP = 1 - r3,
  xP = 1 + r3,
  i3 = 0.01,
  SP = 0 - i3,
  _P = 0 + i3
function Rn(e) {
  return e.max - e.min
}
function kP(e, n, t) {
  return Math.abs(e - n) <= t
}
function Sy(e, n, t, r = 0.5) {
  ;((e.origin = r),
    (e.originPoint = Ve(n.min, n.max, e.origin)),
    (e.scale = Rn(t) / Rn(n)),
    (e.translate = Ve(t.min, t.max, e.origin) - e.originPoint),
    ((e.scale >= wP && e.scale <= xP) || isNaN(e.scale)) && (e.scale = 1),
    ((e.translate >= SP && e.translate <= _P) || isNaN(e.translate)) && (e.translate = 0))
}
function Pa(e, n, t, r) {
  ;(Sy(e.x, n.x, t.x, r ? r.originX : void 0), Sy(e.y, n.y, t.y, r ? r.originY : void 0))
}
function _y(e, n, t) {
  ;((e.min = t.min + n.min), (e.max = e.min + Rn(n)))
}
function CP(e, n, t) {
  ;(_y(e.x, n.x, t.x), _y(e.y, n.y, t.y))
}
function ky(e, n, t) {
  ;((e.min = n.min - t.min), (e.max = e.min + Rn(n)))
}
function Na(e, n, t) {
  ;(ky(e.x, n.x, t.x), ky(e.y, n.y, t.y))
}
function Zn(e) {
  return [e('x'), e('y')]
}
const s3 = ({ current: e }) => (e ? e.ownerDocument.defaultView : null),
  Cy = (e, n) => Math.abs(e - n)
function MP(e, n) {
  const t = Cy(e.x, n.x),
    r = Cy(e.y, n.y)
  return Math.sqrt(t ** 2 + r ** 2)
}
class o3 {
  constructor(
    n,
    t,
    {
      transformPagePoint: r,
      contextWindow: i = window,
      dragSnapToOrigin: s = !1,
      distanceThreshold: o = 3,
    } = {},
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const d = Ad(this.lastMoveEventInfo, this.history),
          h = this.startEvent !== null,
          p = MP(d.offset, { x: 0, y: 0 }) >= this.distanceThreshold
        if (!h && !p) return
        const { point: g } = d,
          { timestamp: m } = bn
        this.history.push({ ...g, timestamp: m })
        const { onStart: y, onMove: b } = this.handlers
        ;(h || (y && y(this.lastMoveEvent, d), (this.startEvent = this.lastMoveEvent)),
          b && b(this.lastMoveEvent, d))
      }),
      (this.handlePointerMove = (d, h) => {
        ;((this.lastMoveEvent = d),
          (this.lastMoveEventInfo = Td(h, this.transformPagePoint)),
          Fe.update(this.updatePoint, !0))
      }),
      (this.handlePointerUp = (d, h) => {
        this.end()
        const { onEnd: p, onSessionEnd: g, resumeAnimation: m } = this.handlers
        if ((this.dragSnapToOrigin && m && m(), !(this.lastMoveEvent && this.lastMoveEventInfo)))
          return
        const y = Ad(
          d.type === 'pointercancel' ? this.lastMoveEventInfo : Td(h, this.transformPagePoint),
          this.history,
        )
        ;(this.startEvent && p && p(d, y), g && g(d, y))
      }),
      !u0(n))
    )
      return
    ;((this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = r),
      (this.distanceThreshold = o),
      (this.contextWindow = i || window))
    const a = Tl(n),
      l = Td(a, this.transformPagePoint),
      { point: c } = l,
      { timestamp: u } = bn
    this.history = [{ ...c, timestamp: u }]
    const { onSessionStart: f } = t
    ;(f && f(n, Ad(l, this.history)),
      (this.removeListeners = Cl(
        Oa(this.contextWindow, 'pointermove', this.handlePointerMove),
        Oa(this.contextWindow, 'pointerup', this.handlePointerUp),
        Oa(this.contextWindow, 'pointercancel', this.handlePointerUp),
      )))
  }
  updateHandlers(n) {
    this.handlers = n
  }
  end() {
    ;(this.removeListeners && this.removeListeners(), Ui(this.updatePoint))
  }
}
function Td(e, n) {
  return n ? { point: n(e.point) } : e
}
function My(e, n) {
  return { x: e.x - n.x, y: e.y - n.y }
}
function Ad({ point: e }, n) {
  return { point: e, delta: My(e, a3(n)), offset: My(e, EP(n)), velocity: TP(n, 0.1) }
}
function EP(e) {
  return e[0]
}
function a3(e) {
  return e[e.length - 1]
}
function TP(e, n) {
  if (e.length < 2) return { x: 0, y: 0 }
  let t = e.length - 1,
    r = null
  const i = a3(e)
  for (; t >= 0 && ((r = e[t]), !(i.timestamp - r.timestamp > Nr(n))); ) t--
  if (!r) return { x: 0, y: 0 }
  const s = sr(i.timestamp - r.timestamp)
  if (s === 0) return { x: 0, y: 0 }
  const o = { x: (i.x - r.x) / s, y: (i.y - r.y) / s }
  return (o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o)
}
function AP(e, { min: n, max: t }, r) {
  return (
    n !== void 0 && e < n
      ? (e = r ? Ve(n, e, r.min) : Math.max(e, n))
      : t !== void 0 && e > t && (e = r ? Ve(t, e, r.max) : Math.min(e, t)),
    e
  )
}
function Ey(e, n, t) {
  return {
    min: n !== void 0 ? e.min + n : void 0,
    max: t !== void 0 ? e.max + t - (e.max - e.min) : void 0,
  }
}
function RP(e, { top: n, left: t, bottom: r, right: i }) {
  return { x: Ey(e.x, t, i), y: Ey(e.y, n, r) }
}
function Ty(e, n) {
  let t = n.min - e.min,
    r = n.max - e.max
  return (n.max - n.min < e.max - e.min && ([t, r] = [r, t]), { min: t, max: r })
}
function OP(e, n) {
  return { x: Ty(e.x, n.x), y: Ty(e.y, n.y) }
}
function PP(e, n) {
  let t = 0.5
  const r = Rn(e),
    i = Rn(n)
  return (
    i > r ? (t = Ja(n.min, n.max - r, e.min)) : r > i && (t = Ja(e.min, e.max - i, n.min)),
    ri(0, 1, t)
  )
}
function NP(e, n) {
  const t = {}
  return (
    n.min !== void 0 && (t.min = n.min - e.min),
    n.max !== void 0 && (t.max = n.max - e.min),
    t
  )
}
const vp = 0.35
function IP(e = vp) {
  return (
    e === !1 ? (e = 0) : e === !0 && (e = vp),
    { x: Ay(e, 'left', 'right'), y: Ay(e, 'top', 'bottom') }
  )
}
function Ay(e, n, t) {
  return { min: Ry(e, n), max: Ry(e, t) }
}
function Ry(e, n) {
  return typeof e == 'number' ? e : e[n] || 0
}
const DP = new WeakMap()
class jP {
  constructor(n) {
    ;((this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Ye()),
      (this.latestPointerEvent = null),
      (this.latestPanInfo = null),
      (this.visualElement = n))
  }
  start(n, { snapToCursor: t = !1, distanceThreshold: r } = {}) {
    const { presenceContext: i } = this.visualElement
    if (i && i.isPresent === !1) return
    const s = (f) => {
        const { dragSnapToOrigin: d } = this.getProps()
        ;(d ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(Tl(f).point))
      },
      o = (f, d) => {
        const { drag: h, dragPropagation: p, onDragStart: g } = this.getProps()
        if (
          h &&
          !p &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = VR(h)),
          !this.openDragLock)
        )
          return
        ;((this.latestPointerEvent = f),
          (this.latestPanInfo = d),
          (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Zn((y) => {
            let b = this.getAxisMotionValue(y).get() || 0
            if (Ir.test(b)) {
              const { projection: w } = this.visualElement
              if (w && w.layout) {
                const C = w.layout.layoutBox[y]
                C && (b = Rn(C) * (parseFloat(b) / 100))
              }
            }
            this.originPoint[y] = b
          }),
          g && Fe.postRender(() => g(f, d)),
          yp(this.visualElement, 'transform'))
        const { animationState: m } = this.visualElement
        m && m.setActive('whileDrag', !0)
      },
      a = (f, d) => {
        ;((this.latestPointerEvent = f), (this.latestPanInfo = d))
        const {
          dragPropagation: h,
          dragDirectionLock: p,
          onDirectionLock: g,
          onDrag: m,
        } = this.getProps()
        if (!h && !this.openDragLock) return
        const { offset: y } = d
        if (p && this.currentDirection === null) {
          ;((this.currentDirection = LP(y)),
            this.currentDirection !== null && g && g(this.currentDirection))
          return
        }
        ;(this.updateAxis('x', d.point, y),
          this.updateAxis('y', d.point, y),
          this.visualElement.render(),
          m && m(f, d))
      },
      l = (f, d) => {
        ;((this.latestPointerEvent = f),
          (this.latestPanInfo = d),
          this.stop(f, d),
          (this.latestPointerEvent = null),
          (this.latestPanInfo = null))
      },
      c = () =>
        Zn(
          (f) =>
            this.getAnimationState(f) === 'paused' && this.getAxisMotionValue(f).animation?.play(),
        ),
      { dragSnapToOrigin: u } = this.getProps()
    this.panSession = new o3(
      n,
      { onSessionStart: s, onStart: o, onMove: a, onSessionEnd: l, resumeAnimation: c },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        distanceThreshold: r,
        contextWindow: s3(this.visualElement),
      },
    )
  }
  stop(n, t) {
    const r = n || this.latestPointerEvent,
      i = t || this.latestPanInfo,
      s = this.isDragging
    if ((this.cancel(), !s || !i || !r)) return
    const { velocity: o } = i
    this.startAnimation(o)
    const { onDragEnd: a } = this.getProps()
    a && Fe.postRender(() => a(r, i))
  }
  cancel() {
    this.isDragging = !1
    const { projection: n, animationState: t } = this.visualElement
    ;(n && (n.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0))
    const { dragPropagation: r } = this.getProps()
    ;(!r && this.openDragLock && (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive('whileDrag', !1))
  }
  updateAxis(n, t, r) {
    const { drag: i } = this.getProps()
    if (!r || !ic(n, i, this.currentDirection)) return
    const s = this.getAxisMotionValue(n)
    let o = this.originPoint[n] + r[n]
    ;(this.constraints && this.constraints[n] && (o = AP(o, this.constraints[n], this.elastic[n])),
      s.set(o))
  }
  resolveConstraints() {
    const { dragConstraints: n, dragElastic: t } = this.getProps(),
      r =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : this.visualElement.projection?.layout,
      i = this.constraints
    ;(n && lo(n)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : n && r
        ? (this.constraints = RP(r.layoutBox, n))
        : (this.constraints = !1),
      (this.elastic = IP(t)),
      i !== this.constraints &&
        r &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Zn((s) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(s) &&
            (this.constraints[s] = NP(r.layoutBox[s], this.constraints[s]))
        }))
  }
  resolveRefConstraints() {
    const { dragConstraints: n, onMeasureDragConstraints: t } = this.getProps()
    if (!n || !lo(n)) return !1
    const r = n.current,
      { projection: i } = this.visualElement
    if (!i || !i.layout) return !1
    const s = FO(r, i.root, this.visualElement.getTransformPagePoint())
    let o = OP(i.layout.layoutBox, s)
    if (t) {
      const a = t(DO(o))
      ;((this.hasMutatedConstraints = !!a), a && (o = Ux(a)))
    }
    return o
  }
  startAnimation(n) {
    const {
        drag: t,
        dragMomentum: r,
        dragElastic: i,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      l = this.constraints || {},
      c = Zn((u) => {
        if (!ic(u, t, this.currentDirection)) return
        let f = (l && l[u]) || {}
        o && (f = { min: 0, max: 0 })
        const d = i ? 200 : 1e6,
          h = i ? 40 : 1e7,
          p = {
            type: 'inertia',
            velocity: r ? n[u] : 0,
            bounceStiffness: d,
            bounceDamping: h,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...f,
          }
        return this.startAxisValueAnimation(u, p)
      })
    return Promise.all(c).then(a)
  }
  startAxisValueAnimation(n, t) {
    const r = this.getAxisMotionValue(n)
    return (yp(this.visualElement, n), r.start(w0(n, r, 0, t, this.visualElement, !1)))
  }
  stopAnimation() {
    Zn((n) => this.getAxisMotionValue(n).stop())
  }
  pauseAnimation() {
    Zn((n) => this.getAxisMotionValue(n).animation?.pause())
  }
  getAnimationState(n) {
    return this.getAxisMotionValue(n).animation?.state
  }
  getAxisMotionValue(n) {
    const t = `_drag${n.toUpperCase()}`,
      r = this.visualElement.getProps(),
      i = r[t]
    return i || this.visualElement.getValue(n, (r.initial ? r.initial[n] : void 0) || 0)
  }
  snapToCursor(n) {
    Zn((t) => {
      const { drag: r } = this.getProps()
      if (!ic(t, r, this.currentDirection)) return
      const { projection: i } = this.visualElement,
        s = this.getAxisMotionValue(t)
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[t]
        s.set(n[t] - Ve(o, a, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: n, dragConstraints: t } = this.getProps(),
      { projection: r } = this.visualElement
    if (!lo(t) || !r || !this.constraints) return
    this.stopAnimation()
    const i = { x: 0, y: 0 }
    Zn((o) => {
      const a = this.getAxisMotionValue(o)
      if (a && this.constraints !== !1) {
        const l = a.get()
        i[o] = PP({ min: l, max: l }, this.constraints[o])
      }
    })
    const { transformTemplate: s } = this.visualElement.getProps()
    ;((this.visualElement.current.style.transform = s ? s({}, '') : 'none'),
      r.root && r.root.updateScroll(),
      r.updateLayout(),
      this.resolveConstraints(),
      Zn((o) => {
        if (!ic(o, n, null)) return
        const a = this.getAxisMotionValue(o),
          { min: l, max: c } = this.constraints[o]
        a.set(Ve(l, c, i[o]))
      }))
  }
  addListeners() {
    if (!this.visualElement.current) return
    DP.set(this.visualElement, this)
    const n = this.visualElement.current,
      t = Oa(n, 'pointerdown', (l) => {
        const { drag: c, dragListener: u = !0 } = this.getProps()
        c && u && this.start(l)
      }),
      r = () => {
        const { dragConstraints: l } = this.getProps()
        lo(l) && l.current && (this.constraints = this.resolveRefConstraints())
      },
      { projection: i } = this.visualElement,
      s = i.addEventListener('measure', r)
    ;(i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Fe.read(r))
    const o = rl(window, 'resize', () => this.scalePositionWithinConstraints()),
      a = i.addEventListener('didUpdate', ({ delta: l, hasLayoutChanged: c }) => {
        this.isDragging &&
          c &&
          (Zn((u) => {
            const f = this.getAxisMotionValue(u)
            f && ((this.originPoint[u] += l[u].translate), f.set(f.get() + l[u].translate))
          }),
          this.visualElement.render())
      })
    return () => {
      ;(o(), t(), s(), a && a())
    }
  }
  getProps() {
    const n = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: r = !1,
        dragPropagation: i = !1,
        dragConstraints: s = !1,
        dragElastic: o = vp,
        dragMomentum: a = !0,
      } = n
    return {
      ...n,
      drag: t,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    }
  }
}
function ic(e, n, t) {
  return (n === !0 || n === e) && (t === null || t === e)
}
function LP(e, n = 10) {
  let t = null
  return (Math.abs(e.y) > n ? (t = 'y') : Math.abs(e.x) > n && (t = 'x'), t)
}
class FP extends Xi {
  constructor(n) {
    ;(super(n),
      (this.removeGroupControls = ar),
      (this.removeListeners = ar),
      (this.controls = new jP(n)))
  }
  mount() {
    const { dragControls: n } = this.node.getProps()
    ;(n && (this.removeGroupControls = n.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || ar))
  }
  unmount() {
    ;(this.removeGroupControls(), this.removeListeners())
  }
}
const Oy = (e) => (n, t) => {
  e && Fe.postRender(() => e(n, t))
}
class BP extends Xi {
  constructor() {
    ;(super(...arguments), (this.removePointerDownListener = ar))
  }
  onPointerDown(n) {
    this.session = new o3(n, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: s3(this.node),
    })
  }
  createPanHandlers() {
    const { onPanSessionStart: n, onPanStart: t, onPan: r, onPanEnd: i } = this.node.getProps()
    return {
      onSessionStart: Oy(n),
      onStart: Oy(t),
      onMove: r,
      onEnd: (s, o) => {
        ;(delete this.session, i && Fe.postRender(() => i(s, o)))
      },
    }
  }
  mount() {
    this.removePointerDownListener = Oa(this.node.current, 'pointerdown', (n) =>
      this.onPointerDown(n),
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    ;(this.removePointerDownListener(), this.session && this.session.end())
  }
}
const Fc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function Py(e, n) {
  return n.max === n.min ? 0 : (e / (n.max - n.min)) * 100
}
const la = {
    correct: (e, n) => {
      if (!n.target) return e
      if (typeof e == 'string')
        if (se.test(e)) e = parseFloat(e)
        else return e
      const t = Py(e, n.target.x),
        r = Py(e, n.target.y)
      return `${t}% ${r}%`
    },
  },
  zP = {
    correct: (e, { treeScale: n, projectionDelta: t }) => {
      const r = e,
        i = qi.parse(e)
      if (i.length > 5) return r
      const s = qi.createTransformer(e),
        o = typeof i[0] != 'number' ? 1 : 0,
        a = t.x.scale * n.x,
        l = t.y.scale * n.y
      ;((i[0 + o] /= a), (i[1 + o] /= l))
      const c = Ve(a, l, 0.5)
      return (
        typeof i[2 + o] == 'number' && (i[2 + o] /= c),
        typeof i[3 + o] == 'number' && (i[3 + o] /= c),
        s(i)
      )
    },
  }
let Rd = !1
class $P extends Y.Component {
  componentDidMount() {
    const { visualElement: n, layoutGroup: t, switchLayoutGroup: r, layoutId: i } = this.props,
      { projection: s } = n
    ;(cO(VP),
      s &&
        (t.group && t.group.add(s),
        r && r.register && i && r.register(s),
        Rd && s.root.didUpdate(),
        s.addEventListener('animationComplete', () => {
          this.safeToRemove()
        }),
        s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })),
      (Fc.hasEverUpdated = !0))
  }
  getSnapshotBeforeUpdate(n) {
    const { layoutDependency: t, visualElement: r, drag: i, isPresent: s } = this.props,
      { projection: o } = r
    return (
      o &&
        ((o.isPresent = s),
        (Rd = !0),
        i || n.layoutDependency !== t || t === void 0 || n.isPresent !== s
          ? o.willUpdate()
          : this.safeToRemove(),
        n.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              Fe.postRender(() => {
                const a = o.getStack()
                ;(!a || !a.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: n } = this.props.visualElement
    n &&
      (n.root.didUpdate(),
      c0.postRender(() => {
        !n.currentAnimation && n.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const { visualElement: n, layoutGroup: t, switchLayoutGroup: r } = this.props,
      { projection: i } = n
    ;((Rd = !0),
      i &&
        (i.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(i),
        r && r.deregister && r.deregister(i)))
  }
  safeToRemove() {
    const { safeToRemove: n } = this.props
    n && n()
  }
  render() {
    return null
  }
}
function l3(e) {
  const [n, t] = Rx(),
    r = Y.useContext($m)
  return Cn.jsx($P, {
    ...e,
    layoutGroup: r,
    switchLayoutGroup: Y.useContext(Vx),
    isPresent: n,
    safeToRemove: t,
  })
}
const VP = {
  borderRadius: {
    ...la,
    applyTo: [
      'borderTopLeftRadius',
      'borderTopRightRadius',
      'borderBottomLeftRadius',
      'borderBottomRightRadius',
    ],
  },
  borderTopLeftRadius: la,
  borderTopRightRadius: la,
  borderBottomLeftRadius: la,
  borderBottomRightRadius: la,
  boxShadow: zP,
}
function HP(e, n, t) {
  const r = Mn(e) ? e : No(e)
  return (r.start(w0('', r, n, t)), r.animation)
}
const UP = (e, n) => e.depth - n.depth
class qP {
  constructor() {
    ;((this.children = []), (this.isDirty = !1))
  }
  add(n) {
    ;(Um(this.children, n), (this.isDirty = !0))
  }
  remove(n) {
    ;(qm(this.children, n), (this.isDirty = !0))
  }
  forEach(n) {
    ;(this.isDirty && this.children.sort(UP), (this.isDirty = !1), this.children.forEach(n))
  }
}
function WP(e, n) {
  const t = Ln.now(),
    r = ({ timestamp: i }) => {
      const s = i - t
      s >= n && (Ui(r), e(s - n))
    }
  return (Fe.setup(r, !0), () => Ui(r))
}
const c3 = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  KP = c3.length,
  Ny = (e) => (typeof e == 'string' ? parseFloat(e) : e),
  Iy = (e) => typeof e == 'number' || se.test(e)
function GP(e, n, t, r, i, s) {
  i
    ? ((e.opacity = Ve(0, t.opacity ?? 1, XP(r))), (e.opacityExit = Ve(n.opacity ?? 1, 0, YP(r))))
    : s && (e.opacity = Ve(n.opacity ?? 1, t.opacity ?? 1, r))
  for (let o = 0; o < KP; o++) {
    const a = `border${c3[o]}Radius`
    let l = Dy(n, a),
      c = Dy(t, a)
    if (l === void 0 && c === void 0) continue
    ;(l || (l = 0),
      c || (c = 0),
      l === 0 || c === 0 || Iy(l) === Iy(c)
        ? ((e[a] = Math.max(Ve(Ny(l), Ny(c), r), 0)), (Ir.test(c) || Ir.test(l)) && (e[a] += '%'))
        : (e[a] = c))
  }
  ;(n.rotate || t.rotate) && (e.rotate = Ve(n.rotate || 0, t.rotate || 0, r))
}
function Dy(e, n) {
  return e[n] !== void 0 ? e[n] : e.borderRadius
}
const XP = u3(0, 0.5, Yw),
  YP = u3(0.5, 0.95, ar)
function u3(e, n, t) {
  return (r) => (r < e ? 0 : r > n ? 1 : t(Ja(e, n, r)))
}
function jy(e, n) {
  ;((e.min = n.min), (e.max = n.max))
}
function Xn(e, n) {
  ;(jy(e.x, n.x), jy(e.y, n.y))
}
function Ly(e, n) {
  ;((e.translate = n.translate),
    (e.scale = n.scale),
    (e.originPoint = n.originPoint),
    (e.origin = n.origin))
}
function Fy(e, n, t, r, i) {
  return ((e -= n), (e = cu(e, 1 / t, r)), i !== void 0 && (e = cu(e, 1 / i, r)), e)
}
function ZP(e, n = 0, t = 1, r = 0.5, i, s = e, o = e) {
  if (
    (Ir.test(n) && ((n = parseFloat(n)), (n = Ve(o.min, o.max, n / 100) - o.min)),
    typeof n != 'number')
  )
    return
  let a = Ve(s.min, s.max, r)
  ;(e === s && (a -= n), (e.min = Fy(e.min, n, t, a, i)), (e.max = Fy(e.max, n, t, a, i)))
}
function By(e, n, [t, r, i], s, o) {
  ZP(e, n[t], n[r], n[i], n.scale, s, o)
}
const JP = ['x', 'scaleX', 'originX'],
  QP = ['y', 'scaleY', 'originY']
function zy(e, n, t, r) {
  ;(By(e.x, n, JP, t ? t.x : void 0, r ? r.x : void 0),
    By(e.y, n, QP, t ? t.y : void 0, r ? r.y : void 0))
}
function $y(e) {
  return e.translate === 0 && e.scale === 1
}
function f3(e) {
  return $y(e.x) && $y(e.y)
}
function Vy(e, n) {
  return e.min === n.min && e.max === n.max
}
function tN(e, n) {
  return Vy(e.x, n.x) && Vy(e.y, n.y)
}
function Hy(e, n) {
  return Math.round(e.min) === Math.round(n.min) && Math.round(e.max) === Math.round(n.max)
}
function d3(e, n) {
  return Hy(e.x, n.x) && Hy(e.y, n.y)
}
function Uy(e) {
  return Rn(e.x) / Rn(e.y)
}
function qy(e, n) {
  return e.translate === n.translate && e.scale === n.scale && e.originPoint === n.originPoint
}
class eN {
  constructor() {
    this.members = []
  }
  add(n) {
    ;(Um(this.members, n), n.scheduleRender())
  }
  remove(n) {
    if ((qm(this.members, n), n === this.prevLead && (this.prevLead = void 0), n === this.lead)) {
      const t = this.members[this.members.length - 1]
      t && this.promote(t)
    }
  }
  relegate(n) {
    const t = this.members.findIndex((i) => n === i)
    if (t === 0) return !1
    let r
    for (let i = t; i >= 0; i--) {
      const s = this.members[i]
      if (s.isPresent !== !1) {
        r = s
        break
      }
    }
    return r ? (this.promote(r), !0) : !1
  }
  promote(n, t) {
    const r = this.lead
    if (n !== r && ((this.prevLead = r), (this.lead = n), n.show(), r)) {
      ;(r.instance && r.scheduleRender(),
        n.scheduleRender(),
        (n.resumeFrom = r),
        t && (n.resumeFrom.preserveOpacity = !0),
        r.snapshot &&
          ((n.snapshot = r.snapshot),
          (n.snapshot.latestValues = r.animationValues || r.latestValues)),
        n.root && n.root.isUpdating && (n.isLayoutDirty = !0))
      const { crossfade: i } = n.options
      i === !1 && r.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((n) => {
      const { options: t, resumingFrom: r } = n
      ;(t.onExitComplete && t.onExitComplete(),
        r && r.options.onExitComplete && r.options.onExitComplete())
    })
  }
  scheduleRender() {
    this.members.forEach((n) => {
      n.instance && n.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function nN(e, n, t) {
  let r = ''
  const i = e.x.translate / n.x,
    s = e.y.translate / n.y,
    o = t?.z || 0
  if (
    ((i || s || o) && (r = `translate3d(${i}px, ${s}px, ${o}px) `),
    (n.x !== 1 || n.y !== 1) && (r += `scale(${1 / n.x}, ${1 / n.y}) `),
    t)
  ) {
    const { transformPerspective: c, rotate: u, rotateX: f, rotateY: d, skewX: h, skewY: p } = t
    ;(c && (r = `perspective(${c}px) ${r}`),
      u && (r += `rotate(${u}deg) `),
      f && (r += `rotateX(${f}deg) `),
      d && (r += `rotateY(${d}deg) `),
      h && (r += `skewX(${h}deg) `),
      p && (r += `skewY(${p}deg) `))
  }
  const a = e.x.scale * n.x,
    l = e.y.scale * n.y
  return ((a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || 'none')
}
const Od = ['', 'X', 'Y', 'Z'],
  rN = 1e3
let iN = 0
function Pd(e, n, t, r) {
  const { latestValues: i } = n
  i[e] && ((t[e] = i[e]), n.setStaticValue(e, 0), r && (r[e] = 0))
}
function h3(e) {
  if (((e.hasCheckedOptimisedAppear = !0), e.root === e)) return
  const { visualElement: n } = e.options
  if (!n) return
  const t = Jx(n)
  if (window.MotionHasOptimisedAnimation(t, 'transform')) {
    const { layout: i, layoutId: s } = e.options
    window.MotionCancelOptimisedAnimation(t, 'transform', Fe, !(i || s))
  }
  const { parent: r } = e
  r && !r.hasCheckedOptimisedAppear && h3(r)
}
function p3({
  attachResizeListener: e,
  defaultParent: n,
  measureScroll: t,
  checkIsScrollRoot: r,
  resetTransform: i,
}) {
  return class {
    constructor(o = {}, a = n?.()) {
      ;((this.id = iN++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;((this.projectionUpdateScheduled = !1),
            this.nodes.forEach(aN),
            this.nodes.forEach(fN),
            this.nodes.forEach(dN),
            this.nodes.forEach(lN))
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0))
      for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = !0
      this.root === this && (this.nodes = new qP())
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new Gm()),
        this.eventHandlers.get(o).add(a)
      )
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o)
      l && l.notify(...a)
    }
    hasListeners(o) {
      return this.eventHandlers.has(o)
    }
    mount(o) {
      if (this.instance) return
      ;((this.isSVG = Ax(o) && !GR(o)), (this.instance = o))
      const { layoutId: a, layout: l, visualElement: c } = this.options
      if (
        (c && !c.current && c.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0),
        e)
      ) {
        let u,
          f = 0
        const d = () => (this.root.updateBlockedByResize = !1)
        ;(Fe.read(() => {
          f = window.innerWidth
        }),
          e(o, () => {
            const h = window.innerWidth
            h !== f &&
              ((f = h),
              (this.root.updateBlockedByResize = !0),
              u && u(),
              (u = WP(d, 250)),
              Fc.hasAnimatedSinceResize &&
                ((Fc.hasAnimatedSinceResize = !1), this.nodes.forEach(Gy)))
          }))
      }
      ;(a && this.root.registerSharedNode(a, this),
        this.options.animate !== !1 &&
          c &&
          (a || l) &&
          this.addEventListener(
            'didUpdate',
            ({ delta: u, hasLayoutChanged: f, hasRelativeLayoutChanged: d, layout: h }) => {
              if (this.isTreeAnimationBlocked()) {
                ;((this.target = void 0), (this.relativeTarget = void 0))
                return
              }
              const p = this.options.transition || c.getDefaultTransition() || yN,
                { onLayoutAnimationStart: g, onLayoutAnimationComplete: m } = c.getProps(),
                y = !this.targetLayout || !d3(this.targetLayout, h),
                b = !f && d
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                b ||
                (f && (y || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom), (this.resumingFrom.resumingFrom = void 0))
                const w = { ...a0(p, 'layout'), onPlay: g, onComplete: m }
                ;((c.shouldReduceMotion || this.options.layoutRoot) &&
                  ((w.delay = 0), (w.type = !1)),
                  this.startAnimation(w),
                  this.setAnimationOrigin(u, b))
              } else
                (f || Gy(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete())
              this.targetLayout = h
            },
          ))
    }
    unmount() {
      ;(this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this))
      const o = this.getStack()
      ;(o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        Ui(this.updateProjection))
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || !1
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0), this.nodes && this.nodes.forEach(hN), this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options
      return o && o.getProps().transformTemplate
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && h3(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u]
        ;((f.shouldResetTransform = !0),
          f.updateScroll('snapshot'),
          f.options.layoutRoot && f.willUpdate(!1))
      }
      const { layoutId: a, layout: l } = this.options
      if (a === void 0 && !l) return
      const c = this.getTransformTemplate()
      ;((this.prevTransformTemplateValue = c ? c(this.latestValues, '') : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners('willUpdate'))
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        ;(this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Wy))
        return
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(Ky)
        return
      }
      ;((this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(uN),
            this.nodes.forEach(sN),
            this.nodes.forEach(oN))
          : this.nodes.forEach(Ky),
        this.clearAllSnapshots())
      const a = Ln.now()
      ;((bn.delta = ri(0, 1e3 / 60, a - bn.timestamp)),
        (bn.timestamp = a),
        (bn.isProcessing = !0),
        wd.update.process(bn),
        wd.preRender.process(bn),
        wd.render.process(bn),
        (bn.isProcessing = !1))
    }
    didUpdate() {
      this.updateScheduled || ((this.updateScheduled = !0), c0.read(this.scheduleUpdate))
    }
    clearAllSnapshots() {
      ;(this.nodes.forEach(cN), this.sharedNodes.forEach(pN))
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0), Fe.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      Fe.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !Rn(this.snapshot.measuredBox.x) &&
          !Rn(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0))
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll()
      const o = this.layout
      ;((this.layout = this.measure(!1)),
        (this.layoutCorrected = Ye()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox))
      const { visualElement: a } = this.options
      a && a.notify('LayoutMeasure', this.layout.layoutBox, o ? o.layoutBox : void 0)
    }
    updateScroll(o = 'measure') {
      let a = !!(this.options.layoutScroll && this.instance)
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === o &&
          (a = !1),
        a && this.instance)
      ) {
        const l = r(this.instance)
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: l,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l,
        }
      }
    }
    resetTransform() {
      if (!i) return
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
        a = this.projectionDelta && !f3(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, '') : void 0,
        u = c !== this.prevTransformTemplateValue
      o &&
        this.instance &&
        (a || ns(this.latestValues) || u) &&
        (i(this.instance, c), (this.shouldResetTransform = !1), this.scheduleRender())
    }
    measure(o = !0) {
      const a = this.measurePageBox()
      let l = this.removeElementScroll(a)
      return (
        o && (l = this.removeTransform(l)),
        bN(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      )
    }
    measurePageBox() {
      const { visualElement: o } = this.options
      if (!o) return Ye()
      const a = o.measureViewportBox()
      if (!(this.scroll?.wasRoot || this.path.some(vN))) {
        const { scroll: c } = this.root
        c && (co(a.x, c.offset.x), co(a.y, c.offset.y))
      }
      return a
    }
    removeElementScroll(o) {
      const a = Ye()
      if ((Xn(a, o), this.scroll?.wasRoot)) return a
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l],
          { scroll: u, options: f } = c
        c !== this.root &&
          u &&
          f.layoutScroll &&
          (u.wasRoot && Xn(a, o), co(a.x, u.offset.x), co(a.y, u.offset.y))
      }
      return a
    }
    applyTransform(o, a = !1) {
      const l = Ye()
      Xn(l, o)
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c]
        ;(!a &&
          u.options.layoutScroll &&
          u.scroll &&
          u !== u.root &&
          uo(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }),
          ns(u.latestValues) && uo(l, u.latestValues))
      }
      return (ns(this.latestValues) && uo(l, this.latestValues), l)
    }
    removeTransform(o) {
      const a = Ye()
      Xn(a, o)
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l]
        if (!c.instance || !ns(c.latestValues)) continue
        hp(c.latestValues) && c.updateSnapshot()
        const u = Ye(),
          f = c.measurePageBox()
        ;(Xn(u, f), zy(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u))
      }
      return (ns(this.latestValues) && zy(a, this.latestValues), a)
    }
    setTargetDelta(o) {
      ;((this.targetDelta = o), this.root.scheduleUpdateProjection(), (this.isProjectionDirty = !0))
    }
    setOptions(o) {
      this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 }
    }
    clearMeasurements() {
      ;((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1))
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== bn.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(o = !1) {
      const a = this.getLead()
      ;(this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty),
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty))
      const l = !!this.resumingFrom || this !== a
      if (
        !(
          o ||
          (l && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          this.parent?.isProjectionDirty ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return
      const { layout: u, layoutId: f } = this.options
      if (!(!this.layout || !(u || f))) {
        if (
          ((this.resolvedRelativeTargetAt = bn.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const d = this.getClosestProjectingParent()
          d && d.layout && this.animationProgress !== 1
            ? ((this.relativeParent = d),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Ye()),
              (this.relativeTargetOrigin = Ye()),
              Na(this.relativeTargetOrigin, this.layout.layoutBox, d.layout.layoutBox),
              Xn(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (
          !(!this.relativeTarget && !this.targetDelta) &&
          (this.target || ((this.target = Ye()), (this.targetWithTransforms = Ye())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              CP(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : Xn(this.target, this.layout.layoutBox),
                Wx(this.target, this.targetDelta))
              : Xn(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget)
        ) {
          this.attemptToResolveRelativeTarget = !1
          const d = this.getClosestProjectingParent()
          d &&
          !!d.resumingFrom == !!this.resumingFrom &&
          !d.options.layoutScroll &&
          d.target &&
          this.animationProgress !== 1
            ? ((this.relativeParent = d),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Ye()),
              (this.relativeTargetOrigin = Ye()),
              Na(this.relativeTargetOrigin, this.target, d.target),
              Xn(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hp(this.parent.latestValues) || qx(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
    }
    calcProjection() {
      const o = this.getLead(),
        a = !!this.resumingFrom || this !== o
      let l = !0
      if (
        ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (l = !1),
        a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1),
        this.resolvedRelativeTargetAt === bn.timestamp && (l = !1),
        l)
      )
        return
      const { layout: c, layoutId: u } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(c || u))
      )
        return
      Xn(this.layoutCorrected, this.layout.layoutBox)
      const f = this.treeScale.x,
        d = this.treeScale.y
      ;(LO(this.layoutCorrected, this.treeScale, this.path, a),
        o.layout &&
          !o.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((o.target = o.layout.layoutBox), (o.targetWithTransforms = Ye())))
      const { target: h } = o
      if (!h) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender())
        return
      }
      ;(!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (Ly(this.prevProjectionDelta.x, this.projectionDelta.x),
          Ly(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Pa(this.projectionDelta, this.layoutCorrected, h, this.latestValues),
        (this.treeScale.x !== f ||
          this.treeScale.y !== d ||
          !qy(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !qy(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners('projectionUpdate', h)))
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(o = !0) {
      if ((this.options.visualElement?.scheduleRender(), o)) {
        const a = this.getStack()
        a && a.scheduleRender()
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
    }
    createProjectionDeltas() {
      ;((this.prevProjectionDelta = fo()),
        (this.projectionDelta = fo()),
        (this.projectionDeltaWithTransform = fo()))
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        u = { ...this.latestValues },
        f = fo()
      ;((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a))
      const d = Ye(),
        h = l ? l.source : void 0,
        p = this.layout ? this.layout.source : void 0,
        g = h !== p,
        m = this.getStack(),
        y = !m || m.members.length <= 1,
        b = !!(g && !y && this.options.crossfade === !0 && !this.path.some(gN))
      this.animationProgress = 0
      let w
      ;((this.mixTargetDelta = (C) => {
        const T = C / 1e3
        ;(Xy(f.x, o.x, T),
          Xy(f.y, o.y, T),
          this.setTargetDelta(f),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Na(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            mN(this.relativeTarget, this.relativeTargetOrigin, d, T),
            w && tN(this.relativeTarget, w) && (this.isProjectionDirty = !1),
            w || (w = Ye()),
            Xn(w, this.relativeTarget)),
          g && ((this.animationValues = u), GP(u, c, this.latestValues, T, b, y)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = T))
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0))
    }
    startAnimation(o) {
      ;(this.notifyListeners('animationStart'),
        this.currentAnimation?.stop(),
        this.resumingFrom?.currentAnimation?.stop(),
        this.pendingAnimation && (Ui(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = Fe.update(() => {
          ;((Fc.hasAnimatedSinceResize = !0),
            this.motionValue || (this.motionValue = No(0)),
            (this.currentAnimation = HP(this.motionValue, [0, 1e3], {
              ...o,
              velocity: 0,
              isSync: !0,
              onUpdate: (a) => {
                ;(this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a))
              },
              onStop: () => {},
              onComplete: () => {
                ;(o.onComplete && o.onComplete(), this.completeAnimation())
              },
            })),
            this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0))
        })))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const o = this.getStack()
      ;(o && o.exitAnimationComplete(),
        (this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
        this.notifyListeners('animationComplete'))
    }
    finishAnimation() {
      ;(this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(rN), this.currentAnimation.stop()),
        this.completeAnimation())
    }
    applyTransformsToTarget() {
      const o = this.getLead()
      let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = o
      if (!(!a || !l || !c)) {
        if (
          this !== o &&
          this.layout &&
          c &&
          m3(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || Ye()
          const f = Rn(this.layout.layoutBox.x)
          ;((l.x.min = o.target.x.min), (l.x.max = l.x.min + f))
          const d = Rn(this.layout.layoutBox.y)
          ;((l.y.min = o.target.y.min), (l.y.max = l.y.min + d))
        }
        ;(Xn(a, l), uo(a, u), Pa(this.projectionDeltaWithTransform, this.layoutCorrected, a, u))
      }
    }
    registerSharedNode(o, a) {
      ;(this.sharedNodes.has(o) || this.sharedNodes.set(o, new eN()),
        this.sharedNodes.get(o).add(a))
      const c = a.options.initialPromotionConfig
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity:
          c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0,
      })
    }
    isLead() {
      const o = this.getStack()
      return o ? o.lead === this : !0
    }
    getLead() {
      const { layoutId: o } = this.options
      return o ? this.getStack()?.lead || this : this
    }
    getPrevLead() {
      const { layoutId: o } = this.options
      return o ? this.getStack()?.prevLead : void 0
    }
    getStack() {
      const { layoutId: o } = this.options
      if (o) return this.root.sharedNodes.get(o)
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack()
      ;(c && c.promote(this, l),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a }))
    }
    relegate() {
      const o = this.getStack()
      return o ? o.relegate(this) : !1
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options
      if (!o) return
      let a = !1
      const { latestValues: l } = o
      if (
        ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0),
        !a)
      )
        return
      const c = {}
      l.z && Pd('z', o, c, this.animationValues)
      for (let u = 0; u < Od.length; u++)
        (Pd(`rotate${Od[u]}`, o, c, this.animationValues),
          Pd(`skew${Od[u]}`, o, c, this.animationValues))
      o.render()
      for (const u in c)
        (o.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]))
      o.scheduleRender()
    }
    applyProjectionStyles(o, a) {
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) {
        o.visibility = 'hidden'
        return
      }
      const l = this.getTransformTemplate()
      if (this.needsReset) {
        ;((this.needsReset = !1),
          (o.visibility = ''),
          (o.opacity = ''),
          (o.pointerEvents = Lc(a?.pointerEvents) || ''),
          (o.transform = l ? l(this.latestValues, '') : 'none'))
        return
      }
      const c = this.getLead()
      if (!this.projectionDelta || !this.layout || !c.target) {
        ;(this.options.layoutId &&
          ((o.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1),
          (o.pointerEvents = Lc(a?.pointerEvents) || '')),
          this.hasProjected &&
            !ns(this.latestValues) &&
            ((o.transform = l ? l({}, '') : 'none'), (this.hasProjected = !1)))
        return
      }
      o.visibility = ''
      const u = c.animationValues || c.latestValues
      this.applyTransformsToTarget()
      let f = nN(this.projectionDeltaWithTransform, this.treeScale, u)
      ;(l && (f = l(u, f)), (o.transform = f))
      const { x: d, y: h } = this.projectionDelta
      ;((o.transformOrigin = `${d.origin * 100}% ${h.origin * 100}% 0`),
        c.animationValues
          ? (o.opacity =
              c === this
                ? (u.opacity ?? this.latestValues.opacity ?? 1)
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : u.opacityExit)
          : (o.opacity =
              c === this
                ? u.opacity !== void 0
                  ? u.opacity
                  : ''
                : u.opacityExit !== void 0
                  ? u.opacityExit
                  : 0))
      for (const p in nl) {
        if (u[p] === void 0) continue
        const { correct: g, applyTo: m, isCSSVariable: y } = nl[p],
          b = f === 'none' ? u[p] : g(u[p], c)
        if (m) {
          const w = m.length
          for (let C = 0; C < w; C++) o[m[C]] = b
        } else y ? (this.options.visualElement.renderState.vars[p] = b) : (o[p] = b)
      }
      this.options.layoutId && (o.pointerEvents = c === this ? Lc(a?.pointerEvents) || '' : 'none')
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      ;(this.root.nodes.forEach((o) => o.currentAnimation?.stop()),
        this.root.nodes.forEach(Wy),
        this.root.sharedNodes.clear())
    }
  }
}
function sN(e) {
  e.updateLayout()
}
function oN(e) {
  const n = e.resumeFrom?.snapshot || e.snapshot
  if (e.isLead() && e.layout && n && e.hasListeners('didUpdate')) {
    const { layoutBox: t, measuredBox: r } = e.layout,
      { animationType: i } = e.options,
      s = n.source !== e.layout.source
    i === 'size'
      ? Zn((u) => {
          const f = s ? n.measuredBox[u] : n.layoutBox[u],
            d = Rn(f)
          ;((f.min = t[u].min), (f.max = f.min + d))
        })
      : m3(i, n.layoutBox, t) &&
        Zn((u) => {
          const f = s ? n.measuredBox[u] : n.layoutBox[u],
            d = Rn(t[u])
          ;((f.max = f.min + d),
            e.relativeTarget &&
              !e.currentAnimation &&
              ((e.isProjectionDirty = !0), (e.relativeTarget[u].max = e.relativeTarget[u].min + d)))
        })
    const o = fo()
    Pa(o, t, n.layoutBox)
    const a = fo()
    s ? Pa(a, e.applyTransform(r, !0), n.measuredBox) : Pa(a, t, n.layoutBox)
    const l = !f3(o)
    let c = !1
    if (!e.resumeFrom) {
      const u = e.getClosestProjectingParent()
      if (u && !u.resumeFrom) {
        const { snapshot: f, layout: d } = u
        if (f && d) {
          const h = Ye()
          Na(h, n.layoutBox, f.layoutBox)
          const p = Ye()
          ;(Na(p, t, d.layoutBox),
            d3(h, p) || (c = !0),
            u.options.layoutRoot &&
              ((e.relativeTarget = p), (e.relativeTargetOrigin = h), (e.relativeParent = u)))
        }
      }
    }
    e.notifyListeners('didUpdate', {
      layout: t,
      snapshot: n,
      delta: a,
      layoutDelta: o,
      hasLayoutChanged: l,
      hasRelativeLayoutChanged: c,
    })
  } else if (e.isLead()) {
    const { onExitComplete: t } = e.options
    t && t()
  }
  e.options.transition = void 0
}
function aN(e) {
  e.parent &&
    (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
    e.isSharedProjectionDirty ||
      (e.isSharedProjectionDirty = !!(
        e.isProjectionDirty ||
        e.parent.isProjectionDirty ||
        e.parent.isSharedProjectionDirty
      )),
    e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function lN(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function cN(e) {
  e.clearSnapshot()
}
function Wy(e) {
  e.clearMeasurements()
}
function Ky(e) {
  e.isLayoutDirty = !1
}
function uN(e) {
  const { visualElement: n } = e.options
  ;(n && n.getProps().onBeforeLayoutMeasure && n.notify('BeforeLayoutMeasure'), e.resetTransform())
}
function Gy(e) {
  ;(e.finishAnimation(),
    (e.targetDelta = e.relativeTarget = e.target = void 0),
    (e.isProjectionDirty = !0))
}
function fN(e) {
  e.resolveTargetDelta()
}
function dN(e) {
  e.calcProjection()
}
function hN(e) {
  e.resetSkewAndRotation()
}
function pN(e) {
  e.removeLeadSnapshot()
}
function Xy(e, n, t) {
  ;((e.translate = Ve(n.translate, 0, t)),
    (e.scale = Ve(n.scale, 1, t)),
    (e.origin = n.origin),
    (e.originPoint = n.originPoint))
}
function Yy(e, n, t, r) {
  ;((e.min = Ve(n.min, t.min, r)), (e.max = Ve(n.max, t.max, r)))
}
function mN(e, n, t, r) {
  ;(Yy(e.x, n.x, t.x, r), Yy(e.y, n.y, t.y, r))
}
function gN(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0
}
const yN = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  Zy = (e) =>
    typeof navigator < 'u' && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e),
  Jy = Zy('applewebkit/') && !Zy('chrome/') ? Math.round : ar
function Qy(e) {
  ;((e.min = Jy(e.min)), (e.max = Jy(e.max)))
}
function bN(e) {
  ;(Qy(e.x), Qy(e.y))
}
function m3(e, n, t) {
  return e === 'position' || (e === 'preserve-aspect' && !kP(Uy(n), Uy(t), 0.2))
}
function vN(e) {
  return e !== e.root && e.scroll?.wasRoot
}
const wN = p3({
    attachResizeListener: (e, n) => rl(e, 'resize', n),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  Nd = { current: void 0 },
  g3 = p3({
    measureScroll: (e) => ({ x: e.scrollLeft, y: e.scrollTop }),
    defaultParent: () => {
      if (!Nd.current) {
        const e = new wN({})
        ;(e.mount(window), e.setOptions({ layoutScroll: !0 }), (Nd.current = e))
      }
      return Nd.current
    },
    resetTransform: (e, n) => {
      e.style.transform = n !== void 0 ? n : 'none'
    },
    checkIsScrollRoot: (e) => window.getComputedStyle(e).position === 'fixed',
  }),
  xN = { pan: { Feature: BP }, drag: { Feature: FP, ProjectionNode: g3, MeasureLayout: l3 } }
function tb(e, n, t) {
  const { props: r } = e
  e.animationState && r.whileHover && e.animationState.setActive('whileHover', t === 'Start')
  const i = 'onHover' + t,
    s = r[i]
  s && Fe.postRender(() => s(n, Tl(n)))
}
class SN extends Xi {
  mount() {
    const { current: n } = this.node
    n &&
      (this.unmount = HR(n, (t, r) => (tb(this.node, r, 'Start'), (i) => tb(this.node, i, 'End'))))
  }
  unmount() {}
}
class _N extends Xi {
  constructor() {
    ;(super(...arguments), (this.isActive = !1))
  }
  onFocus() {
    let n = !1
    try {
      n = this.node.current.matches(':focus-visible')
    } catch {
      n = !0
    }
    !n ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !0), (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !1), (this.isActive = !1))
  }
  mount() {
    this.unmount = Cl(
      rl(this.node.current, 'focus', () => this.onFocus()),
      rl(this.node.current, 'blur', () => this.onBlur()),
    )
  }
  unmount() {}
}
function eb(e, n, t) {
  const { props: r } = e
  if (e.current instanceof HTMLButtonElement && e.current.disabled) return
  e.animationState && r.whileTap && e.animationState.setActive('whileTap', t === 'Start')
  const i = 'onTap' + (t === 'End' ? '' : t),
    s = r[i]
  s && Fe.postRender(() => s(n, Tl(n)))
}
class kN extends Xi {
  mount() {
    const { current: n } = this.node
    n &&
      (this.unmount = KR(
        n,
        (t, r) => (
          eb(this.node, r, 'Start'),
          (i, { success: s }) => eb(this.node, i, s ? 'End' : 'Cancel')
        ),
        { useGlobalTarget: this.node.props.globalTapTarget },
      ))
  }
  unmount() {}
}
const wp = new WeakMap(),
  Id = new WeakMap(),
  CN = (e) => {
    const n = wp.get(e.target)
    n && n(e)
  },
  MN = (e) => {
    e.forEach(CN)
  }
function EN({ root: e, ...n }) {
  const t = e || document
  Id.has(t) || Id.set(t, {})
  const r = Id.get(t),
    i = JSON.stringify(n)
  return (r[i] || (r[i] = new IntersectionObserver(MN, { root: e, ...n })), r[i])
}
function TN(e, n, t) {
  const r = EN(n)
  return (
    wp.set(e, t),
    r.observe(e),
    () => {
      ;(wp.delete(e), r.unobserve(e))
    }
  )
}
const AN = { some: 0, all: 1 }
class RN extends Xi {
  constructor() {
    ;(super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1))
  }
  startObserver() {
    this.unmount()
    const { viewport: n = {} } = this.node.getProps(),
      { root: t, margin: r, amount: i = 'some', once: s } = n,
      o = {
        root: t ? t.current : void 0,
        rootMargin: r,
        threshold: typeof i == 'number' ? i : AN[i],
      },
      a = (l) => {
        const { isIntersecting: c } = l
        if (this.isInView === c || ((this.isInView = c), s && !c && this.hasEnteredView)) return
        ;(c && (this.hasEnteredView = !0),
          this.node.animationState && this.node.animationState.setActive('whileInView', c))
        const { onViewportEnter: u, onViewportLeave: f } = this.node.getProps(),
          d = c ? u : f
        d && d(l)
      }
    return TN(this.node.current, o, a)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > 'u') return
    const { props: n, prevProps: t } = this.node
    ;['amount', 'margin', 'root'].some(ON(n, t)) && this.startObserver()
  }
  unmount() {}
}
function ON({ viewport: e = {} }, { viewport: n = {} } = {}) {
  return (t) => e[t] !== n[t]
}
const PN = {
    inView: { Feature: RN },
    tap: { Feature: kN },
    focus: { Feature: _N },
    hover: { Feature: SN },
  },
  NN = { layout: { ProjectionNode: g3, MeasureLayout: l3 } },
  IN = { ...bP, ...PN, ...xN, ...NN },
  EZ = IO(IN, KO)
/**
 * @license @tabler/icons-react v3.35.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ var DN = {
  outline: {
    xmlns: 'http://www.w3.org/2000/svg',
    width: 24,
    height: 24,
    viewBox: '0 0 24 24',
    fill: 'none',
    stroke: 'currentColor',
    strokeWidth: 2,
    strokeLinecap: 'round',
    strokeLinejoin: 'round',
  },
  filled: {
    xmlns: 'http://www.w3.org/2000/svg',
    width: 24,
    height: 24,
    viewBox: '0 0 24 24',
    fill: 'currentColor',
    stroke: 'none',
  },
}
/**
 * @license @tabler/icons-react v3.35.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ const jN = (e, n, t, r) => {
  const i = Y.forwardRef(
    (
      {
        color: s = 'currentColor',
        size: o = 24,
        stroke: a = 2,
        title: l,
        className: c,
        children: u,
        ...f
      },
      d,
    ) =>
      Y.createElement(
        'svg',
        {
          ref: d,
          ...DN[e],
          width: o,
          height: o,
          className: ['tabler-icon', `tabler-icon-${n}`, c].join(' '),
          strokeWidth: a,
          stroke: s,
          ...f,
        },
        [
          l && Y.createElement('title', { key: 'svg-title' }, l),
          ...r.map(([h, p]) => Y.createElement(h, p)),
          ...(Array.isArray(u) ? u : [u]),
        ],
      ),
  )
  return ((i.displayName = `${t}`), i)
}
/**
 * @license @tabler/icons-react v3.35.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */ const LN = [
    ['path', { d: 'M5 12l14 0', key: 'svg-0' }],
    ['path', { d: 'M5 12l4 4', key: 'svg-1' }],
    ['path', { d: 'M5 12l4 -4', key: 'svg-2' }],
  ],
  TZ = jN('outline', 'arrow-narrow-left', 'ArrowNarrowLeft', LN)
/**
 * table-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Ai(e, n) {
  return typeof e == 'function' ? e(n) : e
}
function Wn(e, n) {
  return (t) => {
    n.setState((r) => ({ ...r, [e]: Ai(t, r[e]) }))
  }
}
function Af(e) {
  return e instanceof Function
}
function FN(e) {
  return Array.isArray(e) && e.every((n) => typeof n == 'number')
}
function BN(e, n) {
  const t = [],
    r = (i) => {
      i.forEach((s) => {
        t.push(s)
        const o = n(s)
        o != null && o.length && r(o)
      })
    }
  return (r(e), t)
}
function ne(e, n, t) {
  let r = [],
    i
  return (s) => {
    let o
    t.key && t.debug && (o = Date.now())
    const a = e(s)
    if (!(a.length !== r.length || a.some((u, f) => r[f] !== u))) return i
    r = a
    let c
    if (
      (t.key && t.debug && (c = Date.now()),
      (i = n(...a)),
      t == null || t.onChange == null || t.onChange(i),
      t.key && t.debug && t != null && t.debug())
    ) {
      const u = Math.round((Date.now() - o) * 100) / 100,
        f = Math.round((Date.now() - c) * 100) / 100,
        d = f / 16,
        h = (p, g) => {
          for (p = String(p); p.length < g; ) p = ' ' + p
          return p
        }
      console.info(
        `%c ${h(f, 5)} /${h(u, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * d, 120))}deg 100% 31%);`,
        t?.key,
      )
    }
    return i
  }
}
function re(e, n, t, r) {
  return {
    debug: () => {
      var i
      return (i = e?.debugAll) != null ? i : e[n]
    },
    key: !1,
    onChange: r,
  }
}
function zN(e, n, t, r) {
  const i = () => {
      var o
      return (o = s.getValue()) != null ? o : e.options.renderFallbackValue
    },
    s = {
      id: `${n.id}_${t.id}`,
      row: n,
      column: t,
      getValue: () => n.getValue(r),
      renderValue: i,
      getContext: ne(
        () => [e, t, n, s],
        (o, a, l, c) => ({
          table: o,
          column: a,
          row: l,
          cell: c,
          getValue: c.getValue,
          renderValue: c.renderValue,
        }),
        re(e.options, 'debugCells'),
      ),
    }
  return (
    e._features.forEach((o) => {
      o.createCell == null || o.createCell(s, t, n, e)
    }, {}),
    s
  )
}
function $N(e, n, t, r) {
  var i, s
  const a = { ...e._getDefaultColumnDef(), ...n },
    l = a.accessorKey
  let c =
      (i =
        (s = a.id) != null
          ? s
          : l
            ? typeof String.prototype.replaceAll == 'function'
              ? l.replaceAll('.', '_')
              : l.replace(/\./g, '_')
            : void 0) != null
        ? i
        : typeof a.header == 'string'
          ? a.header
          : void 0,
    u
  if (
    (a.accessorFn
      ? (u = a.accessorFn)
      : l &&
        (l.includes('.')
          ? (u = (d) => {
              let h = d
              for (const g of l.split('.')) {
                var p
                h = (p = h) == null ? void 0 : p[g]
              }
              return h
            })
          : (u = (d) => d[a.accessorKey])),
    !c)
  )
    throw new Error()
  let f = {
    id: `${String(c)}`,
    accessorFn: u,
    parent: r,
    depth: t,
    columnDef: a,
    columns: [],
    getFlatColumns: ne(
      () => [!0],
      () => {
        var d
        return [f, ...((d = f.columns) == null ? void 0 : d.flatMap((h) => h.getFlatColumns()))]
      },
      re(e.options, 'debugColumns'),
    ),
    getLeafColumns: ne(
      () => [e._getOrderColumnsFn()],
      (d) => {
        var h
        if ((h = f.columns) != null && h.length) {
          let p = f.columns.flatMap((g) => g.getLeafColumns())
          return d(p)
        }
        return [f]
      },
      re(e.options, 'debugColumns'),
    ),
  }
  for (const d of e._features) d.createColumn == null || d.createColumn(f, e)
  return f
}
const _n = 'debugHeaders'
function nb(e, n, t) {
  var r
  let s = {
    id: (r = t.id) != null ? r : n.id,
    column: n,
    index: t.index,
    isPlaceholder: !!t.isPlaceholder,
    placeholderId: t.placeholderId,
    depth: t.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const o = [],
        a = (l) => {
          ;(l.subHeaders && l.subHeaders.length && l.subHeaders.map(a), o.push(l))
        }
      return (a(s), o)
    },
    getContext: () => ({ table: e, header: s, column: n }),
  }
  return (
    e._features.forEach((o) => {
      o.createHeader == null || o.createHeader(s, e)
    }),
    s
  )
}
const VN = {
  createTable: (e) => {
    ;((e.getHeaderGroups = ne(
      () => [
        e.getAllColumns(),
        e.getVisibleLeafColumns(),
        e.getState().columnPinning.left,
        e.getState().columnPinning.right,
      ],
      (n, t, r, i) => {
        var s, o
        const a = (s = r?.map((f) => t.find((d) => d.id === f)).filter(Boolean)) != null ? s : [],
          l = (o = i?.map((f) => t.find((d) => d.id === f)).filter(Boolean)) != null ? o : [],
          c = t.filter((f) => !(r != null && r.includes(f.id)) && !(i != null && i.includes(f.id)))
        return sc(n, [...a, ...c, ...l], e)
      },
      re(e.options, _n),
    )),
      (e.getCenterHeaderGroups = ne(
        () => [
          e.getAllColumns(),
          e.getVisibleLeafColumns(),
          e.getState().columnPinning.left,
          e.getState().columnPinning.right,
        ],
        (n, t, r, i) => (
          (t = t.filter(
            (s) => !(r != null && r.includes(s.id)) && !(i != null && i.includes(s.id)),
          )),
          sc(n, t, e, 'center')
        ),
        re(e.options, _n),
      )),
      (e.getLeftHeaderGroups = ne(
        () => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left],
        (n, t, r) => {
          var i
          const s = (i = r?.map((o) => t.find((a) => a.id === o)).filter(Boolean)) != null ? i : []
          return sc(n, s, e, 'left')
        },
        re(e.options, _n),
      )),
      (e.getRightHeaderGroups = ne(
        () => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.right],
        (n, t, r) => {
          var i
          const s = (i = r?.map((o) => t.find((a) => a.id === o)).filter(Boolean)) != null ? i : []
          return sc(n, s, e, 'right')
        },
        re(e.options, _n),
      )),
      (e.getFooterGroups = ne(
        () => [e.getHeaderGroups()],
        (n) => [...n].reverse(),
        re(e.options, _n),
      )),
      (e.getLeftFooterGroups = ne(
        () => [e.getLeftHeaderGroups()],
        (n) => [...n].reverse(),
        re(e.options, _n),
      )),
      (e.getCenterFooterGroups = ne(
        () => [e.getCenterHeaderGroups()],
        (n) => [...n].reverse(),
        re(e.options, _n),
      )),
      (e.getRightFooterGroups = ne(
        () => [e.getRightHeaderGroups()],
        (n) => [...n].reverse(),
        re(e.options, _n),
      )),
      (e.getFlatHeaders = ne(
        () => [e.getHeaderGroups()],
        (n) => n.map((t) => t.headers).flat(),
        re(e.options, _n),
      )),
      (e.getLeftFlatHeaders = ne(
        () => [e.getLeftHeaderGroups()],
        (n) => n.map((t) => t.headers).flat(),
        re(e.options, _n),
      )),
      (e.getCenterFlatHeaders = ne(
        () => [e.getCenterHeaderGroups()],
        (n) => n.map((t) => t.headers).flat(),
        re(e.options, _n),
      )),
      (e.getRightFlatHeaders = ne(
        () => [e.getRightHeaderGroups()],
        (n) => n.map((t) => t.headers).flat(),
        re(e.options, _n),
      )),
      (e.getCenterLeafHeaders = ne(
        () => [e.getCenterFlatHeaders()],
        (n) =>
          n.filter((t) => {
            var r
            return !((r = t.subHeaders) != null && r.length)
          }),
        re(e.options, _n),
      )),
      (e.getLeftLeafHeaders = ne(
        () => [e.getLeftFlatHeaders()],
        (n) =>
          n.filter((t) => {
            var r
            return !((r = t.subHeaders) != null && r.length)
          }),
        re(e.options, _n),
      )),
      (e.getRightLeafHeaders = ne(
        () => [e.getRightFlatHeaders()],
        (n) =>
          n.filter((t) => {
            var r
            return !((r = t.subHeaders) != null && r.length)
          }),
        re(e.options, _n),
      )),
      (e.getLeafHeaders = ne(
        () => [e.getLeftHeaderGroups(), e.getCenterHeaderGroups(), e.getRightHeaderGroups()],
        (n, t, r) => {
          var i, s, o, a, l, c
          return [
            ...((i = (s = n[0]) == null ? void 0 : s.headers) != null ? i : []),
            ...((o = (a = t[0]) == null ? void 0 : a.headers) != null ? o : []),
            ...((l = (c = r[0]) == null ? void 0 : c.headers) != null ? l : []),
          ]
            .map((u) => u.getLeafHeaders())
            .flat()
        },
        re(e.options, _n),
      )))
  },
}
function sc(e, n, t, r) {
  var i, s
  let o = 0
  const a = function (d, h) {
    ;(h === void 0 && (h = 1),
      (o = Math.max(o, h)),
      d
        .filter((p) => p.getIsVisible())
        .forEach((p) => {
          var g
          ;(g = p.columns) != null && g.length && a(p.columns, h + 1)
        }, 0))
  }
  a(e)
  let l = []
  const c = (d, h) => {
      const p = { depth: h, id: [r, `${h}`].filter(Boolean).join('_'), headers: [] },
        g = []
      ;(d.forEach((m) => {
        const y = [...g].reverse()[0],
          b = m.column.depth === p.depth
        let w,
          C = !1
        if (
          (b && m.column.parent ? (w = m.column.parent) : ((w = m.column), (C = !0)),
          y && y?.column === w)
        )
          y.subHeaders.push(m)
        else {
          const T = nb(t, w, {
            id: [r, h, w.id, m?.id].filter(Boolean).join('_'),
            isPlaceholder: C,
            placeholderId: C ? `${g.filter((I) => I.column === w).length}` : void 0,
            depth: h,
            index: g.length,
          })
          ;(T.subHeaders.push(m), g.push(T))
        }
        ;(p.headers.push(m), (m.headerGroup = p))
      }),
        l.push(p),
        h > 0 && c(g, h - 1))
    },
    u = n.map((d, h) => nb(t, d, { depth: o, index: h }))
  ;(c(u, o - 1), l.reverse())
  const f = (d) =>
    d
      .filter((p) => p.column.getIsVisible())
      .map((p) => {
        let g = 0,
          m = 0,
          y = [0]
        p.subHeaders && p.subHeaders.length
          ? ((y = []),
            f(p.subHeaders).forEach((w) => {
              let { colSpan: C, rowSpan: T } = w
              ;((g += C), y.push(T))
            }))
          : (g = 1)
        const b = Math.min(...y)
        return ((m = m + b), (p.colSpan = g), (p.rowSpan = m), { colSpan: g, rowSpan: m })
      })
  return (f((i = (s = l[0]) == null ? void 0 : s.headers) != null ? i : []), l)
}
const x0 = (e, n, t, r, i, s, o) => {
    let a = {
      id: n,
      index: r,
      original: t,
      depth: i,
      parentId: o,
      _valuesCache: {},
      _uniqueValuesCache: {},
      getValue: (l) => {
        if (a._valuesCache.hasOwnProperty(l)) return a._valuesCache[l]
        const c = e.getColumn(l)
        if (c != null && c.accessorFn)
          return ((a._valuesCache[l] = c.accessorFn(a.original, r)), a._valuesCache[l])
      },
      getUniqueValues: (l) => {
        if (a._uniqueValuesCache.hasOwnProperty(l)) return a._uniqueValuesCache[l]
        const c = e.getColumn(l)
        if (c != null && c.accessorFn)
          return c.columnDef.getUniqueValues
            ? ((a._uniqueValuesCache[l] = c.columnDef.getUniqueValues(a.original, r)),
              a._uniqueValuesCache[l])
            : ((a._uniqueValuesCache[l] = [a.getValue(l)]), a._uniqueValuesCache[l])
      },
      renderValue: (l) => {
        var c
        return (c = a.getValue(l)) != null ? c : e.options.renderFallbackValue
      },
      subRows: [],
      getLeafRows: () => BN(a.subRows, (l) => l.subRows),
      getParentRow: () => (a.parentId ? e.getRow(a.parentId, !0) : void 0),
      getParentRows: () => {
        let l = [],
          c = a
        for (;;) {
          const u = c.getParentRow()
          if (!u) break
          ;(l.push(u), (c = u))
        }
        return l.reverse()
      },
      getAllCells: ne(
        () => [e.getAllLeafColumns()],
        (l) => l.map((c) => zN(e, a, c, c.id)),
        re(e.options, 'debugRows'),
      ),
      _getAllCellsByColumnId: ne(
        () => [a.getAllCells()],
        (l) => l.reduce((c, u) => ((c[u.column.id] = u), c), {}),
        re(e.options, 'debugRows'),
      ),
    }
    for (let l = 0; l < e._features.length; l++) {
      const c = e._features[l]
      c == null || c.createRow == null || c.createRow(a, e)
    }
    return a
  },
  HN = {
    createColumn: (e, n) => {
      ;((e._getFacetedRowModel =
        n.options.getFacetedRowModel && n.options.getFacetedRowModel(n, e.id)),
        (e.getFacetedRowModel = () =>
          e._getFacetedRowModel ? e._getFacetedRowModel() : n.getPreFilteredRowModel()),
        (e._getFacetedUniqueValues =
          n.options.getFacetedUniqueValues && n.options.getFacetedUniqueValues(n, e.id)),
        (e.getFacetedUniqueValues = () =>
          e._getFacetedUniqueValues ? e._getFacetedUniqueValues() : new Map()),
        (e._getFacetedMinMaxValues =
          n.options.getFacetedMinMaxValues && n.options.getFacetedMinMaxValues(n, e.id)),
        (e.getFacetedMinMaxValues = () => {
          if (e._getFacetedMinMaxValues) return e._getFacetedMinMaxValues()
        }))
    },
  },
  y3 = (e, n, t) => {
    var r, i
    const s = t == null || (r = t.toString()) == null ? void 0 : r.toLowerCase()
    return !!(
      !(
        (i = e.getValue(n)) == null ||
        (i = i.toString()) == null ||
        (i = i.toLowerCase()) == null
      ) && i.includes(s)
    )
  }
y3.autoRemove = (e) => br(e)
const b3 = (e, n, t) => {
  var r
  return !!(!((r = e.getValue(n)) == null || (r = r.toString()) == null) && r.includes(t))
}
b3.autoRemove = (e) => br(e)
const v3 = (e, n, t) => {
  var r
  return (
    ((r = e.getValue(n)) == null || (r = r.toString()) == null ? void 0 : r.toLowerCase()) ===
    t?.toLowerCase()
  )
}
v3.autoRemove = (e) => br(e)
const w3 = (e, n, t) => {
  var r
  return (r = e.getValue(n)) == null ? void 0 : r.includes(t)
}
w3.autoRemove = (e) => br(e)
const x3 = (e, n, t) =>
  !t.some((r) => {
    var i
    return !((i = e.getValue(n)) != null && i.includes(r))
  })
x3.autoRemove = (e) => br(e) || !(e != null && e.length)
const S3 = (e, n, t) =>
  t.some((r) => {
    var i
    return (i = e.getValue(n)) == null ? void 0 : i.includes(r)
  })
S3.autoRemove = (e) => br(e) || !(e != null && e.length)
const _3 = (e, n, t) => e.getValue(n) === t
_3.autoRemove = (e) => br(e)
const k3 = (e, n, t) => e.getValue(n) == t
k3.autoRemove = (e) => br(e)
const S0 = (e, n, t) => {
  let [r, i] = t
  const s = e.getValue(n)
  return s >= r && s <= i
}
S0.resolveFilterValue = (e) => {
  let [n, t] = e,
    r = typeof n != 'number' ? parseFloat(n) : n,
    i = typeof t != 'number' ? parseFloat(t) : t,
    s = n === null || Number.isNaN(r) ? -1 / 0 : r,
    o = t === null || Number.isNaN(i) ? 1 / 0 : i
  if (s > o) {
    const a = s
    ;((s = o), (o = a))
  }
  return [s, o]
}
S0.autoRemove = (e) => br(e) || (br(e[0]) && br(e[1]))
const Kr = {
  includesString: y3,
  includesStringSensitive: b3,
  equalsString: v3,
  arrIncludes: w3,
  arrIncludesAll: x3,
  arrIncludesSome: S3,
  equals: _3,
  weakEquals: k3,
  inNumberRange: S0,
}
function br(e) {
  return e == null || e === ''
}
const UN = {
  getDefaultColumnDef: () => ({ filterFn: 'auto' }),
  getInitialState: (e) => ({ columnFilters: [], ...e }),
  getDefaultOptions: (e) => ({
    onColumnFiltersChange: Wn('columnFilters', e),
    filterFromLeafRows: !1,
    maxLeafRowFilterDepth: 100,
  }),
  createColumn: (e, n) => {
    ;((e.getAutoFilterFn = () => {
      const t = n.getCoreRowModel().flatRows[0],
        r = t?.getValue(e.id)
      return typeof r == 'string'
        ? Kr.includesString
        : typeof r == 'number'
          ? Kr.inNumberRange
          : typeof r == 'boolean' || (r !== null && typeof r == 'object')
            ? Kr.equals
            : Array.isArray(r)
              ? Kr.arrIncludes
              : Kr.weakEquals
    }),
      (e.getFilterFn = () => {
        var t, r
        return Af(e.columnDef.filterFn)
          ? e.columnDef.filterFn
          : e.columnDef.filterFn === 'auto'
            ? e.getAutoFilterFn()
            : (t = (r = n.options.filterFns) == null ? void 0 : r[e.columnDef.filterFn]) != null
              ? t
              : Kr[e.columnDef.filterFn]
      }),
      (e.getCanFilter = () => {
        var t, r, i
        return (
          ((t = e.columnDef.enableColumnFilter) != null ? t : !0) &&
          ((r = n.options.enableColumnFilters) != null ? r : !0) &&
          ((i = n.options.enableFilters) != null ? i : !0) &&
          !!e.accessorFn
        )
      }),
      (e.getIsFiltered = () => e.getFilterIndex() > -1),
      (e.getFilterValue = () => {
        var t
        return (t = n.getState().columnFilters) == null ||
          (t = t.find((r) => r.id === e.id)) == null
          ? void 0
          : t.value
      }),
      (e.getFilterIndex = () => {
        var t, r
        return (t =
          (r = n.getState().columnFilters) == null ? void 0 : r.findIndex((i) => i.id === e.id)) !=
          null
          ? t
          : -1
      }),
      (e.setFilterValue = (t) => {
        n.setColumnFilters((r) => {
          const i = e.getFilterFn(),
            s = r?.find((u) => u.id === e.id),
            o = Ai(t, s ? s.value : void 0)
          if (rb(i, o, e)) {
            var a
            return (a = r?.filter((u) => u.id !== e.id)) != null ? a : []
          }
          const l = { id: e.id, value: o }
          if (s) {
            var c
            return (c = r?.map((u) => (u.id === e.id ? l : u))) != null ? c : []
          }
          return r != null && r.length ? [...r, l] : [l]
        })
      }))
  },
  createRow: (e, n) => {
    ;((e.columnFilters = {}), (e.columnFiltersMeta = {}))
  },
  createTable: (e) => {
    ;((e.setColumnFilters = (n) => {
      const t = e.getAllLeafColumns(),
        r = (i) => {
          var s
          return (s = Ai(n, i)) == null
            ? void 0
            : s.filter((o) => {
                const a = t.find((l) => l.id === o.id)
                if (a) {
                  const l = a.getFilterFn()
                  if (rb(l, o.value, a)) return !1
                }
                return !0
              })
        }
      e.options.onColumnFiltersChange == null || e.options.onColumnFiltersChange(r)
    }),
      (e.resetColumnFilters = (n) => {
        var t, r
        e.setColumnFilters(
          n ? [] : (t = (r = e.initialState) == null ? void 0 : r.columnFilters) != null ? t : [],
        )
      }),
      (e.getPreFilteredRowModel = () => e.getCoreRowModel()),
      (e.getFilteredRowModel = () => (
        !e._getFilteredRowModel &&
          e.options.getFilteredRowModel &&
          (e._getFilteredRowModel = e.options.getFilteredRowModel(e)),
        e.options.manualFiltering || !e._getFilteredRowModel
          ? e.getPreFilteredRowModel()
          : e._getFilteredRowModel()
      )))
  },
}
function rb(e, n, t) {
  return (
    (e && e.autoRemove ? e.autoRemove(n, t) : !1) || typeof n > 'u' || (typeof n == 'string' && !n)
  )
}
const qN = (e, n, t) =>
    t.reduce((r, i) => {
      const s = i.getValue(e)
      return r + (typeof s == 'number' ? s : 0)
    }, 0),
  WN = (e, n, t) => {
    let r
    return (
      t.forEach((i) => {
        const s = i.getValue(e)
        s != null && (r > s || (r === void 0 && s >= s)) && (r = s)
      }),
      r
    )
  },
  KN = (e, n, t) => {
    let r
    return (
      t.forEach((i) => {
        const s = i.getValue(e)
        s != null && (r < s || (r === void 0 && s >= s)) && (r = s)
      }),
      r
    )
  },
  GN = (e, n, t) => {
    let r, i
    return (
      t.forEach((s) => {
        const o = s.getValue(e)
        o != null && (r === void 0 ? o >= o && (r = i = o) : (r > o && (r = o), i < o && (i = o)))
      }),
      [r, i]
    )
  },
  XN = (e, n) => {
    let t = 0,
      r = 0
    if (
      (n.forEach((i) => {
        let s = i.getValue(e)
        s != null && (s = +s) >= s && (++t, (r += s))
      }),
      t)
    )
      return r / t
  },
  YN = (e, n) => {
    if (!n.length) return
    const t = n.map((s) => s.getValue(e))
    if (!FN(t)) return
    if (t.length === 1) return t[0]
    const r = Math.floor(t.length / 2),
      i = t.sort((s, o) => s - o)
    return t.length % 2 !== 0 ? i[r] : (i[r - 1] + i[r]) / 2
  },
  ZN = (e, n) => Array.from(new Set(n.map((t) => t.getValue(e))).values()),
  JN = (e, n) => new Set(n.map((t) => t.getValue(e))).size,
  QN = (e, n) => n.length,
  Dd = {
    sum: qN,
    min: WN,
    max: KN,
    extent: GN,
    mean: XN,
    median: YN,
    unique: ZN,
    uniqueCount: JN,
    count: QN,
  },
  tI = {
    getDefaultColumnDef: () => ({
      aggregatedCell: (e) => {
        var n, t
        return (n = (t = e.getValue()) == null || t.toString == null ? void 0 : t.toString()) !=
          null
          ? n
          : null
      },
      aggregationFn: 'auto',
    }),
    getInitialState: (e) => ({ grouping: [], ...e }),
    getDefaultOptions: (e) => ({
      onGroupingChange: Wn('grouping', e),
      groupedColumnMode: 'reorder',
    }),
    createColumn: (e, n) => {
      ;((e.toggleGrouping = () => {
        n.setGrouping((t) =>
          t != null && t.includes(e.id) ? t.filter((r) => r !== e.id) : [...(t ?? []), e.id],
        )
      }),
        (e.getCanGroup = () => {
          var t, r
          return (
            ((t = e.columnDef.enableGrouping) != null ? t : !0) &&
            ((r = n.options.enableGrouping) != null ? r : !0) &&
            (!!e.accessorFn || !!e.columnDef.getGroupingValue)
          )
        }),
        (e.getIsGrouped = () => {
          var t
          return (t = n.getState().grouping) == null ? void 0 : t.includes(e.id)
        }),
        (e.getGroupedIndex = () => {
          var t
          return (t = n.getState().grouping) == null ? void 0 : t.indexOf(e.id)
        }),
        (e.getToggleGroupingHandler = () => {
          const t = e.getCanGroup()
          return () => {
            t && e.toggleGrouping()
          }
        }),
        (e.getAutoAggregationFn = () => {
          const t = n.getCoreRowModel().flatRows[0],
            r = t?.getValue(e.id)
          if (typeof r == 'number') return Dd.sum
          if (Object.prototype.toString.call(r) === '[object Date]') return Dd.extent
        }),
        (e.getAggregationFn = () => {
          var t, r
          if (!e) throw new Error()
          return Af(e.columnDef.aggregationFn)
            ? e.columnDef.aggregationFn
            : e.columnDef.aggregationFn === 'auto'
              ? e.getAutoAggregationFn()
              : (t =
                    (r = n.options.aggregationFns) == null
                      ? void 0
                      : r[e.columnDef.aggregationFn]) != null
                ? t
                : Dd[e.columnDef.aggregationFn]
        }))
    },
    createTable: (e) => {
      ;((e.setGrouping = (n) =>
        e.options.onGroupingChange == null ? void 0 : e.options.onGroupingChange(n)),
        (e.resetGrouping = (n) => {
          var t, r
          e.setGrouping(
            n ? [] : (t = (r = e.initialState) == null ? void 0 : r.grouping) != null ? t : [],
          )
        }),
        (e.getPreGroupedRowModel = () => e.getFilteredRowModel()),
        (e.getGroupedRowModel = () => (
          !e._getGroupedRowModel &&
            e.options.getGroupedRowModel &&
            (e._getGroupedRowModel = e.options.getGroupedRowModel(e)),
          e.options.manualGrouping || !e._getGroupedRowModel
            ? e.getPreGroupedRowModel()
            : e._getGroupedRowModel()
        )))
    },
    createRow: (e, n) => {
      ;((e.getIsGrouped = () => !!e.groupingColumnId),
        (e.getGroupingValue = (t) => {
          if (e._groupingValuesCache.hasOwnProperty(t)) return e._groupingValuesCache[t]
          const r = n.getColumn(t)
          return r != null && r.columnDef.getGroupingValue
            ? ((e._groupingValuesCache[t] = r.columnDef.getGroupingValue(e.original)),
              e._groupingValuesCache[t])
            : e.getValue(t)
        }),
        (e._groupingValuesCache = {}))
    },
    createCell: (e, n, t, r) => {
      ;((e.getIsGrouped = () => n.getIsGrouped() && n.id === t.groupingColumnId),
        (e.getIsPlaceholder = () => !e.getIsGrouped() && n.getIsGrouped()),
        (e.getIsAggregated = () => {
          var i
          return (
            !e.getIsGrouped() && !e.getIsPlaceholder() && !!((i = t.subRows) != null && i.length)
          )
        }))
    },
  }
function eI(e, n, t) {
  if (!(n != null && n.length) || !t) return e
  const r = e.filter((s) => !n.includes(s.id))
  return t === 'remove' ? r : [...n.map((s) => e.find((o) => o.id === s)).filter(Boolean), ...r]
}
const nI = {
    getInitialState: (e) => ({ columnOrder: [], ...e }),
    getDefaultOptions: (e) => ({ onColumnOrderChange: Wn('columnOrder', e) }),
    createColumn: (e, n) => {
      ;((e.getIndex = ne(
        (t) => [Ia(n, t)],
        (t) => t.findIndex((r) => r.id === e.id),
        re(n.options, 'debugColumns'),
      )),
        (e.getIsFirstColumn = (t) => {
          var r
          return ((r = Ia(n, t)[0]) == null ? void 0 : r.id) === e.id
        }),
        (e.getIsLastColumn = (t) => {
          var r
          const i = Ia(n, t)
          return ((r = i[i.length - 1]) == null ? void 0 : r.id) === e.id
        }))
    },
    createTable: (e) => {
      ;((e.setColumnOrder = (n) =>
        e.options.onColumnOrderChange == null ? void 0 : e.options.onColumnOrderChange(n)),
        (e.resetColumnOrder = (n) => {
          var t
          e.setColumnOrder(n ? [] : (t = e.initialState.columnOrder) != null ? t : [])
        }),
        (e._getOrderColumnsFn = ne(
          () => [e.getState().columnOrder, e.getState().grouping, e.options.groupedColumnMode],
          (n, t, r) => (i) => {
            let s = []
            if (!(n != null && n.length)) s = i
            else {
              const o = [...n],
                a = [...i]
              for (; a.length && o.length; ) {
                const l = o.shift(),
                  c = a.findIndex((u) => u.id === l)
                c > -1 && s.push(a.splice(c, 1)[0])
              }
              s = [...s, ...a]
            }
            return eI(s, t, r)
          },
          re(e.options, 'debugTable'),
        )))
    },
  },
  jd = () => ({ left: [], right: [] }),
  rI = {
    getInitialState: (e) => ({ columnPinning: jd(), ...e }),
    getDefaultOptions: (e) => ({ onColumnPinningChange: Wn('columnPinning', e) }),
    createColumn: (e, n) => {
      ;((e.pin = (t) => {
        const r = e
          .getLeafColumns()
          .map((i) => i.id)
          .filter(Boolean)
        n.setColumnPinning((i) => {
          var s, o
          if (t === 'right') {
            var a, l
            return {
              left: ((a = i?.left) != null ? a : []).filter((f) => !(r != null && r.includes(f))),
              right: [
                ...((l = i?.right) != null ? l : []).filter((f) => !(r != null && r.includes(f))),
                ...r,
              ],
            }
          }
          if (t === 'left') {
            var c, u
            return {
              left: [
                ...((c = i?.left) != null ? c : []).filter((f) => !(r != null && r.includes(f))),
                ...r,
              ],
              right: ((u = i?.right) != null ? u : []).filter((f) => !(r != null && r.includes(f))),
            }
          }
          return {
            left: ((s = i?.left) != null ? s : []).filter((f) => !(r != null && r.includes(f))),
            right: ((o = i?.right) != null ? o : []).filter((f) => !(r != null && r.includes(f))),
          }
        })
      }),
        (e.getCanPin = () =>
          e.getLeafColumns().some((r) => {
            var i, s, o
            return (
              ((i = r.columnDef.enablePinning) != null ? i : !0) &&
              ((s = (o = n.options.enableColumnPinning) != null ? o : n.options.enablePinning) !=
              null
                ? s
                : !0)
            )
          })),
        (e.getIsPinned = () => {
          const t = e.getLeafColumns().map((a) => a.id),
            { left: r, right: i } = n.getState().columnPinning,
            s = t.some((a) => r?.includes(a)),
            o = t.some((a) => i?.includes(a))
          return s ? 'left' : o ? 'right' : !1
        }),
        (e.getPinnedIndex = () => {
          var t, r
          const i = e.getIsPinned()
          return i
            ? (t =
                (r = n.getState().columnPinning) == null || (r = r[i]) == null
                  ? void 0
                  : r.indexOf(e.id)) != null
              ? t
              : -1
            : 0
        }))
    },
    createRow: (e, n) => {
      ;((e.getCenterVisibleCells = ne(
        () => [
          e._getAllVisibleCells(),
          n.getState().columnPinning.left,
          n.getState().columnPinning.right,
        ],
        (t, r, i) => {
          const s = [...(r ?? []), ...(i ?? [])]
          return t.filter((o) => !s.includes(o.column.id))
        },
        re(n.options, 'debugRows'),
      )),
        (e.getLeftVisibleCells = ne(
          () => [e._getAllVisibleCells(), n.getState().columnPinning.left],
          (t, r) =>
            (r ?? [])
              .map((s) => t.find((o) => o.column.id === s))
              .filter(Boolean)
              .map((s) => ({ ...s, position: 'left' })),
          re(n.options, 'debugRows'),
        )),
        (e.getRightVisibleCells = ne(
          () => [e._getAllVisibleCells(), n.getState().columnPinning.right],
          (t, r) =>
            (r ?? [])
              .map((s) => t.find((o) => o.column.id === s))
              .filter(Boolean)
              .map((s) => ({ ...s, position: 'right' })),
          re(n.options, 'debugRows'),
        )))
    },
    createTable: (e) => {
      ;((e.setColumnPinning = (n) =>
        e.options.onColumnPinningChange == null ? void 0 : e.options.onColumnPinningChange(n)),
        (e.resetColumnPinning = (n) => {
          var t, r
          return e.setColumnPinning(
            n
              ? jd()
              : (t = (r = e.initialState) == null ? void 0 : r.columnPinning) != null
                ? t
                : jd(),
          )
        }),
        (e.getIsSomeColumnsPinned = (n) => {
          var t
          const r = e.getState().columnPinning
          if (!n) {
            var i, s
            return !!(((i = r.left) != null && i.length) || ((s = r.right) != null && s.length))
          }
          return !!((t = r[n]) != null && t.length)
        }),
        (e.getLeftLeafColumns = ne(
          () => [e.getAllLeafColumns(), e.getState().columnPinning.left],
          (n, t) => (t ?? []).map((r) => n.find((i) => i.id === r)).filter(Boolean),
          re(e.options, 'debugColumns'),
        )),
        (e.getRightLeafColumns = ne(
          () => [e.getAllLeafColumns(), e.getState().columnPinning.right],
          (n, t) => (t ?? []).map((r) => n.find((i) => i.id === r)).filter(Boolean),
          re(e.options, 'debugColumns'),
        )),
        (e.getCenterLeafColumns = ne(
          () => [
            e.getAllLeafColumns(),
            e.getState().columnPinning.left,
            e.getState().columnPinning.right,
          ],
          (n, t, r) => {
            const i = [...(t ?? []), ...(r ?? [])]
            return n.filter((s) => !i.includes(s.id))
          },
          re(e.options, 'debugColumns'),
        )))
    },
  }
function iI(e) {
  return e || (typeof document < 'u' ? document : null)
}
const oc = { size: 150, minSize: 20, maxSize: Number.MAX_SAFE_INTEGER },
  Ld = () => ({
    startOffset: null,
    startSize: null,
    deltaOffset: null,
    deltaPercentage: null,
    isResizingColumn: !1,
    columnSizingStart: [],
  }),
  sI = {
    getDefaultColumnDef: () => oc,
    getInitialState: (e) => ({ columnSizing: {}, columnSizingInfo: Ld(), ...e }),
    getDefaultOptions: (e) => ({
      columnResizeMode: 'onEnd',
      columnResizeDirection: 'ltr',
      onColumnSizingChange: Wn('columnSizing', e),
      onColumnSizingInfoChange: Wn('columnSizingInfo', e),
    }),
    createColumn: (e, n) => {
      ;((e.getSize = () => {
        var t, r, i
        const s = n.getState().columnSizing[e.id]
        return Math.min(
          Math.max(
            (t = e.columnDef.minSize) != null ? t : oc.minSize,
            (r = s ?? e.columnDef.size) != null ? r : oc.size,
          ),
          (i = e.columnDef.maxSize) != null ? i : oc.maxSize,
        )
      }),
        (e.getStart = ne(
          (t) => [t, Ia(n, t), n.getState().columnSizing],
          (t, r) => r.slice(0, e.getIndex(t)).reduce((i, s) => i + s.getSize(), 0),
          re(n.options, 'debugColumns'),
        )),
        (e.getAfter = ne(
          (t) => [t, Ia(n, t), n.getState().columnSizing],
          (t, r) => r.slice(e.getIndex(t) + 1).reduce((i, s) => i + s.getSize(), 0),
          re(n.options, 'debugColumns'),
        )),
        (e.resetSize = () => {
          n.setColumnSizing((t) => {
            let { [e.id]: r, ...i } = t
            return i
          })
        }),
        (e.getCanResize = () => {
          var t, r
          return (
            ((t = e.columnDef.enableResizing) != null ? t : !0) &&
            ((r = n.options.enableColumnResizing) != null ? r : !0)
          )
        }),
        (e.getIsResizing = () => n.getState().columnSizingInfo.isResizingColumn === e.id))
    },
    createHeader: (e, n) => {
      ;((e.getSize = () => {
        let t = 0
        const r = (i) => {
          if (i.subHeaders.length) i.subHeaders.forEach(r)
          else {
            var s
            t += (s = i.column.getSize()) != null ? s : 0
          }
        }
        return (r(e), t)
      }),
        (e.getStart = () => {
          if (e.index > 0) {
            const t = e.headerGroup.headers[e.index - 1]
            return t.getStart() + t.getSize()
          }
          return 0
        }),
        (e.getResizeHandler = (t) => {
          const r = n.getColumn(e.column.id),
            i = r?.getCanResize()
          return (s) => {
            if (
              !r ||
              !i ||
              (s.persist == null || s.persist(), Fd(s) && s.touches && s.touches.length > 1)
            )
              return
            const o = e.getSize(),
              a = e
                ? e.getLeafHeaders().map((y) => [y.column.id, y.column.getSize()])
                : [[r.id, r.getSize()]],
              l = Fd(s) ? Math.round(s.touches[0].clientX) : s.clientX,
              c = {},
              u = (y, b) => {
                typeof b == 'number' &&
                  (n.setColumnSizingInfo((w) => {
                    var C, T
                    const I = n.options.columnResizeDirection === 'rtl' ? -1 : 1,
                      B = (b - ((C = w?.startOffset) != null ? C : 0)) * I,
                      E = Math.max(B / ((T = w?.startSize) != null ? T : 0), -0.999999)
                    return (
                      w.columnSizingStart.forEach((O) => {
                        let [P, $] = O
                        c[P] = Math.round(Math.max($ + $ * E, 0) * 100) / 100
                      }),
                      { ...w, deltaOffset: B, deltaPercentage: E }
                    )
                  }),
                  (n.options.columnResizeMode === 'onChange' || y === 'end') &&
                    n.setColumnSizing((w) => ({ ...w, ...c })))
              },
              f = (y) => u('move', y),
              d = (y) => {
                ;(u('end', y),
                  n.setColumnSizingInfo((b) => ({
                    ...b,
                    isResizingColumn: !1,
                    startOffset: null,
                    startSize: null,
                    deltaOffset: null,
                    deltaPercentage: null,
                    columnSizingStart: [],
                  })))
              },
              h = iI(t),
              p = {
                moveHandler: (y) => f(y.clientX),
                upHandler: (y) => {
                  ;(h?.removeEventListener('mousemove', p.moveHandler),
                    h?.removeEventListener('mouseup', p.upHandler),
                    d(y.clientX))
                },
              },
              g = {
                moveHandler: (y) => (
                  y.cancelable && (y.preventDefault(), y.stopPropagation()),
                  f(y.touches[0].clientX),
                  !1
                ),
                upHandler: (y) => {
                  var b
                  ;(h?.removeEventListener('touchmove', g.moveHandler),
                    h?.removeEventListener('touchend', g.upHandler),
                    y.cancelable && (y.preventDefault(), y.stopPropagation()),
                    d((b = y.touches[0]) == null ? void 0 : b.clientX))
                },
              },
              m = oI() ? { passive: !1 } : !1
            ;(Fd(s)
              ? (h?.addEventListener('touchmove', g.moveHandler, m),
                h?.addEventListener('touchend', g.upHandler, m))
              : (h?.addEventListener('mousemove', p.moveHandler, m),
                h?.addEventListener('mouseup', p.upHandler, m)),
              n.setColumnSizingInfo((y) => ({
                ...y,
                startOffset: l,
                startSize: o,
                deltaOffset: 0,
                deltaPercentage: 0,
                columnSizingStart: a,
                isResizingColumn: r.id,
              })))
          }
        }))
    },
    createTable: (e) => {
      ;((e.setColumnSizing = (n) =>
        e.options.onColumnSizingChange == null ? void 0 : e.options.onColumnSizingChange(n)),
        (e.setColumnSizingInfo = (n) =>
          e.options.onColumnSizingInfoChange == null
            ? void 0
            : e.options.onColumnSizingInfoChange(n)),
        (e.resetColumnSizing = (n) => {
          var t
          e.setColumnSizing(n ? {} : (t = e.initialState.columnSizing) != null ? t : {})
        }),
        (e.resetHeaderSizeInfo = (n) => {
          var t
          e.setColumnSizingInfo(n ? Ld() : (t = e.initialState.columnSizingInfo) != null ? t : Ld())
        }),
        (e.getTotalSize = () => {
          var n, t
          return (n =
            (t = e.getHeaderGroups()[0]) == null
              ? void 0
              : t.headers.reduce((r, i) => r + i.getSize(), 0)) != null
            ? n
            : 0
        }),
        (e.getLeftTotalSize = () => {
          var n, t
          return (n =
            (t = e.getLeftHeaderGroups()[0]) == null
              ? void 0
              : t.headers.reduce((r, i) => r + i.getSize(), 0)) != null
            ? n
            : 0
        }),
        (e.getCenterTotalSize = () => {
          var n, t
          return (n =
            (t = e.getCenterHeaderGroups()[0]) == null
              ? void 0
              : t.headers.reduce((r, i) => r + i.getSize(), 0)) != null
            ? n
            : 0
        }),
        (e.getRightTotalSize = () => {
          var n, t
          return (n =
            (t = e.getRightHeaderGroups()[0]) == null
              ? void 0
              : t.headers.reduce((r, i) => r + i.getSize(), 0)) != null
            ? n
            : 0
        }))
    },
  }
let ac = null
function oI() {
  if (typeof ac == 'boolean') return ac
  let e = !1
  try {
    const n = {
        get passive() {
          return ((e = !0), !1)
        },
      },
      t = () => {}
    ;(window.addEventListener('test', t, n), window.removeEventListener('test', t))
  } catch {
    e = !1
  }
  return ((ac = e), ac)
}
function Fd(e) {
  return e.type === 'touchstart'
}
const aI = {
  getInitialState: (e) => ({ columnVisibility: {}, ...e }),
  getDefaultOptions: (e) => ({ onColumnVisibilityChange: Wn('columnVisibility', e) }),
  createColumn: (e, n) => {
    ;((e.toggleVisibility = (t) => {
      e.getCanHide() && n.setColumnVisibility((r) => ({ ...r, [e.id]: t ?? !e.getIsVisible() }))
    }),
      (e.getIsVisible = () => {
        var t, r
        const i = e.columns
        return (t = i.length
          ? i.some((s) => s.getIsVisible())
          : (r = n.getState().columnVisibility) == null
            ? void 0
            : r[e.id]) != null
          ? t
          : !0
      }),
      (e.getCanHide = () => {
        var t, r
        return (
          ((t = e.columnDef.enableHiding) != null ? t : !0) &&
          ((r = n.options.enableHiding) != null ? r : !0)
        )
      }),
      (e.getToggleVisibilityHandler = () => (t) => {
        e.toggleVisibility == null || e.toggleVisibility(t.target.checked)
      }))
  },
  createRow: (e, n) => {
    ;((e._getAllVisibleCells = ne(
      () => [e.getAllCells(), n.getState().columnVisibility],
      (t) => t.filter((r) => r.column.getIsVisible()),
      re(n.options, 'debugRows'),
    )),
      (e.getVisibleCells = ne(
        () => [e.getLeftVisibleCells(), e.getCenterVisibleCells(), e.getRightVisibleCells()],
        (t, r, i) => [...t, ...r, ...i],
        re(n.options, 'debugRows'),
      )))
  },
  createTable: (e) => {
    const n = (t, r) =>
      ne(
        () => [
          r(),
          r()
            .filter((i) => i.getIsVisible())
            .map((i) => i.id)
            .join('_'),
        ],
        (i) => i.filter((s) => (s.getIsVisible == null ? void 0 : s.getIsVisible())),
        re(e.options, 'debugColumns'),
      )
    ;((e.getVisibleFlatColumns = n('getVisibleFlatColumns', () => e.getAllFlatColumns())),
      (e.getVisibleLeafColumns = n('getVisibleLeafColumns', () => e.getAllLeafColumns())),
      (e.getLeftVisibleLeafColumns = n('getLeftVisibleLeafColumns', () => e.getLeftLeafColumns())),
      (e.getRightVisibleLeafColumns = n('getRightVisibleLeafColumns', () =>
        e.getRightLeafColumns(),
      )),
      (e.getCenterVisibleLeafColumns = n('getCenterVisibleLeafColumns', () =>
        e.getCenterLeafColumns(),
      )),
      (e.setColumnVisibility = (t) =>
        e.options.onColumnVisibilityChange == null
          ? void 0
          : e.options.onColumnVisibilityChange(t)),
      (e.resetColumnVisibility = (t) => {
        var r
        e.setColumnVisibility(t ? {} : (r = e.initialState.columnVisibility) != null ? r : {})
      }),
      (e.toggleAllColumnsVisible = (t) => {
        var r
        ;((t = (r = t) != null ? r : !e.getIsAllColumnsVisible()),
          e.setColumnVisibility(
            e
              .getAllLeafColumns()
              .reduce(
                (i, s) => ({ ...i, [s.id]: t || !(s.getCanHide != null && s.getCanHide()) }),
                {},
              ),
          ))
      }),
      (e.getIsAllColumnsVisible = () =>
        !e.getAllLeafColumns().some((t) => !(t.getIsVisible != null && t.getIsVisible()))),
      (e.getIsSomeColumnsVisible = () =>
        e.getAllLeafColumns().some((t) => (t.getIsVisible == null ? void 0 : t.getIsVisible()))),
      (e.getToggleAllColumnsVisibilityHandler = () => (t) => {
        var r
        e.toggleAllColumnsVisible((r = t.target) == null ? void 0 : r.checked)
      }))
  },
}
function Ia(e, n) {
  return n
    ? n === 'center'
      ? e.getCenterVisibleLeafColumns()
      : n === 'left'
        ? e.getLeftVisibleLeafColumns()
        : e.getRightVisibleLeafColumns()
    : e.getVisibleLeafColumns()
}
const lI = {
    createTable: (e) => {
      ;((e._getGlobalFacetedRowModel =
        e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, '__global__')),
        (e.getGlobalFacetedRowModel = () =>
          e.options.manualFiltering || !e._getGlobalFacetedRowModel
            ? e.getPreFilteredRowModel()
            : e._getGlobalFacetedRowModel()),
        (e._getGlobalFacetedUniqueValues =
          e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, '__global__')),
        (e.getGlobalFacetedUniqueValues = () =>
          e._getGlobalFacetedUniqueValues ? e._getGlobalFacetedUniqueValues() : new Map()),
        (e._getGlobalFacetedMinMaxValues =
          e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, '__global__')),
        (e.getGlobalFacetedMinMaxValues = () => {
          if (e._getGlobalFacetedMinMaxValues) return e._getGlobalFacetedMinMaxValues()
        }))
    },
  },
  cI = {
    getInitialState: (e) => ({ globalFilter: void 0, ...e }),
    getDefaultOptions: (e) => ({
      onGlobalFilterChange: Wn('globalFilter', e),
      globalFilterFn: 'auto',
      getColumnCanGlobalFilter: (n) => {
        var t
        const r =
          (t = e.getCoreRowModel().flatRows[0]) == null ||
          (t = t._getAllCellsByColumnId()[n.id]) == null
            ? void 0
            : t.getValue()
        return typeof r == 'string' || typeof r == 'number'
      },
    }),
    createColumn: (e, n) => {
      e.getCanGlobalFilter = () => {
        var t, r, i, s
        return (
          ((t = e.columnDef.enableGlobalFilter) != null ? t : !0) &&
          ((r = n.options.enableGlobalFilter) != null ? r : !0) &&
          ((i = n.options.enableFilters) != null ? i : !0) &&
          ((s =
            n.options.getColumnCanGlobalFilter == null
              ? void 0
              : n.options.getColumnCanGlobalFilter(e)) != null
            ? s
            : !0) &&
          !!e.accessorFn
        )
      }
    },
    createTable: (e) => {
      ;((e.getGlobalAutoFilterFn = () => Kr.includesString),
        (e.getGlobalFilterFn = () => {
          var n, t
          const { globalFilterFn: r } = e.options
          return Af(r)
            ? r
            : r === 'auto'
              ? e.getGlobalAutoFilterFn()
              : (n = (t = e.options.filterFns) == null ? void 0 : t[r]) != null
                ? n
                : Kr[r]
        }),
        (e.setGlobalFilter = (n) => {
          e.options.onGlobalFilterChange == null || e.options.onGlobalFilterChange(n)
        }),
        (e.resetGlobalFilter = (n) => {
          e.setGlobalFilter(n ? void 0 : e.initialState.globalFilter)
        }))
    },
  },
  uI = {
    getInitialState: (e) => ({ expanded: {}, ...e }),
    getDefaultOptions: (e) => ({ onExpandedChange: Wn('expanded', e), paginateExpandedRows: !0 }),
    createTable: (e) => {
      let n = !1,
        t = !1
      ;((e._autoResetExpanded = () => {
        var r, i
        if (!n) {
          e._queue(() => {
            n = !0
          })
          return
        }
        if (
          (r = (i = e.options.autoResetAll) != null ? i : e.options.autoResetExpanded) != null
            ? r
            : !e.options.manualExpanding
        ) {
          if (t) return
          ;((t = !0),
            e._queue(() => {
              ;(e.resetExpanded(), (t = !1))
            }))
        }
      }),
        (e.setExpanded = (r) =>
          e.options.onExpandedChange == null ? void 0 : e.options.onExpandedChange(r)),
        (e.toggleAllRowsExpanded = (r) => {
          ;(r ?? !e.getIsAllRowsExpanded()) ? e.setExpanded(!0) : e.setExpanded({})
        }),
        (e.resetExpanded = (r) => {
          var i, s
          e.setExpanded(
            r ? {} : (i = (s = e.initialState) == null ? void 0 : s.expanded) != null ? i : {},
          )
        }),
        (e.getCanSomeRowsExpand = () =>
          e.getPrePaginationRowModel().flatRows.some((r) => r.getCanExpand())),
        (e.getToggleAllRowsExpandedHandler = () => (r) => {
          ;(r.persist == null || r.persist(), e.toggleAllRowsExpanded())
        }),
        (e.getIsSomeRowsExpanded = () => {
          const r = e.getState().expanded
          return r === !0 || Object.values(r).some(Boolean)
        }),
        (e.getIsAllRowsExpanded = () => {
          const r = e.getState().expanded
          return typeof r == 'boolean'
            ? r === !0
            : !(!Object.keys(r).length || e.getRowModel().flatRows.some((i) => !i.getIsExpanded()))
        }),
        (e.getExpandedDepth = () => {
          let r = 0
          return (
            (e.getState().expanded === !0
              ? Object.keys(e.getRowModel().rowsById)
              : Object.keys(e.getState().expanded)
            ).forEach((s) => {
              const o = s.split('.')
              r = Math.max(r, o.length)
            }),
            r
          )
        }),
        (e.getPreExpandedRowModel = () => e.getSortedRowModel()),
        (e.getExpandedRowModel = () => (
          !e._getExpandedRowModel &&
            e.options.getExpandedRowModel &&
            (e._getExpandedRowModel = e.options.getExpandedRowModel(e)),
          e.options.manualExpanding || !e._getExpandedRowModel
            ? e.getPreExpandedRowModel()
            : e._getExpandedRowModel()
        )))
    },
    createRow: (e, n) => {
      ;((e.toggleExpanded = (t) => {
        n.setExpanded((r) => {
          var i
          const s = r === !0 ? !0 : !!(r != null && r[e.id])
          let o = {}
          if (
            (r === !0
              ? Object.keys(n.getRowModel().rowsById).forEach((a) => {
                  o[a] = !0
                })
              : (o = r),
            (t = (i = t) != null ? i : !s),
            !s && t)
          )
            return { ...o, [e.id]: !0 }
          if (s && !t) {
            const { [e.id]: a, ...l } = o
            return l
          }
          return r
        })
      }),
        (e.getIsExpanded = () => {
          var t
          const r = n.getState().expanded
          return !!((t =
            n.options.getIsRowExpanded == null ? void 0 : n.options.getIsRowExpanded(e)) != null
            ? t
            : r === !0 || r?.[e.id])
        }),
        (e.getCanExpand = () => {
          var t, r, i
          return (t = n.options.getRowCanExpand == null ? void 0 : n.options.getRowCanExpand(e)) !=
            null
            ? t
            : ((r = n.options.enableExpanding) != null ? r : !0) &&
                !!((i = e.subRows) != null && i.length)
        }),
        (e.getIsAllParentsExpanded = () => {
          let t = !0,
            r = e
          for (; t && r.parentId; ) ((r = n.getRow(r.parentId, !0)), (t = r.getIsExpanded()))
          return t
        }),
        (e.getToggleExpandedHandler = () => {
          const t = e.getCanExpand()
          return () => {
            t && e.toggleExpanded()
          }
        }))
    },
  },
  xp = 0,
  Sp = 10,
  Bd = () => ({ pageIndex: xp, pageSize: Sp }),
  fI = {
    getInitialState: (e) => ({ ...e, pagination: { ...Bd(), ...e?.pagination } }),
    getDefaultOptions: (e) => ({ onPaginationChange: Wn('pagination', e) }),
    createTable: (e) => {
      let n = !1,
        t = !1
      ;((e._autoResetPageIndex = () => {
        var r, i
        if (!n) {
          e._queue(() => {
            n = !0
          })
          return
        }
        if (
          (r = (i = e.options.autoResetAll) != null ? i : e.options.autoResetPageIndex) != null
            ? r
            : !e.options.manualPagination
        ) {
          if (t) return
          ;((t = !0),
            e._queue(() => {
              ;(e.resetPageIndex(), (t = !1))
            }))
        }
      }),
        (e.setPagination = (r) => {
          const i = (s) => Ai(r, s)
          return e.options.onPaginationChange == null ? void 0 : e.options.onPaginationChange(i)
        }),
        (e.resetPagination = (r) => {
          var i
          e.setPagination(r ? Bd() : (i = e.initialState.pagination) != null ? i : Bd())
        }),
        (e.setPageIndex = (r) => {
          e.setPagination((i) => {
            let s = Ai(r, i.pageIndex)
            const o =
              typeof e.options.pageCount > 'u' || e.options.pageCount === -1
                ? Number.MAX_SAFE_INTEGER
                : e.options.pageCount - 1
            return ((s = Math.max(0, Math.min(s, o))), { ...i, pageIndex: s })
          })
        }),
        (e.resetPageIndex = (r) => {
          var i, s
          e.setPageIndex(
            r
              ? xp
              : (i =
                    (s = e.initialState) == null || (s = s.pagination) == null
                      ? void 0
                      : s.pageIndex) != null
                ? i
                : xp,
          )
        }),
        (e.resetPageSize = (r) => {
          var i, s
          e.setPageSize(
            r
              ? Sp
              : (i =
                    (s = e.initialState) == null || (s = s.pagination) == null
                      ? void 0
                      : s.pageSize) != null
                ? i
                : Sp,
          )
        }),
        (e.setPageSize = (r) => {
          e.setPagination((i) => {
            const s = Math.max(1, Ai(r, i.pageSize)),
              o = i.pageSize * i.pageIndex,
              a = Math.floor(o / s)
            return { ...i, pageIndex: a, pageSize: s }
          })
        }),
        (e.setPageCount = (r) =>
          e.setPagination((i) => {
            var s
            let o = Ai(r, (s = e.options.pageCount) != null ? s : -1)
            return (typeof o == 'number' && (o = Math.max(-1, o)), { ...i, pageCount: o })
          })),
        (e.getPageOptions = ne(
          () => [e.getPageCount()],
          (r) => {
            let i = []
            return (r && r > 0 && (i = [...new Array(r)].fill(null).map((s, o) => o)), i)
          },
          re(e.options, 'debugTable'),
        )),
        (e.getCanPreviousPage = () => e.getState().pagination.pageIndex > 0),
        (e.getCanNextPage = () => {
          const { pageIndex: r } = e.getState().pagination,
            i = e.getPageCount()
          return i === -1 ? !0 : i === 0 ? !1 : r < i - 1
        }),
        (e.previousPage = () => e.setPageIndex((r) => r - 1)),
        (e.nextPage = () => e.setPageIndex((r) => r + 1)),
        (e.firstPage = () => e.setPageIndex(0)),
        (e.lastPage = () => e.setPageIndex(e.getPageCount() - 1)),
        (e.getPrePaginationRowModel = () => e.getExpandedRowModel()),
        (e.getPaginationRowModel = () => (
          !e._getPaginationRowModel &&
            e.options.getPaginationRowModel &&
            (e._getPaginationRowModel = e.options.getPaginationRowModel(e)),
          e.options.manualPagination || !e._getPaginationRowModel
            ? e.getPrePaginationRowModel()
            : e._getPaginationRowModel()
        )),
        (e.getPageCount = () => {
          var r
          return (r = e.options.pageCount) != null
            ? r
            : Math.ceil(e.getRowCount() / e.getState().pagination.pageSize)
        }),
        (e.getRowCount = () => {
          var r
          return (r = e.options.rowCount) != null ? r : e.getPrePaginationRowModel().rows.length
        }))
    },
  },
  zd = () => ({ top: [], bottom: [] }),
  dI = {
    getInitialState: (e) => ({ rowPinning: zd(), ...e }),
    getDefaultOptions: (e) => ({ onRowPinningChange: Wn('rowPinning', e) }),
    createRow: (e, n) => {
      ;((e.pin = (t, r, i) => {
        const s = r
            ? e.getLeafRows().map((l) => {
                let { id: c } = l
                return c
              })
            : [],
          o = i
            ? e.getParentRows().map((l) => {
                let { id: c } = l
                return c
              })
            : [],
          a = new Set([...o, e.id, ...s])
        n.setRowPinning((l) => {
          var c, u
          if (t === 'bottom') {
            var f, d
            return {
              top: ((f = l?.top) != null ? f : []).filter((g) => !(a != null && a.has(g))),
              bottom: [
                ...((d = l?.bottom) != null ? d : []).filter((g) => !(a != null && a.has(g))),
                ...Array.from(a),
              ],
            }
          }
          if (t === 'top') {
            var h, p
            return {
              top: [
                ...((h = l?.top) != null ? h : []).filter((g) => !(a != null && a.has(g))),
                ...Array.from(a),
              ],
              bottom: ((p = l?.bottom) != null ? p : []).filter((g) => !(a != null && a.has(g))),
            }
          }
          return {
            top: ((c = l?.top) != null ? c : []).filter((g) => !(a != null && a.has(g))),
            bottom: ((u = l?.bottom) != null ? u : []).filter((g) => !(a != null && a.has(g))),
          }
        })
      }),
        (e.getCanPin = () => {
          var t
          const { enableRowPinning: r, enablePinning: i } = n.options
          return typeof r == 'function' ? r(e) : (t = r ?? i) != null ? t : !0
        }),
        (e.getIsPinned = () => {
          const t = [e.id],
            { top: r, bottom: i } = n.getState().rowPinning,
            s = t.some((a) => r?.includes(a)),
            o = t.some((a) => i?.includes(a))
          return s ? 'top' : o ? 'bottom' : !1
        }),
        (e.getPinnedIndex = () => {
          var t, r
          const i = e.getIsPinned()
          if (!i) return -1
          const s =
            (t = i === 'top' ? n.getTopRows() : n.getBottomRows()) == null
              ? void 0
              : t.map((o) => {
                  let { id: a } = o
                  return a
                })
          return (r = s?.indexOf(e.id)) != null ? r : -1
        }))
    },
    createTable: (e) => {
      ;((e.setRowPinning = (n) =>
        e.options.onRowPinningChange == null ? void 0 : e.options.onRowPinningChange(n)),
        (e.resetRowPinning = (n) => {
          var t, r
          return e.setRowPinning(
            n
              ? zd()
              : (t = (r = e.initialState) == null ? void 0 : r.rowPinning) != null
                ? t
                : zd(),
          )
        }),
        (e.getIsSomeRowsPinned = (n) => {
          var t
          const r = e.getState().rowPinning
          if (!n) {
            var i, s
            return !!(((i = r.top) != null && i.length) || ((s = r.bottom) != null && s.length))
          }
          return !!((t = r[n]) != null && t.length)
        }),
        (e._getPinnedRows = (n, t, r) => {
          var i
          return (
            (i = e.options.keepPinnedRows) == null || i
              ? (t ?? []).map((o) => {
                  const a = e.getRow(o, !0)
                  return a.getIsAllParentsExpanded() ? a : null
                })
              : (t ?? []).map((o) => n.find((a) => a.id === o))
          )
            .filter(Boolean)
            .map((o) => ({ ...o, position: r }))
        }),
        (e.getTopRows = ne(
          () => [e.getRowModel().rows, e.getState().rowPinning.top],
          (n, t) => e._getPinnedRows(n, t, 'top'),
          re(e.options, 'debugRows'),
        )),
        (e.getBottomRows = ne(
          () => [e.getRowModel().rows, e.getState().rowPinning.bottom],
          (n, t) => e._getPinnedRows(n, t, 'bottom'),
          re(e.options, 'debugRows'),
        )),
        (e.getCenterRows = ne(
          () => [e.getRowModel().rows, e.getState().rowPinning.top, e.getState().rowPinning.bottom],
          (n, t, r) => {
            const i = new Set([...(t ?? []), ...(r ?? [])])
            return n.filter((s) => !i.has(s.id))
          },
          re(e.options, 'debugRows'),
        )))
    },
  },
  hI = {
    getInitialState: (e) => ({ rowSelection: {}, ...e }),
    getDefaultOptions: (e) => ({
      onRowSelectionChange: Wn('rowSelection', e),
      enableRowSelection: !0,
      enableMultiRowSelection: !0,
      enableSubRowSelection: !0,
    }),
    createTable: (e) => {
      ;((e.setRowSelection = (n) =>
        e.options.onRowSelectionChange == null ? void 0 : e.options.onRowSelectionChange(n)),
        (e.resetRowSelection = (n) => {
          var t
          return e.setRowSelection(n ? {} : (t = e.initialState.rowSelection) != null ? t : {})
        }),
        (e.toggleAllRowsSelected = (n) => {
          e.setRowSelection((t) => {
            n = typeof n < 'u' ? n : !e.getIsAllRowsSelected()
            const r = { ...t },
              i = e.getPreGroupedRowModel().flatRows
            return (
              n
                ? i.forEach((s) => {
                    s.getCanSelect() && (r[s.id] = !0)
                  })
                : i.forEach((s) => {
                    delete r[s.id]
                  }),
              r
            )
          })
        }),
        (e.toggleAllPageRowsSelected = (n) =>
          e.setRowSelection((t) => {
            const r = typeof n < 'u' ? n : !e.getIsAllPageRowsSelected(),
              i = { ...t }
            return (
              e.getRowModel().rows.forEach((s) => {
                _p(i, s.id, r, !0, e)
              }),
              i
            )
          })),
        (e.getPreSelectedRowModel = () => e.getCoreRowModel()),
        (e.getSelectedRowModel = ne(
          () => [e.getState().rowSelection, e.getCoreRowModel()],
          (n, t) => (Object.keys(n).length ? $d(e, t) : { rows: [], flatRows: [], rowsById: {} }),
          re(e.options, 'debugTable'),
        )),
        (e.getFilteredSelectedRowModel = ne(
          () => [e.getState().rowSelection, e.getFilteredRowModel()],
          (n, t) => (Object.keys(n).length ? $d(e, t) : { rows: [], flatRows: [], rowsById: {} }),
          re(e.options, 'debugTable'),
        )),
        (e.getGroupedSelectedRowModel = ne(
          () => [e.getState().rowSelection, e.getSortedRowModel()],
          (n, t) => (Object.keys(n).length ? $d(e, t) : { rows: [], flatRows: [], rowsById: {} }),
          re(e.options, 'debugTable'),
        )),
        (e.getIsAllRowsSelected = () => {
          const n = e.getFilteredRowModel().flatRows,
            { rowSelection: t } = e.getState()
          let r = !!(n.length && Object.keys(t).length)
          return (r && n.some((i) => i.getCanSelect() && !t[i.id]) && (r = !1), r)
        }),
        (e.getIsAllPageRowsSelected = () => {
          const n = e.getPaginationRowModel().flatRows.filter((i) => i.getCanSelect()),
            { rowSelection: t } = e.getState()
          let r = !!n.length
          return (r && n.some((i) => !t[i.id]) && (r = !1), r)
        }),
        (e.getIsSomeRowsSelected = () => {
          var n
          const t = Object.keys((n = e.getState().rowSelection) != null ? n : {}).length
          return t > 0 && t < e.getFilteredRowModel().flatRows.length
        }),
        (e.getIsSomePageRowsSelected = () => {
          const n = e.getPaginationRowModel().flatRows
          return e.getIsAllPageRowsSelected()
            ? !1
            : n
                .filter((t) => t.getCanSelect())
                .some((t) => t.getIsSelected() || t.getIsSomeSelected())
        }),
        (e.getToggleAllRowsSelectedHandler = () => (n) => {
          e.toggleAllRowsSelected(n.target.checked)
        }),
        (e.getToggleAllPageRowsSelectedHandler = () => (n) => {
          e.toggleAllPageRowsSelected(n.target.checked)
        }))
    },
    createRow: (e, n) => {
      ;((e.toggleSelected = (t, r) => {
        const i = e.getIsSelected()
        n.setRowSelection((s) => {
          var o
          if (((t = typeof t < 'u' ? t : !i), e.getCanSelect() && i === t)) return s
          const a = { ...s }
          return (_p(a, e.id, t, (o = r?.selectChildren) != null ? o : !0, n), a)
        })
      }),
        (e.getIsSelected = () => {
          const { rowSelection: t } = n.getState()
          return _0(e, t)
        }),
        (e.getIsSomeSelected = () => {
          const { rowSelection: t } = n.getState()
          return kp(e, t) === 'some'
        }),
        (e.getIsAllSubRowsSelected = () => {
          const { rowSelection: t } = n.getState()
          return kp(e, t) === 'all'
        }),
        (e.getCanSelect = () => {
          var t
          return typeof n.options.enableRowSelection == 'function'
            ? n.options.enableRowSelection(e)
            : (t = n.options.enableRowSelection) != null
              ? t
              : !0
        }),
        (e.getCanSelectSubRows = () => {
          var t
          return typeof n.options.enableSubRowSelection == 'function'
            ? n.options.enableSubRowSelection(e)
            : (t = n.options.enableSubRowSelection) != null
              ? t
              : !0
        }),
        (e.getCanMultiSelect = () => {
          var t
          return typeof n.options.enableMultiRowSelection == 'function'
            ? n.options.enableMultiRowSelection(e)
            : (t = n.options.enableMultiRowSelection) != null
              ? t
              : !0
        }),
        (e.getToggleSelectedHandler = () => {
          const t = e.getCanSelect()
          return (r) => {
            var i
            t && e.toggleSelected((i = r.target) == null ? void 0 : i.checked)
          }
        }))
    },
  },
  _p = (e, n, t, r, i) => {
    var s
    const o = i.getRow(n, !0)
    ;(t
      ? (o.getCanMultiSelect() || Object.keys(e).forEach((a) => delete e[a]),
        o.getCanSelect() && (e[n] = !0))
      : delete e[n],
      r &&
        (s = o.subRows) != null &&
        s.length &&
        o.getCanSelectSubRows() &&
        o.subRows.forEach((a) => _p(e, a.id, t, r, i)))
  }
function $d(e, n) {
  const t = e.getState().rowSelection,
    r = [],
    i = {},
    s = function (o, a) {
      return o
        .map((l) => {
          var c
          const u = _0(l, t)
          if (
            (u && (r.push(l), (i[l.id] = l)),
            (c = l.subRows) != null && c.length && (l = { ...l, subRows: s(l.subRows) }),
            u)
          )
            return l
        })
        .filter(Boolean)
    }
  return { rows: s(n.rows), flatRows: r, rowsById: i }
}
function _0(e, n) {
  var t
  return (t = n[e.id]) != null ? t : !1
}
function kp(e, n, t) {
  var r
  if (!((r = e.subRows) != null && r.length)) return !1
  let i = !0,
    s = !1
  return (
    e.subRows.forEach((o) => {
      if (
        !(s && !i) &&
        (o.getCanSelect() && (_0(o, n) ? (s = !0) : (i = !1)), o.subRows && o.subRows.length)
      ) {
        const a = kp(o, n)
        a === 'all' ? (s = !0) : (a === 'some' && (s = !0), (i = !1))
      }
    }),
    i ? 'all' : s ? 'some' : !1
  )
}
const Cp = /([0-9]+)/gm,
  pI = (e, n, t) => C3(Wi(e.getValue(t)).toLowerCase(), Wi(n.getValue(t)).toLowerCase()),
  mI = (e, n, t) => C3(Wi(e.getValue(t)), Wi(n.getValue(t))),
  gI = (e, n, t) => k0(Wi(e.getValue(t)).toLowerCase(), Wi(n.getValue(t)).toLowerCase()),
  yI = (e, n, t) => k0(Wi(e.getValue(t)), Wi(n.getValue(t))),
  bI = (e, n, t) => {
    const r = e.getValue(t),
      i = n.getValue(t)
    return r > i ? 1 : r < i ? -1 : 0
  },
  vI = (e, n, t) => k0(e.getValue(t), n.getValue(t))
function k0(e, n) {
  return e === n ? 0 : e > n ? 1 : -1
}
function Wi(e) {
  return typeof e == 'number'
    ? isNaN(e) || e === 1 / 0 || e === -1 / 0
      ? ''
      : String(e)
    : typeof e == 'string'
      ? e
      : ''
}
function C3(e, n) {
  const t = e.split(Cp).filter(Boolean),
    r = n.split(Cp).filter(Boolean)
  for (; t.length && r.length; ) {
    const i = t.shift(),
      s = r.shift(),
      o = parseInt(i, 10),
      a = parseInt(s, 10),
      l = [o, a].sort()
    if (isNaN(l[0])) {
      if (i > s) return 1
      if (s > i) return -1
      continue
    }
    if (isNaN(l[1])) return isNaN(o) ? -1 : 1
    if (o > a) return 1
    if (a > o) return -1
  }
  return t.length - r.length
}
const ca = {
    alphanumeric: pI,
    alphanumericCaseSensitive: mI,
    text: gI,
    textCaseSensitive: yI,
    datetime: bI,
    basic: vI,
  },
  wI = {
    getInitialState: (e) => ({ sorting: [], ...e }),
    getDefaultColumnDef: () => ({ sortingFn: 'auto', sortUndefined: 1 }),
    getDefaultOptions: (e) => ({
      onSortingChange: Wn('sorting', e),
      isMultiSortEvent: (n) => n.shiftKey,
    }),
    createColumn: (e, n) => {
      ;((e.getAutoSortingFn = () => {
        const t = n.getFilteredRowModel().flatRows.slice(10)
        let r = !1
        for (const i of t) {
          const s = i?.getValue(e.id)
          if (Object.prototype.toString.call(s) === '[object Date]') return ca.datetime
          if (typeof s == 'string' && ((r = !0), s.split(Cp).length > 1)) return ca.alphanumeric
        }
        return r ? ca.text : ca.basic
      }),
        (e.getAutoSortDir = () => {
          const t = n.getFilteredRowModel().flatRows[0]
          return typeof t?.getValue(e.id) == 'string' ? 'asc' : 'desc'
        }),
        (e.getSortingFn = () => {
          var t, r
          if (!e) throw new Error()
          return Af(e.columnDef.sortingFn)
            ? e.columnDef.sortingFn
            : e.columnDef.sortingFn === 'auto'
              ? e.getAutoSortingFn()
              : (t = (r = n.options.sortingFns) == null ? void 0 : r[e.columnDef.sortingFn]) != null
                ? t
                : ca[e.columnDef.sortingFn]
        }),
        (e.toggleSorting = (t, r) => {
          const i = e.getNextSortingOrder(),
            s = typeof t < 'u' && t !== null
          n.setSorting((o) => {
            const a = o?.find((h) => h.id === e.id),
              l = o?.findIndex((h) => h.id === e.id)
            let c = [],
              u,
              f = s ? t : i === 'desc'
            if (
              (o != null && o.length && e.getCanMultiSort() && r
                ? a
                  ? (u = 'toggle')
                  : (u = 'add')
                : o != null && o.length && l !== o.length - 1
                  ? (u = 'replace')
                  : a
                    ? (u = 'toggle')
                    : (u = 'replace'),
              u === 'toggle' && (s || i || (u = 'remove')),
              u === 'add')
            ) {
              var d
              ;((c = [...o, { id: e.id, desc: f }]),
                c.splice(
                  0,
                  c.length -
                    ((d = n.options.maxMultiSortColCount) != null ? d : Number.MAX_SAFE_INTEGER),
                ))
            } else
              u === 'toggle'
                ? (c = o.map((h) => (h.id === e.id ? { ...h, desc: f } : h)))
                : u === 'remove'
                  ? (c = o.filter((h) => h.id !== e.id))
                  : (c = [{ id: e.id, desc: f }])
            return c
          })
        }),
        (e.getFirstSortDir = () => {
          var t, r
          return (
            (t = (r = e.columnDef.sortDescFirst) != null ? r : n.options.sortDescFirst) != null
              ? t
              : e.getAutoSortDir() === 'desc'
          )
            ? 'desc'
            : 'asc'
        }),
        (e.getNextSortingOrder = (t) => {
          var r, i
          const s = e.getFirstSortDir(),
            o = e.getIsSorted()
          return o
            ? o !== s &&
              ((r = n.options.enableSortingRemoval) == null || r) &&
              (!(t && (i = n.options.enableMultiRemove) != null) || i)
              ? !1
              : o === 'desc'
                ? 'asc'
                : 'desc'
            : s
        }),
        (e.getCanSort = () => {
          var t, r
          return (
            ((t = e.columnDef.enableSorting) != null ? t : !0) &&
            ((r = n.options.enableSorting) != null ? r : !0) &&
            !!e.accessorFn
          )
        }),
        (e.getCanMultiSort = () => {
          var t, r
          return (t = (r = e.columnDef.enableMultiSort) != null ? r : n.options.enableMultiSort) !=
            null
            ? t
            : !!e.accessorFn
        }),
        (e.getIsSorted = () => {
          var t
          const r = (t = n.getState().sorting) == null ? void 0 : t.find((i) => i.id === e.id)
          return r ? (r.desc ? 'desc' : 'asc') : !1
        }),
        (e.getSortIndex = () => {
          var t, r
          return (t =
            (r = n.getState().sorting) == null ? void 0 : r.findIndex((i) => i.id === e.id)) != null
            ? t
            : -1
        }),
        (e.clearSorting = () => {
          n.setSorting((t) => (t != null && t.length ? t.filter((r) => r.id !== e.id) : []))
        }),
        (e.getToggleSortingHandler = () => {
          const t = e.getCanSort()
          return (r) => {
            t &&
              (r.persist == null || r.persist(),
              e.toggleSorting == null ||
                e.toggleSorting(
                  void 0,
                  e.getCanMultiSort()
                    ? n.options.isMultiSortEvent == null
                      ? void 0
                      : n.options.isMultiSortEvent(r)
                    : !1,
                ))
          }
        }))
    },
    createTable: (e) => {
      ;((e.setSorting = (n) =>
        e.options.onSortingChange == null ? void 0 : e.options.onSortingChange(n)),
        (e.resetSorting = (n) => {
          var t, r
          e.setSorting(
            n ? [] : (t = (r = e.initialState) == null ? void 0 : r.sorting) != null ? t : [],
          )
        }),
        (e.getPreSortedRowModel = () => e.getGroupedRowModel()),
        (e.getSortedRowModel = () => (
          !e._getSortedRowModel &&
            e.options.getSortedRowModel &&
            (e._getSortedRowModel = e.options.getSortedRowModel(e)),
          e.options.manualSorting || !e._getSortedRowModel
            ? e.getPreSortedRowModel()
            : e._getSortedRowModel()
        )))
    },
  },
  xI = [VN, aI, nI, rI, HN, UN, lI, cI, wI, tI, uI, fI, dI, hI, sI]
function SI(e) {
  var n, t
  const r = [...xI, ...((n = e._features) != null ? n : [])]
  let i = { _features: r }
  const s = i._features.reduce(
      (d, h) => Object.assign(d, h.getDefaultOptions == null ? void 0 : h.getDefaultOptions(i)),
      {},
    ),
    o = (d) => (i.options.mergeOptions ? i.options.mergeOptions(s, d) : { ...s, ...d })
  let l = { ...{}, ...((t = e.initialState) != null ? t : {}) }
  i._features.forEach((d) => {
    var h
    l = (h = d.getInitialState == null ? void 0 : d.getInitialState(l)) != null ? h : l
  })
  const c = []
  let u = !1
  const f = {
    _features: r,
    options: { ...s, ...e },
    initialState: l,
    _queue: (d) => {
      ;(c.push(d),
        u ||
          ((u = !0),
          Promise.resolve()
            .then(() => {
              for (; c.length; ) c.shift()()
              u = !1
            })
            .catch((h) =>
              setTimeout(() => {
                throw h
              }),
            )))
    },
    reset: () => {
      i.setState(i.initialState)
    },
    setOptions: (d) => {
      const h = Ai(d, i.options)
      i.options = o(h)
    },
    getState: () => i.options.state,
    setState: (d) => {
      i.options.onStateChange == null || i.options.onStateChange(d)
    },
    _getRowId: (d, h, p) => {
      var g
      return (g = i.options.getRowId == null ? void 0 : i.options.getRowId(d, h, p)) != null
        ? g
        : `${p ? [p.id, h].join('.') : h}`
    },
    getCoreRowModel: () => (
      i._getCoreRowModel || (i._getCoreRowModel = i.options.getCoreRowModel(i)),
      i._getCoreRowModel()
    ),
    getRowModel: () => i.getPaginationRowModel(),
    getRow: (d, h) => {
      let p = (h ? i.getPrePaginationRowModel() : i.getRowModel()).rowsById[d]
      if (!p && ((p = i.getCoreRowModel().rowsById[d]), !p)) throw new Error()
      return p
    },
    _getDefaultColumnDef: ne(
      () => [i.options.defaultColumn],
      (d) => {
        var h
        return (
          (d = (h = d) != null ? h : {}),
          {
            header: (p) => {
              const g = p.header.column.columnDef
              return g.accessorKey ? g.accessorKey : g.accessorFn ? g.id : null
            },
            cell: (p) => {
              var g, m
              return (g =
                (m = p.renderValue()) == null || m.toString == null ? void 0 : m.toString()) != null
                ? g
                : null
            },
            ...i._features.reduce(
              (p, g) =>
                Object.assign(p, g.getDefaultColumnDef == null ? void 0 : g.getDefaultColumnDef()),
              {},
            ),
            ...d,
          }
        )
      },
      re(e, 'debugColumns'),
    ),
    _getColumnDefs: () => i.options.columns,
    getAllColumns: ne(
      () => [i._getColumnDefs()],
      (d) => {
        const h = function (p, g, m) {
          return (
            m === void 0 && (m = 0),
            p.map((y) => {
              const b = $N(i, y, m, g),
                w = y
              return ((b.columns = w.columns ? h(w.columns, b, m + 1) : []), b)
            })
          )
        }
        return h(d)
      },
      re(e, 'debugColumns'),
    ),
    getAllFlatColumns: ne(
      () => [i.getAllColumns()],
      (d) => d.flatMap((h) => h.getFlatColumns()),
      re(e, 'debugColumns'),
    ),
    _getAllFlatColumnsById: ne(
      () => [i.getAllFlatColumns()],
      (d) => d.reduce((h, p) => ((h[p.id] = p), h), {}),
      re(e, 'debugColumns'),
    ),
    getAllLeafColumns: ne(
      () => [i.getAllColumns(), i._getOrderColumnsFn()],
      (d, h) => {
        let p = d.flatMap((g) => g.getLeafColumns())
        return h(p)
      },
      re(e, 'debugColumns'),
    ),
    getColumn: (d) => i._getAllFlatColumnsById()[d],
  }
  Object.assign(i, f)
  for (let d = 0; d < i._features.length; d++) {
    const h = i._features[d]
    h == null || h.createTable == null || h.createTable(i)
  }
  return i
}
function AZ() {
  return (e) =>
    ne(
      () => [e.options.data],
      (n) => {
        const t = { rows: [], flatRows: [], rowsById: {} },
          r = function (i, s, o) {
            s === void 0 && (s = 0)
            const a = []
            for (let c = 0; c < i.length; c++) {
              const u = x0(e, e._getRowId(i[c], c, o), i[c], c, s, void 0, o?.id)
              if ((t.flatRows.push(u), (t.rowsById[u.id] = u), a.push(u), e.options.getSubRows)) {
                var l
                ;((u.originalSubRows = e.options.getSubRows(i[c], c)),
                  (l = u.originalSubRows) != null &&
                    l.length &&
                    (u.subRows = r(u.originalSubRows, s + 1, u)))
              }
            }
            return a
          }
        return ((t.rows = r(n)), t)
      },
      re(e.options, 'debugTable', 'getRowModel', () => e._autoResetPageIndex()),
    )
}
function _I(e) {
  const n = [],
    t = (r) => {
      var i
      ;(n.push(r), (i = r.subRows) != null && i.length && r.getIsExpanded() && r.subRows.forEach(t))
    }
  return (e.rows.forEach(t), { rows: n, flatRows: e.flatRows, rowsById: e.rowsById })
}
function kI(e, n, t) {
  return t.options.filterFromLeafRows ? CI(e, n, t) : MI(e, n, t)
}
function CI(e, n, t) {
  var r
  const i = [],
    s = {},
    o = (r = t.options.maxLeafRowFilterDepth) != null ? r : 100,
    a = function (l, c) {
      c === void 0 && (c = 0)
      const u = []
      for (let d = 0; d < l.length; d++) {
        var f
        let h = l[d]
        const p = x0(t, h.id, h.original, h.index, h.depth, void 0, h.parentId)
        if (((p.columnFilters = h.columnFilters), (f = h.subRows) != null && f.length && c < o)) {
          if (((p.subRows = a(h.subRows, c + 1)), (h = p), n(h) && !p.subRows.length)) {
            ;(u.push(h), (s[h.id] = h), i.push(h))
            continue
          }
          if (n(h) || p.subRows.length) {
            ;(u.push(h), (s[h.id] = h), i.push(h))
            continue
          }
        } else ((h = p), n(h) && (u.push(h), (s[h.id] = h), i.push(h)))
      }
      return u
    }
  return { rows: a(e), flatRows: i, rowsById: s }
}
function MI(e, n, t) {
  var r
  const i = [],
    s = {},
    o = (r = t.options.maxLeafRowFilterDepth) != null ? r : 100,
    a = function (l, c) {
      c === void 0 && (c = 0)
      const u = []
      for (let d = 0; d < l.length; d++) {
        let h = l[d]
        if (n(h)) {
          var f
          if ((f = h.subRows) != null && f.length && c < o) {
            const g = x0(t, h.id, h.original, h.index, h.depth, void 0, h.parentId)
            ;((g.subRows = a(h.subRows, c + 1)), (h = g))
          }
          ;(u.push(h), i.push(h), (s[h.id] = h))
        }
      }
      return u
    }
  return { rows: a(e), flatRows: i, rowsById: s }
}
function RZ() {
  return (e) =>
    ne(
      () => [e.getPreFilteredRowModel(), e.getState().columnFilters, e.getState().globalFilter],
      (n, t, r) => {
        if (!n.rows.length || (!(t != null && t.length) && !r)) {
          for (let d = 0; d < n.flatRows.length; d++)
            ((n.flatRows[d].columnFilters = {}), (n.flatRows[d].columnFiltersMeta = {}))
          return n
        }
        const i = [],
          s = []
        ;(t ?? []).forEach((d) => {
          var h
          const p = e.getColumn(d.id)
          if (!p) return
          const g = p.getFilterFn()
          g &&
            i.push({
              id: d.id,
              filterFn: g,
              resolvedValue:
                (h = g.resolveFilterValue == null ? void 0 : g.resolveFilterValue(d.value)) != null
                  ? h
                  : d.value,
            })
        })
        const o = (t ?? []).map((d) => d.id),
          a = e.getGlobalFilterFn(),
          l = e.getAllLeafColumns().filter((d) => d.getCanGlobalFilter())
        r &&
          a &&
          l.length &&
          (o.push('__global__'),
          l.forEach((d) => {
            var h
            s.push({
              id: d.id,
              filterFn: a,
              resolvedValue:
                (h = a.resolveFilterValue == null ? void 0 : a.resolveFilterValue(r)) != null
                  ? h
                  : r,
            })
          }))
        let c, u
        for (let d = 0; d < n.flatRows.length; d++) {
          const h = n.flatRows[d]
          if (((h.columnFilters = {}), i.length))
            for (let p = 0; p < i.length; p++) {
              c = i[p]
              const g = c.id
              h.columnFilters[g] = c.filterFn(h, g, c.resolvedValue, (m) => {
                h.columnFiltersMeta[g] = m
              })
            }
          if (s.length) {
            for (let p = 0; p < s.length; p++) {
              u = s[p]
              const g = u.id
              if (
                u.filterFn(h, g, u.resolvedValue, (m) => {
                  h.columnFiltersMeta[g] = m
                })
              ) {
                h.columnFilters.__global__ = !0
                break
              }
            }
            h.columnFilters.__global__ !== !0 && (h.columnFilters.__global__ = !1)
          }
        }
        const f = (d) => {
          for (let h = 0; h < o.length; h++) if (d.columnFilters[o[h]] === !1) return !1
          return !0
        }
        return kI(n.rows, f, e)
      },
      re(e.options, 'debugTable', 'getFilteredRowModel', () => e._autoResetPageIndex()),
    )
}
function OZ(e) {
  return (n) =>
    ne(
      () => [
        n.getState().pagination,
        n.getPrePaginationRowModel(),
        n.options.paginateExpandedRows ? void 0 : n.getState().expanded,
      ],
      (t, r) => {
        if (!r.rows.length) return r
        const { pageSize: i, pageIndex: s } = t
        let { rows: o, flatRows: a, rowsById: l } = r
        const c = i * s,
          u = c + i
        o = o.slice(c, u)
        let f
        ;(n.options.paginateExpandedRows
          ? (f = { rows: o, flatRows: a, rowsById: l })
          : (f = _I({ rows: o, flatRows: a, rowsById: l })),
          (f.flatRows = []))
        const d = (h) => {
          ;(f.flatRows.push(h), h.subRows.length && h.subRows.forEach(d))
        }
        return (f.rows.forEach(d), f)
      },
      re(n.options, 'debugTable'),
    )
}
function PZ() {
  return (e) =>
    ne(
      () => [e.getState().sorting, e.getPreSortedRowModel()],
      (n, t) => {
        if (!t.rows.length || !(n != null && n.length)) return t
        const r = e.getState().sorting,
          i = [],
          s = r.filter((l) => {
            var c
            return (c = e.getColumn(l.id)) == null ? void 0 : c.getCanSort()
          }),
          o = {}
        s.forEach((l) => {
          const c = e.getColumn(l.id)
          c &&
            (o[l.id] = {
              sortUndefined: c.columnDef.sortUndefined,
              invertSorting: c.columnDef.invertSorting,
              sortingFn: c.getSortingFn(),
            })
        })
        const a = (l) => {
          const c = l.map((u) => ({ ...u }))
          return (
            c.sort((u, f) => {
              for (let h = 0; h < s.length; h += 1) {
                var d
                const p = s[h],
                  g = o[p.id],
                  m = g.sortUndefined,
                  y = (d = p?.desc) != null ? d : !1
                let b = 0
                if (m) {
                  const w = u.getValue(p.id),
                    C = f.getValue(p.id),
                    T = w === void 0,
                    I = C === void 0
                  if (T || I) {
                    if (m === 'first') return T ? -1 : 1
                    if (m === 'last') return T ? 1 : -1
                    b = T && I ? 0 : T ? m : -m
                  }
                }
                if ((b === 0 && (b = g.sortingFn(u, f, p.id)), b !== 0))
                  return (y && (b *= -1), g.invertSorting && (b *= -1), b)
              }
              return u.index - f.index
            }),
            c.forEach((u) => {
              var f
              ;(i.push(u), (f = u.subRows) != null && f.length && (u.subRows = a(u.subRows)))
            }),
            c
          )
        }
        return { rows: a(t.rows), flatRows: i, rowsById: t.rowsById }
      },
      re(e.options, 'debugTable', 'getSortedRowModel', () => e._autoResetPageIndex()),
    )
}
/**
 * react-table
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function NZ(e, n) {
  return e ? (EI(e) ? Y.createElement(e, n) : e) : null
}
function EI(e) {
  return TI(e) || typeof e == 'function' || AI(e)
}
function TI(e) {
  return (
    typeof e == 'function' &&
    (() => {
      const n = Object.getPrototypeOf(e)
      return n.prototype && n.prototype.isReactComponent
    })()
  )
}
function AI(e) {
  return (
    typeof e == 'object' &&
    typeof e.$$typeof == 'symbol' &&
    ['react.memo', 'react.forward_ref'].includes(e.$$typeof.description)
  )
}
function IZ(e) {
  const n = { state: {}, onStateChange: () => {}, renderFallbackValue: null, ...e },
    [t] = Y.useState(() => ({ current: SI(n) })),
    [r, i] = Y.useState(() => t.current.initialState)
  return (
    t.current.setOptions((s) => ({
      ...s,
      ...e,
      state: { ...r, ...e.state },
      onStateChange: (o) => {
        ;(i(o), e.onStateChange == null || e.onStateChange(o))
      },
    })),
    t.current
  )
}
function RI() {
  for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++) n[t] = arguments[t]
  return Y.useMemo(
    () => (r) => {
      n.forEach((i) => i(r))
    },
    n,
  )
}
const Rf =
  typeof window < 'u' && typeof window.document < 'u' && typeof window.document.createElement < 'u'
function Jo(e) {
  const n = Object.prototype.toString.call(e)
  return n === '[object Window]' || n === '[object global]'
}
function C0(e) {
  return 'nodeType' in e
}
function Dn(e) {
  var n, t
  return e
    ? Jo(e)
      ? e
      : C0(e) && (n = (t = e.ownerDocument) == null ? void 0 : t.defaultView) != null
        ? n
        : window
    : window
}
function M0(e) {
  const { Document: n } = Dn(e)
  return e instanceof n
}
function Al(e) {
  return Jo(e) ? !1 : e instanceof Dn(e).HTMLElement
}
function M3(e) {
  return e instanceof Dn(e).SVGElement
}
function Qo(e) {
  return e
    ? Jo(e)
      ? e.document
      : C0(e)
        ? M0(e)
          ? e
          : Al(e) || M3(e)
            ? e.ownerDocument
            : document
        : document
    : document
}
const Sr = Rf ? Y.useLayoutEffect : Y.useEffect
function Of(e) {
  const n = Y.useRef(e)
  return (
    Sr(() => {
      n.current = e
    }),
    Y.useCallback(function () {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i]
      return n.current == null ? void 0 : n.current(...r)
    }, [])
  )
}
function OI() {
  const e = Y.useRef(null),
    n = Y.useCallback((r, i) => {
      e.current = setInterval(r, i)
    }, []),
    t = Y.useCallback(() => {
      e.current !== null && (clearInterval(e.current), (e.current = null))
    }, [])
  return [n, t]
}
function il(e, n) {
  n === void 0 && (n = [e])
  const t = Y.useRef(e)
  return (
    Sr(() => {
      t.current !== e && (t.current = e)
    }, n),
    t
  )
}
function Rl(e, n) {
  const t = Y.useRef()
  return Y.useMemo(() => {
    const r = e(t.current)
    return ((t.current = r), r)
  }, [...n])
}
function uu(e) {
  const n = Of(e),
    t = Y.useRef(null),
    r = Y.useCallback((i) => {
      ;(i !== t.current && n?.(i, t.current), (t.current = i))
    }, [])
  return [t, r]
}
function fu(e) {
  const n = Y.useRef()
  return (
    Y.useEffect(() => {
      n.current = e
    }, [e]),
    n.current
  )
}
let Vd = {}
function Ol(e, n) {
  return Y.useMemo(() => {
    if (n) return n
    const t = Vd[e] == null ? 0 : Vd[e] + 1
    return ((Vd[e] = t), e + '-' + t)
  }, [e, n])
}
function E3(e) {
  return function (n) {
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i]
    return r.reduce(
      (s, o) => {
        const a = Object.entries(o)
        for (const [l, c] of a) {
          const u = s[l]
          u != null && (s[l] = u + e * c)
        }
        return s
      },
      { ...n },
    )
  }
}
const So = E3(1),
  sl = E3(-1)
function PI(e) {
  return 'clientX' in e && 'clientY' in e
}
function Pf(e) {
  if (!e) return !1
  const { KeyboardEvent: n } = Dn(e.target)
  return n && e instanceof n
}
function NI(e) {
  if (!e) return !1
  const { TouchEvent: n } = Dn(e.target)
  return n && e instanceof n
}
function du(e) {
  if (NI(e)) {
    if (e.touches && e.touches.length) {
      const { clientX: n, clientY: t } = e.touches[0]
      return { x: n, y: t }
    } else if (e.changedTouches && e.changedTouches.length) {
      const { clientX: n, clientY: t } = e.changedTouches[0]
      return { x: n, y: t }
    }
  }
  return PI(e) ? { x: e.clientX, y: e.clientY } : null
}
const Ps = Object.freeze({
    Translate: {
      toString(e) {
        if (!e) return
        const { x: n, y: t } = e
        return (
          'translate3d(' + (n ? Math.round(n) : 0) + 'px, ' + (t ? Math.round(t) : 0) + 'px, 0)'
        )
      },
    },
    Scale: {
      toString(e) {
        if (!e) return
        const { scaleX: n, scaleY: t } = e
        return 'scaleX(' + n + ') scaleY(' + t + ')'
      },
    },
    Transform: {
      toString(e) {
        if (e) return [Ps.Translate.toString(e), Ps.Scale.toString(e)].join(' ')
      },
    },
    Transition: {
      toString(e) {
        let { property: n, duration: t, easing: r } = e
        return n + ' ' + t + 'ms ' + r
      },
    },
  }),
  ib =
    'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]'
function II(e) {
  return e.matches(ib) ? e : e.querySelector(ib)
}
const DI = { display: 'none' }
function jI(e) {
  let { id: n, value: t } = e
  return ut.createElement('div', { id: n, style: DI }, t)
}
function LI(e) {
  let { id: n, announcement: t, ariaLiveType: r = 'assertive' } = e
  const i = {
    position: 'fixed',
    top: 0,
    left: 0,
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: 'hidden',
    clip: 'rect(0 0 0 0)',
    clipPath: 'inset(100%)',
    whiteSpace: 'nowrap',
  }
  return ut.createElement(
    'div',
    { id: n, style: i, role: 'status', 'aria-live': r, 'aria-atomic': !0 },
    t,
  )
}
function FI() {
  const [e, n] = Y.useState('')
  return {
    announce: Y.useCallback((r) => {
      r != null && n(r)
    }, []),
    announcement: e,
  }
}
const T3 = Y.createContext(null)
function BI(e) {
  const n = Y.useContext(T3)
  Y.useEffect(() => {
    if (!n) throw new Error('useDndMonitor must be used within a children of <DndContext>')
    return n(e)
  }, [e, n])
}
function zI() {
  const [e] = Y.useState(() => new Set()),
    n = Y.useCallback((r) => (e.add(r), () => e.delete(r)), [e])
  return [
    Y.useCallback(
      (r) => {
        let { type: i, event: s } = r
        e.forEach((o) => {
          var a
          return (a = o[i]) == null ? void 0 : a.call(o, s)
        })
      },
      [e],
    ),
    n,
  ]
}
const $I = {
    draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `,
  },
  VI = {
    onDragStart(e) {
      let { active: n } = e
      return 'Picked up draggable item ' + n.id + '.'
    },
    onDragOver(e) {
      let { active: n, over: t } = e
      return t
        ? 'Draggable item ' + n.id + ' was moved over droppable area ' + t.id + '.'
        : 'Draggable item ' + n.id + ' is no longer over a droppable area.'
    },
    onDragEnd(e) {
      let { active: n, over: t } = e
      return t
        ? 'Draggable item ' + n.id + ' was dropped over droppable area ' + t.id
        : 'Draggable item ' + n.id + ' was dropped.'
    },
    onDragCancel(e) {
      let { active: n } = e
      return 'Dragging was cancelled. Draggable item ' + n.id + ' was dropped.'
    },
  }
function HI(e) {
  let {
    announcements: n = VI,
    container: t,
    hiddenTextDescribedById: r,
    screenReaderInstructions: i = $I,
  } = e
  const { announce: s, announcement: o } = FI(),
    a = Ol('DndLiveRegion'),
    [l, c] = Y.useState(!1)
  if (
    (Y.useEffect(() => {
      c(!0)
    }, []),
    BI(
      Y.useMemo(
        () => ({
          onDragStart(f) {
            let { active: d } = f
            s(n.onDragStart({ active: d }))
          },
          onDragMove(f) {
            let { active: d, over: h } = f
            n.onDragMove && s(n.onDragMove({ active: d, over: h }))
          },
          onDragOver(f) {
            let { active: d, over: h } = f
            s(n.onDragOver({ active: d, over: h }))
          },
          onDragEnd(f) {
            let { active: d, over: h } = f
            s(n.onDragEnd({ active: d, over: h }))
          },
          onDragCancel(f) {
            let { active: d, over: h } = f
            s(n.onDragCancel({ active: d, over: h }))
          },
        }),
        [s, n],
      ),
    ),
    !l)
  )
    return null
  const u = ut.createElement(
    ut.Fragment,
    null,
    ut.createElement(jI, { id: r, value: i.draggable }),
    ut.createElement(LI, { id: a, announcement: o }),
  )
  return t ? Ei.createPortal(u, t) : u
}
var rn
;(function (e) {
  ;((e.DragStart = 'dragStart'),
    (e.DragMove = 'dragMove'),
    (e.DragEnd = 'dragEnd'),
    (e.DragCancel = 'dragCancel'),
    (e.DragOver = 'dragOver'),
    (e.RegisterDroppable = 'registerDroppable'),
    (e.SetDroppableDisabled = 'setDroppableDisabled'),
    (e.UnregisterDroppable = 'unregisterDroppable'))
})(rn || (rn = {}))
function hu() {}
function DZ(e, n) {
  return Y.useMemo(() => ({ sensor: e, options: n ?? {} }), [e, n])
}
function jZ() {
  for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++) n[t] = arguments[t]
  return Y.useMemo(() => [...n].filter((r) => r != null), [...n])
}
const _r = Object.freeze({ x: 0, y: 0 })
function A3(e, n) {
  return Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2))
}
function UI(e, n) {
  const t = du(e)
  if (!t) return '0 0'
  const r = { x: ((t.x - n.left) / n.width) * 100, y: ((t.y - n.top) / n.height) * 100 }
  return r.x + '% ' + r.y + '%'
}
function R3(e, n) {
  let {
      data: { value: t },
    } = e,
    {
      data: { value: r },
    } = n
  return t - r
}
function qI(e, n) {
  let {
      data: { value: t },
    } = e,
    {
      data: { value: r },
    } = n
  return r - t
}
function sb(e) {
  let { left: n, top: t, height: r, width: i } = e
  return [
    { x: n, y: t },
    { x: n + i, y: t },
    { x: n, y: t + r },
    { x: n + i, y: t + r },
  ]
}
function O3(e, n) {
  if (!e || e.length === 0) return null
  const [t] = e
  return t[n]
}
function ob(e, n, t) {
  return (
    n === void 0 && (n = e.left),
    t === void 0 && (t = e.top),
    { x: n + e.width * 0.5, y: t + e.height * 0.5 }
  )
}
const LZ = (e) => {
    let { collisionRect: n, droppableRects: t, droppableContainers: r } = e
    const i = ob(n, n.left, n.top),
      s = []
    for (const o of r) {
      const { id: a } = o,
        l = t.get(a)
      if (l) {
        const c = A3(ob(l), i)
        s.push({ id: a, data: { droppableContainer: o, value: c } })
      }
    }
    return s.sort(R3)
  },
  WI = (e) => {
    let { collisionRect: n, droppableRects: t, droppableContainers: r } = e
    const i = sb(n),
      s = []
    for (const o of r) {
      const { id: a } = o,
        l = t.get(a)
      if (l) {
        const c = sb(l),
          u = i.reduce((d, h, p) => d + A3(c[p], h), 0),
          f = Number((u / 4).toFixed(4))
        s.push({ id: a, data: { droppableContainer: o, value: f } })
      }
    }
    return s.sort(R3)
  }
function KI(e, n) {
  const t = Math.max(n.top, e.top),
    r = Math.max(n.left, e.left),
    i = Math.min(n.left + n.width, e.left + e.width),
    s = Math.min(n.top + n.height, e.top + e.height),
    o = i - r,
    a = s - t
  if (r < i && t < s) {
    const l = n.width * n.height,
      c = e.width * e.height,
      u = o * a,
      f = u / (l + c - u)
    return Number(f.toFixed(4))
  }
  return 0
}
const GI = (e) => {
  let { collisionRect: n, droppableRects: t, droppableContainers: r } = e
  const i = []
  for (const s of r) {
    const { id: o } = s,
      a = t.get(o)
    if (a) {
      const l = KI(a, n)
      l > 0 && i.push({ id: o, data: { droppableContainer: s, value: l } })
    }
  }
  return i.sort(qI)
}
function XI(e, n, t) {
  return { ...e, scaleX: n && t ? n.width / t.width : 1, scaleY: n && t ? n.height / t.height : 1 }
}
function P3(e, n) {
  return e && n ? { x: e.left - n.left, y: e.top - n.top } : _r
}
function YI(e) {
  return function (t) {
    for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
      i[s - 1] = arguments[s]
    return i.reduce(
      (o, a) => ({
        ...o,
        top: o.top + e * a.y,
        bottom: o.bottom + e * a.y,
        left: o.left + e * a.x,
        right: o.right + e * a.x,
      }),
      { ...t },
    )
  }
}
const ZI = YI(1)
function N3(e) {
  if (e.startsWith('matrix3d(')) {
    const n = e.slice(9, -1).split(/, /)
    return { x: +n[12], y: +n[13], scaleX: +n[0], scaleY: +n[5] }
  } else if (e.startsWith('matrix(')) {
    const n = e.slice(7, -1).split(/, /)
    return { x: +n[4], y: +n[5], scaleX: +n[0], scaleY: +n[3] }
  }
  return null
}
function JI(e, n, t) {
  const r = N3(n)
  if (!r) return e
  const { scaleX: i, scaleY: s, x: o, y: a } = r,
    l = e.left - o - (1 - i) * parseFloat(t),
    c = e.top - a - (1 - s) * parseFloat(t.slice(t.indexOf(' ') + 1)),
    u = i ? e.width / i : e.width,
    f = s ? e.height / s : e.height
  return { width: u, height: f, top: c, right: l + u, bottom: c + f, left: l }
}
const QI = { ignoreTransform: !1 }
function ta(e, n) {
  n === void 0 && (n = QI)
  let t = e.getBoundingClientRect()
  if (n.ignoreTransform) {
    const { transform: c, transformOrigin: u } = Dn(e).getComputedStyle(e)
    c && (t = JI(t, c, u))
  }
  const { top: r, left: i, width: s, height: o, bottom: a, right: l } = t
  return { top: r, left: i, width: s, height: o, bottom: a, right: l }
}
function ab(e) {
  return ta(e, { ignoreTransform: !0 })
}
function tD(e) {
  const n = e.innerWidth,
    t = e.innerHeight
  return { top: 0, left: 0, right: n, bottom: t, width: n, height: t }
}
function eD(e, n) {
  return (n === void 0 && (n = Dn(e).getComputedStyle(e)), n.position === 'fixed')
}
function nD(e, n) {
  n === void 0 && (n = Dn(e).getComputedStyle(e))
  const t = /(auto|scroll|overlay)/
  return ['overflow', 'overflowX', 'overflowY'].some((i) => {
    const s = n[i]
    return typeof s == 'string' ? t.test(s) : !1
  })
}
function Nf(e, n) {
  const t = []
  function r(i) {
    if ((n != null && t.length >= n) || !i) return t
    if (M0(i) && i.scrollingElement != null && !t.includes(i.scrollingElement))
      return (t.push(i.scrollingElement), t)
    if (!Al(i) || M3(i) || t.includes(i)) return t
    const s = Dn(e).getComputedStyle(i)
    return (i !== e && nD(i, s) && t.push(i), eD(i, s) ? t : r(i.parentNode))
  }
  return e ? r(e) : t
}
function I3(e) {
  const [n] = Nf(e, 1)
  return n ?? null
}
function Hd(e) {
  return !Rf || !e
    ? null
    : Jo(e)
      ? e
      : C0(e)
        ? M0(e) || e === Qo(e).scrollingElement
          ? window
          : Al(e)
            ? e
            : null
        : null
}
function D3(e) {
  return Jo(e) ? e.scrollX : e.scrollLeft
}
function j3(e) {
  return Jo(e) ? e.scrollY : e.scrollTop
}
function Mp(e) {
  return { x: D3(e), y: j3(e) }
}
var ln
;(function (e) {
  ;((e[(e.Forward = 1)] = 'Forward'), (e[(e.Backward = -1)] = 'Backward'))
})(ln || (ln = {}))
function L3(e) {
  return !Rf || !e ? !1 : e === document.scrollingElement
}
function F3(e) {
  const n = { x: 0, y: 0 },
    t = L3(e)
      ? { height: window.innerHeight, width: window.innerWidth }
      : { height: e.clientHeight, width: e.clientWidth },
    r = { x: e.scrollWidth - t.width, y: e.scrollHeight - t.height },
    i = e.scrollTop <= n.y,
    s = e.scrollLeft <= n.x,
    o = e.scrollTop >= r.y,
    a = e.scrollLeft >= r.x
  return { isTop: i, isLeft: s, isBottom: o, isRight: a, maxScroll: r, minScroll: n }
}
const rD = { x: 0.2, y: 0.2 }
function iD(e, n, t, r, i) {
  let { top: s, left: o, right: a, bottom: l } = t
  ;(r === void 0 && (r = 10), i === void 0 && (i = rD))
  const { isTop: c, isBottom: u, isLeft: f, isRight: d } = F3(e),
    h = { x: 0, y: 0 },
    p = { x: 0, y: 0 },
    g = { height: n.height * i.y, width: n.width * i.x }
  return (
    !c && s <= n.top + g.height
      ? ((h.y = ln.Backward), (p.y = r * Math.abs((n.top + g.height - s) / g.height)))
      : !u &&
        l >= n.bottom - g.height &&
        ((h.y = ln.Forward), (p.y = r * Math.abs((n.bottom - g.height - l) / g.height))),
    !d && a >= n.right - g.width
      ? ((h.x = ln.Forward), (p.x = r * Math.abs((n.right - g.width - a) / g.width)))
      : !f &&
        o <= n.left + g.width &&
        ((h.x = ln.Backward), (p.x = r * Math.abs((n.left + g.width - o) / g.width))),
    { direction: h, speed: p }
  )
}
function sD(e) {
  if (e === document.scrollingElement) {
    const { innerWidth: s, innerHeight: o } = window
    return { top: 0, left: 0, right: s, bottom: o, width: s, height: o }
  }
  const { top: n, left: t, right: r, bottom: i } = e.getBoundingClientRect()
  return { top: n, left: t, right: r, bottom: i, width: e.clientWidth, height: e.clientHeight }
}
function B3(e) {
  return e.reduce((n, t) => So(n, Mp(t)), _r)
}
function oD(e) {
  return e.reduce((n, t) => n + D3(t), 0)
}
function aD(e) {
  return e.reduce((n, t) => n + j3(t), 0)
}
function z3(e, n) {
  if ((n === void 0 && (n = ta), !e)) return
  const { top: t, left: r, bottom: i, right: s } = n(e)
  I3(e) &&
    (i <= 0 || s <= 0 || t >= window.innerHeight || r >= window.innerWidth) &&
    e.scrollIntoView({ block: 'center', inline: 'center' })
}
const lD = [
  ['x', ['left', 'right'], oD],
  ['y', ['top', 'bottom'], aD],
]
class E0 {
  constructor(n, t) {
    ;((this.rect = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.right = void 0),
      (this.left = void 0))
    const r = Nf(t),
      i = B3(r)
    ;((this.rect = { ...n }), (this.width = n.width), (this.height = n.height))
    for (const [s, o, a] of lD)
      for (const l of o)
        Object.defineProperty(this, l, {
          get: () => {
            const c = a(r),
              u = i[s] - c
            return this.rect[l] + u
          },
          enumerable: !0,
        })
    Object.defineProperty(this, 'rect', { enumerable: !1 })
  }
}
class Da {
  constructor(n) {
    ;((this.target = void 0),
      (this.listeners = []),
      (this.removeAll = () => {
        this.listeners.forEach((t) => {
          var r
          return (r = this.target) == null ? void 0 : r.removeEventListener(...t)
        })
      }),
      (this.target = n))
  }
  add(n, t, r) {
    var i
    ;((i = this.target) == null || i.addEventListener(n, t, r), this.listeners.push([n, t, r]))
  }
}
function cD(e) {
  const { EventTarget: n } = Dn(e)
  return e instanceof n ? e : Qo(e)
}
function Ud(e, n) {
  const t = Math.abs(e.x),
    r = Math.abs(e.y)
  return typeof n == 'number'
    ? Math.sqrt(t ** 2 + r ** 2) > n
    : 'x' in n && 'y' in n
      ? t > n.x && r > n.y
      : 'x' in n
        ? t > n.x
        : 'y' in n
          ? r > n.y
          : !1
}
var nr
;(function (e) {
  ;((e.Click = 'click'),
    (e.DragStart = 'dragstart'),
    (e.Keydown = 'keydown'),
    (e.ContextMenu = 'contextmenu'),
    (e.Resize = 'resize'),
    (e.SelectionChange = 'selectionchange'),
    (e.VisibilityChange = 'visibilitychange'))
})(nr || (nr = {}))
function lb(e) {
  e.preventDefault()
}
function uD(e) {
  e.stopPropagation()
}
var _e
;(function (e) {
  ;((e.Space = 'Space'),
    (e.Down = 'ArrowDown'),
    (e.Right = 'ArrowRight'),
    (e.Left = 'ArrowLeft'),
    (e.Up = 'ArrowUp'),
    (e.Esc = 'Escape'),
    (e.Enter = 'Enter'),
    (e.Tab = 'Tab'))
})(_e || (_e = {}))
const $3 = { start: [_e.Space, _e.Enter], cancel: [_e.Esc], end: [_e.Space, _e.Enter, _e.Tab] },
  fD = (e, n) => {
    let { currentCoordinates: t } = n
    switch (e.code) {
      case _e.Right:
        return { ...t, x: t.x + 25 }
      case _e.Left:
        return { ...t, x: t.x - 25 }
      case _e.Down:
        return { ...t, y: t.y + 25 }
      case _e.Up:
        return { ...t, y: t.y - 25 }
    }
  }
class V3 {
  constructor(n) {
    ;((this.props = void 0),
      (this.autoScrollEnabled = !1),
      (this.referenceCoordinates = void 0),
      (this.listeners = void 0),
      (this.windowListeners = void 0),
      (this.props = n))
    const {
      event: { target: t },
    } = n
    ;((this.props = n),
      (this.listeners = new Da(Qo(t))),
      (this.windowListeners = new Da(Dn(t))),
      (this.handleKeyDown = this.handleKeyDown.bind(this)),
      (this.handleCancel = this.handleCancel.bind(this)),
      this.attach())
  }
  attach() {
    ;(this.handleStart(),
      this.windowListeners.add(nr.Resize, this.handleCancel),
      this.windowListeners.add(nr.VisibilityChange, this.handleCancel),
      setTimeout(() => this.listeners.add(nr.Keydown, this.handleKeyDown)))
  }
  handleStart() {
    const { activeNode: n, onStart: t } = this.props,
      r = n.node.current
    ;(r && z3(r), t(_r))
  }
  handleKeyDown(n) {
    if (Pf(n)) {
      const { active: t, context: r, options: i } = this.props,
        { keyboardCodes: s = $3, coordinateGetter: o = fD, scrollBehavior: a = 'smooth' } = i,
        { code: l } = n
      if (s.end.includes(l)) {
        this.handleEnd(n)
        return
      }
      if (s.cancel.includes(l)) {
        this.handleCancel(n)
        return
      }
      const { collisionRect: c } = r.current,
        u = c ? { x: c.left, y: c.top } : _r
      this.referenceCoordinates || (this.referenceCoordinates = u)
      const f = o(n, { active: t, context: r.current, currentCoordinates: u })
      if (f) {
        const d = sl(f, u),
          h = { x: 0, y: 0 },
          { scrollableAncestors: p } = r.current
        for (const g of p) {
          const m = n.code,
            { isTop: y, isRight: b, isLeft: w, isBottom: C, maxScroll: T, minScroll: I } = F3(g),
            B = sD(g),
            E = {
              x: Math.min(
                m === _e.Right ? B.right - B.width / 2 : B.right,
                Math.max(m === _e.Right ? B.left : B.left + B.width / 2, f.x),
              ),
              y: Math.min(
                m === _e.Down ? B.bottom - B.height / 2 : B.bottom,
                Math.max(m === _e.Down ? B.top : B.top + B.height / 2, f.y),
              ),
            },
            O = (m === _e.Right && !b) || (m === _e.Left && !w),
            P = (m === _e.Down && !C) || (m === _e.Up && !y)
          if (O && E.x !== f.x) {
            const $ = g.scrollLeft + d.x,
              F = (m === _e.Right && $ <= T.x) || (m === _e.Left && $ >= I.x)
            if (F && !d.y) {
              g.scrollTo({ left: $, behavior: a })
              return
            }
            ;(F
              ? (h.x = g.scrollLeft - $)
              : (h.x = m === _e.Right ? g.scrollLeft - T.x : g.scrollLeft - I.x),
              h.x && g.scrollBy({ left: -h.x, behavior: a }))
            break
          } else if (P && E.y !== f.y) {
            const $ = g.scrollTop + d.y,
              F = (m === _e.Down && $ <= T.y) || (m === _e.Up && $ >= I.y)
            if (F && !d.x) {
              g.scrollTo({ top: $, behavior: a })
              return
            }
            ;(F
              ? (h.y = g.scrollTop - $)
              : (h.y = m === _e.Down ? g.scrollTop - T.y : g.scrollTop - I.y),
              h.y && g.scrollBy({ top: -h.y, behavior: a }))
            break
          }
        }
        this.handleMove(n, So(sl(f, this.referenceCoordinates), h))
      }
    }
  }
  handleMove(n, t) {
    const { onMove: r } = this.props
    ;(n.preventDefault(), r(t))
  }
  handleEnd(n) {
    const { onEnd: t } = this.props
    ;(n.preventDefault(), this.detach(), t())
  }
  handleCancel(n) {
    const { onCancel: t } = this.props
    ;(n.preventDefault(), this.detach(), t())
  }
  detach() {
    ;(this.listeners.removeAll(), this.windowListeners.removeAll())
  }
}
V3.activators = [
  {
    eventName: 'onKeyDown',
    handler: (e, n, t) => {
      let { keyboardCodes: r = $3, onActivation: i } = n,
        { active: s } = t
      const { code: o } = e.nativeEvent
      if (r.start.includes(o)) {
        const a = s.activatorNode.current
        return a && e.target !== a ? !1 : (e.preventDefault(), i?.({ event: e.nativeEvent }), !0)
      }
      return !1
    },
  },
]
function cb(e) {
  return !!(e && 'distance' in e)
}
function ub(e) {
  return !!(e && 'delay' in e)
}
class T0 {
  constructor(n, t, r) {
    var i
    ;(r === void 0 && (r = cD(n.event.target)),
      (this.props = void 0),
      (this.events = void 0),
      (this.autoScrollEnabled = !0),
      (this.document = void 0),
      (this.activated = !1),
      (this.initialCoordinates = void 0),
      (this.timeoutId = null),
      (this.listeners = void 0),
      (this.documentListeners = void 0),
      (this.windowListeners = void 0),
      (this.props = n),
      (this.events = t))
    const { event: s } = n,
      { target: o } = s
    ;((this.props = n),
      (this.events = t),
      (this.document = Qo(o)),
      (this.documentListeners = new Da(this.document)),
      (this.listeners = new Da(r)),
      (this.windowListeners = new Da(Dn(o))),
      (this.initialCoordinates = (i = du(s)) != null ? i : _r),
      (this.handleStart = this.handleStart.bind(this)),
      (this.handleMove = this.handleMove.bind(this)),
      (this.handleEnd = this.handleEnd.bind(this)),
      (this.handleCancel = this.handleCancel.bind(this)),
      (this.handleKeydown = this.handleKeydown.bind(this)),
      (this.removeTextSelection = this.removeTextSelection.bind(this)),
      this.attach())
  }
  attach() {
    const {
      events: n,
      props: {
        options: { activationConstraint: t, bypassActivationConstraint: r },
      },
    } = this
    if (
      (this.listeners.add(n.move.name, this.handleMove, { passive: !1 }),
      this.listeners.add(n.end.name, this.handleEnd),
      n.cancel && this.listeners.add(n.cancel.name, this.handleCancel),
      this.windowListeners.add(nr.Resize, this.handleCancel),
      this.windowListeners.add(nr.DragStart, lb),
      this.windowListeners.add(nr.VisibilityChange, this.handleCancel),
      this.windowListeners.add(nr.ContextMenu, lb),
      this.documentListeners.add(nr.Keydown, this.handleKeydown),
      t)
    ) {
      if (
        r != null &&
        r({
          event: this.props.event,
          activeNode: this.props.activeNode,
          options: this.props.options,
        })
      )
        return this.handleStart()
      if (ub(t)) {
        ;((this.timeoutId = setTimeout(this.handleStart, t.delay)), this.handlePending(t))
        return
      }
      if (cb(t)) {
        this.handlePending(t)
        return
      }
    }
    this.handleStart()
  }
  detach() {
    ;(this.listeners.removeAll(),
      this.windowListeners.removeAll(),
      setTimeout(this.documentListeners.removeAll, 50),
      this.timeoutId !== null && (clearTimeout(this.timeoutId), (this.timeoutId = null)))
  }
  handlePending(n, t) {
    const { active: r, onPending: i } = this.props
    i(r, n, this.initialCoordinates, t)
  }
  handleStart() {
    const { initialCoordinates: n } = this,
      { onStart: t } = this.props
    n &&
      ((this.activated = !0),
      this.documentListeners.add(nr.Click, uD, { capture: !0 }),
      this.removeTextSelection(),
      this.documentListeners.add(nr.SelectionChange, this.removeTextSelection),
      t(n))
  }
  handleMove(n) {
    var t
    const { activated: r, initialCoordinates: i, props: s } = this,
      {
        onMove: o,
        options: { activationConstraint: a },
      } = s
    if (!i) return
    const l = (t = du(n)) != null ? t : _r,
      c = sl(i, l)
    if (!r && a) {
      if (cb(a)) {
        if (a.tolerance != null && Ud(c, a.tolerance)) return this.handleCancel()
        if (Ud(c, a.distance)) return this.handleStart()
      }
      if (ub(a) && Ud(c, a.tolerance)) return this.handleCancel()
      this.handlePending(a, c)
      return
    }
    ;(n.cancelable && n.preventDefault(), o(l))
  }
  handleEnd() {
    const { onAbort: n, onEnd: t } = this.props
    ;(this.detach(), this.activated || n(this.props.active), t())
  }
  handleCancel() {
    const { onAbort: n, onCancel: t } = this.props
    ;(this.detach(), this.activated || n(this.props.active), t())
  }
  handleKeydown(n) {
    n.code === _e.Esc && this.handleCancel()
  }
  removeTextSelection() {
    var n
    ;(n = this.document.getSelection()) == null || n.removeAllRanges()
  }
}
const dD = {
  cancel: { name: 'pointercancel' },
  move: { name: 'pointermove' },
  end: { name: 'pointerup' },
}
class H3 extends T0 {
  constructor(n) {
    const { event: t } = n,
      r = Qo(t.target)
    super(n, dD, r)
  }
}
H3.activators = [
  {
    eventName: 'onPointerDown',
    handler: (e, n) => {
      let { nativeEvent: t } = e,
        { onActivation: r } = n
      return !t.isPrimary || t.button !== 0 ? !1 : (r?.({ event: t }), !0)
    },
  },
]
const hD = { move: { name: 'mousemove' }, end: { name: 'mouseup' } }
var Ep
;(function (e) {
  e[(e.RightClick = 2)] = 'RightClick'
})(Ep || (Ep = {}))
class pD extends T0 {
  constructor(n) {
    super(n, hD, Qo(n.event.target))
  }
}
pD.activators = [
  {
    eventName: 'onMouseDown',
    handler: (e, n) => {
      let { nativeEvent: t } = e,
        { onActivation: r } = n
      return t.button === Ep.RightClick ? !1 : (r?.({ event: t }), !0)
    },
  },
]
const qd = {
  cancel: { name: 'touchcancel' },
  move: { name: 'touchmove' },
  end: { name: 'touchend' },
}
class mD extends T0 {
  constructor(n) {
    super(n, qd)
  }
  static setup() {
    return (
      window.addEventListener(qd.move.name, n, { capture: !1, passive: !1 }),
      function () {
        window.removeEventListener(qd.move.name, n)
      }
    )
    function n() {}
  }
}
mD.activators = [
  {
    eventName: 'onTouchStart',
    handler: (e, n) => {
      let { nativeEvent: t } = e,
        { onActivation: r } = n
      const { touches: i } = t
      return i.length > 1 ? !1 : (r?.({ event: t }), !0)
    },
  },
]
var ja
;(function (e) {
  ;((e[(e.Pointer = 0)] = 'Pointer'), (e[(e.DraggableRect = 1)] = 'DraggableRect'))
})(ja || (ja = {}))
var pu
;(function (e) {
  ;((e[(e.TreeOrder = 0)] = 'TreeOrder'), (e[(e.ReversedTreeOrder = 1)] = 'ReversedTreeOrder'))
})(pu || (pu = {}))
function gD(e) {
  let {
    acceleration: n,
    activator: t = ja.Pointer,
    canScroll: r,
    draggingRect: i,
    enabled: s,
    interval: o = 5,
    order: a = pu.TreeOrder,
    pointerCoordinates: l,
    scrollableAncestors: c,
    scrollableAncestorRects: u,
    delta: f,
    threshold: d,
  } = e
  const h = bD({ delta: f, disabled: !s }),
    [p, g] = OI(),
    m = Y.useRef({ x: 0, y: 0 }),
    y = Y.useRef({ x: 0, y: 0 }),
    b = Y.useMemo(() => {
      switch (t) {
        case ja.Pointer:
          return l ? { top: l.y, bottom: l.y, left: l.x, right: l.x } : null
        case ja.DraggableRect:
          return i
      }
    }, [t, i, l]),
    w = Y.useRef(null),
    C = Y.useCallback(() => {
      const I = w.current
      if (!I) return
      const B = m.current.x * y.current.x,
        E = m.current.y * y.current.y
      I.scrollBy(B, E)
    }, []),
    T = Y.useMemo(() => (a === pu.TreeOrder ? [...c].reverse() : c), [a, c])
  Y.useEffect(() => {
    if (!s || !c.length || !b) {
      g()
      return
    }
    for (const I of T) {
      if (r?.(I) === !1) continue
      const B = c.indexOf(I),
        E = u[B]
      if (!E) continue
      const { direction: O, speed: P } = iD(I, E, b, n, d)
      for (const $ of ['x', 'y']) h[$][O[$]] || ((P[$] = 0), (O[$] = 0))
      if (P.x > 0 || P.y > 0) {
        ;(g(), (w.current = I), p(C, o), (m.current = P), (y.current = O))
        return
      }
    }
    ;((m.current = { x: 0, y: 0 }), (y.current = { x: 0, y: 0 }), g())
  }, [n, C, r, g, s, o, JSON.stringify(b), JSON.stringify(h), p, c, T, u, JSON.stringify(d)])
}
const yD = {
  x: { [ln.Backward]: !1, [ln.Forward]: !1 },
  y: { [ln.Backward]: !1, [ln.Forward]: !1 },
}
function bD(e) {
  let { delta: n, disabled: t } = e
  const r = fu(n)
  return Rl(
    (i) => {
      if (t || !r || !i) return yD
      const s = { x: Math.sign(n.x - r.x), y: Math.sign(n.y - r.y) }
      return {
        x: {
          [ln.Backward]: i.x[ln.Backward] || s.x === -1,
          [ln.Forward]: i.x[ln.Forward] || s.x === 1,
        },
        y: {
          [ln.Backward]: i.y[ln.Backward] || s.y === -1,
          [ln.Forward]: i.y[ln.Forward] || s.y === 1,
        },
      }
    },
    [t, n, r],
  )
}
function vD(e, n) {
  const t = n != null ? e.get(n) : void 0,
    r = t ? t.node.current : null
  return Rl(
    (i) => {
      var s
      return n == null ? null : (s = r ?? i) != null ? s : null
    },
    [r, n],
  )
}
function wD(e, n) {
  return Y.useMemo(
    () =>
      e.reduce((t, r) => {
        const { sensor: i } = r,
          s = i.activators.map((o) => ({ eventName: o.eventName, handler: n(o.handler, r) }))
        return [...t, ...s]
      }, []),
    [e, n],
  )
}
var ol
;(function (e) {
  ;((e[(e.Always = 0)] = 'Always'),
    (e[(e.BeforeDragging = 1)] = 'BeforeDragging'),
    (e[(e.WhileDragging = 2)] = 'WhileDragging'))
})(ol || (ol = {}))
var Tp
;(function (e) {
  e.Optimized = 'optimized'
})(Tp || (Tp = {}))
const fb = new Map()
function xD(e, n) {
  let { dragging: t, dependencies: r, config: i } = n
  const [s, o] = Y.useState(null),
    { frequency: a, measure: l, strategy: c } = i,
    u = Y.useRef(e),
    f = m(),
    d = il(f),
    h = Y.useCallback(
      function (y) {
        ;(y === void 0 && (y = []),
          !d.current && o((b) => (b === null ? y : b.concat(y.filter((w) => !b.includes(w))))))
      },
      [d],
    ),
    p = Y.useRef(null),
    g = Rl(
      (y) => {
        if (f && !t) return fb
        if (!y || y === fb || u.current !== e || s != null) {
          const b = new Map()
          for (let w of e) {
            if (!w) continue
            if (s && s.length > 0 && !s.includes(w.id) && w.rect.current) {
              b.set(w.id, w.rect.current)
              continue
            }
            const C = w.node.current,
              T = C ? new E0(l(C), C) : null
            ;((w.rect.current = T), T && b.set(w.id, T))
          }
          return b
        }
        return y
      },
      [e, s, t, f, l],
    )
  return (
    Y.useEffect(() => {
      u.current = e
    }, [e]),
    Y.useEffect(() => {
      f || h()
    }, [t, f]),
    Y.useEffect(() => {
      s && s.length > 0 && o(null)
    }, [JSON.stringify(s)]),
    Y.useEffect(() => {
      f ||
        typeof a != 'number' ||
        p.current !== null ||
        (p.current = setTimeout(() => {
          ;(h(), (p.current = null))
        }, a))
    }, [a, f, h, ...r]),
    { droppableRects: g, measureDroppableContainers: h, measuringScheduled: s != null }
  )
  function m() {
    switch (c) {
      case ol.Always:
        return !1
      case ol.BeforeDragging:
        return t
      default:
        return !t
    }
  }
}
function A0(e, n) {
  return Rl((t) => (e ? t || (typeof n == 'function' ? n(e) : e) : null), [n, e])
}
function SD(e, n) {
  return A0(e, n)
}
function _D(e) {
  let { callback: n, disabled: t } = e
  const r = Of(n),
    i = Y.useMemo(() => {
      if (t || typeof window > 'u' || typeof window.MutationObserver > 'u') return
      const { MutationObserver: s } = window
      return new s(r)
    }, [r, t])
  return (Y.useEffect(() => () => i?.disconnect(), [i]), i)
}
function If(e) {
  let { callback: n, disabled: t } = e
  const r = Of(n),
    i = Y.useMemo(() => {
      if (t || typeof window > 'u' || typeof window.ResizeObserver > 'u') return
      const { ResizeObserver: s } = window
      return new s(r)
    }, [t])
  return (Y.useEffect(() => () => i?.disconnect(), [i]), i)
}
function kD(e) {
  return new E0(ta(e), e)
}
function db(e, n, t) {
  n === void 0 && (n = kD)
  const [r, i] = Y.useState(null)
  function s() {
    i((l) => {
      if (!e) return null
      if (e.isConnected === !1) {
        var c
        return (c = l ?? t) != null ? c : null
      }
      const u = n(e)
      return JSON.stringify(l) === JSON.stringify(u) ? l : u
    })
  }
  const o = _D({
      callback(l) {
        if (e)
          for (const c of l) {
            const { type: u, target: f } = c
            if (u === 'childList' && f instanceof HTMLElement && f.contains(e)) {
              s()
              break
            }
          }
      },
    }),
    a = If({ callback: s })
  return (
    Sr(() => {
      ;(s(),
        e
          ? (a?.observe(e), o?.observe(document.body, { childList: !0, subtree: !0 }))
          : (a?.disconnect(), o?.disconnect()))
    }, [e]),
    r
  )
}
function CD(e) {
  const n = A0(e)
  return P3(e, n)
}
const hb = []
function MD(e) {
  const n = Y.useRef(e),
    t = Rl(
      (r) =>
        e
          ? r && r !== hb && e && n.current && e.parentNode === n.current.parentNode
            ? r
            : Nf(e)
          : hb,
      [e],
    )
  return (
    Y.useEffect(() => {
      n.current = e
    }, [e]),
    t
  )
}
function ED(e) {
  const [n, t] = Y.useState(null),
    r = Y.useRef(e),
    i = Y.useCallback((s) => {
      const o = Hd(s.target)
      o && t((a) => (a ? (a.set(o, Mp(o)), new Map(a)) : null))
    }, [])
  return (
    Y.useEffect(() => {
      const s = r.current
      if (e !== s) {
        o(s)
        const a = e
          .map((l) => {
            const c = Hd(l)
            return c ? (c.addEventListener('scroll', i, { passive: !0 }), [c, Mp(c)]) : null
          })
          .filter((l) => l != null)
        ;(t(a.length ? new Map(a) : null), (r.current = e))
      }
      return () => {
        ;(o(e), o(s))
      }
      function o(a) {
        a.forEach((l) => {
          const c = Hd(l)
          c?.removeEventListener('scroll', i)
        })
      }
    }, [i, e]),
    Y.useMemo(
      () => (e.length ? (n ? Array.from(n.values()).reduce((s, o) => So(s, o), _r) : B3(e)) : _r),
      [e, n],
    )
  )
}
function pb(e, n) {
  n === void 0 && (n = [])
  const t = Y.useRef(null)
  return (
    Y.useEffect(() => {
      t.current = null
    }, n),
    Y.useEffect(() => {
      const r = e !== _r
      ;(r && !t.current && (t.current = e), !r && t.current && (t.current = null))
    }, [e]),
    t.current ? sl(e, t.current) : _r
  )
}
function TD(e) {
  Y.useEffect(
    () => {
      if (!Rf) return
      const n = e.map((t) => {
        let { sensor: r } = t
        return r.setup == null ? void 0 : r.setup()
      })
      return () => {
        for (const t of n) t?.()
      }
    },
    e.map((n) => {
      let { sensor: t } = n
      return t
    }),
  )
}
function AD(e, n) {
  return Y.useMemo(
    () =>
      e.reduce((t, r) => {
        let { eventName: i, handler: s } = r
        return (
          (t[i] = (o) => {
            s(o, n)
          }),
          t
        )
      }, {}),
    [e, n],
  )
}
function U3(e) {
  return Y.useMemo(() => (e ? tD(e) : null), [e])
}
const mb = []
function RD(e, n) {
  n === void 0 && (n = ta)
  const [t] = e,
    r = U3(t ? Dn(t) : null),
    [i, s] = Y.useState(mb)
  function o() {
    s(() => (e.length ? e.map((l) => (L3(l) ? r : new E0(n(l), l))) : mb))
  }
  const a = If({ callback: o })
  return (
    Sr(() => {
      ;(a?.disconnect(), o(), e.forEach((l) => a?.observe(l)))
    }, [e]),
    i
  )
}
function q3(e) {
  if (!e) return null
  if (e.children.length > 1) return e
  const n = e.children[0]
  return Al(n) ? n : e
}
function OD(e) {
  let { measure: n } = e
  const [t, r] = Y.useState(null),
    i = Y.useCallback(
      (c) => {
        for (const { target: u } of c)
          if (Al(u)) {
            r((f) => {
              const d = n(u)
              return f ? { ...f, width: d.width, height: d.height } : d
            })
            break
          }
      },
      [n],
    ),
    s = If({ callback: i }),
    o = Y.useCallback(
      (c) => {
        const u = q3(c)
        ;(s?.disconnect(), u && s?.observe(u), r(u ? n(u) : null))
      },
      [n, s],
    ),
    [a, l] = uu(o)
  return Y.useMemo(() => ({ nodeRef: a, rect: t, setRef: l }), [t, a, l])
}
const PD = [
    { sensor: H3, options: {} },
    { sensor: V3, options: {} },
  ],
  ND = { current: {} },
  Bc = {
    draggable: { measure: ab },
    droppable: { measure: ab, strategy: ol.WhileDragging, frequency: Tp.Optimized },
    dragOverlay: { measure: ta },
  }
class La extends Map {
  get(n) {
    var t
    return n != null && (t = super.get(n)) != null ? t : void 0
  }
  toArray() {
    return Array.from(this.values())
  }
  getEnabled() {
    return this.toArray().filter((n) => {
      let { disabled: t } = n
      return !t
    })
  }
  getNodeFor(n) {
    var t, r
    return (t = (r = this.get(n)) == null ? void 0 : r.node.current) != null ? t : void 0
  }
}
const ID = {
    activatorEvent: null,
    active: null,
    activeNode: null,
    activeNodeRect: null,
    collisions: null,
    containerNodeRect: null,
    draggableNodes: new Map(),
    droppableRects: new Map(),
    droppableContainers: new La(),
    over: null,
    dragOverlay: { nodeRef: { current: null }, rect: null, setRef: hu },
    scrollableAncestors: [],
    scrollableAncestorRects: [],
    measuringConfiguration: Bc,
    measureDroppableContainers: hu,
    windowRect: null,
    measuringScheduled: !1,
  },
  W3 = {
    activatorEvent: null,
    activators: [],
    active: null,
    activeNodeRect: null,
    ariaDescribedById: { draggable: '' },
    dispatch: hu,
    draggableNodes: new Map(),
    over: null,
    measureDroppableContainers: hu,
  },
  Pl = Y.createContext(W3),
  K3 = Y.createContext(ID)
function DD() {
  return {
    draggable: {
      active: null,
      initialCoordinates: { x: 0, y: 0 },
      nodes: new Map(),
      translate: { x: 0, y: 0 },
    },
    droppable: { containers: new La() },
  }
}
function jD(e, n) {
  switch (n.type) {
    case rn.DragStart:
      return {
        ...e,
        draggable: { ...e.draggable, initialCoordinates: n.initialCoordinates, active: n.active },
      }
    case rn.DragMove:
      return e.draggable.active == null
        ? e
        : {
            ...e,
            draggable: {
              ...e.draggable,
              translate: {
                x: n.coordinates.x - e.draggable.initialCoordinates.x,
                y: n.coordinates.y - e.draggable.initialCoordinates.y,
              },
            },
          }
    case rn.DragEnd:
    case rn.DragCancel:
      return {
        ...e,
        draggable: {
          ...e.draggable,
          active: null,
          initialCoordinates: { x: 0, y: 0 },
          translate: { x: 0, y: 0 },
        },
      }
    case rn.RegisterDroppable: {
      const { element: t } = n,
        { id: r } = t,
        i = new La(e.droppable.containers)
      return (i.set(r, t), { ...e, droppable: { ...e.droppable, containers: i } })
    }
    case rn.SetDroppableDisabled: {
      const { id: t, key: r, disabled: i } = n,
        s = e.droppable.containers.get(t)
      if (!s || r !== s.key) return e
      const o = new La(e.droppable.containers)
      return (
        o.set(t, { ...s, disabled: i }),
        { ...e, droppable: { ...e.droppable, containers: o } }
      )
    }
    case rn.UnregisterDroppable: {
      const { id: t, key: r } = n,
        i = e.droppable.containers.get(t)
      if (!i || r !== i.key) return e
      const s = new La(e.droppable.containers)
      return (s.delete(t), { ...e, droppable: { ...e.droppable, containers: s } })
    }
    default:
      return e
  }
}
function LD(e) {
  let { disabled: n } = e
  const { active: t, activatorEvent: r, draggableNodes: i } = Y.useContext(Pl),
    s = fu(r),
    o = fu(t?.id)
  return (
    Y.useEffect(() => {
      if (!n && !r && s && o != null) {
        if (!Pf(s) || document.activeElement === s.target) return
        const a = i.get(o)
        if (!a) return
        const { activatorNode: l, node: c } = a
        if (!l.current && !c.current) return
        requestAnimationFrame(() => {
          for (const u of [l.current, c.current]) {
            if (!u) continue
            const f = II(u)
            if (f) {
              f.focus()
              break
            }
          }
        })
      }
    }, [r, n, i, o, s]),
    null
  )
}
function G3(e, n) {
  let { transform: t, ...r } = n
  return e != null && e.length ? e.reduce((i, s) => s({ transform: i, ...r }), t) : t
}
function FD(e) {
  return Y.useMemo(
    () => ({
      draggable: { ...Bc.draggable, ...e?.draggable },
      droppable: { ...Bc.droppable, ...e?.droppable },
      dragOverlay: { ...Bc.dragOverlay, ...e?.dragOverlay },
    }),
    [e?.draggable, e?.droppable, e?.dragOverlay],
  )
}
function BD(e) {
  let { activeNode: n, measure: t, initialRect: r, config: i = !0 } = e
  const s = Y.useRef(!1),
    { x: o, y: a } = typeof i == 'boolean' ? { x: i, y: i } : i
  Sr(() => {
    if ((!o && !a) || !n) {
      s.current = !1
      return
    }
    if (s.current || !r) return
    const c = n?.node.current
    if (!c || c.isConnected === !1) return
    const u = t(c),
      f = P3(u, r)
    if (
      (o || (f.x = 0), a || (f.y = 0), (s.current = !0), Math.abs(f.x) > 0 || Math.abs(f.y) > 0)
    ) {
      const d = I3(c)
      d && d.scrollBy({ top: f.y, left: f.x })
    }
  }, [n, o, a, r, t])
}
const Df = Y.createContext({ ..._r, scaleX: 1, scaleY: 1 })
var yi
;(function (e) {
  ;((e[(e.Uninitialized = 0)] = 'Uninitialized'),
    (e[(e.Initializing = 1)] = 'Initializing'),
    (e[(e.Initialized = 2)] = 'Initialized'))
})(yi || (yi = {}))
const FZ = Y.memo(function (n) {
    var t, r, i, s
    let {
      id: o,
      accessibility: a,
      autoScroll: l = !0,
      children: c,
      sensors: u = PD,
      collisionDetection: f = GI,
      measuring: d,
      modifiers: h,
      ...p
    } = n
    const g = Y.useReducer(jD, void 0, DD),
      [m, y] = g,
      [b, w] = zI(),
      [C, T] = Y.useState(yi.Uninitialized),
      I = C === yi.Initialized,
      {
        draggable: { active: B, nodes: E, translate: O },
        droppable: { containers: P },
      } = m,
      $ = B != null ? E.get(B) : null,
      F = Y.useRef({ initial: null, translated: null }),
      M = Y.useMemo(() => {
        var Ut
        return B != null ? { id: B, data: (Ut = $?.data) != null ? Ut : ND, rect: F } : null
      }, [B, $]),
      R = Y.useRef(null),
      [k, v] = Y.useState(null),
      [x, _] = Y.useState(null),
      S = il(p, Object.values(p)),
      A = Ol('DndDescribedBy', o),
      j = Y.useMemo(() => P.getEnabled(), [P]),
      L = FD(d),
      {
        droppableRects: H,
        measureDroppableContainers: U,
        measuringScheduled: K,
      } = xD(j, { dragging: I, dependencies: [O.x, O.y], config: L.droppable }),
      z = vD(E, B),
      q = Y.useMemo(() => (x ? du(x) : null), [x]),
      D = be(),
      N = SD(z, L.draggable.measure)
    BD({
      activeNode: B != null ? E.get(B) : null,
      config: D.layoutShiftCompensation,
      initialRect: N,
      measure: L.draggable.measure,
    })
    const V = db(z, L.draggable.measure, N),
      W = db(z ? z.parentElement : null),
      J = Y.useRef({
        activatorEvent: null,
        active: null,
        activeNode: z,
        collisionRect: null,
        collisions: null,
        droppableRects: H,
        draggableNodes: E,
        draggingNode: null,
        draggingNodeRect: null,
        droppableContainers: P,
        over: null,
        scrollableAncestors: [],
        scrollAdjustedTranslate: null,
      }),
      G = P.getNodeFor((t = J.current.over) == null ? void 0 : t.id),
      Z = OD({ measure: L.dragOverlay.measure }),
      rt = (r = Z.nodeRef.current) != null ? r : z,
      nt = I ? ((i = Z.rect) != null ? i : V) : null,
      X = !!(Z.nodeRef.current && Z.rect),
      Q = CD(X ? null : V),
      tt = U3(rt ? Dn(rt) : null),
      st = MD(I ? (G ?? z) : null),
      ot = RD(st),
      at = G3(h, {
        transform: { x: O.x - Q.x, y: O.y - Q.y, scaleX: 1, scaleY: 1 },
        activatorEvent: x,
        active: M,
        activeNodeRect: V,
        containerNodeRect: W,
        draggingNodeRect: nt,
        over: J.current.over,
        overlayNodeRect: Z.rect,
        scrollableAncestors: st,
        scrollableAncestorRects: ot,
        windowRect: tt,
      }),
      ht = q ? So(q, O) : null,
      dt = ED(st),
      mt = pb(dt),
      bt = pb(dt, [V]),
      yt = So(at, mt),
      vt = nt ? ZI(nt, at) : null,
      Nt =
        M && vt
          ? f({
              active: M,
              collisionRect: vt,
              droppableRects: H,
              droppableContainers: j,
              pointerCoordinates: ht,
            })
          : null,
      Dt = O3(Nt, 'id'),
      [Mt, Ot] = Y.useState(null),
      Ct = X ? at : So(at, bt),
      xt = XI(Ct, (s = Mt?.rect) != null ? s : null, V),
      Rt = Y.useRef(null),
      It = Y.useCallback(
        (Ut, Lt) => {
          let { sensor: le, options: ce } = Lt
          if (R.current == null) return
          const Ft = E.get(R.current)
          if (!Ft) return
          const Qt = Ut.nativeEvent,
            fe = new le({
              active: R.current,
              activeNode: Ft,
              event: Qt,
              options: ce,
              context: J,
              onAbort(Jt) {
                if (!E.get(Jt)) return
                const { onDragAbort: Wt } = S.current,
                  it = { id: Jt }
                ;(Wt?.(it), b({ type: 'onDragAbort', event: it }))
              },
              onPending(Jt, me, Wt, it) {
                if (!E.get(Jt)) return
                const { onDragPending: pt } = S.current,
                  _t = { id: Jt, constraint: me, initialCoordinates: Wt, offset: it }
                ;(pt?.(_t), b({ type: 'onDragPending', event: _t }))
              },
              onStart(Jt) {
                const me = R.current
                if (me == null) return
                const Wt = E.get(me)
                if (!Wt) return
                const { onDragStart: it } = S.current,
                  ct = { activatorEvent: Qt, active: { id: me, data: Wt.data, rect: F } }
                Ei.unstable_batchedUpdates(() => {
                  ;(it?.(ct),
                    T(yi.Initializing),
                    y({ type: rn.DragStart, initialCoordinates: Jt, active: me }),
                    b({ type: 'onDragStart', event: ct }),
                    v(Rt.current),
                    _(Qt))
                })
              },
              onMove(Jt) {
                y({ type: rn.DragMove, coordinates: Jt })
              },
              onEnd: qt(rn.DragEnd),
              onCancel: qt(rn.DragCancel),
            })
          Rt.current = fe
          function qt(Jt) {
            return async function () {
              const {
                active: Wt,
                collisions: it,
                over: ct,
                scrollAdjustedTranslate: pt,
              } = J.current
              let _t = null
              if (Wt && pt) {
                const { cancelDrop: Vt } = S.current
                ;((_t = { activatorEvent: Qt, active: Wt, collisions: it, delta: pt, over: ct }),
                  Jt === rn.DragEnd &&
                    typeof Vt == 'function' &&
                    (await Promise.resolve(Vt(_t))) &&
                    (Jt = rn.DragCancel))
              }
              ;((R.current = null),
                Ei.unstable_batchedUpdates(() => {
                  ;(y({ type: Jt }),
                    T(yi.Uninitialized),
                    Ot(null),
                    v(null),
                    _(null),
                    (Rt.current = null))
                  const Vt = Jt === rn.DragEnd ? 'onDragEnd' : 'onDragCancel'
                  if (_t) {
                    const Tt = S.current[Vt]
                    ;(Tt?.(_t), b({ type: Vt, event: _t }))
                  }
                }))
            }
          }
        },
        [E],
      ),
      Pt = Y.useCallback(
        (Ut, Lt) => (le, ce) => {
          const Ft = le.nativeEvent,
            Qt = E.get(ce)
          if (R.current !== null || !Qt || Ft.dndKit || Ft.defaultPrevented) return
          const fe = { active: Qt }
          Ut(le, Lt.options, fe) === !0 &&
            ((Ft.dndKit = { capturedBy: Lt.sensor }), (R.current = ce), It(le, Lt))
        },
        [E, It],
      ),
      ae = wD(u, Pt)
    ;(TD(u),
      Sr(() => {
        V && C === yi.Initializing && T(yi.Initialized)
      }, [V, C]),
      Y.useEffect(() => {
        const { onDragMove: Ut } = S.current,
          { active: Lt, activatorEvent: le, collisions: ce, over: Ft } = J.current
        if (!Lt || !le) return
        const Qt = {
          active: Lt,
          activatorEvent: le,
          collisions: ce,
          delta: { x: yt.x, y: yt.y },
          over: Ft,
        }
        Ei.unstable_batchedUpdates(() => {
          ;(Ut?.(Qt), b({ type: 'onDragMove', event: Qt }))
        })
      }, [yt.x, yt.y]),
      Y.useEffect(() => {
        const {
          active: Ut,
          activatorEvent: Lt,
          collisions: le,
          droppableContainers: ce,
          scrollAdjustedTranslate: Ft,
        } = J.current
        if (!Ut || R.current == null || !Lt || !Ft) return
        const { onDragOver: Qt } = S.current,
          fe = ce.get(Dt),
          qt =
            fe && fe.rect.current
              ? { id: fe.id, rect: fe.rect.current, data: fe.data, disabled: fe.disabled }
              : null,
          Jt = {
            active: Ut,
            activatorEvent: Lt,
            collisions: le,
            delta: { x: Ft.x, y: Ft.y },
            over: qt,
          }
        Ei.unstable_batchedUpdates(() => {
          ;(Ot(qt), Qt?.(Jt), b({ type: 'onDragOver', event: Jt }))
        })
      }, [Dt]),
      Sr(() => {
        ;((J.current = {
          activatorEvent: x,
          active: M,
          activeNode: z,
          collisionRect: vt,
          collisions: Nt,
          droppableRects: H,
          draggableNodes: E,
          draggingNode: rt,
          draggingNodeRect: nt,
          droppableContainers: P,
          over: Mt,
          scrollableAncestors: st,
          scrollAdjustedTranslate: yt,
        }),
          (F.current = { initial: nt, translated: vt }))
      }, [M, z, Nt, vt, E, rt, nt, H, P, Mt, st, yt]),
      gD({
        ...D,
        delta: O,
        draggingRect: vt,
        pointerCoordinates: ht,
        scrollableAncestors: st,
        scrollableAncestorRects: ot,
      }))
    const Se = Y.useMemo(
        () => ({
          active: M,
          activeNode: z,
          activeNodeRect: V,
          activatorEvent: x,
          collisions: Nt,
          containerNodeRect: W,
          dragOverlay: Z,
          draggableNodes: E,
          droppableContainers: P,
          droppableRects: H,
          over: Mt,
          measureDroppableContainers: U,
          scrollableAncestors: st,
          scrollableAncestorRects: ot,
          measuringConfiguration: L,
          measuringScheduled: K,
          windowRect: tt,
        }),
        [M, z, V, x, Nt, W, Z, E, P, H, Mt, U, st, ot, L, K, tt],
      ),
      zt = Y.useMemo(
        () => ({
          activatorEvent: x,
          activators: ae,
          active: M,
          activeNodeRect: V,
          ariaDescribedById: { draggable: A },
          dispatch: y,
          draggableNodes: E,
          over: Mt,
          measureDroppableContainers: U,
        }),
        [x, ae, M, V, y, A, E, Mt, U],
      )
    return ut.createElement(
      T3.Provider,
      { value: w },
      ut.createElement(
        Pl.Provider,
        { value: zt },
        ut.createElement(
          K3.Provider,
          { value: Se },
          ut.createElement(Df.Provider, { value: xt }, c),
        ),
        ut.createElement(LD, { disabled: a?.restoreFocus === !1 }),
      ),
      ut.createElement(HI, { ...a, hiddenTextDescribedById: A }),
    )
    function be() {
      const Ut = k?.autoScrollEnabled === !1,
        Lt = typeof l == 'object' ? l.enabled === !1 : l === !1,
        le = I && !Ut && !Lt
      return typeof l == 'object' ? { ...l, enabled: le } : { enabled: le }
    }
  }),
  zD = Y.createContext(null),
  gb = 'button',
  $D = 'Draggable'
function VD(e) {
  let { id: n, data: t, disabled: r = !1, attributes: i } = e
  const s = Ol($D),
    {
      activators: o,
      activatorEvent: a,
      active: l,
      activeNodeRect: c,
      ariaDescribedById: u,
      draggableNodes: f,
      over: d,
    } = Y.useContext(Pl),
    { role: h = gb, roleDescription: p = 'draggable', tabIndex: g = 0 } = i ?? {},
    m = l?.id === n,
    y = Y.useContext(m ? Df : zD),
    [b, w] = uu(),
    [C, T] = uu(),
    I = AD(o, n),
    B = il(t)
  Sr(
    () => (
      f.set(n, { id: n, key: s, node: b, activatorNode: C, data: B }),
      () => {
        const O = f.get(n)
        O && O.key === s && f.delete(n)
      }
    ),
    [f, n],
  )
  const E = Y.useMemo(
    () => ({
      role: h,
      tabIndex: g,
      'aria-disabled': r,
      'aria-pressed': m && h === gb ? !0 : void 0,
      'aria-roledescription': p,
      'aria-describedby': u.draggable,
    }),
    [r, h, g, m, p, u.draggable],
  )
  return {
    active: l,
    activatorEvent: a,
    activeNodeRect: c,
    attributes: E,
    isDragging: m,
    listeners: r ? void 0 : I,
    node: b,
    over: d,
    setNodeRef: w,
    setActivatorNodeRef: T,
    transform: y,
  }
}
function X3() {
  return Y.useContext(K3)
}
const HD = 'Droppable',
  UD = { timeout: 25 }
function qD(e) {
  let { data: n, disabled: t = !1, id: r, resizeObserverConfig: i } = e
  const s = Ol(HD),
    { active: o, dispatch: a, over: l, measureDroppableContainers: c } = Y.useContext(Pl),
    u = Y.useRef({ disabled: t }),
    f = Y.useRef(!1),
    d = Y.useRef(null),
    h = Y.useRef(null),
    { disabled: p, updateMeasurementsFor: g, timeout: m } = { ...UD, ...i },
    y = il(g ?? r),
    b = Y.useCallback(() => {
      if (!f.current) {
        f.current = !0
        return
      }
      ;(h.current != null && clearTimeout(h.current),
        (h.current = setTimeout(() => {
          ;(c(Array.isArray(y.current) ? y.current : [y.current]), (h.current = null))
        }, m)))
    }, [m]),
    w = If({ callback: b, disabled: p || !o }),
    C = Y.useCallback(
      (E, O) => {
        w && (O && (w.unobserve(O), (f.current = !1)), E && w.observe(E))
      },
      [w],
    ),
    [T, I] = uu(C),
    B = il(n)
  return (
    Y.useEffect(() => {
      !w || !T.current || (w.disconnect(), (f.current = !1), w.observe(T.current))
    }, [T, w]),
    Y.useEffect(
      () => (
        a({
          type: rn.RegisterDroppable,
          element: { id: r, key: s, disabled: t, node: T, rect: d, data: B },
        }),
        () => a({ type: rn.UnregisterDroppable, key: s, id: r })
      ),
      [r],
    ),
    Y.useEffect(() => {
      t !== u.current.disabled &&
        (a({ type: rn.SetDroppableDisabled, id: r, key: s, disabled: t }), (u.current.disabled = t))
    }, [r, s, t, a]),
    { active: o, rect: d, isOver: l?.id === r, node: T, over: l, setNodeRef: I }
  )
}
function WD(e) {
  let { animation: n, children: t } = e
  const [r, i] = Y.useState(null),
    [s, o] = Y.useState(null),
    a = fu(t)
  return (
    !t && !r && a && i(a),
    Sr(() => {
      if (!s) return
      const l = r?.key,
        c = r?.props.id
      if (l == null || c == null) {
        i(null)
        return
      }
      Promise.resolve(n(c, s)).then(() => {
        i(null)
      })
    }, [n, r, s]),
    ut.createElement(ut.Fragment, null, t, r ? Y.cloneElement(r, { ref: o }) : null)
  )
}
const KD = { x: 0, y: 0, scaleX: 1, scaleY: 1 }
function GD(e) {
  let { children: n } = e
  return ut.createElement(
    Pl.Provider,
    { value: W3 },
    ut.createElement(Df.Provider, { value: KD }, n),
  )
}
const XD = { position: 'fixed', touchAction: 'none' },
  YD = (e) => (Pf(e) ? 'transform 250ms ease' : void 0),
  ZD = Y.forwardRef((e, n) => {
    let {
      as: t,
      activatorEvent: r,
      adjustScale: i,
      children: s,
      className: o,
      rect: a,
      style: l,
      transform: c,
      transition: u = YD,
    } = e
    if (!a) return null
    const f = i ? c : { ...c, scaleX: 1, scaleY: 1 },
      d = {
        ...XD,
        width: a.width,
        height: a.height,
        top: a.top,
        left: a.left,
        transform: Ps.Transform.toString(f),
        transformOrigin: i && r ? UI(r, a) : void 0,
        transition: typeof u == 'function' ? u(r) : u,
        ...l,
      }
    return ut.createElement(t, { className: o, style: d, ref: n }, s)
  }),
  JD = (e) => (n) => {
    let { active: t, dragOverlay: r } = n
    const i = {},
      { styles: s, className: o } = e
    if (s != null && s.active)
      for (const [a, l] of Object.entries(s.active))
        l !== void 0 && ((i[a] = t.node.style.getPropertyValue(a)), t.node.style.setProperty(a, l))
    if (s != null && s.dragOverlay)
      for (const [a, l] of Object.entries(s.dragOverlay))
        l !== void 0 && r.node.style.setProperty(a, l)
    return (
      o != null && o.active && t.node.classList.add(o.active),
      o != null && o.dragOverlay && r.node.classList.add(o.dragOverlay),
      function () {
        for (const [l, c] of Object.entries(i)) t.node.style.setProperty(l, c)
        o != null && o.active && t.node.classList.remove(o.active)
      }
    )
  },
  QD = (e) => {
    let {
      transform: { initial: n, final: t },
    } = e
    return [{ transform: Ps.Transform.toString(n) }, { transform: Ps.Transform.toString(t) }]
  },
  tj = {
    duration: 250,
    easing: 'ease',
    keyframes: QD,
    sideEffects: JD({ styles: { active: { opacity: '0' } } }),
  }
function ej(e) {
  let { config: n, draggableNodes: t, droppableContainers: r, measuringConfiguration: i } = e
  return Of((s, o) => {
    if (n === null) return
    const a = t.get(s)
    if (!a) return
    const l = a.node.current
    if (!l) return
    const c = q3(o)
    if (!c) return
    const { transform: u } = Dn(o).getComputedStyle(o),
      f = N3(u)
    if (!f) return
    const d = typeof n == 'function' ? n : nj(n)
    return (
      z3(l, i.draggable.measure),
      d({
        active: { id: s, data: a.data, node: l, rect: i.draggable.measure(l) },
        draggableNodes: t,
        dragOverlay: { node: o, rect: i.dragOverlay.measure(c) },
        droppableContainers: r,
        measuringConfiguration: i,
        transform: f,
      })
    )
  })
}
function nj(e) {
  const { duration: n, easing: t, sideEffects: r, keyframes: i } = { ...tj, ...e }
  return (s) => {
    let { active: o, dragOverlay: a, transform: l, ...c } = s
    if (!n) return
    const u = { x: a.rect.left - o.rect.left, y: a.rect.top - o.rect.top },
      f = {
        scaleX: l.scaleX !== 1 ? (o.rect.width * l.scaleX) / a.rect.width : 1,
        scaleY: l.scaleY !== 1 ? (o.rect.height * l.scaleY) / a.rect.height : 1,
      },
      d = { x: l.x - u.x, y: l.y - u.y, ...f },
      h = i({ ...c, active: o, dragOverlay: a, transform: { initial: l, final: d } }),
      [p] = h,
      g = h[h.length - 1]
    if (JSON.stringify(p) === JSON.stringify(g)) return
    const m = r?.({ active: o, dragOverlay: a, ...c }),
      y = a.node.animate(h, { duration: n, easing: t, fill: 'forwards' })
    return new Promise((b) => {
      y.onfinish = () => {
        ;(m?.(), b())
      }
    })
  }
}
let yb = 0
function rj(e) {
  return Y.useMemo(() => {
    if (e != null) return (yb++, yb)
  }, [e])
}
const BZ = ut.memo((e) => {
  let {
    adjustScale: n = !1,
    children: t,
    dropAnimation: r,
    style: i,
    transition: s,
    modifiers: o,
    wrapperElement: a = 'div',
    className: l,
    zIndex: c = 999,
  } = e
  const {
      activatorEvent: u,
      active: f,
      activeNodeRect: d,
      containerNodeRect: h,
      draggableNodes: p,
      droppableContainers: g,
      dragOverlay: m,
      over: y,
      measuringConfiguration: b,
      scrollableAncestors: w,
      scrollableAncestorRects: C,
      windowRect: T,
    } = X3(),
    I = Y.useContext(Df),
    B = rj(f?.id),
    E = G3(o, {
      activatorEvent: u,
      active: f,
      activeNodeRect: d,
      containerNodeRect: h,
      draggingNodeRect: m.rect,
      over: y,
      overlayNodeRect: m.rect,
      scrollableAncestors: w,
      scrollableAncestorRects: C,
      transform: I,
      windowRect: T,
    }),
    O = A0(d),
    P = ej({ config: r, draggableNodes: p, droppableContainers: g, measuringConfiguration: b }),
    $ = O ? m.setRef : void 0
  return ut.createElement(
    GD,
    null,
    ut.createElement(
      WD,
      { animation: P },
      f && B
        ? ut.createElement(
            ZD,
            {
              key: B,
              id: f.id,
              ref: $,
              as: a,
              activatorEvent: u,
              adjustScale: n,
              className: l,
              transition: s,
              rect: O,
              style: { zIndex: c, ...i },
              transform: E,
            },
            t,
          )
        : null,
    ),
  )
})
function Y3(e, n, t) {
  const r = e.slice()
  return (r.splice(t < 0 ? r.length + t : t, 0, r.splice(n, 1)[0]), r)
}
function ij(e, n) {
  return e.reduce((t, r, i) => {
    const s = n.get(r)
    return (s && (t[i] = s), t)
  }, Array(e.length))
}
function lc(e) {
  return e !== null && e >= 0
}
function sj(e, n) {
  if (e === n) return !0
  if (e.length !== n.length) return !1
  for (let t = 0; t < e.length; t++) if (e[t] !== n[t]) return !1
  return !0
}
function oj(e) {
  return typeof e == 'boolean' ? { draggable: e, droppable: e } : e
}
const Z3 = (e) => {
    let { rects: n, activeIndex: t, overIndex: r, index: i } = e
    const s = Y3(n, r, t),
      o = n[i],
      a = s[i]
    return !a || !o
      ? null
      : {
          x: a.left - o.left,
          y: a.top - o.top,
          scaleX: a.width / o.width,
          scaleY: a.height / o.height,
        }
  },
  cc = { scaleX: 1, scaleY: 1 },
  zZ = (e) => {
    var n
    let { activeIndex: t, activeNodeRect: r, index: i, rects: s, overIndex: o } = e
    const a = (n = s[t]) != null ? n : r
    if (!a) return null
    if (i === t) {
      const c = s[o]
      return c
        ? { x: 0, y: t < o ? c.top + c.height - (a.top + a.height) : c.top - a.top, ...cc }
        : null
    }
    const l = aj(s, i, t)
    return i > t && i <= o
      ? { x: 0, y: -a.height - l, ...cc }
      : i < t && i >= o
        ? { x: 0, y: a.height + l, ...cc }
        : { x: 0, y: 0, ...cc }
  }
function aj(e, n, t) {
  const r = e[n],
    i = e[n - 1],
    s = e[n + 1]
  return r
    ? t < n
      ? i
        ? r.top - (i.top + i.height)
        : s
          ? s.top - (r.top + r.height)
          : 0
      : s
        ? s.top - (r.top + r.height)
        : i
          ? r.top - (i.top + i.height)
          : 0
    : 0
}
const J3 = 'Sortable',
  Q3 = ut.createContext({
    activeIndex: -1,
    containerId: J3,
    disableTransforms: !1,
    items: [],
    overIndex: -1,
    useDragOverlay: !1,
    sortedRects: [],
    strategy: Z3,
    disabled: { draggable: !1, droppable: !1 },
  })
function $Z(e) {
  let { children: n, id: t, items: r, strategy: i = Z3, disabled: s = !1 } = e
  const {
      active: o,
      dragOverlay: a,
      droppableRects: l,
      over: c,
      measureDroppableContainers: u,
    } = X3(),
    f = Ol(J3, t),
    d = a.rect !== null,
    h = Y.useMemo(() => r.map((I) => (typeof I == 'object' && 'id' in I ? I.id : I)), [r]),
    p = o != null,
    g = o ? h.indexOf(o.id) : -1,
    m = c ? h.indexOf(c.id) : -1,
    y = Y.useRef(h),
    b = !sj(h, y.current),
    w = (m !== -1 && g === -1) || b,
    C = oj(s)
  ;(Sr(() => {
    b && p && u(h)
  }, [b, h, p, u]),
    Y.useEffect(() => {
      y.current = h
    }, [h]))
  const T = Y.useMemo(
    () => ({
      activeIndex: g,
      containerId: f,
      disabled: C,
      disableTransforms: w,
      items: h,
      overIndex: m,
      useDragOverlay: d,
      sortedRects: ij(h, l),
      strategy: i,
    }),
    [g, f, C.draggable, C.droppable, w, h, m, l, d, i],
  )
  return ut.createElement(Q3.Provider, { value: T }, n)
}
const lj = (e) => {
    let { id: n, items: t, activeIndex: r, overIndex: i } = e
    return Y3(t, r, i).indexOf(n)
  },
  cj = (e) => {
    let {
      containerId: n,
      isSorting: t,
      wasDragging: r,
      index: i,
      items: s,
      newIndex: o,
      previousItems: a,
      previousContainerId: l,
      transition: c,
    } = e
    return !c || !r || (a !== s && i === o) ? !1 : t ? !0 : o !== i && n === l
  },
  uj = { duration: 200, easing: 'ease' },
  t4 = 'transform',
  fj = Ps.Transition.toString({ property: t4, duration: 0, easing: 'linear' }),
  dj = { roleDescription: 'sortable' }
function hj(e) {
  let { disabled: n, index: t, node: r, rect: i } = e
  const [s, o] = Y.useState(null),
    a = Y.useRef(t)
  return (
    Sr(() => {
      if (!n && t !== a.current && r.current) {
        const l = i.current
        if (l) {
          const c = ta(r.current, { ignoreTransform: !0 }),
            u = {
              x: l.left - c.left,
              y: l.top - c.top,
              scaleX: l.width / c.width,
              scaleY: l.height / c.height,
            }
          ;(u.x || u.y) && o(u)
        }
      }
      t !== a.current && (a.current = t)
    }, [n, t, r, i]),
    Y.useEffect(() => {
      s && o(null)
    }, [s]),
    s
  )
}
function VZ(e) {
  let {
    animateLayoutChanges: n = cj,
    attributes: t,
    disabled: r,
    data: i,
    getNewIndex: s = lj,
    id: o,
    strategy: a,
    resizeObserverConfig: l,
    transition: c = uj,
  } = e
  const {
      items: u,
      containerId: f,
      activeIndex: d,
      disabled: h,
      disableTransforms: p,
      sortedRects: g,
      overIndex: m,
      useDragOverlay: y,
      strategy: b,
    } = Y.useContext(Q3),
    w = pj(r, h),
    C = u.indexOf(o),
    T = Y.useMemo(() => ({ sortable: { containerId: f, index: C, items: u }, ...i }), [f, i, C, u]),
    I = Y.useMemo(() => u.slice(u.indexOf(o)), [u, o]),
    {
      rect: B,
      node: E,
      isOver: O,
      setNodeRef: P,
    } = qD({
      id: o,
      data: T,
      disabled: w.droppable,
      resizeObserverConfig: { updateMeasurementsFor: I, ...l },
    }),
    {
      active: $,
      activatorEvent: F,
      activeNodeRect: M,
      attributes: R,
      setNodeRef: k,
      listeners: v,
      isDragging: x,
      over: _,
      setActivatorNodeRef: S,
      transform: A,
    } = VD({ id: o, data: T, attributes: { ...dj, ...t }, disabled: w.draggable }),
    j = RI(P, k),
    L = !!$,
    H = L && !p && lc(d) && lc(m),
    U = !y && x,
    K = U && H ? A : null,
    q = H
      ? (K ?? (a ?? b)({ rects: g, activeNodeRect: M, activeIndex: d, overIndex: m, index: C }))
      : null,
    D = lc(d) && lc(m) ? s({ id: o, items: u, activeIndex: d, overIndex: m }) : C,
    N = $?.id,
    V = Y.useRef({ activeId: N, items: u, newIndex: D, containerId: f }),
    W = u !== V.current.items,
    J = n({
      active: $,
      containerId: f,
      isDragging: x,
      isSorting: L,
      id: o,
      index: C,
      items: u,
      newIndex: V.current.newIndex,
      previousItems: V.current.items,
      previousContainerId: V.current.containerId,
      transition: c,
      wasDragging: V.current.activeId != null,
    }),
    G = hj({ disabled: !J, index: C, node: E, rect: B })
  return (
    Y.useEffect(() => {
      ;(L && V.current.newIndex !== D && (V.current.newIndex = D),
        f !== V.current.containerId && (V.current.containerId = f),
        u !== V.current.items && (V.current.items = u))
    }, [L, D, f, u]),
    Y.useEffect(() => {
      if (N === V.current.activeId) return
      if (N != null && V.current.activeId == null) {
        V.current.activeId = N
        return
      }
      const rt = setTimeout(() => {
        V.current.activeId = N
      }, 50)
      return () => clearTimeout(rt)
    }, [N]),
    {
      active: $,
      activeIndex: d,
      attributes: R,
      data: T,
      rect: B,
      index: C,
      newIndex: D,
      items: u,
      isOver: O,
      isSorting: L,
      isDragging: x,
      listeners: v,
      node: E,
      overIndex: m,
      over: _,
      setNodeRef: j,
      setActivatorNodeRef: S,
      setDroppableNodeRef: P,
      setDraggableNodeRef: k,
      transform: G ?? q,
      transition: Z(),
    }
  )
  function Z() {
    if (G || (W && V.current.newIndex === C)) return fj
    if (!((U && !Pf(F)) || !c) && (L || J)) return Ps.Transition.toString({ ...c, property: t4 })
  }
}
function pj(e, n) {
  var t, r
  return typeof e == 'boolean'
    ? { draggable: e, droppable: !1 }
    : {
        draggable: (t = e?.draggable) != null ? t : n.draggable,
        droppable: (r = e?.droppable) != null ? r : n.droppable,
      }
}
function mu(e) {
  if (!e) return !1
  const n = e.data.current
  return !!(
    n &&
    'sortable' in n &&
    typeof n.sortable == 'object' &&
    'containerId' in n.sortable &&
    'items' in n.sortable &&
    'index' in n.sortable
  )
}
const mj = [_e.Down, _e.Right, _e.Up, _e.Left],
  HZ = (e, n) => {
    let {
      context: {
        active: t,
        collisionRect: r,
        droppableRects: i,
        droppableContainers: s,
        over: o,
        scrollableAncestors: a,
      },
    } = n
    if (mj.includes(e.code)) {
      if ((e.preventDefault(), !t || !r)) return
      const l = []
      s.getEnabled().forEach((f) => {
        if (!f || (f != null && f.disabled)) return
        const d = i.get(f.id)
        if (d)
          switch (e.code) {
            case _e.Down:
              r.top < d.top && l.push(f)
              break
            case _e.Up:
              r.top > d.top && l.push(f)
              break
            case _e.Left:
              r.left > d.left && l.push(f)
              break
            case _e.Right:
              r.left < d.left && l.push(f)
              break
          }
      })
      const c = WI({ collisionRect: r, droppableRects: i, droppableContainers: l })
      let u = O3(c, 'id')
      if ((u === o?.id && c.length > 1 && (u = c[1].id), u != null)) {
        const f = s.get(t.id),
          d = s.get(u),
          h = d ? i.get(d.id) : null,
          p = d?.node.current
        if (p && h && f && d) {
          const m = Nf(p).some((I, B) => a[B] !== I),
            y = e4(f, d),
            b = gj(f, d),
            w =
              m || !y
                ? { x: 0, y: 0 }
                : { x: b ? r.width - h.width : 0, y: b ? r.height - h.height : 0 },
            C = { x: h.left, y: h.top }
          return w.x && w.y ? C : sl(C, w)
        }
      }
    }
  }
function e4(e, n) {
  return !mu(e) || !mu(n)
    ? !1
    : e.data.current.sortable.containerId === n.data.current.sortable.containerId
}
function gj(e, n) {
  return !mu(e) || !mu(n) || !e4(e, n)
    ? !1
    : e.data.current.sortable.index < n.data.current.sortable.index
}
function uc(e) {
  throw new Error(
    'Could not dynamically require "' +
      e +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.',
  )
}
var n4 = { exports: {} }
/*! ExcelJS 19-10-2023 */ ;(function (e, n) {
  ;(function (t) {
    e.exports = t()
  })(function () {
    return (function t(r, i, s) {
      function o(c, u) {
        if (!i[c]) {
          if (!r[c]) {
            var f = typeof uc == 'function' && uc
            if (!u && f) return f(c, !0)
            if (a) return a(c, !0)
            var d = new Error("Cannot find module '" + c + "'")
            throw ((d.code = 'MODULE_NOT_FOUND'), d)
          }
          var h = (i[c] = { exports: {} })
          r[c][0].call(
            h.exports,
            function (p) {
              return o(r[c][1][p] || p)
            },
            h,
            h.exports,
            t,
            r,
            i,
            s,
          )
        }
        return i[c].exports
      }
      for (var a = typeof uc == 'function' && uc, l = 0; l < s.length; l++) o(s[l])
      return o
    })(
      {
        1: [
          function (t, r, i) {
            const s = t('fs'),
              o = t('fast-csv'),
              a = t('dayjs/plugin/customParseFormat'),
              l = t('dayjs/plugin/utc'),
              c = t('dayjs').extend(a).extend(l),
              u = t('../utils/stream-buf'),
              {
                fs: { exists: f },
              } = t('../utils/utils'),
              d = {
                true: !0,
                false: !1,
                '#N/A': { error: '#N/A' },
                '#REF!': { error: '#REF!' },
                '#NAME?': { error: '#NAME?' },
                '#DIV/0!': { error: '#DIV/0!' },
                '#NULL!': { error: '#NULL!' },
                '#VALUE!': { error: '#VALUE!' },
                '#NUM!': { error: '#NUM!' },
              }
            r.exports = class {
              constructor(h) {
                ;((this.workbook = h), (this.worksheet = null))
              }
              async readFile(h, p) {
                if (((p = p || {}), !(await f(h)))) throw new Error('File not found: ' + h)
                const g = s.createReadStream(h),
                  m = await this.read(g, p)
                return (g.close(), m)
              }
              read(h, p) {
                return (
                  (p = p || {}),
                  new Promise((g, m) => {
                    const y = this.workbook.addWorksheet(p.sheetName),
                      b = p.dateFormats || [
                        'YYYY-MM-DD[T]HH:mm:ssZ',
                        'YYYY-MM-DD[T]HH:mm:ss',
                        'MM-DD-YYYY',
                        'YYYY-MM-DD',
                      ],
                      w =
                        p.map ||
                        function (T) {
                          if (T === '') return null
                          const I = Number(T)
                          if (!Number.isNaN(I) && I !== 1 / 0) return I
                          const B = b.reduce((O, P) => {
                            if (O) return O
                            const $ = c(T, P, !0)
                            return $.isValid() ? $ : null
                          }, null)
                          if (B) return new Date(B.valueOf())
                          const E = d[T]
                          return E !== void 0 ? E : T
                        },
                      C = o
                        .parse(p.parserOptions)
                        .on('data', (T) => {
                          y.addRow(T.map(w))
                        })
                        .on('end', () => {
                          C.emit('worksheet', y)
                        })
                    ;(C.on('worksheet', g).on('error', m), h.pipe(C))
                  })
                )
              }
              createInputStream() {
                throw new Error(
                  '`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md',
                )
              }
              write(h, p) {
                return new Promise((g, m) => {
                  p = p || {}
                  const y = this.workbook.getWorksheet(p.sheetName || p.sheetId),
                    b = o.format(p.formatterOptions)
                  ;(h.on('finish', () => {
                    g()
                  }),
                    b.on('error', m),
                    b.pipe(h))
                  const { dateFormat: w, dateUTC: C } = p,
                    T =
                      p.map ||
                      ((E) => {
                        if (E) {
                          if (E.text || E.hyperlink) return E.hyperlink || E.text || ''
                          if (E.formula || E.result) return E.result || ''
                          if (E instanceof Date)
                            return w
                              ? C
                                ? c.utc(E).format(w)
                                : c(E).format(w)
                              : C
                                ? c.utc(E).format()
                                : c(E).format()
                          if (E.error) return E.error
                          if (typeof E == 'object') return JSON.stringify(E)
                        }
                        return E
                      }),
                    I = p.includeEmptyRows === void 0 || p.includeEmptyRows
                  let B = 1
                  ;(y &&
                    y.eachRow((E, O) => {
                      if (I) for (; B++ < O - 1; ) b.write([])
                      const { values: P } = E
                      ;(P.shift(), b.write(P.map(T)), (B = O))
                    }),
                    b.end())
                })
              }
              writeFile(h, p) {
                const g = { encoding: (p = p || {}).encoding || 'utf8' },
                  m = s.createWriteStream(h, g)
                return this.write(m, p)
              }
              async writeBuffer(h) {
                const p = new u()
                return (await this.write(p, h), p.read())
              }
            }
          },
          {
            '../utils/stream-buf': 24,
            '../utils/utils': 27,
            dayjs: 391,
            'dayjs/plugin/customParseFormat': 392,
            'dayjs/plugin/utc': 393,
            'fast-csv': 424,
            fs: 216,
          },
        ],
        2: [
          function (t, r, i) {
            const s = t('../utils/col-cache')
            class o {
              constructor(l, c) {
                let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0
                if (((this.worksheet = l), c))
                  if (typeof c == 'string') {
                    const f = s.decodeAddress(c)
                    ;((this.nativeCol = f.col + u),
                      (this.nativeColOff = 0),
                      (this.nativeRow = f.row + u),
                      (this.nativeRowOff = 0))
                  } else
                    c.nativeCol !== void 0
                      ? ((this.nativeCol = c.nativeCol || 0),
                        (this.nativeColOff = c.nativeColOff || 0),
                        (this.nativeRow = c.nativeRow || 0),
                        (this.nativeRowOff = c.nativeRowOff || 0))
                      : c.col !== void 0
                        ? ((this.col = c.col + u), (this.row = c.row + u))
                        : ((this.nativeCol = 0),
                          (this.nativeColOff = 0),
                          (this.nativeRow = 0),
                          (this.nativeRowOff = 0))
                else
                  ((this.nativeCol = 0),
                    (this.nativeColOff = 0),
                    (this.nativeRow = 0),
                    (this.nativeRowOff = 0))
              }
              static asInstance(l) {
                return l instanceof o || l == null ? l : new o(l)
              }
              get col() {
                return (
                  this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth
                )
              }
              set col(l) {
                ;((this.nativeCol = Math.floor(l)),
                  (this.nativeColOff = Math.floor((l - this.nativeCol) * this.colWidth)))
              }
              get row() {
                return (
                  this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight
                )
              }
              set row(l) {
                ;((this.nativeRow = Math.floor(l)),
                  (this.nativeRowOff = Math.floor((l - this.nativeRow) * this.rowHeight)))
              }
              get colWidth() {
                return this.worksheet &&
                  this.worksheet.getColumn(this.nativeCol + 1) &&
                  this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth
                  ? Math.floor(1e4 * this.worksheet.getColumn(this.nativeCol + 1).width)
                  : 64e4
              }
              get rowHeight() {
                return this.worksheet &&
                  this.worksheet.getRow(this.nativeRow + 1) &&
                  this.worksheet.getRow(this.nativeRow + 1).height
                  ? Math.floor(1e4 * this.worksheet.getRow(this.nativeRow + 1).height)
                  : 18e4
              }
              get model() {
                return {
                  nativeCol: this.nativeCol,
                  nativeColOff: this.nativeColOff,
                  nativeRow: this.nativeRow,
                  nativeRowOff: this.nativeRowOff,
                }
              }
              set model(l) {
                ;((this.nativeCol = l.nativeCol),
                  (this.nativeColOff = l.nativeColOff),
                  (this.nativeRow = l.nativeRow),
                  (this.nativeRowOff = l.nativeRowOff))
              }
            }
            r.exports = o
          },
          { '../utils/col-cache': 19 },
        ],
        3: [
          function (t, r, i) {
            const s = t('../utils/col-cache'),
              o = t('../utils/under-dash'),
              a = t('./enums'),
              { slideFormula: l } = t('../utils/shared-formula'),
              c = t('./note')
            class u {
              constructor(h, p, g) {
                if (!h || !p) throw new Error('A Cell needs a Row')
                ;((this._row = h),
                  (this._column = p),
                  s.validateAddress(g),
                  (this._address = g),
                  (this._value = f.create(u.Types.Null, this)),
                  (this.style = this._mergeStyle(h.style, p.style, {})),
                  (this._mergeCount = 0))
              }
              get worksheet() {
                return this._row.worksheet
              }
              get workbook() {
                return this._row.worksheet.workbook
              }
              destroy() {
                ;(delete this.style,
                  delete this._value,
                  delete this._row,
                  delete this._column,
                  delete this._address)
              }
              get numFmt() {
                return this.style.numFmt
              }
              set numFmt(h) {
                this.style.numFmt = h
              }
              get font() {
                return this.style.font
              }
              set font(h) {
                this.style.font = h
              }
              get alignment() {
                return this.style.alignment
              }
              set alignment(h) {
                this.style.alignment = h
              }
              get border() {
                return this.style.border
              }
              set border(h) {
                this.style.border = h
              }
              get fill() {
                return this.style.fill
              }
              set fill(h) {
                this.style.fill = h
              }
              get protection() {
                return this.style.protection
              }
              set protection(h) {
                this.style.protection = h
              }
              _mergeStyle(h, p, g) {
                const m = (h && h.numFmt) || (p && p.numFmt)
                m && (g.numFmt = m)
                const y = (h && h.font) || (p && p.font)
                y && (g.font = y)
                const b = (h && h.alignment) || (p && p.alignment)
                b && (g.alignment = b)
                const w = (h && h.border) || (p && p.border)
                w && (g.border = w)
                const C = (h && h.fill) || (p && p.fill)
                C && (g.fill = C)
                const T = (h && h.protection) || (p && p.protection)
                return (T && (g.protection = T), g)
              }
              get address() {
                return this._address
              }
              get row() {
                return this._row.number
              }
              get col() {
                return this._column.number
              }
              get $col$row() {
                return `$${this._column.letter}$${this.row}`
              }
              get type() {
                return this._value.type
              }
              get effectiveType() {
                return this._value.effectiveType
              }
              toCsvString() {
                return this._value.toCsvString()
              }
              addMergeRef() {
                this._mergeCount++
              }
              releaseMergeRef() {
                this._mergeCount--
              }
              get isMerged() {
                return this._mergeCount > 0 || this.type === u.Types.Merge
              }
              merge(h, p) {
                ;(this._value.release(),
                  (this._value = f.create(u.Types.Merge, this, h)),
                  p || (this.style = h.style))
              }
              unmerge() {
                this.type === u.Types.Merge &&
                  (this._value.release(),
                  (this._value = f.create(u.Types.Null, this)),
                  (this.style = this._mergeStyle(this._row.style, this._column.style, {})))
              }
              isMergedTo(h) {
                return this._value.type === u.Types.Merge && this._value.isMergedTo(h)
              }
              get master() {
                return this.type === u.Types.Merge ? this._value.master : this
              }
              get isHyperlink() {
                return this._value.type === u.Types.Hyperlink
              }
              get hyperlink() {
                return this._value.hyperlink
              }
              get value() {
                return this._value.value
              }
              set value(h) {
                this.type !== u.Types.Merge
                  ? (this._value.release(), (this._value = f.create(f.getType(h), this, h)))
                  : (this._value.master.value = h)
              }
              get note() {
                return this._comment && this._comment.note
              }
              set note(h) {
                this._comment = new c(h)
              }
              get text() {
                return this._value.toString()
              }
              get html() {
                return o.escapeHtml(this.text)
              }
              toString() {
                return this.text
              }
              _upgradeToHyperlink(h) {
                this.type === u.Types.String &&
                  (this._value = f.create(u.Types.Hyperlink, this, {
                    text: this._value.value,
                    hyperlink: h,
                  }))
              }
              get formula() {
                return this._value.formula
              }
              get result() {
                return this._value.result
              }
              get formulaType() {
                return this._value.formulaType
              }
              get fullAddress() {
                const { worksheet: h } = this._row
                return { sheetName: h.name, address: this.address, row: this.row, col: this.col }
              }
              get name() {
                return this.names[0]
              }
              set name(h) {
                this.names = [h]
              }
              get names() {
                return this.workbook.definedNames.getNamesEx(this.fullAddress)
              }
              set names(h) {
                const { definedNames: p } = this.workbook
                ;(p.removeAllNames(this.fullAddress),
                  h.forEach((g) => {
                    p.addEx(this.fullAddress, g)
                  }))
              }
              addName(h) {
                this.workbook.definedNames.addEx(this.fullAddress, h)
              }
              removeName(h) {
                this.workbook.definedNames.removeEx(this.fullAddress, h)
              }
              removeAllNames() {
                this.workbook.definedNames.removeAllNames(this.fullAddress)
              }
              get _dataValidations() {
                return this.worksheet.dataValidations
              }
              get dataValidation() {
                return this._dataValidations.find(this.address)
              }
              set dataValidation(h) {
                this._dataValidations.add(this.address, h)
              }
              get model() {
                const { model: h } = this._value
                return (
                  (h.style = this.style),
                  this._comment && (h.comment = this._comment.model),
                  h
                )
              }
              set model(h) {
                if (
                  (this._value.release(),
                  (this._value = f.create(h.type, this)),
                  (this._value.model = h),
                  h.comment)
                )
                  switch (h.comment.type) {
                    case 'note':
                      this._comment = c.fromModel(h.comment)
                  }
                h.style ? (this.style = h.style) : (this.style = {})
              }
            }
            u.Types = a.ValueType
            const f = {
              getType: (d) =>
                d == null
                  ? u.Types.Null
                  : d instanceof String || typeof d == 'string'
                    ? u.Types.String
                    : typeof d == 'number'
                      ? u.Types.Number
                      : typeof d == 'boolean'
                        ? u.Types.Boolean
                        : d instanceof Date
                          ? u.Types.Date
                          : d.text && d.hyperlink
                            ? u.Types.Hyperlink
                            : d.formula || d.sharedFormula
                              ? u.Types.Formula
                              : d.richText
                                ? u.Types.RichText
                                : d.sharedString
                                  ? u.Types.SharedString
                                  : d.error
                                    ? u.Types.Error
                                    : u.Types.JSON,
              types: [
                {
                  t: u.Types.Null,
                  f: class {
                    constructor(d) {
                      this.model = { address: d.address, type: u.Types.Null }
                    }
                    get value() {
                      return null
                    }
                    set value(d) {}
                    get type() {
                      return u.Types.Null
                    }
                    get effectiveType() {
                      return u.Types.Null
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return ''
                    }
                    release() {}
                    toString() {
                      return ''
                    }
                  },
                },
                {
                  t: u.Types.Number,
                  f: class {
                    constructor(d, h) {
                      this.model = { address: d.address, type: u.Types.Number, value: h }
                    }
                    get value() {
                      return this.model.value
                    }
                    set value(d) {
                      this.model.value = d
                    }
                    get type() {
                      return u.Types.Number
                    }
                    get effectiveType() {
                      return u.Types.Number
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return this.model.value.toString()
                    }
                    release() {}
                    toString() {
                      return this.model.value.toString()
                    }
                  },
                },
                {
                  t: u.Types.String,
                  f: class {
                    constructor(d, h) {
                      this.model = { address: d.address, type: u.Types.String, value: h }
                    }
                    get value() {
                      return this.model.value
                    }
                    set value(d) {
                      this.model.value = d
                    }
                    get type() {
                      return u.Types.String
                    }
                    get effectiveType() {
                      return u.Types.String
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return `"${this.model.value.replace(/"/g, '""')}"`
                    }
                    release() {}
                    toString() {
                      return this.model.value
                    }
                  },
                },
                {
                  t: u.Types.Date,
                  f: class {
                    constructor(d, h) {
                      this.model = { address: d.address, type: u.Types.Date, value: h }
                    }
                    get value() {
                      return this.model.value
                    }
                    set value(d) {
                      this.model.value = d
                    }
                    get type() {
                      return u.Types.Date
                    }
                    get effectiveType() {
                      return u.Types.Date
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return this.model.value.toISOString()
                    }
                    release() {}
                    toString() {
                      return this.model.value.toString()
                    }
                  },
                },
                {
                  t: u.Types.Hyperlink,
                  f: class {
                    constructor(d, h) {
                      ;((this.model = {
                        address: d.address,
                        type: u.Types.Hyperlink,
                        text: h ? h.text : void 0,
                        hyperlink: h ? h.hyperlink : void 0,
                      }),
                        h && h.tooltip && (this.model.tooltip = h.tooltip))
                    }
                    get value() {
                      const d = { text: this.model.text, hyperlink: this.model.hyperlink }
                      return (this.model.tooltip && (d.tooltip = this.model.tooltip), d)
                    }
                    set value(d) {
                      ;((this.model = { text: d.text, hyperlink: d.hyperlink }),
                        d.tooltip && (this.model.tooltip = d.tooltip))
                    }
                    get text() {
                      return this.model.text
                    }
                    set text(d) {
                      this.model.text = d
                    }
                    get hyperlink() {
                      return this.model.hyperlink
                    }
                    set hyperlink(d) {
                      this.model.hyperlink = d
                    }
                    get type() {
                      return u.Types.Hyperlink
                    }
                    get effectiveType() {
                      return u.Types.Hyperlink
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return this.model.hyperlink
                    }
                    release() {}
                    toString() {
                      return this.model.text
                    }
                  },
                },
                {
                  t: u.Types.Formula,
                  f: class {
                    constructor(d, h) {
                      ;((this.cell = d),
                        (this.model = {
                          address: d.address,
                          type: u.Types.Formula,
                          shareType: h ? h.shareType : void 0,
                          ref: h ? h.ref : void 0,
                          formula: h ? h.formula : void 0,
                          sharedFormula: h ? h.sharedFormula : void 0,
                          result: h ? h.result : void 0,
                        }))
                    }
                    _copyModel(d) {
                      const h = {},
                        p = (g) => {
                          const m = d[g]
                          m && (h[g] = m)
                        }
                      return (
                        p('formula'),
                        p('result'),
                        p('ref'),
                        p('shareType'),
                        p('sharedFormula'),
                        h
                      )
                    }
                    get value() {
                      return this._copyModel(this.model)
                    }
                    set value(d) {
                      this.model = this._copyModel(d)
                    }
                    validate(d) {
                      switch (f.getType(d)) {
                        case u.Types.Null:
                        case u.Types.String:
                        case u.Types.Number:
                        case u.Types.Date:
                          break
                        case u.Types.Hyperlink:
                        case u.Types.Formula:
                        default:
                          throw new Error('Cannot process that type of result value')
                      }
                    }
                    get dependencies() {
                      return {
                        ranges: this.formula.match(
                          /([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g,
                        ),
                        cells: this.formula
                          .replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, '')
                          .match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g),
                      }
                    }
                    get formula() {
                      return this.model.formula || this._getTranslatedFormula()
                    }
                    set formula(d) {
                      this.model.formula = d
                    }
                    get formulaType() {
                      return this.model.formula
                        ? a.FormulaType.Master
                        : this.model.sharedFormula
                          ? a.FormulaType.Shared
                          : a.FormulaType.None
                    }
                    get result() {
                      return this.model.result
                    }
                    set result(d) {
                      this.model.result = d
                    }
                    get type() {
                      return u.Types.Formula
                    }
                    get effectiveType() {
                      const d = this.model.result
                      return d == null
                        ? a.ValueType.Null
                        : d instanceof String || typeof d == 'string'
                          ? a.ValueType.String
                          : typeof d == 'number'
                            ? a.ValueType.Number
                            : d instanceof Date
                              ? a.ValueType.Date
                              : d.text && d.hyperlink
                                ? a.ValueType.Hyperlink
                                : d.formula
                                  ? a.ValueType.Formula
                                  : a.ValueType.Null
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    _getTranslatedFormula() {
                      if (!this._translatedFormula && this.model.sharedFormula) {
                        const { worksheet: d } = this.cell,
                          h = d.findCell(this.model.sharedFormula)
                        this._translatedFormula = h && l(h.formula, h.address, this.model.address)
                      }
                      return this._translatedFormula
                    }
                    toCsvString() {
                      return '' + (this.model.result || '')
                    }
                    release() {}
                    toString() {
                      return this.model.result ? this.model.result.toString() : ''
                    }
                  },
                },
                {
                  t: u.Types.Merge,
                  f: class {
                    constructor(d, h) {
                      ;((this.model = {
                        address: d.address,
                        type: u.Types.Merge,
                        master: h ? h.address : void 0,
                      }),
                        (this._master = h),
                        h && h.addMergeRef())
                    }
                    get value() {
                      return this._master.value
                    }
                    set value(d) {
                      d instanceof u
                        ? (this._master && this._master.releaseMergeRef(),
                          d.addMergeRef(),
                          (this._master = d))
                        : (this._master.value = d)
                    }
                    isMergedTo(d) {
                      return d === this._master
                    }
                    get master() {
                      return this._master
                    }
                    get type() {
                      return u.Types.Merge
                    }
                    get effectiveType() {
                      return this._master.effectiveType
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return ''
                    }
                    release() {
                      this._master.releaseMergeRef()
                    }
                    toString() {
                      return this.value.toString()
                    }
                  },
                },
                {
                  t: u.Types.JSON,
                  f: class {
                    constructor(d, h) {
                      this.model = {
                        address: d.address,
                        type: u.Types.String,
                        value: JSON.stringify(h),
                        rawValue: h,
                      }
                    }
                    get value() {
                      return this.model.rawValue
                    }
                    set value(d) {
                      ;((this.model.rawValue = d), (this.model.value = JSON.stringify(d)))
                    }
                    get type() {
                      return u.Types.String
                    }
                    get effectiveType() {
                      return u.Types.String
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return this.model.value
                    }
                    release() {}
                    toString() {
                      return this.model.value
                    }
                  },
                },
                {
                  t: u.Types.SharedString,
                  f: class {
                    constructor(d, h) {
                      this.model = { address: d.address, type: u.Types.SharedString, value: h }
                    }
                    get value() {
                      return this.model.value
                    }
                    set value(d) {
                      this.model.value = d
                    }
                    get type() {
                      return u.Types.SharedString
                    }
                    get effectiveType() {
                      return u.Types.SharedString
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return this.model.value.toString()
                    }
                    release() {}
                    toString() {
                      return this.model.value.toString()
                    }
                  },
                },
                {
                  t: u.Types.RichText,
                  f: class {
                    constructor(d, h) {
                      this.model = { address: d.address, type: u.Types.String, value: h }
                    }
                    get value() {
                      return this.model.value
                    }
                    set value(d) {
                      this.model.value = d
                    }
                    toString() {
                      return this.model.value.richText.map((d) => d.text).join('')
                    }
                    get type() {
                      return u.Types.RichText
                    }
                    get effectiveType() {
                      return u.Types.RichText
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return `"${this.text.replace(/"/g, '""')}"`
                    }
                    release() {}
                  },
                },
                {
                  t: u.Types.Boolean,
                  f: class {
                    constructor(d, h) {
                      this.model = { address: d.address, type: u.Types.Boolean, value: h }
                    }
                    get value() {
                      return this.model.value
                    }
                    set value(d) {
                      this.model.value = d
                    }
                    get type() {
                      return u.Types.Boolean
                    }
                    get effectiveType() {
                      return u.Types.Boolean
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return this.model.value ? 1 : 0
                    }
                    release() {}
                    toString() {
                      return this.model.value.toString()
                    }
                  },
                },
                {
                  t: u.Types.Error,
                  f: class {
                    constructor(d, h) {
                      this.model = { address: d.address, type: u.Types.Error, value: h }
                    }
                    get value() {
                      return this.model.value
                    }
                    set value(d) {
                      this.model.value = d
                    }
                    get type() {
                      return u.Types.Error
                    }
                    get effectiveType() {
                      return u.Types.Error
                    }
                    get address() {
                      return this.model.address
                    }
                    set address(d) {
                      this.model.address = d
                    }
                    toCsvString() {
                      return this.toString()
                    }
                    release() {}
                    toString() {
                      return this.model.value.error.toString()
                    }
                  },
                },
              ].reduce((d, h) => ((d[h.t] = h.f), d), []),
              create(d, h, p) {
                const g = this.types[d]
                if (!g) throw new Error('Could not create Value of type ' + d)
                return new g(h, p)
              },
            }
            r.exports = u
          },
          {
            '../utils/col-cache': 19,
            '../utils/shared-formula': 23,
            '../utils/under-dash': 26,
            './enums': 7,
            './note': 9,
          },
        ],
        4: [
          function (t, r, i) {
            const s = t('../utils/under-dash'),
              o = t('./enums'),
              a = t('../utils/col-cache')
            class l {
              constructor(u, f, d) {
                ;((this._worksheet = u), (this._number = f), d !== !1 && (this.defn = d))
              }
              get number() {
                return this._number
              }
              get worksheet() {
                return this._worksheet
              }
              get letter() {
                return a.n2l(this._number)
              }
              get isCustomWidth() {
                return this.width !== void 0 && this.width !== 9
              }
              get defn() {
                return {
                  header: this._header,
                  key: this.key,
                  width: this.width,
                  style: this.style,
                  hidden: this.hidden,
                  outlineLevel: this.outlineLevel,
                }
              }
              set defn(u) {
                u
                  ? ((this.key = u.key),
                    (this.width = u.width !== void 0 ? u.width : 9),
                    (this.outlineLevel = u.outlineLevel),
                    u.style ? (this.style = u.style) : (this.style = {}),
                    (this.header = u.header),
                    (this._hidden = !!u.hidden))
                  : (delete this._header,
                    delete this._key,
                    delete this.width,
                    (this.style = {}),
                    (this.outlineLevel = 0))
              }
              get headers() {
                return this._header && this._header instanceof Array ? this._header : [this._header]
              }
              get header() {
                return this._header
              }
              set header(u) {
                u !== void 0
                  ? ((this._header = u),
                    this.headers.forEach((f, d) => {
                      this._worksheet.getCell(d + 1, this.number).value = f
                    }))
                  : (this._header = void 0)
              }
              get key() {
                return this._key
              }
              set key(u) {
                ;((this._key && this._worksheet.getColumnKey(this._key)) === this &&
                  this._worksheet.deleteColumnKey(this._key),
                  (this._key = u),
                  u && this._worksheet.setColumnKey(this._key, this))
              }
              get hidden() {
                return !!this._hidden
              }
              set hidden(u) {
                this._hidden = u
              }
              get outlineLevel() {
                return this._outlineLevel || 0
              }
              set outlineLevel(u) {
                this._outlineLevel = u
              }
              get collapsed() {
                return !!(
                  this._outlineLevel &&
                  this._outlineLevel >= this._worksheet.properties.outlineLevelCol
                )
              }
              toString() {
                return JSON.stringify({
                  key: this.key,
                  width: this.width,
                  headers: this.headers.length ? this.headers : void 0,
                })
              }
              equivalentTo(u) {
                return (
                  this.width === u.width &&
                  this.hidden === u.hidden &&
                  this.outlineLevel === u.outlineLevel &&
                  s.isEqual(this.style, u.style)
                )
              }
              get isDefault() {
                if (this.isCustomWidth || this.hidden || this.outlineLevel) return !1
                const u = this.style
                return (
                  !u || !(u.font || u.numFmt || u.alignment || u.border || u.fill || u.protection)
                )
              }
              get headerCount() {
                return this.headers.length
              }
              eachCell(u, f) {
                const d = this.number
                ;(f || ((f = u), (u = null)),
                  this._worksheet.eachRow(u, (h, p) => {
                    f(h.getCell(d), p)
                  }))
              }
              get values() {
                const u = []
                return (
                  this.eachCell((f, d) => {
                    f && f.type !== o.ValueType.Null && (u[d] = f.value)
                  }),
                  u
                )
              }
              set values(u) {
                if (!u) return
                const f = this.number
                let d = 0
                ;(u.hasOwnProperty('0') && (d = 1),
                  u.forEach((h, p) => {
                    this._worksheet.getCell(p + d, f).value = h
                  }))
              }
              _applyStyle(u, f) {
                return (
                  (this.style[u] = f),
                  this.eachCell((d) => {
                    d[u] = f
                  }),
                  f
                )
              }
              get numFmt() {
                return this.style.numFmt
              }
              set numFmt(u) {
                this._applyStyle('numFmt', u)
              }
              get font() {
                return this.style.font
              }
              set font(u) {
                this._applyStyle('font', u)
              }
              get alignment() {
                return this.style.alignment
              }
              set alignment(u) {
                this._applyStyle('alignment', u)
              }
              get protection() {
                return this.style.protection
              }
              set protection(u) {
                this._applyStyle('protection', u)
              }
              get border() {
                return this.style.border
              }
              set border(u) {
                this._applyStyle('border', u)
              }
              get fill() {
                return this.style.fill
              }
              set fill(u) {
                this._applyStyle('fill', u)
              }
              static toModel(u) {
                const f = []
                let d = null
                return (
                  u &&
                    u.forEach((h, p) => {
                      h.isDefault
                        ? d && (d = null)
                        : d && h.equivalentTo(d)
                          ? (d.max = p + 1)
                          : ((d = {
                              min: p + 1,
                              max: p + 1,
                              width: h.width !== void 0 ? h.width : 9,
                              style: h.style,
                              isCustomWidth: h.isCustomWidth,
                              hidden: h.hidden,
                              outlineLevel: h.outlineLevel,
                              collapsed: h.collapsed,
                            }),
                            f.push(d))
                    }),
                  f.length ? f : void 0
                )
              }
              static fromModel(u, f) {
                const d = []
                let h = 1,
                  p = 0
                for (
                  f = (f = f || []).sort(function (g, m) {
                    return g.min - m.min
                  });
                  p < f.length;

                ) {
                  const g = f[p++]
                  for (; h < g.min; ) d.push(new l(u, h++))
                  for (; h <= g.max; ) d.push(new l(u, h++, g))
                }
                return d.length ? d : null
              }
            }
            r.exports = l
          },
          { '../utils/col-cache': 19, '../utils/under-dash': 26, './enums': 7 },
        ],
        5: [
          function (t, r, i) {
            r.exports = class {
              constructor(s) {
                this.model = s || {}
              }
              add(s, o) {
                return (this.model[s] = o)
              }
              find(s) {
                return this.model[s]
              }
              remove(s) {
                this.model[s] = void 0
              }
            }
          },
          {},
        ],
        6: [
          function (t, r, i) {
            const s = t('../utils/under-dash'),
              o = t('../utils/col-cache'),
              a = t('../utils/cell-matrix'),
              l = t('./range'),
              c = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/
            r.exports = class {
              constructor() {
                this.matrixMap = {}
              }
              getMatrix(u) {
                return this.matrixMap[u] || (this.matrixMap[u] = new a())
              }
              add(u, f) {
                const d = o.decodeEx(u)
                this.addEx(d, f)
              }
              addEx(u, f) {
                const d = this.getMatrix(f)
                if (u.top)
                  for (let h = u.left; h <= u.right; h++)
                    for (let p = u.top; p <= u.bottom; p++) {
                      const g = { sheetName: u.sheetName, address: o.n2l(h) + p, row: p, col: h }
                      d.addCellEx(g)
                    }
                else d.addCellEx(u)
              }
              remove(u, f) {
                const d = o.decodeEx(u)
                this.removeEx(d, f)
              }
              removeEx(u, f) {
                this.getMatrix(f).removeCellEx(u)
              }
              removeAllNames(u) {
                s.each(this.matrixMap, (f) => {
                  f.removeCellEx(u)
                })
              }
              forEach(u) {
                s.each(this.matrixMap, (f, d) => {
                  f.forEach((h) => {
                    u(d, h)
                  })
                })
              }
              getNames(u) {
                return this.getNamesEx(o.decodeEx(u))
              }
              getNamesEx(u) {
                return s.map(this.matrixMap, (f, d) => f.findCellEx(u) && d).filter(Boolean)
              }
              _explore(u, f) {
                f.mark = !1
                const { sheetName: d } = f,
                  h = new l(f.row, f.col, f.row, f.col, d)
                let p, g
                function m(b, w) {
                  const C = u.findCellAt(d, b, f.col)
                  return !(!C || !C.mark) && ((h[w] = b), (C.mark = !1), !0)
                }
                for (g = f.row - 1; m(g, 'top'); g--);
                for (g = f.row + 1; m(g, 'bottom'); g++);
                function y(b, w) {
                  const C = []
                  for (g = h.top; g <= h.bottom; g++) {
                    const T = u.findCellAt(d, g, b)
                    if (!T || !T.mark) return !1
                    C.push(T)
                  }
                  h[w] = b
                  for (let T = 0; T < C.length; T++) C[T].mark = !1
                  return !0
                }
                for (p = f.col - 1; y(p, 'left'); p--);
                for (p = f.col + 1; y(p, 'right'); p++);
                return h
              }
              getRanges(u, f) {
                return (f = f || this.matrixMap[u])
                  ? (f.forEach((d) => {
                      d.mark = !0
                    }),
                    {
                      name: u,
                      ranges: f
                        .map((d) => d.mark && this._explore(f, d))
                        .filter(Boolean)
                        .map((d) => d.$shortRange),
                    })
                  : { name: u, ranges: [] }
              }
              normaliseMatrix(u, f) {
                u.forEachInSheet(f, (d, h, p) => {
                  d &&
                    ((d.row === h && d.col === p) ||
                      ((d.row = h), (d.col = p), (d.address = o.n2l(p) + h)))
                })
              }
              spliceRows(u, f, d, h) {
                s.each(this.matrixMap, (p) => {
                  ;(p.spliceRows(u, f, d, h), this.normaliseMatrix(p, u))
                })
              }
              spliceColumns(u, f, d, h) {
                s.each(this.matrixMap, (p) => {
                  ;(p.spliceColumns(u, f, d, h), this.normaliseMatrix(p, u))
                })
              }
              get model() {
                return s
                  .map(this.matrixMap, (u, f) => this.getRanges(f, u))
                  .filter((u) => u.ranges.length)
              }
              set model(u) {
                const f = (this.matrixMap = {})
                u.forEach((d) => {
                  const h = (f[d.name] = new a())
                  d.ranges.forEach((p) => {
                    c.test(p.split('!').pop() || '') && h.addCell(p)
                  })
                })
              }
            }
          },
          {
            '../utils/cell-matrix': 18,
            '../utils/col-cache': 19,
            '../utils/under-dash': 26,
            './range': 10,
          },
        ],
        7: [
          function (t, r, i) {
            r.exports = {
              ValueType: {
                Null: 0,
                Merge: 1,
                Number: 2,
                String: 3,
                Date: 4,
                Hyperlink: 5,
                Formula: 6,
                SharedString: 7,
                RichText: 8,
                Boolean: 9,
                Error: 10,
              },
              FormulaType: { None: 0, Master: 1, Shared: 2 },
              RelationshipType: {
                None: 0,
                OfficeDocument: 1,
                Worksheet: 2,
                CalcChain: 3,
                SharedStrings: 4,
                Styles: 5,
                Theme: 6,
                Hyperlink: 7,
              },
              DocumentType: { Xlsx: 1 },
              ReadingOrder: { LeftToRight: 1, RightToLeft: 2 },
              ErrorValue: {
                NotApplicable: '#N/A',
                Ref: '#REF!',
                Name: '#NAME?',
                DivZero: '#DIV/0!',
                Null: '#NULL!',
                Value: '#VALUE!',
                Num: '#NUM!',
              },
            }
          },
          {},
        ],
        8: [
          function (t, r, i) {
            const s = t('../utils/col-cache'),
              o = t('./anchor')
            r.exports = class {
              constructor(a, l) {
                ;((this.worksheet = a), (this.model = l))
              }
              get model() {
                switch (this.type) {
                  case 'background':
                    return { type: this.type, imageId: this.imageId }
                  case 'image':
                    return {
                      type: this.type,
                      imageId: this.imageId,
                      hyperlinks: this.range.hyperlinks,
                      range: {
                        tl: this.range.tl.model,
                        br: this.range.br && this.range.br.model,
                        ext: this.range.ext,
                        editAs: this.range.editAs,
                      },
                    }
                  default:
                    throw new Error('Invalid Image Type')
                }
              }
              set model(a) {
                let { type: l, imageId: c, range: u, hyperlinks: f } = a
                if (((this.type = l), (this.imageId = c), l === 'image'))
                  if (typeof u == 'string') {
                    const d = s.decode(u)
                    this.range = {
                      tl: new o(this.worksheet, { col: d.left, row: d.top }, -1),
                      br: new o(this.worksheet, { col: d.right, row: d.bottom }, 0),
                      editAs: 'oneCell',
                    }
                  } else
                    this.range = {
                      tl: new o(this.worksheet, u.tl, 0),
                      br: u.br && new o(this.worksheet, u.br, 0),
                      ext: u.ext,
                      editAs: u.editAs,
                      hyperlinks: f || u.hyperlinks,
                    }
              }
            }
          },
          { '../utils/col-cache': 19, './anchor': 2 },
        ],
        9: [
          function (t, r, i) {
            const s = t('../utils/under-dash')
            class o {
              constructor(l) {
                this.note = l
              }
              get model() {
                let l = null
                switch (typeof this.note) {
                  case 'string':
                    l = { type: 'note', note: { texts: [{ text: this.note }] } }
                    break
                  default:
                    l = { type: 'note', note: this.note }
                }
                return s.deepMerge({}, o.DEFAULT_CONFIGS, l)
              }
              set model(l) {
                const { note: c } = l,
                  { texts: u } = c
                u.length === 1 && Object.keys(u[0]).length === 1
                  ? (this.note = u[0].text)
                  : (this.note = c)
              }
              static fromModel(l) {
                const c = new o()
                return ((c.model = l), c)
              }
            }
            ;((o.DEFAULT_CONFIGS = {
              note: {
                margins: { insetmode: 'auto', inset: [0.13, 0.13, 0.25, 0.25] },
                protection: { locked: 'True', lockText: 'True' },
                editAs: 'absolute',
              },
            }),
              (r.exports = o))
          },
          { '../utils/under-dash': 26 },
        ],
        10: [
          function (t, r, i) {
            const s = t('../utils/col-cache')
            class o {
              constructor() {
                this.decode(arguments)
              }
              setTLBR(l, c, u, f, d) {
                if (arguments.length < 4) {
                  const h = s.decodeAddress(l),
                    p = s.decodeAddress(c)
                  ;((this.model = {
                    top: Math.min(h.row, p.row),
                    left: Math.min(h.col, p.col),
                    bottom: Math.max(h.row, p.row),
                    right: Math.max(h.col, p.col),
                    sheetName: u,
                  }),
                    this.setTLBR(h.row, h.col, p.row, p.col, d))
                } else
                  this.model = {
                    top: Math.min(l, u),
                    left: Math.min(c, f),
                    bottom: Math.max(l, u),
                    right: Math.max(c, f),
                    sheetName: d,
                  }
              }
              decode(l) {
                switch (l.length) {
                  case 5:
                    this.setTLBR(l[0], l[1], l[2], l[3], l[4])
                    break
                  case 4:
                    this.setTLBR(l[0], l[1], l[2], l[3])
                    break
                  case 3:
                    this.setTLBR(l[0], l[1], l[2])
                    break
                  case 2:
                    this.setTLBR(l[0], l[1])
                    break
                  case 1: {
                    const c = l[0]
                    if (c instanceof o)
                      this.model = {
                        top: c.model.top,
                        left: c.model.left,
                        bottom: c.model.bottom,
                        right: c.model.right,
                        sheetName: c.sheetName,
                      }
                    else if (c instanceof Array) this.decode(c)
                    else if (c.top && c.left && c.bottom && c.right)
                      this.model = {
                        top: c.top,
                        left: c.left,
                        bottom: c.bottom,
                        right: c.right,
                        sheetName: c.sheetName,
                      }
                    else {
                      const u = s.decodeEx(c)
                      u.top
                        ? (this.model = {
                            top: u.top,
                            left: u.left,
                            bottom: u.bottom,
                            right: u.right,
                            sheetName: u.sheetName,
                          })
                        : (this.model = {
                            top: u.row,
                            left: u.col,
                            bottom: u.row,
                            right: u.col,
                            sheetName: u.sheetName,
                          })
                    }
                    break
                  }
                  case 0:
                    this.model = { top: 0, left: 0, bottom: 0, right: 0 }
                    break
                  default:
                    throw new Error('Invalid number of arguments to _getDimensions() - ' + l.length)
                }
              }
              get top() {
                return this.model.top || 1
              }
              set top(l) {
                this.model.top = l
              }
              get left() {
                return this.model.left || 1
              }
              set left(l) {
                this.model.left = l
              }
              get bottom() {
                return this.model.bottom || 1
              }
              set bottom(l) {
                this.model.bottom = l
              }
              get right() {
                return this.model.right || 1
              }
              set right(l) {
                this.model.right = l
              }
              get sheetName() {
                return this.model.sheetName
              }
              set sheetName(l) {
                this.model.sheetName = l
              }
              get _serialisedSheetName() {
                const { sheetName: l } = this.model
                return l ? (/^[a-zA-Z0-9]*$/.test(l) ? l + '!' : `'${l}'!`) : ''
              }
              expand(l, c, u, f) {
                ;((!this.model.top || l < this.top) && (this.top = l),
                  (!this.model.left || c < this.left) && (this.left = c),
                  (!this.model.bottom || u > this.bottom) && (this.bottom = u),
                  (!this.model.right || f > this.right) && (this.right = f))
              }
              expandRow(l) {
                if (l) {
                  const { dimensions: c, number: u } = l
                  c && this.expand(u, c.min, u, c.max)
                }
              }
              expandToAddress(l) {
                const c = s.decodeEx(l)
                this.expand(c.row, c.col, c.row, c.col)
              }
              get tl() {
                return s.n2l(this.left) + this.top
              }
              get $t$l() {
                return `$${s.n2l(this.left)}$${this.top}`
              }
              get br() {
                return s.n2l(this.right) + this.bottom
              }
              get $b$r() {
                return `$${s.n2l(this.right)}$${this.bottom}`
              }
              get range() {
                return `${this._serialisedSheetName + this.tl}:${this.br}`
              }
              get $range() {
                return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`
              }
              get shortRange() {
                return this.count > 1 ? this.range : this._serialisedSheetName + this.tl
              }
              get $shortRange() {
                return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l
              }
              get count() {
                return (1 + this.bottom - this.top) * (1 + this.right - this.left)
              }
              toString() {
                return this.range
              }
              intersects(l) {
                return (
                  (!l.sheetName || !this.sheetName || l.sheetName === this.sheetName) &&
                  !(l.bottom < this.top) &&
                  !(l.top > this.bottom) &&
                  !(l.right < this.left) &&
                  !(l.left > this.right)
                )
              }
              contains(l) {
                const c = s.decodeEx(l)
                return this.containsEx(c)
              }
              containsEx(l) {
                return (
                  (!l.sheetName || !this.sheetName || l.sheetName === this.sheetName) &&
                  l.row >= this.top &&
                  l.row <= this.bottom &&
                  l.col >= this.left &&
                  l.col <= this.right
                )
              }
              forEachAddress(l) {
                for (let c = this.left; c <= this.right; c++)
                  for (let u = this.top; u <= this.bottom; u++) l(s.encodeAddress(u, c), u, c)
              }
            }
            r.exports = o
          },
          { '../utils/col-cache': 19 },
        ],
        11: [
          function (t, r, i) {
            const s = t('../utils/under-dash'),
              o = t('./enums'),
              a = t('../utils/col-cache'),
              l = t('./cell')
            r.exports = class {
              constructor(c, u) {
                ;((this._worksheet = c),
                  (this._number = u),
                  (this._cells = []),
                  (this.style = {}),
                  (this.outlineLevel = 0))
              }
              get number() {
                return this._number
              }
              get worksheet() {
                return this._worksheet
              }
              commit() {
                this._worksheet._commitRow(this)
              }
              destroy() {
                ;(delete this._worksheet, delete this._cells, delete this.style)
              }
              findCell(c) {
                return this._cells[c - 1]
              }
              getCellEx(c) {
                let u = this._cells[c.col - 1]
                if (!u) {
                  const f = this._worksheet.getColumn(c.col)
                  ;((u = new l(this, f, c.address)), (this._cells[c.col - 1] = u))
                }
                return u
              }
              getCell(c) {
                if (typeof c == 'string') {
                  const u = this._worksheet.getColumnKey(c)
                  c = u ? u.number : a.l2n(c)
                }
                return (
                  this._cells[c - 1] ||
                  this.getCellEx({
                    address: a.encodeAddress(this._number, c),
                    row: this._number,
                    col: c,
                  })
                )
              }
              splice(c, u) {
                const f = c + u
                for (var d = arguments.length, h = new Array(d > 2 ? d - 2 : 0), p = 2; p < d; p++)
                  h[p - 2] = arguments[p]
                const g = h.length - u,
                  m = this._cells.length
                let y, b, w
                if (g < 0)
                  for (y = c + h.length; y <= m; y++)
                    ((w = this._cells[y - 1]),
                      (b = this._cells[y - g - 1]),
                      b
                        ? ((w = this.getCell(y)),
                          (w.value = b.value),
                          (w.style = b.style),
                          (w._comment = b._comment))
                        : w && ((w.value = null), (w.style = {}), (w._comment = void 0)))
                else if (g > 0)
                  for (y = m; y >= f; y--)
                    ((b = this._cells[y - 1]),
                      b
                        ? ((w = this.getCell(y + g)),
                          (w.value = b.value),
                          (w.style = b.style),
                          (w._comment = b._comment))
                        : (this._cells[y + g - 1] = void 0))
                for (y = 0; y < h.length; y++)
                  ((w = this.getCell(c + y)),
                    (w.value = h[y]),
                    (w.style = {}),
                    (w._comment = void 0))
              }
              eachCell(c, u) {
                if ((u || ((u = c), (c = null)), c && c.includeEmpty)) {
                  const f = this._cells.length
                  for (let d = 1; d <= f; d++) u(this.getCell(d), d)
                } else
                  this._cells.forEach((f, d) => {
                    f && f.type !== o.ValueType.Null && u(f, d + 1)
                  })
              }
              addPageBreak(c, u) {
                const f = this._worksheet,
                  d = Math.max(0, c - 1) || 0,
                  h = Math.max(0, u - 1) || 16838,
                  p = { id: this._number, max: h, man: 1 }
                ;(d && (p.min = d), f.rowBreaks.push(p))
              }
              get values() {
                const c = []
                return (
                  this._cells.forEach((u) => {
                    u && u.type !== o.ValueType.Null && (c[u.col] = u.value)
                  }),
                  c
                )
              }
              set values(c) {
                if (((this._cells = []), c))
                  if (c instanceof Array) {
                    let u = 0
                    ;(c.hasOwnProperty('0') && (u = 1),
                      c.forEach((f, d) => {
                        f !== void 0 &&
                          (this.getCellEx({
                            address: a.encodeAddress(this._number, d + u),
                            row: this._number,
                            col: d + u,
                          }).value = f)
                      }))
                  } else
                    this._worksheet.eachColumnKey((u, f) => {
                      c[f] !== void 0 &&
                        (this.getCellEx({
                          address: a.encodeAddress(this._number, u.number),
                          row: this._number,
                          col: u.number,
                        }).value = c[f])
                    })
              }
              get hasValues() {
                return s.some(this._cells, (c) => c && c.type !== o.ValueType.Null)
              }
              get cellCount() {
                return this._cells.length
              }
              get actualCellCount() {
                let c = 0
                return (
                  this.eachCell(() => {
                    c++
                  }),
                  c
                )
              }
              get dimensions() {
                let c = 0,
                  u = 0
                return (
                  this._cells.forEach((f) => {
                    f &&
                      f.type !== o.ValueType.Null &&
                      ((!c || c > f.col) && (c = f.col), u < f.col && (u = f.col))
                  }),
                  c > 0 ? { min: c, max: u } : null
                )
              }
              _applyStyle(c, u) {
                return (
                  (this.style[c] = u),
                  this._cells.forEach((f) => {
                    f && (f[c] = u)
                  }),
                  u
                )
              }
              get numFmt() {
                return this.style.numFmt
              }
              set numFmt(c) {
                this._applyStyle('numFmt', c)
              }
              get font() {
                return this.style.font
              }
              set font(c) {
                this._applyStyle('font', c)
              }
              get alignment() {
                return this.style.alignment
              }
              set alignment(c) {
                this._applyStyle('alignment', c)
              }
              get protection() {
                return this.style.protection
              }
              set protection(c) {
                this._applyStyle('protection', c)
              }
              get border() {
                return this.style.border
              }
              set border(c) {
                this._applyStyle('border', c)
              }
              get fill() {
                return this.style.fill
              }
              set fill(c) {
                this._applyStyle('fill', c)
              }
              get hidden() {
                return !!this._hidden
              }
              set hidden(c) {
                this._hidden = c
              }
              get outlineLevel() {
                return this._outlineLevel || 0
              }
              set outlineLevel(c) {
                this._outlineLevel = c
              }
              get collapsed() {
                return !!(
                  this._outlineLevel &&
                  this._outlineLevel >= this._worksheet.properties.outlineLevelRow
                )
              }
              get model() {
                const c = []
                let u = 0,
                  f = 0
                return (
                  this._cells.forEach((d) => {
                    if (d) {
                      const h = d.model
                      h && ((!u || u > d.col) && (u = d.col), f < d.col && (f = d.col), c.push(h))
                    }
                  }),
                  this.height || c.length
                    ? {
                        cells: c,
                        number: this.number,
                        min: u,
                        max: f,
                        height: this.height,
                        style: this.style,
                        hidden: this.hidden,
                        outlineLevel: this.outlineLevel,
                        collapsed: this.collapsed,
                      }
                    : null
                )
              }
              set model(c) {
                if (c.number !== this._number) throw new Error('Invalid row number in model')
                let u
                ;((this._cells = []),
                  c.cells.forEach((f) => {
                    switch (f.type) {
                      case l.Types.Merge:
                        break
                      default: {
                        let d
                        if (f.address) d = a.decodeAddress(f.address)
                        else if (u) {
                          const { row: h } = u,
                            p = u.col + 1
                          d = {
                            row: h,
                            col: p,
                            address: a.encodeAddress(h, p),
                            $col$row: `$${a.n2l(p)}$${h}`,
                          }
                        }
                        ;((u = d), (this.getCellEx(d).model = f))
                        break
                      }
                    }
                  }),
                  c.height ? (this.height = c.height) : delete this.height,
                  (this.hidden = c.hidden),
                  (this.outlineLevel = c.outlineLevel || 0),
                  (this.style = (c.style && JSON.parse(JSON.stringify(c.style))) || {}))
              }
            }
          },
          { '../utils/col-cache': 19, '../utils/under-dash': 26, './cell': 3, './enums': 7 },
        ],
        12: [
          function (t, r, i) {
            const s = t('../utils/col-cache')
            class o {
              constructor(l, c, u) {
                ;((this.table = l), (this.column = c), (this.index = u))
              }
              _set(l, c) {
                ;(this.table.cacheState(), (this.column[l] = c))
              }
              get name() {
                return this.column.name
              }
              set name(l) {
                this._set('name', l)
              }
              get filterButton() {
                return this.column.filterButton
              }
              set filterButton(l) {
                this.column.filterButton = l
              }
              get style() {
                return this.column.style
              }
              set style(l) {
                this.column.style = l
              }
              get totalsRowLabel() {
                return this.column.totalsRowLabel
              }
              set totalsRowLabel(l) {
                this._set('totalsRowLabel', l)
              }
              get totalsRowFunction() {
                return this.column.totalsRowFunction
              }
              set totalsRowFunction(l) {
                this._set('totalsRowFunction', l)
              }
              get totalsRowResult() {
                return this.column.totalsRowResult
              }
              set totalsRowResult(l) {
                this._set('totalsRowResult', l)
              }
              get totalsRowFormula() {
                return this.column.totalsRowFormula
              }
              set totalsRowFormula(l) {
                this._set('totalsRowFormula', l)
              }
            }
            r.exports = class {
              constructor(a, l) {
                ;((this.worksheet = a), l && ((this.table = l), this.validate(), this.store()))
              }
              getFormula(a) {
                switch (a.totalsRowFunction) {
                  case 'none':
                    return null
                  case 'average':
                    return `SUBTOTAL(101,${this.table.name}[${a.name}])`
                  case 'countNums':
                    return `SUBTOTAL(102,${this.table.name}[${a.name}])`
                  case 'count':
                    return `SUBTOTAL(103,${this.table.name}[${a.name}])`
                  case 'max':
                    return `SUBTOTAL(104,${this.table.name}[${a.name}])`
                  case 'min':
                    return `SUBTOTAL(105,${this.table.name}[${a.name}])`
                  case 'stdDev':
                    return `SUBTOTAL(106,${this.table.name}[${a.name}])`
                  case 'var':
                    return `SUBTOTAL(107,${this.table.name}[${a.name}])`
                  case 'sum':
                    return `SUBTOTAL(109,${this.table.name}[${a.name}])`
                  case 'custom':
                    return a.totalsRowFormula
                  default:
                    throw new Error('Invalid Totals Row Function: ' + a.totalsRowFunction)
                }
              }
              get width() {
                return this.table.columns.length
              }
              get height() {
                return this.table.rows.length
              }
              get filterHeight() {
                return this.height + (this.table.headerRow ? 1 : 0)
              }
              get tableHeight() {
                return this.filterHeight + (this.table.totalsRow ? 1 : 0)
              }
              validate() {
                const { table: a } = this,
                  l = (g, m, y) => {
                    g[m] === void 0 && (g[m] = y)
                  }
                ;(l(a, 'headerRow', !0),
                  l(a, 'totalsRow', !1),
                  l(a, 'style', {}),
                  l(a.style, 'theme', 'TableStyleMedium2'),
                  l(a.style, 'showFirstColumn', !1),
                  l(a.style, 'showLastColumn', !1),
                  l(a.style, 'showRowStripes', !1),
                  l(a.style, 'showColumnStripes', !1))
                const c = (g, m) => {
                  if (!g) throw new Error(m)
                }
                ;(c(a.ref, 'Table must have ref'),
                  c(a.columns, 'Table must have column definitions'),
                  c(a.rows, 'Table must have row definitions'),
                  (a.tl = s.decodeAddress(a.ref)))
                const { row: u, col: f } = a.tl
                ;(c(u > 0, 'Table must be on valid row'), c(f > 0, 'Table must be on valid col'))
                const { width: d, filterHeight: h, tableHeight: p } = this
                ;((a.autoFilterRef = s.encode(u, f, u + h - 1, f + d - 1)),
                  (a.tableRef = s.encode(u, f, u + p - 1, f + d - 1)),
                  a.columns.forEach((g, m) => {
                    ;(c(g.name, `Column ${m} must have a name`),
                      m === 0
                        ? l(g, 'totalsRowLabel', 'Total')
                        : (l(g, 'totalsRowFunction', 'none'),
                          (g.totalsRowFormula = this.getFormula(g))))
                  }))
              }
              store() {
                const a = (h, p) => {
                    p &&
                      Object.keys(p).forEach((g) => {
                        h[g] = p[g]
                      })
                  },
                  { worksheet: l, table: c } = this,
                  { row: u, col: f } = c.tl
                let d = 0
                if (c.headerRow) {
                  const h = l.getRow(u + d++)
                  c.columns.forEach((p, g) => {
                    const { style: m, name: y } = p,
                      b = h.getCell(f + g)
                    ;((b.value = y), a(b, m))
                  })
                }
                if (
                  (c.rows.forEach((h) => {
                    const p = l.getRow(u + d++)
                    h.forEach((g, m) => {
                      const y = p.getCell(f + m)
                      ;((y.value = g), a(y, c.columns[m].style))
                    })
                  }),
                  c.totalsRow)
                ) {
                  const h = l.getRow(u + d++)
                  c.columns.forEach((p, g) => {
                    const m = h.getCell(f + g)
                    if (g === 0) m.value = p.totalsRowLabel
                    else {
                      const y = this.getFormula(p)
                      m.value = y
                        ? { formula: p.totalsRowFormula, result: p.totalsRowResult }
                        : null
                    }
                    a(m, p.style)
                  })
                }
              }
              load(a) {
                const { table: l } = this,
                  { row: c, col: u } = l.tl
                let f = 0
                if (l.headerRow) {
                  const d = a.getRow(c + f++)
                  l.columns.forEach((h, p) => {
                    d.getCell(u + p).value = h.name
                  })
                }
                if (
                  (l.rows.forEach((d) => {
                    const h = a.getRow(c + f++)
                    d.forEach((p, g) => {
                      h.getCell(u + g).value = p
                    })
                  }),
                  l.totalsRow)
                ) {
                  const d = a.getRow(c + f++)
                  l.columns.forEach((h, p) => {
                    const g = d.getCell(u + p)
                    p === 0
                      ? (g.value = h.totalsRowLabel)
                      : this.getFormula(h) &&
                        (g.value = { formula: h.totalsRowFormula, result: h.totalsRowResult })
                  })
                }
              }
              get model() {
                return this.table
              }
              set model(a) {
                this.table = a
              }
              cacheState() {
                this._cache ||
                  (this._cache = {
                    ref: this.ref,
                    width: this.width,
                    tableHeight: this.tableHeight,
                  })
              }
              commit() {
                if (!this._cache) return
                this.validate()
                const a = s.decodeAddress(this._cache.ref)
                if (this.ref !== this._cache.ref)
                  for (let l = 0; l < this._cache.tableHeight; l++) {
                    const c = this.worksheet.getRow(a.row + l)
                    for (let u = 0; u < this._cache.width; u++) c.getCell(a.col + u).value = null
                  }
                else {
                  for (let l = this.tableHeight; l < this._cache.tableHeight; l++) {
                    const c = this.worksheet.getRow(a.row + l)
                    for (let u = 0; u < this._cache.width; u++) c.getCell(a.col + u).value = null
                  }
                  for (let l = 0; l < this.tableHeight; l++) {
                    const c = this.worksheet.getRow(a.row + l)
                    for (let u = this.width; u < this._cache.width; u++)
                      c.getCell(a.col + u).value = null
                  }
                }
                this.store()
              }
              addRow(a, l) {
                ;(this.cacheState(),
                  l === void 0 ? this.table.rows.push(a) : this.table.rows.splice(l, 0, a))
              }
              removeRows(a) {
                let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
                ;(this.cacheState(), this.table.rows.splice(a, l))
              }
              getColumn(a) {
                const l = this.table.columns[a]
                return new o(this, l, a)
              }
              addColumn(a, l, c) {
                ;(this.cacheState(),
                  c === void 0
                    ? (this.table.columns.push(a),
                      this.table.rows.forEach((u, f) => {
                        u.push(l[f])
                      }))
                    : (this.table.columns.splice(c, 0, a),
                      this.table.rows.forEach((u, f) => {
                        u.splice(c, 0, l[f])
                      })))
              }
              removeColumns(a) {
                let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
                ;(this.cacheState(),
                  this.table.columns.splice(a, l),
                  this.table.rows.forEach((c) => {
                    c.splice(a, l)
                  }))
              }
              _assign(a, l, c) {
                ;(this.cacheState(), (a[l] = c))
              }
              get ref() {
                return this.table.ref
              }
              set ref(a) {
                this._assign(this.table, 'ref', a)
              }
              get name() {
                return this.table.name
              }
              set name(a) {
                this.table.name = a
              }
              get displayName() {
                return this.table.displyName || this.table.name
              }
              set displayNamename(a) {
                this.table.displayName = a
              }
              get headerRow() {
                return this.table.headerRow
              }
              set headerRow(a) {
                this._assign(this.table, 'headerRow', a)
              }
              get totalsRow() {
                return this.table.totalsRow
              }
              set totalsRow(a) {
                this._assign(this.table, 'totalsRow', a)
              }
              get theme() {
                return this.table.style.name
              }
              set theme(a) {
                this.table.style.name = a
              }
              get showFirstColumn() {
                return this.table.style.showFirstColumn
              }
              set showFirstColumn(a) {
                this.table.style.showFirstColumn = a
              }
              get showLastColumn() {
                return this.table.style.showLastColumn
              }
              set showLastColumn(a) {
                this.table.style.showLastColumn = a
              }
              get showRowStripes() {
                return this.table.style.showRowStripes
              }
              set showRowStripes(a) {
                this.table.style.showRowStripes = a
              }
              get showColumnStripes() {
                return this.table.style.showColumnStripes
              }
              set showColumnStripes(a) {
                this.table.style.showColumnStripes = a
              }
            }
          },
          { '../utils/col-cache': 19 },
        ],
        13: [
          function (t, r, i) {
            const s = t('./worksheet'),
              o = t('./defined-names'),
              a = t('../xlsx/xlsx'),
              l = t('../csv/csv')
            r.exports = class {
              constructor() {
                ;((this.category = ''),
                  (this.company = ''),
                  (this.created = new Date()),
                  (this.description = ''),
                  (this.keywords = ''),
                  (this.manager = ''),
                  (this.modified = this.created),
                  (this.properties = {}),
                  (this.calcProperties = {}),
                  (this._worksheets = []),
                  (this.subject = ''),
                  (this.title = ''),
                  (this.views = []),
                  (this.media = []),
                  (this._definedNames = new o()))
              }
              get xlsx() {
                return (this._xlsx || (this._xlsx = new a(this)), this._xlsx)
              }
              get csv() {
                return (this._csv || (this._csv = new l(this)), this._csv)
              }
              get nextId() {
                for (let c = 1; c < this._worksheets.length; c++) if (!this._worksheets[c]) return c
                return this._worksheets.length || 1
              }
              addWorksheet(c, u) {
                const f = this.nextId
                u &&
                  (typeof u == 'string'
                    ? (console.trace(
                        'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }',
                      ),
                      (u = { properties: { tabColor: { argb: u } } }))
                    : (u.argb || u.theme || u.indexed) &&
                      (console.trace(
                        'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }',
                      ),
                      (u = { properties: { tabColor: u } })))
                const d = this._worksheets.reduce(
                    (g, m) => ((m && m.orderNo) > g ? m.orderNo : g),
                    0,
                  ),
                  h = Object.assign({}, u, { id: f, name: c, orderNo: d + 1, workbook: this }),
                  p = new s(h)
                return ((this._worksheets[f] = p), p)
              }
              removeWorksheetEx(c) {
                delete this._worksheets[c.id]
              }
              removeWorksheet(c) {
                const u = this.getWorksheet(c)
                u && u.destroy()
              }
              getWorksheet(c) {
                return c === void 0
                  ? this._worksheets.find(Boolean)
                  : typeof c == 'number'
                    ? this._worksheets[c]
                    : typeof c == 'string'
                      ? this._worksheets.find((u) => u && u.name === c)
                      : void 0
              }
              get worksheets() {
                return this._worksheets
                  .slice(1)
                  .sort((c, u) => c.orderNo - u.orderNo)
                  .filter(Boolean)
              }
              eachSheet(c) {
                this.worksheets.forEach((u) => {
                  c(u, u.id)
                })
              }
              get definedNames() {
                return this._definedNames
              }
              clearThemes() {
                this._themes = void 0
              }
              addImage(c) {
                const u = this.media.length
                return (this.media.push(Object.assign({}, c, { type: 'image' })), u)
              }
              getImage(c) {
                return this.media[c]
              }
              get model() {
                return {
                  creator: this.creator || 'Unknown',
                  lastModifiedBy: this.lastModifiedBy || 'Unknown',
                  lastPrinted: this.lastPrinted,
                  created: this.created,
                  modified: this.modified,
                  properties: this.properties,
                  worksheets: this.worksheets.map((c) => c.model),
                  sheets: this.worksheets.map((c) => c.model).filter(Boolean),
                  definedNames: this._definedNames.model,
                  views: this.views,
                  company: this.company,
                  manager: this.manager,
                  title: this.title,
                  subject: this.subject,
                  keywords: this.keywords,
                  category: this.category,
                  description: this.description,
                  language: this.language,
                  revision: this.revision,
                  contentStatus: this.contentStatus,
                  themes: this._themes,
                  media: this.media,
                  calcProperties: this.calcProperties,
                }
              }
              set model(c) {
                ;((this.creator = c.creator),
                  (this.lastModifiedBy = c.lastModifiedBy),
                  (this.lastPrinted = c.lastPrinted),
                  (this.created = c.created),
                  (this.modified = c.modified),
                  (this.company = c.company),
                  (this.manager = c.manager),
                  (this.title = c.title),
                  (this.subject = c.subject),
                  (this.keywords = c.keywords),
                  (this.category = c.category),
                  (this.description = c.description),
                  (this.language = c.language),
                  (this.revision = c.revision),
                  (this.contentStatus = c.contentStatus),
                  (this.properties = c.properties),
                  (this.calcProperties = c.calcProperties),
                  (this._worksheets = []),
                  c.worksheets.forEach((u) => {
                    const { id: f, name: d, state: h } = u,
                      p = c.sheets && c.sheets.findIndex((g) => g.id === f)
                    ;(this._worksheets[f] = new s({
                      id: f,
                      name: d,
                      orderNo: p,
                      state: h,
                      workbook: this,
                    })).model = u
                  }),
                  (this._definedNames.model = c.definedNames),
                  (this.views = c.views),
                  (this._themes = c.themes),
                  (this.media = c.media || []))
              }
            }
          },
          { '../csv/csv': 1, '../xlsx/xlsx': 144, './defined-names': 6, './worksheet': 14 },
        ],
        14: [
          function (t, r, i) {
            const s = t('../utils/under-dash'),
              o = t('../utils/col-cache'),
              a = t('./range'),
              l = t('./row'),
              c = t('./column'),
              u = t('./enums'),
              f = t('./image'),
              d = t('./table'),
              h = t('./data-validations'),
              p = t('../utils/encryptor'),
              { copyStyle: g } = t('../utils/copy-style')
            r.exports = class {
              constructor(m) {
                ;((m = m || {}),
                  (this._workbook = m.workbook),
                  (this.id = m.id),
                  (this.orderNo = m.orderNo),
                  (this.name = m.name),
                  (this.state = m.state || 'visible'),
                  (this._rows = []),
                  (this._columns = null),
                  (this._keys = {}),
                  (this._merges = {}),
                  (this.rowBreaks = []),
                  (this.properties = Object.assign(
                    {},
                    { defaultRowHeight: 15, dyDescent: 55, outlineLevelCol: 0, outlineLevelRow: 0 },
                    m.properties,
                  )),
                  (this.pageSetup = Object.assign(
                    {},
                    {
                      margins: {
                        left: 0.7,
                        right: 0.7,
                        top: 0.75,
                        bottom: 0.75,
                        header: 0.3,
                        footer: 0.3,
                      },
                      orientation: 'portrait',
                      horizontalDpi: 4294967295,
                      verticalDpi: 4294967295,
                      fitToPage: !(
                        !m.pageSetup ||
                        (!m.pageSetup.fitToWidth && !m.pageSetup.fitToHeight) ||
                        m.pageSetup.scale
                      ),
                      pageOrder: 'downThenOver',
                      blackAndWhite: !1,
                      draft: !1,
                      cellComments: 'None',
                      errors: 'displayed',
                      scale: 100,
                      fitToWidth: 1,
                      fitToHeight: 1,
                      paperSize: void 0,
                      showRowColHeaders: !1,
                      showGridLines: !1,
                      firstPageNumber: void 0,
                      horizontalCentered: !1,
                      verticalCentered: !1,
                      rowBreaks: null,
                      colBreaks: null,
                    },
                    m.pageSetup,
                  )),
                  (this.headerFooter = Object.assign(
                    {},
                    {
                      differentFirst: !1,
                      differentOddEven: !1,
                      oddHeader: null,
                      oddFooter: null,
                      evenHeader: null,
                      evenFooter: null,
                      firstHeader: null,
                      firstFooter: null,
                    },
                    m.headerFooter,
                  )),
                  (this.dataValidations = new h()),
                  (this.views = m.views || []),
                  (this.autoFilter = m.autoFilter || null),
                  (this._media = []),
                  (this.sheetProtection = null),
                  (this.tables = {}),
                  (this.conditionalFormattings = []))
              }
              get name() {
                return this._name
              }
              set name(m) {
                if ((m === void 0 && (m = 'sheet' + this.id), this._name !== m)) {
                  if (typeof m != 'string') throw new Error('The name has to be a string.')
                  if (m === '') throw new Error("The name can't be empty.")
                  if (m === 'History')
                    throw new Error('The name "History" is protected. Please use a different name.')
                  if (/[*?:/\\[\]]/.test(m))
                    throw new Error(
                      `Worksheet name ${m} cannot include any of the following characters: * ? : \\ / [ ]`,
                    )
                  if (/(^')|('$)/.test(m))
                    throw new Error(
                      'The first or last character of worksheet name cannot be a single quotation mark: ' +
                        m,
                    )
                  if (
                    (m &&
                      m.length > 31 &&
                      (console.warn(`Worksheet name ${m} exceeds 31 chars. This will be truncated`),
                      (m = m.substring(0, 31))),
                    this._workbook._worksheets.find(
                      (y) => y && y.name.toLowerCase() === m.toLowerCase(),
                    ))
                  )
                    throw new Error('Worksheet name already exists: ' + m)
                  this._name = m
                }
              }
              get workbook() {
                return this._workbook
              }
              destroy() {
                this._workbook.removeWorksheetEx(this)
              }
              get dimensions() {
                const m = new a()
                return (
                  this._rows.forEach((y) => {
                    if (y) {
                      const b = y.dimensions
                      b && m.expand(y.number, b.min, y.number, b.max)
                    }
                  }),
                  m
                )
              }
              get columns() {
                return this._columns
              }
              set columns(m) {
                this._headerRowCount = m.reduce((w, C) => {
                  const T = (C.header ? 1 : C.headers && C.headers.length) || 0
                  return Math.max(w, T)
                }, 0)
                let y = 1
                const b = (this._columns = [])
                m.forEach((w) => {
                  const C = new c(this, y++, !1)
                  ;(b.push(C), (C.defn = w))
                })
              }
              getColumnKey(m) {
                return this._keys[m]
              }
              setColumnKey(m, y) {
                this._keys[m] = y
              }
              deleteColumnKey(m) {
                delete this._keys[m]
              }
              eachColumnKey(m) {
                s.each(this._keys, m)
              }
              getColumn(m) {
                if (typeof m == 'string') {
                  const y = this._keys[m]
                  if (y) return y
                  m = o.l2n(m)
                }
                if ((this._columns || (this._columns = []), m > this._columns.length)) {
                  let y = this._columns.length + 1
                  for (; y <= m; ) this._columns.push(new c(this, y++))
                }
                return this._columns[m - 1]
              }
              spliceColumns(m, y) {
                const b = this._rows.length
                for (var w = arguments.length, C = new Array(w > 2 ? w - 2 : 0), T = 2; T < w; T++)
                  C[T - 2] = arguments[T]
                if (C.length > 0)
                  for (let O = 0; O < b; O++) {
                    const P = [m, y]
                    C.forEach((F) => {
                      P.push(F[O] || null)
                    })
                    const $ = this.getRow(O + 1)
                    $.splice.apply($, P)
                  }
                else
                  this._rows.forEach((O) => {
                    O && O.splice(m, y)
                  })
                const I = C.length - y,
                  B = m + y,
                  E = this._columns.length
                if (I < 0)
                  for (let O = m + C.length; O <= E; O++)
                    this.getColumn(O).defn = this.getColumn(O - I).defn
                else if (I > 0)
                  for (let O = E; O >= B; O--) this.getColumn(O + I).defn = this.getColumn(O).defn
                for (let O = m; O < m + C.length; O++) this.getColumn(O).defn = null
                this.workbook.definedNames.spliceColumns(this.name, m, y, C.length)
              }
              get lastColumn() {
                return this.getColumn(this.columnCount)
              }
              get columnCount() {
                let m = 0
                return (
                  this.eachRow((y) => {
                    m = Math.max(m, y.cellCount)
                  }),
                  m
                )
              }
              get actualColumnCount() {
                const m = []
                let y = 0
                return (
                  this.eachRow((b) => {
                    b.eachCell((w) => {
                      let { col: C } = w
                      m[C] || ((m[C] = !0), y++)
                    })
                  }),
                  y
                )
              }
              _commitRow() {}
              get _lastRowNumber() {
                const m = this._rows
                let y = m.length
                for (; y > 0 && m[y - 1] === void 0; ) y--
                return y
              }
              get _nextRow() {
                return this._lastRowNumber + 1
              }
              get lastRow() {
                if (this._rows.length) return this._rows[this._rows.length - 1]
              }
              findRow(m) {
                return this._rows[m - 1]
              }
              findRows(m, y) {
                return this._rows.slice(m - 1, m - 1 + y)
              }
              get rowCount() {
                return this._lastRowNumber
              }
              get actualRowCount() {
                let m = 0
                return (
                  this.eachRow(() => {
                    m++
                  }),
                  m
                )
              }
              getRow(m) {
                let y = this._rows[m - 1]
                return (y || (y = this._rows[m - 1] = new l(this, m)), y)
              }
              getRows(m, y) {
                if (y < 1) return
                const b = []
                for (let w = m; w < m + y; w++) b.push(this.getRow(w))
                return b
              }
              addRow(m) {
                let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'n'
                const b = this._nextRow,
                  w = this.getRow(b)
                return ((w.values = m), this._setStyleOption(b, y[0] === 'i' ? y : 'n'), w)
              }
              addRows(m) {
                let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'n'
                const b = []
                return (
                  m.forEach((w) => {
                    b.push(this.addRow(w, y))
                  }),
                  b
                )
              }
              insertRow(m, y) {
                let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'n'
                return (this.spliceRows(m, 0, y), this._setStyleOption(m, b), this.getRow(m))
              }
              insertRows(m, y) {
                let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'n'
                if ((this.spliceRows(m, 0, ...y), b !== 'n'))
                  for (let w = 0; w < y.length; w++)
                    b[0] === 'o' && this.findRow(y.length + m + w) !== void 0
                      ? this._copyStyle(y.length + m + w, m + w, b[1] === '+')
                      : b[0] === 'i' &&
                        this.findRow(m - 1) !== void 0 &&
                        this._copyStyle(m - 1, m + w, b[1] === '+')
                return this.getRows(m, y.length)
              }
              _setStyleOption(m) {
                let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'n'
                y[0] === 'o' && this.findRow(m + 1) !== void 0
                  ? this._copyStyle(m + 1, m, y[1] === '+')
                  : y[0] === 'i' &&
                    this.findRow(m - 1) !== void 0 &&
                    this._copyStyle(m - 1, m, y[1] === '+')
              }
              _copyStyle(m, y) {
                let b = arguments.length > 2 && arguments[2] !== void 0 && arguments[2]
                const w = this.getRow(m),
                  C = this.getRow(y)
                ;((C.style = g(w.style)),
                  w.eachCell({ includeEmpty: b }, (T, I) => {
                    C.getCell(I).style = g(T.style)
                  }),
                  (C.height = w.height))
              }
              duplicateRow(m, y) {
                let b = arguments.length > 2 && arguments[2] !== void 0 && arguments[2]
                const w = this._rows[m - 1],
                  C = new Array(y).fill(w.values)
                this.spliceRows(m + 1, b ? 0 : y, ...C)
                for (let T = 0; T < y; T++) {
                  const I = this._rows[m + T]
                  ;((I.style = w.style),
                    (I.height = w.height),
                    w.eachCell({ includeEmpty: !0 }, (B, E) => {
                      I.getCell(E).style = B.style
                    }))
                }
              }
              spliceRows(m, y) {
                const b = m + y
                for (var w = arguments.length, C = new Array(w > 2 ? w - 2 : 0), T = 2; T < w; T++)
                  C[T - 2] = arguments[T]
                const I = C.length,
                  B = I - y,
                  E = this._rows.length
                let O, P
                if (B < 0)
                  for (m === E && (this._rows[E - 1] = void 0), O = b; O <= E; O++)
                    if (((P = this._rows[O - 1]), P)) {
                      const $ = this.getRow(O + B)
                      ;(($.values = P.values),
                        ($.style = P.style),
                        ($.height = P.height),
                        P.eachCell({ includeEmpty: !0 }, (F, M) => {
                          $.getCell(M).style = F.style
                        }),
                        (this._rows[O - 1] = void 0))
                    } else this._rows[O + B - 1] = void 0
                else if (B > 0)
                  for (O = E; O >= b; O--)
                    if (((P = this._rows[O - 1]), P)) {
                      const $ = this.getRow(O + B)
                      ;(($.values = P.values),
                        ($.style = P.style),
                        ($.height = P.height),
                        P.eachCell({ includeEmpty: !0 }, (F, M) => {
                          if (
                            (($.getCell(M).style = F.style),
                            F._value.constructor.name === 'MergeValue')
                          ) {
                            const R = this.getRow(F._row._number + I).getCell(M),
                              k = F._value._master,
                              v = this.getRow(k._row._number + I).getCell(k._column._number)
                            R.merge(v)
                          }
                        }))
                    } else this._rows[O + B - 1] = void 0
                for (O = 0; O < I; O++) {
                  const $ = this.getRow(m + O)
                  ;(($.style = {}), ($.values = C[O]))
                }
                this.workbook.definedNames.spliceRows(this.name, m, y, I)
              }
              eachRow(m, y) {
                if ((y || ((y = m), (m = void 0)), m && m.includeEmpty)) {
                  const b = this._rows.length
                  for (let w = 1; w <= b; w++) y(this.getRow(w), w)
                } else
                  this._rows.forEach((b) => {
                    b && b.hasValues && y(b, b.number)
                  })
              }
              getSheetValues() {
                const m = []
                return (
                  this._rows.forEach((y) => {
                    y && (m[y.number] = y.values)
                  }),
                  m
                )
              }
              findCell(m, y) {
                const b = o.getAddress(m, y),
                  w = this._rows[b.row - 1]
                return w ? w.findCell(b.col) : void 0
              }
              getCell(m, y) {
                const b = o.getAddress(m, y)
                return this.getRow(b.row).getCellEx(b)
              }
              mergeCells() {
                for (var m = arguments.length, y = new Array(m), b = 0; b < m; b++)
                  y[b] = arguments[b]
                const w = new a(y)
                this._mergeCellsInternal(w)
              }
              mergeCellsWithoutStyle() {
                for (var m = arguments.length, y = new Array(m), b = 0; b < m; b++)
                  y[b] = arguments[b]
                const w = new a(y)
                this._mergeCellsInternal(w, !0)
              }
              _mergeCellsInternal(m, y) {
                s.each(this._merges, (w) => {
                  if (w.intersects(m)) throw new Error('Cannot merge already merged cells')
                })
                const b = this.getCell(m.top, m.left)
                for (let w = m.top; w <= m.bottom; w++)
                  for (let C = m.left; C <= m.right; C++)
                    (w > m.top || C > m.left) && this.getCell(w, C).merge(b, y)
                this._merges[b.address] = m
              }
              _unMergeMaster(m) {
                const y = this._merges[m.address]
                if (y) {
                  for (let b = y.top; b <= y.bottom; b++)
                    for (let w = y.left; w <= y.right; w++) this.getCell(b, w).unmerge()
                  delete this._merges[m.address]
                }
              }
              get hasMerges() {
                return s.some(this._merges, Boolean)
              }
              unMergeCells() {
                for (var m = arguments.length, y = new Array(m), b = 0; b < m; b++)
                  y[b] = arguments[b]
                const w = new a(y)
                for (let C = w.top; C <= w.bottom; C++)
                  for (let T = w.left; T <= w.right; T++) {
                    const I = this.findCell(C, T)
                    I &&
                      (I.type === u.ValueType.Merge
                        ? this._unMergeMaster(I.master)
                        : this._merges[I.address] && this._unMergeMaster(I))
                  }
              }
              fillFormula(m, y, b) {
                let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'shared'
                const C = o.decode(m),
                  { top: T, left: I, bottom: B, right: E } = C,
                  O = E - I + 1,
                  P = o.encodeAddress(T, I),
                  $ = w === 'shared'
                let F
                F =
                  typeof b == 'function'
                    ? b
                    : Array.isArray(b)
                      ? Array.isArray(b[0])
                        ? (R, k) => b[R - T][k - I]
                        : (R, k) => b[(R - T) * O + (k - I)]
                      : () => {}
                let M = !0
                for (let R = T; R <= B; R++)
                  for (let k = I; k <= E; k++)
                    M
                      ? ((this.getCell(R, k).value = {
                          shareType: w,
                          formula: y,
                          ref: m,
                          result: F(R, k),
                        }),
                        (M = !1))
                      : (this.getCell(R, k).value = $
                          ? { sharedFormula: P, result: F(R, k) }
                          : F(R, k))
              }
              addImage(m, y) {
                const b = { type: 'image', imageId: m, range: y }
                this._media.push(new f(this, b))
              }
              getImages() {
                return this._media.filter((m) => m.type === 'image')
              }
              addBackgroundImage(m) {
                const y = { type: 'background', imageId: m }
                this._media.push(new f(this, y))
              }
              getBackgroundImageId() {
                const m = this._media.find((y) => y.type === 'background')
                return m && m.imageId
              }
              protect(m, y) {
                return new Promise((b) => {
                  ;((this.sheetProtection = { sheet: !0 }),
                    y &&
                      'spinCount' in y &&
                      (y.spinCount = Number.isFinite(y.spinCount)
                        ? Math.round(Math.max(0, y.spinCount))
                        : 1e5),
                    m &&
                      ((this.sheetProtection.algorithmName = 'SHA-512'),
                      (this.sheetProtection.saltValue = p.randomBytes(16).toString('base64')),
                      (this.sheetProtection.spinCount = y && 'spinCount' in y ? y.spinCount : 1e5),
                      (this.sheetProtection.hashValue = p.convertPasswordToHash(
                        m,
                        'SHA512',
                        this.sheetProtection.saltValue,
                        this.sheetProtection.spinCount,
                      ))),
                    y &&
                      ((this.sheetProtection = Object.assign(this.sheetProtection, y)),
                      !m && 'spinCount' in y && delete this.sheetProtection.spinCount),
                    b())
                })
              }
              unprotect() {
                this.sheetProtection = null
              }
              addTable(m) {
                const y = new d(this, m)
                return ((this.tables[m.name] = y), y)
              }
              getTable(m) {
                return this.tables[m]
              }
              removeTable(m) {
                delete this.tables[m]
              }
              getTables() {
                return Object.values(this.tables)
              }
              addConditionalFormatting(m) {
                this.conditionalFormattings.push(m)
              }
              removeConditionalFormatting(m) {
                typeof m == 'number'
                  ? this.conditionalFormattings.splice(m, 1)
                  : (this.conditionalFormattings =
                      m instanceof Function ? this.conditionalFormattings.filter(m) : [])
              }
              get tabColor() {
                return (
                  console.trace(
                    'worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor',
                  ),
                  this.properties.tabColor
                )
              }
              set tabColor(m) {
                ;(console.trace(
                  'worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor',
                ),
                  (this.properties.tabColor = m))
              }
              get model() {
                const m = {
                  id: this.id,
                  name: this.name,
                  dataValidations: this.dataValidations.model,
                  properties: this.properties,
                  state: this.state,
                  pageSetup: this.pageSetup,
                  headerFooter: this.headerFooter,
                  rowBreaks: this.rowBreaks,
                  views: this.views,
                  autoFilter: this.autoFilter,
                  media: this._media.map((w) => w.model),
                  sheetProtection: this.sheetProtection,
                  tables: Object.values(this.tables).map((w) => w.model),
                  conditionalFormattings: this.conditionalFormattings,
                }
                m.cols = c.toModel(this.columns)
                const y = (m.rows = []),
                  b = (m.dimensions = new a())
                return (
                  this._rows.forEach((w) => {
                    const C = w && w.model
                    C && (b.expand(C.number, C.min, C.number, C.max), y.push(C))
                  }),
                  (m.merges = []),
                  s.each(this._merges, (w) => {
                    m.merges.push(w.range)
                  }),
                  m
                )
              }
              _parseRows(m) {
                ;((this._rows = []),
                  m.rows.forEach((y) => {
                    const b = new l(this, y.number)
                    ;((this._rows[b.number - 1] = b), (b.model = y))
                  }))
              }
              _parseMergeCells(m) {
                s.each(m.mergeCells, (y) => {
                  this.mergeCellsWithoutStyle(y)
                })
              }
              set model(m) {
                ;((this.name = m.name),
                  (this._columns = c.fromModel(this, m.cols)),
                  this._parseRows(m),
                  this._parseMergeCells(m),
                  (this.dataValidations = new h(m.dataValidations)),
                  (this.properties = m.properties),
                  (this.pageSetup = m.pageSetup),
                  (this.headerFooter = m.headerFooter),
                  (this.views = m.views),
                  (this.autoFilter = m.autoFilter),
                  (this._media = m.media.map((y) => new f(this, y))),
                  (this.sheetProtection = m.sheetProtection),
                  (this.tables = m.tables.reduce((y, b) => {
                    const w = new d()
                    return ((w.model = b), (y[b.name] = w), y)
                  }, {})),
                  (this.conditionalFormattings = m.conditionalFormattings))
              }
            }
          },
          {
            '../utils/col-cache': 19,
            '../utils/copy-style': 20,
            '../utils/encryptor': 21,
            '../utils/under-dash': 26,
            './column': 4,
            './data-validations': 5,
            './enums': 7,
            './image': 8,
            './range': 10,
            './row': 11,
            './table': 12,
          },
        ],
        15: [
          function (t, r, i) {
            ;(t('core-js/modules/es.promise'),
              t('core-js/modules/es.promise.finally'),
              t('core-js/modules/es.object.assign'),
              t('core-js/modules/es.object.keys'),
              t('core-js/modules/es.object.values'),
              t('core-js/modules/es.symbol'),
              t('core-js/modules/es.symbol.async-iterator'),
              t('core-js/modules/es.array.iterator'),
              t('core-js/modules/es.array.includes'),
              t('core-js/modules/es.array.find-index'),
              t('core-js/modules/es.array.find'),
              t('core-js/modules/es.string.from-code-point'),
              t('core-js/modules/es.string.includes'),
              t('core-js/modules/es.number.is-nan'),
              t('regenerator-runtime/runtime'))
            const s = { Workbook: t('./doc/workbook') },
              o = t('./doc/enums')
            ;(Object.keys(o).forEach((a) => {
              s[a] = o[a]
            }),
              (r.exports = s))
          },
          {
            './doc/enums': 7,
            './doc/workbook': 13,
            'core-js/modules/es.array.find': 359,
            'core-js/modules/es.array.find-index': 358,
            'core-js/modules/es.array.includes': 360,
            'core-js/modules/es.array.iterator': 361,
            'core-js/modules/es.number.is-nan': 363,
            'core-js/modules/es.object.assign': 364,
            'core-js/modules/es.object.keys': 366,
            'core-js/modules/es.object.values': 367,
            'core-js/modules/es.promise': 372,
            'core-js/modules/es.promise.finally': 371,
            'core-js/modules/es.string.from-code-point': 376,
            'core-js/modules/es.string.includes': 377,
            'core-js/modules/es.symbol': 381,
            'core-js/modules/es.symbol.async-iterator': 378,
            'regenerator-runtime/runtime': 492,
          },
        ],
        16: [
          function (t, r, i) {
            const s = typeof TextDecoder > 'u' ? null : new TextDecoder('utf-8')
            i.bufferToString = function (o) {
              return typeof o == 'string' ? o : s ? s.decode(o) : o.toString()
            }
          },
          {},
        ],
        17: [
          function (t, r, i) {
            const s = typeof TextEncoder > 'u' ? null : new TextEncoder('utf-8'),
              { Buffer: o } = t('buffer')
            i.stringToBuffer = function (a) {
              return typeof a != 'string' ? a : s ? o.from(s.encode(a).buffer) : o.from(a)
            }
          },
          { buffer: 220 },
        ],
        18: [
          function (t, r, i) {
            const s = t('./under-dash'),
              o = t('./col-cache')
            r.exports = class {
              constructor(a) {
                ;((this.template = a), (this.sheets = {}))
              }
              addCell(a) {
                this.addCellEx(o.decodeEx(a))
              }
              getCell(a) {
                return this.findCellEx(o.decodeEx(a), !0)
              }
              findCell(a) {
                return this.findCellEx(o.decodeEx(a), !1)
              }
              findCellAt(a, l, c) {
                const u = this.sheets[a],
                  f = u && u[l]
                return f && f[c]
              }
              addCellEx(a) {
                if (a.top)
                  for (let l = a.top; l <= a.bottom; l++)
                    for (let c = a.left; c <= a.right; c++) this.getCellAt(a.sheetName, l, c)
                else this.findCellEx(a, !0)
              }
              getCellEx(a) {
                return this.findCellEx(a, !0)
              }
              findCellEx(a, l) {
                const c = this.findSheet(a, l),
                  u = this.findSheetRow(c, a, l)
                return this.findRowCell(u, a, l)
              }
              getCellAt(a, l, c) {
                const u = this.sheets[a] || (this.sheets[a] = []),
                  f = u[l] || (u[l] = [])
                return f[c] || (f[c] = { sheetName: a, address: o.n2l(c) + l, row: l, col: c })
              }
              removeCellEx(a) {
                const l = this.findSheet(a)
                if (!l) return
                const c = this.findSheetRow(l, a)
                c && delete c[a.col]
              }
              forEachInSheet(a, l) {
                const c = this.sheets[a]
                c &&
                  c.forEach((u, f) => {
                    u &&
                      u.forEach((d, h) => {
                        d && l(d, f, h)
                      })
                  })
              }
              forEach(a) {
                s.each(this.sheets, (l, c) => {
                  this.forEachInSheet(c, a)
                })
              }
              map(a) {
                const l = []
                return (
                  this.forEach((c) => {
                    l.push(a(c))
                  }),
                  l
                )
              }
              findSheet(a, l) {
                const c = a.sheetName
                return this.sheets[c] ? this.sheets[c] : l ? (this.sheets[c] = []) : void 0
              }
              findSheetRow(a, l, c) {
                const { row: u } = l
                return a && a[u] ? a[u] : c ? (a[u] = []) : void 0
              }
              findRowCell(a, l, c) {
                const { col: u } = l
                return a && a[u]
                  ? a[u]
                  : c
                    ? (a[u] = this.template
                        ? Object.assign(l, JSON.parse(JSON.stringify(this.template)))
                        : l)
                    : void 0
              }
              spliceRows(a, l, c, u) {
                const f = this.sheets[a]
                if (f) {
                  const d = []
                  for (let h = 0; h < u; h++) d.push([])
                  f.splice(l, c, ...d)
                }
              }
              spliceColumns(a, l, c, u) {
                const f = this.sheets[a]
                if (f) {
                  const d = []
                  for (let h = 0; h < u; h++) d.push(null)
                  s.each(f, (h) => {
                    h.splice(l, c, ...d)
                  })
                }
              }
            }
          },
          { './col-cache': 19, './under-dash': 26 },
        ],
        19: [
          function (t, r, i) {
            const s = /^[A-Z]+\d+$/,
              o = {
                _dictionary: [
                  'A',
                  'B',
                  'C',
                  'D',
                  'E',
                  'F',
                  'G',
                  'H',
                  'I',
                  'J',
                  'K',
                  'L',
                  'M',
                  'N',
                  'O',
                  'P',
                  'Q',
                  'R',
                  'S',
                  'T',
                  'U',
                  'V',
                  'W',
                  'X',
                  'Y',
                  'Z',
                ],
                _l2nFill: 0,
                _l2n: {},
                _n2l: [],
                _level: (a) => (a <= 26 ? 1 : a <= 676 ? 2 : 3),
                _fill(a) {
                  let l,
                    c,
                    u,
                    f,
                    d,
                    h = 1
                  if (a >= 4)
                    throw new Error('Out of bounds. Excel supports columns from 1 to 16384')
                  if (this._l2nFill < 1 && a >= 1) {
                    for (; h <= 26; )
                      ((l = this._dictionary[h - 1]), (this._n2l[h] = l), (this._l2n[l] = h), h++)
                    this._l2nFill = 1
                  }
                  if (this._l2nFill < 2 && a >= 2) {
                    for (h = 27; h <= 702; )
                      ((c = h - 27),
                        (u = c % 26),
                        (f = Math.floor(c / 26)),
                        (l = this._dictionary[f] + this._dictionary[u]),
                        (this._n2l[h] = l),
                        (this._l2n[l] = h),
                        h++)
                    this._l2nFill = 2
                  }
                  if (this._l2nFill < 3 && a >= 3) {
                    for (h = 703; h <= 16384; )
                      ((c = h - 703),
                        (u = c % 26),
                        (f = Math.floor(c / 26) % 26),
                        (d = Math.floor(c / 676)),
                        (l = this._dictionary[d] + this._dictionary[f] + this._dictionary[u]),
                        (this._n2l[h] = l),
                        (this._l2n[l] = h),
                        h++)
                    this._l2nFill = 3
                  }
                },
                l2n(a) {
                  if ((this._l2n[a] || this._fill(a.length), !this._l2n[a]))
                    throw new Error('Out of bounds. Invalid column letter: ' + a)
                  return this._l2n[a]
                },
                n2l(a) {
                  if (a < 1 || a > 16384)
                    throw new Error(a + ' is out of bounds. Excel supports columns from 1 to 16384')
                  return (this._n2l[a] || this._fill(this._level(a)), this._n2l[a])
                },
                _hash: {},
                validateAddress(a) {
                  if (!s.test(a)) throw new Error('Invalid Address: ' + a)
                  return !0
                },
                decodeAddress(a) {
                  const l = a.length < 5 && this._hash[a]
                  if (l) return l
                  let c = !1,
                    u = '',
                    f = 0,
                    d = !1,
                    h = '',
                    p = 0
                  for (let m, y = 0; y < a.length; y++)
                    if (((m = a.charCodeAt(y)), !d && m >= 65 && m <= 90))
                      ((c = !0), (u += a[y]), (f = 26 * f + m - 64))
                    else if (m >= 48 && m <= 57) ((d = !0), (h += a[y]), (p = 10 * p + m - 48))
                    else if (d && c && m !== 36) break
                  if (c) {
                    if (f > 16384) throw new Error('Out of bounds. Invalid column letter: ' + u)
                  } else f = void 0
                  d || (p = void 0)
                  const g = { address: (a = u + h), col: f, row: p, $col$row: `$${u}$${h}` }
                  return (
                    f <= 100 && p <= 100 && ((this._hash[a] = g), (this._hash[g.$col$row] = g)),
                    g
                  )
                },
                getAddress(a, l) {
                  if (l) {
                    const c = this.n2l(l) + a
                    return this.decodeAddress(c)
                  }
                  return this.decodeAddress(a)
                },
                decode(a) {
                  const l = a.split(':')
                  if (l.length === 2) {
                    const c = this.decodeAddress(l[0]),
                      u = this.decodeAddress(l[1]),
                      f = {
                        top: Math.min(c.row, u.row),
                        left: Math.min(c.col, u.col),
                        bottom: Math.max(c.row, u.row),
                        right: Math.max(c.col, u.col),
                      }
                    return (
                      (f.tl = this.n2l(f.left) + f.top),
                      (f.br = this.n2l(f.right) + f.bottom),
                      (f.dimensions = `${f.tl}:${f.br}`),
                      f
                    )
                  }
                  return this.decodeAddress(a)
                },
                decodeEx(a) {
                  const l = a.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/),
                    c = l[1] || l[2],
                    u = l[3],
                    f = u.split(':')
                  if (f.length > 1) {
                    let h = this.decodeAddress(f[0]),
                      p = this.decodeAddress(f[1])
                    const g = Math.min(h.row, p.row),
                      m = Math.min(h.col, p.col),
                      y = Math.max(h.row, p.row),
                      b = Math.max(h.col, p.col)
                    return (
                      (h = this.n2l(m) + g),
                      (p = this.n2l(b) + y),
                      {
                        top: g,
                        left: m,
                        bottom: y,
                        right: b,
                        sheetName: c,
                        tl: {
                          address: h,
                          col: m,
                          row: g,
                          $col$row: `$${this.n2l(m)}$${g}`,
                          sheetName: c,
                        },
                        br: {
                          address: p,
                          col: b,
                          row: y,
                          $col$row: `$${this.n2l(b)}$${y}`,
                          sheetName: c,
                        },
                        dimensions: `${h}:${p}`,
                      }
                    )
                  }
                  if (u.startsWith('#')) return c ? { sheetName: c, error: u } : { error: u }
                  const d = this.decodeAddress(u)
                  return c ? { sheetName: c, ...d } : d
                },
                encodeAddress: (a, l) => o.n2l(l) + a,
                encode() {
                  switch (arguments.length) {
                    case 2:
                      return o.encodeAddress(arguments[0], arguments[1])
                    case 4:
                      return `${o.encodeAddress(arguments[0], arguments[1])}:${o.encodeAddress(arguments[2], arguments[3])}`
                    default:
                      throw new Error('Can only encode with 2 or 4 arguments')
                  }
                },
                inRange(a, l) {
                  const [c, u, , f, d] = a,
                    [h, p] = l
                  return h >= c && h <= f && p >= u && p <= d
                },
              }
            r.exports = o
          },
          {},
        ],
        20: [
          function (t, r, i) {
            const s = (a, l) => ({
                ...a,
                ...l.reduce((c, u) => (a[u] && (c[u] = { ...a[u] }), c), {}),
              }),
              o = function (a, l, c) {
                let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : []
                a[c] && (l[c] = s(a[c], u))
              }
            i.copyStyle = (a) => {
              if (!a) return a
              if (((l = a), Object.keys(l).length === 0)) return {}
              var l
              const c = { ...a }
              return (
                o(a, c, 'font', ['color']),
                o(a, c, 'alignment'),
                o(a, c, 'protection'),
                a.border &&
                  (o(a, c, 'border'),
                  o(a.border, c.border, 'top', ['color']),
                  o(a.border, c.border, 'left', ['color']),
                  o(a.border, c.border, 'bottom', ['color']),
                  o(a.border, c.border, 'right', ['color']),
                  o(a.border, c.border, 'diagonal', ['color'])),
                a.fill &&
                  (o(a, c, 'fill', ['fgColor', 'bgColor', 'center']),
                  a.fill.stops && (c.fill.stops = a.fill.stops.map((u) => s(u, ['color'])))),
                c
              )
            }
          },
          {},
        ],
        21: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                const o = t('crypto'),
                  a = {
                    hash(l) {
                      const c = o.createHash(l)
                      for (
                        var u = arguments.length, f = new Array(u > 1 ? u - 1 : 0), d = 1;
                        d < u;
                        d++
                      )
                        f[d - 1] = arguments[d]
                      return (c.update(s.concat(f)), c.digest())
                    },
                    convertPasswordToHash(l, c, u, f) {
                      if (((c = c.toLowerCase()), o.getHashes().indexOf(c) < 0))
                        throw new Error(`Hash algorithm '${c}' not supported!`)
                      const d = s.from(l, 'utf16le')
                      let h = this.hash(c, s.from(u, 'base64'), d)
                      for (let p = 0; p < f; p++) {
                        const g = s.alloc(4)
                        ;(g.writeUInt32LE(p, 0), (h = this.hash(c, h, g)))
                      }
                      return h.toString('base64')
                    },
                    randomBytes: (l) => o.randomBytes(l),
                  }
                r.exports = a
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { buffer: 220, crypto: 390 },
        ],
        22: [
          function (t, r, i) {
            const { SaxesParser: s } = t('saxes'),
              { PassThrough: o } = t('readable-stream'),
              { bufferToString: a } = t('./browser-buffer-decode')
            r.exports = async function* (l) {
              l.pipe && !l[Symbol.asyncIterator] && (l = l.pipe(new o()))
              const c = new s()
              let u
              c.on('error', (d) => {
                u = d
              })
              let f = []
              ;(c.on('opentag', (d) => f.push({ eventType: 'opentag', value: d })),
                c.on('text', (d) => f.push({ eventType: 'text', value: d })),
                c.on('closetag', (d) => f.push({ eventType: 'closetag', value: d })))
              for await (const d of l) {
                if ((c.write(a(d)), u)) throw u
                ;(yield f, (f = []))
              }
            }
          },
          { './browser-buffer-decode': 16, 'readable-stream': 491, saxes: 496 },
        ],
        23: [
          function (t, r, i) {
            const s = t('./col-cache'),
              o = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi,
              a = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i
            r.exports = {
              slideFormula: function (l, c, u) {
                const f = s.decode(c),
                  d = s.decode(u)
                return l.replace(o, (h, p, g, m, y) => {
                  if (y) return h
                  const b = a.exec(m)
                  if (b) {
                    const w = b[1],
                      C = b[2].toUpperCase(),
                      T = b[3],
                      I = b[4]
                    if (C.length > 3 || (C.length === 3 && C > 'XFD')) return h
                    let B = s.l2n(C),
                      E = parseInt(I, 10)
                    return (
                      w || (B += d.col - f.col),
                      T || (E += d.row - f.row),
                      (p || '') + (w || '') + s.n2l(B) + (T || '') + E
                    )
                  }
                  return h
                })
              },
            }
          },
          { './col-cache': 19 },
        ],
        24: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                const a = t('readable-stream'),
                  l = t('./utils'),
                  c = t('./string-buf')
                class u {
                  constructor(m, y) {
                    ;((this._data = m), (this._encoding = y))
                  }
                  get length() {
                    return this.toBuffer().length
                  }
                  copy(m, y, b, w) {
                    return this.toBuffer().copy(m, y, b, w)
                  }
                  toBuffer() {
                    return (
                      this._buffer || (this._buffer = o.from(this._data, this._encoding)),
                      this._buffer
                    )
                  }
                }
                class f {
                  constructor(m) {
                    this._data = m
                  }
                  get length() {
                    return this._data.length
                  }
                  copy(m, y, b, w) {
                    return this._data._buf.copy(m, y, b, w)
                  }
                  toBuffer() {
                    return this._data.toBuffer()
                  }
                }
                class d {
                  constructor(m) {
                    this._data = m
                  }
                  get length() {
                    return this._data.length
                  }
                  copy(m, y, b, w) {
                    this._data.copy(m, y, b, w)
                  }
                  toBuffer() {
                    return this._data
                  }
                }
                class h {
                  constructor(m) {
                    ;((this.size = m),
                      (this.buffer = o.alloc(m)),
                      (this.iRead = 0),
                      (this.iWrite = 0))
                  }
                  toBuffer() {
                    if (this.iRead === 0 && this.iWrite === this.size) return this.buffer
                    const m = o.alloc(this.iWrite - this.iRead)
                    return (this.buffer.copy(m, 0, this.iRead, this.iWrite), m)
                  }
                  get length() {
                    return this.iWrite - this.iRead
                  }
                  get eod() {
                    return this.iRead === this.iWrite
                  }
                  get full() {
                    return this.iWrite === this.size
                  }
                  read(m) {
                    let y
                    return m === 0
                      ? null
                      : m === void 0 || m >= this.length
                        ? ((y = this.toBuffer()), (this.iRead = this.iWrite), y)
                        : ((y = o.alloc(m)),
                          this.buffer.copy(y, 0, this.iRead, m),
                          (this.iRead += m),
                          y)
                  }
                  write(m, y, b) {
                    const w = Math.min(b, this.size - this.iWrite)
                    return (m.copy(this.buffer, this.iWrite, y, y + w), (this.iWrite += w), w)
                  }
                }
                const p = function (g) {
                  ;((g = g || {}),
                    (this.bufSize = g.bufSize || 1048576),
                    (this.buffers = []),
                    (this.batch = g.batch || !1),
                    (this.corked = !1),
                    (this.inPos = 0),
                    (this.outPos = 0),
                    (this.pipes = []),
                    (this.paused = !1),
                    (this.encoding = null))
                }
                ;(l.inherits(p, a.Duplex, {
                  toBuffer() {
                    switch (this.buffers.length) {
                      case 0:
                        return null
                      case 1:
                        return this.buffers[0].toBuffer()
                      default:
                        return o.concat(this.buffers.map((g) => g.toBuffer()))
                    }
                  },
                  _getWritableBuffer() {
                    if (this.buffers.length) {
                      const m = this.buffers[this.buffers.length - 1]
                      if (!m.full) return m
                    }
                    const g = new h(this.bufSize)
                    return (this.buffers.push(g), g)
                  },
                  async _pipe(g) {
                    await Promise.all(
                      this.pipes.map(function (m) {
                        return new Promise((y) => {
                          m.write(g.toBuffer(), () => {
                            y()
                          })
                        })
                      }),
                    )
                  },
                  _writeToBuffers(g) {
                    let m = 0
                    const y = g.length
                    for (; m < y; ) m += this._getWritableBuffer().write(g, m, y - m)
                  },
                  async write(g, m, y) {
                    let b
                    if (
                      (m instanceof Function && ((y = m), (m = 'utf8')),
                      (y = y || l.nop),
                      g instanceof c)
                    )
                      b = new f(g)
                    else if (g instanceof o) b = new d(g)
                    else {
                      if (
                        !(typeof g == 'string' || g instanceof String || g instanceof ArrayBuffer)
                      )
                        throw new Error('Chunk must be one of type String, Buffer or StringBuf.')
                      b = new u(g, m)
                    }
                    if (this.pipes.length)
                      if (this.batch)
                        for (this._writeToBuffers(b); !this.corked && this.buffers.length > 1; )
                          this._pipe(this.buffers.shift())
                      else
                        this.corked
                          ? (this._writeToBuffers(b), s.nextTick(y))
                          : (await this._pipe(b), y())
                    else
                      (this.paused || this.emit('data', b.toBuffer()),
                        this._writeToBuffers(b),
                        this.emit('readable'))
                    return !0
                  },
                  cork() {
                    this.corked = !0
                  },
                  _flush() {
                    if (this.pipes.length)
                      for (; this.buffers.length; ) this._pipe(this.buffers.shift())
                  },
                  uncork() {
                    ;((this.corked = !1), this._flush())
                  },
                  end(g, m, y) {
                    const b = (w) => {
                      w
                        ? y(w)
                        : (this._flush(),
                          this.pipes.forEach((C) => {
                            C.end()
                          }),
                          this.emit('finish'))
                    }
                    g ? this.write(g, m, b) : b()
                  },
                  read(g) {
                    let m
                    if (g) {
                      for (m = []; g && this.buffers.length && !this.buffers[0].eod; ) {
                        const y = this.buffers[0],
                          b = y.read(g)
                        ;((g -= b.length), m.push(b), y.eod && y.full && this.buffers.shift())
                      }
                      return o.concat(m)
                    }
                    return (
                      (m = this.buffers.map((y) => y.toBuffer()).filter(Boolean)),
                      (this.buffers = []),
                      o.concat(m)
                    )
                  },
                  setEncoding(g) {
                    this.encoding = g
                  },
                  pause() {
                    this.paused = !0
                  },
                  resume() {
                    this.paused = !1
                  },
                  isPaused() {
                    return !!this.paused
                  },
                  pipe(g) {
                    ;(this.pipes.push(g), !this.paused && this.buffers.length && this.end())
                  },
                  unpipe(g) {
                    this.pipes = this.pipes.filter((m) => m !== g)
                  },
                  unshift() {
                    throw new Error('Not Implemented')
                  },
                  wrap() {
                    throw new Error('Not Implemented')
                  },
                }),
                  (r.exports = p))
              }).call(this)
            }).call(this, t('_process'), t('buffer').Buffer)
          },
          { './string-buf': 25, './utils': 27, _process: 467, buffer: 220, 'readable-stream': 491 },
        ],
        25: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                r.exports = class {
                  constructor(o) {
                    ;((this._buf = s.alloc((o && o.size) || 16384)),
                      (this._encoding = (o && o.encoding) || 'utf8'),
                      (this._inPos = 0),
                      (this._buffer = void 0))
                  }
                  get length() {
                    return this._inPos
                  }
                  get capacity() {
                    return this._buf.length
                  }
                  get buffer() {
                    return this._buf
                  }
                  toBuffer() {
                    return (
                      this._buffer ||
                        ((this._buffer = s.alloc(this.length)),
                        this._buf.copy(this._buffer, 0, 0, this.length)),
                      this._buffer
                    )
                  }
                  reset(o) {
                    ;((o = o || 0), (this._buffer = void 0), (this._inPos = o))
                  }
                  _grow(o) {
                    let a = 2 * this._buf.length
                    for (; a < o; ) a *= 2
                    const l = s.alloc(a)
                    ;(this._buf.copy(l, 0), (this._buf = l))
                  }
                  addText(o) {
                    this._buffer = void 0
                    let a = this._inPos + this._buf.write(o, this._inPos, this._encoding)
                    for (; a >= this._buf.length - 4; )
                      (this._grow(this._inPos + o.length),
                        (a = this._inPos + this._buf.write(o, this._inPos, this._encoding)))
                    this._inPos = a
                  }
                  addStringBuf(o) {
                    o.length &&
                      ((this._buffer = void 0),
                      this.length + o.length > this.capacity && this._grow(this.length + o.length),
                      o._buf.copy(this._buf, this._inPos, 0, o.length),
                      (this._inPos += o.length))
                  }
                }
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { buffer: 220 },
        ],
        26: [
          function (t, r, i) {
            const { toString: s } = Object.prototype,
              o = /["&<>]/,
              a = {
                each: function (l, c) {
                  l &&
                    (Array.isArray(l)
                      ? l.forEach(c)
                      : Object.keys(l).forEach((u) => {
                          c(l[u], u)
                        }))
                },
                some: function (l, c) {
                  return (
                    !!l && (Array.isArray(l) ? l.some(c) : Object.keys(l).some((u) => c(l[u], u)))
                  )
                },
                every: function (l, c) {
                  return (
                    !l || (Array.isArray(l) ? l.every(c) : Object.keys(l).every((u) => c(l[u], u)))
                  )
                },
                map: function (l, c) {
                  return l
                    ? Array.isArray(l)
                      ? l.map(c)
                      : Object.keys(l).map((u) => c(l[u], u))
                    : []
                },
                keyBy: (l, c) => l.reduce((u, f) => ((u[f[c]] = f), u), {}),
                isEqual: function (l, c) {
                  const u = typeof l,
                    f = typeof c,
                    d = Array.isArray(l),
                    h = Array.isArray(c)
                  let p
                  if (u !== f) return !1
                  switch (typeof l) {
                    case 'object':
                      if (d || h)
                        return (
                          !(!d || !h) &&
                          l.length === c.length &&
                          l.every((g, m) => {
                            const y = c[m]
                            return a.isEqual(g, y)
                          })
                        )
                      if (l === null || c === null) return l === c
                      if (((p = Object.keys(l)), Object.keys(c).length !== p.length)) return !1
                      for (const g of p) if (!c.hasOwnProperty(g)) return !1
                      return a.every(l, (g, m) => {
                        const y = c[m]
                        return a.isEqual(g, y)
                      })
                    default:
                      return l === c
                  }
                },
                escapeHtml(l) {
                  const c = o.exec(l)
                  if (!c) return l
                  let u = '',
                    f = '',
                    d = 0,
                    h = c.index
                  for (; h < l.length; h++) {
                    switch (l.charAt(h)) {
                      case '"':
                        f = '&quot;'
                        break
                      case '&':
                        f = '&amp;'
                        break
                      case "'":
                        f = '&apos;'
                        break
                      case '<':
                        f = '&lt;'
                        break
                      case '>':
                        f = '&gt;'
                        break
                      default:
                        continue
                    }
                    ;(d !== h && (u += l.substring(d, h)), (d = h + 1), (u += f))
                  }
                  return d !== h ? u + l.substring(d, h) : u
                },
                strcmp: (l, c) => (l < c ? -1 : l > c ? 1 : 0),
                isUndefined: (l) => s.call(l) === '[object Undefined]',
                isObject: (l) => s.call(l) === '[object Object]',
                deepMerge() {
                  const l = arguments[0] || {},
                    { length: c } = arguments
                  let u, f, d
                  function h(p, g) {
                    ;((u = l[g]),
                      (d = Array.isArray(p)),
                      a.isObject(p) || d
                        ? (d
                            ? ((d = !1), (f = u && Array.isArray(u) ? u : []))
                            : (f = u && a.isObject(u) ? u : {}),
                          (l[g] = a.deepMerge(f, p)))
                        : a.isUndefined(p) || (l[g] = p))
                  }
                  for (let p = 0; p < c; p++) a.each(arguments[p], h)
                  return l
                },
              }
            r.exports = a
          },
          {},
        ],
        27: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                const a = t('fs'),
                  l = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/,
                  c = {
                    nop() {},
                    promiseImmediate: (u) =>
                      new Promise((f) => {
                        s.setImmediate
                          ? o(() => {
                              f(u)
                            })
                          : setTimeout(() => {
                              f(u)
                            }, 1)
                      }),
                    inherits: function (u, f, d, h) {
                      ;((u.super_ = f),
                        h || ((h = d), (d = null)),
                        d &&
                          Object.keys(d).forEach((g) => {
                            Object.defineProperty(u, g, Object.getOwnPropertyDescriptor(d, g))
                          }))
                      const p = {
                        constructor: { value: u, enumerable: !1, writable: !1, configurable: !0 },
                      }
                      ;(h &&
                        Object.keys(h).forEach((g) => {
                          p[g] = Object.getOwnPropertyDescriptor(h, g)
                        }),
                        (u.prototype = Object.create(f.prototype, p)))
                    },
                    dateToExcel: (u, f) => 25569 + u.getTime() / 864e5 - (f ? 1462 : 0),
                    excelToDate(u, f) {
                      const d = Math.round(24 * (u - 25569 + (f ? 1462 : 0)) * 3600 * 1e3)
                      return new Date(d)
                    },
                    parsePath(u) {
                      const f = u.lastIndexOf('/')
                      return { path: u.substring(0, f), name: u.substring(f + 1) }
                    },
                    getRelsPath(u) {
                      const f = c.parsePath(u)
                      return `${f.path}/_rels/${f.name}.rels`
                    },
                    xmlEncode(u) {
                      const f = l.exec(u)
                      if (!f) return u
                      let d = '',
                        h = '',
                        p = 0,
                        g = f.index
                      for (; g < u.length; g++) {
                        const m = u.charCodeAt(g)
                        switch (m) {
                          case 34:
                            h = '&quot;'
                            break
                          case 38:
                            h = '&amp;'
                            break
                          case 39:
                            h = '&apos;'
                            break
                          case 60:
                            h = '&lt;'
                            break
                          case 62:
                            h = '&gt;'
                            break
                          case 127:
                            h = ''
                            break
                          default:
                            if (m <= 31 && (m <= 8 || (m >= 11 && m !== 13))) {
                              h = ''
                              break
                            }
                            continue
                        }
                        ;(p !== g && (d += u.substring(p, g)), (p = g + 1), h && (d += h))
                      }
                      return p !== g ? d + u.substring(p, g) : d
                    },
                    xmlDecode: (u) =>
                      u.replace(/&([a-z]*);/g, (f) => {
                        switch (f) {
                          case '&lt;':
                            return '<'
                          case '&gt;':
                            return '>'
                          case '&amp;':
                            return '&'
                          case '&apos;':
                            return "'"
                          case '&quot;':
                            return '"'
                          default:
                            return f
                        }
                      }),
                    validInt(u) {
                      const f = parseInt(u, 10)
                      return Number.isNaN(f) ? 0 : f
                    },
                    isDateFmt(u) {
                      return u
                        ? (u = (u = u.replace(/\[[^\]]*]/g, '')).replace(/"[^"]*"/g, '')).match(
                            /[ymdhMsb]+/,
                          ) !== null
                        : !1
                    },
                    fs: {
                      exists: (u) =>
                        new Promise((f) => {
                          a.access(u, a.constants.F_OK, (d) => {
                            f(!d)
                          })
                        }),
                    },
                    toIsoDateString: (u) => u.toIsoString().subsstr(0, 10),
                    parseBoolean: (u) => u === !0 || u === 'true' || u === 1 || u === '1',
                  }
                r.exports = c
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
              t('timers').setImmediate,
            )
          },
          { fs: 216, timers: 523 },
        ],
        28: [
          function (t, r, i) {
            const s = t('./under-dash'),
              o = t('./utils')
            function a(u, f, d) {
              u.push(` ${f}="${o.xmlEncode(d.toString())}"`)
            }
            function l(u, f) {
              if (f) {
                const d = []
                ;(s.each(f, (h, p) => {
                  h !== void 0 && a(d, p, h)
                }),
                  u.push(d.join('')))
              }
            }
            class c {
              constructor() {
                ;((this._xml = []), (this._stack = []), (this._rollbacks = []))
              }
              get tos() {
                return this._stack.length ? this._stack[this._stack.length - 1] : void 0
              }
              get cursor() {
                return this._xml.length
              }
              openXml(f) {
                const d = this._xml
                ;(d.push('<?xml'),
                  l(d, f),
                  d.push(`?>
`))
              }
              openNode(f, d) {
                const h = this.tos,
                  p = this._xml
                ;(h && this.open && p.push('>'),
                  this._stack.push(f),
                  p.push('<'),
                  p.push(f),
                  l(p, d),
                  (this.leaf = !0),
                  (this.open = !0))
              }
              addAttribute(f, d) {
                if (!this.open) throw new Error('Cannot write attributes to node if it is not open')
                d !== void 0 && a(this._xml, f, d)
              }
              addAttributes(f) {
                if (!this.open) throw new Error('Cannot write attributes to node if it is not open')
                l(this._xml, f)
              }
              writeText(f) {
                const d = this._xml
                ;(this.open && (d.push('>'), (this.open = !1)),
                  (this.leaf = !1),
                  d.push(o.xmlEncode(f.toString())))
              }
              writeXml(f) {
                ;(this.open && (this._xml.push('>'), (this.open = !1)),
                  (this.leaf = !1),
                  this._xml.push(f))
              }
              closeNode() {
                const f = this._stack.pop(),
                  d = this._xml
                ;(this.leaf ? d.push('/>') : (d.push('</'), d.push(f), d.push('>')),
                  (this.open = !1),
                  (this.leaf = !1))
              }
              leafNode(f, d, h) {
                ;(this.openNode(f, d), h !== void 0 && this.writeText(h), this.closeNode())
              }
              closeAll() {
                for (; this._stack.length; ) this.closeNode()
              }
              addRollback() {
                return (
                  this._rollbacks.push({
                    xml: this._xml.length,
                    stack: this._stack.length,
                    leaf: this.leaf,
                    open: this.open,
                  }),
                  this.cursor
                )
              }
              commit() {
                this._rollbacks.pop()
              }
              rollback() {
                const f = this._rollbacks.pop()
                ;(this._xml.length > f.xml && this._xml.splice(f.xml, this._xml.length - f.xml),
                  this._stack.length > f.stack &&
                    this._stack.splice(f.stack, this._stack.length - f.stack),
                  (this.leaf = f.leaf),
                  (this.open = f.open))
              }
              get xml() {
                return (this.closeAll(), this._xml.join(''))
              }
            }
            ;((c.StdDocAttributes = { version: '1.0', encoding: 'UTF-8', standalone: 'yes' }),
              (r.exports = c))
          },
          { './under-dash': 26, './utils': 27 },
        ],
        29: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                const o = t('events'),
                  a = t('jszip'),
                  l = t('./stream-buf'),
                  { stringToBuffer: c } = t('./browser-buffer-encode')
                class u extends o.EventEmitter {
                  constructor(d) {
                    ;(super(),
                      (this.options = Object.assign(
                        { type: 'nodebuffer', compression: 'DEFLATE' },
                        d,
                      )),
                      (this.zip = new a()),
                      (this.stream = new l()))
                  }
                  append(d, h) {
                    h.hasOwnProperty('base64') && h.base64
                      ? this.zip.file(h.name, d, { base64: !0 })
                      : (s.browser && typeof d == 'string' && (d = c(d)), this.zip.file(h.name, d))
                  }
                  async finalize() {
                    const d = await this.zip.generateAsync(this.options)
                    ;(this.stream.end(d), this.emit('finish'))
                  }
                  read(d) {
                    return this.stream.read(d)
                  }
                  setEncoding(d) {
                    return this.stream.setEncoding(d)
                  }
                  pause() {
                    return this.stream.pause()
                  }
                  resume() {
                    return this.stream.resume()
                  }
                  isPaused() {
                    return this.stream.isPaused()
                  }
                  pipe(d, h) {
                    return this.stream.pipe(d, h)
                  }
                  unpipe(d) {
                    return this.stream.unpipe(d)
                  }
                  unshift(d) {
                    return this.stream.unshift(d)
                  }
                  wrap(d) {
                    return this.stream.wrap(d)
                  }
                }
                r.exports = { ZipWriter: u }
              }).call(this)
            }).call(this, t('_process'))
          },
          {
            './browser-buffer-encode': 17,
            './stream-buf': 24,
            _process: 467,
            events: 422,
            jszip: 441,
          },
        ],
        30: [
          function (t, r, i) {
            r.exports = {
              0: { f: 'General' },
              1: { f: '0' },
              2: { f: '0.00' },
              3: { f: '#,##0' },
              4: { f: '#,##0.00' },
              9: { f: '0%' },
              10: { f: '0.00%' },
              11: { f: '0.00E+00' },
              12: { f: '# ?/?' },
              13: { f: '# ??/??' },
              14: { f: 'mm-dd-yy' },
              15: { f: 'd-mmm-yy' },
              16: { f: 'd-mmm' },
              17: { f: 'mmm-yy' },
              18: { f: 'h:mm AM/PM' },
              19: { f: 'h:mm:ss AM/PM' },
              20: { f: 'h:mm' },
              21: { f: 'h:mm:ss' },
              22: { f: 'm/d/yy "h":mm' },
              27: {
                'zh-tw': '[$-404]e/m/d',
                'zh-cn': 'yyyy""m""',
                'ja-jp': '[$-411]ge.m.d',
                'ko-kr': 'yyyy"" mm"" dd""',
              },
              28: {
                'zh-tw': '[$-404]e""m""d""',
                'zh-cn': 'm""d""',
                'ja-jp': '[$-411]ggge""m""d""',
                'ko-kr': 'mm-dd',
              },
              29: {
                'zh-tw': '[$-404]e""m""d""',
                'zh-cn': 'm""d""',
                'ja-jp': '[$-411]ggge""m""d""',
                'ko-kr': 'mm-dd',
              },
              30: { 'zh-tw': 'm/d/yy ', 'zh-cn': 'm-d-yy', 'ja-jp': 'm/d/yy', 'ko-kr': 'mm-dd-yy' },
              31: {
                'zh-tw': 'yyyy""m""d""',
                'zh-cn': 'yyyy""m""d""',
                'ja-jp': 'yyyy""m""d""',
                'ko-kr': 'yyyy"" mm"" dd""',
              },
              32: {
                'zh-tw': 'hh""mm""',
                'zh-cn': 'h""mm""',
                'ja-jp': 'h""mm""',
                'ko-kr': 'h"" mm""',
              },
              33: {
                'zh-tw': 'hh""mm""ss""',
                'zh-cn': 'h""mm""ss""',
                'ja-jp': 'h""mm""ss""',
                'ko-kr': 'h"" mm"" ss""',
              },
              34: {
                'zh-tw': '/ hh""mm""',
                'zh-cn': '/ h""mm""',
                'ja-jp': 'yyyy""m""',
                'ko-kr': 'yyyy-mm-dd',
              },
              35: {
                'zh-tw': '/ hh""mm""ss""',
                'zh-cn': '/ h""mm""ss""',
                'ja-jp': 'm""d""',
                'ko-kr': 'yyyy-mm-dd',
              },
              36: {
                'zh-tw': '[$-404]e/m/d',
                'zh-cn': 'yyyy""m""',
                'ja-jp': '[$-411]ge.m.d',
                'ko-kr': 'yyyy"" mm"" dd""',
              },
              37: { f: '#,##0 ;(#,##0)' },
              38: { f: '#,##0 ;[Red](#,##0)' },
              39: { f: '#,##0.00 ;(#,##0.00)' },
              40: { f: '#,##0.00 ;[Red](#,##0.00)' },
              45: { f: 'mm:ss' },
              46: { f: '[h]:mm:ss' },
              47: { f: 'mmss.0' },
              48: { f: '##0.0E+0' },
              49: { f: '@' },
              50: {
                'zh-tw': '[$-404]e/m/d',
                'zh-cn': 'yyyy""m""',
                'ja-jp': '[$-411]ge.m.d',
                'ko-kr': 'yyyy"" mm"" dd""',
              },
              51: {
                'zh-tw': '[$-404]e""m""d""',
                'zh-cn': 'm""d""',
                'ja-jp': '[$-411]ggge""m""d""',
                'ko-kr': 'mm-dd',
              },
              52: {
                'zh-tw': '/ hh""mm""',
                'zh-cn': 'yyyy""m""',
                'ja-jp': 'yyyy""m""',
                'ko-kr': 'yyyy-mm-dd',
              },
              53: {
                'zh-tw': '/ hh""mm""ss""',
                'zh-cn': 'm""d""',
                'ja-jp': 'm""d""',
                'ko-kr': 'yyyy-mm-dd',
              },
              54: {
                'zh-tw': '[$-404]e""m""d""',
                'zh-cn': 'm""d""',
                'ja-jp': '[$-411]ggge""m""d""',
                'ko-kr': 'mm-dd',
              },
              55: {
                'zh-tw': '/ hh""mm""',
                'zh-cn': '/ h""mm""',
                'ja-jp': 'yyyy""m""',
                'ko-kr': 'yyyy-mm-dd',
              },
              56: {
                'zh-tw': '/ hh""mm""ss""',
                'zh-cn': '/ h""mm""ss""',
                'ja-jp': 'm""d""',
                'ko-kr': 'yyyy-mm-dd',
              },
              57: {
                'zh-tw': '[$-404]e/m/d',
                'zh-cn': 'yyyy""m""',
                'ja-jp': '[$-411]ge.m.d',
                'ko-kr': 'yyyy"" mm"" dd""',
              },
              58: {
                'zh-tw': '[$-404]e""m""d""',
                'zh-cn': 'm""d""',
                'ja-jp': '[$-411]ggge""m""d""',
                'ko-kr': 'mm-dd',
              },
              59: { 'th-th': 't0' },
              60: { 'th-th': 't0.00' },
              61: { 'th-th': 't#,##0' },
              62: { 'th-th': 't#,##0.00' },
              67: { 'th-th': 't0%' },
              68: { 'th-th': 't0.00%' },
              69: { 'th-th': 't# ?/?' },
              70: { 'th-th': 't# ??/??' },
              81: { 'th-th': 'd/m/bb' },
            }
          },
          {},
        ],
        31: [
          function (t, r, i) {
            r.exports = {
              OfficeDocument:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
              Worksheet:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
              CalcChain:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain',
              SharedStrings:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
              Styles: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
              Theme: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
              Hyperlink:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
              Image: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
              CoreProperties:
                'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
              ExtenderProperties:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',
              Comments:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',
              VmlDrawing:
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',
              Table: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
            }
          },
          {},
        ],
        32: [
          function (t, r, i) {
            const s = t('../../utils/parse-sax'),
              o = t('../../utils/xml-stream')
            class a {
              prepare() {}
              render() {}
              parseOpen(c) {}
              parseText(c) {}
              parseClose(c) {}
              reconcile(c, u) {}
              reset() {
                ;((this.model = null),
                  this.map &&
                    Object.values(this.map).forEach((c) => {
                      c instanceof a ? c.reset() : c.xform && c.xform.reset()
                    }))
              }
              mergeModel(c) {
                this.model = Object.assign(this.model || {}, c)
              }
              async parse(c) {
                for await (const u of c)
                  for (const { eventType: f, value: d } of u)
                    if (f === 'opentag') this.parseOpen(d)
                    else if (f === 'text') this.parseText(d)
                    else if (f === 'closetag' && !this.parseClose(d.name)) return this.model
                return this.model
              }
              async parseStream(c) {
                return this.parse(s(c))
              }
              get xml() {
                return this.toXml(this.model)
              }
              toXml(c) {
                const u = new o()
                return (this.render(u, c), u.xml)
              }
              static toAttribute(c, u) {
                let f = arguments.length > 2 && arguments[2] !== void 0 && arguments[2]
                if (c === void 0) {
                  if (f) return u
                } else if (f || c !== u) return c.toString()
              }
              static toStringAttribute(c, u) {
                let f = arguments.length > 2 && arguments[2] !== void 0 && arguments[2]
                return a.toAttribute(c, u, f)
              }
              static toStringValue(c, u) {
                return c === void 0 ? u : c
              }
              static toBoolAttribute(c, u) {
                let f = arguments.length > 2 && arguments[2] !== void 0 && arguments[2]
                if (c === void 0) {
                  if (f) return u
                } else if (f || c !== u) return c ? '1' : '0'
              }
              static toBoolValue(c, u) {
                return c === void 0 ? u : c === '1'
              }
              static toIntAttribute(c, u) {
                let f = arguments.length > 2 && arguments[2] !== void 0 && arguments[2]
                return a.toAttribute(c, u, f)
              }
              static toIntValue(c, u) {
                return c === void 0 ? u : parseInt(c, 10)
              }
              static toFloatAttribute(c, u) {
                let f = arguments.length > 2 && arguments[2] !== void 0 && arguments[2]
                return a.toAttribute(c, u, f)
              }
              static toFloatValue(c, u) {
                return c === void 0 ? u : parseFloat(c)
              }
            }
            r.exports = a
          },
          { '../../utils/parse-sax': 22, '../../utils/xml-stream': 28 },
        ],
        33: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('../../../utils/col-cache')
            function a(c) {
              try {
                return (o.decodeEx(c), !0)
              } catch {
                return !1
              }
            }
            function l(c) {
              const u = []
              let f = !1,
                d = ''
              return (
                c.split(',').forEach((h) => {
                  if (!h) return
                  const p = (h.match(/'/g) || []).length
                  if (!p) return void (f ? (d += h + ',') : a(h) && u.push(h))
                  const g = p % 2 == 0
                  !f && g && a(h)
                    ? u.push(h)
                    : f && !g
                      ? ((f = !1), a(d + h) && u.push(d + h), (d = ''))
                      : ((f = !0), (d += h + ','))
                }),
                u
              )
            }
            r.exports = class extends s {
              render(c, u) {
                ;(c.openNode('definedName', { name: u.name, localSheetId: u.localSheetId }),
                  c.writeText(u.ranges.join(',')),
                  c.closeNode())
              }
              parseOpen(c) {
                switch (c.name) {
                  case 'definedName':
                    return (
                      (this._parsedName = c.attributes.name),
                      (this._parsedLocalSheetId = c.attributes.localSheetId),
                      (this._parsedText = []),
                      !0
                    )
                  default:
                    return !1
                }
              }
              parseText(c) {
                this._parsedText.push(c)
              }
              parseClose() {
                return (
                  (this.model = { name: this._parsedName, ranges: l(this._parsedText.join('')) }),
                  this._parsedLocalSheetId !== void 0 &&
                    (this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10)),
                  !1
                )
              }
            }
          },
          { '../../../utils/col-cache': 19, '../base-xform': 32 },
        ],
        34: [
          function (t, r, i) {
            const s = t('../../../utils/utils'),
              o = t('../base-xform')
            r.exports = class extends o {
              render(a, l) {
                a.leafNode('sheet', { sheetId: l.id, name: l.name, state: l.state, 'r:id': l.rId })
              }
              parseOpen(a) {
                return (
                  a.name === 'sheet' &&
                  ((this.model = {
                    name: s.xmlDecode(a.attributes.name),
                    id: parseInt(a.attributes.sheetId, 10),
                    state: a.attributes.state,
                    rId: a.attributes['r:id'],
                  }),
                  !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../../utils/utils': 27, '../base-xform': 32 },
        ],
        35: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              render(o, a) {
                o.leafNode('calcPr', {
                  calcId: 171027,
                  fullCalcOnLoad: a.fullCalcOnLoad ? 1 : void 0,
                })
              }
              parseOpen(o) {
                return o.name === 'calcPr' && ((this.model = {}), !0)
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        36: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              render(o, a) {
                o.leafNode('workbookPr', {
                  date1904: a.date1904 ? 1 : void 0,
                  defaultThemeVersion: 164011,
                  filterPrivacy: 1,
                })
              }
              parseOpen(o) {
                return (
                  o.name === 'workbookPr' &&
                  ((this.model = { date1904: o.attributes.date1904 === '1' }), !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        37: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              render(o, a) {
                const l = {
                  xWindow: a.x || 0,
                  yWindow: a.y || 0,
                  windowWidth: a.width || 12e3,
                  windowHeight: a.height || 24e3,
                  firstSheet: a.firstSheet,
                  activeTab: a.activeTab,
                }
                ;(a.visibility && a.visibility !== 'visible' && (l.visibility = a.visibility),
                  o.leafNode('workbookView', l))
              }
              parseOpen(o) {
                if (o.name === 'workbookView') {
                  const a = (this.model = {}),
                    l = function (u, f, d) {
                      const h = f !== void 0 ? (a[u] = f) : d
                      h !== void 0 && (a[u] = h)
                    },
                    c = function (u, f, d) {
                      const h = f !== void 0 ? (a[u] = parseInt(f, 10)) : d
                      h !== void 0 && (a[u] = h)
                    }
                  return (
                    c('x', o.attributes.xWindow, 0),
                    c('y', o.attributes.yWindow, 0),
                    c('width', o.attributes.windowWidth, 25e3),
                    c('height', o.attributes.windowHeight, 1e4),
                    l('visibility', o.attributes.visibility, 'visible'),
                    c('activeTab', o.attributes.activeTab, void 0),
                    c('firstSheet', o.attributes.firstSheet, void 0),
                    !0
                  )
                }
                return !1
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        38: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../../../utils/col-cache'),
              a = t('../../../utils/xml-stream'),
              l = t('../base-xform'),
              c = t('../static-xform'),
              u = t('../list-xform'),
              f = t('./defined-name-xform'),
              d = t('./sheet-xform'),
              h = t('./workbook-view-xform'),
              p = t('./workbook-properties-xform'),
              g = t('./workbook-calc-properties-xform')
            class m extends l {
              constructor() {
                ;(super(),
                  (this.map = {
                    fileVersion: m.STATIC_XFORMS.fileVersion,
                    workbookPr: new p(),
                    bookViews: new u({ tag: 'bookViews', count: !1, childXform: new h() }),
                    sheets: new u({ tag: 'sheets', count: !1, childXform: new d() }),
                    definedNames: new u({ tag: 'definedNames', count: !1, childXform: new f() }),
                    calcPr: new g(),
                  }))
              }
              prepare(b) {
                b.sheets = b.worksheets
                const w = []
                let C = 0
                ;(b.sheets.forEach((T) => {
                  if (
                    (T.pageSetup &&
                      T.pageSetup.printArea &&
                      T.pageSetup.printArea.split('&&').forEach((I) => {
                        const B = I.split(':'),
                          E = {
                            name: '_xlnm.Print_Area',
                            ranges: [`'${T.name}'!$${B[0]}:$${B[1]}`],
                            localSheetId: C,
                          }
                        w.push(E)
                      }),
                    T.pageSetup && (T.pageSetup.printTitlesRow || T.pageSetup.printTitlesColumn))
                  ) {
                    const I = []
                    if (T.pageSetup.printTitlesColumn) {
                      const E = T.pageSetup.printTitlesColumn.split(':')
                      I.push(`'${T.name}'!$${E[0]}:$${E[1]}`)
                    }
                    if (T.pageSetup.printTitlesRow) {
                      const E = T.pageSetup.printTitlesRow.split(':')
                      I.push(`'${T.name}'!$${E[0]}:$${E[1]}`)
                    }
                    const B = { name: '_xlnm.Print_Titles', ranges: I, localSheetId: C }
                    w.push(B)
                  }
                  C++
                }),
                  w.length && (b.definedNames = b.definedNames.concat(w)),
                  (b.media || []).forEach((T, I) => {
                    T.name = T.type + (I + 1)
                  }))
              }
              render(b, w) {
                ;(b.openXml(a.StdDocAttributes),
                  b.openNode('workbook', m.WORKBOOK_ATTRIBUTES),
                  this.map.fileVersion.render(b),
                  this.map.workbookPr.render(b, w.properties),
                  this.map.bookViews.render(b, w.views),
                  this.map.sheets.render(b, w.sheets),
                  this.map.definedNames.render(b, w.definedNames),
                  this.map.calcPr.render(b, w.calcProperties),
                  b.closeNode())
              }
              parseOpen(b) {
                if (this.parser) return (this.parser.parseOpen(b), !0)
                switch (b.name) {
                  case 'workbook':
                    return !0
                  default:
                    return (
                      (this.parser = this.map[b.name]),
                      this.parser && this.parser.parseOpen(b),
                      !0
                    )
                }
              }
              parseText(b) {
                this.parser && this.parser.parseText(b)
              }
              parseClose(b) {
                if (this.parser) return (this.parser.parseClose(b) || (this.parser = void 0), !0)
                switch (b) {
                  case 'workbook':
                    return (
                      (this.model = {
                        sheets: this.map.sheets.model,
                        properties: this.map.workbookPr.model || {},
                        views: this.map.bookViews.model,
                        calcProperties: {},
                      }),
                      this.map.definedNames.model &&
                        (this.model.definedNames = this.map.definedNames.model),
                      !1
                    )
                  default:
                    return !0
                }
              }
              reconcile(b) {
                const w = (b.workbookRels || []).reduce((E, O) => ((E[O.Id] = O), E), {}),
                  C = []
                let T,
                  I = 0
                ;(b.sheets || []).forEach((E) => {
                  const O = w[E.rId]
                  O &&
                    ((T = b.worksheetHash['xl/' + O.Target.replace(/^(\s|\/xl\/)+/, '')]),
                    T && ((T.name = E.name), (T.id = E.id), (T.state = E.state), (C[I++] = T)))
                })
                const B = []
                ;(s.each(b.definedNames, (E) => {
                  if (E.name === '_xlnm.Print_Area') {
                    if (((T = C[E.localSheetId]), T)) {
                      T.pageSetup || (T.pageSetup = {})
                      const O = o.decodeEx(E.ranges[0])
                      T.pageSetup.printArea = T.pageSetup.printArea
                        ? `${T.pageSetup.printArea}&&${O.dimensions}`
                        : O.dimensions
                    }
                  } else if (E.name === '_xlnm.Print_Titles') {
                    if (((T = C[E.localSheetId]), T)) {
                      T.pageSetup || (T.pageSetup = {})
                      const O = E.ranges.join(','),
                        P = /\$/g,
                        $ = /\$\d+:\$\d+/,
                        F = O.match($)
                      if (F && F.length) {
                        const k = F[0]
                        T.pageSetup.printTitlesRow = k.replace(P, '')
                      }
                      const M = /\$[A-Z]+:\$[A-Z]+/,
                        R = O.match(M)
                      if (R && R.length) {
                        const k = R[0]
                        T.pageSetup.printTitlesColumn = k.replace(P, '')
                      }
                    }
                  } else B.push(E)
                }),
                  (b.definedNames = B),
                  b.media.forEach((E, O) => {
                    E.index = O
                  }))
              }
            }
            ;((m.WORKBOOK_ATTRIBUTES = {
              xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
              'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
              'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
              'mc:Ignorable': 'x15',
              'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',
            }),
              (m.STATIC_XFORMS = {
                fileVersion: new c({
                  tag: 'fileVersion',
                  $: { appName: 'xl', lastEdited: 5, lowestEdited: 5, rupBuild: 9303 },
                }),
              }),
              (r.exports = m))
          },
          {
            '../../../utils/col-cache': 19,
            '../../../utils/under-dash': 26,
            '../../../utils/xml-stream': 28,
            '../base-xform': 32,
            '../list-xform': 71,
            '../static-xform': 120,
            './defined-name-xform': 33,
            './sheet-xform': 34,
            './workbook-calc-properties-xform': 35,
            './workbook-properties-xform': 36,
            './workbook-view-xform': 37,
          },
        ],
        39: [
          function (t, r, i) {
            const s = t('../strings/rich-text-xform'),
              o = t('../../../utils/utils'),
              a = t('../base-xform'),
              l = (r.exports = function (c) {
                this.model = c
              })
            o.inherits(l, a, {
              get tag() {
                return 'r'
              },
              get richTextXform() {
                return (this._richTextXform || (this._richTextXform = new s()), this._richTextXform)
              },
              render(c, u) {
                ;((u = u || this.model),
                  c.openNode('comment', { ref: u.ref, authorId: 0 }),
                  c.openNode('text'),
                  u &&
                    u.note &&
                    u.note.texts &&
                    u.note.texts.forEach((f) => {
                      this.richTextXform.render(c, f)
                    }),
                  c.closeNode(),
                  c.closeNode())
              },
              parseOpen(c) {
                if (this.parser) return (this.parser.parseOpen(c), !0)
                switch (c.name) {
                  case 'comment':
                    return (
                      (this.model = { type: 'note', note: { texts: [] }, ...c.attributes }),
                      !0
                    )
                  case 'r':
                    return ((this.parser = this.richTextXform), this.parser.parseOpen(c), !0)
                  default:
                    return !1
                }
              },
              parseText(c) {
                this.parser && this.parser.parseText(c)
              },
              parseClose(c) {
                switch (c) {
                  case 'comment':
                    return !1
                  case 'r':
                    return (
                      this.model.note.texts.push(this.parser.model),
                      (this.parser = void 0),
                      !0
                    )
                  default:
                    return (this.parser && this.parser.parseClose(c), !0)
                }
              },
            })
          },
          { '../../../utils/utils': 27, '../base-xform': 32, '../strings/rich-text-xform': 122 },
        ],
        40: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../../../utils/utils'),
              a = t('../base-xform'),
              l = t('./comment-xform'),
              c = (r.exports = function () {
                this.map = { comment: new l() }
              })
            o.inherits(
              c,
              a,
              {
                COMMENTS_ATTRIBUTES: {
                  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                },
              },
              {
                render(u, f) {
                  ;((f = f || this.model),
                    u.openXml(s.StdDocAttributes),
                    u.openNode('comments', c.COMMENTS_ATTRIBUTES),
                    u.openNode('authors'),
                    u.leafNode('author', null, 'Author'),
                    u.closeNode(),
                    u.openNode('commentList'),
                    f.comments.forEach((d) => {
                      this.map.comment.render(u, d)
                    }),
                    u.closeNode(),
                    u.closeNode())
                },
                parseOpen(u) {
                  if (this.parser) return (this.parser.parseOpen(u), !0)
                  switch (u.name) {
                    case 'commentList':
                      return ((this.model = { comments: [] }), !0)
                    case 'comment':
                      return ((this.parser = this.map.comment), this.parser.parseOpen(u), !0)
                    default:
                      return !1
                  }
                },
                parseText(u) {
                  this.parser && this.parser.parseText(u)
                },
                parseClose(u) {
                  switch (u) {
                    case 'commentList':
                      return !1
                    case 'comment':
                      return (
                        this.model.comments.push(this.parser.model),
                        (this.parser = void 0),
                        !0
                      )
                    default:
                      return (this.parser && this.parser.parseClose(u), !0)
                  }
                },
              },
            )
          },
          {
            '../../../utils/utils': 27,
            '../../../utils/xml-stream': 28,
            '../base-xform': 32,
            './comment-xform': 39,
          },
        ],
        41: [
          function (t, r, i) {
            const s = t('../../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(), (this._model = o))
              }
              get tag() {
                return this._model && this._model.tag
              }
              render(o, a, l) {
                ;(a === l[2] || (this.tag === 'x:SizeWithCells' && a === l[1])) &&
                  o.leafNode(this.tag)
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return ((this.model = {}), (this.model[this.tag] = !0), !0)
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../base-xform': 32 },
        ],
        42: [
          function (t, r, i) {
            const s = t('../../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(), (this._model = o))
              }
              get tag() {
                return this._model && this._model.tag
              }
              render(o, a) {
                o.leafNode(this.tag, null, a)
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return ((this.text = ''), !0)
                  default:
                    return !1
                }
              }
              parseText(o) {
                this.text = o
              }
              parseClose() {
                return !1
              }
            }
          },
          { '../../base-xform': 32 },
        ],
        43: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'x:Anchor'
              }
              getAnchorRect(o) {
                const a = Math.floor(o.left),
                  l = Math.floor(68 * (o.left - a)),
                  c = Math.floor(o.top),
                  u = Math.floor(18 * (o.top - c)),
                  f = Math.floor(o.right),
                  d = Math.floor(68 * (o.right - f)),
                  h = Math.floor(o.bottom)
                return [a, l, c, u, f, d, h, Math.floor(18 * (o.bottom - h))]
              }
              getDefaultRect(o) {
                const a = o.col,
                  l = Math.max(o.row - 2, 0)
                return [a, 6, l, 14, a + 2, 2, l + 4, 16]
              }
              render(o, a) {
                const l = a.anchor
                  ? this.getAnchorRect(a.anchor)
                  : this.getDefaultRect(a.refAddress)
                o.leafNode('x:Anchor', null, l.join(', '))
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return ((this.text = ''), !0)
                  default:
                    return !1
                }
              }
              parseText(o) {
                this.text = o
              }
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        44: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./vml-anchor-xform'),
              a = t('./style/vml-protection-xform'),
              l = t('./style/vml-position-xform'),
              c = ['twoCells', 'oneCells', 'absolute']
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    'x:Anchor': new o(),
                    'x:Locked': new a({ tag: 'x:Locked' }),
                    'x:LockText': new a({ tag: 'x:LockText' }),
                    'x:SizeWithCells': new l({ tag: 'x:SizeWithCells' }),
                    'x:MoveWithCells': new l({ tag: 'x:MoveWithCells' }),
                  }))
              }
              get tag() {
                return 'x:ClientData'
              }
              render(u, f) {
                const { protection: d, editAs: h } = f.note
                ;(u.openNode(this.tag, { ObjectType: 'Note' }),
                  this.map['x:MoveWithCells'].render(u, h, c),
                  this.map['x:SizeWithCells'].render(u, h, c),
                  this.map['x:Anchor'].render(u, f),
                  this.map['x:Locked'].render(u, d.locked),
                  u.leafNode('x:AutoFill', null, 'False'),
                  this.map['x:LockText'].render(u, d.lockText),
                  u.leafNode('x:Row', null, f.refAddress.row - 1),
                  u.leafNode('x:Column', null, f.refAddress.col - 1),
                  u.closeNode())
              }
              parseOpen(u) {
                switch (u.name) {
                  case this.tag:
                    ;(this.reset(), (this.model = { anchor: [], protection: {}, editAs: '' }))
                    break
                  default:
                    ;((this.parser = this.map[u.name]), this.parser && this.parser.parseOpen(u))
                }
                return !0
              }
              parseText(u) {
                this.parser && this.parser.parseText(u)
              }
              parseClose(u) {
                if (this.parser) return (this.parser.parseClose(u) || (this.parser = void 0), !0)
                switch (u) {
                  case this.tag:
                    return (this.normalizeModel(), !1)
                  default:
                    return !0
                }
              }
              normalizeModel() {
                const u = Object.assign(
                    {},
                    this.map['x:MoveWithCells'].model,
                    this.map['x:SizeWithCells'].model,
                  ),
                  f = Object.keys(u).length
                ;((this.model.editAs = c[f]),
                  (this.model.anchor = this.map['x:Anchor'].text),
                  (this.model.protection.locked = this.map['x:Locked'].text),
                  (this.model.protection.lockText = this.map['x:LockText'].text))
              }
            }
          },
          {
            '../base-xform': 32,
            './style/vml-position-xform': 41,
            './style/vml-protection-xform': 42,
            './vml-anchor-xform': 43,
          },
        ],
        45: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../base-xform'),
              a = t('./vml-shape-xform')
            class l extends o {
              constructor() {
                ;(super(), (this.map = { 'v:shape': new a() }))
              }
              get tag() {
                return 'xml'
              }
              render(u, f) {
                ;(u.openXml(s.StdDocAttributes),
                  u.openNode(this.tag, l.DRAWING_ATTRIBUTES),
                  u.openNode('o:shapelayout', { 'v:ext': 'edit' }),
                  u.leafNode('o:idmap', { 'v:ext': 'edit', data: 1 }),
                  u.closeNode(),
                  u.openNode('v:shapetype', {
                    id: '_x0000_t202',
                    coordsize: '21600,21600',
                    'o:spt': 202,
                    path: 'm,l,21600r21600,l21600,xe',
                  }),
                  u.leafNode('v:stroke', { joinstyle: 'miter' }),
                  u.leafNode('v:path', { gradientshapeok: 't', 'o:connecttype': 'rect' }),
                  u.closeNode(),
                  f.comments.forEach((d, h) => {
                    this.map['v:shape'].render(u, d, h)
                  }),
                  u.closeNode())
              }
              parseOpen(u) {
                if (this.parser) return (this.parser.parseOpen(u), !0)
                switch (u.name) {
                  case this.tag:
                    ;(this.reset(), (this.model = { comments: [] }))
                    break
                  default:
                    ;((this.parser = this.map[u.name]), this.parser && this.parser.parseOpen(u))
                }
                return !0
              }
              parseText(u) {
                this.parser && this.parser.parseText(u)
              }
              parseClose(u) {
                if (this.parser)
                  return (
                    this.parser.parseClose(u) ||
                      (this.model.comments.push(this.parser.model), (this.parser = void 0)),
                    !0
                  )
                switch (u) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
              reconcile(u, f) {
                u.anchors.forEach((d) => {
                  d.br
                    ? this.map['xdr:twoCellAnchor'].reconcile(d, f)
                    : this.map['xdr:oneCellAnchor'].reconcile(d, f)
                })
              }
            }
            ;((l.DRAWING_ATTRIBUTES = {
              'xmlns:v': 'urn:schemas-microsoft-com:vml',
              'xmlns:o': 'urn:schemas-microsoft-com:office:office',
              'xmlns:x': 'urn:schemas-microsoft-com:office:excel',
            }),
              (r.exports = l))
          },
          { '../../../utils/xml-stream': 28, '../base-xform': 32, './vml-shape-xform': 46 },
        ],
        46: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./vml-textbox-xform'),
              a = t('./vml-client-data-xform')
            class l extends s {
              constructor() {
                ;(super(), (this.map = { 'v:textbox': new o(), 'x:ClientData': new a() }))
              }
              get tag() {
                return 'v:shape'
              }
              render(u, f, d) {
                ;(u.openNode('v:shape', l.V_SHAPE_ATTRIBUTES(f, d)),
                  u.leafNode('v:fill', { color2: 'infoBackground [80]' }),
                  u.leafNode('v:shadow', { color: 'none [81]', obscured: 't' }),
                  u.leafNode('v:path', { 'o:connecttype': 'none' }),
                  this.map['v:textbox'].render(u, f),
                  this.map['x:ClientData'].render(u, f),
                  u.closeNode())
              }
              parseOpen(u) {
                if (this.parser) return (this.parser.parseOpen(u), !0)
                switch (u.name) {
                  case this.tag:
                    ;(this.reset(),
                      (this.model = {
                        margins: { insetmode: u.attributes['o:insetmode'] },
                        anchor: '',
                        editAs: '',
                        protection: {},
                      }))
                    break
                  default:
                    ;((this.parser = this.map[u.name]), this.parser && this.parser.parseOpen(u))
                }
                return !0
              }
              parseText(u) {
                this.parser && this.parser.parseText(u)
              }
              parseClose(u) {
                if (this.parser) return (this.parser.parseClose(u) || (this.parser = void 0), !0)
                switch (u) {
                  case this.tag:
                    return (
                      (this.model.margins.inset =
                        this.map['v:textbox'].model && this.map['v:textbox'].model.inset),
                      (this.model.protection =
                        this.map['x:ClientData'].model &&
                        this.map['x:ClientData'].model.protection),
                      (this.model.anchor =
                        this.map['x:ClientData'].model && this.map['x:ClientData'].model.anchor),
                      (this.model.editAs =
                        this.map['x:ClientData'].model && this.map['x:ClientData'].model.editAs),
                      !1
                    )
                  default:
                    return !0
                }
              }
            }
            ;((l.V_SHAPE_ATTRIBUTES = (c, u) => ({
              id: '_x0000_s' + (1025 + u),
              type: '#_x0000_t202',
              style:
                'position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden',
              fillcolor: 'infoBackground [80]',
              strokecolor: 'none [81]',
              'o:insetmode': c.note.margins && c.note.margins.insetmode,
            })),
              (r.exports = l))
          },
          { '../base-xform': 32, './vml-client-data-xform': 44, './vml-textbox-xform': 47 },
        ],
        47: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'v:textbox'
              }
              conversionUnit(o, a, l) {
                return `${parseFloat(o) * a.toFixed(2)}${l}`
              }
              reverseConversionUnit(o) {
                return (o || '')
                  .split(',')
                  .map((a) =>
                    Number(parseFloat(this.conversionUnit(parseFloat(a), 0.1, '')).toFixed(2)),
                  )
              }
              render(o, a) {
                const l = { style: 'mso-direction-alt:auto' }
                if (a && a.note) {
                  let { inset: c } = a.note && a.note.margins
                  ;(Array.isArray(c) &&
                    (c = c.map((u) => this.conversionUnit(u, 10, 'mm')).join(',')),
                    c && (l.inset = c))
                }
                ;(o.openNode('v:textbox', l),
                  o.leafNode('div', { style: 'text-align:left' }),
                  o.closeNode())
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return (
                      (this.model = { inset: this.reverseConversionUnit(o.attributes.inset) }),
                      !0
                    )
                  default:
                    return !0
                }
              }
              parseText() {}
              parseClose(o) {
                switch (o) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32 },
        ],
        48: [
          function (t, r, i) {
            const s = t('./base-xform')
            r.exports = class extends s {
              createNewModel(o) {
                return {}
              }
              parseOpen(o) {
                return (
                  (this.parser = this.parser || this.map[o.name]),
                  this.parser
                    ? (this.parser.parseOpen(o), !0)
                    : o.name === this.tag && ((this.model = this.createNewModel(o)), !0)
                )
              }
              parseText(o) {
                this.parser && this.parser.parseText(o)
              }
              onParserClose(o, a) {
                this.model[o] = a.model
              }
              parseClose(o) {
                return this.parser
                  ? (this.parser.parseClose(o) ||
                      (this.onParserClose(o, this.parser), (this.parser = void 0)),
                    !0)
                  : o !== this.tag
              }
            }
          },
          { './base-xform': 32 },
        ],
        49: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              render(o, a) {
                ;(o.openNode('HeadingPairs'),
                  o.openNode('vt:vector', { size: 2, baseType: 'variant' }),
                  o.openNode('vt:variant'),
                  o.leafNode('vt:lpstr', void 0, 'Worksheets'),
                  o.closeNode(),
                  o.openNode('vt:variant'),
                  o.leafNode('vt:i4', void 0, a.length),
                  o.closeNode(),
                  o.closeNode(),
                  o.closeNode())
              }
              parseOpen(o) {
                return o.name === 'HeadingPairs'
              }
              parseText() {}
              parseClose(o) {
                return o !== 'HeadingPairs'
              }
            }
          },
          { '../base-xform': 32 },
        ],
        50: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              render(o, a) {
                ;(o.openNode('TitlesOfParts'),
                  o.openNode('vt:vector', { size: a.length, baseType: 'lpstr' }),
                  a.forEach((l) => {
                    o.leafNode('vt:lpstr', void 0, l.name)
                  }),
                  o.closeNode(),
                  o.closeNode())
              }
              parseOpen(o) {
                return o.name === 'TitlesOfParts'
              }
              parseText() {}
              parseClose(o) {
                return o !== 'TitlesOfParts'
              }
            }
          },
          { '../base-xform': 32 },
        ],
        51: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../base-xform'),
              a = t('../simple/string-xform'),
              l = t('./app-heading-pairs-xform'),
              c = t('./app-titles-of-parts-xform')
            class u extends o {
              constructor() {
                ;(super(),
                  (this.map = {
                    Company: new a({ tag: 'Company' }),
                    Manager: new a({ tag: 'Manager' }),
                    HeadingPairs: new l(),
                    TitleOfParts: new c(),
                  }))
              }
              render(d, h) {
                ;(d.openXml(s.StdDocAttributes),
                  d.openNode('Properties', u.PROPERTY_ATTRIBUTES),
                  d.leafNode('Application', void 0, 'Microsoft Excel'),
                  d.leafNode('DocSecurity', void 0, '0'),
                  d.leafNode('ScaleCrop', void 0, 'false'),
                  this.map.HeadingPairs.render(d, h.worksheets),
                  this.map.TitleOfParts.render(d, h.worksheets),
                  this.map.Company.render(d, h.company || ''),
                  this.map.Manager.render(d, h.manager),
                  d.leafNode('LinksUpToDate', void 0, 'false'),
                  d.leafNode('SharedDoc', void 0, 'false'),
                  d.leafNode('HyperlinksChanged', void 0, 'false'),
                  d.leafNode('AppVersion', void 0, '16.0300'),
                  d.closeNode())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case 'Properties':
                    return !0
                  default:
                    return (
                      (this.parser = this.map[d.name]),
                      !!this.parser && (this.parser.parseOpen(d), !0)
                    )
                }
              }
              parseText(d) {
                this.parser && this.parser.parseText(d)
              }
              parseClose(d) {
                if (this.parser) return (this.parser.parseClose(d) || (this.parser = void 0), !0)
                switch (d) {
                  case 'Properties':
                    return (
                      (this.model = {
                        worksheets: this.map.TitleOfParts.model,
                        company: this.map.Company.model,
                        manager: this.map.Manager.model,
                      }),
                      !1
                    )
                  default:
                    return !0
                }
              }
            }
            ;((u.DateFormat = function (f) {
              return f.toISOString().replace(/[.]\d{3,6}/, '')
            }),
              (u.DateAttrs = { 'xsi:type': 'dcterms:W3CDTF' }),
              (u.PROPERTY_ATTRIBUTES = {
                xmlns: 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
                'xmlns:vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
              }),
              (r.exports = u))
          },
          {
            '../../../utils/xml-stream': 28,
            '../base-xform': 32,
            '../simple/string-xform': 119,
            './app-heading-pairs-xform': 49,
            './app-titles-of-parts-xform': 50,
          },
        ],
        52: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../base-xform')
            class a extends o {
              render(c, u) {
                ;(c.openXml(s.StdDocAttributes), c.openNode('Types', a.PROPERTY_ATTRIBUTES))
                const f = {}
                ;((u.media || []).forEach((d) => {
                  if (d.type === 'image') {
                    const h = d.extension
                    f[h] ||
                      ((f[h] = !0),
                      c.leafNode('Default', { Extension: h, ContentType: 'image/' + h }))
                  }
                }),
                  c.leafNode('Default', {
                    Extension: 'rels',
                    ContentType: 'application/vnd.openxmlformats-package.relationships+xml',
                  }),
                  c.leafNode('Default', { Extension: 'xml', ContentType: 'application/xml' }),
                  c.leafNode('Override', {
                    PartName: '/xl/workbook.xml',
                    ContentType:
                      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
                  }),
                  u.worksheets.forEach((d) => {
                    const h = `/xl/worksheets/sheet${d.id}.xml`
                    c.leafNode('Override', {
                      PartName: h,
                      ContentType:
                        'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
                    })
                  }),
                  c.leafNode('Override', {
                    PartName: '/xl/theme/theme1.xml',
                    ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',
                  }),
                  c.leafNode('Override', {
                    PartName: '/xl/styles.xml',
                    ContentType:
                      'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
                  }),
                  u.sharedStrings &&
                    u.sharedStrings.count &&
                    c.leafNode('Override', {
                      PartName: '/xl/sharedStrings.xml',
                      ContentType:
                        'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
                    }),
                  u.tables &&
                    u.tables.forEach((d) => {
                      c.leafNode('Override', {
                        PartName: '/xl/tables/' + d.target,
                        ContentType:
                          'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',
                      })
                    }),
                  u.drawings &&
                    u.drawings.forEach((d) => {
                      c.leafNode('Override', {
                        PartName: `/xl/drawings/${d.name}.xml`,
                        ContentType: 'application/vnd.openxmlformats-officedocument.drawing+xml',
                      })
                    }),
                  u.commentRefs &&
                    (c.leafNode('Default', {
                      Extension: 'vml',
                      ContentType: 'application/vnd.openxmlformats-officedocument.vmlDrawing',
                    }),
                    u.commentRefs.forEach((d) => {
                      let { commentName: h } = d
                      c.leafNode('Override', {
                        PartName: `/xl/${h}.xml`,
                        ContentType:
                          'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',
                      })
                    })),
                  c.leafNode('Override', {
                    PartName: '/docProps/core.xml',
                    ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',
                  }),
                  c.leafNode('Override', {
                    PartName: '/docProps/app.xml',
                    ContentType:
                      'application/vnd.openxmlformats-officedocument.extended-properties+xml',
                  }),
                  c.closeNode())
              }
              parseOpen() {
                return !1
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
            ;((a.PROPERTY_ATTRIBUTES = {
              xmlns: 'http://schemas.openxmlformats.org/package/2006/content-types',
            }),
              (r.exports = a))
          },
          { '../../../utils/xml-stream': 28, '../base-xform': 32 },
        ],
        53: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../base-xform'),
              a = t('../simple/date-xform'),
              l = t('../simple/string-xform'),
              c = t('../simple/integer-xform')
            class u extends o {
              constructor() {
                ;(super(),
                  (this.map = {
                    'dc:creator': new l({ tag: 'dc:creator' }),
                    'dc:title': new l({ tag: 'dc:title' }),
                    'dc:subject': new l({ tag: 'dc:subject' }),
                    'dc:description': new l({ tag: 'dc:description' }),
                    'dc:identifier': new l({ tag: 'dc:identifier' }),
                    'dc:language': new l({ tag: 'dc:language' }),
                    'cp:keywords': new l({ tag: 'cp:keywords' }),
                    'cp:category': new l({ tag: 'cp:category' }),
                    'cp:lastModifiedBy': new l({ tag: 'cp:lastModifiedBy' }),
                    'cp:lastPrinted': new a({ tag: 'cp:lastPrinted', format: u.DateFormat }),
                    'cp:revision': new c({ tag: 'cp:revision' }),
                    'cp:version': new l({ tag: 'cp:version' }),
                    'cp:contentStatus': new l({ tag: 'cp:contentStatus' }),
                    'cp:contentType': new l({ tag: 'cp:contentType' }),
                    'dcterms:created': new a({
                      tag: 'dcterms:created',
                      attrs: u.DateAttrs,
                      format: u.DateFormat,
                    }),
                    'dcterms:modified': new a({
                      tag: 'dcterms:modified',
                      attrs: u.DateAttrs,
                      format: u.DateFormat,
                    }),
                  }))
              }
              render(d, h) {
                ;(d.openXml(s.StdDocAttributes),
                  d.openNode('cp:coreProperties', u.CORE_PROPERTY_ATTRIBUTES),
                  this.map['dc:creator'].render(d, h.creator),
                  this.map['dc:title'].render(d, h.title),
                  this.map['dc:subject'].render(d, h.subject),
                  this.map['dc:description'].render(d, h.description),
                  this.map['dc:identifier'].render(d, h.identifier),
                  this.map['dc:language'].render(d, h.language),
                  this.map['cp:keywords'].render(d, h.keywords),
                  this.map['cp:category'].render(d, h.category),
                  this.map['cp:lastModifiedBy'].render(d, h.lastModifiedBy),
                  this.map['cp:lastPrinted'].render(d, h.lastPrinted),
                  this.map['cp:revision'].render(d, h.revision),
                  this.map['cp:version'].render(d, h.version),
                  this.map['cp:contentStatus'].render(d, h.contentStatus),
                  this.map['cp:contentType'].render(d, h.contentType),
                  this.map['dcterms:created'].render(d, h.created),
                  this.map['dcterms:modified'].render(d, h.modified),
                  d.closeNode())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case 'cp:coreProperties':
                  case 'coreProperties':
                    return !0
                  default:
                    if (((this.parser = this.map[d.name]), this.parser))
                      return (this.parser.parseOpen(d), !0)
                    throw new Error('Unexpected xml node in parseOpen: ' + JSON.stringify(d))
                }
              }
              parseText(d) {
                this.parser && this.parser.parseText(d)
              }
              parseClose(d) {
                if (this.parser) return (this.parser.parseClose(d) || (this.parser = void 0), !0)
                switch (d) {
                  case 'cp:coreProperties':
                  case 'coreProperties':
                    return (
                      (this.model = {
                        creator: this.map['dc:creator'].model,
                        title: this.map['dc:title'].model,
                        subject: this.map['dc:subject'].model,
                        description: this.map['dc:description'].model,
                        identifier: this.map['dc:identifier'].model,
                        language: this.map['dc:language'].model,
                        keywords: this.map['cp:keywords'].model,
                        category: this.map['cp:category'].model,
                        lastModifiedBy: this.map['cp:lastModifiedBy'].model,
                        lastPrinted: this.map['cp:lastPrinted'].model,
                        revision: this.map['cp:revision'].model,
                        contentStatus: this.map['cp:contentStatus'].model,
                        contentType: this.map['cp:contentType'].model,
                        created: this.map['dcterms:created'].model,
                        modified: this.map['dcterms:modified'].model,
                      }),
                      !1
                    )
                  default:
                    throw new Error('Unexpected xml node in parseClose: ' + d)
                }
              }
            }
            ;((u.DateFormat = function (f) {
              return f.toISOString().replace(/[.]\d{3}/, '')
            }),
              (u.DateAttrs = { 'xsi:type': 'dcterms:W3CDTF' }),
              (u.CORE_PROPERTY_ATTRIBUTES = {
                'xmlns:cp':
                  'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
                'xmlns:dc': 'http://purl.org/dc/elements/1.1/',
                'xmlns:dcterms': 'http://purl.org/dc/terms/',
                'xmlns:dcmitype': 'http://purl.org/dc/dcmitype/',
                'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
              }),
              (r.exports = u))
          },
          {
            '../../../utils/xml-stream': 28,
            '../base-xform': 32,
            '../simple/date-xform': 117,
            '../simple/integer-xform': 118,
            '../simple/string-xform': 119,
          },
        ],
        54: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              render(o, a) {
                o.leafNode('Relationship', a)
              }
              parseOpen(o) {
                switch (o.name) {
                  case 'Relationship':
                    return ((this.model = o.attributes), !0)
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        55: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../base-xform'),
              a = t('./relationship-xform')
            class l extends o {
              constructor() {
                ;(super(), (this.map = { Relationship: new a() }))
              }
              render(u, f) {
                ;((f = f || this._values),
                  u.openXml(s.StdDocAttributes),
                  u.openNode('Relationships', l.RELATIONSHIPS_ATTRIBUTES),
                  f.forEach((d) => {
                    this.map.Relationship.render(u, d)
                  }),
                  u.closeNode())
              }
              parseOpen(u) {
                if (this.parser) return (this.parser.parseOpen(u), !0)
                switch (u.name) {
                  case 'Relationships':
                    return ((this.model = []), !0)
                  default:
                    if (((this.parser = this.map[u.name]), this.parser))
                      return (this.parser.parseOpen(u), !0)
                    throw new Error('Unexpected xml node in parseOpen: ' + JSON.stringify(u))
                }
              }
              parseText(u) {
                this.parser && this.parser.parseText(u)
              }
              parseClose(u) {
                if (this.parser)
                  return (
                    this.parser.parseClose(u) ||
                      (this.model.push(this.parser.model), (this.parser = void 0)),
                    !0
                  )
                switch (u) {
                  case 'Relationships':
                    return !1
                  default:
                    throw new Error('Unexpected xml node in parseClose: ' + u)
                }
              }
            }
            ;((l.RELATIONSHIPS_ATTRIBUTES = {
              xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',
            }),
              (r.exports = l))
          },
          { '../../../utils/xml-stream': 28, '../base-xform': 32, './relationship-xform': 54 },
        ],
        56: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              parseOpen(o) {
                if (this.parser) return (this.parser.parseOpen(o), !0)
                switch (o.name) {
                  case this.tag:
                    ;(this.reset(),
                      (this.model = { range: { editAs: o.attributes.editAs || 'oneCell' } }))
                    break
                  default:
                    ;((this.parser = this.map[o.name]), this.parser && this.parser.parseOpen(o))
                }
                return !0
              }
              parseText(o) {
                this.parser && this.parser.parseText(o)
              }
              reconcilePicture(o, a) {
                if (o && o.rId) {
                  const l = a.rels[o.rId].Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/)
                  if (l) {
                    const c = l[1],
                      u = a.mediaIndex[c]
                    return a.media[u]
                  }
                }
              }
            }
          },
          { '../base-xform': 32 },
        ],
        57: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./blip-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { 'a:blip': new o() }))
              }
              get tag() {
                return 'xdr:blipFill'
              }
              render(a, l) {
                ;(a.openNode(this.tag),
                  this.map['a:blip'].render(a, l),
                  a.openNode('a:stretch'),
                  a.leafNode('a:fillRect'),
                  a.closeNode(),
                  a.closeNode())
              }
              parseOpen(a) {
                if (this.parser) return (this.parser.parseOpen(a), !0)
                switch (a.name) {
                  case this.tag:
                    this.reset()
                    break
                  default:
                    ;((this.parser = this.map[a.name]), this.parser && this.parser.parseOpen(a))
                }
                return !0
              }
              parseText() {}
              parseClose(a) {
                if (this.parser) return (this.parser.parseClose(a) || (this.parser = void 0), !0)
                switch (a) {
                  case this.tag:
                    return ((this.model = this.map['a:blip'].model), !1)
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32, './blip-xform': 58 },
        ],
        58: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'a:blip'
              }
              render(o, a) {
                o.leafNode(this.tag, {
                  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                  'r:embed': a.rId,
                  cstate: 'print',
                })
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return ((this.model = { rId: o.attributes['r:embed'] }), !0)
                  default:
                    return !0
                }
              }
              parseText() {}
              parseClose(o) {
                switch (o) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32 },
        ],
        59: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'xdr:cNvPicPr'
              }
              render(o) {
                ;(o.openNode(this.tag),
                  o.leafNode('a:picLocks', { noChangeAspect: '1' }),
                  o.closeNode())
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                  default:
                    return !0
                }
              }
              parseText() {}
              parseClose(o) {
                switch (o) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32 },
        ],
        60: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./hlink-click-xform'),
              a = t('./ext-lst-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { 'a:hlinkClick': new o(), 'a:extLst': new a() }))
              }
              get tag() {
                return 'xdr:cNvPr'
              }
              render(l, c) {
                ;(l.openNode(this.tag, { id: c.index, name: 'Picture ' + c.index }),
                  this.map['a:hlinkClick'].render(l, c),
                  this.map['a:extLst'].render(l, c),
                  l.closeNode())
              }
              parseOpen(l) {
                if (this.parser) return (this.parser.parseOpen(l), !0)
                switch (l.name) {
                  case this.tag:
                    this.reset()
                    break
                  default:
                    ;((this.parser = this.map[l.name]), this.parser && this.parser.parseOpen(l))
                }
                return !0
              }
              parseText() {}
              parseClose(l) {
                if (this.parser) return (this.parser.parseClose(l) || (this.parser = void 0), !0)
                switch (l) {
                  case this.tag:
                    return ((this.model = this.map['a:hlinkClick'].model), !1)
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32, './ext-lst-xform': 63, './hlink-click-xform': 65 },
        ],
        61: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('../simple/integer-xform')
            r.exports = class extends s {
              constructor(a) {
                ;(super(),
                  (this.tag = a.tag),
                  (this.map = {
                    'xdr:col': new o({ tag: 'xdr:col', zero: !0 }),
                    'xdr:colOff': new o({ tag: 'xdr:colOff', zero: !0 }),
                    'xdr:row': new o({ tag: 'xdr:row', zero: !0 }),
                    'xdr:rowOff': new o({ tag: 'xdr:rowOff', zero: !0 }),
                  }))
              }
              render(a, l) {
                ;(a.openNode(this.tag),
                  this.map['xdr:col'].render(a, l.nativeCol),
                  this.map['xdr:colOff'].render(a, l.nativeColOff),
                  this.map['xdr:row'].render(a, l.nativeRow),
                  this.map['xdr:rowOff'].render(a, l.nativeRowOff),
                  a.closeNode())
              }
              parseOpen(a) {
                if (this.parser) return (this.parser.parseOpen(a), !0)
                switch (a.name) {
                  case this.tag:
                    this.reset()
                    break
                  default:
                    ;((this.parser = this.map[a.name]), this.parser && this.parser.parseOpen(a))
                }
                return !0
              }
              parseText(a) {
                this.parser && this.parser.parseText(a)
              }
              parseClose(a) {
                if (this.parser) return (this.parser.parseClose(a) || (this.parser = void 0), !0)
                switch (a) {
                  case this.tag:
                    return (
                      (this.model = {
                        nativeCol: this.map['xdr:col'].model,
                        nativeColOff: this.map['xdr:colOff'].model,
                        nativeRow: this.map['xdr:row'].model,
                        nativeRowOff: this.map['xdr:rowOff'].model,
                      }),
                      !1
                    )
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32, '../simple/integer-xform': 118 },
        ],
        62: [
          function (t, r, i) {
            const s = t('../../../utils/col-cache'),
              o = t('../../../utils/xml-stream'),
              a = t('../base-xform'),
              l = t('./two-cell-anchor-xform'),
              c = t('./one-cell-anchor-xform')
            class u extends a {
              constructor() {
                ;(super(),
                  (this.map = { 'xdr:twoCellAnchor': new l(), 'xdr:oneCellAnchor': new c() }))
              }
              prepare(d) {
                d.anchors.forEach((h, p) => {
                  ;((h.anchorType = (function (g) {
                    return (typeof g.range == 'string' ? s.decode(g.range) : g.range).br
                      ? 'xdr:twoCellAnchor'
                      : 'xdr:oneCellAnchor'
                  })(h)),
                    this.map[h.anchorType].prepare(h, { index: p }))
                })
              }
              get tag() {
                return 'xdr:wsDr'
              }
              render(d, h) {
                ;(d.openXml(o.StdDocAttributes),
                  d.openNode(this.tag, u.DRAWING_ATTRIBUTES),
                  h.anchors.forEach((p) => {
                    this.map[p.anchorType].render(d, p)
                  }),
                  d.closeNode())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case this.tag:
                    ;(this.reset(), (this.model = { anchors: [] }))
                    break
                  default:
                    ;((this.parser = this.map[d.name]), this.parser && this.parser.parseOpen(d))
                }
                return !0
              }
              parseText(d) {
                this.parser && this.parser.parseText(d)
              }
              parseClose(d) {
                if (this.parser)
                  return (
                    this.parser.parseClose(d) ||
                      (this.model.anchors.push(this.parser.model), (this.parser = void 0)),
                    !0
                  )
                switch (d) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
              reconcile(d, h) {
                d.anchors.forEach((p) => {
                  p.br
                    ? this.map['xdr:twoCellAnchor'].reconcile(p, h)
                    : this.map['xdr:oneCellAnchor'].reconcile(p, h)
                })
              }
            }
            ;((u.DRAWING_ATTRIBUTES = {
              'xmlns:xdr': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
              'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
            }),
              (r.exports = u))
          },
          {
            '../../../utils/col-cache': 19,
            '../../../utils/xml-stream': 28,
            '../base-xform': 32,
            './one-cell-anchor-xform': 67,
            './two-cell-anchor-xform': 70,
          },
        ],
        63: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'a:extLst'
              }
              render(o) {
                ;(o.openNode(this.tag),
                  o.openNode('a:ext', { uri: '{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}' }),
                  o.leafNode('a16:creationId', {
                    'xmlns:a16': 'http://schemas.microsoft.com/office/drawing/2014/main',
                    id: '{00000000-0008-0000-0000-000002000000}',
                  }),
                  o.closeNode(),
                  o.closeNode())
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                  default:
                    return !0
                }
              }
              parseText() {}
              parseClose(o) {
                switch (o) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32 },
        ],
        64: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(), (this.tag = o.tag), (this.map = {}))
              }
              render(o, a) {
                o.openNode(this.tag)
                const l = Math.floor(9525 * a.width),
                  c = Math.floor(9525 * a.height)
                ;(o.addAttribute('cx', l), o.addAttribute('cy', c), o.closeNode())
              }
              parseOpen(o) {
                return (
                  o.name === this.tag &&
                  ((this.model = {
                    width: parseInt(o.attributes.cx || '0', 10) / 9525,
                    height: parseInt(o.attributes.cy || '0', 10) / 9525,
                  }),
                  !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        65: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'a:hlinkClick'
              }
              render(o, a) {
                a.hyperlinks &&
                  a.hyperlinks.rId &&
                  o.leafNode(this.tag, {
                    'xmlns:r':
                      'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                    'r:id': a.hyperlinks.rId,
                    tooltip: a.hyperlinks.tooltip,
                  })
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return (
                      (this.model = {
                        hyperlinks: { rId: o.attributes['r:id'], tooltip: o.attributes.tooltip },
                      }),
                      !0
                    )
                  default:
                    return !0
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        66: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./c-nv-pr-xform'),
              a = t('./c-nv-pic-pr-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { 'xdr:cNvPr': new o(), 'xdr:cNvPicPr': new a() }))
              }
              get tag() {
                return 'xdr:nvPicPr'
              }
              render(l, c) {
                ;(l.openNode(this.tag),
                  this.map['xdr:cNvPr'].render(l, c),
                  this.map['xdr:cNvPicPr'].render(l, c),
                  l.closeNode())
              }
              parseOpen(l) {
                if (this.parser) return (this.parser.parseOpen(l), !0)
                switch (l.name) {
                  case this.tag:
                    this.reset()
                    break
                  default:
                    ;((this.parser = this.map[l.name]), this.parser && this.parser.parseOpen(l))
                }
                return !0
              }
              parseText() {}
              parseClose(l) {
                if (this.parser) return (this.parser.parseClose(l) || (this.parser = void 0), !0)
                switch (l) {
                  case this.tag:
                    return ((this.model = this.map['xdr:cNvPr'].model), !1)
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32, './c-nv-pic-pr-xform': 59, './c-nv-pr-xform': 60 },
        ],
        67: [
          function (t, r, i) {
            const s = t('./base-cell-anchor-xform'),
              o = t('../static-xform'),
              a = t('./cell-position-xform'),
              l = t('./ext-xform'),
              c = t('./pic-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    'xdr:from': new a({ tag: 'xdr:from' }),
                    'xdr:ext': new l({ tag: 'xdr:ext' }),
                    'xdr:pic': new c(),
                    'xdr:clientData': new o({ tag: 'xdr:clientData' }),
                  }))
              }
              get tag() {
                return 'xdr:oneCellAnchor'
              }
              prepare(u, f) {
                this.map['xdr:pic'].prepare(u.picture, f)
              }
              render(u, f) {
                ;(u.openNode(this.tag, { editAs: f.range.editAs || 'oneCell' }),
                  this.map['xdr:from'].render(u, f.range.tl),
                  this.map['xdr:ext'].render(u, f.range.ext),
                  this.map['xdr:pic'].render(u, f.picture),
                  this.map['xdr:clientData'].render(u, {}),
                  u.closeNode())
              }
              parseClose(u) {
                if (this.parser) return (this.parser.parseClose(u) || (this.parser = void 0), !0)
                switch (u) {
                  case this.tag:
                    return (
                      (this.model.range.tl = this.map['xdr:from'].model),
                      (this.model.range.ext = this.map['xdr:ext'].model),
                      (this.model.picture = this.map['xdr:pic'].model),
                      !1
                    )
                  default:
                    return !0
                }
              }
              reconcile(u, f) {
                u.medium = this.reconcilePicture(u.picture, f)
              }
            }
          },
          {
            '../static-xform': 120,
            './base-cell-anchor-xform': 56,
            './cell-position-xform': 61,
            './ext-xform': 64,
            './pic-xform': 68,
          },
        ],
        68: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('../static-xform'),
              a = t('./blip-fill-xform'),
              l = t('./nv-pic-pr-xform'),
              c = t('./sp-pr')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    'xdr:nvPicPr': new l(),
                    'xdr:blipFill': new a(),
                    'xdr:spPr': new o(c),
                  }))
              }
              get tag() {
                return 'xdr:pic'
              }
              prepare(u, f) {
                u.index = f.index + 1
              }
              render(u, f) {
                ;(u.openNode(this.tag),
                  this.map['xdr:nvPicPr'].render(u, f),
                  this.map['xdr:blipFill'].render(u, f),
                  this.map['xdr:spPr'].render(u, f),
                  u.closeNode())
              }
              parseOpen(u) {
                if (this.parser) return (this.parser.parseOpen(u), !0)
                switch (u.name) {
                  case this.tag:
                    this.reset()
                    break
                  default:
                    ;((this.parser = this.map[u.name]), this.parser && this.parser.parseOpen(u))
                }
                return !0
              }
              parseText() {}
              parseClose(u) {
                if (this.parser)
                  return (
                    this.parser.parseClose(u) ||
                      (this.mergeModel(this.parser.model), (this.parser = void 0)),
                    !0
                  )
                switch (u) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          {
            '../base-xform': 32,
            '../static-xform': 120,
            './blip-fill-xform': 57,
            './nv-pic-pr-xform': 66,
            './sp-pr': 69,
          },
        ],
        69: [
          function (t, r, i) {
            r.exports = {
              tag: 'xdr:spPr',
              c: [
                {
                  tag: 'a:xfrm',
                  c: [
                    { tag: 'a:off', $: { x: '0', y: '0' } },
                    { tag: 'a:ext', $: { cx: '0', cy: '0' } },
                  ],
                },
                { tag: 'a:prstGeom', $: { prst: 'rect' }, c: [{ tag: 'a:avLst' }] },
              ],
            }
          },
          {},
        ],
        70: [
          function (t, r, i) {
            const s = t('./base-cell-anchor-xform'),
              o = t('../static-xform'),
              a = t('./cell-position-xform'),
              l = t('./pic-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    'xdr:from': new a({ tag: 'xdr:from' }),
                    'xdr:to': new a({ tag: 'xdr:to' }),
                    'xdr:pic': new l(),
                    'xdr:clientData': new o({ tag: 'xdr:clientData' }),
                  }))
              }
              get tag() {
                return 'xdr:twoCellAnchor'
              }
              prepare(c, u) {
                this.map['xdr:pic'].prepare(c.picture, u)
              }
              render(c, u) {
                ;(c.openNode(this.tag, { editAs: u.range.editAs || 'oneCell' }),
                  this.map['xdr:from'].render(c, u.range.tl),
                  this.map['xdr:to'].render(c, u.range.br),
                  this.map['xdr:pic'].render(c, u.picture),
                  this.map['xdr:clientData'].render(c, {}),
                  c.closeNode())
              }
              parseClose(c) {
                if (this.parser) return (this.parser.parseClose(c) || (this.parser = void 0), !0)
                switch (c) {
                  case this.tag:
                    return (
                      (this.model.range.tl = this.map['xdr:from'].model),
                      (this.model.range.br = this.map['xdr:to'].model),
                      (this.model.picture = this.map['xdr:pic'].model),
                      !1
                    )
                  default:
                    return !0
                }
              }
              reconcile(c, u) {
                c.medium = this.reconcilePicture(c.picture, u)
              }
            }
          },
          {
            '../static-xform': 120,
            './base-cell-anchor-xform': 56,
            './cell-position-xform': 61,
            './pic-xform': 68,
          },
        ],
        71: [
          function (t, r, i) {
            const s = t('./base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(),
                  (this.tag = o.tag),
                  (this.always = !!o.always),
                  (this.count = o.count),
                  (this.empty = o.empty),
                  (this.$count = o.$count || 'count'),
                  (this.$ = o.$),
                  (this.childXform = o.childXform),
                  (this.maxItems = o.maxItems))
              }
              prepare(o, a) {
                const { childXform: l } = this
                o &&
                  o.forEach((c, u) => {
                    ;((a.index = u), l.prepare(c, a))
                  })
              }
              render(o, a) {
                if (this.always || (a && a.length)) {
                  ;(o.openNode(this.tag, this.$),
                    this.count && o.addAttribute(this.$count, (a && a.length) || 0))
                  const { childXform: l } = this
                  ;((a || []).forEach((c, u) => {
                    l.render(o, c, u)
                  }),
                    o.closeNode())
                } else this.empty && o.leafNode(this.tag)
              }
              parseOpen(o) {
                if (this.parser) return (this.parser.parseOpen(o), !0)
                switch (o.name) {
                  case this.tag:
                    return ((this.model = []), !0)
                  default:
                    return !!this.childXform.parseOpen(o) && ((this.parser = this.childXform), !0)
                }
              }
              parseText(o) {
                this.parser && this.parser.parseText(o)
              }
              parseClose(o) {
                if (this.parser) {
                  if (
                    !this.parser.parseClose(o) &&
                    (this.model.push(this.parser.model),
                    (this.parser = void 0),
                    this.maxItems && this.model.length > this.maxItems)
                  )
                    throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`)
                  return !0
                }
                return !1
              }
              reconcile(o, a) {
                if (o) {
                  const { childXform: l } = this
                  o.forEach((c) => {
                    l.reconcile(c, a)
                  })
                }
              }
            }
          },
          { './base-xform': 32 },
        ],
        72: [
          function (t, r, i) {
            const s = t('../../../utils/col-cache'),
              o = t('../base-xform')
            r.exports = class extends o {
              get tag() {
                return 'autoFilter'
              }
              render(a, l) {
                if (l)
                  if (typeof l == 'string') a.leafNode('autoFilter', { ref: l })
                  else {
                    const c = function (d) {
                        return typeof d == 'string' ? d : s.getAddress(d.row, d.column).address
                      },
                      u = c(l.from),
                      f = c(l.to)
                    u && f && a.leafNode('autoFilter', { ref: `${u}:${f}` })
                  }
              }
              parseOpen(a) {
                a.name === 'autoFilter' && (this.model = a.attributes.ref)
              }
            }
          },
          { '../../../utils/col-cache': 19, '../base-xform': 32 },
        ],
        73: [
          function (t, r, i) {
            const s = t('../../../utils/utils'),
              o = t('../base-xform'),
              a = t('../../../doc/range'),
              l = t('../../../doc/enums'),
              c = t('../strings/rich-text-xform')
            function u(f) {
              if (f == null) return l.ValueType.Null
              if (f instanceof String || typeof f == 'string') return l.ValueType.String
              if (typeof f == 'number') return l.ValueType.Number
              if (typeof f == 'boolean') return l.ValueType.Boolean
              if (f instanceof Date) return l.ValueType.Date
              if (f.text && f.hyperlink) return l.ValueType.Hyperlink
              if (f.formula) return l.ValueType.Formula
              if (f.error) return l.ValueType.Error
              throw new Error('I could not understand type of value')
            }
            r.exports = class extends o {
              constructor() {
                ;(super(), (this.richTextXForm = new c()))
              }
              get tag() {
                return 'c'
              }
              prepare(f, d) {
                const h = d.styles.addStyleModel(
                  f.style || {},
                  (function (p) {
                    switch (p.type) {
                      case l.ValueType.Formula:
                        return u(p.result)
                      default:
                        return p.type
                    }
                  })(f),
                )
                switch (
                  (h && (f.styleId = h),
                  f.comment && d.comments.push({ ...f.comment, ref: f.address }),
                  f.type)
                ) {
                  case l.ValueType.String:
                  case l.ValueType.RichText:
                    d.sharedStrings && (f.ssId = d.sharedStrings.add(f.value))
                    break
                  case l.ValueType.Date:
                    d.date1904 && (f.date1904 = !0)
                    break
                  case l.ValueType.Hyperlink:
                    ;(d.sharedStrings &&
                      f.text !== void 0 &&
                      f.text !== null &&
                      (f.ssId = d.sharedStrings.add(f.text)),
                      d.hyperlinks.push({
                        address: f.address,
                        target: f.hyperlink,
                        tooltip: f.tooltip,
                      }))
                    break
                  case l.ValueType.Merge:
                    d.merges.add(f)
                    break
                  case l.ValueType.Formula:
                    if (
                      (d.date1904 && (f.date1904 = !0),
                      f.shareType === 'shared' && (f.si = d.siFormulae++),
                      f.formula)
                    )
                      d.formulae[f.address] = f
                    else if (f.sharedFormula) {
                      const p = d.formulae[f.sharedFormula]
                      if (!p)
                        throw new Error(
                          'Shared Formula master must exist above and or left of clone for cell ' +
                            f.address,
                        )
                      ;(p.si === void 0
                        ? ((p.shareType = 'shared'),
                          (p.si = d.siFormulae++),
                          (p.range = new a(p.address, f.address)))
                        : p.range && p.range.expandToAddress(f.address),
                        (f.si = p.si))
                    }
                }
              }
              renderFormula(f, d) {
                let h = null
                switch (d.shareType) {
                  case 'shared':
                    h = { t: 'shared', ref: d.ref || d.range.range, si: d.si }
                    break
                  case 'array':
                    h = { t: 'array', ref: d.ref }
                    break
                  default:
                    d.si !== void 0 && (h = { t: 'shared', si: d.si })
                }
                switch (u(d.result)) {
                  case l.ValueType.Null:
                    f.leafNode('f', h, d.formula)
                    break
                  case l.ValueType.String:
                    ;(f.addAttribute('t', 'str'),
                      f.leafNode('f', h, d.formula),
                      f.leafNode('v', null, d.result))
                    break
                  case l.ValueType.Number:
                    ;(f.leafNode('f', h, d.formula), f.leafNode('v', null, d.result))
                    break
                  case l.ValueType.Boolean:
                    ;(f.addAttribute('t', 'b'),
                      f.leafNode('f', h, d.formula),
                      f.leafNode('v', null, d.result ? 1 : 0))
                    break
                  case l.ValueType.Error:
                    ;(f.addAttribute('t', 'e'),
                      f.leafNode('f', h, d.formula),
                      f.leafNode('v', null, d.result.error))
                    break
                  case l.ValueType.Date:
                    ;(f.leafNode('f', h, d.formula),
                      f.leafNode('v', null, s.dateToExcel(d.result, d.date1904)))
                    break
                  default:
                    throw new Error('I could not understand type of value')
                }
              }
              render(f, d) {
                if (d.type !== l.ValueType.Null || d.styleId) {
                  switch (
                    (f.openNode('c'),
                    f.addAttribute('r', d.address),
                    d.styleId && f.addAttribute('s', d.styleId),
                    d.type)
                  ) {
                    case l.ValueType.Null:
                      break
                    case l.ValueType.Number:
                      f.leafNode('v', null, d.value)
                      break
                    case l.ValueType.Boolean:
                      ;(f.addAttribute('t', 'b'), f.leafNode('v', null, d.value ? '1' : '0'))
                      break
                    case l.ValueType.Error:
                      ;(f.addAttribute('t', 'e'), f.leafNode('v', null, d.value.error))
                      break
                    case l.ValueType.String:
                    case l.ValueType.RichText:
                      d.ssId !== void 0
                        ? (f.addAttribute('t', 's'), f.leafNode('v', null, d.ssId))
                        : d.value && d.value.richText
                          ? (f.addAttribute('t', 'inlineStr'),
                            f.openNode('is'),
                            d.value.richText.forEach((h) => {
                              this.richTextXForm.render(f, h)
                            }),
                            f.closeNode('is'))
                          : (f.addAttribute('t', 'str'), f.leafNode('v', null, d.value))
                      break
                    case l.ValueType.Date:
                      f.leafNode('v', null, s.dateToExcel(d.value, d.date1904))
                      break
                    case l.ValueType.Hyperlink:
                      d.ssId !== void 0
                        ? (f.addAttribute('t', 's'), f.leafNode('v', null, d.ssId))
                        : (f.addAttribute('t', 'str'), f.leafNode('v', null, d.text))
                      break
                    case l.ValueType.Formula:
                      this.renderFormula(f, d)
                      break
                    case l.ValueType.Merge:
                  }
                  f.closeNode()
                }
              }
              parseOpen(f) {
                if (this.parser) return (this.parser.parseOpen(f), !0)
                switch (f.name) {
                  case 'c':
                    return (
                      (this.model = { address: f.attributes.r }),
                      (this.t = f.attributes.t),
                      f.attributes.s && (this.model.styleId = parseInt(f.attributes.s, 10)),
                      !0
                    )
                  case 'f':
                    return (
                      (this.currentNode = 'f'),
                      (this.model.si = f.attributes.si),
                      (this.model.shareType = f.attributes.t),
                      (this.model.ref = f.attributes.ref),
                      !0
                    )
                  case 'v':
                    return ((this.currentNode = 'v'), !0)
                  case 't':
                    return ((this.currentNode = 't'), !0)
                  case 'r':
                    return ((this.parser = this.richTextXForm), this.parser.parseOpen(f), !0)
                  default:
                    return !1
                }
              }
              parseText(f) {
                if (this.parser) this.parser.parseText(f)
                else
                  switch (this.currentNode) {
                    case 'f':
                      this.model.formula = this.model.formula ? this.model.formula + f : f
                      break
                    case 'v':
                    case 't':
                      this.model.value && this.model.value.richText
                        ? (this.model.value.richText.text = this.model.value.richText.text
                            ? this.model.value.richText.text + f
                            : f)
                        : (this.model.value = this.model.value ? this.model.value + f : f)
                  }
              }
              parseClose(f) {
                switch (f) {
                  case 'c': {
                    const { model: d } = this
                    if (d.formula || d.shareType)
                      ((d.type = l.ValueType.Formula),
                        d.value &&
                          (this.t === 'str'
                            ? (d.result = s.xmlDecode(d.value))
                            : this.t === 'b'
                              ? (d.result = parseInt(d.value, 10) !== 0)
                              : this.t === 'e'
                                ? (d.result = { error: d.value })
                                : (d.result = parseFloat(d.value)),
                          (d.value = void 0)))
                    else if (d.value !== void 0)
                      switch (this.t) {
                        case 's':
                          ;((d.type = l.ValueType.String), (d.value = parseInt(d.value, 10)))
                          break
                        case 'str':
                          ;((d.type = l.ValueType.String), (d.value = s.xmlDecode(d.value)))
                          break
                        case 'inlineStr':
                          d.type = l.ValueType.String
                          break
                        case 'b':
                          ;((d.type = l.ValueType.Boolean), (d.value = parseInt(d.value, 10) !== 0))
                          break
                        case 'e':
                          ;((d.type = l.ValueType.Error), (d.value = { error: d.value }))
                          break
                        default:
                          ;((d.type = l.ValueType.Number), (d.value = parseFloat(d.value)))
                      }
                    else d.styleId ? (d.type = l.ValueType.Null) : (d.type = l.ValueType.Merge)
                    return !1
                  }
                  case 'f':
                  case 'v':
                  case 'is':
                    return ((this.currentNode = void 0), !0)
                  case 't':
                    return this.parser
                      ? (this.parser.parseClose(f), !0)
                      : ((this.currentNode = void 0), !0)
                  case 'r':
                    return (
                      (this.model.value = this.model.value || {}),
                      (this.model.value.richText = this.model.value.richText || []),
                      this.model.value.richText.push(this.parser.model),
                      (this.parser = void 0),
                      (this.currentNode = void 0),
                      !0
                    )
                  default:
                    return !!this.parser && (this.parser.parseClose(f), !0)
                }
              }
              reconcile(f, d) {
                const h = f.styleId && d.styles && d.styles.getStyleModel(f.styleId)
                switch (
                  (h && (f.style = h), f.styleId !== void 0 && (f.styleId = void 0), f.type)
                ) {
                  case l.ValueType.String:
                    ;(typeof f.value == 'number' &&
                      d.sharedStrings &&
                      (f.value = d.sharedStrings.getString(f.value)),
                      f.value.richText && (f.type = l.ValueType.RichText))
                    break
                  case l.ValueType.Number:
                    h &&
                      s.isDateFmt(h.numFmt) &&
                      ((f.type = l.ValueType.Date), (f.value = s.excelToDate(f.value, d.date1904)))
                    break
                  case l.ValueType.Formula:
                    ;(f.result !== void 0 &&
                      h &&
                      s.isDateFmt(h.numFmt) &&
                      (f.result = s.excelToDate(f.result, d.date1904)),
                      f.shareType === 'shared' &&
                        (f.ref
                          ? (d.formulae[f.si] = f.address)
                          : ((f.sharedFormula = d.formulae[f.si]), delete f.shareType),
                        delete f.si))
                }
                const p = d.hyperlinkMap[f.address]
                p &&
                  (f.type === l.ValueType.Formula
                    ? ((f.text = f.result), (f.result = void 0))
                    : ((f.text = f.value), (f.value = void 0)),
                  (f.type = l.ValueType.Hyperlink),
                  (f.hyperlink = p))
                const g = d.commentsMap && d.commentsMap[f.address]
                g && (f.comment = g)
              }
            }
          },
          {
            '../../../doc/enums': 7,
            '../../../doc/range': 10,
            '../../../utils/utils': 27,
            '../base-xform': 32,
            '../strings/rich-text-xform': 122,
          },
        ],
        74: [
          function (t, r, i) {
            const s = t('../../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'x14:cfIcon'
              }
              render(o, a) {
                o.leafNode(this.tag, { iconSet: a.iconSet, iconId: a.iconId })
              }
              parseOpen(o) {
                let { attributes: a } = o
                this.model = { iconSet: a.iconSet, iconId: s.toIntValue(a.iconId) }
              }
              parseClose(o) {
                return o !== this.tag
              }
            }
          },
          { '../../base-xform': 32 },
        ],
        75: [
          function (t, r, i) {
            const { v4: s } = t('uuid'),
              o = t('../../base-xform'),
              a = t('../../composite-xform'),
              l = t('./databar-ext-xform'),
              c = t('./icon-set-ext-xform'),
              u = { '3Triangles': !0, '3Stars': !0, '5Boxes': !0 }
            class f extends a {
              constructor() {
                ;(super(),
                  (this.map = {
                    'x14:dataBar': (this.databarXform = new l()),
                    'x14:iconSet': (this.iconSetXform = new c()),
                  }))
              }
              get tag() {
                return 'x14:cfRule'
              }
              static isExt(h) {
                return h.type === 'dataBar'
                  ? l.isExt(h)
                  : !(h.type !== 'iconSet' || (!h.custom && !u[h.iconSet]))
              }
              prepare(h) {
                f.isExt(h) && (h.x14Id = `{${s()}}`.toUpperCase())
              }
              render(h, p) {
                if (f.isExt(p))
                  switch (p.type) {
                    case 'dataBar':
                      this.renderDataBar(h, p)
                      break
                    case 'iconSet':
                      this.renderIconSet(h, p)
                  }
              }
              renderDataBar(h, p) {
                ;(h.openNode(this.tag, { type: 'dataBar', id: p.x14Id }),
                  this.databarXform.render(h, p),
                  h.closeNode())
              }
              renderIconSet(h, p) {
                ;(h.openNode(this.tag, {
                  type: 'iconSet',
                  priority: p.priority,
                  id: p.x14Id || `{${s()}}`,
                }),
                  this.iconSetXform.render(h, p),
                  h.closeNode())
              }
              createNewModel(h) {
                let { attributes: p } = h
                return { type: p.type, x14Id: p.id, priority: o.toIntValue(p.priority) }
              }
              onParserClose(h, p) {
                Object.assign(this.model, p.model)
              }
            }
            r.exports = f
          },
          {
            '../../base-xform': 32,
            '../../composite-xform': 48,
            './databar-ext-xform': 79,
            './icon-set-ext-xform': 81,
            uuid: 528,
          },
        ],
        76: [
          function (t, r, i) {
            const s = t('../../composite-xform'),
              o = t('./f-ext-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { 'xm:f': (this.fExtXform = new o()) }))
              }
              get tag() {
                return 'x14:cfvo'
              }
              render(a, l) {
                ;(a.openNode(this.tag, { type: l.type }),
                  l.value !== void 0 && this.fExtXform.render(a, l.value),
                  a.closeNode())
              }
              createNewModel(a) {
                return { type: a.attributes.type }
              }
              onParserClose(a, l) {
                switch (a) {
                  case 'xm:f':
                    this.model.value = l.model ? parseFloat(l.model) : 0
                }
              }
            }
          },
          { '../../composite-xform': 48, './f-ext-xform': 80 },
        ],
        77: [
          function (t, r, i) {
            const s = t('../../composite-xform'),
              o = t('./sqref-ext-xform'),
              a = t('./cf-rule-ext-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    'xm:sqref': (this.sqRef = new o()),
                    'x14:cfRule': (this.cfRule = new a()),
                  }))
              }
              get tag() {
                return 'x14:conditionalFormatting'
              }
              prepare(l, c) {
                l.rules.forEach((u) => {
                  this.cfRule.prepare(u, c)
                })
              }
              render(l, c) {
                c.rules.some(a.isExt) &&
                  (l.openNode(this.tag, {
                    'xmlns:xm': 'http://schemas.microsoft.com/office/excel/2006/main',
                  }),
                  c.rules.filter(a.isExt).forEach((u) => this.cfRule.render(l, u)),
                  this.sqRef.render(l, c.ref),
                  l.closeNode())
              }
              createNewModel() {
                return { rules: [] }
              }
              onParserClose(l, c) {
                switch (l) {
                  case 'xm:sqref':
                    this.model.ref = c.model
                    break
                  case 'x14:cfRule':
                    this.model.rules.push(c.model)
                }
              }
            }
          },
          { '../../composite-xform': 48, './cf-rule-ext-xform': 75, './sqref-ext-xform': 82 },
        ],
        78: [
          function (t, r, i) {
            const s = t('../../composite-xform'),
              o = t('./cf-rule-ext-xform'),
              a = t('./conditional-formatting-ext-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { 'x14:conditionalFormatting': (this.cfXform = new a()) }))
              }
              get tag() {
                return 'x14:conditionalFormattings'
              }
              hasContent(l) {
                return (
                  l.hasExtContent === void 0 &&
                    (l.hasExtContent = l.some((c) => c.rules.some(o.isExt))),
                  l.hasExtContent
                )
              }
              prepare(l, c) {
                l.forEach((u) => {
                  this.cfXform.prepare(u, c)
                })
              }
              render(l, c) {
                this.hasContent(c) &&
                  (l.openNode(this.tag), c.forEach((u) => this.cfXform.render(l, u)), l.closeNode())
              }
              createNewModel() {
                return []
              }
              onParserClose(l, c) {
                this.model.push(c.model)
              }
            }
          },
          {
            '../../composite-xform': 48,
            './cf-rule-ext-xform': 75,
            './conditional-formatting-ext-xform': 77,
          },
        ],
        79: [
          function (t, r, i) {
            const s = t('../../base-xform'),
              o = t('../../composite-xform'),
              a = t('../../style/color-xform'),
              l = t('./cfvo-ext-xform')
            r.exports = class extends o {
              constructor() {
                ;(super(),
                  (this.map = {
                    'x14:cfvo': (this.cfvoXform = new l()),
                    'x14:borderColor': (this.borderColorXform = new a('x14:borderColor')),
                    'x14:negativeBorderColor': (this.negativeBorderColorXform = new a(
                      'x14:negativeBorderColor',
                    )),
                    'x14:negativeFillColor': (this.negativeFillColorXform = new a(
                      'x14:negativeFillColor',
                    )),
                    'x14:axisColor': (this.axisColorXform = new a('x14:axisColor')),
                  }))
              }
              static isExt(c) {
                return !c.gradient
              }
              get tag() {
                return 'x14:dataBar'
              }
              render(c, u) {
                ;(c.openNode(this.tag, {
                  minLength: s.toIntAttribute(u.minLength, 0, !0),
                  maxLength: s.toIntAttribute(u.maxLength, 100, !0),
                  border: s.toBoolAttribute(u.border, !1),
                  gradient: s.toBoolAttribute(u.gradient, !0),
                  negativeBarColorSameAsPositive: s.toBoolAttribute(
                    u.negativeBarColorSameAsPositive,
                    !0,
                  ),
                  negativeBarBorderColorSameAsPositive: s.toBoolAttribute(
                    u.negativeBarBorderColorSameAsPositive,
                    !0,
                  ),
                  axisPosition: s.toAttribute(u.axisPosition, 'auto'),
                  direction: s.toAttribute(u.direction, 'leftToRight'),
                }),
                  u.cfvo.forEach((f) => {
                    this.cfvoXform.render(c, f)
                  }),
                  this.borderColorXform.render(c, u.borderColor),
                  this.negativeBorderColorXform.render(c, u.negativeBorderColor),
                  this.negativeFillColorXform.render(c, u.negativeFillColor),
                  this.axisColorXform.render(c, u.axisColor),
                  c.closeNode())
              }
              createNewModel(c) {
                let { attributes: u } = c
                return {
                  cfvo: [],
                  minLength: s.toIntValue(u.minLength, 0),
                  maxLength: s.toIntValue(u.maxLength, 100),
                  border: s.toBoolValue(u.border, !1),
                  gradient: s.toBoolValue(u.gradient, !0),
                  negativeBarColorSameAsPositive: s.toBoolValue(
                    u.negativeBarColorSameAsPositive,
                    !0,
                  ),
                  negativeBarBorderColorSameAsPositive: s.toBoolValue(
                    u.negativeBarBorderColorSameAsPositive,
                    !0,
                  ),
                  axisPosition: s.toStringValue(u.axisPosition, 'auto'),
                  direction: s.toStringValue(u.direction, 'leftToRight'),
                }
              }
              onParserClose(c, u) {
                const [, f] = c.split(':')
                switch (f) {
                  case 'cfvo':
                    this.model.cfvo.push(u.model)
                    break
                  default:
                    this.model[f] = u.model
                }
              }
            }
          },
          {
            '../../base-xform': 32,
            '../../composite-xform': 48,
            '../../style/color-xform': 128,
            './cfvo-ext-xform': 76,
          },
        ],
        80: [
          function (t, r, i) {
            const s = t('../../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'xm:f'
              }
              render(o, a) {
                o.leafNode(this.tag, null, a)
              }
              parseOpen() {
                this.model = ''
              }
              parseText(o) {
                this.model += o
              }
              parseClose(o) {
                return o !== this.tag
              }
            }
          },
          { '../../base-xform': 32 },
        ],
        81: [
          function (t, r, i) {
            const s = t('../../base-xform'),
              o = t('../../composite-xform'),
              a = t('./cfvo-ext-xform'),
              l = t('./cf-icon-ext-xform')
            r.exports = class extends o {
              constructor() {
                ;(super(),
                  (this.map = {
                    'x14:cfvo': (this.cfvoXform = new a()),
                    'x14:cfIcon': (this.cfIconXform = new l()),
                  }))
              }
              get tag() {
                return 'x14:iconSet'
              }
              render(c, u) {
                ;(c.openNode(this.tag, {
                  iconSet: s.toStringAttribute(u.iconSet),
                  reverse: s.toBoolAttribute(u.reverse, !1),
                  showValue: s.toBoolAttribute(u.showValue, !0),
                  custom: s.toBoolAttribute(u.icons, !1),
                }),
                  u.cfvo.forEach((f) => {
                    this.cfvoXform.render(c, f)
                  }),
                  u.icons &&
                    u.icons.forEach((f, d) => {
                      ;((f.iconId = d), this.cfIconXform.render(c, f))
                    }),
                  c.closeNode())
              }
              createNewModel(c) {
                let { attributes: u } = c
                return {
                  cfvo: [],
                  iconSet: s.toStringValue(u.iconSet, '3TrafficLights'),
                  reverse: s.toBoolValue(u.reverse, !1),
                  showValue: s.toBoolValue(u.showValue, !0),
                }
              }
              onParserClose(c, u) {
                const [, f] = c.split(':')
                switch (f) {
                  case 'cfvo':
                    this.model.cfvo.push(u.model)
                    break
                  case 'cfIcon':
                    ;(this.model.icons || (this.model.icons = []), this.model.icons.push(u.model))
                    break
                  default:
                    this.model[f] = u.model
                }
              }
            }
          },
          {
            '../../base-xform': 32,
            '../../composite-xform': 48,
            './cf-icon-ext-xform': 74,
            './cfvo-ext-xform': 76,
          },
        ],
        82: [
          function (t, r, i) {
            const s = t('../../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'xm:sqref'
              }
              render(o, a) {
                o.leafNode(this.tag, null, a)
              }
              parseOpen() {
                this.model = ''
              }
              parseText(o) {
                this.model += o
              }
              parseClose(o) {
                return o !== this.tag
              }
            }
          },
          { '../../base-xform': 32 },
        ],
        83: [
          function (t, r, i) {
            const s = t('../../base-xform'),
              o = t('../../composite-xform'),
              a = t('../../../../doc/range'),
              l = t('./databar-xform'),
              c = t('./ext-lst-ref-xform'),
              u = t('./formula-xform'),
              f = t('./color-scale-xform'),
              d = t('./icon-set-xform'),
              h = { '3Triangles': !0, '3Stars': !0, '5Boxes': !0 },
              p = (m) => {
                const { type: y, operator: b } = m
                switch (y) {
                  case 'containsText':
                  case 'containsBlanks':
                  case 'notContainsBlanks':
                  case 'containsErrors':
                  case 'notContainsErrors':
                    return { type: 'containsText', operator: y }
                  default:
                    return { type: y, operator: b }
                }
              }
            class g extends o {
              constructor() {
                ;(super(),
                  (this.map = {
                    dataBar: (this.databarXform = new l()),
                    extLst: (this.extLstRefXform = new c()),
                    formula: (this.formulaXform = new u()),
                    colorScale: (this.colorScaleXform = new f()),
                    iconSet: (this.iconSetXform = new d()),
                  }))
              }
              get tag() {
                return 'cfRule'
              }
              static isPrimitive(y) {
                return y.type !== 'iconSet' || (!y.custom && !h[y.iconSet])
              }
              render(y, b) {
                switch (b.type) {
                  case 'expression':
                    this.renderExpression(y, b)
                    break
                  case 'cellIs':
                    this.renderCellIs(y, b)
                    break
                  case 'top10':
                    this.renderTop10(y, b)
                    break
                  case 'aboveAverage':
                    this.renderAboveAverage(y, b)
                    break
                  case 'dataBar':
                    this.renderDataBar(y, b)
                    break
                  case 'colorScale':
                    this.renderColorScale(y, b)
                    break
                  case 'iconSet':
                    this.renderIconSet(y, b)
                    break
                  case 'containsText':
                    this.renderText(y, b)
                    break
                  case 'timePeriod':
                    this.renderTimePeriod(y, b)
                }
              }
              renderExpression(y, b) {
                ;(y.openNode(this.tag, {
                  type: 'expression',
                  dxfId: b.dxfId,
                  priority: b.priority,
                }),
                  this.formulaXform.render(y, b.formulae[0]),
                  y.closeNode())
              }
              renderCellIs(y, b) {
                ;(y.openNode(this.tag, {
                  type: 'cellIs',
                  dxfId: b.dxfId,
                  priority: b.priority,
                  operator: b.operator,
                }),
                  b.formulae.forEach((w) => {
                    this.formulaXform.render(y, w)
                  }),
                  y.closeNode())
              }
              renderTop10(y, b) {
                y.leafNode(this.tag, {
                  type: 'top10',
                  dxfId: b.dxfId,
                  priority: b.priority,
                  percent: s.toBoolAttribute(b.percent, !1),
                  bottom: s.toBoolAttribute(b.bottom, !1),
                  rank: s.toIntValue(b.rank, 10, !0),
                })
              }
              renderAboveAverage(y, b) {
                y.leafNode(this.tag, {
                  type: 'aboveAverage',
                  dxfId: b.dxfId,
                  priority: b.priority,
                  aboveAverage: s.toBoolAttribute(b.aboveAverage, !0),
                })
              }
              renderDataBar(y, b) {
                ;(y.openNode(this.tag, { type: 'dataBar', priority: b.priority }),
                  this.databarXform.render(y, b),
                  this.extLstRefXform.render(y, b),
                  y.closeNode())
              }
              renderColorScale(y, b) {
                ;(y.openNode(this.tag, { type: 'colorScale', priority: b.priority }),
                  this.colorScaleXform.render(y, b),
                  y.closeNode())
              }
              renderIconSet(y, b) {
                g.isPrimitive(b) &&
                  (y.openNode(this.tag, { type: 'iconSet', priority: b.priority }),
                  this.iconSetXform.render(y, b),
                  y.closeNode())
              }
              renderText(y, b) {
                y.openNode(this.tag, {
                  type: b.operator,
                  dxfId: b.dxfId,
                  priority: b.priority,
                  operator: s.toStringAttribute(b.operator, 'containsText'),
                })
                const w = ((C) => {
                  if (C.formulae && C.formulae[0]) return C.formulae[0]
                  const T = new a(C.ref),
                    { tl: I } = T
                  switch (C.operator) {
                    case 'containsText':
                      return `NOT(ISERROR(SEARCH("${C.text}",${I})))`
                    case 'containsBlanks':
                      return `LEN(TRIM(${I}))=0`
                    case 'notContainsBlanks':
                      return `LEN(TRIM(${I}))>0`
                    case 'containsErrors':
                      return `ISERROR(${I})`
                    case 'notContainsErrors':
                      return `NOT(ISERROR(${I}))`
                    default:
                      return
                  }
                })(b)
                ;(w && this.formulaXform.render(y, w), y.closeNode())
              }
              renderTimePeriod(y, b) {
                y.openNode(this.tag, {
                  type: 'timePeriod',
                  dxfId: b.dxfId,
                  priority: b.priority,
                  timePeriod: b.timePeriod,
                })
                const w = ((C) => {
                  if (C.formulae && C.formulae[0]) return C.formulae[0]
                  const T = new a(C.ref),
                    { tl: I } = T
                  switch (C.timePeriod) {
                    case 'thisWeek':
                      return `AND(TODAY()-ROUNDDOWN(${I},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${I},0)-TODAY()<=7-WEEKDAY(TODAY()))`
                    case 'lastWeek':
                      return `AND(TODAY()-ROUNDDOWN(${I},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${I},0)<(WEEKDAY(TODAY())+7))`
                    case 'nextWeek':
                      return `AND(ROUNDDOWN(${I},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${I},0)-TODAY()<(15-WEEKDAY(TODAY())))`
                    case 'yesterday':
                      return `FLOOR(${I},1)=TODAY()-1`
                    case 'today':
                      return `FLOOR(${I},1)=TODAY()`
                    case 'tomorrow':
                      return `FLOOR(${I},1)=TODAY()+1`
                    case 'last7Days':
                      return `AND(TODAY()-FLOOR(${I},1)<=6,FLOOR(${I},1)<=TODAY())`
                    case 'lastMonth':
                      return `AND(MONTH(${I})=MONTH(EDATE(TODAY(),0-1)),YEAR(${I})=YEAR(EDATE(TODAY(),0-1)))`
                    case 'thisMonth':
                      return `AND(MONTH(${I})=MONTH(TODAY()),YEAR(${I})=YEAR(TODAY()))`
                    case 'nextMonth':
                      return `AND(MONTH(${I})=MONTH(EDATE(TODAY(),0+1)),YEAR(${I})=YEAR(EDATE(TODAY(),0+1)))`
                    default:
                      return
                  }
                })(b)
                ;(w && this.formulaXform.render(y, w), y.closeNode())
              }
              createNewModel(y) {
                let { attributes: b } = y
                return {
                  ...p(b),
                  dxfId: s.toIntValue(b.dxfId),
                  priority: s.toIntValue(b.priority),
                  timePeriod: b.timePeriod,
                  percent: s.toBoolValue(b.percent),
                  bottom: s.toBoolValue(b.bottom),
                  rank: s.toIntValue(b.rank),
                  aboveAverage: s.toBoolValue(b.aboveAverage),
                }
              }
              onParserClose(y, b) {
                switch (y) {
                  case 'dataBar':
                  case 'extLst':
                  case 'colorScale':
                  case 'iconSet':
                    Object.assign(this.model, b.model)
                    break
                  case 'formula':
                    ;((this.model.formulae = this.model.formulae || []),
                      this.model.formulae.push(b.model))
                }
              }
            }
            r.exports = g
          },
          {
            '../../../../doc/range': 10,
            '../../base-xform': 32,
            '../../composite-xform': 48,
            './color-scale-xform': 85,
            './databar-xform': 88,
            './ext-lst-ref-xform': 89,
            './formula-xform': 90,
            './icon-set-xform': 91,
          },
        ],
        84: [
          function (t, r, i) {
            const s = t('../../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'cfvo'
              }
              render(o, a) {
                o.leafNode(this.tag, { type: a.type, val: a.value })
              }
              parseOpen(o) {
                this.model = { type: o.attributes.type, value: s.toFloatValue(o.attributes.val) }
              }
              parseClose(o) {
                return o !== this.tag
              }
            }
          },
          { '../../base-xform': 32 },
        ],
        85: [
          function (t, r, i) {
            const s = t('../../composite-xform'),
              o = t('../../style/color-xform'),
              a = t('./cfvo-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    cfvo: (this.cfvoXform = new a()),
                    color: (this.colorXform = new o()),
                  }))
              }
              get tag() {
                return 'colorScale'
              }
              render(l, c) {
                ;(l.openNode(this.tag),
                  c.cfvo.forEach((u) => {
                    this.cfvoXform.render(l, u)
                  }),
                  c.color.forEach((u) => {
                    this.colorXform.render(l, u)
                  }),
                  l.closeNode())
              }
              createNewModel(l) {
                return { cfvo: [], color: [] }
              }
              onParserClose(l, c) {
                this.model[l].push(c.model)
              }
            }
          },
          { '../../composite-xform': 48, '../../style/color-xform': 128, './cfvo-xform': 84 },
        ],
        86: [
          function (t, r, i) {
            const s = t('../../composite-xform'),
              o = t('./cf-rule-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { cfRule: new o() }))
              }
              get tag() {
                return 'conditionalFormatting'
              }
              render(a, l) {
                l.rules.some(o.isPrimitive) &&
                  (a.openNode(this.tag, { sqref: l.ref }),
                  l.rules.forEach((c) => {
                    o.isPrimitive(c) && ((c.ref = l.ref), this.map.cfRule.render(a, c))
                  }),
                  a.closeNode())
              }
              createNewModel(a) {
                let { attributes: l } = a
                return { ref: l.sqref, rules: [] }
              }
              onParserClose(a, l) {
                this.model.rules.push(l.model)
              }
            }
          },
          { '../../composite-xform': 48, './cf-rule-xform': 83 },
        ],
        87: [
          function (t, r, i) {
            const s = t('../../base-xform'),
              o = t('./conditional-formatting-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.cfXform = new o()))
              }
              get tag() {
                return 'conditionalFormatting'
              }
              reset() {
                this.model = []
              }
              prepare(a, l) {
                let c = a.reduce((u, f) => Math.max(u, ...f.rules.map((d) => d.priority || 0)), 1)
                a.forEach((u) => {
                  u.rules.forEach((f) => {
                    ;(f.priority || (f.priority = c++),
                      f.style && (f.dxfId = l.styles.addDxfStyle(f.style)))
                  })
                })
              }
              render(a, l) {
                l.forEach((c) => {
                  this.cfXform.render(a, c)
                })
              }
              parseOpen(a) {
                if (this.parser) return (this.parser.parseOpen(a), !0)
                switch (a.name) {
                  case 'conditionalFormatting':
                    return ((this.parser = this.cfXform), this.parser.parseOpen(a), !0)
                  default:
                    return !1
                }
              }
              parseText(a) {
                this.parser && this.parser.parseText(a)
              }
              parseClose(a) {
                return (
                  !!this.parser &&
                  (!!this.parser.parseClose(a) ||
                    (this.model.push(this.parser.model), (this.parser = void 0), !1))
                )
              }
              reconcile(a, l) {
                a.forEach((c) => {
                  c.rules.forEach((u) => {
                    u.dxfId !== void 0 &&
                      ((u.style = l.styles.getDxfStyle(u.dxfId)), delete u.dxfId)
                  })
                })
              }
            }
          },
          { '../../base-xform': 32, './conditional-formatting-xform': 86 },
        ],
        88: [
          function (t, r, i) {
            const s = t('../../composite-xform'),
              o = t('../../style/color-xform'),
              a = t('./cfvo-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    cfvo: (this.cfvoXform = new a()),
                    color: (this.colorXform = new o()),
                  }))
              }
              get tag() {
                return 'dataBar'
              }
              render(l, c) {
                ;(l.openNode(this.tag),
                  c.cfvo.forEach((u) => {
                    this.cfvoXform.render(l, u)
                  }),
                  this.colorXform.render(l, c.color),
                  l.closeNode())
              }
              createNewModel() {
                return { cfvo: [] }
              }
              onParserClose(l, c) {
                switch (l) {
                  case 'cfvo':
                    this.model.cfvo.push(c.model)
                    break
                  case 'color':
                    this.model.color = c.model
                }
              }
            }
          },
          { '../../composite-xform': 48, '../../style/color-xform': 128, './cfvo-xform': 84 },
        ],
        89: [
          function (t, r, i) {
            const s = t('../../base-xform'),
              o = t('../../composite-xform')
            class a extends s {
              get tag() {
                return 'x14:id'
              }
              render(u, f) {
                u.leafNode(this.tag, null, f)
              }
              parseOpen() {
                this.model = ''
              }
              parseText(u) {
                this.model += u
              }
              parseClose(u) {
                return u !== this.tag
              }
            }
            class l extends o {
              constructor() {
                ;(super(), (this.map = { 'x14:id': (this.idXform = new a()) }))
              }
              get tag() {
                return 'ext'
              }
              render(u, f) {
                ;(u.openNode(this.tag, {
                  uri: '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}',
                  'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
                }),
                  this.idXform.render(u, f.x14Id),
                  u.closeNode())
              }
              createNewModel() {
                return {}
              }
              onParserClose(u, f) {
                this.model.x14Id = f.model
              }
            }
            r.exports = class extends o {
              constructor() {
                ;(super(), (this.map = { ext: new l() }))
              }
              get tag() {
                return 'extLst'
              }
              render(c, u) {
                ;(c.openNode(this.tag), this.map.ext.render(c, u), c.closeNode())
              }
              createNewModel() {
                return {}
              }
              onParserClose(c, u) {
                Object.assign(this.model, u.model)
              }
            }
          },
          { '../../base-xform': 32, '../../composite-xform': 48 },
        ],
        90: [
          function (t, r, i) {
            const s = t('../../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'formula'
              }
              render(o, a) {
                o.leafNode(this.tag, null, a)
              }
              parseOpen() {
                this.model = ''
              }
              parseText(o) {
                this.model += o
              }
              parseClose(o) {
                return o !== this.tag
              }
            }
          },
          { '../../base-xform': 32 },
        ],
        91: [
          function (t, r, i) {
            const s = t('../../base-xform'),
              o = t('../../composite-xform'),
              a = t('./cfvo-xform')
            r.exports = class extends o {
              constructor() {
                ;(super(), (this.map = { cfvo: (this.cfvoXform = new a()) }))
              }
              get tag() {
                return 'iconSet'
              }
              render(l, c) {
                ;(l.openNode(this.tag, {
                  iconSet: s.toStringAttribute(c.iconSet, '3TrafficLights'),
                  reverse: s.toBoolAttribute(c.reverse, !1),
                  showValue: s.toBoolAttribute(c.showValue, !0),
                }),
                  c.cfvo.forEach((u) => {
                    this.cfvoXform.render(l, u)
                  }),
                  l.closeNode())
              }
              createNewModel(l) {
                let { attributes: c } = l
                return {
                  iconSet: s.toStringValue(c.iconSet, '3TrafficLights'),
                  reverse: s.toBoolValue(c.reverse),
                  showValue: s.toBoolValue(c.showValue),
                  cfvo: [],
                }
              }
              onParserClose(l, c) {
                this.model[l].push(c.model)
              }
            }
          },
          { '../../base-xform': 32, '../../composite-xform': 48, './cfvo-xform': 84 },
        ],
        92: [
          function (t, r, i) {
            const s = t('../../../utils/utils'),
              o = t('../base-xform')
            r.exports = class extends o {
              get tag() {
                return 'col'
              }
              prepare(a, l) {
                const c = l.styles.addStyleModel(a.style || {})
                c && (a.styleId = c)
              }
              render(a, l) {
                ;(a.openNode('col'),
                  a.addAttribute('min', l.min),
                  a.addAttribute('max', l.max),
                  l.width && a.addAttribute('width', l.width),
                  l.styleId && a.addAttribute('style', l.styleId),
                  l.hidden && a.addAttribute('hidden', '1'),
                  l.bestFit && a.addAttribute('bestFit', '1'),
                  l.outlineLevel && a.addAttribute('outlineLevel', l.outlineLevel),
                  l.collapsed && a.addAttribute('collapsed', '1'),
                  a.addAttribute('customWidth', '1'),
                  a.closeNode())
              }
              parseOpen(a) {
                if (a.name === 'col') {
                  const l = (this.model = {
                    min: parseInt(a.attributes.min || '0', 10),
                    max: parseInt(a.attributes.max || '0', 10),
                    width:
                      a.attributes.width === void 0
                        ? void 0
                        : parseFloat(a.attributes.width || '0'),
                  })
                  return (
                    a.attributes.style && (l.styleId = parseInt(a.attributes.style, 10)),
                    s.parseBoolean(a.attributes.hidden) && (l.hidden = !0),
                    s.parseBoolean(a.attributes.bestFit) && (l.bestFit = !0),
                    a.attributes.outlineLevel &&
                      (l.outlineLevel = parseInt(a.attributes.outlineLevel, 10)),
                    s.parseBoolean(a.attributes.collapsed) && (l.collapsed = !0),
                    !0
                  )
                }
                return !1
              }
              parseText() {}
              parseClose() {
                return !1
              }
              reconcile(a, l) {
                a.styleId && (a.style = l.styles.getStyleModel(a.styleId))
              }
            }
          },
          { '../../../utils/utils': 27, '../base-xform': 32 },
        ],
        93: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../../../utils/utils'),
              a = t('../../../utils/col-cache'),
              l = t('../base-xform'),
              c = t('../../../doc/range')
            function u(d, h, p, g) {
              const m = h[p]
              m !== void 0 ? (d[p] = m) : g !== void 0 && (d[p] = g)
            }
            function f(d, h, p, g) {
              const m = h[p]
              m !== void 0 && (d[p] = o.parseBoolean(m))
            }
            r.exports = class extends l {
              get tag() {
                return 'dataValidations'
              }
              render(d, h) {
                const p = (function (g) {
                  const m = s
                      .map(g, (w, C) => ({ address: C, dataValidation: w, marked: !1 }))
                      .sort((w, C) => s.strcmp(w.address, C.address)),
                    y = s.keyBy(m, 'address'),
                    b = (w, C, T) => {
                      for (let I = 0; I < C; I++) {
                        const B = a.encodeAddress(w.row + I, T)
                        if (!g[B] || !s.isEqual(g[w.address], g[B])) return !1
                      }
                      return !0
                    }
                  return m
                    .map((w) => {
                      if (!w.marked) {
                        const C = a.decodeEx(w.address)
                        if (C.dimensions)
                          return (
                            (y[C.dimensions].marked = !0),
                            { ...w.dataValidation, sqref: w.address }
                          )
                        let T = 1,
                          I = a.encodeAddress(C.row + T, C.col)
                        for (; g[I] && s.isEqual(w.dataValidation, g[I]); )
                          (T++, (I = a.encodeAddress(C.row + T, C.col)))
                        let B = 1
                        for (; b(C, T, C.col + B); ) B++
                        for (let E = 0; E < T; E++)
                          for (let O = 0; O < B; O++)
                            ((I = a.encodeAddress(C.row + E, C.col + O)), (y[I].marked = !0))
                        if (T > 1 || B > 1) {
                          const E = C.row + (T - 1),
                            O = C.col + (B - 1)
                          return {
                            ...w.dataValidation,
                            sqref: `${w.address}:${a.encodeAddress(E, O)}`,
                          }
                        }
                        return { ...w.dataValidation, sqref: w.address }
                      }
                      return null
                    })
                    .filter(Boolean)
                })(h)
                p.length &&
                  (d.openNode('dataValidations', { count: p.length }),
                  p.forEach((g) => {
                    ;(d.openNode('dataValidation'),
                      g.type !== 'any' &&
                        (d.addAttribute('type', g.type),
                        g.operator &&
                          g.type !== 'list' &&
                          g.operator !== 'between' &&
                          d.addAttribute('operator', g.operator),
                        g.allowBlank && d.addAttribute('allowBlank', '1')),
                      g.showInputMessage && d.addAttribute('showInputMessage', '1'),
                      g.promptTitle && d.addAttribute('promptTitle', g.promptTitle),
                      g.prompt && d.addAttribute('prompt', g.prompt),
                      g.showErrorMessage && d.addAttribute('showErrorMessage', '1'),
                      g.errorStyle && d.addAttribute('errorStyle', g.errorStyle),
                      g.errorTitle && d.addAttribute('errorTitle', g.errorTitle),
                      g.error && d.addAttribute('error', g.error),
                      d.addAttribute('sqref', g.sqref),
                      (g.formulae || []).forEach((m, y) => {
                        ;(d.openNode('formula' + (y + 1)),
                          g.type === 'date'
                            ? d.writeText(o.dateToExcel(new Date(m)))
                            : d.writeText(m),
                          d.closeNode())
                      }),
                      d.closeNode())
                  }),
                  d.closeNode())
              }
              parseOpen(d) {
                switch (d.name) {
                  case 'dataValidations':
                    return ((this.model = {}), !0)
                  case 'dataValidation': {
                    this._address = d.attributes.sqref
                    const h = { type: d.attributes.type || 'any', formulae: [] }
                    switch (
                      (d.attributes.type && f(h, d.attributes, 'allowBlank'),
                      f(h, d.attributes, 'showInputMessage'),
                      f(h, d.attributes, 'showErrorMessage'),
                      h.type)
                    ) {
                      case 'any':
                      case 'list':
                      case 'custom':
                        break
                      default:
                        u(h, d.attributes, 'operator', 'between')
                    }
                    return (
                      u(h, d.attributes, 'promptTitle'),
                      u(h, d.attributes, 'prompt'),
                      u(h, d.attributes, 'errorStyle'),
                      u(h, d.attributes, 'errorTitle'),
                      u(h, d.attributes, 'error'),
                      (this._dataValidation = h),
                      !0
                    )
                  }
                  case 'formula1':
                  case 'formula2':
                    return ((this._formula = []), !0)
                  default:
                    return !1
                }
              }
              parseText(d) {
                this._formula && this._formula.push(d)
              }
              parseClose(d) {
                switch (d) {
                  case 'dataValidations':
                    return !1
                  case 'dataValidation':
                    return (
                      (this._dataValidation.formulae && this._dataValidation.formulae.length) ||
                        (delete this._dataValidation.formulae,
                        delete this._dataValidation.operator),
                      (this._address.split(/\s+/g) || []).forEach((h) => {
                        h.includes(':')
                          ? new c(h).forEachAddress((p) => {
                              this.model[p] = this._dataValidation
                            })
                          : (this.model[h] = this._dataValidation)
                      }),
                      !0
                    )
                  case 'formula1':
                  case 'formula2': {
                    let h = this._formula.join('')
                    switch (this._dataValidation.type) {
                      case 'whole':
                      case 'textLength':
                        h = parseInt(h, 10)
                        break
                      case 'decimal':
                        h = parseFloat(h)
                        break
                      case 'date':
                        h = o.excelToDate(parseFloat(h))
                    }
                    return (this._dataValidation.formulae.push(h), (this._formula = void 0), !0)
                  }
                  default:
                    return !0
                }
              }
            }
          },
          {
            '../../../doc/range': 10,
            '../../../utils/col-cache': 19,
            '../../../utils/under-dash': 26,
            '../../../utils/utils': 27,
            '../base-xform': 32,
          },
        ],
        94: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'dimension'
              }
              render(o, a) {
                a && o.leafNode('dimension', { ref: a })
              }
              parseOpen(o) {
                return o.name === 'dimension' && ((this.model = o.attributes.ref), !0)
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        95: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'drawing'
              }
              render(o, a) {
                a && o.leafNode(this.tag, { 'r:id': a.rId })
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return ((this.model = { rId: o.attributes['r:id'] }), !0)
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        96: [
          function (t, r, i) {
            const s = t('../composite-xform'),
              o = t('./cf-ext/conditional-formattings-ext-xform')
            class a extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    'x14:conditionalFormattings': (this.conditionalFormattings = new o()),
                  }))
              }
              get tag() {
                return 'ext'
              }
              hasContent(c) {
                return this.conditionalFormattings.hasContent(c.conditionalFormattings)
              }
              prepare(c, u) {
                this.conditionalFormattings.prepare(c.conditionalFormattings, u)
              }
              render(c, u) {
                ;(c.openNode('ext', {
                  uri: '{78C0D931-6437-407d-A8EE-F0AAD7539E65}',
                  'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
                }),
                  this.conditionalFormattings.render(c, u.conditionalFormattings),
                  c.closeNode())
              }
              createNewModel() {
                return {}
              }
              onParserClose(c, u) {
                this.model[c] = u.model
              }
            }
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { ext: (this.ext = new a()) }))
              }
              get tag() {
                return 'extLst'
              }
              prepare(l, c) {
                this.ext.prepare(l, c)
              }
              hasContent(l) {
                return this.ext.hasContent(l)
              }
              render(l, c) {
                this.hasContent(c) && (l.openNode('extLst'), this.ext.render(l, c), l.closeNode())
              }
              createNewModel() {
                return {}
              }
              onParserClose(l, c) {
                Object.assign(this.model, c.model)
              }
            }
          },
          { '../composite-xform': 48, './cf-ext/conditional-formattings-ext-xform': 78 },
        ],
        97: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'headerFooter'
              }
              render(o, a) {
                if (a) {
                  o.addRollback()
                  let l = !1
                  ;(o.openNode('headerFooter'),
                    a.differentFirst && (o.addAttribute('differentFirst', '1'), (l = !0)),
                    a.differentOddEven && (o.addAttribute('differentOddEven', '1'), (l = !0)),
                    a.oddHeader &&
                      typeof a.oddHeader == 'string' &&
                      (o.leafNode('oddHeader', null, a.oddHeader), (l = !0)),
                    a.oddFooter &&
                      typeof a.oddFooter == 'string' &&
                      (o.leafNode('oddFooter', null, a.oddFooter), (l = !0)),
                    a.evenHeader &&
                      typeof a.evenHeader == 'string' &&
                      (o.leafNode('evenHeader', null, a.evenHeader), (l = !0)),
                    a.evenFooter &&
                      typeof a.evenFooter == 'string' &&
                      (o.leafNode('evenFooter', null, a.evenFooter), (l = !0)),
                    a.firstHeader &&
                      typeof a.firstHeader == 'string' &&
                      (o.leafNode('firstHeader', null, a.firstHeader), (l = !0)),
                    a.firstFooter &&
                      typeof a.firstFooter == 'string' &&
                      (o.leafNode('firstFooter', null, a.firstFooter), (l = !0)),
                    l ? (o.closeNode(), o.commit()) : o.rollback())
                }
              }
              parseOpen(o) {
                switch (o.name) {
                  case 'headerFooter':
                    return (
                      (this.model = {}),
                      o.attributes.differentFirst &&
                        (this.model.differentFirst =
                          parseInt(o.attributes.differentFirst, 0) === 1),
                      o.attributes.differentOddEven &&
                        (this.model.differentOddEven =
                          parseInt(o.attributes.differentOddEven, 0) === 1),
                      !0
                    )
                  case 'oddHeader':
                    return ((this.currentNode = 'oddHeader'), !0)
                  case 'oddFooter':
                    return ((this.currentNode = 'oddFooter'), !0)
                  case 'evenHeader':
                    return ((this.currentNode = 'evenHeader'), !0)
                  case 'evenFooter':
                    return ((this.currentNode = 'evenFooter'), !0)
                  case 'firstHeader':
                    return ((this.currentNode = 'firstHeader'), !0)
                  case 'firstFooter':
                    return ((this.currentNode = 'firstFooter'), !0)
                  default:
                    return !1
                }
              }
              parseText(o) {
                switch (this.currentNode) {
                  case 'oddHeader':
                    this.model.oddHeader = o
                    break
                  case 'oddFooter':
                    this.model.oddFooter = o
                    break
                  case 'evenHeader':
                    this.model.evenHeader = o
                    break
                  case 'evenFooter':
                    this.model.evenFooter = o
                    break
                  case 'firstHeader':
                    this.model.firstHeader = o
                    break
                  case 'firstFooter':
                    this.model.firstFooter = o
                }
              }
              parseClose() {
                switch (this.currentNode) {
                  case 'oddHeader':
                  case 'oddFooter':
                  case 'evenHeader':
                  case 'evenFooter':
                  case 'firstHeader':
                  case 'firstFooter':
                    return ((this.currentNode = void 0), !0)
                  default:
                    return !1
                }
              }
            }
          },
          { '../base-xform': 32 },
        ],
        98: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'hyperlink'
              }
              render(o, a) {
                this.isInternalLink(a)
                  ? o.leafNode('hyperlink', {
                      ref: a.address,
                      'r:id': a.rId,
                      tooltip: a.tooltip,
                      location: a.target,
                    })
                  : o.leafNode('hyperlink', { ref: a.address, 'r:id': a.rId, tooltip: a.tooltip })
              }
              parseOpen(o) {
                return (
                  o.name === 'hyperlink' &&
                  ((this.model = {
                    address: o.attributes.ref,
                    rId: o.attributes['r:id'],
                    tooltip: o.attributes.tooltip,
                  }),
                  o.attributes.location && (this.model.target = o.attributes.location),
                  !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
              isInternalLink(o) {
                return o.target && /^[^!]+![a-zA-Z]+[\d]+$/.test(o.target)
              }
            }
          },
          { '../base-xform': 32 },
        ],
        99: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'mergeCell'
              }
              render(o, a) {
                o.leafNode('mergeCell', { ref: a })
              }
              parseOpen(o) {
                return o.name === 'mergeCell' && ((this.model = o.attributes.ref), !0)
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        100: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../../../doc/range'),
              a = t('../../../utils/col-cache'),
              l = t('../../../doc/enums')
            r.exports = class {
              constructor() {
                this.merges = {}
              }
              add(c) {
                if (this.merges[c.master]) this.merges[c.master].expandToAddress(c.address)
                else {
                  const u = `${c.master}:${c.address}`
                  this.merges[c.master] = new o(u)
                }
              }
              get mergeCells() {
                return s.map(this.merges, (c) => c.range)
              }
              reconcile(c, u) {
                s.each(c, (f) => {
                  const d = a.decode(f)
                  for (let h = d.top; h <= d.bottom; h++) {
                    const p = u[h - 1]
                    for (let g = d.left; g <= d.right; g++) {
                      const m = p.cells[g - 1]
                      m
                        ? m.type === l.ValueType.Merge && (m.master = d.tl)
                        : (p.cells[g] = { type: l.ValueType.Null, address: a.encodeAddress(h, g) })
                    }
                  }
                })
              }
              getMasterAddress(c) {
                const u = this.hash[c]
                return u && u.tl
              }
            }
          },
          {
            '../../../doc/enums': 7,
            '../../../doc/range': 10,
            '../../../utils/col-cache': 19,
            '../../../utils/under-dash': 26,
          },
        ],
        101: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = (a) => a !== void 0
            r.exports = class extends s {
              get tag() {
                return 'outlinePr'
              }
              render(a, l) {
                return (
                  !(!l || (!o(l.summaryBelow) && !o(l.summaryRight))) &&
                  (a.leafNode(this.tag, {
                    summaryBelow: o(l.summaryBelow) ? Number(l.summaryBelow) : void 0,
                    summaryRight: o(l.summaryRight) ? Number(l.summaryRight) : void 0,
                  }),
                  !0)
                )
              }
              parseOpen(a) {
                return (
                  a.name === this.tag &&
                  ((this.model = {
                    summaryBelow: o(a.attributes.summaryBelow)
                      ? !!Number(a.attributes.summaryBelow)
                      : void 0,
                    summaryRight: o(a.attributes.summaryRight)
                      ? !!Number(a.attributes.summaryRight)
                      : void 0,
                  }),
                  !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        102: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'brk'
              }
              render(o, a) {
                o.leafNode('brk', a)
              }
              parseOpen(o) {
                return o.name === 'brk' && ((this.model = o.attributes.ref), !0)
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        103: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../base-xform')
            r.exports = class extends o {
              get tag() {
                return 'pageMargins'
              }
              render(a, l) {
                if (l) {
                  const c = {
                    left: l.left,
                    right: l.right,
                    top: l.top,
                    bottom: l.bottom,
                    header: l.header,
                    footer: l.footer,
                  }
                  s.some(c, (u) => u !== void 0) && a.leafNode(this.tag, c)
                }
              }
              parseOpen(a) {
                switch (a.name) {
                  case this.tag:
                    return (
                      (this.model = {
                        left: parseFloat(a.attributes.left || 0.7),
                        right: parseFloat(a.attributes.right || 0.7),
                        top: parseFloat(a.attributes.top || 0.75),
                        bottom: parseFloat(a.attributes.bottom || 0.75),
                        header: parseFloat(a.attributes.header || 0.3),
                        footer: parseFloat(a.attributes.footer || 0.3),
                      }),
                      !0
                    )
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../../utils/under-dash': 26, '../base-xform': 32 },
        ],
        104: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'pageSetUpPr'
              }
              render(o, a) {
                return (
                  !(!a || !a.fitToPage) &&
                  (o.leafNode(this.tag, { fitToPage: a.fitToPage ? '1' : void 0 }), !0)
                )
              }
              parseOpen(o) {
                return (
                  o.name === this.tag &&
                  ((this.model = { fitToPage: o.attributes.fitToPage === '1' }), !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        105: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../base-xform')
            function a(f) {
              return f ? '1' : void 0
            }
            function l(f) {
              switch (f) {
                case 'overThenDown':
                  return f
                default:
                  return
              }
            }
            function c(f) {
              switch (f) {
                case 'atEnd':
                case 'asDisplyed':
                  return f
                default:
                  return
              }
            }
            function u(f) {
              switch (f) {
                case 'dash':
                case 'blank':
                case 'NA':
                  return f
                default:
                  return
              }
            }
            r.exports = class extends o {
              get tag() {
                return 'pageSetup'
              }
              render(f, d) {
                if (d) {
                  const h = {
                    paperSize: d.paperSize,
                    orientation: d.orientation,
                    horizontalDpi: d.horizontalDpi,
                    verticalDpi: d.verticalDpi,
                    pageOrder: l(d.pageOrder),
                    blackAndWhite: a(d.blackAndWhite),
                    draft: a(d.draft),
                    cellComments: c(d.cellComments),
                    errors: u(d.errors),
                    scale: d.scale,
                    fitToWidth: d.fitToWidth,
                    fitToHeight: d.fitToHeight,
                    firstPageNumber: d.firstPageNumber,
                    useFirstPageNumber: a(d.firstPageNumber),
                    usePrinterDefaults: a(d.usePrinterDefaults),
                    copies: d.copies,
                  }
                  s.some(h, (p) => p !== void 0) && f.leafNode(this.tag, h)
                }
              }
              parseOpen(f) {
                switch (f.name) {
                  case this.tag:
                    return (
                      (this.model = {
                        paperSize:
                          ((d = f.attributes.paperSize), d !== void 0 ? parseInt(d, 10) : void 0),
                        orientation: f.attributes.orientation || 'portrait',
                        horizontalDpi: parseInt(f.attributes.horizontalDpi || '4294967295', 10),
                        verticalDpi: parseInt(f.attributes.verticalDpi || '4294967295', 10),
                        pageOrder: f.attributes.pageOrder || 'downThenOver',
                        blackAndWhite: f.attributes.blackAndWhite === '1',
                        draft: f.attributes.draft === '1',
                        cellComments: f.attributes.cellComments || 'None',
                        errors: f.attributes.errors || 'displayed',
                        scale: parseInt(f.attributes.scale || '100', 10),
                        fitToWidth: parseInt(f.attributes.fitToWidth || '1', 10),
                        fitToHeight: parseInt(f.attributes.fitToHeight || '1', 10),
                        firstPageNumber: parseInt(f.attributes.firstPageNumber || '1', 10),
                        useFirstPageNumber: f.attributes.useFirstPageNumber === '1',
                        usePrinterDefaults: f.attributes.usePrinterDefaults === '1',
                        copies: parseInt(f.attributes.copies || '1', 10),
                      }),
                      !0
                    )
                  default:
                    return !1
                }
                var d
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../../utils/under-dash': 26, '../base-xform': 32 },
        ],
        106: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'picture'
              }
              render(o, a) {
                a && o.leafNode(this.tag, { 'r:id': a.rId })
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return ((this.model = { rId: o.attributes['r:id'] }), !0)
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        107: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../base-xform')
            function a(l) {
              return l ? '1' : void 0
            }
            r.exports = class extends o {
              get tag() {
                return 'printOptions'
              }
              render(l, c) {
                if (c) {
                  const u = {
                    headings: a(c.showRowColHeaders),
                    gridLines: a(c.showGridLines),
                    horizontalCentered: a(c.horizontalCentered),
                    verticalCentered: a(c.verticalCentered),
                  }
                  s.some(u, (f) => f !== void 0) && l.leafNode(this.tag, u)
                }
              }
              parseOpen(l) {
                switch (l.name) {
                  case this.tag:
                    return (
                      (this.model = {
                        showRowColHeaders: l.attributes.headings === '1',
                        showGridLines: l.attributes.gridLines === '1',
                        horizontalCentered: l.attributes.horizontalCentered === '1',
                        verticalCentered: l.attributes.verticalCentered === '1',
                      }),
                      !0
                    )
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../../utils/under-dash': 26, '../base-xform': 32 },
        ],
        108: [
          function (t, r, i) {
            const s = t('./page-breaks-xform'),
              o = t('../list-xform')
            r.exports = class extends o {
              constructor() {
                super({ tag: 'rowBreaks', count: !0, childXform: new s() })
              }
              render(a, l) {
                if (l && l.length) {
                  ;(a.openNode(this.tag, this.$),
                    this.count &&
                      (a.addAttribute(this.$count, l.length),
                      a.addAttribute('manualBreakCount', l.length)))
                  const { childXform: c } = this
                  ;(l.forEach((u) => {
                    c.render(a, u)
                  }),
                    a.closeNode())
                } else this.empty && a.leafNode(this.tag)
              }
            }
          },
          { '../list-xform': 71, './page-breaks-xform': 102 },
        ],
        109: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('../../../utils/utils'),
              a = t('./cell-xform')
            r.exports = class extends s {
              constructor(l) {
                ;(super(), (this.maxItems = l && l.maxItems), (this.map = { c: new a() }))
              }
              get tag() {
                return 'row'
              }
              prepare(l, c) {
                const u = c.styles.addStyleModel(l.style)
                u && (l.styleId = u)
                const f = this.map.c
                l.cells.forEach((d) => {
                  f.prepare(d, c)
                })
              }
              render(l, c, u) {
                ;(l.openNode('row'),
                  l.addAttribute('r', c.number),
                  c.height && (l.addAttribute('ht', c.height), l.addAttribute('customHeight', '1')),
                  c.hidden && l.addAttribute('hidden', '1'),
                  c.min > 0 &&
                    c.max > 0 &&
                    c.min <= c.max &&
                    l.addAttribute('spans', `${c.min}:${c.max}`),
                  c.styleId &&
                    (l.addAttribute('s', c.styleId), l.addAttribute('customFormat', '1')),
                  l.addAttribute('x14ac:dyDescent', '0.25'),
                  c.outlineLevel && l.addAttribute('outlineLevel', c.outlineLevel),
                  c.collapsed && l.addAttribute('collapsed', '1'))
                const f = this.map.c
                ;(c.cells.forEach((d) => {
                  f.render(l, d, u)
                }),
                  l.closeNode())
              }
              parseOpen(l) {
                if (this.parser) return (this.parser.parseOpen(l), !0)
                if (l.name === 'row') {
                  this.numRowsSeen += 1
                  const c = l.attributes.spans
                      ? l.attributes.spans.split(':').map((f) => parseInt(f, 10))
                      : [void 0, void 0],
                    u = (this.model = {
                      number: parseInt(l.attributes.r, 10),
                      min: c[0],
                      max: c[1],
                      cells: [],
                    })
                  return (
                    l.attributes.s && (u.styleId = parseInt(l.attributes.s, 10)),
                    o.parseBoolean(l.attributes.hidden) && (u.hidden = !0),
                    o.parseBoolean(l.attributes.bestFit) && (u.bestFit = !0),
                    l.attributes.ht && (u.height = parseFloat(l.attributes.ht)),
                    l.attributes.outlineLevel &&
                      (u.outlineLevel = parseInt(l.attributes.outlineLevel, 10)),
                    o.parseBoolean(l.attributes.collapsed) && (u.collapsed = !0),
                    !0
                  )
                }
                return (
                  (this.parser = this.map[l.name]),
                  !!this.parser && (this.parser.parseOpen(l), !0)
                )
              }
              parseText(l) {
                this.parser && this.parser.parseText(l)
              }
              parseClose(l) {
                if (this.parser) {
                  if (!this.parser.parseClose(l)) {
                    if (
                      (this.model.cells.push(this.parser.model),
                      this.maxItems && this.model.cells.length > this.maxItems)
                    )
                      throw new Error(`Max column count (${this.maxItems}) exceeded`)
                    this.parser = void 0
                  }
                  return !0
                }
                return !1
              }
              reconcile(l, c) {
                ;((l.style = l.styleId ? c.styles.getStyleModel(l.styleId) : {}),
                  l.styleId !== void 0 && (l.styleId = void 0))
                const u = this.map.c
                l.cells.forEach((f) => {
                  u.reconcile(f, c)
                })
              }
            }
          },
          { '../../../utils/utils': 27, '../base-xform': 32, './cell-xform': 73 },
        ],
        110: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../base-xform')
            r.exports = class extends o {
              get tag() {
                return 'sheetFormatPr'
              }
              render(a, l) {
                if (l) {
                  const c = {
                    defaultRowHeight: l.defaultRowHeight,
                    outlineLevelRow: l.outlineLevelRow,
                    outlineLevelCol: l.outlineLevelCol,
                    'x14ac:dyDescent': l.dyDescent,
                  }
                  ;(l.defaultColWidth && (c.defaultColWidth = l.defaultColWidth),
                    (l.defaultRowHeight && l.defaultRowHeight === 15) || (c.customHeight = '1'),
                    s.some(c, (u) => u !== void 0) && a.leafNode('sheetFormatPr', c))
                }
              }
              parseOpen(a) {
                return (
                  a.name === 'sheetFormatPr' &&
                  ((this.model = {
                    defaultRowHeight: parseFloat(a.attributes.defaultRowHeight || '0'),
                    dyDescent: parseFloat(a.attributes['x14ac:dyDescent'] || '0'),
                    outlineLevelRow: parseInt(a.attributes.outlineLevelRow || '0', 10),
                    outlineLevelCol: parseInt(a.attributes.outlineLevelCol || '0', 10),
                  }),
                  a.attributes.defaultColWidth &&
                    (this.model.defaultColWidth = parseFloat(a.attributes.defaultColWidth)),
                  !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../../utils/under-dash': 26, '../base-xform': 32 },
        ],
        111: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('../style/color-xform'),
              a = t('./page-setup-properties-xform'),
              l = t('./outline-properties-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    tabColor: new o('tabColor'),
                    pageSetUpPr: new a(),
                    outlinePr: new l(),
                  }))
              }
              get tag() {
                return 'sheetPr'
              }
              render(c, u) {
                if (u) {
                  ;(c.addRollback(), c.openNode('sheetPr'))
                  let f = !1
                  ;((f = this.map.tabColor.render(c, u.tabColor) || f),
                    (f = this.map.pageSetUpPr.render(c, u.pageSetup) || f),
                    (f = this.map.outlinePr.render(c, u.outlineProperties) || f),
                    f ? (c.closeNode(), c.commit()) : c.rollback())
                }
              }
              parseOpen(c) {
                return this.parser
                  ? (this.parser.parseOpen(c), !0)
                  : c.name === this.tag
                    ? (this.reset(), !0)
                    : !!this.map[c.name] &&
                      ((this.parser = this.map[c.name]), this.parser.parseOpen(c), !0)
              }
              parseText(c) {
                return !!this.parser && (this.parser.parseText(c), !0)
              }
              parseClose(c) {
                return this.parser
                  ? (this.parser.parseClose(c) || (this.parser = void 0), !0)
                  : (this.map.tabColor.model ||
                    this.map.pageSetUpPr.model ||
                    this.map.outlinePr.model
                      ? ((this.model = {}),
                        this.map.tabColor.model && (this.model.tabColor = this.map.tabColor.model),
                        this.map.pageSetUpPr.model &&
                          (this.model.pageSetup = this.map.pageSetUpPr.model),
                        this.map.outlinePr.model &&
                          (this.model.outlineProperties = this.map.outlinePr.model))
                      : (this.model = null),
                    !1)
              }
            }
          },
          {
            '../base-xform': 32,
            '../style/color-xform': 128,
            './outline-properties-xform': 101,
            './page-setup-properties-xform': 104,
          },
        ],
        112: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../base-xform')
            function a(c, u) {
              return c ? u : void 0
            }
            function l(c, u) {
              return c === u || void 0
            }
            r.exports = class extends o {
              get tag() {
                return 'sheetProtection'
              }
              render(c, u) {
                if (u) {
                  const f = {
                    sheet: a(u.sheet, '1'),
                    selectLockedCells: u.selectLockedCells === !1 ? '1' : void 0,
                    selectUnlockedCells: u.selectUnlockedCells === !1 ? '1' : void 0,
                    formatCells: a(u.formatCells, '0'),
                    formatColumns: a(u.formatColumns, '0'),
                    formatRows: a(u.formatRows, '0'),
                    insertColumns: a(u.insertColumns, '0'),
                    insertRows: a(u.insertRows, '0'),
                    insertHyperlinks: a(u.insertHyperlinks, '0'),
                    deleteColumns: a(u.deleteColumns, '0'),
                    deleteRows: a(u.deleteRows, '0'),
                    sort: a(u.sort, '0'),
                    autoFilter: a(u.autoFilter, '0'),
                    pivotTables: a(u.pivotTables, '0'),
                  }
                  ;(u.sheet &&
                    ((f.algorithmName = u.algorithmName),
                    (f.hashValue = u.hashValue),
                    (f.saltValue = u.saltValue),
                    (f.spinCount = u.spinCount),
                    (f.objects = a(u.objects === !1, '1')),
                    (f.scenarios = a(u.scenarios === !1, '1'))),
                    s.some(f, (d) => d !== void 0) && c.leafNode(this.tag, f))
                }
              }
              parseOpen(c) {
                switch (c.name) {
                  case this.tag:
                    return (
                      (this.model = {
                        sheet: l(c.attributes.sheet, '1'),
                        objects: c.attributes.objects !== '1' && void 0,
                        scenarios: c.attributes.scenarios !== '1' && void 0,
                        selectLockedCells: c.attributes.selectLockedCells !== '1' && void 0,
                        selectUnlockedCells: c.attributes.selectUnlockedCells !== '1' && void 0,
                        formatCells: l(c.attributes.formatCells, '0'),
                        formatColumns: l(c.attributes.formatColumns, '0'),
                        formatRows: l(c.attributes.formatRows, '0'),
                        insertColumns: l(c.attributes.insertColumns, '0'),
                        insertRows: l(c.attributes.insertRows, '0'),
                        insertHyperlinks: l(c.attributes.insertHyperlinks, '0'),
                        deleteColumns: l(c.attributes.deleteColumns, '0'),
                        deleteRows: l(c.attributes.deleteRows, '0'),
                        sort: l(c.attributes.sort, '0'),
                        autoFilter: l(c.attributes.autoFilter, '0'),
                        pivotTables: l(c.attributes.pivotTables, '0'),
                      }),
                      c.attributes.algorithmName &&
                        ((this.model.algorithmName = c.attributes.algorithmName),
                        (this.model.hashValue = c.attributes.hashValue),
                        (this.model.saltValue = c.attributes.saltValue),
                        (this.model.spinCount = parseInt(c.attributes.spinCount, 10))),
                      !0
                    )
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../../utils/under-dash': 26, '../base-xform': 32 },
        ],
        113: [
          function (t, r, i) {
            const s = t('../../../utils/col-cache'),
              o = t('../base-xform'),
              a = { frozen: 'frozen', frozenSplit: 'frozen', split: 'split' }
            r.exports = class extends o {
              get tag() {
                return 'sheetView'
              }
              prepare(l) {
                switch (l.state) {
                  case 'frozen':
                  case 'split':
                    break
                  default:
                    l.state = 'normal'
                }
              }
              render(l, c) {
                l.openNode('sheetView', { workbookViewId: c.workbookViewId || 0 })
                const u = function (g, m, y) {
                  y && l.addAttribute(g, m)
                }
                let f, d, h, p
                switch (
                  (u('rightToLeft', '1', c.rightToLeft === !0),
                  u('tabSelected', '1', c.tabSelected),
                  u('showRuler', '0', c.showRuler === !1),
                  u('showRowColHeaders', '0', c.showRowColHeaders === !1),
                  u('showGridLines', '0', c.showGridLines === !1),
                  u('zoomScale', c.zoomScale, c.zoomScale),
                  u('zoomScaleNormal', c.zoomScaleNormal, c.zoomScaleNormal),
                  u('view', c.style, c.style),
                  c.state)
                ) {
                  case 'frozen':
                    ;((d = c.xSplit || 0),
                      (h = c.ySplit || 0),
                      (f = c.topLeftCell || s.getAddress(h + 1, d + 1).address),
                      (p =
                        (c.xSplit && c.ySplit ? 'bottomRight' : c.xSplit && 'topRight') ||
                        'bottomLeft'),
                      l.leafNode('pane', {
                        xSplit: c.xSplit || void 0,
                        ySplit: c.ySplit || void 0,
                        topLeftCell: f,
                        activePane: p,
                        state: 'frozen',
                      }),
                      l.leafNode('selection', {
                        pane: p,
                        activeCell: c.activeCell,
                        sqref: c.activeCell,
                      }))
                    break
                  case 'split':
                    ;(c.activePane === 'topLeft' && (c.activePane = void 0),
                      l.leafNode('pane', {
                        xSplit: c.xSplit || void 0,
                        ySplit: c.ySplit || void 0,
                        topLeftCell: c.topLeftCell,
                        activePane: c.activePane,
                      }),
                      l.leafNode('selection', {
                        pane: c.activePane,
                        activeCell: c.activeCell,
                        sqref: c.activeCell,
                      }))
                    break
                  case 'normal':
                    c.activeCell &&
                      l.leafNode('selection', { activeCell: c.activeCell, sqref: c.activeCell })
                }
                l.closeNode()
              }
              parseOpen(l) {
                switch (l.name) {
                  case 'sheetView':
                    return (
                      (this.sheetView = {
                        workbookViewId: parseInt(l.attributes.workbookViewId, 10),
                        rightToLeft: l.attributes.rightToLeft === '1',
                        tabSelected: l.attributes.tabSelected === '1',
                        showRuler: l.attributes.showRuler !== '0',
                        showRowColHeaders: l.attributes.showRowColHeaders !== '0',
                        showGridLines: l.attributes.showGridLines !== '0',
                        zoomScale: parseInt(l.attributes.zoomScale || '100', 10),
                        zoomScaleNormal: parseInt(l.attributes.zoomScaleNormal || '100', 10),
                        style: l.attributes.view,
                      }),
                      (this.pane = void 0),
                      (this.selections = {}),
                      !0
                    )
                  case 'pane':
                    return (
                      (this.pane = {
                        xSplit: parseInt(l.attributes.xSplit || '0', 10),
                        ySplit: parseInt(l.attributes.ySplit || '0', 10),
                        topLeftCell: l.attributes.topLeftCell,
                        activePane: l.attributes.activePane || 'topLeft',
                        state: l.attributes.state,
                      }),
                      !0
                    )
                  case 'selection': {
                    const c = l.attributes.pane || 'topLeft'
                    return (
                      (this.selections[c] = { pane: c, activeCell: l.attributes.activeCell }),
                      !0
                    )
                  }
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose(l) {
                let c, u
                switch (l) {
                  case 'sheetView':
                    return (
                      this.sheetView && this.pane
                        ? ((c = this.model =
                            {
                              workbookViewId: this.sheetView.workbookViewId,
                              rightToLeft: this.sheetView.rightToLeft,
                              state: a[this.pane.state] || 'split',
                              xSplit: this.pane.xSplit,
                              ySplit: this.pane.ySplit,
                              topLeftCell: this.pane.topLeftCell,
                              showRuler: this.sheetView.showRuler,
                              showRowColHeaders: this.sheetView.showRowColHeaders,
                              showGridLines: this.sheetView.showGridLines,
                              zoomScale: this.sheetView.zoomScale,
                              zoomScaleNormal: this.sheetView.zoomScaleNormal,
                            }),
                          this.model.state === 'split' && (c.activePane = this.pane.activePane),
                          (u = this.selections[this.pane.activePane]),
                          u && u.activeCell && (c.activeCell = u.activeCell),
                          this.sheetView.style && (c.style = this.sheetView.style))
                        : ((c = this.model =
                            {
                              workbookViewId: this.sheetView.workbookViewId,
                              rightToLeft: this.sheetView.rightToLeft,
                              state: 'normal',
                              showRuler: this.sheetView.showRuler,
                              showRowColHeaders: this.sheetView.showRowColHeaders,
                              showGridLines: this.sheetView.showGridLines,
                              zoomScale: this.sheetView.zoomScale,
                              zoomScaleNormal: this.sheetView.zoomScaleNormal,
                            }),
                          (u = this.selections.topLeft),
                          u && u.activeCell && (c.activeCell = u.activeCell),
                          this.sheetView.style && (c.style = this.sheetView.style)),
                      !1
                    )
                  default:
                    return !0
                }
              }
              reconcile() {}
            }
          },
          { '../../../utils/col-cache': 19, '../base-xform': 32 },
        ],
        114: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'tablePart'
              }
              render(o, a) {
                a && o.leafNode(this.tag, { 'r:id': a.rId })
              }
              parseOpen(o) {
                switch (o.name) {
                  case this.tag:
                    return ((this.model = { rId: o.attributes['r:id'] }), !0)
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        115: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../../../utils/col-cache'),
              a = t('../../../utils/xml-stream'),
              l = t('../../rel-type'),
              c = t('./merges'),
              u = t('../base-xform'),
              f = t('../list-xform'),
              d = t('./row-xform'),
              h = t('./col-xform'),
              p = t('./dimension-xform'),
              g = t('./hyperlink-xform'),
              m = t('./merge-cell-xform'),
              y = t('./data-validations-xform'),
              b = t('./sheet-properties-xform'),
              w = t('./sheet-format-properties-xform'),
              C = t('./sheet-view-xform'),
              T = t('./sheet-protection-xform'),
              I = t('./page-margins-xform'),
              B = t('./page-setup-xform'),
              E = t('./print-options-xform'),
              O = t('./auto-filter-xform'),
              P = t('./picture-xform'),
              $ = t('./drawing-xform'),
              F = t('./table-part-xform'),
              M = t('./row-breaks-xform'),
              R = t('./header-footer-xform'),
              k = t('./cf/conditional-formattings-xform'),
              v = t('./ext-lst-xform'),
              x = (S, A) => {
                if (!A || !A.length) return S
                if (!S || !S.length) return A
                const j = {},
                  L = {}
                return (
                  S.forEach((H) => {
                    ;((j[H.ref] = H),
                      H.rules.forEach((U) => {
                        const { x14Id: K } = U
                        K && (L[K] = U)
                      }))
                  }),
                  A.forEach((H) => {
                    H.rules.forEach((U) => {
                      const K = L[U.x14Id]
                      K
                        ? ((z, q) => {
                            Object.keys(q).forEach((D) => {
                              const N = z[D],
                                V = q[D]
                              N === void 0 && V !== void 0 && (z[D] = V)
                            })
                          })(K, U)
                        : j[H.ref]
                          ? j[H.ref].rules.push(U)
                          : S.push({ ref: H.ref, rules: [U] })
                    })
                  }),
                  S
                )
              }
            class _ extends u {
              constructor(A) {
                super()
                const { maxRows: j, maxCols: L, ignoreNodes: H } = A || {}
                ;((this.ignoreNodes = H || []),
                  (this.map = {
                    sheetPr: new b(),
                    dimension: new p(),
                    sheetViews: new f({ tag: 'sheetViews', count: !1, childXform: new C() }),
                    sheetFormatPr: new w(),
                    cols: new f({ tag: 'cols', count: !1, childXform: new h() }),
                    sheetData: new f({
                      tag: 'sheetData',
                      count: !1,
                      empty: !0,
                      childXform: new d({ maxItems: L }),
                      maxItems: j,
                    }),
                    autoFilter: new O(),
                    mergeCells: new f({ tag: 'mergeCells', count: !0, childXform: new m() }),
                    rowBreaks: new M(),
                    hyperlinks: new f({ tag: 'hyperlinks', count: !1, childXform: new g() }),
                    pageMargins: new I(),
                    dataValidations: new y(),
                    pageSetup: new B(),
                    headerFooter: new R(),
                    printOptions: new E(),
                    picture: new P(),
                    drawing: new $(),
                    sheetProtection: new T(),
                    tableParts: new f({ tag: 'tableParts', count: !0, childXform: new F() }),
                    conditionalFormatting: new k(),
                    extLst: new v(),
                  }))
              }
              prepare(A, j) {
                ;((j.merges = new c()),
                  (A.hyperlinks = j.hyperlinks = []),
                  (A.comments = j.comments = []),
                  (j.formulae = {}),
                  (j.siFormulae = 0),
                  this.map.cols.prepare(A.cols, j),
                  this.map.sheetData.prepare(A.rows, j),
                  this.map.conditionalFormatting.prepare(A.conditionalFormattings, j),
                  (A.mergeCells = j.merges.mergeCells))
                const L = (A.rels = [])
                function H(z) {
                  return 'rId' + (z.length + 1)
                }
                if (
                  (A.hyperlinks.forEach((z) => {
                    const q = H(L)
                    ;((z.rId = q),
                      L.push({
                        Id: q,
                        Type: l.Hyperlink,
                        Target: z.target,
                        TargetMode: 'External',
                      }))
                  }),
                  A.comments.length > 0)
                ) {
                  const z = { Id: H(L), Type: l.Comments, Target: `../comments${A.id}.xml` }
                  L.push(z)
                  const q = {
                    Id: H(L),
                    Type: l.VmlDrawing,
                    Target: `../drawings/vmlDrawing${A.id}.vml`,
                  }
                  ;(L.push(q),
                    A.comments.forEach((D) => {
                      D.refAddress = o.decodeAddress(D.ref)
                    }),
                    j.commentRefs.push({
                      commentName: 'comments' + A.id,
                      vmlDrawing: 'vmlDrawing' + A.id,
                    }))
                }
                const U = []
                let K
                ;(A.media.forEach((z) => {
                  if (z.type === 'background') {
                    const q = H(L)
                    ;((K = j.media[z.imageId]),
                      L.push({ Id: q, Type: l.Image, Target: `../media/${K.name}.${K.extension}` }),
                      (A.background = { rId: q }),
                      (A.image = j.media[z.imageId]))
                  } else if (z.type === 'image') {
                    let { drawing: q } = A
                    ;((K = j.media[z.imageId]),
                      q ||
                        ((q = A.drawing =
                          {
                            rId: H(L),
                            name: 'drawing' + ++j.drawingsCount,
                            anchors: [],
                            rels: [],
                          }),
                        j.drawings.push(q),
                        L.push({
                          Id: q.rId,
                          Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
                          Target: `../drawings/${q.name}.xml`,
                        })))
                    let D = this.preImageId === z.imageId ? U[z.imageId] : U[q.rels.length]
                    D ||
                      ((D = H(q.rels)),
                      (U[q.rels.length] = D),
                      q.rels.push({
                        Id: D,
                        Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
                        Target: `../media/${K.name}.${K.extension}`,
                      }))
                    const N = { picture: { rId: D }, range: z.range }
                    if (z.hyperlinks && z.hyperlinks.hyperlink) {
                      const V = H(q.rels)
                      ;((U[q.rels.length] = V),
                        (N.picture.hyperlinks = { tooltip: z.hyperlinks.tooltip, rId: V }),
                        q.rels.push({
                          Id: V,
                          Type: l.Hyperlink,
                          Target: z.hyperlinks.hyperlink,
                          TargetMode: 'External',
                        }))
                    }
                    ;((this.preImageId = z.imageId), q.anchors.push(N))
                  }
                }),
                  A.tables.forEach((z) => {
                    const q = H(L)
                    ;((z.rId = q),
                      L.push({ Id: q, Type: l.Table, Target: '../tables/' + z.target }),
                      z.columns.forEach((D) => {
                        const { style: N } = D
                        N && (D.dxfId = j.styles.addDxfStyle(N))
                      }))
                  }),
                  this.map.extLst.prepare(A, j))
              }
              render(A, j) {
                ;(A.openXml(a.StdDocAttributes), A.openNode('worksheet', _.WORKSHEET_ATTRIBUTES))
                const L = j.properties
                  ? {
                      defaultRowHeight: j.properties.defaultRowHeight,
                      dyDescent: j.properties.dyDescent,
                      outlineLevelCol: j.properties.outlineLevelCol,
                      outlineLevelRow: j.properties.outlineLevelRow,
                    }
                  : void 0
                j.properties &&
                  j.properties.defaultColWidth &&
                  (L.defaultColWidth = j.properties.defaultColWidth)
                const H = {
                    outlineProperties: j.properties && j.properties.outlineProperties,
                    tabColor: j.properties && j.properties.tabColor,
                    pageSetup:
                      j.pageSetup && j.pageSetup.fitToPage
                        ? { fitToPage: j.pageSetup.fitToPage }
                        : void 0,
                  },
                  U = j.pageSetup && j.pageSetup.margins,
                  K = {
                    showRowColHeaders: j.pageSetup && j.pageSetup.showRowColHeaders,
                    showGridLines: j.pageSetup && j.pageSetup.showGridLines,
                    horizontalCentered: j.pageSetup && j.pageSetup.horizontalCentered,
                    verticalCentered: j.pageSetup && j.pageSetup.verticalCentered,
                  },
                  z = j.sheetProtection
                ;(this.map.sheetPr.render(A, H),
                  this.map.dimension.render(A, j.dimensions),
                  this.map.sheetViews.render(A, j.views),
                  this.map.sheetFormatPr.render(A, L),
                  this.map.cols.render(A, j.cols),
                  this.map.sheetData.render(A, j.rows),
                  this.map.sheetProtection.render(A, z),
                  this.map.autoFilter.render(A, j.autoFilter),
                  this.map.mergeCells.render(A, j.mergeCells),
                  this.map.conditionalFormatting.render(A, j.conditionalFormattings),
                  this.map.dataValidations.render(A, j.dataValidations),
                  this.map.hyperlinks.render(A, j.hyperlinks),
                  this.map.printOptions.render(A, K),
                  this.map.pageMargins.render(A, U),
                  this.map.pageSetup.render(A, j.pageSetup),
                  this.map.headerFooter.render(A, j.headerFooter),
                  this.map.rowBreaks.render(A, j.rowBreaks),
                  this.map.drawing.render(A, j.drawing),
                  this.map.picture.render(A, j.background),
                  this.map.tableParts.render(A, j.tables),
                  this.map.extLst.render(A, j),
                  j.rels &&
                    j.rels.forEach((q) => {
                      q.Type === l.VmlDrawing && A.leafNode('legacyDrawing', { 'r:id': q.Id })
                    }),
                  A.closeNode())
              }
              parseOpen(A) {
                return this.parser
                  ? (this.parser.parseOpen(A), !0)
                  : A.name === 'worksheet'
                    ? (s.each(this.map, (j) => {
                        j.reset()
                      }),
                      !0)
                    : (this.map[A.name] &&
                        !this.ignoreNodes.includes(A.name) &&
                        ((this.parser = this.map[A.name]), this.parser.parseOpen(A)),
                      !0)
              }
              parseText(A) {
                this.parser && this.parser.parseText(A)
              }
              parseClose(A) {
                if (this.parser) return (this.parser.parseClose(A) || (this.parser = void 0), !0)
                switch (A) {
                  case 'worksheet': {
                    const j = this.map.sheetFormatPr.model || {}
                    ;(this.map.sheetPr.model &&
                      this.map.sheetPr.model.tabColor &&
                      (j.tabColor = this.map.sheetPr.model.tabColor),
                      this.map.sheetPr.model &&
                        this.map.sheetPr.model.outlineProperties &&
                        (j.outlineProperties = this.map.sheetPr.model.outlineProperties))
                    const L = {
                        fitToPage:
                          (this.map.sheetPr.model &&
                            this.map.sheetPr.model.pageSetup &&
                            this.map.sheetPr.model.pageSetup.fitToPage) ||
                          !1,
                        margins: this.map.pageMargins.model,
                      },
                      H = Object.assign(L, this.map.pageSetup.model, this.map.printOptions.model),
                      U = x(
                        this.map.conditionalFormatting.model,
                        this.map.extLst.model &&
                          this.map.extLst.model['x14:conditionalFormattings'],
                      )
                    return (
                      (this.model = {
                        dimensions: this.map.dimension.model,
                        cols: this.map.cols.model,
                        rows: this.map.sheetData.model,
                        mergeCells: this.map.mergeCells.model,
                        hyperlinks: this.map.hyperlinks.model,
                        dataValidations: this.map.dataValidations.model,
                        properties: j,
                        views: this.map.sheetViews.model,
                        pageSetup: H,
                        headerFooter: this.map.headerFooter.model,
                        background: this.map.picture.model,
                        drawing: this.map.drawing.model,
                        tables: this.map.tableParts.model,
                        conditionalFormattings: U,
                      }),
                      this.map.autoFilter.model &&
                        (this.model.autoFilter = this.map.autoFilter.model),
                      this.map.sheetProtection.model &&
                        (this.model.sheetProtection = this.map.sheetProtection.model),
                      !1
                    )
                  }
                  default:
                    return !0
                }
              }
              reconcile(A, j) {
                const L = (A.relationships || []).reduce((U, K) => {
                  if (
                    ((U[K.Id] = K),
                    K.Type === l.Comments && (A.comments = j.comments[K.Target].comments),
                    K.Type === l.VmlDrawing && A.comments && A.comments.length)
                  ) {
                    const z = j.vmlDrawings[K.Target].comments
                    A.comments.forEach((q, D) => {
                      q.note = Object.assign({}, q.note, z[D])
                    })
                  }
                  return U
                }, {})
                if (
                  ((j.commentsMap = (A.comments || []).reduce(
                    (U, K) => (K.ref && (U[K.ref] = K), U),
                    {},
                  )),
                  (j.hyperlinkMap = (A.hyperlinks || []).reduce(
                    (U, K) => (K.rId && (U[K.address] = L[K.rId].Target), U),
                    {},
                  )),
                  (j.formulae = {}),
                  (A.rows = (A.rows && A.rows.filter(Boolean)) || []),
                  A.rows.forEach((U) => {
                    U.cells = (U.cells && U.cells.filter(Boolean)) || []
                  }),
                  this.map.cols.reconcile(A.cols, j),
                  this.map.sheetData.reconcile(A.rows, j),
                  this.map.conditionalFormatting.reconcile(A.conditionalFormattings, j),
                  (A.media = []),
                  A.drawing)
                ) {
                  const U = L[A.drawing.rId].Target.match(
                    /\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/,
                  )
                  if (U) {
                    const K = U[1]
                    j.drawings[K].anchors.forEach((z) => {
                      if (z.medium) {
                        const q = {
                          type: 'image',
                          imageId: z.medium.index,
                          range: z.range,
                          hyperlinks: z.picture.hyperlinks,
                        }
                        A.media.push(q)
                      }
                    })
                  }
                }
                const H = A.background && L[A.background.rId]
                if (H) {
                  const U = H.Target.split('/media/')[1],
                    K = j.mediaIndex && j.mediaIndex[U]
                  K !== void 0 && A.media.push({ type: 'background', imageId: K })
                }
                ;((A.tables = (A.tables || []).map((U) => {
                  const K = L[U.rId]
                  return j.tables[K.Target]
                })),
                  delete A.relationships,
                  delete A.hyperlinks,
                  delete A.comments)
              }
            }
            ;((_.WORKSHEET_ATTRIBUTES = {
              xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
              'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
              'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
              'mc:Ignorable': 'x14ac',
              'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
            }),
              (r.exports = _))
          },
          {
            '../../../utils/col-cache': 19,
            '../../../utils/under-dash': 26,
            '../../../utils/xml-stream': 28,
            '../../rel-type': 31,
            '../base-xform': 32,
            '../list-xform': 71,
            './auto-filter-xform': 72,
            './cf/conditional-formattings-xform': 87,
            './col-xform': 92,
            './data-validations-xform': 93,
            './dimension-xform': 94,
            './drawing-xform': 95,
            './ext-lst-xform': 96,
            './header-footer-xform': 97,
            './hyperlink-xform': 98,
            './merge-cell-xform': 99,
            './merges': 100,
            './page-margins-xform': 103,
            './page-setup-xform': 105,
            './picture-xform': 106,
            './print-options-xform': 107,
            './row-breaks-xform': 108,
            './row-xform': 109,
            './sheet-format-properties-xform': 110,
            './sheet-properties-xform': 111,
            './sheet-protection-xform': 112,
            './sheet-view-xform': 113,
            './table-part-xform': 114,
          },
        ],
        116: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(), (this.tag = o.tag), (this.attr = o.attr))
              }
              render(o, a) {
                a && (o.openNode(this.tag), o.closeNode())
              }
              parseOpen(o) {
                o.name === this.tag && (this.model = !0)
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        117: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(),
                  (this.tag = o.tag),
                  (this.attr = o.attr),
                  (this.attrs = o.attrs),
                  (this._format =
                    o.format ||
                    function (a) {
                      try {
                        return Number.isNaN(a.getTime()) ? '' : a.toISOString()
                      } catch {
                        return ''
                      }
                    }),
                  (this._parse =
                    o.parse ||
                    function (a) {
                      return new Date(a)
                    }))
              }
              render(o, a) {
                a &&
                  (o.openNode(this.tag),
                  this.attrs && o.addAttributes(this.attrs),
                  this.attr
                    ? o.addAttribute(this.attr, this._format(a))
                    : o.writeText(this._format(a)),
                  o.closeNode())
              }
              parseOpen(o) {
                o.name === this.tag &&
                  (this.attr
                    ? (this.model = this._parse(o.attributes[this.attr]))
                    : (this.text = []))
              }
              parseText(o) {
                this.attr || this.text.push(o)
              }
              parseClose() {
                return (this.attr || (this.model = this._parse(this.text.join(''))), !1)
              }
            }
          },
          { '../base-xform': 32 },
        ],
        118: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(),
                  (this.tag = o.tag),
                  (this.attr = o.attr),
                  (this.attrs = o.attrs),
                  (this.zero = o.zero))
              }
              render(o, a) {
                ;(a || this.zero) &&
                  (o.openNode(this.tag),
                  this.attrs && o.addAttributes(this.attrs),
                  this.attr ? o.addAttribute(this.attr, a) : o.writeText(a),
                  o.closeNode())
              }
              parseOpen(o) {
                return (
                  o.name === this.tag &&
                  (this.attr
                    ? (this.model = parseInt(o.attributes[this.attr], 10))
                    : (this.text = []),
                  !0)
                )
              }
              parseText(o) {
                this.attr || this.text.push(o)
              }
              parseClose() {
                return (this.attr || (this.model = parseInt(this.text.join('') || 0, 10)), !1)
              }
            }
          },
          { '../base-xform': 32 },
        ],
        119: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(), (this.tag = o.tag), (this.attr = o.attr), (this.attrs = o.attrs))
              }
              render(o, a) {
                a !== void 0 &&
                  (o.openNode(this.tag),
                  this.attrs && o.addAttributes(this.attrs),
                  this.attr ? o.addAttribute(this.attr, a) : o.writeText(a),
                  o.closeNode())
              }
              parseOpen(o) {
                o.name === this.tag &&
                  (this.attr ? (this.model = o.attributes[this.attr]) : (this.text = []))
              }
              parseText(o) {
                this.attr || this.text.push(o)
              }
              parseClose() {
                return (this.attr || (this.model = this.text.join('')), !1)
              }
            }
          },
          { '../base-xform': 32 },
        ],
        120: [
          function (t, r, i) {
            const s = t('./base-xform'),
              o = t('../../utils/xml-stream')
            r.exports = class extends s {
              constructor(a) {
                ;(super(), (this._model = a))
              }
              render(a) {
                if (!this._xml) {
                  const l = new o()
                  ;((function c(u, f) {
                    ;(u.openNode(f.tag, f.$),
                      f.c &&
                        f.c.forEach((d) => {
                          c(u, d)
                        }),
                      f.t && u.writeText(f.t),
                      u.closeNode())
                  })(l, this._model),
                    (this._xml = l.xml))
                }
                a.writeXml(this._xml)
              }
              parseOpen() {
                return !0
              }
              parseText() {}
              parseClose(a) {
                switch (a) {
                  case this._model.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          { '../../utils/xml-stream': 28, './base-xform': 32 },
        ],
        121: [
          function (t, r, i) {
            const s = t('./text-xform'),
              o = t('./rich-text-xform'),
              a = t('../base-xform')
            r.exports = class extends a {
              constructor() {
                ;(super(), (this.map = { r: new o(), t: new s() }))
              }
              get tag() {
                return 'rPh'
              }
              render(l, c) {
                if (
                  (l.openNode(this.tag, { sb: c.sb || 0, eb: c.eb || 0 }),
                  c && c.hasOwnProperty('richText') && c.richText)
                ) {
                  const { r: u } = this.map
                  c.richText.forEach((f) => {
                    u.render(l, f)
                  })
                } else c && this.map.t.render(l, c.text)
                l.closeNode()
              }
              parseOpen(l) {
                const { name: c } = l
                return this.parser
                  ? (this.parser.parseOpen(l), !0)
                  : c === this.tag
                    ? ((this.model = {
                        sb: parseInt(l.attributes.sb, 10),
                        eb: parseInt(l.attributes.eb, 10),
                      }),
                      !0)
                    : ((this.parser = this.map[c]), !!this.parser && (this.parser.parseOpen(l), !0))
              }
              parseText(l) {
                this.parser && this.parser.parseText(l)
              }
              parseClose(l) {
                if (this.parser) {
                  if (!this.parser.parseClose(l)) {
                    switch (l) {
                      case 'r': {
                        let c = this.model.richText
                        ;(c || (c = this.model.richText = []), c.push(this.parser.model))
                        break
                      }
                      case 't':
                        this.model.text = this.parser.model
                    }
                    this.parser = void 0
                  }
                  return !0
                }
                switch (l) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          { '../base-xform': 32, './rich-text-xform': 122, './text-xform': 125 },
        ],
        122: [
          function (t, r, i) {
            const s = t('./text-xform'),
              o = t('../style/font-xform'),
              a = t('../base-xform')
            class l extends a {
              constructor(u) {
                ;(super(), (this.model = u))
              }
              get tag() {
                return 'r'
              }
              get textXform() {
                return this._textXform || (this._textXform = new s())
              }
              get fontXform() {
                return this._fontXform || (this._fontXform = new o(l.FONT_OPTIONS))
              }
              render(u, f) {
                ;((f = f || this.model),
                  u.openNode('r'),
                  f.font && this.fontXform.render(u, f.font),
                  this.textXform.render(u, f.text),
                  u.closeNode())
              }
              parseOpen(u) {
                if (this.parser) return (this.parser.parseOpen(u), !0)
                switch (u.name) {
                  case 'r':
                    return ((this.model = {}), !0)
                  case 't':
                    return ((this.parser = this.textXform), this.parser.parseOpen(u), !0)
                  case 'rPr':
                    return ((this.parser = this.fontXform), this.parser.parseOpen(u), !0)
                  default:
                    return !1
                }
              }
              parseText(u) {
                this.parser && this.parser.parseText(u)
              }
              parseClose(u) {
                switch (u) {
                  case 'r':
                    return !1
                  case 't':
                    return ((this.model.text = this.parser.model), (this.parser = void 0), !0)
                  case 'rPr':
                    return ((this.model.font = this.parser.model), (this.parser = void 0), !0)
                  default:
                    return (this.parser && this.parser.parseClose(u), !0)
                }
              }
            }
            ;((l.FONT_OPTIONS = { tagName: 'rPr', fontNameTag: 'rFont' }), (r.exports = l))
          },
          { '../base-xform': 32, '../style/font-xform': 131, './text-xform': 125 },
        ],
        123: [
          function (t, r, i) {
            const s = t('./text-xform'),
              o = t('./rich-text-xform'),
              a = t('./phonetic-text-xform'),
              l = t('../base-xform')
            r.exports = class extends l {
              constructor(c) {
                ;(super(), (this.model = c), (this.map = { r: new o(), t: new s(), rPh: new a() }))
              }
              get tag() {
                return 'si'
              }
              render(c, u) {
                ;(c.openNode(this.tag),
                  u && u.hasOwnProperty('richText') && u.richText
                    ? u.richText.length
                      ? u.richText.forEach((f) => {
                          this.map.r.render(c, f)
                        })
                      : this.map.t.render(c, '')
                    : u != null && this.map.t.render(c, u),
                  c.closeNode())
              }
              parseOpen(c) {
                const { name: u } = c
                return this.parser
                  ? (this.parser.parseOpen(c), !0)
                  : u === this.tag
                    ? ((this.model = {}), !0)
                    : ((this.parser = this.map[u]), !!this.parser && (this.parser.parseOpen(c), !0))
              }
              parseText(c) {
                this.parser && this.parser.parseText(c)
              }
              parseClose(c) {
                if (this.parser) {
                  if (!this.parser.parseClose(c)) {
                    switch (c) {
                      case 'r': {
                        let u = this.model.richText
                        ;(u || (u = this.model.richText = []), u.push(this.parser.model))
                        break
                      }
                      case 't':
                        this.model = this.parser.model
                    }
                    this.parser = void 0
                  }
                  return !0
                }
                switch (c) {
                  case this.tag:
                    return !1
                  default:
                    return !0
                }
              }
            }
          },
          {
            '../base-xform': 32,
            './phonetic-text-xform': 121,
            './rich-text-xform': 122,
            './text-xform': 125,
          },
        ],
        124: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../base-xform'),
              a = t('./shared-string-xform')
            r.exports = class extends o {
              constructor(l) {
                ;(super(),
                  (this.model = l || { values: [], count: 0 }),
                  (this.hash = Object.create(null)),
                  (this.rich = Object.create(null)))
              }
              get sharedStringXform() {
                return this._sharedStringXform || (this._sharedStringXform = new a())
              }
              get values() {
                return this.model.values
              }
              get uniqueCount() {
                return this.model.values.length
              }
              get count() {
                return this.model.count
              }
              getString(l) {
                return this.model.values[l]
              }
              add(l) {
                return l.richText ? this.addRichText(l) : this.addText(l)
              }
              addText(l) {
                let c = this.hash[l]
                return (
                  c === void 0 &&
                    ((c = this.hash[l] = this.model.values.length), this.model.values.push(l)),
                  this.model.count++,
                  c
                )
              }
              addRichText(l) {
                const c = this.sharedStringXform.toXml(l)
                let u = this.rich[c]
                return (
                  u === void 0 &&
                    ((u = this.rich[c] = this.model.values.length), this.model.values.push(l)),
                  this.model.count++,
                  u
                )
              }
              render(l, c) {
                ;((c = c || this._values),
                  l.openXml(s.StdDocAttributes),
                  l.openNode('sst', {
                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                    count: c.count,
                    uniqueCount: c.values.length,
                  }))
                const u = this.sharedStringXform
                ;(c.values.forEach((f) => {
                  u.render(l, f)
                }),
                  l.closeNode())
              }
              parseOpen(l) {
                if (this.parser) return (this.parser.parseOpen(l), !0)
                switch (l.name) {
                  case 'sst':
                    return !0
                  case 'si':
                    return ((this.parser = this.sharedStringXform), this.parser.parseOpen(l), !0)
                  default:
                    throw new Error('Unexpected xml node in parseOpen: ' + JSON.stringify(l))
                }
              }
              parseText(l) {
                this.parser && this.parser.parseText(l)
              }
              parseClose(l) {
                if (this.parser)
                  return (
                    this.parser.parseClose(l) ||
                      (this.model.values.push(this.parser.model),
                      this.model.count++,
                      (this.parser = void 0)),
                    !0
                  )
                switch (l) {
                  case 'sst':
                    return !1
                  default:
                    throw new Error('Unexpected xml node in parseClose: ' + l)
                }
              }
            }
          },
          { '../../../utils/xml-stream': 28, '../base-xform': 32, './shared-string-xform': 123 },
        ],
        125: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 't'
              }
              render(o, a) {
                ;(o.openNode('t'),
                  /^\s|\n|\s$/.test(a) && o.addAttribute('xml:space', 'preserve'),
                  o.writeText(a),
                  o.closeNode())
              }
              get model() {
                return this._text
                  .join('')
                  .replace(/_x([0-9A-F]{4})_/g, (o, a) => String.fromCharCode(parseInt(a, 16)))
              }
              parseOpen(o) {
                switch (o.name) {
                  case 't':
                    return ((this._text = []), !0)
                  default:
                    return !1
                }
              }
              parseText(o) {
                this._text.push(o)
              }
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        126: [
          function (t, r, i) {
            const s = t('../../../doc/enums'),
              o = t('../../../utils/utils'),
              a = t('../base-xform'),
              l = {
                horizontalValues: [
                  'left',
                  'center',
                  'right',
                  'fill',
                  'centerContinuous',
                  'distributed',
                  'justify',
                ].reduce((u, f) => ((u[f] = !0), u), {}),
                horizontal(u) {
                  return this.horizontalValues[u] ? u : void 0
                },
                verticalValues: ['top', 'middle', 'bottom', 'distributed', 'justify'].reduce(
                  (u, f) => ((u[f] = !0), u),
                  {},
                ),
                vertical(u) {
                  return u === 'middle' ? 'center' : this.verticalValues[u] ? u : void 0
                },
                wrapText: (u) => !!u || void 0,
                shrinkToFit: (u) => !!u || void 0,
                textRotation(u) {
                  switch (u) {
                    case 'vertical':
                      return u
                    default:
                      return (u = o.validInt(u)) >= -90 && u <= 90 ? u : void 0
                  }
                },
                indent: (u) => ((u = o.validInt(u)), Math.max(0, u)),
                readingOrder(u) {
                  switch (u) {
                    case 'ltr':
                      return s.ReadingOrder.LeftToRight
                    case 'rtl':
                      return s.ReadingOrder.RightToLeft
                    default:
                      return
                  }
                },
              },
              c = {
                toXml(u) {
                  if ((u = l.textRotation(u))) {
                    if (u === 'vertical') return 255
                    const f = Math.round(u)
                    if (f >= 0 && f <= 90) return f
                    if (f < 0 && f >= -90) return 90 - f
                  }
                },
                toModel(u) {
                  const f = o.validInt(u)
                  if (f !== void 0) {
                    if (f === 255) return 'vertical'
                    if (f >= 0 && f <= 90) return f
                    if (f > 90 && f <= 180) return 90 - f
                  }
                },
              }
            r.exports = class extends a {
              get tag() {
                return 'alignment'
              }
              render(u, f) {
                ;(u.addRollback(), u.openNode('alignment'))
                let d = !1
                function h(p, g) {
                  g && (u.addAttribute(p, g), (d = !0))
                }
                ;(h('horizontal', l.horizontal(f.horizontal)),
                  h('vertical', l.vertical(f.vertical)),
                  h('wrapText', !!l.wrapText(f.wrapText) && '1'),
                  h('shrinkToFit', !!l.shrinkToFit(f.shrinkToFit) && '1'),
                  h('indent', l.indent(f.indent)),
                  h('textRotation', c.toXml(f.textRotation)),
                  h('readingOrder', l.readingOrder(f.readingOrder)),
                  u.closeNode(),
                  d ? u.commit() : u.rollback())
              }
              parseOpen(u) {
                const f = {}
                let d = !1
                function h(p, g, m) {
                  p && ((f[g] = m), (d = !0))
                }
                ;(h(u.attributes.horizontal, 'horizontal', u.attributes.horizontal),
                  h(
                    u.attributes.vertical,
                    'vertical',
                    u.attributes.vertical === 'center' ? 'middle' : u.attributes.vertical,
                  ),
                  h(u.attributes.wrapText, 'wrapText', o.parseBoolean(u.attributes.wrapText)),
                  h(
                    u.attributes.shrinkToFit,
                    'shrinkToFit',
                    o.parseBoolean(u.attributes.shrinkToFit),
                  ),
                  h(u.attributes.indent, 'indent', parseInt(u.attributes.indent, 10)),
                  h(
                    u.attributes.textRotation,
                    'textRotation',
                    c.toModel(u.attributes.textRotation),
                  ),
                  h(
                    u.attributes.readingOrder,
                    'readingOrder',
                    u.attributes.readingOrder === '2' ? 'rtl' : 'ltr',
                  ),
                  (this.model = d ? f : null))
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../../../doc/enums': 7, '../../../utils/utils': 27, '../base-xform': 32 },
        ],
        127: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('../../../utils/utils'),
              a = t('./color-xform')
            class l extends s {
              constructor(u) {
                ;(super(), (this.name = u), (this.map = { color: new a() }))
              }
              get tag() {
                return this.name
              }
              render(u, f, d) {
                const h = (f && f.color) || d || this.defaultColor
                ;(u.openNode(this.name),
                  f &&
                    f.style &&
                    (u.addAttribute('style', f.style), h && this.map.color.render(u, h)),
                  u.closeNode())
              }
              parseOpen(u) {
                if (this.parser) return (this.parser.parseOpen(u), !0)
                switch (u.name) {
                  case this.name: {
                    const { style: f } = u.attributes
                    return ((this.model = f ? { style: f } : void 0), !0)
                  }
                  case 'color':
                    return ((this.parser = this.map.color), this.parser.parseOpen(u), !0)
                  default:
                    return !1
                }
              }
              parseText(u) {
                this.parser && this.parser.parseText(u)
              }
              parseClose(u) {
                return this.parser
                  ? (this.parser.parseClose(u) || (this.parser = void 0), !0)
                  : (u === this.name &&
                      this.map.color.model &&
                      (this.model || (this.model = {}), (this.model.color = this.map.color.model)),
                    !1)
              }
              validStyle(u) {
                return l.validStyleValues[u]
              }
            }
            ;((l.validStyleValues = [
              'thin',
              'dashed',
              'dotted',
              'dashDot',
              'hair',
              'dashDotDot',
              'slantDashDot',
              'mediumDashed',
              'mediumDashDotDot',
              'mediumDashDot',
              'medium',
              'double',
              'thick',
            ].reduce((c, u) => ((c[u] = !0), c), {})),
              (r.exports = class extends s {
                constructor() {
                  ;(super(),
                    (this.map = {
                      top: new l('top'),
                      left: new l('left'),
                      bottom: new l('bottom'),
                      right: new l('right'),
                      diagonal: new l('diagonal'),
                    }))
                }
                render(c, u) {
                  const { color: f } = u
                  function d(h, p) {
                    ;(h && !h.color && u.color && (h = { ...h, color: u.color }), p.render(c, h, f))
                  }
                  ;(c.openNode('border'),
                    u.diagonal &&
                      u.diagonal.style &&
                      (u.diagonal.up && c.addAttribute('diagonalUp', '1'),
                      u.diagonal.down && c.addAttribute('diagonalDown', '1')),
                    d(u.left, this.map.left),
                    d(u.right, this.map.right),
                    d(u.top, this.map.top),
                    d(u.bottom, this.map.bottom),
                    d(u.diagonal, this.map.diagonal),
                    c.closeNode())
                }
                parseOpen(c) {
                  if (this.parser) return (this.parser.parseOpen(c), !0)
                  switch (c.name) {
                    case 'border':
                      return (
                        this.reset(),
                        (this.diagonalUp = o.parseBoolean(c.attributes.diagonalUp)),
                        (this.diagonalDown = o.parseBoolean(c.attributes.diagonalDown)),
                        !0
                      )
                    default:
                      return (
                        (this.parser = this.map[c.name]),
                        !!this.parser && (this.parser.parseOpen(c), !0)
                      )
                  }
                }
                parseText(c) {
                  this.parser && this.parser.parseText(c)
                }
                parseClose(c) {
                  if (this.parser) return (this.parser.parseClose(c) || (this.parser = void 0), !0)
                  if (c === 'border') {
                    const u = (this.model = {}),
                      f = function (d, h, p) {
                        h && (p && Object.assign(h, p), (u[d] = h))
                      }
                    ;(f('left', this.map.left.model),
                      f('right', this.map.right.model),
                      f('top', this.map.top.model),
                      f('bottom', this.map.bottom.model),
                      f('diagonal', this.map.diagonal.model, {
                        up: this.diagonalUp,
                        down: this.diagonalDown,
                      }))
                  }
                  return !1
                }
              }))
          },
          { '../../../utils/utils': 27, '../base-xform': 32, './color-xform': 128 },
        ],
        128: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              constructor(o) {
                ;(super(), (this.name = o || 'color'))
              }
              get tag() {
                return this.name
              }
              render(o, a) {
                return (
                  !!a &&
                  (o.openNode(this.name),
                  a.argb
                    ? o.addAttribute('rgb', a.argb)
                    : a.theme !== void 0
                      ? (o.addAttribute('theme', a.theme),
                        a.tint !== void 0 && o.addAttribute('tint', a.tint))
                      : a.indexed !== void 0
                        ? o.addAttribute('indexed', a.indexed)
                        : o.addAttribute('auto', '1'),
                  o.closeNode(),
                  !0)
                )
              }
              parseOpen(o) {
                return (
                  o.name === this.name &&
                  (o.attributes.rgb
                    ? (this.model = { argb: o.attributes.rgb })
                    : o.attributes.theme
                      ? ((this.model = { theme: parseInt(o.attributes.theme, 10) }),
                        o.attributes.tint && (this.model.tint = parseFloat(o.attributes.tint)))
                      : o.attributes.indexed
                        ? (this.model = { indexed: parseInt(o.attributes.indexed, 10) })
                        : (this.model = void 0),
                  !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        129: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./alignment-xform'),
              a = t('./border-xform'),
              l = t('./fill-xform'),
              c = t('./font-xform'),
              u = t('./numfmt-xform'),
              f = t('./protection-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    alignment: new o(),
                    border: new a(),
                    fill: new l(),
                    font: new c(),
                    numFmt: new u(),
                    protection: new f(),
                  }))
              }
              get tag() {
                return 'dxf'
              }
              render(d, h) {
                if (
                  (d.openNode(this.tag),
                  h.font && this.map.font.render(d, h.font),
                  h.numFmt && h.numFmtId)
                ) {
                  const p = { id: h.numFmtId, formatCode: h.numFmt }
                  this.map.numFmt.render(d, p)
                }
                ;(h.fill && this.map.fill.render(d, h.fill),
                  h.alignment && this.map.alignment.render(d, h.alignment),
                  h.border && this.map.border.render(d, h.border),
                  h.protection && this.map.protection.render(d, h.protection),
                  d.closeNode())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case this.tag:
                    return (this.reset(), !0)
                  default:
                    return (
                      (this.parser = this.map[d.name]),
                      this.parser && this.parser.parseOpen(d),
                      !0
                    )
                }
              }
              parseText(d) {
                this.parser && this.parser.parseText(d)
              }
              parseClose(d) {
                return this.parser
                  ? (this.parser.parseClose(d) || (this.parser = void 0), !0)
                  : d !== this.tag ||
                      ((this.model = {
                        alignment: this.map.alignment.model,
                        border: this.map.border.model,
                        fill: this.map.fill.model,
                        font: this.map.font.model,
                        numFmt: this.map.numFmt.model,
                        protection: this.map.protection.model,
                      }),
                      !1)
              }
            }
          },
          {
            '../base-xform': 32,
            './alignment-xform': 126,
            './border-xform': 127,
            './fill-xform': 130,
            './font-xform': 131,
            './numfmt-xform': 132,
            './protection-xform': 133,
          },
        ],
        130: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./color-xform')
            class a extends s {
              constructor() {
                ;(super(), (this.map = { color: new o() }))
              }
              get tag() {
                return 'stop'
              }
              render(d, h) {
                ;(d.openNode('stop'),
                  d.addAttribute('position', h.position),
                  this.map.color.render(d, h.color),
                  d.closeNode())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case 'stop':
                    return ((this.model = { position: parseFloat(d.attributes.position) }), !0)
                  case 'color':
                    return ((this.parser = this.map.color), this.parser.parseOpen(d), !0)
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose(d) {
                return (
                  !!this.parser &&
                  (this.parser.parseClose(d) ||
                    ((this.model.color = this.parser.model), (this.parser = void 0)),
                  !0)
                )
              }
            }
            class l extends s {
              constructor() {
                ;(super(), (this.map = { fgColor: new o('fgColor'), bgColor: new o('bgColor') }))
              }
              get name() {
                return 'pattern'
              }
              get tag() {
                return 'patternFill'
              }
              render(d, h) {
                ;(d.openNode('patternFill'),
                  d.addAttribute('patternType', h.pattern),
                  h.fgColor && this.map.fgColor.render(d, h.fgColor),
                  h.bgColor && this.map.bgColor.render(d, h.bgColor),
                  d.closeNode())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case 'patternFill':
                    return (
                      (this.model = { type: 'pattern', pattern: d.attributes.patternType }),
                      !0
                    )
                  default:
                    return (
                      (this.parser = this.map[d.name]),
                      !!this.parser && (this.parser.parseOpen(d), !0)
                    )
                }
              }
              parseText(d) {
                this.parser && this.parser.parseText(d)
              }
              parseClose(d) {
                return (
                  !!this.parser &&
                  (this.parser.parseClose(d) ||
                    (this.parser.model && (this.model[d] = this.parser.model),
                    (this.parser = void 0)),
                  !0)
                )
              }
            }
            class c extends s {
              constructor() {
                ;(super(), (this.map = { stop: new a() }))
              }
              get name() {
                return 'gradient'
              }
              get tag() {
                return 'gradientFill'
              }
              render(d, h) {
                switch ((d.openNode('gradientFill'), h.gradient)) {
                  case 'angle':
                    d.addAttribute('degree', h.degree)
                    break
                  case 'path':
                    ;(d.addAttribute('type', 'path'),
                      h.center.left &&
                        (d.addAttribute('left', h.center.left),
                        h.center.right === void 0 && d.addAttribute('right', h.center.left)),
                      h.center.right && d.addAttribute('right', h.center.right),
                      h.center.top &&
                        (d.addAttribute('top', h.center.top),
                        h.center.bottom === void 0 && d.addAttribute('bottom', h.center.top)),
                      h.center.bottom && d.addAttribute('bottom', h.center.bottom))
                }
                const p = this.map.stop
                ;(h.stops.forEach((g) => {
                  p.render(d, g)
                }),
                  d.closeNode())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case 'gradientFill': {
                    const h = (this.model = { stops: [] })
                    return (
                      d.attributes.degree
                        ? ((h.gradient = 'angle'), (h.degree = parseInt(d.attributes.degree, 10)))
                        : d.attributes.type === 'path' &&
                          ((h.gradient = 'path'),
                          (h.center = {
                            left: d.attributes.left ? parseFloat(d.attributes.left) : 0,
                            top: d.attributes.top ? parseFloat(d.attributes.top) : 0,
                          }),
                          d.attributes.right !== d.attributes.left &&
                            (h.center.right = d.attributes.right
                              ? parseFloat(d.attributes.right)
                              : 0),
                          d.attributes.bottom !== d.attributes.top &&
                            (h.center.bottom = d.attributes.bottom
                              ? parseFloat(d.attributes.bottom)
                              : 0)),
                      !0
                    )
                  }
                  case 'stop':
                    return ((this.parser = this.map.stop), this.parser.parseOpen(d), !0)
                  default:
                    return !1
                }
              }
              parseText(d) {
                this.parser && this.parser.parseText(d)
              }
              parseClose(d) {
                return (
                  !!this.parser &&
                  (this.parser.parseClose(d) ||
                    (this.model.stops.push(this.parser.model), (this.parser = void 0)),
                  !0)
                )
              }
            }
            class u extends s {
              constructor() {
                ;(super(), (this.map = { patternFill: new l(), gradientFill: new c() }))
              }
              get tag() {
                return 'fill'
              }
              render(d, h) {
                switch ((d.addRollback(), d.openNode('fill'), h.type)) {
                  case 'pattern':
                    this.map.patternFill.render(d, h)
                    break
                  case 'gradient':
                    this.map.gradientFill.render(d, h)
                    break
                  default:
                    return void d.rollback()
                }
                ;(d.closeNode(), d.commit())
              }
              parseOpen(d) {
                if (this.parser) return (this.parser.parseOpen(d), !0)
                switch (d.name) {
                  case 'fill':
                    return ((this.model = {}), !0)
                  default:
                    return (
                      (this.parser = this.map[d.name]),
                      !!this.parser && (this.parser.parseOpen(d), !0)
                    )
                }
              }
              parseText(d) {
                this.parser && this.parser.parseText(d)
              }
              parseClose(d) {
                return (
                  !!this.parser &&
                  (this.parser.parseClose(d) ||
                    ((this.model = this.parser.model),
                    (this.model.type = this.parser.name),
                    (this.parser = void 0)),
                  !0)
                )
              }
              validStyle(d) {
                return u.validPatternValues[d]
              }
            }
            ;((u.validPatternValues = [
              'none',
              'solid',
              'darkVertical',
              'darkGray',
              'mediumGray',
              'lightGray',
              'gray125',
              'gray0625',
              'darkHorizontal',
              'darkVertical',
              'darkDown',
              'darkUp',
              'darkGrid',
              'darkTrellis',
              'lightHorizontal',
              'lightVertical',
              'lightDown',
              'lightUp',
              'lightGrid',
              'lightTrellis',
              'lightGrid',
            ].reduce((f, d) => ((f[d] = !0), f), {})),
              (u.StopXform = a),
              (u.PatternFillXform = l),
              (u.GradientFillXform = c),
              (r.exports = u))
          },
          { '../base-xform': 32, './color-xform': 128 },
        ],
        131: [
          function (t, r, i) {
            const s = t('./color-xform'),
              o = t('../simple/boolean-xform'),
              a = t('../simple/integer-xform'),
              l = t('../simple/string-xform'),
              c = t('./underline-xform'),
              u = t('../../../utils/under-dash'),
              f = t('../base-xform')
            class d extends f {
              constructor(p) {
                ;(super(),
                  (this.options = p || d.OPTIONS),
                  (this.map = {
                    b: { prop: 'bold', xform: new o({ tag: 'b', attr: 'val' }) },
                    i: { prop: 'italic', xform: new o({ tag: 'i', attr: 'val' }) },
                    u: { prop: 'underline', xform: new c() },
                    charset: { prop: 'charset', xform: new a({ tag: 'charset', attr: 'val' }) },
                    color: { prop: 'color', xform: new s() },
                    condense: { prop: 'condense', xform: new o({ tag: 'condense', attr: 'val' }) },
                    extend: { prop: 'extend', xform: new o({ tag: 'extend', attr: 'val' }) },
                    family: { prop: 'family', xform: new a({ tag: 'family', attr: 'val' }) },
                    outline: { prop: 'outline', xform: new o({ tag: 'outline', attr: 'val' }) },
                    vertAlign: {
                      prop: 'vertAlign',
                      xform: new l({ tag: 'vertAlign', attr: 'val' }),
                    },
                    scheme: { prop: 'scheme', xform: new l({ tag: 'scheme', attr: 'val' }) },
                    shadow: { prop: 'shadow', xform: new o({ tag: 'shadow', attr: 'val' }) },
                    strike: { prop: 'strike', xform: new o({ tag: 'strike', attr: 'val' }) },
                    sz: { prop: 'size', xform: new a({ tag: 'sz', attr: 'val' }) },
                  }),
                  (this.map[this.options.fontNameTag] = {
                    prop: 'name',
                    xform: new l({ tag: this.options.fontNameTag, attr: 'val' }),
                  }))
              }
              get tag() {
                return this.options.tagName
              }
              render(p, g) {
                const { map: m } = this
                ;(p.openNode(this.options.tagName),
                  u.each(this.map, (y, b) => {
                    m[b].xform.render(p, g[y.prop])
                  }),
                  p.closeNode())
              }
              parseOpen(p) {
                if (this.parser) return (this.parser.parseOpen(p), !0)
                if (this.map[p.name])
                  return ((this.parser = this.map[p.name].xform), this.parser.parseOpen(p))
                switch (p.name) {
                  case this.options.tagName:
                    return ((this.model = {}), !0)
                  default:
                    return !1
                }
              }
              parseText(p) {
                this.parser && this.parser.parseText(p)
              }
              parseClose(p) {
                if (this.parser && !this.parser.parseClose(p)) {
                  const g = this.map[p]
                  return (
                    this.parser.model && (this.model[g.prop] = this.parser.model),
                    (this.parser = void 0),
                    !0
                  )
                }
                switch (p) {
                  case this.options.tagName:
                    return !1
                  default:
                    return !0
                }
              }
            }
            ;((d.OPTIONS = { tagName: 'font', fontNameTag: 'name' }), (r.exports = d))
          },
          {
            '../../../utils/under-dash': 26,
            '../base-xform': 32,
            '../simple/boolean-xform': 116,
            '../simple/integer-xform': 118,
            '../simple/string-xform': 119,
            './color-xform': 128,
            './underline-xform': 136,
          },
        ],
        132: [
          function (t, r, i) {
            const s = t('../../../utils/under-dash'),
              o = t('../../defaultnumformats'),
              a = t('../base-xform'),
              l = (function () {
                const u = {}
                return (
                  s.each(o, (f, d) => {
                    f.f && (u[f.f] = parseInt(d, 10))
                  }),
                  u
                )
              })()
            class c extends a {
              constructor(f, d) {
                ;(super(), (this.id = f), (this.formatCode = d))
              }
              get tag() {
                return 'numFmt'
              }
              render(f, d) {
                f.leafNode('numFmt', { numFmtId: d.id, formatCode: d.formatCode })
              }
              parseOpen(f) {
                switch (f.name) {
                  case 'numFmt':
                    return (
                      (this.model = {
                        id: parseInt(f.attributes.numFmtId, 10),
                        formatCode: f.attributes.formatCode.replace(/[\\](.)/g, '$1'),
                      }),
                      !0
                    )
                  default:
                    return !1
                }
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
            ;((c.getDefaultFmtId = function (u) {
              return l[u]
            }),
              (c.getDefaultFmtCode = function (u) {
                return o[u] && o[u].f
              }),
              (r.exports = c))
          },
          { '../../../utils/under-dash': 26, '../../defaultnumformats': 30, '../base-xform': 32 },
        ],
        133: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = { boolean: (a, l) => (a === void 0 ? l : a) }
            r.exports = class extends s {
              get tag() {
                return 'protection'
              }
              render(a, l) {
                ;(a.addRollback(), a.openNode('protection'))
                let c = !1
                function u(f, d) {
                  d !== void 0 && (a.addAttribute(f, d), (c = !0))
                }
                ;(u('locked', o.boolean(l.locked, !0) ? void 0 : '0'),
                  u('hidden', o.boolean(l.hidden, !1) ? '1' : void 0),
                  a.closeNode(),
                  c ? a.commit() : a.rollback())
              }
              parseOpen(a) {
                const l = {
                    locked: a.attributes.locked !== '0',
                    hidden: a.attributes.hidden === '1',
                  },
                  c = !l.locked || l.hidden
                this.model = c ? l : null
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        134: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./alignment-xform'),
              a = t('./protection-xform')
            r.exports = class extends s {
              constructor(l) {
                ;(super(),
                  (this.xfId = !(!l || !l.xfId)),
                  (this.map = { alignment: new o(), protection: new a() }))
              }
              get tag() {
                return 'xf'
              }
              render(l, c) {
                ;(l.openNode('xf', {
                  numFmtId: c.numFmtId || 0,
                  fontId: c.fontId || 0,
                  fillId: c.fillId || 0,
                  borderId: c.borderId || 0,
                }),
                  this.xfId && l.addAttribute('xfId', c.xfId || 0),
                  c.numFmtId && l.addAttribute('applyNumberFormat', '1'),
                  c.fontId && l.addAttribute('applyFont', '1'),
                  c.fillId && l.addAttribute('applyFill', '1'),
                  c.borderId && l.addAttribute('applyBorder', '1'),
                  c.alignment && l.addAttribute('applyAlignment', '1'),
                  c.protection && l.addAttribute('applyProtection', '1'),
                  c.alignment && this.map.alignment.render(l, c.alignment),
                  c.protection && this.map.protection.render(l, c.protection),
                  l.closeNode())
              }
              parseOpen(l) {
                if (this.parser) return (this.parser.parseOpen(l), !0)
                switch (l.name) {
                  case 'xf':
                    return (
                      (this.model = {
                        numFmtId: parseInt(l.attributes.numFmtId, 10),
                        fontId: parseInt(l.attributes.fontId, 10),
                        fillId: parseInt(l.attributes.fillId, 10),
                        borderId: parseInt(l.attributes.borderId, 10),
                      }),
                      this.xfId && (this.model.xfId = parseInt(l.attributes.xfId, 10)),
                      !0
                    )
                  case 'alignment':
                    return ((this.parser = this.map.alignment), this.parser.parseOpen(l), !0)
                  case 'protection':
                    return ((this.parser = this.map.protection), this.parser.parseOpen(l), !0)
                  default:
                    return !1
                }
              }
              parseText(l) {
                this.parser && this.parser.parseText(l)
              }
              parseClose(l) {
                return this.parser
                  ? (this.parser.parseClose(l) ||
                      (this.map.protection === this.parser
                        ? (this.model.protection = this.parser.model)
                        : (this.model.alignment = this.parser.model),
                      (this.parser = void 0)),
                    !0)
                  : l !== 'xf'
              }
            }
          },
          { '../base-xform': 32, './alignment-xform': 126, './protection-xform': 133 },
        ],
        135: [
          function (t, r, i) {
            const s = t('../../../doc/enums'),
              o = t('../../../utils/xml-stream'),
              a = t('../base-xform'),
              l = t('../static-xform'),
              c = t('../list-xform'),
              u = t('./font-xform'),
              f = t('./fill-xform'),
              d = t('./border-xform'),
              h = t('./numfmt-xform'),
              p = t('./style-xform'),
              g = t('./dxf-xform')
            class m extends a {
              constructor(b) {
                ;(super(),
                  (this.map = {
                    numFmts: new c({ tag: 'numFmts', count: !0, childXform: new h() }),
                    fonts: new c({
                      tag: 'fonts',
                      count: !0,
                      childXform: new u(),
                      $: { 'x14ac:knownFonts': 1 },
                    }),
                    fills: new c({ tag: 'fills', count: !0, childXform: new f() }),
                    borders: new c({ tag: 'borders', count: !0, childXform: new d() }),
                    cellStyleXfs: new c({ tag: 'cellStyleXfs', count: !0, childXform: new p() }),
                    cellXfs: new c({ tag: 'cellXfs', count: !0, childXform: new p({ xfId: !0 }) }),
                    dxfs: new c({ tag: 'dxfs', always: !0, count: !0, childXform: new g() }),
                    numFmt: new h(),
                    font: new u(),
                    fill: new f(),
                    border: new d(),
                    style: new p({ xfId: !0 }),
                    cellStyles: m.STATIC_XFORMS.cellStyles,
                    tableStyles: m.STATIC_XFORMS.tableStyles,
                    extLst: m.STATIC_XFORMS.extLst,
                  }),
                  b && this.init())
              }
              initIndex() {
                this.index = {
                  style: {},
                  numFmt: {},
                  numFmtNextId: 164,
                  font: {},
                  border: {},
                  fill: {},
                }
              }
              init() {
                ;((this.model = {
                  styles: [],
                  numFmts: [],
                  fonts: [],
                  borders: [],
                  fills: [],
                  dxfs: [],
                }),
                  this.initIndex(),
                  this._addBorder({}),
                  this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }),
                  this._addFill({ type: 'pattern', pattern: 'none' }),
                  this._addFill({ type: 'pattern', pattern: 'gray125' }),
                  (this.weakMap = new WeakMap()))
              }
              render(b, w) {
                ;((w = w || this.model),
                  b.openXml(o.StdDocAttributes),
                  b.openNode('styleSheet', m.STYLESHEET_ATTRIBUTES),
                  this.index
                    ? (w.numFmts &&
                        w.numFmts.length &&
                        (b.openNode('numFmts', { count: w.numFmts.length }),
                        w.numFmts.forEach((C) => {
                          b.writeXml(C)
                        }),
                        b.closeNode()),
                      w.fonts.length ||
                        this._addFont({
                          size: 11,
                          color: { theme: 1 },
                          name: 'Calibri',
                          family: 2,
                          scheme: 'minor',
                        }),
                      b.openNode('fonts', { count: w.fonts.length, 'x14ac:knownFonts': 1 }),
                      w.fonts.forEach((C) => {
                        b.writeXml(C)
                      }),
                      b.closeNode(),
                      b.openNode('fills', { count: w.fills.length }),
                      w.fills.forEach((C) => {
                        b.writeXml(C)
                      }),
                      b.closeNode(),
                      b.openNode('borders', { count: w.borders.length }),
                      w.borders.forEach((C) => {
                        b.writeXml(C)
                      }),
                      b.closeNode(),
                      this.map.cellStyleXfs.render(b, [
                        { numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 },
                      ]),
                      b.openNode('cellXfs', { count: w.styles.length }),
                      w.styles.forEach((C) => {
                        b.writeXml(C)
                      }),
                      b.closeNode())
                    : (this.map.numFmts.render(b, w.numFmts),
                      this.map.fonts.render(b, w.fonts),
                      this.map.fills.render(b, w.fills),
                      this.map.borders.render(b, w.borders),
                      this.map.cellStyleXfs.render(b, [
                        { numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 },
                      ]),
                      this.map.cellXfs.render(b, w.styles)),
                  m.STATIC_XFORMS.cellStyles.render(b),
                  this.map.dxfs.render(b, w.dxfs),
                  m.STATIC_XFORMS.tableStyles.render(b),
                  m.STATIC_XFORMS.extLst.render(b),
                  b.closeNode())
              }
              parseOpen(b) {
                if (this.parser) return (this.parser.parseOpen(b), !0)
                switch (b.name) {
                  case 'styleSheet':
                    return (this.initIndex(), !0)
                  default:
                    return (
                      (this.parser = this.map[b.name]),
                      this.parser && this.parser.parseOpen(b),
                      !0
                    )
                }
              }
              parseText(b) {
                this.parser && this.parser.parseText(b)
              }
              parseClose(b) {
                if (this.parser) return (this.parser.parseClose(b) || (this.parser = void 0), !0)
                switch (b) {
                  case 'styleSheet': {
                    this.model = {}
                    const w = (C, T) => {
                      T.model && T.model.length && (this.model[C] = T.model)
                    }
                    if (
                      (w('numFmts', this.map.numFmts),
                      w('fonts', this.map.fonts),
                      w('fills', this.map.fills),
                      w('borders', this.map.borders),
                      w('styles', this.map.cellXfs),
                      w('dxfs', this.map.dxfs),
                      (this.index = { model: [], numFmt: [] }),
                      this.model.numFmts)
                    ) {
                      const C = this.index.numFmt
                      this.model.numFmts.forEach((T) => {
                        C[T.id] = T.formatCode
                      })
                    }
                    return !1
                  }
                  default:
                    return !0
                }
              }
              addStyleModel(b, w) {
                if (!b) return 0
                if (
                  (this.model.fonts.length ||
                    this._addFont({
                      size: 11,
                      color: { theme: 1 },
                      name: 'Calibri',
                      family: 2,
                      scheme: 'minor',
                    }),
                  this.weakMap && this.weakMap.has(b))
                )
                  return this.weakMap.get(b)
                const C = {}
                if (((w = w || s.ValueType.Number), b.numFmt))
                  C.numFmtId = this._addNumFmtStr(b.numFmt)
                else
                  switch (w) {
                    case s.ValueType.Number:
                      C.numFmtId = this._addNumFmtStr('General')
                      break
                    case s.ValueType.Date:
                      C.numFmtId = this._addNumFmtStr('mm-dd-yy')
                  }
                ;(b.font && (C.fontId = this._addFont(b.font)),
                  b.border && (C.borderId = this._addBorder(b.border)),
                  b.fill && (C.fillId = this._addFill(b.fill)),
                  b.alignment && (C.alignment = b.alignment),
                  b.protection && (C.protection = b.protection))
                const T = this._addStyle(C)
                return (this.weakMap && this.weakMap.set(b, T), T)
              }
              getStyleModel(b) {
                const w = this.model.styles[b]
                if (!w) return null
                let C = this.index.model[b]
                if (C) return C
                if (((C = this.index.model[b] = {}), w.numFmtId)) {
                  const I = this.index.numFmt[w.numFmtId] || h.getDefaultFmtCode(w.numFmtId)
                  I && (C.numFmt = I)
                }
                function T(I, B, E) {
                  if (E || E === 0) {
                    const O = B[E]
                    O && (C[I] = O)
                  }
                }
                return (
                  T('font', this.model.fonts, w.fontId),
                  T('border', this.model.borders, w.borderId),
                  T('fill', this.model.fills, w.fillId),
                  w.alignment && (C.alignment = w.alignment),
                  w.protection && (C.protection = w.protection),
                  C
                )
              }
              addDxfStyle(b) {
                return (
                  b.numFmt && (b.numFmtId = this._addNumFmtStr(b.numFmt)),
                  this.model.dxfs.push(b),
                  this.model.dxfs.length - 1
                )
              }
              getDxfStyle(b) {
                return this.model.dxfs[b]
              }
              _addStyle(b) {
                const w = this.map.style.toXml(b)
                let C = this.index.style[w]
                return (
                  C === void 0 &&
                    ((C = this.index.style[w] = this.model.styles.length),
                    this.model.styles.push(w)),
                  C
                )
              }
              _addNumFmtStr(b) {
                let w = h.getDefaultFmtId(b)
                if (w !== void 0 || ((w = this.index.numFmt[b]), w !== void 0)) return w
                w = this.index.numFmt[b] = 164 + this.model.numFmts.length
                const C = this.map.numFmt.toXml({ id: w, formatCode: b })
                return (this.model.numFmts.push(C), w)
              }
              _addFont(b) {
                const w = this.map.font.toXml(b)
                let C = this.index.font[w]
                return (
                  C === void 0 &&
                    ((C = this.index.font[w] = this.model.fonts.length), this.model.fonts.push(w)),
                  C
                )
              }
              _addBorder(b) {
                const w = this.map.border.toXml(b)
                let C = this.index.border[w]
                return (
                  C === void 0 &&
                    ((C = this.index.border[w] = this.model.borders.length),
                    this.model.borders.push(w)),
                  C
                )
              }
              _addFill(b) {
                const w = this.map.fill.toXml(b)
                let C = this.index.fill[w]
                return (
                  C === void 0 &&
                    ((C = this.index.fill[w] = this.model.fills.length), this.model.fills.push(w)),
                  C
                )
              }
            }
            ;((m.STYLESHEET_ATTRIBUTES = {
              xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
              'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
              'mc:Ignorable': 'x14ac x16r2',
              'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
              'xmlns:x16r2': 'http://schemas.microsoft.com/office/spreadsheetml/2015/02/main',
            }),
              (m.STATIC_XFORMS = {
                cellStyles: new l({
                  tag: 'cellStyles',
                  $: { count: 1 },
                  c: [{ tag: 'cellStyle', $: { name: 'Normal', xfId: 0, builtinId: 0 } }],
                }),
                dxfs: new l({ tag: 'dxfs', $: { count: 0 } }),
                tableStyles: new l({
                  tag: 'tableStyles',
                  $: {
                    count: 0,
                    defaultTableStyle: 'TableStyleMedium2',
                    defaultPivotStyle: 'PivotStyleLight16',
                  },
                }),
                extLst: new l({
                  tag: 'extLst',
                  c: [
                    {
                      tag: 'ext',
                      $: {
                        uri: '{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}',
                        'xmlns:x14':
                          'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
                      },
                      c: [
                        { tag: 'x14:slicerStyles', $: { defaultSlicerStyle: 'SlicerStyleLight1' } },
                      ],
                    },
                    {
                      tag: 'ext',
                      $: {
                        uri: '{9260A510-F301-46a8-8635-F512D64BE5F5}',
                        'xmlns:x15':
                          'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',
                      },
                      c: [
                        {
                          tag: 'x15:timelineStyles',
                          $: { defaultTimelineStyle: 'TimeSlicerStyleLight1' },
                        },
                      ],
                    },
                  ],
                }),
              }),
              (m.Mock = class extends m {
                constructor() {
                  ;(super(),
                    (this.model = {
                      styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }],
                      numFmts: [],
                      fonts: [
                        {
                          size: 11,
                          color: { theme: 1 },
                          name: 'Calibri',
                          family: 2,
                          scheme: 'minor',
                        },
                      ],
                      borders: [{}],
                      fills: [
                        { type: 'pattern', pattern: 'none' },
                        { type: 'pattern', pattern: 'gray125' },
                      ],
                    }))
                }
                parseStream(y) {
                  return (y.autodrain(), Promise.resolve())
                }
                addStyleModel(y, b) {
                  switch (b) {
                    case s.ValueType.Date:
                      return this.dateStyleId
                    default:
                      return 0
                  }
                }
                get dateStyleId() {
                  if (!this._dateStyleId) {
                    const y = { numFmtId: h.getDefaultFmtId('mm-dd-yy') }
                    ;((this._dateStyleId = this.model.styles.length), this.model.styles.push(y))
                  }
                  return this._dateStyleId
                }
                getStyleModel() {
                  return {}
                }
              }),
              (r.exports = m))
          },
          {
            '../../../doc/enums': 7,
            '../../../utils/xml-stream': 28,
            '../base-xform': 32,
            '../list-xform': 71,
            '../static-xform': 120,
            './border-xform': 127,
            './dxf-xform': 129,
            './fill-xform': 130,
            './font-xform': 131,
            './numfmt-xform': 132,
            './style-xform': 134,
          },
        ],
        136: [
          function (t, r, i) {
            const s = t('../base-xform')
            class o extends s {
              constructor(l) {
                ;(super(), (this.model = l))
              }
              get tag() {
                return 'u'
              }
              render(l, c) {
                if ((c = c || this.model) === !0) l.leafNode('u')
                else {
                  const u = o.Attributes[c]
                  u && l.leafNode('u', u)
                }
              }
              parseOpen(l) {
                l.name === 'u' && (this.model = l.attributes.val || !0)
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
            ;((o.Attributes = {
              single: {},
              double: { val: 'double' },
              singleAccounting: { val: 'singleAccounting' },
              doubleAccounting: { val: 'doubleAccounting' },
            }),
              (r.exports = o))
          },
          { '../base-xform': 32 },
        ],
        137: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('./filter-column-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(), (this.map = { filterColumn: new o() }))
              }
              get tag() {
                return 'autoFilter'
              }
              prepare(a) {
                a.columns.forEach((l, c) => {
                  this.map.filterColumn.prepare(l, { index: c })
                })
              }
              render(a, l) {
                return (
                  a.openNode(this.tag, { ref: l.autoFilterRef }),
                  l.columns.forEach((c) => {
                    this.map.filterColumn.render(a, c)
                  }),
                  a.closeNode(),
                  !0
                )
              }
              parseOpen(a) {
                if (this.parser) return (this.parser.parseOpen(a), !0)
                switch (a.name) {
                  case this.tag:
                    return ((this.model = { autoFilterRef: a.attributes.ref, columns: [] }), !0)
                  default:
                    if (((this.parser = this.map[a.name]), this.parser))
                      return (this.parseOpen(a), !0)
                    throw new Error('Unexpected xml node in parseOpen: ' + JSON.stringify(a))
                }
              }
              parseText(a) {
                this.parser && this.parser.parseText(a)
              }
              parseClose(a) {
                if (this.parser)
                  return (
                    this.parser.parseClose(a) ||
                      (this.model.columns.push(this.parser.model), (this.parser = void 0)),
                    !0
                  )
                switch (a) {
                  case this.tag:
                    return !1
                  default:
                    throw new Error('Unexpected xml node in parseClose: ' + a)
                }
              }
            }
          },
          { '../base-xform': 32, './filter-column-xform': 139 },
        ],
        138: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'customFilter'
              }
              render(o, a) {
                o.leafNode(this.tag, { val: a.val, operator: a.operator })
              }
              parseOpen(o) {
                return (
                  o.name === this.tag &&
                  ((this.model = { val: o.attributes.val, operator: o.attributes.operator }), !0)
                )
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        139: [
          function (t, r, i) {
            const s = t('../base-xform'),
              o = t('../list-xform'),
              a = t('./custom-filter-xform'),
              l = t('./filter-xform')
            r.exports = class extends s {
              constructor() {
                ;(super(),
                  (this.map = {
                    customFilters: new o({
                      tag: 'customFilters',
                      count: !1,
                      empty: !0,
                      childXform: new a(),
                    }),
                    filters: new o({ tag: 'filters', count: !1, empty: !0, childXform: new l() }),
                  }))
              }
              get tag() {
                return 'filterColumn'
              }
              prepare(c, u) {
                c.colId = u.index.toString()
              }
              render(c, u) {
                return u.customFilters
                  ? (c.openNode(this.tag, {
                      colId: u.colId,
                      hiddenButton: u.filterButton ? '0' : '1',
                    }),
                    this.map.customFilters.render(c, u.customFilters),
                    c.closeNode(),
                    !0)
                  : (c.leafNode(this.tag, {
                      colId: u.colId,
                      hiddenButton: u.filterButton ? '0' : '1',
                    }),
                    !0)
              }
              parseOpen(c) {
                if (this.parser) return (this.parser.parseOpen(c), !0)
                const { attributes: u } = c
                switch (c.name) {
                  case this.tag:
                    return ((this.model = { filterButton: u.hiddenButton === '0' }), !0)
                  default:
                    if (((this.parser = this.map[c.name]), this.parser))
                      return (this.parseOpen(c), !0)
                    throw new Error('Unexpected xml node in parseOpen: ' + JSON.stringify(c))
                }
              }
              parseText() {}
              parseClose(c) {
                if (this.parser) return (this.parser.parseClose(c) || (this.parser = void 0), !0)
                switch (c) {
                  case this.tag:
                    return ((this.model.customFilters = this.map.customFilters.model), !1)
                  default:
                    return !0
                }
              }
            }
          },
          {
            '../base-xform': 32,
            '../list-xform': 71,
            './custom-filter-xform': 138,
            './filter-xform': 140,
          },
        ],
        140: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'filter'
              }
              render(o, a) {
                o.leafNode(this.tag, { val: a.val })
              }
              parseOpen(o) {
                return o.name === this.tag && ((this.model = { val: o.attributes.val }), !0)
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        141: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'tableColumn'
              }
              prepare(o, a) {
                o.id = a.index + 1
              }
              render(o, a) {
                return (
                  o.leafNode(this.tag, {
                    id: a.id.toString(),
                    name: a.name,
                    totalsRowLabel: a.totalsRowLabel,
                    totalsRowFunction: a.totalsRowFunction,
                    dxfId: a.dxfId,
                  }),
                  !0
                )
              }
              parseOpen(o) {
                if (o.name === this.tag) {
                  const { attributes: a } = o
                  return (
                    (this.model = {
                      name: a.name,
                      totalsRowLabel: a.totalsRowLabel,
                      totalsRowFunction: a.totalsRowFunction,
                      dxfId: a.dxfId,
                    }),
                    !0
                  )
                }
                return !1
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        142: [
          function (t, r, i) {
            const s = t('../base-xform')
            r.exports = class extends s {
              get tag() {
                return 'tableStyleInfo'
              }
              render(o, a) {
                return (
                  o.leafNode(this.tag, {
                    name: a.theme ? a.theme : void 0,
                    showFirstColumn: a.showFirstColumn ? '1' : '0',
                    showLastColumn: a.showLastColumn ? '1' : '0',
                    showRowStripes: a.showRowStripes ? '1' : '0',
                    showColumnStripes: a.showColumnStripes ? '1' : '0',
                  }),
                  !0
                )
              }
              parseOpen(o) {
                if (o.name === this.tag) {
                  const { attributes: a } = o
                  return (
                    (this.model = {
                      theme: a.name ? a.name : null,
                      showFirstColumn: a.showFirstColumn === '1',
                      showLastColumn: a.showLastColumn === '1',
                      showRowStripes: a.showRowStripes === '1',
                      showColumnStripes: a.showColumnStripes === '1',
                    }),
                    !0
                  )
                }
                return !1
              }
              parseText() {}
              parseClose() {
                return !1
              }
            }
          },
          { '../base-xform': 32 },
        ],
        143: [
          function (t, r, i) {
            const s = t('../../../utils/xml-stream'),
              o = t('../base-xform'),
              a = t('../list-xform'),
              l = t('./auto-filter-xform'),
              c = t('./table-column-xform'),
              u = t('./table-style-info-xform')
            class f extends o {
              constructor() {
                ;(super(),
                  (this.map = {
                    autoFilter: new l(),
                    tableColumns: new a({
                      tag: 'tableColumns',
                      count: !0,
                      empty: !0,
                      childXform: new c(),
                    }),
                    tableStyleInfo: new u(),
                  }))
              }
              prepare(h, p) {
                ;(this.map.autoFilter.prepare(h), this.map.tableColumns.prepare(h.columns, p))
              }
              get tag() {
                return 'table'
              }
              render(h, p) {
                ;(h.openXml(s.StdDocAttributes),
                  h.openNode(this.tag, {
                    ...f.TABLE_ATTRIBUTES,
                    id: p.id,
                    name: p.name,
                    displayName: p.displayName || p.name,
                    ref: p.tableRef,
                    totalsRowCount: p.totalsRow ? '1' : void 0,
                    totalsRowShown: p.totalsRow ? void 0 : '1',
                    headerRowCount: p.headerRow ? '1' : '0',
                  }),
                  this.map.autoFilter.render(h, p),
                  this.map.tableColumns.render(h, p.columns),
                  this.map.tableStyleInfo.render(h, p.style),
                  h.closeNode())
              }
              parseOpen(h) {
                if (this.parser) return (this.parser.parseOpen(h), !0)
                const { name: p, attributes: g } = h
                switch (p) {
                  case this.tag:
                    ;(this.reset(),
                      (this.model = {
                        name: g.name,
                        displayName: g.displayName || g.name,
                        tableRef: g.ref,
                        totalsRow: g.totalsRowCount === '1',
                        headerRow: g.headerRowCount === '1',
                      }))
                    break
                  default:
                    ;((this.parser = this.map[h.name]), this.parser && this.parser.parseOpen(h))
                }
                return !0
              }
              parseText(h) {
                this.parser && this.parser.parseText(h)
              }
              parseClose(h) {
                if (this.parser) return (this.parser.parseClose(h) || (this.parser = void 0), !0)
                switch (h) {
                  case this.tag:
                    return (
                      (this.model.columns = this.map.tableColumns.model),
                      this.map.autoFilter.model &&
                        ((this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef),
                        this.map.autoFilter.model.columns.forEach((p, g) => {
                          this.model.columns[g].filterButton = p.filterButton
                        })),
                      (this.model.style = this.map.tableStyleInfo.model),
                      !1
                    )
                  default:
                    return !0
                }
              }
              reconcile(h, p) {
                h.columns.forEach((g) => {
                  g.dxfId !== void 0 && (g.style = p.styles.getDxfStyle(g.dxfId))
                })
              }
            }
            ;((f.TABLE_ATTRIBUTES = {
              xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
              'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
              'mc:Ignorable': 'xr xr3',
              'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',
              'xmlns:xr3': 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3',
            }),
              (r.exports = f))
          },
          {
            '../../../utils/xml-stream': 28,
            '../base-xform': 32,
            '../list-xform': 71,
            './auto-filter-xform': 137,
            './table-column-xform': 141,
            './table-style-info-xform': 142,
          },
        ],
        144: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                const a = t('fs'),
                  l = t('jszip'),
                  { PassThrough: c } = t('readable-stream'),
                  u = t('../utils/zip-stream'),
                  f = t('../utils/stream-buf'),
                  d = t('../utils/utils'),
                  h = t('../utils/xml-stream'),
                  { bufferToString: p } = t('../utils/browser-buffer-decode'),
                  g = t('./xform/style/styles-xform'),
                  m = t('./xform/core/core-xform'),
                  y = t('./xform/strings/shared-strings-xform'),
                  b = t('./xform/core/relationships-xform'),
                  w = t('./xform/core/content-types-xform'),
                  C = t('./xform/core/app-xform'),
                  T = t('./xform/book/workbook-xform'),
                  I = t('./xform/sheet/worksheet-xform'),
                  B = t('./xform/drawing/drawing-xform'),
                  E = t('./xform/table/table-xform'),
                  O = t('./xform/comment/comments-xform'),
                  P = t('./xform/comment/vml-notes-xform'),
                  $ = t('./xml/theme1')
                class F {
                  constructor(R) {
                    this.workbook = R
                  }
                  async readFile(R, k) {
                    if (!(await d.fs.exists(R))) throw new Error('File not found: ' + R)
                    const v = a.createReadStream(R)
                    try {
                      const x = await this.read(v, k)
                      return (v.close(), x)
                    } catch (x) {
                      throw (v.close(), x)
                    }
                  }
                  parseRels(R) {
                    return new b().parseStream(R)
                  }
                  parseWorkbook(R) {
                    return new T().parseStream(R)
                  }
                  parseSharedStrings(R) {
                    return new y().parseStream(R)
                  }
                  reconcile(R, k) {
                    const v = new T(),
                      x = new I(k),
                      _ = new B(),
                      S = new E()
                    v.reconcile(R)
                    const A = { media: R.media, mediaIndex: R.mediaIndex }
                    Object.keys(R.drawings).forEach((H) => {
                      const U = R.drawings[H],
                        K = R.drawingRels[H]
                      K &&
                        ((A.rels = K.reduce((z, q) => ((z[q.Id] = q), z), {})),
                        (U.anchors || []).forEach((z) => {
                          const q = z.picture && z.picture.hyperlinks
                          q && A.rels[q.rId] && ((q.hyperlink = A.rels[q.rId].Target), delete q.rId)
                        }),
                        _.reconcile(U, A))
                    })
                    const j = { styles: R.styles }
                    Object.values(R.tables).forEach((H) => {
                      S.reconcile(H, j)
                    })
                    const L = {
                      styles: R.styles,
                      sharedStrings: R.sharedStrings,
                      media: R.media,
                      mediaIndex: R.mediaIndex,
                      date1904: R.properties && R.properties.date1904,
                      drawings: R.drawings,
                      comments: R.comments,
                      tables: R.tables,
                      vmlDrawings: R.vmlDrawings,
                    }
                    ;(R.worksheets.forEach((H) => {
                      ;((H.relationships = R.worksheetRels[H.sheetNo]), x.reconcile(H, L))
                    }),
                      delete R.worksheetHash,
                      delete R.worksheetRels,
                      delete R.globalRels,
                      delete R.sharedStrings,
                      delete R.workbookRels,
                      delete R.sheetDefs,
                      delete R.styles,
                      delete R.mediaIndex,
                      delete R.drawings,
                      delete R.drawingRels,
                      delete R.vmlDrawings)
                  }
                  async _processWorksheetEntry(R, k, v, x, _) {
                    const S = new I(x),
                      A = await S.parseStream(R)
                    ;((A.sheetNo = v), (k.worksheetHash[_] = A), k.worksheets.push(A))
                  }
                  async _processCommentEntry(R, k, v) {
                    const x = new O(),
                      _ = await x.parseStream(R)
                    k.comments[`../${v}.xml`] = _
                  }
                  async _processTableEntry(R, k, v) {
                    const x = new E(),
                      _ = await x.parseStream(R)
                    k.tables[`../tables/${v}.xml`] = _
                  }
                  async _processWorksheetRelsEntry(R, k, v) {
                    const x = new b(),
                      _ = await x.parseStream(R)
                    k.worksheetRels[v] = _
                  }
                  async _processMediaEntry(R, k, v) {
                    const x = v.lastIndexOf('.')
                    if (x >= 1) {
                      const _ = v.substr(x + 1),
                        S = v.substr(0, x)
                      await new Promise((A, j) => {
                        const L = new f()
                        ;(L.on('finish', () => {
                          ;((k.mediaIndex[v] = k.media.length), (k.mediaIndex[S] = k.media.length))
                          const H = { type: 'image', name: S, extension: _, buffer: L.toBuffer() }
                          ;(k.media.push(H), A())
                        }),
                          R.on('error', (H) => {
                            j(H)
                          }),
                          R.pipe(L))
                      })
                    }
                  }
                  async _processDrawingEntry(R, k, v) {
                    const x = new B(),
                      _ = await x.parseStream(R)
                    k.drawings[v] = _
                  }
                  async _processDrawingRelsEntry(R, k, v) {
                    const x = new b(),
                      _ = await x.parseStream(R)
                    k.drawingRels[v] = _
                  }
                  async _processVmlDrawingEntry(R, k, v) {
                    const x = new P(),
                      _ = await x.parseStream(R)
                    k.vmlDrawings[`../drawings/${v}.vml`] = _
                  }
                  async _processThemeEntry(R, k, v) {
                    await new Promise((x, _) => {
                      const S = new f()
                      ;(R.on('error', _),
                        S.on('error', _),
                        S.on('finish', () => {
                          ;((k.themes[v] = S.read().toString()), x())
                        }),
                        R.pipe(S))
                    })
                  }
                  createInputStream() {
                    throw new Error(
                      '`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md',
                    )
                  }
                  async read(R, k) {
                    !R[Symbol.asyncIterator] && R.pipe && (R = R.pipe(new c()))
                    const v = []
                    for await (const x of R) v.push(x)
                    return this.load(o.concat(v), k)
                  }
                  async load(R, k) {
                    let v
                    v = k && k.base64 ? o.from(R.toString(), 'base64') : R
                    const x = {
                        worksheets: [],
                        worksheetHash: {},
                        worksheetRels: [],
                        themes: {},
                        media: [],
                        mediaIndex: {},
                        drawings: {},
                        drawingRels: {},
                        comments: {},
                        tables: {},
                        vmlDrawings: {},
                      },
                      _ = await l.loadAsync(v)
                    for (const S of Object.values(_.files))
                      if (!S.dir) {
                        let A,
                          j = S.name
                        if (
                          (j[0] === '/' && (j = j.substr(1)),
                          j.match(/xl\/media\//) || j.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/))
                        )
                          ((A = new c()), A.write(await S.async('nodebuffer')))
                        else {
                          let L
                          ;((A = new c({ writableObjectMode: !0, readableObjectMode: !0 })),
                            (L = s.browser
                              ? p(await S.async('nodebuffer'))
                              : await S.async('string')))
                          const H = 16384
                          for (let U = 0; U < L.length; U += H) A.write(L.substring(U, U + H))
                        }
                        switch ((A.end(), j)) {
                          case '_rels/.rels':
                            x.globalRels = await this.parseRels(A)
                            break
                          case 'xl/workbook.xml': {
                            const L = await this.parseWorkbook(A)
                            ;((x.sheets = L.sheets),
                              (x.definedNames = L.definedNames),
                              (x.views = L.views),
                              (x.properties = L.properties),
                              (x.calcProperties = L.calcProperties))
                            break
                          }
                          case 'xl/_rels/workbook.xml.rels':
                            x.workbookRels = await this.parseRels(A)
                            break
                          case 'xl/sharedStrings.xml':
                            ;((x.sharedStrings = new y()), await x.sharedStrings.parseStream(A))
                            break
                          case 'xl/styles.xml':
                            ;((x.styles = new g()), await x.styles.parseStream(A))
                            break
                          case 'docProps/app.xml': {
                            const L = new C(),
                              H = await L.parseStream(A)
                            ;((x.company = H.company), (x.manager = H.manager))
                            break
                          }
                          case 'docProps/core.xml': {
                            const L = new m(),
                              H = await L.parseStream(A)
                            Object.assign(x, H)
                            break
                          }
                          default: {
                            let L = j.match(/xl\/worksheets\/sheet(\d+)[.]xml/)
                            if (L) {
                              await this._processWorksheetEntry(A, x, L[1], k, j)
                              break
                            }
                            if (
                              ((L = j.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/)), L)
                            ) {
                              await this._processWorksheetRelsEntry(A, x, L[1])
                              break
                            }
                            if (((L = j.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)), L)) {
                              await this._processThemeEntry(A, x, L[1])
                              break
                            }
                            if (
                              ((L = j.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/)), L)
                            ) {
                              await this._processMediaEntry(A, x, L[1])
                              break
                            }
                            if (((L = j.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/)), L)) {
                              await this._processDrawingEntry(A, x, L[1])
                              break
                            }
                            if (((L = j.match(/xl\/(comments\d+)[.]xml/)), L)) {
                              await this._processCommentEntry(A, x, L[1])
                              break
                            }
                            if (((L = j.match(/xl\/tables\/(table\d+)[.]xml/)), L)) {
                              await this._processTableEntry(A, x, L[1])
                              break
                            }
                            if (
                              ((L = j.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/)), L)
                            ) {
                              await this._processDrawingRelsEntry(A, x, L[1])
                              break
                            }
                            if (((L = j.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/)), L)) {
                              await this._processVmlDrawingEntry(A, x, L[1])
                              break
                            }
                          }
                        }
                      }
                    return (this.reconcile(x, k), (this.workbook.model = x), this.workbook)
                  }
                  async addMedia(R, k) {
                    await Promise.all(
                      k.media.map(async (v) => {
                        if (v.type === 'image') {
                          const x = `xl/media/${v.name}.${v.extension}`
                          if (v.filename) {
                            const _ = await (function (S, A) {
                              return new Promise((j, L) => {
                                a.readFile(S, A, (H, U) => {
                                  H ? L(H) : j(U)
                                })
                              })
                            })(v.filename)
                            return R.append(_, { name: x })
                          }
                          if (v.buffer) return R.append(v.buffer, { name: x })
                          if (v.base64) {
                            const _ = v.base64,
                              S = _.substring(_.indexOf(',') + 1)
                            return R.append(S, { name: x, base64: !0 })
                          }
                        }
                        throw new Error('Unsupported media')
                      }),
                    )
                  }
                  addDrawings(R, k) {
                    const v = new B(),
                      x = new b()
                    k.worksheets.forEach((_) => {
                      const { drawing: S } = _
                      if (S) {
                        v.prepare(S, {})
                        let A = v.toXml(S)
                        ;(R.append(A, { name: `xl/drawings/${S.name}.xml` }),
                          (A = x.toXml(S.rels)),
                          R.append(A, { name: `xl/drawings/_rels/${S.name}.xml.rels` }))
                      }
                    })
                  }
                  addTables(R, k) {
                    const v = new E()
                    k.worksheets.forEach((x) => {
                      const { tables: _ } = x
                      _.forEach((S) => {
                        v.prepare(S, {})
                        const A = v.toXml(S)
                        R.append(A, { name: 'xl/tables/' + S.target })
                      })
                    })
                  }
                  async addContentTypes(R, k) {
                    const v = new w().toXml(k)
                    R.append(v, { name: '[Content_Types].xml' })
                  }
                  async addApp(R, k) {
                    const v = new C().toXml(k)
                    R.append(v, { name: 'docProps/app.xml' })
                  }
                  async addCore(R, k) {
                    const v = new m()
                    R.append(v.toXml(k), { name: 'docProps/core.xml' })
                  }
                  async addThemes(R, k) {
                    const v = k.themes || { theme1: $ }
                    Object.keys(v).forEach((x) => {
                      const _ = v[x],
                        S = `xl/theme/${x}.xml`
                      R.append(_, { name: S })
                    })
                  }
                  async addOfficeRels(R) {
                    const k = new b().toXml([
                      { Id: 'rId1', Type: F.RelType.OfficeDocument, Target: 'xl/workbook.xml' },
                      { Id: 'rId2', Type: F.RelType.CoreProperties, Target: 'docProps/core.xml' },
                      {
                        Id: 'rId3',
                        Type: F.RelType.ExtenderProperties,
                        Target: 'docProps/app.xml',
                      },
                    ])
                    R.append(k, { name: '_rels/.rels' })
                  }
                  async addWorkbookRels(R, k) {
                    let v = 1
                    const x = [
                      { Id: 'rId' + v++, Type: F.RelType.Styles, Target: 'styles.xml' },
                      { Id: 'rId' + v++, Type: F.RelType.Theme, Target: 'theme/theme1.xml' },
                    ]
                    ;(k.sharedStrings.count &&
                      x.push({
                        Id: 'rId' + v++,
                        Type: F.RelType.SharedStrings,
                        Target: 'sharedStrings.xml',
                      }),
                      k.worksheets.forEach((S) => {
                        ;((S.rId = 'rId' + v++),
                          x.push({
                            Id: S.rId,
                            Type: F.RelType.Worksheet,
                            Target: `worksheets/sheet${S.id}.xml`,
                          }))
                      }))
                    const _ = new b().toXml(x)
                    R.append(_, { name: 'xl/_rels/workbook.xml.rels' })
                  }
                  async addSharedStrings(R, k) {
                    k.sharedStrings &&
                      k.sharedStrings.count &&
                      R.append(k.sharedStrings.xml, { name: 'xl/sharedStrings.xml' })
                  }
                  async addStyles(R, k) {
                    const { xml: v } = k.styles
                    v && R.append(v, { name: 'xl/styles.xml' })
                  }
                  async addWorkbook(R, k) {
                    const v = new T()
                    R.append(v.toXml(k), { name: 'xl/workbook.xml' })
                  }
                  async addWorksheets(R, k) {
                    const v = new I(),
                      x = new b(),
                      _ = new O(),
                      S = new P()
                    k.worksheets.forEach((A) => {
                      let j = new h()
                      ;(v.render(j, A),
                        R.append(j.xml, { name: `xl/worksheets/sheet${A.id}.xml` }),
                        A.rels &&
                          A.rels.length &&
                          ((j = new h()),
                          x.render(j, A.rels),
                          R.append(j.xml, { name: `xl/worksheets/_rels/sheet${A.id}.xml.rels` })),
                        A.comments.length > 0 &&
                          ((j = new h()),
                          _.render(j, A),
                          R.append(j.xml, { name: `xl/comments${A.id}.xml` }),
                          (j = new h()),
                          S.render(j, A),
                          R.append(j.xml, { name: `xl/drawings/vmlDrawing${A.id}.vml` })))
                    })
                  }
                  _finalize(R) {
                    return new Promise((k, v) => {
                      ;(R.on('finish', () => {
                        k(this)
                      }),
                        R.on('error', v),
                        R.finalize())
                    })
                  }
                  prepareModel(R, k) {
                    ;((R.creator = R.creator || 'ExcelJS'),
                      (R.lastModifiedBy = R.lastModifiedBy || 'ExcelJS'),
                      (R.created = R.created || new Date()),
                      (R.modified = R.modified || new Date()),
                      (R.useSharedStrings = k.useSharedStrings === void 0 || k.useSharedStrings),
                      (R.useStyles = k.useStyles === void 0 || k.useStyles),
                      (R.sharedStrings = new y()),
                      (R.styles = R.useStyles ? new g(!0) : new g.Mock()))
                    const v = new T(),
                      x = new I()
                    v.prepare(R)
                    const _ = {
                      sharedStrings: R.sharedStrings,
                      styles: R.styles,
                      date1904: R.properties.date1904,
                      drawingsCount: 0,
                      media: R.media,
                    }
                    ;((_.drawings = R.drawings = []), (_.commentRefs = R.commentRefs = []))
                    let S = 0
                    ;((R.tables = []),
                      R.worksheets.forEach((A) => {
                        ;(A.tables.forEach((j) => {
                          ;(S++, (j.target = `table${S}.xml`), (j.id = S), R.tables.push(j))
                        }),
                          x.prepare(A, _))
                      }))
                  }
                  async write(R, k) {
                    k = k || {}
                    const { model: v } = this.workbook,
                      x = new u.ZipWriter(k.zip)
                    return (
                      x.pipe(R),
                      this.prepareModel(v, k),
                      await this.addContentTypes(x, v),
                      await this.addOfficeRels(x, v),
                      await this.addWorkbookRels(x, v),
                      await this.addWorksheets(x, v),
                      await this.addSharedStrings(x, v),
                      await this.addDrawings(x, v),
                      await this.addTables(x, v),
                      await Promise.all([this.addThemes(x, v), this.addStyles(x, v)]),
                      await this.addMedia(x, v),
                      await Promise.all([this.addApp(x, v), this.addCore(x, v)]),
                      await this.addWorkbook(x, v),
                      this._finalize(x)
                    )
                  }
                  writeFile(R, k) {
                    const v = a.createWriteStream(R)
                    return new Promise((x, _) => {
                      ;(v.on('finish', () => {
                        x()
                      }),
                        v.on('error', (S) => {
                          _(S)
                        }),
                        this.write(v, k)
                          .then(() => {
                            v.end()
                          })
                          .catch((S) => {
                            _(S)
                          }))
                    })
                  }
                  async writeBuffer(R) {
                    const k = new f()
                    return (await this.write(k, R), k.read())
                  }
                }
                ;((F.RelType = t('./rel-type')), (r.exports = F))
              }).call(this)
            }).call(this, t('_process'), t('buffer').Buffer)
          },
          {
            '../utils/browser-buffer-decode': 16,
            '../utils/stream-buf': 24,
            '../utils/utils': 27,
            '../utils/xml-stream': 28,
            '../utils/zip-stream': 29,
            './rel-type': 31,
            './xform/book/workbook-xform': 38,
            './xform/comment/comments-xform': 40,
            './xform/comment/vml-notes-xform': 45,
            './xform/core/app-xform': 51,
            './xform/core/content-types-xform': 52,
            './xform/core/core-xform': 53,
            './xform/core/relationships-xform': 55,
            './xform/drawing/drawing-xform': 62,
            './xform/sheet/worksheet-xform': 115,
            './xform/strings/shared-strings-xform': 124,
            './xform/style/styles-xform': 135,
            './xform/table/table-xform': 143,
            './xml/theme1': 145,
            _process: 467,
            buffer: 220,
            fs: 216,
            jszip: 441,
            'readable-stream': 491,
          },
        ],
        145: [
          function (t, r, i) {
            r.exports = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>`
          },
          {},
        ],
        146: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                ;(Object.defineProperty(i, '__esModule', { value: !0 }),
                  (i.CsvFormatterStream = void 0))
                const o = t('stream'),
                  a = t('./formatter')
                class l extends o.Transform {
                  constructor(u) {
                    ;(super({ writableObjectMode: u.objectMode }),
                      (this.hasWrittenBOM = !1),
                      (this.formatterOptions = u),
                      (this.rowFormatter = new a.RowFormatter(u)),
                      (this.hasWrittenBOM = !u.writeBOM))
                  }
                  transform(u) {
                    return ((this.rowFormatter.rowTransform = u), this)
                  }
                  _transform(u, f, d) {
                    let h = !1
                    try {
                      ;(this.hasWrittenBOM ||
                        (this.push(this.formatterOptions.BOM), (this.hasWrittenBOM = !0)),
                        this.rowFormatter.format(u, (p, g) =>
                          p
                            ? ((h = !0), d(p))
                            : (g &&
                                g.forEach((m) => {
                                  this.push(s.from(m, 'utf8'))
                                }),
                              (h = !0),
                              d()),
                        ))
                    } catch (p) {
                      if (h) throw p
                      d(p)
                    }
                  }
                  _flush(u) {
                    this.rowFormatter.finish((f, d) =>
                      f
                        ? u(f)
                        : (d &&
                            d.forEach((h) => {
                              this.push(s.from(h, 'utf8'))
                            }),
                          u()),
                    )
                  }
                }
                i.CsvFormatterStream = l
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { './formatter': 150, buffer: 220, stream: 505 },
        ],
        147: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.FormatterOptions = void 0),
              (i.FormatterOptions = class {
                constructor() {
                  let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
                  var o
                  ;((this.objectMode = !0),
                    (this.delimiter = ','),
                    (this.rowDelimiter = `
`),
                    (this.quote = '"'),
                    (this.escape = this.quote),
                    (this.quoteColumns = !1),
                    (this.quoteHeaders = this.quoteColumns),
                    (this.headers = null),
                    (this.includeEndRowDelimiter = !1),
                    (this.writeBOM = !1),
                    (this.BOM = '\uFEFF'),
                    (this.alwaysWriteHeaders = !1),
                    Object.assign(this, s || {}),
                    s?.quoteHeaders === void 0 && (this.quoteHeaders = this.quoteColumns),
                    s?.quote === !0 ? (this.quote = '"') : s?.quote === !1 && (this.quote = ''),
                    typeof s?.escape != 'string' && (this.escape = this.quote),
                    (this.shouldWriteHeaders =
                      !!this.headers && ((o = s.writeHeaders) === null || o === void 0 || o)),
                    (this.headers = Array.isArray(this.headers) ? this.headers : null),
                    (this.escapedQuote = `${this.escape}${this.quote}`))
                }
              }))
          },
          {},
        ],
        148: [
          function (t, r, i) {
            var s = function (c) {
              return c && c.__esModule ? c : { default: c }
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.FieldFormatter = void 0))
            const o = s(t('lodash.isboolean')),
              a = s(t('lodash.isnil')),
              l = s(t('lodash.escaperegexp'))
            i.FieldFormatter = class {
              constructor(c) {
                ;((this._headers = null),
                  (this.formatterOptions = c),
                  c.headers !== null && (this.headers = c.headers),
                  (this.REPLACE_REGEXP = new RegExp(c.quote, 'g')))
                const u = `[${c.delimiter}${l.default(c.rowDelimiter)}|\r|
]`
                this.ESCAPE_REGEXP = new RegExp(u)
              }
              set headers(c) {
                this._headers = c
              }
              shouldQuote(c, u) {
                const f = u
                  ? this.formatterOptions.quoteHeaders
                  : this.formatterOptions.quoteColumns
                return o.default(f)
                  ? f
                  : Array.isArray(f)
                    ? f[c]
                    : this._headers !== null && f[this._headers[c]]
              }
              format(c, u, f) {
                const d = ('' + (a.default(c) ? '' : c)).replace(/\0/g, ''),
                  { formatterOptions: h } = this
                return h.quote !== '' && d.indexOf(h.quote) !== -1
                  ? this.quoteField(d.replace(this.REPLACE_REGEXP, h.escapedQuote))
                  : d.search(this.ESCAPE_REGEXP) !== -1 || this.shouldQuote(u, f)
                    ? this.quoteField(d)
                    : d
              }
              quoteField(c) {
                const { quote: u } = this.formatterOptions
                return `${u}${c}${u}`
              }
            }
          },
          { 'lodash.escaperegexp': 442, 'lodash.isboolean': 444, 'lodash.isnil': 447 },
        ],
        149: [
          function (t, r, i) {
            var s = function (f) {
              return f && f.__esModule ? f : { default: f }
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.RowFormatter = void 0))
            const o = s(t('lodash.isfunction')),
              a = s(t('lodash.isequal')),
              l = t('./FieldFormatter'),
              c = t('../types')
            class u {
              constructor(d) {
                ;((this.rowCount = 0),
                  (this.formatterOptions = d),
                  (this.fieldFormatter = new l.FieldFormatter(d)),
                  (this.headers = d.headers),
                  (this.shouldWriteHeaders = d.shouldWriteHeaders),
                  (this.hasWrittenHeaders = !1),
                  this.headers !== null && (this.fieldFormatter.headers = this.headers),
                  d.transform && (this.rowTransform = d.transform))
              }
              static isRowHashArray(d) {
                return !!Array.isArray(d) && Array.isArray(d[0]) && d[0].length === 2
              }
              static isRowArray(d) {
                return Array.isArray(d) && !this.isRowHashArray(d)
              }
              static gatherHeaders(d) {
                return u.isRowHashArray(d)
                  ? d.map((h) => h[0])
                  : Array.isArray(d)
                    ? d
                    : Object.keys(d)
              }
              static createTransform(d) {
                return c.isSyncTransform(d)
                  ? (h, p) => {
                      let g = null
                      try {
                        g = d(h)
                      } catch (m) {
                        return p(m)
                      }
                      return p(null, g)
                    }
                  : (h, p) => {
                      d(h, p)
                    }
              }
              set rowTransform(d) {
                if (!o.default(d)) throw new TypeError('The transform should be a function')
                this._rowTransform = u.createTransform(d)
              }
              format(d, h) {
                this.callTransformer(d, (p, g) => {
                  if (p) return h(p)
                  if (!d) return h(null)
                  const m = []
                  if (g) {
                    const { shouldFormatColumns: y, headers: b } = this.checkHeaders(g)
                    if (
                      (this.shouldWriteHeaders &&
                        b &&
                        !this.hasWrittenHeaders &&
                        (m.push(this.formatColumns(b, !0)), (this.hasWrittenHeaders = !0)),
                      y)
                    ) {
                      const w = this.gatherColumns(g)
                      m.push(this.formatColumns(w, !1))
                    }
                  }
                  return h(null, m)
                })
              }
              finish(d) {
                const h = []
                if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
                  if (!this.headers)
                    return d(
                      new Error(
                        '`alwaysWriteHeaders` option is set to true but `headers` option not provided.',
                      ),
                    )
                  h.push(this.formatColumns(this.headers, !0))
                }
                return (
                  this.formatterOptions.includeEndRowDelimiter &&
                    h.push(this.formatterOptions.rowDelimiter),
                  d(null, h)
                )
              }
              checkHeaders(d) {
                if (this.headers) return { shouldFormatColumns: !0, headers: this.headers }
                const h = u.gatherHeaders(d)
                return (
                  (this.headers = h),
                  (this.fieldFormatter.headers = h),
                  this.shouldWriteHeaders
                    ? { shouldFormatColumns: !a.default(h, d), headers: h }
                    : { shouldFormatColumns: !0, headers: null }
                )
              }
              gatherColumns(d) {
                if (this.headers === null) throw new Error('Headers is currently null')
                return Array.isArray(d)
                  ? u.isRowHashArray(d)
                    ? this.headers.map((h, p) => {
                        const g = d[p]
                        return g ? g[1] : ''
                      })
                    : u.isRowArray(d) && !this.shouldWriteHeaders
                      ? d
                      : this.headers.map((h, p) => d[p])
                  : this.headers.map((h) => d[h])
              }
              callTransformer(d, h) {
                return this._rowTransform ? this._rowTransform(d, h) : h(null, d)
              }
              formatColumns(d, h) {
                const p = d
                    .map((m, y) => this.fieldFormatter.format(m, y, h))
                    .join(this.formatterOptions.delimiter),
                  { rowCount: g } = this
                return (
                  (this.rowCount += 1),
                  g ? [this.formatterOptions.rowDelimiter, p].join('') : p
                )
              }
            }
            i.RowFormatter = u
          },
          {
            '../types': 152,
            './FieldFormatter': 148,
            'lodash.isequal': 445,
            'lodash.isfunction': 446,
          },
        ],
        150: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.FieldFormatter = i.RowFormatter = void 0))
            var s = t('./RowFormatter')
            Object.defineProperty(i, 'RowFormatter', {
              enumerable: !0,
              get: function () {
                return s.RowFormatter
              },
            })
            var o = t('./FieldFormatter')
            Object.defineProperty(i, 'FieldFormatter', {
              enumerable: !0,
              get: function () {
                return o.FieldFormatter
              },
            })
          },
          { './FieldFormatter': 148, './RowFormatter': 149 },
        ],
        151: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = Object.create
                    ? function (y, b, w, C) {
                        ;(C === void 0 && (C = w),
                          Object.defineProperty(y, C, {
                            enumerable: !0,
                            get: function () {
                              return b[w]
                            },
                          }))
                      }
                    : function (y, b, w, C) {
                        ;(C === void 0 && (C = w), (y[C] = b[w]))
                      },
                  a = Object.create
                    ? function (y, b) {
                        Object.defineProperty(y, 'default', { enumerable: !0, value: b })
                      }
                    : function (y, b) {
                        y.default = b
                      },
                  l = function (y) {
                    if (y && y.__esModule) return y
                    var b = {}
                    if (y != null)
                      for (var w in y)
                        w !== 'default' && Object.prototype.hasOwnProperty.call(y, w) && o(b, y, w)
                    return (a(b, y), b)
                  },
                  c = function (y, b) {
                    for (var w in y)
                      w === 'default' || Object.prototype.hasOwnProperty.call(b, w) || o(b, y, w)
                  }
                ;(Object.defineProperty(i, '__esModule', { value: !0 }),
                  (i.writeToPath =
                    i.writeToString =
                    i.writeToBuffer =
                    i.writeToStream =
                    i.write =
                    i.format =
                    i.FormatterOptions =
                    i.CsvFormatterStream =
                      void 0))
                const u = t('util'),
                  f = t('stream'),
                  d = l(t('fs')),
                  h = t('./FormatterOptions'),
                  p = t('./CsvFormatterStream')
                c(t('./types'), i)
                var g = t('./CsvFormatterStream')
                Object.defineProperty(i, 'CsvFormatterStream', {
                  enumerable: !0,
                  get: function () {
                    return g.CsvFormatterStream
                  },
                })
                var m = t('./FormatterOptions')
                ;(Object.defineProperty(i, 'FormatterOptions', {
                  enumerable: !0,
                  get: function () {
                    return m.FormatterOptions
                  },
                }),
                  (i.format = (y) => new p.CsvFormatterStream(new h.FormatterOptions(y))),
                  (i.write = (y, b) => {
                    const w = i.format(b),
                      C = u.promisify((T, I) => {
                        w.write(T, void 0, I)
                      })
                    return (
                      y
                        .reduce((T, I) => T.then(() => C(I)), Promise.resolve())
                        .then(() => w.end())
                        .catch((T) => {
                          w.emit('error', T)
                        }),
                      w
                    )
                  }),
                  (i.writeToStream = (y, b, w) => i.write(b, w).pipe(y)),
                  (i.writeToBuffer = function (y) {
                    let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                    const w = [],
                      C = new f.Writable({
                        write(T, I, B) {
                          ;(w.push(T), B())
                        },
                      })
                    return new Promise((T, I) => {
                      ;(C.on('error', I).on('finish', () => T(s.concat(w))), i.write(y, b).pipe(C))
                    })
                  }),
                  (i.writeToString = (y, b) => i.writeToBuffer(y, b).then((w) => w.toString())),
                  (i.writeToPath = (y, b, w) => {
                    const C = d.createWriteStream(y, { encoding: 'utf8' })
                    return i.write(b, w).pipe(C)
                  }))
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          {
            './CsvFormatterStream': 146,
            './FormatterOptions': 147,
            './types': 152,
            buffer: 220,
            fs: 216,
            stream: 505,
            util: 527,
          },
        ],
        152: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.isSyncTransform = void 0),
              (i.isSyncTransform = (s) => s.length === 1))
          },
          {},
        ],
        153: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                ;(Object.defineProperty(i, '__esModule', { value: !0 }),
                  (i.CsvParserStream = void 0))
                const o = t('string_decoder'),
                  a = t('stream'),
                  l = t('./transforms'),
                  c = t('./parser')
                class u extends a.Transform {
                  constructor(d) {
                    ;(super({ objectMode: d.objectMode }),
                      (this.lines = ''),
                      (this.rowCount = 0),
                      (this.parsedRowCount = 0),
                      (this.parsedLineCount = 0),
                      (this.endEmitted = !1),
                      (this.headersEmitted = !1),
                      (this.parserOptions = d),
                      (this.parser = new c.Parser(d)),
                      (this.headerTransformer = new l.HeaderTransformer(d)),
                      (this.decoder = new o.StringDecoder(d.encoding)),
                      (this.rowTransformerValidator = new l.RowTransformerValidator()))
                  }
                  get hasHitRowLimit() {
                    return (
                      this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows
                    )
                  }
                  get shouldEmitRows() {
                    return this.parsedRowCount > this.parserOptions.skipRows
                  }
                  get shouldSkipLine() {
                    return this.parsedLineCount <= this.parserOptions.skipLines
                  }
                  transform(d) {
                    return ((this.rowTransformerValidator.rowTransform = d), this)
                  }
                  validate(d) {
                    return ((this.rowTransformerValidator.rowValidator = d), this)
                  }
                  emit(d) {
                    if (d === 'end')
                      return (
                        this.endEmitted ||
                          ((this.endEmitted = !0), super.emit('end', this.rowCount)),
                        !1
                      )
                    for (
                      var h = arguments.length, p = new Array(h > 1 ? h - 1 : 0), g = 1;
                      g < h;
                      g++
                    )
                      p[g - 1] = arguments[g]
                    return super.emit(d, ...p)
                  }
                  _transform(d, h, p) {
                    if (this.hasHitRowLimit) return p()
                    const g = u.wrapDoneCallback(p)
                    try {
                      const { lines: m } = this,
                        y = m + this.decoder.write(d),
                        b = this.parse(y, !0)
                      return this.processRows(b, g)
                    } catch (m) {
                      return g(m)
                    }
                  }
                  _flush(d) {
                    const h = u.wrapDoneCallback(d)
                    if (this.hasHitRowLimit) return h()
                    try {
                      const p = this.lines + this.decoder.end(),
                        g = this.parse(p, !1)
                      return this.processRows(g, h)
                    } catch (p) {
                      return h(p)
                    }
                  }
                  parse(d, h) {
                    if (!d) return []
                    const { line: p, rows: g } = this.parser.parse(d, h)
                    return ((this.lines = p), g)
                  }
                  processRows(d, h) {
                    const p = d.length,
                      g = (m) => {
                        const y = (C) =>
                          C ? h(C) : m % 100 != 0 ? g(m + 1) : void s(() => g(m + 1))
                        if ((this.checkAndEmitHeaders(), m >= p || this.hasHitRowLimit)) return h()
                        if (((this.parsedLineCount += 1), this.shouldSkipLine)) return y()
                        const b = d[m]
                        ;((this.rowCount += 1), (this.parsedRowCount += 1))
                        const w = this.rowCount
                        return this.transformRow(b, (C, T) => {
                          if (C) return ((this.rowCount -= 1), y(C))
                          if (!T) return y(new Error('expected transform result'))
                          if (T.isValid) {
                            if (T.row) return this.pushRow(T.row, y)
                          } else this.emit('data-invalid', T.row, w, T.reason)
                          return y()
                        })
                      }
                    g(0)
                  }
                  transformRow(d, h) {
                    try {
                      this.headerTransformer.transform(d, (p, g) =>
                        p
                          ? h(p)
                          : g
                            ? g.isValid
                              ? g.row
                                ? this.shouldEmitRows
                                  ? this.rowTransformerValidator.transformAndValidate(g.row, h)
                                  : this.skipRow(h)
                                : ((this.rowCount -= 1),
                                  (this.parsedRowCount -= 1),
                                  h(null, { row: null, isValid: !0 }))
                              : this.shouldEmitRows
                                ? h(null, { isValid: !1, row: d })
                                : this.skipRow(h)
                            : h(new Error('Expected result from header transform')),
                      )
                    } catch (p) {
                      h(p)
                    }
                  }
                  checkAndEmitHeaders() {
                    !this.headersEmitted &&
                      this.headerTransformer.headers &&
                      ((this.headersEmitted = !0),
                      this.emit('headers', this.headerTransformer.headers))
                  }
                  skipRow(d) {
                    return ((this.rowCount -= 1), d(null, { row: null, isValid: !0 }))
                  }
                  pushRow(d, h) {
                    try {
                      ;(this.parserOptions.objectMode ? this.push(d) : this.push(JSON.stringify(d)),
                        h())
                    } catch (p) {
                      h(p)
                    }
                  }
                  static wrapDoneCallback(d) {
                    let h = !1
                    return function (p) {
                      if (p) {
                        if (h) throw p
                        return ((h = !0), void d(p))
                      }
                      for (
                        var g = arguments.length, m = new Array(g > 1 ? g - 1 : 0), y = 1;
                        y < g;
                        y++
                      )
                        m[y - 1] = arguments[y]
                      d(...m)
                    }
                  }
                }
                i.CsvParserStream = u
              }).call(this)
            }).call(this, t('timers').setImmediate)
          },
          { './parser': 165, './transforms': 168, stream: 505, string_decoder: 218, timers: 523 },
        ],
        154: [
          function (t, r, i) {
            var s = function (l) {
              return l && l.__esModule ? l : { default: l }
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.ParserOptions = void 0))
            const o = s(t('lodash.escaperegexp')),
              a = s(t('lodash.isnil'))
            i.ParserOptions = class {
              constructor(l) {
                var c
                if (
                  ((this.objectMode = !0),
                  (this.delimiter = ','),
                  (this.ignoreEmpty = !1),
                  (this.quote = '"'),
                  (this.escape = null),
                  (this.escapeChar = this.quote),
                  (this.comment = null),
                  (this.supportsComments = !1),
                  (this.ltrim = !1),
                  (this.rtrim = !1),
                  (this.trim = !1),
                  (this.headers = null),
                  (this.renameHeaders = !1),
                  (this.strictColumnHandling = !1),
                  (this.discardUnmappedColumns = !1),
                  (this.carriageReturn = '\r'),
                  (this.encoding = 'utf8'),
                  (this.limitRows = !1),
                  (this.maxRows = 0),
                  (this.skipLines = 0),
                  (this.skipRows = 0),
                  Object.assign(this, l || {}),
                  this.delimiter.length > 1)
                )
                  throw new Error('delimiter option must be one character long')
                ;((this.escapedDelimiter = o.default(this.delimiter)),
                  (this.escapeChar = (c = this.escape) !== null && c !== void 0 ? c : this.quote),
                  (this.supportsComments = !a.default(this.comment)),
                  (this.NEXT_TOKEN_REGEXP = new RegExp(
                    `([^\\s]|\\r\\n|\\n|\\r|${this.escapedDelimiter})`,
                  )),
                  this.maxRows > 0 && (this.limitRows = !0))
              }
            }
          },
          { 'lodash.escaperegexp': 442, 'lodash.isnil': 447 },
        ],
        155: [
          function (t, r, i) {
            var s = Object.create
                ? function (g, m, y, b) {
                    ;(b === void 0 && (b = y),
                      Object.defineProperty(g, b, {
                        enumerable: !0,
                        get: function () {
                          return m[y]
                        },
                      }))
                  }
                : function (g, m, y, b) {
                    ;(b === void 0 && (b = y), (g[b] = m[y]))
                  },
              o = Object.create
                ? function (g, m) {
                    Object.defineProperty(g, 'default', { enumerable: !0, value: m })
                  }
                : function (g, m) {
                    g.default = m
                  },
              a = function (g) {
                if (g && g.__esModule) return g
                var m = {}
                if (g != null)
                  for (var y in g)
                    y !== 'default' && Object.prototype.hasOwnProperty.call(g, y) && s(m, g, y)
                return (o(m, g), m)
              },
              l = function (g, m) {
                for (var y in g)
                  y === 'default' || Object.prototype.hasOwnProperty.call(m, y) || s(m, g, y)
              }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.parseString =
                i.parseFile =
                i.parseStream =
                i.parse =
                i.ParserOptions =
                i.CsvParserStream =
                  void 0))
            const c = a(t('fs')),
              u = t('stream'),
              f = t('./ParserOptions'),
              d = t('./CsvParserStream')
            l(t('./types'), i)
            var h = t('./CsvParserStream')
            Object.defineProperty(i, 'CsvParserStream', {
              enumerable: !0,
              get: function () {
                return h.CsvParserStream
              },
            })
            var p = t('./ParserOptions')
            ;(Object.defineProperty(i, 'ParserOptions', {
              enumerable: !0,
              get: function () {
                return p.ParserOptions
              },
            }),
              (i.parse = (g) => new d.CsvParserStream(new f.ParserOptions(g))),
              (i.parseStream = (g, m) => g.pipe(new d.CsvParserStream(new f.ParserOptions(m)))),
              (i.parseFile = function (g) {
                let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                return c.createReadStream(g).pipe(new d.CsvParserStream(new f.ParserOptions(m)))
              }),
              (i.parseString = (g, m) => {
                const y = new u.Readable()
                return (
                  y.push(g),
                  y.push(null),
                  y.pipe(new d.CsvParserStream(new f.ParserOptions(m)))
                )
              }))
          },
          {
            './CsvParserStream': 153,
            './ParserOptions': 154,
            './types': 169,
            fs: 216,
            stream: 505,
          },
        ],
        156: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.Parser = void 0))
            const s = t('./Scanner'),
              o = t('./RowParser'),
              a = t('./Token')
            class l {
              constructor(u) {
                ;((this.parserOptions = u), (this.rowParser = new o.RowParser(this.parserOptions)))
              }
              static removeBOM(u) {
                return u && u.charCodeAt(0) === 65279 ? u.slice(1) : u
              }
              parse(u, f) {
                const d = new s.Scanner({
                  line: l.removeBOM(u),
                  parserOptions: this.parserOptions,
                  hasMoreData: f,
                })
                return this.parserOptions.supportsComments
                  ? this.parseWithComments(d)
                  : this.parseWithoutComments(d)
              }
              parseWithoutComments(u) {
                const f = []
                let d = !0
                for (; d; ) d = this.parseRow(u, f)
                return { line: u.line, rows: f }
              }
              parseWithComments(u) {
                const { parserOptions: f } = this,
                  d = []
                for (let h = u.nextCharacterToken; h !== null; h = u.nextCharacterToken)
                  if (a.Token.isTokenComment(h, f)) {
                    if (u.advancePastLine() === null) return { line: u.lineFromCursor, rows: d }
                    if (!u.hasMoreCharacters) return { line: u.lineFromCursor, rows: d }
                    u.truncateToCursor()
                  } else if (!this.parseRow(u, d)) break
                return { line: u.line, rows: d }
              }
              parseRow(u, f) {
                if (!u.nextNonSpaceToken) return !1
                const d = this.rowParser.parse(u)
                return (
                  d !== null &&
                  ((this.parserOptions.ignoreEmpty && o.RowParser.isEmptyRow(d)) || f.push(d), !0)
                )
              }
            }
            i.Parser = l
          },
          { './RowParser': 157, './Scanner': 158, './Token': 159 },
        ],
        157: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.RowParser = void 0))
            const s = t('./column'),
              o = t('./Token')
            i.RowParser = class {
              constructor(a) {
                ;((this.parserOptions = a), (this.columnParser = new s.ColumnParser(a)))
              }
              static isEmptyRow(a) {
                return a.join('').replace(/\s+/g, '') === ''
              }
              parse(a) {
                const { parserOptions: l } = this,
                  { hasMoreData: c } = a,
                  u = a,
                  f = []
                let d = this.getStartToken(u, f)
                for (; d; ) {
                  if (o.Token.isTokenRowDelimiter(d))
                    return (
                      u.advancePastToken(d),
                      !u.hasMoreCharacters && o.Token.isTokenCarriageReturn(d, l) && c
                        ? null
                        : (u.truncateToCursor(), f)
                    )
                  if (!this.shouldSkipColumnParse(u, d, f)) {
                    const h = this.columnParser.parse(u)
                    if (h === null) return null
                    f.push(h)
                  }
                  d = u.nextNonSpaceToken
                }
                return c ? null : (u.truncateToCursor(), f)
              }
              getStartToken(a, l) {
                const c = a.nextNonSpaceToken
                return c !== null && o.Token.isTokenDelimiter(c, this.parserOptions)
                  ? (l.push(''), a.nextNonSpaceToken)
                  : c
              }
              shouldSkipColumnParse(a, l, c) {
                const { parserOptions: u } = this
                if (o.Token.isTokenDelimiter(l, u)) {
                  a.advancePastToken(l)
                  const f = a.nextCharacterToken
                  if (
                    !a.hasMoreCharacters ||
                    (f !== null && o.Token.isTokenRowDelimiter(f)) ||
                    (f !== null && o.Token.isTokenDelimiter(f, u))
                  )
                    return (c.push(''), !0)
                }
                return !1
              }
            }
          },
          { './Token': 159, './column': 164 },
        ],
        158: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.Scanner = void 0))
            const s = t('./Token'),
              o = /((?:\r\n)|\n|\r)/
            i.Scanner = class {
              constructor(a) {
                ;((this.cursor = 0),
                  (this.line = a.line),
                  (this.lineLength = this.line.length),
                  (this.parserOptions = a.parserOptions),
                  (this.hasMoreData = a.hasMoreData),
                  (this.cursor = a.cursor || 0))
              }
              get hasMoreCharacters() {
                return this.lineLength > this.cursor
              }
              get nextNonSpaceToken() {
                const { lineFromCursor: a } = this,
                  l = this.parserOptions.NEXT_TOKEN_REGEXP
                if (a.search(l) === -1) return null
                const c = l.exec(a)
                if (c == null) return null
                const u = c[1],
                  f = this.cursor + (c.index || 0)
                return new s.Token({ token: u, startCursor: f, endCursor: f + u.length - 1 })
              }
              get nextCharacterToken() {
                const { cursor: a, lineLength: l } = this
                return l <= a
                  ? null
                  : new s.Token({ token: this.line[a], startCursor: a, endCursor: a })
              }
              get lineFromCursor() {
                return this.line.substr(this.cursor)
              }
              advancePastLine() {
                const a = o.exec(this.lineFromCursor)
                return a
                  ? ((this.cursor += (a.index || 0) + a[0].length), this)
                  : this.hasMoreData
                    ? null
                    : ((this.cursor = this.lineLength), this)
              }
              advanceTo(a) {
                return ((this.cursor = a), this)
              }
              advanceToToken(a) {
                return ((this.cursor = a.startCursor), this)
              }
              advancePastToken(a) {
                return ((this.cursor = a.endCursor + 1), this)
              }
              truncateToCursor() {
                return (
                  (this.line = this.lineFromCursor),
                  (this.lineLength = this.line.length),
                  (this.cursor = 0),
                  this
                )
              }
            }
          },
          { './Token': 159 },
        ],
        159: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.Token = void 0),
              (i.Token = class {
                constructor(s) {
                  ;((this.token = s.token),
                    (this.startCursor = s.startCursor),
                    (this.endCursor = s.endCursor))
                }
                static isTokenRowDelimiter(s) {
                  const o = s.token
                  return (
                    o === '\r' ||
                    o ===
                      `
` ||
                    o ===
                      `\r
`
                  )
                }
                static isTokenCarriageReturn(s, o) {
                  return s.token === o.carriageReturn
                }
                static isTokenComment(s, o) {
                  return o.supportsComments && !!s && s.token === o.comment
                }
                static isTokenEscapeCharacter(s, o) {
                  return s.token === o.escapeChar
                }
                static isTokenQuote(s, o) {
                  return s.token === o.quote
                }
                static isTokenDelimiter(s, o) {
                  return s.token === o.delimiter
                }
              }))
          },
          {},
        ],
        160: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.ColumnFormatter = void 0),
              (i.ColumnFormatter = class {
                constructor(s) {
                  s.trim
                    ? (this.format = (o) => o.trim())
                    : s.ltrim
                      ? (this.format = (o) => o.trimLeft())
                      : s.rtrim
                        ? (this.format = (o) => o.trimRight())
                        : (this.format = (o) => o)
                }
              }))
          },
          {},
        ],
        161: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.ColumnParser = void 0))
            const s = t('./NonQuotedColumnParser'),
              o = t('./QuotedColumnParser'),
              a = t('../Token')
            i.ColumnParser = class {
              constructor(l) {
                ;((this.parserOptions = l),
                  (this.quotedColumnParser = new o.QuotedColumnParser(l)),
                  (this.nonQuotedColumnParser = new s.NonQuotedColumnParser(l)))
              }
              parse(l) {
                const { nextNonSpaceToken: c } = l
                return c !== null && a.Token.isTokenQuote(c, this.parserOptions)
                  ? (l.advanceToToken(c), this.quotedColumnParser.parse(l))
                  : this.nonQuotedColumnParser.parse(l)
              }
            }
          },
          { '../Token': 159, './NonQuotedColumnParser': 162, './QuotedColumnParser': 163 },
        ],
        162: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.NonQuotedColumnParser = void 0))
            const s = t('./ColumnFormatter'),
              o = t('../Token')
            i.NonQuotedColumnParser = class {
              constructor(a) {
                ;((this.parserOptions = a), (this.columnFormatter = new s.ColumnFormatter(a)))
              }
              parse(a) {
                if (!a.hasMoreCharacters) return null
                const { parserOptions: l } = this,
                  c = []
                let u = a.nextCharacterToken
                for (
                  ;
                  u && !o.Token.isTokenDelimiter(u, l) && !o.Token.isTokenRowDelimiter(u);
                  u = a.nextCharacterToken
                )
                  (c.push(u.token), a.advancePastToken(u))
                return this.columnFormatter.format(c.join(''))
              }
            }
          },
          { '../Token': 159, './ColumnFormatter': 160 },
        ],
        163: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.QuotedColumnParser = void 0))
            const s = t('./ColumnFormatter'),
              o = t('../Token')
            i.QuotedColumnParser = class {
              constructor(a) {
                ;((this.parserOptions = a), (this.columnFormatter = new s.ColumnFormatter(a)))
              }
              parse(a) {
                if (!a.hasMoreCharacters) return null
                const l = a.cursor,
                  { foundClosingQuote: c, col: u } = this.gatherDataBetweenQuotes(a)
                if (!c) {
                  if ((a.advanceTo(l), !a.hasMoreData))
                    throw new Error(
                      `Parse Error: missing closing: '${this.parserOptions.quote || ''}' in line: at '${a.lineFromCursor.replace(/[\r\n]/g, "\\n'")}'`,
                    )
                  return null
                }
                return (this.checkForMalformedColumn(a), u)
              }
              gatherDataBetweenQuotes(a) {
                const { parserOptions: l } = this
                let c = !1,
                  u = !1
                const f = []
                let d = a.nextCharacterToken
                for (; !u && d !== null; d = a.nextCharacterToken) {
                  const h = o.Token.isTokenQuote(d, l)
                  if (!c && h) c = !0
                  else if (c)
                    if (o.Token.isTokenEscapeCharacter(d, l)) {
                      a.advancePastToken(d)
                      const p = a.nextCharacterToken
                      p !== null &&
                      (o.Token.isTokenQuote(p, l) || o.Token.isTokenEscapeCharacter(p, l))
                        ? (f.push(p.token), (d = p))
                        : h
                          ? (u = !0)
                          : f.push(d.token)
                    } else h ? (u = !0) : f.push(d.token)
                  a.advancePastToken(d)
                }
                return { col: this.columnFormatter.format(f.join('')), foundClosingQuote: u }
              }
              checkForMalformedColumn(a) {
                const { parserOptions: l } = this,
                  { nextNonSpaceToken: c } = a
                if (c) {
                  const u = o.Token.isTokenDelimiter(c, l),
                    f = o.Token.isTokenRowDelimiter(c)
                  if (!u && !f) {
                    const d = a.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'")
                    throw new Error(
                      `Parse Error: expected: '${l.escapedDelimiter}' OR new line got: '${c.token}'. at '${d}`,
                    )
                  }
                  a.advanceToToken(c)
                } else a.hasMoreData || a.advancePastLine()
              }
            }
          },
          { '../Token': 159, './ColumnFormatter': 160 },
        ],
        164: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.ColumnFormatter =
                i.QuotedColumnParser =
                i.NonQuotedColumnParser =
                i.ColumnParser =
                  void 0))
            var s = t('./ColumnParser')
            Object.defineProperty(i, 'ColumnParser', {
              enumerable: !0,
              get: function () {
                return s.ColumnParser
              },
            })
            var o = t('./NonQuotedColumnParser')
            Object.defineProperty(i, 'NonQuotedColumnParser', {
              enumerable: !0,
              get: function () {
                return o.NonQuotedColumnParser
              },
            })
            var a = t('./QuotedColumnParser')
            Object.defineProperty(i, 'QuotedColumnParser', {
              enumerable: !0,
              get: function () {
                return a.QuotedColumnParser
              },
            })
            var l = t('./ColumnFormatter')
            Object.defineProperty(i, 'ColumnFormatter', {
              enumerable: !0,
              get: function () {
                return l.ColumnFormatter
              },
            })
          },
          {
            './ColumnFormatter': 160,
            './ColumnParser': 161,
            './NonQuotedColumnParser': 162,
            './QuotedColumnParser': 163,
          },
        ],
        165: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.QuotedColumnParser =
                i.NonQuotedColumnParser =
                i.ColumnParser =
                i.Token =
                i.Scanner =
                i.RowParser =
                i.Parser =
                  void 0))
            var s = t('./Parser')
            Object.defineProperty(i, 'Parser', {
              enumerable: !0,
              get: function () {
                return s.Parser
              },
            })
            var o = t('./RowParser')
            Object.defineProperty(i, 'RowParser', {
              enumerable: !0,
              get: function () {
                return o.RowParser
              },
            })
            var a = t('./Scanner')
            Object.defineProperty(i, 'Scanner', {
              enumerable: !0,
              get: function () {
                return a.Scanner
              },
            })
            var l = t('./Token')
            Object.defineProperty(i, 'Token', {
              enumerable: !0,
              get: function () {
                return l.Token
              },
            })
            var c = t('./column')
            ;(Object.defineProperty(i, 'ColumnParser', {
              enumerable: !0,
              get: function () {
                return c.ColumnParser
              },
            }),
              Object.defineProperty(i, 'NonQuotedColumnParser', {
                enumerable: !0,
                get: function () {
                  return c.NonQuotedColumnParser
                },
              }),
              Object.defineProperty(i, 'QuotedColumnParser', {
                enumerable: !0,
                get: function () {
                  return c.QuotedColumnParser
                },
              }))
          },
          {
            './Parser': 156,
            './RowParser': 157,
            './Scanner': 158,
            './Token': 159,
            './column': 164,
          },
        ],
        166: [
          function (t, r, i) {
            var s = function (u) {
              return u && u.__esModule ? u : { default: u }
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.HeaderTransformer = void 0))
            const o = s(t('lodash.isundefined')),
              a = s(t('lodash.isfunction')),
              l = s(t('lodash.uniq')),
              c = s(t('lodash.groupby'))
            i.HeaderTransformer = class {
              constructor(u) {
                ;((this.headers = null),
                  (this.receivedHeaders = !1),
                  (this.shouldUseFirstRow = !1),
                  (this.processedFirstRow = !1),
                  (this.headersLength = 0),
                  (this.parserOptions = u),
                  u.headers === !0
                    ? (this.shouldUseFirstRow = !0)
                    : Array.isArray(u.headers)
                      ? this.setHeaders(u.headers)
                      : a.default(u.headers) && (this.headersTransform = u.headers))
              }
              transform(u, f) {
                return this.shouldMapRow(u)
                  ? f(null, this.processRow(u))
                  : f(null, { row: null, isValid: !0 })
              }
              shouldMapRow(u) {
                const { parserOptions: f } = this
                if (!this.headersTransform && f.renameHeaders && !this.processedFirstRow) {
                  if (!this.receivedHeaders)
                    throw new Error(
                      'Error renaming headers: new headers must be provided in an array',
                    )
                  return ((this.processedFirstRow = !0), !1)
                }
                if (!this.receivedHeaders && Array.isArray(u)) {
                  if (this.headersTransform) this.setHeaders(this.headersTransform(u))
                  else {
                    if (!this.shouldUseFirstRow) return !0
                    this.setHeaders(u)
                  }
                  return !1
                }
                return !0
              }
              processRow(u) {
                if (!this.headers) return { row: u, isValid: !0 }
                const { parserOptions: f } = this
                if (!f.discardUnmappedColumns && u.length > this.headersLength) {
                  if (!f.strictColumnHandling)
                    throw new Error(
                      `Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${u.length}`,
                    )
                  return {
                    row: u,
                    isValid: !1,
                    reason: `Column header mismatch expected: ${this.headersLength} columns got: ${u.length}`,
                  }
                }
                return f.strictColumnHandling && u.length < this.headersLength
                  ? {
                      row: u,
                      isValid: !1,
                      reason: `Column header mismatch expected: ${this.headersLength} columns got: ${u.length}`,
                    }
                  : { row: this.mapHeaders(u), isValid: !0 }
              }
              mapHeaders(u) {
                const f = {},
                  { headers: d, headersLength: h } = this
                for (let p = 0; p < h; p += 1) {
                  const g = d[p]
                  if (!o.default(g)) {
                    const m = u[p]
                    o.default(m) ? (f[g] = '') : (f[g] = m)
                  }
                }
                return f
              }
              setHeaders(u) {
                var f
                const d = u.filter((h) => !!h)
                if (l.default(d).length !== d.length) {
                  const h = c.default(d),
                    p = Object.keys(h).filter((g) => h[g].length > 1)
                  throw new Error('Duplicate headers found ' + JSON.stringify(p))
                }
                ;((this.headers = u),
                  (this.receivedHeaders = !0),
                  (this.headersLength =
                    ((f = this.headers) === null || f === void 0 ? void 0 : f.length) || 0))
              }
            }
          },
          {
            'lodash.groupby': 443,
            'lodash.isfunction': 446,
            'lodash.isundefined': 448,
            'lodash.uniq': 449,
          },
        ],
        167: [
          function (t, r, i) {
            var s = function (c) {
              return c && c.__esModule ? c : { default: c }
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.RowTransformerValidator = void 0))
            const o = s(t('lodash.isfunction')),
              a = t('../types')
            class l {
              constructor() {
                ;((this._rowTransform = null), (this._rowValidator = null))
              }
              static createTransform(u) {
                return a.isSyncTransform(u)
                  ? (f, d) => {
                      let h = null
                      try {
                        h = u(f)
                      } catch (p) {
                        return d(p)
                      }
                      return d(null, h)
                    }
                  : u
              }
              static createValidator(u) {
                return a.isSyncValidate(u)
                  ? (f, d) => {
                      d(null, { row: f, isValid: u(f) })
                    }
                  : (f, d) => {
                      u(f, (h, p, g) =>
                        h
                          ? d(h)
                          : d(
                              null,
                              p
                                ? { row: f, isValid: p, reason: g }
                                : { row: f, isValid: !1, reason: g },
                            ),
                      )
                    }
              }
              set rowTransform(u) {
                if (!o.default(u)) throw new TypeError('The transform should be a function')
                this._rowTransform = l.createTransform(u)
              }
              set rowValidator(u) {
                if (!o.default(u)) throw new TypeError('The validate should be a function')
                this._rowValidator = l.createValidator(u)
              }
              transformAndValidate(u, f) {
                return this.callTransformer(u, (d, h) =>
                  d
                    ? f(d)
                    : h
                      ? this.callValidator(h, (p, g) =>
                          p
                            ? f(p)
                            : g && !g.isValid
                              ? f(null, { row: h, isValid: !1, reason: g.reason })
                              : f(null, { row: h, isValid: !0 }),
                        )
                      : f(null, { row: null, isValid: !0 }),
                )
              }
              callTransformer(u, f) {
                return this._rowTransform ? this._rowTransform(u, f) : f(null, u)
              }
              callValidator(u, f) {
                return this._rowValidator
                  ? this._rowValidator(u, f)
                  : f(null, { row: u, isValid: !0 })
              }
            }
            i.RowTransformerValidator = l
          },
          { '../types': 169, 'lodash.isfunction': 446 },
        ],
        168: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.HeaderTransformer = i.RowTransformerValidator = void 0))
            var s = t('./RowTransformerValidator')
            Object.defineProperty(i, 'RowTransformerValidator', {
              enumerable: !0,
              get: function () {
                return s.RowTransformerValidator
              },
            })
            var o = t('./HeaderTransformer')
            Object.defineProperty(i, 'HeaderTransformer', {
              enumerable: !0,
              get: function () {
                return o.HeaderTransformer
              },
            })
          },
          { './HeaderTransformer': 166, './RowTransformerValidator': 167 },
        ],
        169: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.isSyncValidate = i.isSyncTransform = void 0),
              (i.isSyncTransform = (s) => s.length === 1),
              (i.isSyncValidate = (s) => s.length === 1))
          },
          {},
        ],
        170: [
          function (t, r, i) {
            const s = i
            ;((s.bignum = t('bn.js')),
              (s.define = t('./asn1/api').define),
              (s.base = t('./asn1/base')),
              (s.constants = t('./asn1/constants')),
              (s.decoders = t('./asn1/decoders')),
              (s.encoders = t('./asn1/encoders')))
          },
          {
            './asn1/api': 171,
            './asn1/base': 173,
            './asn1/constants': 177,
            './asn1/decoders': 179,
            './asn1/encoders': 182,
            'bn.js': 184,
          },
        ],
        171: [
          function (t, r, i) {
            const s = t('./encoders'),
              o = t('./decoders'),
              a = t('inherits')
            function l(c, u) {
              ;((this.name = c), (this.body = u), (this.decoders = {}), (this.encoders = {}))
            }
            ;((i.define = function (c, u) {
              return new l(c, u)
            }),
              (l.prototype._createNamed = function (c) {
                const u = this.name
                function f(d) {
                  this._initNamed(d, u)
                }
                return (
                  a(f, c),
                  (f.prototype._initNamed = function (d, h) {
                    c.call(this, d, h)
                  }),
                  new f(this)
                )
              }),
              (l.prototype._getDecoder = function (c) {
                return (
                  (c = c || 'der'),
                  this.decoders.hasOwnProperty(c) || (this.decoders[c] = this._createNamed(o[c])),
                  this.decoders[c]
                )
              }),
              (l.prototype.decode = function (c, u, f) {
                return this._getDecoder(u).decode(c, f)
              }),
              (l.prototype._getEncoder = function (c) {
                return (
                  (c = c || 'der'),
                  this.encoders.hasOwnProperty(c) || (this.encoders[c] = this._createNamed(s[c])),
                  this.encoders[c]
                )
              }),
              (l.prototype.encode = function (c, u, f) {
                return this._getEncoder(u).encode(c, f)
              }))
          },
          { './decoders': 179, './encoders': 182, inherits: 440 },
        ],
        172: [
          function (t, r, i) {
            const s = t('inherits'),
              o = t('../base/reporter').Reporter,
              a = t('safer-buffer').Buffer
            function l(u, f) {
              ;(o.call(this, f),
                a.isBuffer(u)
                  ? ((this.base = u), (this.offset = 0), (this.length = u.length))
                  : this.error('Input not Buffer'))
            }
            function c(u, f) {
              if (Array.isArray(u))
                ((this.length = 0),
                  (this.value = u.map(function (d) {
                    return (c.isEncoderBuffer(d) || (d = new c(d, f)), (this.length += d.length), d)
                  }, this)))
              else if (typeof u == 'number') {
                if (!(0 <= u && u <= 255)) return f.error('non-byte EncoderBuffer value')
                ;((this.value = u), (this.length = 1))
              } else if (typeof u == 'string') ((this.value = u), (this.length = a.byteLength(u)))
              else {
                if (!a.isBuffer(u)) return f.error('Unsupported type: ' + typeof u)
                ;((this.value = u), (this.length = u.length))
              }
            }
            ;(s(l, o),
              (i.DecoderBuffer = l),
              (l.isDecoderBuffer = function (u) {
                return u instanceof l
                  ? !0
                  : typeof u == 'object' &&
                      a.isBuffer(u.base) &&
                      u.constructor.name === 'DecoderBuffer' &&
                      typeof u.offset == 'number' &&
                      typeof u.length == 'number' &&
                      typeof u.save == 'function' &&
                      typeof u.restore == 'function' &&
                      typeof u.isEmpty == 'function' &&
                      typeof u.readUInt8 == 'function' &&
                      typeof u.skip == 'function' &&
                      typeof u.raw == 'function'
              }),
              (l.prototype.save = function () {
                return { offset: this.offset, reporter: o.prototype.save.call(this) }
              }),
              (l.prototype.restore = function (u) {
                const f = new l(this.base)
                return (
                  (f.offset = u.offset),
                  (f.length = this.offset),
                  (this.offset = u.offset),
                  o.prototype.restore.call(this, u.reporter),
                  f
                )
              }),
              (l.prototype.isEmpty = function () {
                return this.offset === this.length
              }),
              (l.prototype.readUInt8 = function (u) {
                return this.offset + 1 <= this.length
                  ? this.base.readUInt8(this.offset++, !0)
                  : this.error(u || 'DecoderBuffer overrun')
              }),
              (l.prototype.skip = function (u, f) {
                if (!(this.offset + u <= this.length))
                  return this.error(f || 'DecoderBuffer overrun')
                const d = new l(this.base)
                return (
                  (d._reporterState = this._reporterState),
                  (d.offset = this.offset),
                  (d.length = this.offset + u),
                  (this.offset += u),
                  d
                )
              }),
              (l.prototype.raw = function (u) {
                return this.base.slice(u ? u.offset : this.offset, this.length)
              }),
              (i.EncoderBuffer = c),
              (c.isEncoderBuffer = function (u) {
                return u instanceof c
                  ? !0
                  : typeof u == 'object' &&
                      u.constructor.name === 'EncoderBuffer' &&
                      typeof u.length == 'number' &&
                      typeof u.join == 'function'
              }),
              (c.prototype.join = function (u, f) {
                return (
                  u || (u = a.alloc(this.length)),
                  f || (f = 0),
                  this.length === 0 ||
                    (Array.isArray(this.value)
                      ? this.value.forEach(function (d) {
                          ;(d.join(u, f), (f += d.length))
                        })
                      : (typeof this.value == 'number'
                          ? (u[f] = this.value)
                          : typeof this.value == 'string'
                            ? u.write(this.value, f)
                            : a.isBuffer(this.value) && this.value.copy(u, f),
                        (f += this.length))),
                  u
                )
              }))
          },
          { '../base/reporter': 175, inherits: 440, 'safer-buffer': 495 },
        ],
        173: [
          function (t, r, i) {
            const s = i
            ;((s.Reporter = t('./reporter').Reporter),
              (s.DecoderBuffer = t('./buffer').DecoderBuffer),
              (s.EncoderBuffer = t('./buffer').EncoderBuffer),
              (s.Node = t('./node')))
          },
          { './buffer': 172, './node': 174, './reporter': 175 },
        ],
        174: [
          function (t, r, i) {
            const s = t('../base/reporter').Reporter,
              o = t('../base/buffer').EncoderBuffer,
              a = t('../base/buffer').DecoderBuffer,
              l = t('minimalistic-assert'),
              c = [
                'seq',
                'seqof',
                'set',
                'setof',
                'objid',
                'bool',
                'gentime',
                'utctime',
                'null_',
                'enum',
                'int',
                'objDesc',
                'bitstr',
                'bmpstr',
                'charstr',
                'genstr',
                'graphstr',
                'ia5str',
                'iso646str',
                'numstr',
                'octstr',
                'printstr',
                't61str',
                'unistr',
                'utf8str',
                'videostr',
              ],
              u = [
                'key',
                'obj',
                'use',
                'optional',
                'explicit',
                'implicit',
                'def',
                'choice',
                'any',
                'contains',
              ].concat(c)
            function f(h, p, g) {
              const m = {}
              ;((this._baseState = m),
                (m.name = g),
                (m.enc = h),
                (m.parent = p || null),
                (m.children = null),
                (m.tag = null),
                (m.args = null),
                (m.reverseArgs = null),
                (m.choice = null),
                (m.optional = !1),
                (m.any = !1),
                (m.obj = !1),
                (m.use = null),
                (m.useDecoder = null),
                (m.key = null),
                (m.default = null),
                (m.explicit = null),
                (m.implicit = null),
                (m.contains = null),
                m.parent || ((m.children = []), this._wrap()))
            }
            r.exports = f
            const d = [
              'enc',
              'parent',
              'children',
              'tag',
              'args',
              'reverseArgs',
              'choice',
              'optional',
              'any',
              'obj',
              'use',
              'alteredUse',
              'key',
              'default',
              'explicit',
              'implicit',
              'contains',
            ]
            ;((f.prototype.clone = function () {
              const h = this._baseState,
                p = {}
              d.forEach(function (m) {
                p[m] = h[m]
              })
              const g = new this.constructor(p.parent)
              return ((g._baseState = p), g)
            }),
              (f.prototype._wrap = function () {
                const h = this._baseState
                u.forEach(function (p) {
                  this[p] = function () {
                    const g = new this.constructor(this)
                    return (h.children.push(g), g[p].apply(g, arguments))
                  }
                }, this)
              }),
              (f.prototype._init = function (h) {
                const p = this._baseState
                ;(l(p.parent === null),
                  h.call(this),
                  (p.children = p.children.filter(function (g) {
                    return g._baseState.parent === this
                  }, this)),
                  l.equal(p.children.length, 1, 'Root node can have only one child'))
              }),
              (f.prototype._useArgs = function (h) {
                const p = this._baseState,
                  g = h.filter(function (m) {
                    return m instanceof this.constructor
                  }, this)
                ;((h = h.filter(function (m) {
                  return !(m instanceof this.constructor)
                }, this)),
                  g.length !== 0 &&
                    (l(p.children === null),
                    (p.children = g),
                    g.forEach(function (m) {
                      m._baseState.parent = this
                    }, this)),
                  h.length !== 0 &&
                    (l(p.args === null),
                    (p.args = h),
                    (p.reverseArgs = h.map(function (m) {
                      if (typeof m != 'object' || m.constructor !== Object) return m
                      const y = {}
                      return (
                        Object.keys(m).forEach(function (b) {
                          b == (0 | b) && (b |= 0)
                          const w = m[b]
                          y[w] = b
                        }),
                        y
                      )
                    }))))
              }),
              [
                '_peekTag',
                '_decodeTag',
                '_use',
                '_decodeStr',
                '_decodeObjid',
                '_decodeTime',
                '_decodeNull',
                '_decodeInt',
                '_decodeBool',
                '_decodeList',
                '_encodeComposite',
                '_encodeStr',
                '_encodeObjid',
                '_encodeTime',
                '_encodeNull',
                '_encodeInt',
                '_encodeBool',
              ].forEach(function (h) {
                f.prototype[h] = function () {
                  const p = this._baseState
                  throw new Error(h + ' not implemented for encoding: ' + p.enc)
                }
              }),
              c.forEach(function (h) {
                f.prototype[h] = function () {
                  const p = this._baseState,
                    g = Array.prototype.slice.call(arguments)
                  return (l(p.tag === null), (p.tag = h), this._useArgs(g), this)
                }
              }),
              (f.prototype.use = function (h) {
                l(h)
                const p = this._baseState
                return (l(p.use === null), (p.use = h), this)
              }),
              (f.prototype.optional = function () {
                return ((this._baseState.optional = !0), this)
              }),
              (f.prototype.def = function (h) {
                const p = this._baseState
                return (l(p.default === null), (p.default = h), (p.optional = !0), this)
              }),
              (f.prototype.explicit = function (h) {
                const p = this._baseState
                return (l(p.explicit === null && p.implicit === null), (p.explicit = h), this)
              }),
              (f.prototype.implicit = function (h) {
                const p = this._baseState
                return (l(p.explicit === null && p.implicit === null), (p.implicit = h), this)
              }),
              (f.prototype.obj = function () {
                const h = this._baseState,
                  p = Array.prototype.slice.call(arguments)
                return ((h.obj = !0), p.length !== 0 && this._useArgs(p), this)
              }),
              (f.prototype.key = function (h) {
                const p = this._baseState
                return (l(p.key === null), (p.key = h), this)
              }),
              (f.prototype.any = function () {
                return ((this._baseState.any = !0), this)
              }),
              (f.prototype.choice = function (h) {
                const p = this._baseState
                return (
                  l(p.choice === null),
                  (p.choice = h),
                  this._useArgs(
                    Object.keys(h).map(function (g) {
                      return h[g]
                    }),
                  ),
                  this
                )
              }),
              (f.prototype.contains = function (h) {
                const p = this._baseState
                return (l(p.use === null), (p.contains = h), this)
              }),
              (f.prototype._decode = function (h, p) {
                const g = this._baseState
                if (g.parent === null) return h.wrapResult(g.children[0]._decode(h, p))
                let m,
                  y = g.default,
                  b = !0,
                  w = null
                if ((g.key !== null && (w = h.enterKey(g.key)), g.optional)) {
                  let C = null
                  if (
                    (g.explicit !== null
                      ? (C = g.explicit)
                      : g.implicit !== null
                        ? (C = g.implicit)
                        : g.tag !== null && (C = g.tag),
                    C !== null || g.any)
                  ) {
                    if (((b = this._peekTag(h, C, g.any)), h.isError(b))) return b
                  } else {
                    const T = h.save()
                    try {
                      ;(g.choice === null
                        ? this._decodeGeneric(g.tag, h, p)
                        : this._decodeChoice(h, p),
                        (b = !0))
                    } catch {
                      b = !1
                    }
                    h.restore(T)
                  }
                }
                if ((g.obj && b && (m = h.enterObject()), b)) {
                  if (g.explicit !== null) {
                    const T = this._decodeTag(h, g.explicit)
                    if (h.isError(T)) return T
                    h = T
                  }
                  const C = h.offset
                  if (g.use === null && g.choice === null) {
                    let T
                    g.any && (T = h.save())
                    const I = this._decodeTag(h, g.implicit !== null ? g.implicit : g.tag, g.any)
                    if (h.isError(I)) return I
                    g.any ? (y = h.raw(T)) : (h = I)
                  }
                  if (
                    (p && p.track && g.tag !== null && p.track(h.path(), C, h.length, 'tagged'),
                    p &&
                      p.track &&
                      g.tag !== null &&
                      p.track(h.path(), h.offset, h.length, 'content'),
                    g.any ||
                      (y =
                        g.choice === null
                          ? this._decodeGeneric(g.tag, h, p)
                          : this._decodeChoice(h, p)),
                    h.isError(y))
                  )
                    return y
                  if (
                    (g.any ||
                      g.choice !== null ||
                      g.children === null ||
                      g.children.forEach(function (T) {
                        T._decode(h, p)
                      }),
                    g.contains && (g.tag === 'octstr' || g.tag === 'bitstr'))
                  ) {
                    const T = new a(y)
                    y = this._getUse(g.contains, h._reporterState.obj)._decode(T, p)
                  }
                }
                return (
                  g.obj && b && (y = h.leaveObject(m)),
                  g.key === null || (y === null && b !== !0)
                    ? w !== null && h.exitKey(w)
                    : h.leaveKey(w, g.key, y),
                  y
                )
              }),
              (f.prototype._decodeGeneric = function (h, p, g) {
                const m = this._baseState
                return h === 'seq' || h === 'set'
                  ? null
                  : h === 'seqof' || h === 'setof'
                    ? this._decodeList(p, h, m.args[0], g)
                    : /str$/.test(h)
                      ? this._decodeStr(p, h, g)
                      : h === 'objid' && m.args
                        ? this._decodeObjid(p, m.args[0], m.args[1], g)
                        : h === 'objid'
                          ? this._decodeObjid(p, null, null, g)
                          : h === 'gentime' || h === 'utctime'
                            ? this._decodeTime(p, h, g)
                            : h === 'null_'
                              ? this._decodeNull(p, g)
                              : h === 'bool'
                                ? this._decodeBool(p, g)
                                : h === 'objDesc'
                                  ? this._decodeStr(p, h, g)
                                  : h === 'int' || h === 'enum'
                                    ? this._decodeInt(p, m.args && m.args[0], g)
                                    : m.use !== null
                                      ? this._getUse(m.use, p._reporterState.obj)._decode(p, g)
                                      : p.error('unknown tag: ' + h)
              }),
              (f.prototype._getUse = function (h, p) {
                const g = this._baseState
                return (
                  (g.useDecoder = this._use(h, p)),
                  l(g.useDecoder._baseState.parent === null),
                  (g.useDecoder = g.useDecoder._baseState.children[0]),
                  g.implicit !== g.useDecoder._baseState.implicit &&
                    ((g.useDecoder = g.useDecoder.clone()),
                    (g.useDecoder._baseState.implicit = g.implicit)),
                  g.useDecoder
                )
              }),
              (f.prototype._decodeChoice = function (h, p) {
                const g = this._baseState
                let m = null,
                  y = !1
                return (
                  Object.keys(g.choice).some(function (b) {
                    const w = h.save(),
                      C = g.choice[b]
                    try {
                      const T = C._decode(h, p)
                      if (h.isError(T)) return !1
                      ;((m = { type: b, value: T }), (y = !0))
                    } catch {
                      return (h.restore(w), !1)
                    }
                    return !0
                  }, this),
                  y ? m : h.error('Choice not matched')
                )
              }),
              (f.prototype._createEncoderBuffer = function (h) {
                return new o(h, this.reporter)
              }),
              (f.prototype._encode = function (h, p, g) {
                const m = this._baseState
                if (m.default !== null && m.default === h) return
                const y = this._encodeValue(h, p, g)
                return y === void 0 || this._skipDefault(y, p, g) ? void 0 : y
              }),
              (f.prototype._encodeValue = function (h, p, g) {
                const m = this._baseState
                if (m.parent === null) return m.children[0]._encode(h, p || new s())
                let y = null
                if (((this.reporter = p), m.optional && h === void 0)) {
                  if (m.default === null) return
                  h = m.default
                }
                let b = null,
                  w = !1
                if (m.any) y = this._createEncoderBuffer(h)
                else if (m.choice) y = this._encodeChoice(h, p)
                else if (m.contains) ((b = this._getUse(m.contains, g)._encode(h, p)), (w = !0))
                else if (m.children)
                  ((b = m.children
                    .map(function (C) {
                      if (C._baseState.tag === 'null_') return C._encode(null, p, h)
                      if (C._baseState.key === null) return p.error('Child should have a key')
                      const T = p.enterKey(C._baseState.key)
                      if (typeof h != 'object')
                        return p.error('Child expected, but input is not object')
                      const I = C._encode(h[C._baseState.key], p, h)
                      return (p.leaveKey(T), I)
                    }, this)
                    .filter(function (C) {
                      return C
                    })),
                    (b = this._createEncoderBuffer(b)))
                else if (m.tag === 'seqof' || m.tag === 'setof') {
                  if (!m.args || m.args.length !== 1) return p.error('Too many args for : ' + m.tag)
                  if (!Array.isArray(h)) return p.error('seqof/setof, but data is not Array')
                  const C = this.clone()
                  ;((C._baseState.implicit = null),
                    (b = this._createEncoderBuffer(
                      h.map(function (T) {
                        const I = this._baseState
                        return this._getUse(I.args[0], h)._encode(T, p)
                      }, C),
                    )))
                } else
                  m.use !== null
                    ? (y = this._getUse(m.use, g)._encode(h, p))
                    : ((b = this._encodePrimitive(m.tag, h)), (w = !0))
                if (!m.any && m.choice === null) {
                  const C = m.implicit !== null ? m.implicit : m.tag,
                    T = m.implicit === null ? 'universal' : 'context'
                  C === null
                    ? m.use === null && p.error('Tag could be omitted only for .use()')
                    : m.use === null && (y = this._encodeComposite(C, w, T, b))
                }
                return (
                  m.explicit !== null && (y = this._encodeComposite(m.explicit, !1, 'context', y)),
                  y
                )
              }),
              (f.prototype._encodeChoice = function (h, p) {
                const g = this._baseState,
                  m = g.choice[h.type]
                return (
                  m || l(!1, h.type + ' not found in ' + JSON.stringify(Object.keys(g.choice))),
                  m._encode(h.value, p)
                )
              }),
              (f.prototype._encodePrimitive = function (h, p) {
                const g = this._baseState
                if (/str$/.test(h)) return this._encodeStr(p, h)
                if (h === 'objid' && g.args)
                  return this._encodeObjid(p, g.reverseArgs[0], g.args[1])
                if (h === 'objid') return this._encodeObjid(p, null, null)
                if (h === 'gentime' || h === 'utctime') return this._encodeTime(p, h)
                if (h === 'null_') return this._encodeNull()
                if (h === 'int' || h === 'enum')
                  return this._encodeInt(p, g.args && g.reverseArgs[0])
                if (h === 'bool') return this._encodeBool(p)
                if (h === 'objDesc') return this._encodeStr(p, h)
                throw new Error('Unsupported tag: ' + h)
              }),
              (f.prototype._isNumstr = function (h) {
                return /^[0-9 ]*$/.test(h)
              }),
              (f.prototype._isPrintstr = function (h) {
                return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(h)
              }))
          },
          { '../base/buffer': 172, '../base/reporter': 175, 'minimalistic-assert': 453 },
        ],
        175: [
          function (t, r, i) {
            const s = t('inherits')
            function o(l) {
              this._reporterState = { obj: null, path: [], options: l || {}, errors: [] }
            }
            function a(l, c) {
              ;((this.path = l), this.rethrow(c))
            }
            ;((i.Reporter = o),
              (o.prototype.isError = function (l) {
                return l instanceof a
              }),
              (o.prototype.save = function () {
                const l = this._reporterState
                return { obj: l.obj, pathLen: l.path.length }
              }),
              (o.prototype.restore = function (l) {
                const c = this._reporterState
                ;((c.obj = l.obj), (c.path = c.path.slice(0, l.pathLen)))
              }),
              (o.prototype.enterKey = function (l) {
                return this._reporterState.path.push(l)
              }),
              (o.prototype.exitKey = function (l) {
                const c = this._reporterState
                c.path = c.path.slice(0, l - 1)
              }),
              (o.prototype.leaveKey = function (l, c, u) {
                const f = this._reporterState
                ;(this.exitKey(l), f.obj !== null && (f.obj[c] = u))
              }),
              (o.prototype.path = function () {
                return this._reporterState.path.join('/')
              }),
              (o.prototype.enterObject = function () {
                const l = this._reporterState,
                  c = l.obj
                return ((l.obj = {}), c)
              }),
              (o.prototype.leaveObject = function (l) {
                const c = this._reporterState,
                  u = c.obj
                return ((c.obj = l), u)
              }),
              (o.prototype.error = function (l) {
                let c
                const u = this._reporterState,
                  f = l instanceof a
                if (
                  ((c = f
                    ? l
                    : new a(
                        u.path
                          .map(function (d) {
                            return '[' + JSON.stringify(d) + ']'
                          })
                          .join(''),
                        l.message || l,
                        l.stack,
                      )),
                  !u.options.partial)
                )
                  throw c
                return (f || u.errors.push(c), c)
              }),
              (o.prototype.wrapResult = function (l) {
                const c = this._reporterState
                return c.options.partial
                  ? { result: this.isError(l) ? null : l, errors: c.errors }
                  : l
              }),
              s(a, Error),
              (a.prototype.rethrow = function (l) {
                if (
                  ((this.message = l + ' at: ' + (this.path || '(shallow)')),
                  Error.captureStackTrace && Error.captureStackTrace(this, a),
                  !this.stack)
                )
                  try {
                    throw new Error(this.message)
                  } catch (c) {
                    this.stack = c.stack
                  }
                return this
              }))
          },
          { inherits: 440 },
        ],
        176: [
          function (t, r, i) {
            function s(o) {
              const a = {}
              return (
                Object.keys(o).forEach(function (l) {
                  ;(0 | l) == l && (l |= 0)
                  const c = o[l]
                  a[c] = l
                }),
                a
              )
            }
            ;((i.tagClass = { 0: 'universal', 1: 'application', 2: 'context', 3: 'private' }),
              (i.tagClassByName = s(i.tagClass)),
              (i.tag = {
                0: 'end',
                1: 'bool',
                2: 'int',
                3: 'bitstr',
                4: 'octstr',
                5: 'null_',
                6: 'objid',
                7: 'objDesc',
                8: 'external',
                9: 'real',
                10: 'enum',
                11: 'embed',
                12: 'utf8str',
                13: 'relativeOid',
                16: 'seq',
                17: 'set',
                18: 'numstr',
                19: 'printstr',
                20: 't61str',
                21: 'videostr',
                22: 'ia5str',
                23: 'utctime',
                24: 'gentime',
                25: 'graphstr',
                26: 'iso646str',
                27: 'genstr',
                28: 'unistr',
                29: 'charstr',
                30: 'bmpstr',
              }),
              (i.tagByName = s(i.tag)))
          },
          {},
        ],
        177: [
          function (t, r, i) {
            const s = i
            ;((s._reverse = function (o) {
              const a = {}
              return (
                Object.keys(o).forEach(function (l) {
                  ;(0 | l) == l && (l |= 0)
                  const c = o[l]
                  a[c] = l
                }),
                a
              )
            }),
              (s.der = t('./der')))
          },
          { './der': 176 },
        ],
        178: [
          function (t, r, i) {
            const s = t('inherits'),
              o = t('bn.js'),
              a = t('../base/buffer').DecoderBuffer,
              l = t('../base/node'),
              c = t('../constants/der')
            function u(p) {
              ;((this.enc = 'der'),
                (this.name = p.name),
                (this.entity = p),
                (this.tree = new f()),
                this.tree._init(p.body))
            }
            function f(p) {
              l.call(this, 'der', p)
            }
            function d(p, g) {
              let m = p.readUInt8(g)
              if (p.isError(m)) return m
              const y = c.tagClass[m >> 6],
                b = (32 & m) == 0
              if ((31 & m) == 31) {
                let w = m
                for (m = 0; (128 & w) == 128; ) {
                  if (((w = p.readUInt8(g)), p.isError(w))) return w
                  ;((m <<= 7), (m |= 127 & w))
                }
              } else m &= 31
              return { cls: y, primitive: b, tag: m, tagStr: c.tag[m] }
            }
            function h(p, g, m) {
              let y = p.readUInt8(m)
              if (p.isError(y)) return y
              if (!g && y === 128) return null
              if (!(128 & y)) return y
              const b = 127 & y
              if (b > 4) return p.error('length octect is too long')
              y = 0
              for (let w = 0; w < b; w++) {
                y <<= 8
                const C = p.readUInt8(m)
                if (p.isError(C)) return C
                y |= C
              }
              return y
            }
            ;((r.exports = u),
              (u.prototype.decode = function (p, g) {
                return (a.isDecoderBuffer(p) || (p = new a(p, g)), this.tree._decode(p, g))
              }),
              s(f, l),
              (f.prototype._peekTag = function (p, g, m) {
                if (p.isEmpty()) return !1
                const y = p.save(),
                  b = d(p, 'Failed to peek tag: "' + g + '"')
                return p.isError(b)
                  ? b
                  : (p.restore(y), b.tag === g || b.tagStr === g || b.tagStr + 'of' === g || m)
              }),
              (f.prototype._decodeTag = function (p, g, m) {
                const y = d(p, 'Failed to decode tag of "' + g + '"')
                if (p.isError(y)) return y
                let b = h(p, y.primitive, 'Failed to get length of "' + g + '"')
                if (p.isError(b)) return b
                if (!m && y.tag !== g && y.tagStr !== g && y.tagStr + 'of' !== g)
                  return p.error('Failed to match tag: "' + g + '"')
                if (y.primitive || b !== null)
                  return p.skip(b, 'Failed to match body of: "' + g + '"')
                const w = p.save(),
                  C = this._skipUntilEnd(
                    p,
                    'Failed to skip indefinite length body: "' + this.tag + '"',
                  )
                return p.isError(C)
                  ? C
                  : ((b = p.offset - w.offset),
                    p.restore(w),
                    p.skip(b, 'Failed to match body of: "' + g + '"'))
              }),
              (f.prototype._skipUntilEnd = function (p, g) {
                for (;;) {
                  const m = d(p, g)
                  if (p.isError(m)) return m
                  const y = h(p, m.primitive, g)
                  if (p.isError(y)) return y
                  let b
                  if (
                    ((b = m.primitive || y !== null ? p.skip(y) : this._skipUntilEnd(p, g)),
                    p.isError(b))
                  )
                    return b
                  if (m.tagStr === 'end') break
                }
              }),
              (f.prototype._decodeList = function (p, g, m, y) {
                const b = []
                for (; !p.isEmpty(); ) {
                  const w = this._peekTag(p, 'end')
                  if (p.isError(w)) return w
                  const C = m.decode(p, 'der', y)
                  if (p.isError(C) && w) break
                  b.push(C)
                }
                return b
              }),
              (f.prototype._decodeStr = function (p, g) {
                if (g === 'bitstr') {
                  const m = p.readUInt8()
                  return p.isError(m) ? m : { unused: m, data: p.raw() }
                }
                if (g === 'bmpstr') {
                  const m = p.raw()
                  if (m.length % 2 == 1)
                    return p.error('Decoding of string type: bmpstr length mismatch')
                  let y = ''
                  for (let b = 0; b < m.length / 2; b++)
                    y += String.fromCharCode(m.readUInt16BE(2 * b))
                  return y
                }
                if (g === 'numstr') {
                  const m = p.raw().toString('ascii')
                  return this._isNumstr(m)
                    ? m
                    : p.error('Decoding of string type: numstr unsupported characters')
                }
                if (g === 'octstr' || g === 'objDesc') return p.raw()
                if (g === 'printstr') {
                  const m = p.raw().toString('ascii')
                  return this._isPrintstr(m)
                    ? m
                    : p.error('Decoding of string type: printstr unsupported characters')
                }
                return /str$/.test(g)
                  ? p.raw().toString()
                  : p.error('Decoding of string type: ' + g + ' unsupported')
              }),
              (f.prototype._decodeObjid = function (p, g, m) {
                let y
                const b = []
                let w = 0,
                  C = 0
                for (; !p.isEmpty(); )
                  ((C = p.readUInt8()),
                    (w <<= 7),
                    (w |= 127 & C),
                    !(128 & C) && (b.push(w), (w = 0)))
                128 & C && b.push(w)
                const T = (b[0] / 40) | 0,
                  I = b[0] % 40
                if (((y = m ? b : [T, I].concat(b.slice(1))), g)) {
                  let B = g[y.join(' ')]
                  ;(B === void 0 && (B = g[y.join('.')]), B !== void 0 && (y = B))
                }
                return y
              }),
              (f.prototype._decodeTime = function (p, g) {
                const m = p.raw().toString()
                let y, b, w, C, T, I
                if (g === 'gentime')
                  ((y = 0 | m.slice(0, 4)),
                    (b = 0 | m.slice(4, 6)),
                    (w = 0 | m.slice(6, 8)),
                    (C = 0 | m.slice(8, 10)),
                    (T = 0 | m.slice(10, 12)),
                    (I = 0 | m.slice(12, 14)))
                else {
                  if (g !== 'utctime')
                    return p.error('Decoding ' + g + ' time is not supported yet')
                  ;((y = 0 | m.slice(0, 2)),
                    (b = 0 | m.slice(2, 4)),
                    (w = 0 | m.slice(4, 6)),
                    (C = 0 | m.slice(6, 8)),
                    (T = 0 | m.slice(8, 10)),
                    (I = 0 | m.slice(10, 12)),
                    (y = y < 70 ? 2e3 + y : 1900 + y))
                }
                return Date.UTC(y, b - 1, w, C, T, I, 0)
              }),
              (f.prototype._decodeNull = function () {
                return null
              }),
              (f.prototype._decodeBool = function (p) {
                const g = p.readUInt8()
                return p.isError(g) ? g : g !== 0
              }),
              (f.prototype._decodeInt = function (p, g) {
                const m = p.raw()
                let y = new o(m)
                return (g && (y = g[y.toString(10)] || y), y)
              }),
              (f.prototype._use = function (p, g) {
                return (typeof p == 'function' && (p = p(g)), p._getDecoder('der').tree)
              }))
          },
          {
            '../base/buffer': 172,
            '../base/node': 174,
            '../constants/der': 176,
            'bn.js': 184,
            inherits: 440,
          },
        ],
        179: [
          function (t, r, i) {
            const s = i
            ;((s.der = t('./der')), (s.pem = t('./pem')))
          },
          { './der': 178, './pem': 180 },
        ],
        180: [
          function (t, r, i) {
            const s = t('inherits'),
              o = t('safer-buffer').Buffer,
              a = t('./der')
            function l(c) {
              ;(a.call(this, c), (this.enc = 'pem'))
            }
            ;(s(l, a),
              (r.exports = l),
              (l.prototype.decode = function (c, u) {
                const f = c.toString().split(/[\r\n]+/g),
                  d = u.label.toUpperCase(),
                  h = /^-----(BEGIN|END) ([^-]+)-----$/
                let p = -1,
                  g = -1
                for (let b = 0; b < f.length; b++) {
                  const w = f[b].match(h)
                  if (w !== null && w[2] === d) {
                    if (p !== -1) {
                      if (w[1] !== 'END') break
                      g = b
                      break
                    }
                    if (w[1] !== 'BEGIN') break
                    p = b
                  }
                }
                if (p === -1 || g === -1) throw new Error('PEM section not found for: ' + d)
                const m = f.slice(p + 1, g).join('')
                m.replace(/[^a-z0-9+/=]+/gi, '')
                const y = o.from(m, 'base64')
                return a.prototype.decode.call(this, y, u)
              }))
          },
          { './der': 178, inherits: 440, 'safer-buffer': 495 },
        ],
        181: [
          function (t, r, i) {
            const s = t('inherits'),
              o = t('safer-buffer').Buffer,
              a = t('../base/node'),
              l = t('../constants/der')
            function c(d) {
              ;((this.enc = 'der'),
                (this.name = d.name),
                (this.entity = d),
                (this.tree = new u()),
                this.tree._init(d.body))
            }
            function u(d) {
              a.call(this, 'der', d)
            }
            function f(d) {
              return d < 10 ? '0' + d : d
            }
            ;((r.exports = c),
              (c.prototype.encode = function (d, h) {
                return this.tree._encode(d, h).join()
              }),
              s(u, a),
              (u.prototype._encodeComposite = function (d, h, p, g) {
                const m = (function (w, C, T, I) {
                  let B
                  if (
                    (w === 'seqof' ? (w = 'seq') : w === 'setof' && (w = 'set'),
                    l.tagByName.hasOwnProperty(w))
                  )
                    B = l.tagByName[w]
                  else {
                    if (typeof w != 'number' || (0 | w) !== w) return I.error('Unknown tag: ' + w)
                    B = w
                  }
                  return B >= 31
                    ? I.error('Multi-octet tag encoding unsupported')
                    : (C || (B |= 32), (B |= l.tagClassByName[T || 'universal'] << 6), B)
                })(d, h, p, this.reporter)
                if (g.length < 128) {
                  const w = o.alloc(2)
                  return ((w[0] = m), (w[1] = g.length), this._createEncoderBuffer([w, g]))
                }
                let y = 1
                for (let w = g.length; w >= 256; w >>= 8) y++
                const b = o.alloc(2 + y)
                ;((b[0] = m), (b[1] = 128 | y))
                for (let w = 1 + y, C = g.length; C > 0; w--, C >>= 8) b[w] = 255 & C
                return this._createEncoderBuffer([b, g])
              }),
              (u.prototype._encodeStr = function (d, h) {
                if (h === 'bitstr') return this._createEncoderBuffer([0 | d.unused, d.data])
                if (h === 'bmpstr') {
                  const p = o.alloc(2 * d.length)
                  for (let g = 0; g < d.length; g++) p.writeUInt16BE(d.charCodeAt(g), 2 * g)
                  return this._createEncoderBuffer(p)
                }
                return h === 'numstr'
                  ? this._isNumstr(d)
                    ? this._createEncoderBuffer(d)
                    : this.reporter.error(
                        'Encoding of string type: numstr supports only digits and space',
                      )
                  : h === 'printstr'
                    ? this._isPrintstr(d)
                      ? this._createEncoderBuffer(d)
                      : this.reporter.error(
                          'Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark',
                        )
                    : /str$/.test(h) || h === 'objDesc'
                      ? this._createEncoderBuffer(d)
                      : this.reporter.error('Encoding of string type: ' + h + ' unsupported')
              }),
              (u.prototype._encodeObjid = function (d, h, p) {
                if (typeof d == 'string') {
                  if (!h) return this.reporter.error('string objid given, but no values map found')
                  if (!h.hasOwnProperty(d))
                    return this.reporter.error('objid not found in values map')
                  d = h[d].split(/[\s.]+/g)
                  for (let b = 0; b < d.length; b++) d[b] |= 0
                } else if (Array.isArray(d)) {
                  d = d.slice()
                  for (let b = 0; b < d.length; b++) d[b] |= 0
                }
                if (!Array.isArray(d))
                  return this.reporter.error(
                    'objid() should be either array or string, got: ' + JSON.stringify(d),
                  )
                if (!p) {
                  if (d[1] >= 40) return this.reporter.error('Second objid identifier OOB')
                  d.splice(0, 2, 40 * d[0] + d[1])
                }
                let g = 0
                for (let b = 0; b < d.length; b++) {
                  let w = d[b]
                  for (g++; w >= 128; w >>= 7) g++
                }
                const m = o.alloc(g)
                let y = m.length - 1
                for (let b = d.length - 1; b >= 0; b--) {
                  let w = d[b]
                  for (m[y--] = 127 & w; (w >>= 7) > 0; ) m[y--] = 128 | (127 & w)
                }
                return this._createEncoderBuffer(m)
              }),
              (u.prototype._encodeTime = function (d, h) {
                let p
                const g = new Date(d)
                return (
                  h === 'gentime'
                    ? (p = [
                        f(g.getUTCFullYear()),
                        f(g.getUTCMonth() + 1),
                        f(g.getUTCDate()),
                        f(g.getUTCHours()),
                        f(g.getUTCMinutes()),
                        f(g.getUTCSeconds()),
                        'Z',
                      ].join(''))
                    : h === 'utctime'
                      ? (p = [
                          f(g.getUTCFullYear() % 100),
                          f(g.getUTCMonth() + 1),
                          f(g.getUTCDate()),
                          f(g.getUTCHours()),
                          f(g.getUTCMinutes()),
                          f(g.getUTCSeconds()),
                          'Z',
                        ].join(''))
                      : this.reporter.error('Encoding ' + h + ' time is not supported yet'),
                  this._encodeStr(p, 'octstr')
                )
              }),
              (u.prototype._encodeNull = function () {
                return this._createEncoderBuffer('')
              }),
              (u.prototype._encodeInt = function (d, h) {
                if (typeof d == 'string') {
                  if (!h) return this.reporter.error('String int or enum given, but no values map')
                  if (!h.hasOwnProperty(d))
                    return this.reporter.error("Values map doesn't contain: " + JSON.stringify(d))
                  d = h[d]
                }
                if (typeof d != 'number' && !o.isBuffer(d)) {
                  const m = d.toArray()
                  ;(!d.sign && 128 & m[0] && m.unshift(0), (d = o.from(m)))
                }
                if (o.isBuffer(d)) {
                  let m = d.length
                  d.length === 0 && m++
                  const y = o.alloc(m)
                  return (d.copy(y), d.length === 0 && (y[0] = 0), this._createEncoderBuffer(y))
                }
                if (d < 128) return this._createEncoderBuffer(d)
                if (d < 256) return this._createEncoderBuffer([0, d])
                let p = 1
                for (let m = d; m >= 256; m >>= 8) p++
                const g = new Array(p)
                for (let m = g.length - 1; m >= 0; m--) ((g[m] = 255 & d), (d >>= 8))
                return (128 & g[0] && g.unshift(0), this._createEncoderBuffer(o.from(g)))
              }),
              (u.prototype._encodeBool = function (d) {
                return this._createEncoderBuffer(d ? 255 : 0)
              }),
              (u.prototype._use = function (d, h) {
                return (typeof d == 'function' && (d = d(h)), d._getEncoder('der').tree)
              }),
              (u.prototype._skipDefault = function (d, h, p) {
                const g = this._baseState
                let m
                if (g.default === null) return !1
                const y = d.join()
                if (
                  (g.defaultBuffer === void 0 &&
                    (g.defaultBuffer = this._encodeValue(g.default, h, p).join()),
                  y.length !== g.defaultBuffer.length)
                )
                  return !1
                for (m = 0; m < y.length; m++) if (y[m] !== g.defaultBuffer[m]) return !1
                return !0
              }))
          },
          { '../base/node': 174, '../constants/der': 176, inherits: 440, 'safer-buffer': 495 },
        ],
        182: [
          function (t, r, i) {
            const s = i
            ;((s.der = t('./der')), (s.pem = t('./pem')))
          },
          { './der': 181, './pem': 183 },
        ],
        183: [
          function (t, r, i) {
            const s = t('inherits'),
              o = t('./der')
            function a(l) {
              ;(o.call(this, l), (this.enc = 'pem'))
            }
            ;(s(a, o),
              (r.exports = a),
              (a.prototype.encode = function (l, c) {
                const u = o.prototype.encode.call(this, l).toString('base64'),
                  f = ['-----BEGIN ' + c.label + '-----']
                for (let d = 0; d < u.length; d += 64) f.push(u.slice(d, d + 64))
                return (
                  f.push('-----END ' + c.label + '-----'),
                  f.join(`
`)
                )
              }))
          },
          { './der': 181, inherits: 440 },
        ],
        184: [
          function (t, r, i) {
            ;(function (s, o) {
              function a(M, R) {
                if (!M) throw new Error(R || 'Assertion failed')
              }
              function l(M, R) {
                M.super_ = R
                var k = function () {}
                ;((k.prototype = R.prototype),
                  (M.prototype = new k()),
                  (M.prototype.constructor = M))
              }
              function c(M, R, k) {
                if (c.isBN(M)) return M
                ;((this.negative = 0),
                  (this.words = null),
                  (this.length = 0),
                  (this.red = null),
                  M !== null &&
                    ((R !== 'le' && R !== 'be') || ((k = R), (R = 10)),
                    this._init(M || 0, R || 10, k || 'be')))
              }
              var u
              ;(typeof s == 'object' ? (s.exports = c) : ((void 0).BN = c),
                (c.BN = c),
                (c.wordSize = 26))
              try {
                u =
                  typeof window < 'u' && window.Buffer !== void 0
                    ? window.Buffer
                    : t('buffer').Buffer
              } catch {}
              function f(M, R) {
                var k = M.charCodeAt(R)
                return k >= 65 && k <= 70 ? k - 55 : k >= 97 && k <= 102 ? k - 87 : (k - 48) & 15
              }
              function d(M, R, k) {
                var v = f(M, k)
                return (k - 1 >= R && (v |= f(M, k - 1) << 4), v)
              }
              function h(M, R, k, v) {
                for (var x = 0, _ = Math.min(M.length, k), S = R; S < _; S++) {
                  var A = M.charCodeAt(S) - 48
                  ;((x *= v), (x += A >= 49 ? A - 49 + 10 : A >= 17 ? A - 17 + 10 : A))
                }
                return x
              }
              ;((c.isBN = function (M) {
                return (
                  M instanceof c ||
                  (M !== null &&
                    typeof M == 'object' &&
                    M.constructor.wordSize === c.wordSize &&
                    Array.isArray(M.words))
                )
              }),
                (c.max = function (M, R) {
                  return M.cmp(R) > 0 ? M : R
                }),
                (c.min = function (M, R) {
                  return M.cmp(R) < 0 ? M : R
                }),
                (c.prototype._init = function (M, R, k) {
                  if (typeof M == 'number') return this._initNumber(M, R, k)
                  if (typeof M == 'object') return this._initArray(M, R, k)
                  ;(R === 'hex' && (R = 16), a(R === (0 | R) && R >= 2 && R <= 36))
                  var v = 0
                  ;((M = M.toString().replace(/\s+/g, ''))[0] === '-' && (v++, (this.negative = 1)),
                    v < M.length &&
                      (R === 16
                        ? this._parseHex(M, v, k)
                        : (this._parseBase(M, R, v),
                          k === 'le' && this._initArray(this.toArray(), R, k))))
                }),
                (c.prototype._initNumber = function (M, R, k) {
                  ;(M < 0 && ((this.negative = 1), (M = -M)),
                    M < 67108864
                      ? ((this.words = [67108863 & M]), (this.length = 1))
                      : M < 4503599627370496
                        ? ((this.words = [67108863 & M, (M / 67108864) & 67108863]),
                          (this.length = 2))
                        : (a(M < 9007199254740992),
                          (this.words = [67108863 & M, (M / 67108864) & 67108863, 1]),
                          (this.length = 3)),
                    k === 'le' && this._initArray(this.toArray(), R, k))
                }),
                (c.prototype._initArray = function (M, R, k) {
                  if ((a(typeof M.length == 'number'), M.length <= 0))
                    return ((this.words = [0]), (this.length = 1), this)
                  ;((this.length = Math.ceil(M.length / 3)), (this.words = new Array(this.length)))
                  for (var v = 0; v < this.length; v++) this.words[v] = 0
                  var x,
                    _,
                    S = 0
                  if (k === 'be')
                    for (v = M.length - 1, x = 0; v >= 0; v -= 3)
                      ((_ = M[v] | (M[v - 1] << 8) | (M[v - 2] << 16)),
                        (this.words[x] |= (_ << S) & 67108863),
                        (this.words[x + 1] = (_ >>> (26 - S)) & 67108863),
                        (S += 24) >= 26 && ((S -= 26), x++))
                  else if (k === 'le')
                    for (v = 0, x = 0; v < M.length; v += 3)
                      ((_ = M[v] | (M[v + 1] << 8) | (M[v + 2] << 16)),
                        (this.words[x] |= (_ << S) & 67108863),
                        (this.words[x + 1] = (_ >>> (26 - S)) & 67108863),
                        (S += 24) >= 26 && ((S -= 26), x++))
                  return this.strip()
                }),
                (c.prototype._parseHex = function (M, R, k) {
                  ;((this.length = Math.ceil((M.length - R) / 6)),
                    (this.words = new Array(this.length)))
                  for (var v = 0; v < this.length; v++) this.words[v] = 0
                  var x,
                    _ = 0,
                    S = 0
                  if (k === 'be')
                    for (v = M.length - 1; v >= R; v -= 2)
                      ((x = d(M, R, v) << _),
                        (this.words[S] |= 67108863 & x),
                        _ >= 18 ? ((_ -= 18), (S += 1), (this.words[S] |= x >>> 26)) : (_ += 8))
                  else
                    for (v = (M.length - R) % 2 == 0 ? R + 1 : R; v < M.length; v += 2)
                      ((x = d(M, R, v) << _),
                        (this.words[S] |= 67108863 & x),
                        _ >= 18 ? ((_ -= 18), (S += 1), (this.words[S] |= x >>> 26)) : (_ += 8))
                  this.strip()
                }),
                (c.prototype._parseBase = function (M, R, k) {
                  ;((this.words = [0]), (this.length = 1))
                  for (var v = 0, x = 1; x <= 67108863; x *= R) v++
                  ;(v--, (x = (x / R) | 0))
                  for (
                    var _ = M.length - k, S = _ % v, A = Math.min(_, _ - S) + k, j = 0, L = k;
                    L < A;
                    L += v
                  )
                    ((j = h(M, L, L + v, R)),
                      this.imuln(x),
                      this.words[0] + j < 67108864 ? (this.words[0] += j) : this._iaddn(j))
                  if (S !== 0) {
                    var H = 1
                    for (j = h(M, L, M.length, R), L = 0; L < S; L++) H *= R
                    ;(this.imuln(H),
                      this.words[0] + j < 67108864 ? (this.words[0] += j) : this._iaddn(j))
                  }
                  this.strip()
                }),
                (c.prototype.copy = function (M) {
                  M.words = new Array(this.length)
                  for (var R = 0; R < this.length; R++) M.words[R] = this.words[R]
                  ;((M.length = this.length), (M.negative = this.negative), (M.red = this.red))
                }),
                (c.prototype.clone = function () {
                  var M = new c(null)
                  return (this.copy(M), M)
                }),
                (c.prototype._expand = function (M) {
                  for (; this.length < M; ) this.words[this.length++] = 0
                  return this
                }),
                (c.prototype.strip = function () {
                  for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
                  return this._normSign()
                }),
                (c.prototype._normSign = function () {
                  return (this.length === 1 && this.words[0] === 0 && (this.negative = 0), this)
                }),
                (c.prototype.inspect = function () {
                  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'
                }))
              var p = [
                  '',
                  '0',
                  '00',
                  '000',
                  '0000',
                  '00000',
                  '000000',
                  '0000000',
                  '00000000',
                  '000000000',
                  '0000000000',
                  '00000000000',
                  '000000000000',
                  '0000000000000',
                  '00000000000000',
                  '000000000000000',
                  '0000000000000000',
                  '00000000000000000',
                  '000000000000000000',
                  '0000000000000000000',
                  '00000000000000000000',
                  '000000000000000000000',
                  '0000000000000000000000',
                  '00000000000000000000000',
                  '000000000000000000000000',
                  '0000000000000000000000000',
                ],
                g = [
                  0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5,
                  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                m = [
                  0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
                  43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216,
                  24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625,
                  11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393,
                  45435424, 52521875, 60466176,
                ]
              function y(M, R, k) {
                k.negative = R.negative ^ M.negative
                var v = (M.length + R.length) | 0
                ;((k.length = v), (v = (v - 1) | 0))
                var x = 0 | M.words[0],
                  _ = 0 | R.words[0],
                  S = x * _,
                  A = 67108863 & S,
                  j = (S / 67108864) | 0
                k.words[0] = A
                for (var L = 1; L < v; L++) {
                  for (
                    var H = j >>> 26,
                      U = 67108863 & j,
                      K = Math.min(L, R.length - 1),
                      z = Math.max(0, L - M.length + 1);
                    z <= K;
                    z++
                  ) {
                    var q = (L - z) | 0
                    ;((H += ((S = (x = 0 | M.words[q]) * (_ = 0 | R.words[z]) + U) / 67108864) | 0),
                      (U = 67108863 & S))
                  }
                  ;((k.words[L] = 0 | U), (j = 0 | H))
                }
                return (j !== 0 ? (k.words[L] = 0 | j) : k.length--, k.strip())
              }
              ;((c.prototype.toString = function (M, R) {
                var k
                if (((R = 0 | R || 1), (M = M || 10) === 16 || M === 'hex')) {
                  k = ''
                  for (var v = 0, x = 0, _ = 0; _ < this.length; _++) {
                    var S = this.words[_],
                      A = (16777215 & ((S << v) | x)).toString(16)
                    ;((k =
                      (x = (S >>> (24 - v)) & 16777215) !== 0 || _ !== this.length - 1
                        ? p[6 - A.length] + A + k
                        : A + k),
                      (v += 2) >= 26 && ((v -= 26), _--))
                  }
                  for (x !== 0 && (k = x.toString(16) + k); k.length % R != 0; ) k = '0' + k
                  return (this.negative !== 0 && (k = '-' + k), k)
                }
                if (M === (0 | M) && M >= 2 && M <= 36) {
                  var j = g[M],
                    L = m[M]
                  k = ''
                  var H = this.clone()
                  for (H.negative = 0; !H.isZero(); ) {
                    var U = H.modn(L).toString(M)
                    k = (H = H.idivn(L)).isZero() ? U + k : p[j - U.length] + U + k
                  }
                  for (this.isZero() && (k = '0' + k); k.length % R != 0; ) k = '0' + k
                  return (this.negative !== 0 && (k = '-' + k), k)
                }
                a(!1, 'Base should be between 2 and 36')
              }),
                (c.prototype.toNumber = function () {
                  var M = this.words[0]
                  return (
                    this.length === 2
                      ? (M += 67108864 * this.words[1])
                      : this.length === 3 && this.words[2] === 1
                        ? (M += 4503599627370496 + 67108864 * this.words[1])
                        : this.length > 2 && a(!1, 'Number can only safely store up to 53 bits'),
                    this.negative !== 0 ? -M : M
                  )
                }),
                (c.prototype.toJSON = function () {
                  return this.toString(16)
                }),
                (c.prototype.toBuffer = function (M, R) {
                  return (a(u !== void 0), this.toArrayLike(u, M, R))
                }),
                (c.prototype.toArray = function (M, R) {
                  return this.toArrayLike(Array, M, R)
                }),
                (c.prototype.toArrayLike = function (M, R, k) {
                  var v = this.byteLength(),
                    x = k || Math.max(1, v)
                  ;(a(v <= x, 'byte array longer than desired length'),
                    a(x > 0, 'Requested array length <= 0'),
                    this.strip())
                  var _,
                    S,
                    A = R === 'le',
                    j = new M(x),
                    L = this.clone()
                  if (A) {
                    for (S = 0; !L.isZero(); S++) ((_ = L.andln(255)), L.iushrn(8), (j[S] = _))
                    for (; S < x; S++) j[S] = 0
                  } else {
                    for (S = 0; S < x - v; S++) j[S] = 0
                    for (S = 0; !L.isZero(); S++)
                      ((_ = L.andln(255)), L.iushrn(8), (j[x - S - 1] = _))
                  }
                  return j
                }),
                Math.clz32
                  ? (c.prototype._countBits = function (M) {
                      return 32 - Math.clz32(M)
                    })
                  : (c.prototype._countBits = function (M) {
                      var R = M,
                        k = 0
                      return (
                        R >= 4096 && ((k += 13), (R >>>= 13)),
                        R >= 64 && ((k += 7), (R >>>= 7)),
                        R >= 8 && ((k += 4), (R >>>= 4)),
                        R >= 2 && ((k += 2), (R >>>= 2)),
                        k + R
                      )
                    }),
                (c.prototype._zeroBits = function (M) {
                  if (M === 0) return 26
                  var R = M,
                    k = 0
                  return (
                    !(8191 & R) && ((k += 13), (R >>>= 13)),
                    !(127 & R) && ((k += 7), (R >>>= 7)),
                    !(15 & R) && ((k += 4), (R >>>= 4)),
                    !(3 & R) && ((k += 2), (R >>>= 2)),
                    !(1 & R) && k++,
                    k
                  )
                }),
                (c.prototype.bitLength = function () {
                  var M = this.words[this.length - 1],
                    R = this._countBits(M)
                  return 26 * (this.length - 1) + R
                }),
                (c.prototype.zeroBits = function () {
                  if (this.isZero()) return 0
                  for (var M = 0, R = 0; R < this.length; R++) {
                    var k = this._zeroBits(this.words[R])
                    if (((M += k), k !== 26)) break
                  }
                  return M
                }),
                (c.prototype.byteLength = function () {
                  return Math.ceil(this.bitLength() / 8)
                }),
                (c.prototype.toTwos = function (M) {
                  return this.negative !== 0 ? this.abs().inotn(M).iaddn(1) : this.clone()
                }),
                (c.prototype.fromTwos = function (M) {
                  return this.testn(M - 1) ? this.notn(M).iaddn(1).ineg() : this.clone()
                }),
                (c.prototype.isNeg = function () {
                  return this.negative !== 0
                }),
                (c.prototype.neg = function () {
                  return this.clone().ineg()
                }),
                (c.prototype.ineg = function () {
                  return (this.isZero() || (this.negative ^= 1), this)
                }),
                (c.prototype.iuor = function (M) {
                  for (; this.length < M.length; ) this.words[this.length++] = 0
                  for (var R = 0; R < M.length; R++) this.words[R] = this.words[R] | M.words[R]
                  return this.strip()
                }),
                (c.prototype.ior = function (M) {
                  return (a((this.negative | M.negative) == 0), this.iuor(M))
                }),
                (c.prototype.or = function (M) {
                  return this.length > M.length ? this.clone().ior(M) : M.clone().ior(this)
                }),
                (c.prototype.uor = function (M) {
                  return this.length > M.length ? this.clone().iuor(M) : M.clone().iuor(this)
                }),
                (c.prototype.iuand = function (M) {
                  var R
                  R = this.length > M.length ? M : this
                  for (var k = 0; k < R.length; k++) this.words[k] = this.words[k] & M.words[k]
                  return ((this.length = R.length), this.strip())
                }),
                (c.prototype.iand = function (M) {
                  return (a((this.negative | M.negative) == 0), this.iuand(M))
                }),
                (c.prototype.and = function (M) {
                  return this.length > M.length ? this.clone().iand(M) : M.clone().iand(this)
                }),
                (c.prototype.uand = function (M) {
                  return this.length > M.length ? this.clone().iuand(M) : M.clone().iuand(this)
                }),
                (c.prototype.iuxor = function (M) {
                  var R, k
                  this.length > M.length ? ((R = this), (k = M)) : ((R = M), (k = this))
                  for (var v = 0; v < k.length; v++) this.words[v] = R.words[v] ^ k.words[v]
                  if (this !== R) for (; v < R.length; v++) this.words[v] = R.words[v]
                  return ((this.length = R.length), this.strip())
                }),
                (c.prototype.ixor = function (M) {
                  return (a((this.negative | M.negative) == 0), this.iuxor(M))
                }),
                (c.prototype.xor = function (M) {
                  return this.length > M.length ? this.clone().ixor(M) : M.clone().ixor(this)
                }),
                (c.prototype.uxor = function (M) {
                  return this.length > M.length ? this.clone().iuxor(M) : M.clone().iuxor(this)
                }),
                (c.prototype.inotn = function (M) {
                  a(typeof M == 'number' && M >= 0)
                  var R = 0 | Math.ceil(M / 26),
                    k = M % 26
                  ;(this._expand(R), k > 0 && R--)
                  for (var v = 0; v < R; v++) this.words[v] = 67108863 & ~this.words[v]
                  return (
                    k > 0 && (this.words[v] = ~this.words[v] & (67108863 >> (26 - k))),
                    this.strip()
                  )
                }),
                (c.prototype.notn = function (M) {
                  return this.clone().inotn(M)
                }),
                (c.prototype.setn = function (M, R) {
                  a(typeof M == 'number' && M >= 0)
                  var k = (M / 26) | 0,
                    v = M % 26
                  return (
                    this._expand(k + 1),
                    (this.words[k] = R ? this.words[k] | (1 << v) : this.words[k] & ~(1 << v)),
                    this.strip()
                  )
                }),
                (c.prototype.iadd = function (M) {
                  var R, k, v
                  if (this.negative !== 0 && M.negative === 0)
                    return (
                      (this.negative = 0),
                      (R = this.isub(M)),
                      (this.negative ^= 1),
                      this._normSign()
                    )
                  if (this.negative === 0 && M.negative !== 0)
                    return ((M.negative = 0), (R = this.isub(M)), (M.negative = 1), R._normSign())
                  this.length > M.length ? ((k = this), (v = M)) : ((k = M), (v = this))
                  for (var x = 0, _ = 0; _ < v.length; _++)
                    ((R = (0 | k.words[_]) + (0 | v.words[_]) + x),
                      (this.words[_] = 67108863 & R),
                      (x = R >>> 26))
                  for (; x !== 0 && _ < k.length; _++)
                    ((R = (0 | k.words[_]) + x), (this.words[_] = 67108863 & R), (x = R >>> 26))
                  if (((this.length = k.length), x !== 0))
                    ((this.words[this.length] = x), this.length++)
                  else if (k !== this) for (; _ < k.length; _++) this.words[_] = k.words[_]
                  return this
                }),
                (c.prototype.add = function (M) {
                  var R
                  return M.negative !== 0 && this.negative === 0
                    ? ((M.negative = 0), (R = this.sub(M)), (M.negative ^= 1), R)
                    : M.negative === 0 && this.negative !== 0
                      ? ((this.negative = 0), (R = M.sub(this)), (this.negative = 1), R)
                      : this.length > M.length
                        ? this.clone().iadd(M)
                        : M.clone().iadd(this)
                }),
                (c.prototype.isub = function (M) {
                  if (M.negative !== 0) {
                    M.negative = 0
                    var R = this.iadd(M)
                    return ((M.negative = 1), R._normSign())
                  }
                  if (this.negative !== 0)
                    return (
                      (this.negative = 0),
                      this.iadd(M),
                      (this.negative = 1),
                      this._normSign()
                    )
                  var k,
                    v,
                    x = this.cmp(M)
                  if (x === 0)
                    return ((this.negative = 0), (this.length = 1), (this.words[0] = 0), this)
                  x > 0 ? ((k = this), (v = M)) : ((k = M), (v = this))
                  for (var _ = 0, S = 0; S < v.length; S++)
                    ((_ = (R = (0 | k.words[S]) - (0 | v.words[S]) + _) >> 26),
                      (this.words[S] = 67108863 & R))
                  for (; _ !== 0 && S < k.length; S++)
                    ((_ = (R = (0 | k.words[S]) + _) >> 26), (this.words[S] = 67108863 & R))
                  if (_ === 0 && S < k.length && k !== this)
                    for (; S < k.length; S++) this.words[S] = k.words[S]
                  return (
                    (this.length = Math.max(this.length, S)),
                    k !== this && (this.negative = 1),
                    this.strip()
                  )
                }),
                (c.prototype.sub = function (M) {
                  return this.clone().isub(M)
                }))
              var b = function (M, R, k) {
                var v,
                  x,
                  _,
                  S = M.words,
                  A = R.words,
                  j = k.words,
                  L = 0,
                  H = 0 | S[0],
                  U = 8191 & H,
                  K = H >>> 13,
                  z = 0 | S[1],
                  q = 8191 & z,
                  D = z >>> 13,
                  N = 0 | S[2],
                  V = 8191 & N,
                  W = N >>> 13,
                  J = 0 | S[3],
                  G = 8191 & J,
                  Z = J >>> 13,
                  rt = 0 | S[4],
                  nt = 8191 & rt,
                  X = rt >>> 13,
                  Q = 0 | S[5],
                  tt = 8191 & Q,
                  st = Q >>> 13,
                  ot = 0 | S[6],
                  at = 8191 & ot,
                  ht = ot >>> 13,
                  dt = 0 | S[7],
                  mt = 8191 & dt,
                  bt = dt >>> 13,
                  yt = 0 | S[8],
                  vt = 8191 & yt,
                  Nt = yt >>> 13,
                  Dt = 0 | S[9],
                  Mt = 8191 & Dt,
                  Ot = Dt >>> 13,
                  Ct = 0 | A[0],
                  xt = 8191 & Ct,
                  Rt = Ct >>> 13,
                  It = 0 | A[1],
                  Pt = 8191 & It,
                  ae = It >>> 13,
                  Se = 0 | A[2],
                  zt = 8191 & Se,
                  be = Se >>> 13,
                  Ut = 0 | A[3],
                  Lt = 8191 & Ut,
                  le = Ut >>> 13,
                  ce = 0 | A[4],
                  Ft = 8191 & ce,
                  Qt = ce >>> 13,
                  fe = 0 | A[5],
                  qt = 8191 & fe,
                  Jt = fe >>> 13,
                  me = 0 | A[6],
                  Wt = 8191 & me,
                  it = me >>> 13,
                  ct = 0 | A[7],
                  pt = 8191 & ct,
                  _t = ct >>> 13,
                  Vt = 0 | A[8],
                  Tt = 8191 & Vt,
                  te = Vt >>> 13,
                  Gt = 0 | A[9],
                  Ht = 8191 & Gt,
                  ie = Gt >>> 13
                ;((k.negative = M.negative ^ R.negative), (k.length = 19))
                var ee =
                  (((L + (v = Math.imul(U, xt))) | 0) +
                    ((8191 & (x = ((x = Math.imul(U, Rt)) + Math.imul(K, xt)) | 0)) << 13)) |
                  0
                ;((L = ((((_ = Math.imul(K, Rt)) + (x >>> 13)) | 0) + (ee >>> 26)) | 0),
                  (ee &= 67108863),
                  (v = Math.imul(q, xt)),
                  (x = ((x = Math.imul(q, Rt)) + Math.imul(D, xt)) | 0),
                  (_ = Math.imul(D, Rt)))
                var de =
                  (((L + (v = (v + Math.imul(U, Pt)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, ae)) | 0) + Math.imul(K, Pt)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, ae)) | 0) + (x >>> 13)) | 0) + (de >>> 26)) | 0),
                  (de &= 67108863),
                  (v = Math.imul(V, xt)),
                  (x = ((x = Math.imul(V, Rt)) + Math.imul(W, xt)) | 0),
                  (_ = Math.imul(W, Rt)),
                  (v = (v + Math.imul(q, Pt)) | 0),
                  (x = ((x = (x + Math.imul(q, ae)) | 0) + Math.imul(D, Pt)) | 0),
                  (_ = (_ + Math.imul(D, ae)) | 0))
                var Le =
                  (((L + (v = (v + Math.imul(U, zt)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, be)) | 0) + Math.imul(K, zt)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, be)) | 0) + (x >>> 13)) | 0) + (Le >>> 26)) | 0),
                  (Le &= 67108863),
                  (v = Math.imul(G, xt)),
                  (x = ((x = Math.imul(G, Rt)) + Math.imul(Z, xt)) | 0),
                  (_ = Math.imul(Z, Rt)),
                  (v = (v + Math.imul(V, Pt)) | 0),
                  (x = ((x = (x + Math.imul(V, ae)) | 0) + Math.imul(W, Pt)) | 0),
                  (_ = (_ + Math.imul(W, ae)) | 0),
                  (v = (v + Math.imul(q, zt)) | 0),
                  (x = ((x = (x + Math.imul(q, be)) | 0) + Math.imul(D, zt)) | 0),
                  (_ = (_ + Math.imul(D, be)) | 0))
                var Te =
                  (((L + (v = (v + Math.imul(U, Lt)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, le)) | 0) + Math.imul(K, Lt)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, le)) | 0) + (x >>> 13)) | 0) + (Te >>> 26)) | 0),
                  (Te &= 67108863),
                  (v = Math.imul(nt, xt)),
                  (x = ((x = Math.imul(nt, Rt)) + Math.imul(X, xt)) | 0),
                  (_ = Math.imul(X, Rt)),
                  (v = (v + Math.imul(G, Pt)) | 0),
                  (x = ((x = (x + Math.imul(G, ae)) | 0) + Math.imul(Z, Pt)) | 0),
                  (_ = (_ + Math.imul(Z, ae)) | 0),
                  (v = (v + Math.imul(V, zt)) | 0),
                  (x = ((x = (x + Math.imul(V, be)) | 0) + Math.imul(W, zt)) | 0),
                  (_ = (_ + Math.imul(W, be)) | 0),
                  (v = (v + Math.imul(q, Lt)) | 0),
                  (x = ((x = (x + Math.imul(q, le)) | 0) + Math.imul(D, Lt)) | 0),
                  (_ = (_ + Math.imul(D, le)) | 0))
                var Ge =
                  (((L + (v = (v + Math.imul(U, Ft)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, Qt)) | 0) + Math.imul(K, Ft)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, Qt)) | 0) + (x >>> 13)) | 0) + (Ge >>> 26)) | 0),
                  (Ge &= 67108863),
                  (v = Math.imul(tt, xt)),
                  (x = ((x = Math.imul(tt, Rt)) + Math.imul(st, xt)) | 0),
                  (_ = Math.imul(st, Rt)),
                  (v = (v + Math.imul(nt, Pt)) | 0),
                  (x = ((x = (x + Math.imul(nt, ae)) | 0) + Math.imul(X, Pt)) | 0),
                  (_ = (_ + Math.imul(X, ae)) | 0),
                  (v = (v + Math.imul(G, zt)) | 0),
                  (x = ((x = (x + Math.imul(G, be)) | 0) + Math.imul(Z, zt)) | 0),
                  (_ = (_ + Math.imul(Z, be)) | 0),
                  (v = (v + Math.imul(V, Lt)) | 0),
                  (x = ((x = (x + Math.imul(V, le)) | 0) + Math.imul(W, Lt)) | 0),
                  (_ = (_ + Math.imul(W, le)) | 0),
                  (v = (v + Math.imul(q, Ft)) | 0),
                  (x = ((x = (x + Math.imul(q, Qt)) | 0) + Math.imul(D, Ft)) | 0),
                  (_ = (_ + Math.imul(D, Qt)) | 0))
                var Xe =
                  (((L + (v = (v + Math.imul(U, qt)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, Jt)) | 0) + Math.imul(K, qt)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, Jt)) | 0) + (x >>> 13)) | 0) + (Xe >>> 26)) | 0),
                  (Xe &= 67108863),
                  (v = Math.imul(at, xt)),
                  (x = ((x = Math.imul(at, Rt)) + Math.imul(ht, xt)) | 0),
                  (_ = Math.imul(ht, Rt)),
                  (v = (v + Math.imul(tt, Pt)) | 0),
                  (x = ((x = (x + Math.imul(tt, ae)) | 0) + Math.imul(st, Pt)) | 0),
                  (_ = (_ + Math.imul(st, ae)) | 0),
                  (v = (v + Math.imul(nt, zt)) | 0),
                  (x = ((x = (x + Math.imul(nt, be)) | 0) + Math.imul(X, zt)) | 0),
                  (_ = (_ + Math.imul(X, be)) | 0),
                  (v = (v + Math.imul(G, Lt)) | 0),
                  (x = ((x = (x + Math.imul(G, le)) | 0) + Math.imul(Z, Lt)) | 0),
                  (_ = (_ + Math.imul(Z, le)) | 0),
                  (v = (v + Math.imul(V, Ft)) | 0),
                  (x = ((x = (x + Math.imul(V, Qt)) | 0) + Math.imul(W, Ft)) | 0),
                  (_ = (_ + Math.imul(W, Qt)) | 0),
                  (v = (v + Math.imul(q, qt)) | 0),
                  (x = ((x = (x + Math.imul(q, Jt)) | 0) + Math.imul(D, qt)) | 0),
                  (_ = (_ + Math.imul(D, Jt)) | 0))
                var pn =
                  (((L + (v = (v + Math.imul(U, Wt)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, it)) | 0) + Math.imul(K, Wt)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, it)) | 0) + (x >>> 13)) | 0) + (pn >>> 26)) | 0),
                  (pn &= 67108863),
                  (v = Math.imul(mt, xt)),
                  (x = ((x = Math.imul(mt, Rt)) + Math.imul(bt, xt)) | 0),
                  (_ = Math.imul(bt, Rt)),
                  (v = (v + Math.imul(at, Pt)) | 0),
                  (x = ((x = (x + Math.imul(at, ae)) | 0) + Math.imul(ht, Pt)) | 0),
                  (_ = (_ + Math.imul(ht, ae)) | 0),
                  (v = (v + Math.imul(tt, zt)) | 0),
                  (x = ((x = (x + Math.imul(tt, be)) | 0) + Math.imul(st, zt)) | 0),
                  (_ = (_ + Math.imul(st, be)) | 0),
                  (v = (v + Math.imul(nt, Lt)) | 0),
                  (x = ((x = (x + Math.imul(nt, le)) | 0) + Math.imul(X, Lt)) | 0),
                  (_ = (_ + Math.imul(X, le)) | 0),
                  (v = (v + Math.imul(G, Ft)) | 0),
                  (x = ((x = (x + Math.imul(G, Qt)) | 0) + Math.imul(Z, Ft)) | 0),
                  (_ = (_ + Math.imul(Z, Qt)) | 0),
                  (v = (v + Math.imul(V, qt)) | 0),
                  (x = ((x = (x + Math.imul(V, Jt)) | 0) + Math.imul(W, qt)) | 0),
                  (_ = (_ + Math.imul(W, Jt)) | 0),
                  (v = (v + Math.imul(q, Wt)) | 0),
                  (x = ((x = (x + Math.imul(q, it)) | 0) + Math.imul(D, Wt)) | 0),
                  (_ = (_ + Math.imul(D, it)) | 0))
                var et =
                  (((L + (v = (v + Math.imul(U, pt)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, _t)) | 0) + Math.imul(K, pt)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, _t)) | 0) + (x >>> 13)) | 0) + (et >>> 26)) | 0),
                  (et &= 67108863),
                  (v = Math.imul(vt, xt)),
                  (x = ((x = Math.imul(vt, Rt)) + Math.imul(Nt, xt)) | 0),
                  (_ = Math.imul(Nt, Rt)),
                  (v = (v + Math.imul(mt, Pt)) | 0),
                  (x = ((x = (x + Math.imul(mt, ae)) | 0) + Math.imul(bt, Pt)) | 0),
                  (_ = (_ + Math.imul(bt, ae)) | 0),
                  (v = (v + Math.imul(at, zt)) | 0),
                  (x = ((x = (x + Math.imul(at, be)) | 0) + Math.imul(ht, zt)) | 0),
                  (_ = (_ + Math.imul(ht, be)) | 0),
                  (v = (v + Math.imul(tt, Lt)) | 0),
                  (x = ((x = (x + Math.imul(tt, le)) | 0) + Math.imul(st, Lt)) | 0),
                  (_ = (_ + Math.imul(st, le)) | 0),
                  (v = (v + Math.imul(nt, Ft)) | 0),
                  (x = ((x = (x + Math.imul(nt, Qt)) | 0) + Math.imul(X, Ft)) | 0),
                  (_ = (_ + Math.imul(X, Qt)) | 0),
                  (v = (v + Math.imul(G, qt)) | 0),
                  (x = ((x = (x + Math.imul(G, Jt)) | 0) + Math.imul(Z, qt)) | 0),
                  (_ = (_ + Math.imul(Z, Jt)) | 0),
                  (v = (v + Math.imul(V, Wt)) | 0),
                  (x = ((x = (x + Math.imul(V, it)) | 0) + Math.imul(W, Wt)) | 0),
                  (_ = (_ + Math.imul(W, it)) | 0),
                  (v = (v + Math.imul(q, pt)) | 0),
                  (x = ((x = (x + Math.imul(q, _t)) | 0) + Math.imul(D, pt)) | 0),
                  (_ = (_ + Math.imul(D, _t)) | 0))
                var ft =
                  (((L + (v = (v + Math.imul(U, Tt)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, te)) | 0) + Math.imul(K, Tt)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, te)) | 0) + (x >>> 13)) | 0) + (ft >>> 26)) | 0),
                  (ft &= 67108863),
                  (v = Math.imul(Mt, xt)),
                  (x = ((x = Math.imul(Mt, Rt)) + Math.imul(Ot, xt)) | 0),
                  (_ = Math.imul(Ot, Rt)),
                  (v = (v + Math.imul(vt, Pt)) | 0),
                  (x = ((x = (x + Math.imul(vt, ae)) | 0) + Math.imul(Nt, Pt)) | 0),
                  (_ = (_ + Math.imul(Nt, ae)) | 0),
                  (v = (v + Math.imul(mt, zt)) | 0),
                  (x = ((x = (x + Math.imul(mt, be)) | 0) + Math.imul(bt, zt)) | 0),
                  (_ = (_ + Math.imul(bt, be)) | 0),
                  (v = (v + Math.imul(at, Lt)) | 0),
                  (x = ((x = (x + Math.imul(at, le)) | 0) + Math.imul(ht, Lt)) | 0),
                  (_ = (_ + Math.imul(ht, le)) | 0),
                  (v = (v + Math.imul(tt, Ft)) | 0),
                  (x = ((x = (x + Math.imul(tt, Qt)) | 0) + Math.imul(st, Ft)) | 0),
                  (_ = (_ + Math.imul(st, Qt)) | 0),
                  (v = (v + Math.imul(nt, qt)) | 0),
                  (x = ((x = (x + Math.imul(nt, Jt)) | 0) + Math.imul(X, qt)) | 0),
                  (_ = (_ + Math.imul(X, Jt)) | 0),
                  (v = (v + Math.imul(G, Wt)) | 0),
                  (x = ((x = (x + Math.imul(G, it)) | 0) + Math.imul(Z, Wt)) | 0),
                  (_ = (_ + Math.imul(Z, it)) | 0),
                  (v = (v + Math.imul(V, pt)) | 0),
                  (x = ((x = (x + Math.imul(V, _t)) | 0) + Math.imul(W, pt)) | 0),
                  (_ = (_ + Math.imul(W, _t)) | 0),
                  (v = (v + Math.imul(q, Tt)) | 0),
                  (x = ((x = (x + Math.imul(q, te)) | 0) + Math.imul(D, Tt)) | 0),
                  (_ = (_ + Math.imul(D, te)) | 0))
                var gt =
                  (((L + (v = (v + Math.imul(U, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(U, ie)) | 0) + Math.imul(K, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(K, ie)) | 0) + (x >>> 13)) | 0) + (gt >>> 26)) | 0),
                  (gt &= 67108863),
                  (v = Math.imul(Mt, Pt)),
                  (x = ((x = Math.imul(Mt, ae)) + Math.imul(Ot, Pt)) | 0),
                  (_ = Math.imul(Ot, ae)),
                  (v = (v + Math.imul(vt, zt)) | 0),
                  (x = ((x = (x + Math.imul(vt, be)) | 0) + Math.imul(Nt, zt)) | 0),
                  (_ = (_ + Math.imul(Nt, be)) | 0),
                  (v = (v + Math.imul(mt, Lt)) | 0),
                  (x = ((x = (x + Math.imul(mt, le)) | 0) + Math.imul(bt, Lt)) | 0),
                  (_ = (_ + Math.imul(bt, le)) | 0),
                  (v = (v + Math.imul(at, Ft)) | 0),
                  (x = ((x = (x + Math.imul(at, Qt)) | 0) + Math.imul(ht, Ft)) | 0),
                  (_ = (_ + Math.imul(ht, Qt)) | 0),
                  (v = (v + Math.imul(tt, qt)) | 0),
                  (x = ((x = (x + Math.imul(tt, Jt)) | 0) + Math.imul(st, qt)) | 0),
                  (_ = (_ + Math.imul(st, Jt)) | 0),
                  (v = (v + Math.imul(nt, Wt)) | 0),
                  (x = ((x = (x + Math.imul(nt, it)) | 0) + Math.imul(X, Wt)) | 0),
                  (_ = (_ + Math.imul(X, it)) | 0),
                  (v = (v + Math.imul(G, pt)) | 0),
                  (x = ((x = (x + Math.imul(G, _t)) | 0) + Math.imul(Z, pt)) | 0),
                  (_ = (_ + Math.imul(Z, _t)) | 0),
                  (v = (v + Math.imul(V, Tt)) | 0),
                  (x = ((x = (x + Math.imul(V, te)) | 0) + Math.imul(W, Tt)) | 0),
                  (_ = (_ + Math.imul(W, te)) | 0))
                var wt =
                  (((L + (v = (v + Math.imul(q, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(q, ie)) | 0) + Math.imul(D, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(D, ie)) | 0) + (x >>> 13)) | 0) + (wt >>> 26)) | 0),
                  (wt &= 67108863),
                  (v = Math.imul(Mt, zt)),
                  (x = ((x = Math.imul(Mt, be)) + Math.imul(Ot, zt)) | 0),
                  (_ = Math.imul(Ot, be)),
                  (v = (v + Math.imul(vt, Lt)) | 0),
                  (x = ((x = (x + Math.imul(vt, le)) | 0) + Math.imul(Nt, Lt)) | 0),
                  (_ = (_ + Math.imul(Nt, le)) | 0),
                  (v = (v + Math.imul(mt, Ft)) | 0),
                  (x = ((x = (x + Math.imul(mt, Qt)) | 0) + Math.imul(bt, Ft)) | 0),
                  (_ = (_ + Math.imul(bt, Qt)) | 0),
                  (v = (v + Math.imul(at, qt)) | 0),
                  (x = ((x = (x + Math.imul(at, Jt)) | 0) + Math.imul(ht, qt)) | 0),
                  (_ = (_ + Math.imul(ht, Jt)) | 0),
                  (v = (v + Math.imul(tt, Wt)) | 0),
                  (x = ((x = (x + Math.imul(tt, it)) | 0) + Math.imul(st, Wt)) | 0),
                  (_ = (_ + Math.imul(st, it)) | 0),
                  (v = (v + Math.imul(nt, pt)) | 0),
                  (x = ((x = (x + Math.imul(nt, _t)) | 0) + Math.imul(X, pt)) | 0),
                  (_ = (_ + Math.imul(X, _t)) | 0),
                  (v = (v + Math.imul(G, Tt)) | 0),
                  (x = ((x = (x + Math.imul(G, te)) | 0) + Math.imul(Z, Tt)) | 0),
                  (_ = (_ + Math.imul(Z, te)) | 0))
                var $t =
                  (((L + (v = (v + Math.imul(V, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(V, ie)) | 0) + Math.imul(W, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(W, ie)) | 0) + (x >>> 13)) | 0) + ($t >>> 26)) | 0),
                  ($t &= 67108863),
                  (v = Math.imul(Mt, Lt)),
                  (x = ((x = Math.imul(Mt, le)) + Math.imul(Ot, Lt)) | 0),
                  (_ = Math.imul(Ot, le)),
                  (v = (v + Math.imul(vt, Ft)) | 0),
                  (x = ((x = (x + Math.imul(vt, Qt)) | 0) + Math.imul(Nt, Ft)) | 0),
                  (_ = (_ + Math.imul(Nt, Qt)) | 0),
                  (v = (v + Math.imul(mt, qt)) | 0),
                  (x = ((x = (x + Math.imul(mt, Jt)) | 0) + Math.imul(bt, qt)) | 0),
                  (_ = (_ + Math.imul(bt, Jt)) | 0),
                  (v = (v + Math.imul(at, Wt)) | 0),
                  (x = ((x = (x + Math.imul(at, it)) | 0) + Math.imul(ht, Wt)) | 0),
                  (_ = (_ + Math.imul(ht, it)) | 0),
                  (v = (v + Math.imul(tt, pt)) | 0),
                  (x = ((x = (x + Math.imul(tt, _t)) | 0) + Math.imul(st, pt)) | 0),
                  (_ = (_ + Math.imul(st, _t)) | 0),
                  (v = (v + Math.imul(nt, Tt)) | 0),
                  (x = ((x = (x + Math.imul(nt, te)) | 0) + Math.imul(X, Tt)) | 0),
                  (_ = (_ + Math.imul(X, te)) | 0))
                var Et =
                  (((L + (v = (v + Math.imul(G, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(G, ie)) | 0) + Math.imul(Z, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(Z, ie)) | 0) + (x >>> 13)) | 0) + (Et >>> 26)) | 0),
                  (Et &= 67108863),
                  (v = Math.imul(Mt, Ft)),
                  (x = ((x = Math.imul(Mt, Qt)) + Math.imul(Ot, Ft)) | 0),
                  (_ = Math.imul(Ot, Qt)),
                  (v = (v + Math.imul(vt, qt)) | 0),
                  (x = ((x = (x + Math.imul(vt, Jt)) | 0) + Math.imul(Nt, qt)) | 0),
                  (_ = (_ + Math.imul(Nt, Jt)) | 0),
                  (v = (v + Math.imul(mt, Wt)) | 0),
                  (x = ((x = (x + Math.imul(mt, it)) | 0) + Math.imul(bt, Wt)) | 0),
                  (_ = (_ + Math.imul(bt, it)) | 0),
                  (v = (v + Math.imul(at, pt)) | 0),
                  (x = ((x = (x + Math.imul(at, _t)) | 0) + Math.imul(ht, pt)) | 0),
                  (_ = (_ + Math.imul(ht, _t)) | 0),
                  (v = (v + Math.imul(tt, Tt)) | 0),
                  (x = ((x = (x + Math.imul(tt, te)) | 0) + Math.imul(st, Tt)) | 0),
                  (_ = (_ + Math.imul(st, te)) | 0))
                var At =
                  (((L + (v = (v + Math.imul(nt, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(nt, ie)) | 0) + Math.imul(X, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(X, ie)) | 0) + (x >>> 13)) | 0) + (At >>> 26)) | 0),
                  (At &= 67108863),
                  (v = Math.imul(Mt, qt)),
                  (x = ((x = Math.imul(Mt, Jt)) + Math.imul(Ot, qt)) | 0),
                  (_ = Math.imul(Ot, Jt)),
                  (v = (v + Math.imul(vt, Wt)) | 0),
                  (x = ((x = (x + Math.imul(vt, it)) | 0) + Math.imul(Nt, Wt)) | 0),
                  (_ = (_ + Math.imul(Nt, it)) | 0),
                  (v = (v + Math.imul(mt, pt)) | 0),
                  (x = ((x = (x + Math.imul(mt, _t)) | 0) + Math.imul(bt, pt)) | 0),
                  (_ = (_ + Math.imul(bt, _t)) | 0),
                  (v = (v + Math.imul(at, Tt)) | 0),
                  (x = ((x = (x + Math.imul(at, te)) | 0) + Math.imul(ht, Tt)) | 0),
                  (_ = (_ + Math.imul(ht, te)) | 0))
                var ve =
                  (((L + (v = (v + Math.imul(tt, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(tt, ie)) | 0) + Math.imul(st, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(st, ie)) | 0) + (x >>> 13)) | 0) + (ve >>> 26)) | 0),
                  (ve &= 67108863),
                  (v = Math.imul(Mt, Wt)),
                  (x = ((x = Math.imul(Mt, it)) + Math.imul(Ot, Wt)) | 0),
                  (_ = Math.imul(Ot, it)),
                  (v = (v + Math.imul(vt, pt)) | 0),
                  (x = ((x = (x + Math.imul(vt, _t)) | 0) + Math.imul(Nt, pt)) | 0),
                  (_ = (_ + Math.imul(Nt, _t)) | 0),
                  (v = (v + Math.imul(mt, Tt)) | 0),
                  (x = ((x = (x + Math.imul(mt, te)) | 0) + Math.imul(bt, Tt)) | 0),
                  (_ = (_ + Math.imul(bt, te)) | 0))
                var ue =
                  (((L + (v = (v + Math.imul(at, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(at, ie)) | 0) + Math.imul(ht, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(ht, ie)) | 0) + (x >>> 13)) | 0) + (ue >>> 26)) | 0),
                  (ue &= 67108863),
                  (v = Math.imul(Mt, pt)),
                  (x = ((x = Math.imul(Mt, _t)) + Math.imul(Ot, pt)) | 0),
                  (_ = Math.imul(Ot, _t)),
                  (v = (v + Math.imul(vt, Tt)) | 0),
                  (x = ((x = (x + Math.imul(vt, te)) | 0) + Math.imul(Nt, Tt)) | 0),
                  (_ = (_ + Math.imul(Nt, te)) | 0))
                var he =
                  (((L + (v = (v + Math.imul(mt, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(mt, ie)) | 0) + Math.imul(bt, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(bt, ie)) | 0) + (x >>> 13)) | 0) + (he >>> 26)) | 0),
                  (he &= 67108863),
                  (v = Math.imul(Mt, Tt)),
                  (x = ((x = Math.imul(Mt, te)) + Math.imul(Ot, Tt)) | 0),
                  (_ = Math.imul(Ot, te)))
                var Kt =
                  (((L + (v = (v + Math.imul(vt, Ht)) | 0)) | 0) +
                    ((8191 & (x = ((x = (x + Math.imul(vt, ie)) | 0) + Math.imul(Nt, Ht)) | 0)) <<
                      13)) |
                  0
                ;((L = ((((_ = (_ + Math.imul(Nt, ie)) | 0) + (x >>> 13)) | 0) + (Kt >>> 26)) | 0),
                  (Kt &= 67108863))
                var Ce =
                  (((L + (v = Math.imul(Mt, Ht))) | 0) +
                    ((8191 & (x = ((x = Math.imul(Mt, ie)) + Math.imul(Ot, Ht)) | 0)) << 13)) |
                  0
                return (
                  (L = ((((_ = Math.imul(Ot, ie)) + (x >>> 13)) | 0) + (Ce >>> 26)) | 0),
                  (Ce &= 67108863),
                  (j[0] = ee),
                  (j[1] = de),
                  (j[2] = Le),
                  (j[3] = Te),
                  (j[4] = Ge),
                  (j[5] = Xe),
                  (j[6] = pn),
                  (j[7] = et),
                  (j[8] = ft),
                  (j[9] = gt),
                  (j[10] = wt),
                  (j[11] = $t),
                  (j[12] = Et),
                  (j[13] = At),
                  (j[14] = ve),
                  (j[15] = ue),
                  (j[16] = he),
                  (j[17] = Kt),
                  (j[18] = Ce),
                  L !== 0 && ((j[19] = L), k.length++),
                  k
                )
              }
              function w(M, R, k) {
                return new C().mulp(M, R, k)
              }
              function C(M, R) {
                ;((this.x = M), (this.y = R))
              }
              ;(Math.imul || (b = y),
                (c.prototype.mulTo = function (M, R) {
                  var k = this.length + M.length
                  return this.length === 10 && M.length === 10
                    ? b(this, M, R)
                    : k < 63
                      ? y(this, M, R)
                      : k < 1024
                        ? (function (v, x, _) {
                            ;((_.negative = x.negative ^ v.negative),
                              (_.length = v.length + x.length))
                            for (var S = 0, A = 0, j = 0; j < _.length - 1; j++) {
                              var L = A
                              A = 0
                              for (
                                var H = 67108863 & S,
                                  U = Math.min(j, x.length - 1),
                                  K = Math.max(0, j - v.length + 1);
                                K <= U;
                                K++
                              ) {
                                var z = j - K,
                                  q = (0 | v.words[z]) * (0 | x.words[K]),
                                  D = 67108863 & q
                                ;((H = 67108863 & (D = (D + H) | 0)),
                                  (A +=
                                    (L =
                                      ((L = (L + ((q / 67108864) | 0)) | 0) + (D >>> 26)) | 0) >>>
                                    26),
                                  (L &= 67108863))
                              }
                              ;((_.words[j] = H), (S = L), (L = A))
                            }
                            return (S !== 0 ? (_.words[j] = S) : _.length--, _.strip())
                          })(this, M, R)
                        : w(this, M, R)
                }),
                (C.prototype.makeRBT = function (M) {
                  for (var R = new Array(M), k = c.prototype._countBits(M) - 1, v = 0; v < M; v++)
                    R[v] = this.revBin(v, k, M)
                  return R
                }),
                (C.prototype.revBin = function (M, R, k) {
                  if (M === 0 || M === k - 1) return M
                  for (var v = 0, x = 0; x < R; x++) ((v |= (1 & M) << (R - x - 1)), (M >>= 1))
                  return v
                }),
                (C.prototype.permute = function (M, R, k, v, x, _) {
                  for (var S = 0; S < _; S++) ((v[S] = R[M[S]]), (x[S] = k[M[S]]))
                }),
                (C.prototype.transform = function (M, R, k, v, x, _) {
                  this.permute(_, M, R, k, v, x)
                  for (var S = 1; S < x; S <<= 1)
                    for (
                      var A = S << 1,
                        j = Math.cos((2 * Math.PI) / A),
                        L = Math.sin((2 * Math.PI) / A),
                        H = 0;
                      H < x;
                      H += A
                    )
                      for (var U = j, K = L, z = 0; z < S; z++) {
                        var q = k[H + z],
                          D = v[H + z],
                          N = k[H + z + S],
                          V = v[H + z + S],
                          W = U * N - K * V
                        ;((V = U * V + K * N),
                          (N = W),
                          (k[H + z] = q + N),
                          (v[H + z] = D + V),
                          (k[H + z + S] = q - N),
                          (v[H + z + S] = D - V),
                          z !== A && ((W = j * U - L * K), (K = j * K + L * U), (U = W)))
                      }
                }),
                (C.prototype.guessLen13b = function (M, R) {
                  var k = 1 | Math.max(R, M),
                    v = 1 & k,
                    x = 0
                  for (k = (k / 2) | 0; k; k >>>= 1) x++
                  return 1 << (x + 1 + v)
                }),
                (C.prototype.conjugate = function (M, R, k) {
                  if (!(k <= 1))
                    for (var v = 0; v < k / 2; v++) {
                      var x = M[v]
                      ;((M[v] = M[k - v - 1]),
                        (M[k - v - 1] = x),
                        (x = R[v]),
                        (R[v] = -R[k - v - 1]),
                        (R[k - v - 1] = -x))
                    }
                }),
                (C.prototype.normalize13b = function (M, R) {
                  for (var k = 0, v = 0; v < R / 2; v++) {
                    var x = 8192 * Math.round(M[2 * v + 1] / R) + Math.round(M[2 * v] / R) + k
                    ;((M[v] = 67108863 & x), (k = x < 67108864 ? 0 : (x / 67108864) | 0))
                  }
                  return M
                }),
                (C.prototype.convert13b = function (M, R, k, v) {
                  for (var x = 0, _ = 0; _ < R; _++)
                    ((x += 0 | M[_]),
                      (k[2 * _] = 8191 & x),
                      (x >>>= 13),
                      (k[2 * _ + 1] = 8191 & x),
                      (x >>>= 13))
                  for (_ = 2 * R; _ < v; ++_) k[_] = 0
                  ;(a(x === 0), a((-8192 & x) == 0))
                }),
                (C.prototype.stub = function (M) {
                  for (var R = new Array(M), k = 0; k < M; k++) R[k] = 0
                  return R
                }),
                (C.prototype.mulp = function (M, R, k) {
                  var v = 2 * this.guessLen13b(M.length, R.length),
                    x = this.makeRBT(v),
                    _ = this.stub(v),
                    S = new Array(v),
                    A = new Array(v),
                    j = new Array(v),
                    L = new Array(v),
                    H = new Array(v),
                    U = new Array(v),
                    K = k.words
                  ;((K.length = v),
                    this.convert13b(M.words, M.length, S, v),
                    this.convert13b(R.words, R.length, L, v),
                    this.transform(S, _, A, j, v, x),
                    this.transform(L, _, H, U, v, x))
                  for (var z = 0; z < v; z++) {
                    var q = A[z] * H[z] - j[z] * U[z]
                    ;((j[z] = A[z] * U[z] + j[z] * H[z]), (A[z] = q))
                  }
                  return (
                    this.conjugate(A, j, v),
                    this.transform(A, j, K, _, v, x),
                    this.conjugate(K, _, v),
                    this.normalize13b(K, v),
                    (k.negative = M.negative ^ R.negative),
                    (k.length = M.length + R.length),
                    k.strip()
                  )
                }),
                (c.prototype.mul = function (M) {
                  var R = new c(null)
                  return ((R.words = new Array(this.length + M.length)), this.mulTo(M, R))
                }),
                (c.prototype.mulf = function (M) {
                  var R = new c(null)
                  return ((R.words = new Array(this.length + M.length)), w(this, M, R))
                }),
                (c.prototype.imul = function (M) {
                  return this.clone().mulTo(M, this)
                }),
                (c.prototype.imuln = function (M) {
                  ;(a(typeof M == 'number'), a(M < 67108864))
                  for (var R = 0, k = 0; k < this.length; k++) {
                    var v = (0 | this.words[k]) * M,
                      x = (67108863 & v) + (67108863 & R)
                    ;((R >>= 26),
                      (R += (v / 67108864) | 0),
                      (R += x >>> 26),
                      (this.words[k] = 67108863 & x))
                  }
                  return (R !== 0 && ((this.words[k] = R), this.length++), this)
                }),
                (c.prototype.muln = function (M) {
                  return this.clone().imuln(M)
                }),
                (c.prototype.sqr = function () {
                  return this.mul(this)
                }),
                (c.prototype.isqr = function () {
                  return this.imul(this.clone())
                }),
                (c.prototype.pow = function (M) {
                  var R = (function (_) {
                    for (var S = new Array(_.bitLength()), A = 0; A < S.length; A++) {
                      var j = (A / 26) | 0,
                        L = A % 26
                      S[A] = (_.words[j] & (1 << L)) >>> L
                    }
                    return S
                  })(M)
                  if (R.length === 0) return new c(1)
                  for (var k = this, v = 0; v < R.length && R[v] === 0; v++, k = k.sqr());
                  if (++v < R.length)
                    for (var x = k.sqr(); v < R.length; v++, x = x.sqr())
                      R[v] !== 0 && (k = k.mul(x))
                  return k
                }),
                (c.prototype.iushln = function (M) {
                  a(typeof M == 'number' && M >= 0)
                  var R,
                    k = M % 26,
                    v = (M - k) / 26,
                    x = (67108863 >>> (26 - k)) << (26 - k)
                  if (k !== 0) {
                    var _ = 0
                    for (R = 0; R < this.length; R++) {
                      var S = this.words[R] & x,
                        A = ((0 | this.words[R]) - S) << k
                      ;((this.words[R] = A | _), (_ = S >>> (26 - k)))
                    }
                    _ && ((this.words[R] = _), this.length++)
                  }
                  if (v !== 0) {
                    for (R = this.length - 1; R >= 0; R--) this.words[R + v] = this.words[R]
                    for (R = 0; R < v; R++) this.words[R] = 0
                    this.length += v
                  }
                  return this.strip()
                }),
                (c.prototype.ishln = function (M) {
                  return (a(this.negative === 0), this.iushln(M))
                }),
                (c.prototype.iushrn = function (M, R, k) {
                  var v
                  ;(a(typeof M == 'number' && M >= 0), (v = R ? (R - (R % 26)) / 26 : 0))
                  var x = M % 26,
                    _ = Math.min((M - x) / 26, this.length),
                    S = 67108863 ^ ((67108863 >>> x) << x),
                    A = k
                  if (((v -= _), (v = Math.max(0, v)), A)) {
                    for (var j = 0; j < _; j++) A.words[j] = this.words[j]
                    A.length = _
                  }
                  if (_ !== 0)
                    if (this.length > _)
                      for (this.length -= _, j = 0; j < this.length; j++)
                        this.words[j] = this.words[j + _]
                    else ((this.words[0] = 0), (this.length = 1))
                  var L = 0
                  for (j = this.length - 1; j >= 0 && (L !== 0 || j >= v); j--) {
                    var H = 0 | this.words[j]
                    ;((this.words[j] = (L << (26 - x)) | (H >>> x)), (L = H & S))
                  }
                  return (
                    A && L !== 0 && (A.words[A.length++] = L),
                    this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                    this.strip()
                  )
                }),
                (c.prototype.ishrn = function (M, R, k) {
                  return (a(this.negative === 0), this.iushrn(M, R, k))
                }),
                (c.prototype.shln = function (M) {
                  return this.clone().ishln(M)
                }),
                (c.prototype.ushln = function (M) {
                  return this.clone().iushln(M)
                }),
                (c.prototype.shrn = function (M) {
                  return this.clone().ishrn(M)
                }),
                (c.prototype.ushrn = function (M) {
                  return this.clone().iushrn(M)
                }),
                (c.prototype.testn = function (M) {
                  a(typeof M == 'number' && M >= 0)
                  var R = M % 26,
                    k = (M - R) / 26,
                    v = 1 << R
                  return !(this.length <= k) && !!(this.words[k] & v)
                }),
                (c.prototype.imaskn = function (M) {
                  a(typeof M == 'number' && M >= 0)
                  var R = M % 26,
                    k = (M - R) / 26
                  if (
                    (a(this.negative === 0, 'imaskn works only with positive numbers'),
                    this.length <= k)
                  )
                    return this
                  if ((R !== 0 && k++, (this.length = Math.min(k, this.length)), R !== 0)) {
                    var v = 67108863 ^ ((67108863 >>> R) << R)
                    this.words[this.length - 1] &= v
                  }
                  return this.strip()
                }),
                (c.prototype.maskn = function (M) {
                  return this.clone().imaskn(M)
                }),
                (c.prototype.iaddn = function (M) {
                  return (
                    a(typeof M == 'number'),
                    a(M < 67108864),
                    M < 0
                      ? this.isubn(-M)
                      : this.negative !== 0
                        ? this.length === 1 && (0 | this.words[0]) < M
                          ? ((this.words[0] = M - (0 | this.words[0])), (this.negative = 0), this)
                          : ((this.negative = 0), this.isubn(M), (this.negative = 1), this)
                        : this._iaddn(M)
                  )
                }),
                (c.prototype._iaddn = function (M) {
                  this.words[0] += M
                  for (var R = 0; R < this.length && this.words[R] >= 67108864; R++)
                    ((this.words[R] -= 67108864),
                      R === this.length - 1 ? (this.words[R + 1] = 1) : this.words[R + 1]++)
                  return ((this.length = Math.max(this.length, R + 1)), this)
                }),
                (c.prototype.isubn = function (M) {
                  if ((a(typeof M == 'number'), a(M < 67108864), M < 0)) return this.iaddn(-M)
                  if (this.negative !== 0)
                    return ((this.negative = 0), this.iaddn(M), (this.negative = 1), this)
                  if (((this.words[0] -= M), this.length === 1 && this.words[0] < 0))
                    ((this.words[0] = -this.words[0]), (this.negative = 1))
                  else
                    for (var R = 0; R < this.length && this.words[R] < 0; R++)
                      ((this.words[R] += 67108864), (this.words[R + 1] -= 1))
                  return this.strip()
                }),
                (c.prototype.addn = function (M) {
                  return this.clone().iaddn(M)
                }),
                (c.prototype.subn = function (M) {
                  return this.clone().isubn(M)
                }),
                (c.prototype.iabs = function () {
                  return ((this.negative = 0), this)
                }),
                (c.prototype.abs = function () {
                  return this.clone().iabs()
                }),
                (c.prototype._ishlnsubmul = function (M, R, k) {
                  var v,
                    x,
                    _ = M.length + k
                  this._expand(_)
                  var S = 0
                  for (v = 0; v < M.length; v++) {
                    x = (0 | this.words[v + k]) + S
                    var A = (0 | M.words[v]) * R
                    ;((S = ((x -= 67108863 & A) >> 26) - ((A / 67108864) | 0)),
                      (this.words[v + k] = 67108863 & x))
                  }
                  for (; v < this.length - k; v++)
                    ((S = (x = (0 | this.words[v + k]) + S) >> 26),
                      (this.words[v + k] = 67108863 & x))
                  if (S === 0) return this.strip()
                  for (a(S === -1), S = 0, v = 0; v < this.length; v++)
                    ((S = (x = -(0 | this.words[v]) + S) >> 26), (this.words[v] = 67108863 & x))
                  return ((this.negative = 1), this.strip())
                }),
                (c.prototype._wordDiv = function (M, R) {
                  var k = (this.length, M.length),
                    v = this.clone(),
                    x = M,
                    _ = 0 | x.words[x.length - 1]
                  ;(k = 26 - this._countBits(_)) !== 0 &&
                    ((x = x.ushln(k)), v.iushln(k), (_ = 0 | x.words[x.length - 1]))
                  var S,
                    A = v.length - x.length
                  if (R !== 'mod') {
                    ;(((S = new c(null)).length = A + 1), (S.words = new Array(S.length)))
                    for (var j = 0; j < S.length; j++) S.words[j] = 0
                  }
                  var L = v.clone()._ishlnsubmul(x, 1, A)
                  L.negative === 0 && ((v = L), S && (S.words[A] = 1))
                  for (var H = A - 1; H >= 0; H--) {
                    var U = 67108864 * (0 | v.words[x.length + H]) + (0 | v.words[x.length + H - 1])
                    for (
                      U = Math.min((U / _) | 0, 67108863), v._ishlnsubmul(x, U, H);
                      v.negative !== 0;

                    )
                      (U--,
                        (v.negative = 0),
                        v._ishlnsubmul(x, 1, H),
                        v.isZero() || (v.negative ^= 1))
                    S && (S.words[H] = U)
                  }
                  return (
                    S && S.strip(),
                    v.strip(),
                    R !== 'div' && k !== 0 && v.iushrn(k),
                    { div: S || null, mod: v }
                  )
                }),
                (c.prototype.divmod = function (M, R, k) {
                  return (
                    a(!M.isZero()),
                    this.isZero()
                      ? { div: new c(0), mod: new c(0) }
                      : this.negative !== 0 && M.negative === 0
                        ? ((_ = this.neg().divmod(M, R)),
                          R !== 'mod' && (v = _.div.neg()),
                          R !== 'div' && ((x = _.mod.neg()), k && x.negative !== 0 && x.iadd(M)),
                          { div: v, mod: x })
                        : this.negative === 0 && M.negative !== 0
                          ? ((_ = this.divmod(M.neg(), R)),
                            R !== 'mod' && (v = _.div.neg()),
                            { div: v, mod: _.mod })
                          : this.negative & M.negative
                            ? ((_ = this.neg().divmod(M.neg(), R)),
                              R !== 'div' &&
                                ((x = _.mod.neg()), k && x.negative !== 0 && x.isub(M)),
                              { div: _.div, mod: x })
                            : M.length > this.length || this.cmp(M) < 0
                              ? { div: new c(0), mod: this }
                              : M.length === 1
                                ? R === 'div'
                                  ? { div: this.divn(M.words[0]), mod: null }
                                  : R === 'mod'
                                    ? { div: null, mod: new c(this.modn(M.words[0])) }
                                    : {
                                        div: this.divn(M.words[0]),
                                        mod: new c(this.modn(M.words[0])),
                                      }
                                : this._wordDiv(M, R)
                  )
                  var v, x, _
                }),
                (c.prototype.div = function (M) {
                  return this.divmod(M, 'div', !1).div
                }),
                (c.prototype.mod = function (M) {
                  return this.divmod(M, 'mod', !1).mod
                }),
                (c.prototype.umod = function (M) {
                  return this.divmod(M, 'mod', !0).mod
                }),
                (c.prototype.divRound = function (M) {
                  var R = this.divmod(M)
                  if (R.mod.isZero()) return R.div
                  var k = R.div.negative !== 0 ? R.mod.isub(M) : R.mod,
                    v = M.ushrn(1),
                    x = M.andln(1),
                    _ = k.cmp(v)
                  return _ < 0 || (x === 1 && _ === 0)
                    ? R.div
                    : R.div.negative !== 0
                      ? R.div.isubn(1)
                      : R.div.iaddn(1)
                }),
                (c.prototype.modn = function (M) {
                  a(M <= 67108863)
                  for (var R = (1 << 26) % M, k = 0, v = this.length - 1; v >= 0; v--)
                    k = (R * k + (0 | this.words[v])) % M
                  return k
                }),
                (c.prototype.idivn = function (M) {
                  a(M <= 67108863)
                  for (var R = 0, k = this.length - 1; k >= 0; k--) {
                    var v = (0 | this.words[k]) + 67108864 * R
                    ;((this.words[k] = (v / M) | 0), (R = v % M))
                  }
                  return this.strip()
                }),
                (c.prototype.divn = function (M) {
                  return this.clone().idivn(M)
                }),
                (c.prototype.egcd = function (M) {
                  ;(a(M.negative === 0), a(!M.isZero()))
                  var R = this,
                    k = M.clone()
                  R = R.negative !== 0 ? R.umod(M) : R.clone()
                  for (
                    var v = new c(1), x = new c(0), _ = new c(0), S = new c(1), A = 0;
                    R.isEven() && k.isEven();

                  )
                    (R.iushrn(1), k.iushrn(1), ++A)
                  for (var j = k.clone(), L = R.clone(); !R.isZero(); ) {
                    for (var H = 0, U = 1; !(R.words[0] & U) && H < 26; ++H, U <<= 1);
                    if (H > 0)
                      for (R.iushrn(H); H-- > 0; )
                        ((v.isOdd() || x.isOdd()) && (v.iadd(j), x.isub(L)),
                          v.iushrn(1),
                          x.iushrn(1))
                    for (var K = 0, z = 1; !(k.words[0] & z) && K < 26; ++K, z <<= 1);
                    if (K > 0)
                      for (k.iushrn(K); K-- > 0; )
                        ((_.isOdd() || S.isOdd()) && (_.iadd(j), S.isub(L)),
                          _.iushrn(1),
                          S.iushrn(1))
                    R.cmp(k) >= 0
                      ? (R.isub(k), v.isub(_), x.isub(S))
                      : (k.isub(R), _.isub(v), S.isub(x))
                  }
                  return { a: _, b: S, gcd: k.iushln(A) }
                }),
                (c.prototype._invmp = function (M) {
                  ;(a(M.negative === 0), a(!M.isZero()))
                  var R = this,
                    k = M.clone()
                  R = R.negative !== 0 ? R.umod(M) : R.clone()
                  for (
                    var v, x = new c(1), _ = new c(0), S = k.clone();
                    R.cmpn(1) > 0 && k.cmpn(1) > 0;

                  ) {
                    for (var A = 0, j = 1; !(R.words[0] & j) && A < 26; ++A, j <<= 1);
                    if (A > 0) for (R.iushrn(A); A-- > 0; ) (x.isOdd() && x.iadd(S), x.iushrn(1))
                    for (var L = 0, H = 1; !(k.words[0] & H) && L < 26; ++L, H <<= 1);
                    if (L > 0) for (k.iushrn(L); L-- > 0; ) (_.isOdd() && _.iadd(S), _.iushrn(1))
                    R.cmp(k) >= 0 ? (R.isub(k), x.isub(_)) : (k.isub(R), _.isub(x))
                  }
                  return ((v = R.cmpn(1) === 0 ? x : _).cmpn(0) < 0 && v.iadd(M), v)
                }),
                (c.prototype.gcd = function (M) {
                  if (this.isZero()) return M.abs()
                  if (M.isZero()) return this.abs()
                  var R = this.clone(),
                    k = M.clone()
                  ;((R.negative = 0), (k.negative = 0))
                  for (var v = 0; R.isEven() && k.isEven(); v++) (R.iushrn(1), k.iushrn(1))
                  for (;;) {
                    for (; R.isEven(); ) R.iushrn(1)
                    for (; k.isEven(); ) k.iushrn(1)
                    var x = R.cmp(k)
                    if (x < 0) {
                      var _ = R
                      ;((R = k), (k = _))
                    } else if (x === 0 || k.cmpn(1) === 0) break
                    R.isub(k)
                  }
                  return k.iushln(v)
                }),
                (c.prototype.invm = function (M) {
                  return this.egcd(M).a.umod(M)
                }),
                (c.prototype.isEven = function () {
                  return (1 & this.words[0]) == 0
                }),
                (c.prototype.isOdd = function () {
                  return (1 & this.words[0]) == 1
                }),
                (c.prototype.andln = function (M) {
                  return this.words[0] & M
                }),
                (c.prototype.bincn = function (M) {
                  a(typeof M == 'number')
                  var R = M % 26,
                    k = (M - R) / 26,
                    v = 1 << R
                  if (this.length <= k) return (this._expand(k + 1), (this.words[k] |= v), this)
                  for (var x = v, _ = k; x !== 0 && _ < this.length; _++) {
                    var S = 0 | this.words[_]
                    ;((x = (S += x) >>> 26), (S &= 67108863), (this.words[_] = S))
                  }
                  return (x !== 0 && ((this.words[_] = x), this.length++), this)
                }),
                (c.prototype.isZero = function () {
                  return this.length === 1 && this.words[0] === 0
                }),
                (c.prototype.cmpn = function (M) {
                  var R,
                    k = M < 0
                  if (this.negative !== 0 && !k) return -1
                  if (this.negative === 0 && k) return 1
                  if ((this.strip(), this.length > 1)) R = 1
                  else {
                    ;(k && (M = -M), a(M <= 67108863, 'Number is too big'))
                    var v = 0 | this.words[0]
                    R = v === M ? 0 : v < M ? -1 : 1
                  }
                  return this.negative !== 0 ? 0 | -R : R
                }),
                (c.prototype.cmp = function (M) {
                  if (this.negative !== 0 && M.negative === 0) return -1
                  if (this.negative === 0 && M.negative !== 0) return 1
                  var R = this.ucmp(M)
                  return this.negative !== 0 ? 0 | -R : R
                }),
                (c.prototype.ucmp = function (M) {
                  if (this.length > M.length) return 1
                  if (this.length < M.length) return -1
                  for (var R = 0, k = this.length - 1; k >= 0; k--) {
                    var v = 0 | this.words[k],
                      x = 0 | M.words[k]
                    if (v !== x) {
                      v < x ? (R = -1) : v > x && (R = 1)
                      break
                    }
                  }
                  return R
                }),
                (c.prototype.gtn = function (M) {
                  return this.cmpn(M) === 1
                }),
                (c.prototype.gt = function (M) {
                  return this.cmp(M) === 1
                }),
                (c.prototype.gten = function (M) {
                  return this.cmpn(M) >= 0
                }),
                (c.prototype.gte = function (M) {
                  return this.cmp(M) >= 0
                }),
                (c.prototype.ltn = function (M) {
                  return this.cmpn(M) === -1
                }),
                (c.prototype.lt = function (M) {
                  return this.cmp(M) === -1
                }),
                (c.prototype.lten = function (M) {
                  return this.cmpn(M) <= 0
                }),
                (c.prototype.lte = function (M) {
                  return this.cmp(M) <= 0
                }),
                (c.prototype.eqn = function (M) {
                  return this.cmpn(M) === 0
                }),
                (c.prototype.eq = function (M) {
                  return this.cmp(M) === 0
                }),
                (c.red = function (M) {
                  return new $(M)
                }),
                (c.prototype.toRed = function (M) {
                  return (
                    a(!this.red, 'Already a number in reduction context'),
                    a(this.negative === 0, 'red works only with positives'),
                    M.convertTo(this)._forceRed(M)
                  )
                }),
                (c.prototype.fromRed = function () {
                  return (
                    a(this.red, 'fromRed works only with numbers in reduction context'),
                    this.red.convertFrom(this)
                  )
                }),
                (c.prototype._forceRed = function (M) {
                  return ((this.red = M), this)
                }),
                (c.prototype.forceRed = function (M) {
                  return (a(!this.red, 'Already a number in reduction context'), this._forceRed(M))
                }),
                (c.prototype.redAdd = function (M) {
                  return (a(this.red, 'redAdd works only with red numbers'), this.red.add(this, M))
                }),
                (c.prototype.redIAdd = function (M) {
                  return (
                    a(this.red, 'redIAdd works only with red numbers'),
                    this.red.iadd(this, M)
                  )
                }),
                (c.prototype.redSub = function (M) {
                  return (a(this.red, 'redSub works only with red numbers'), this.red.sub(this, M))
                }),
                (c.prototype.redISub = function (M) {
                  return (
                    a(this.red, 'redISub works only with red numbers'),
                    this.red.isub(this, M)
                  )
                }),
                (c.prototype.redShl = function (M) {
                  return (a(this.red, 'redShl works only with red numbers'), this.red.shl(this, M))
                }),
                (c.prototype.redMul = function (M) {
                  return (
                    a(this.red, 'redMul works only with red numbers'),
                    this.red._verify2(this, M),
                    this.red.mul(this, M)
                  )
                }),
                (c.prototype.redIMul = function (M) {
                  return (
                    a(this.red, 'redMul works only with red numbers'),
                    this.red._verify2(this, M),
                    this.red.imul(this, M)
                  )
                }),
                (c.prototype.redSqr = function () {
                  return (
                    a(this.red, 'redSqr works only with red numbers'),
                    this.red._verify1(this),
                    this.red.sqr(this)
                  )
                }),
                (c.prototype.redISqr = function () {
                  return (
                    a(this.red, 'redISqr works only with red numbers'),
                    this.red._verify1(this),
                    this.red.isqr(this)
                  )
                }),
                (c.prototype.redSqrt = function () {
                  return (
                    a(this.red, 'redSqrt works only with red numbers'),
                    this.red._verify1(this),
                    this.red.sqrt(this)
                  )
                }),
                (c.prototype.redInvm = function () {
                  return (
                    a(this.red, 'redInvm works only with red numbers'),
                    this.red._verify1(this),
                    this.red.invm(this)
                  )
                }),
                (c.prototype.redNeg = function () {
                  return (
                    a(this.red, 'redNeg works only with red numbers'),
                    this.red._verify1(this),
                    this.red.neg(this)
                  )
                }),
                (c.prototype.redPow = function (M) {
                  return (
                    a(this.red && !M.red, 'redPow(normalNum)'),
                    this.red._verify1(this),
                    this.red.pow(this, M)
                  )
                }))
              var T = { k256: null, p224: null, p192: null, p25519: null }
              function I(M, R) {
                ;((this.name = M),
                  (this.p = new c(R, 16)),
                  (this.n = this.p.bitLength()),
                  (this.k = new c(1).iushln(this.n).isub(this.p)),
                  (this.tmp = this._tmp()))
              }
              function B() {
                I.call(
                  this,
                  'k256',
                  'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
                )
              }
              function E() {
                I.call(
                  this,
                  'p224',
                  'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
                )
              }
              function O() {
                I.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff')
              }
              function P() {
                I.call(
                  this,
                  '25519',
                  '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                )
              }
              function $(M) {
                if (typeof M == 'string') {
                  var R = c._prime(M)
                  ;((this.m = R.p), (this.prime = R))
                } else
                  (a(M.gtn(1), 'modulus must be greater than 1'), (this.m = M), (this.prime = null))
              }
              function F(M) {
                ;($.call(this, M),
                  (this.shift = this.m.bitLength()),
                  this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
                  (this.r = new c(1).iushln(this.shift)),
                  (this.r2 = this.imod(this.r.sqr())),
                  (this.rinv = this.r._invmp(this.m)),
                  (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
                  (this.minv = this.minv.umod(this.r)),
                  (this.minv = this.r.sub(this.minv)))
              }
              ;((I.prototype._tmp = function () {
                var M = new c(null)
                return ((M.words = new Array(Math.ceil(this.n / 13))), M)
              }),
                (I.prototype.ireduce = function (M) {
                  var R,
                    k = M
                  do
                    (this.split(k, this.tmp),
                      (R = (k = (k = this.imulK(k)).iadd(this.tmp)).bitLength()))
                  while (R > this.n)
                  var v = R < this.n ? -1 : k.ucmp(this.p)
                  return (
                    v === 0
                      ? ((k.words[0] = 0), (k.length = 1))
                      : v > 0
                        ? k.isub(this.p)
                        : k.strip !== void 0
                          ? k.strip()
                          : k._strip(),
                    k
                  )
                }),
                (I.prototype.split = function (M, R) {
                  M.iushrn(this.n, 0, R)
                }),
                (I.prototype.imulK = function (M) {
                  return M.imul(this.k)
                }),
                l(B, I),
                (B.prototype.split = function (M, R) {
                  for (var k = Math.min(M.length, 9), v = 0; v < k; v++) R.words[v] = M.words[v]
                  if (((R.length = k), M.length <= 9))
                    return ((M.words[0] = 0), void (M.length = 1))
                  var x = M.words[9]
                  for (R.words[R.length++] = 4194303 & x, v = 10; v < M.length; v++) {
                    var _ = 0 | M.words[v]
                    ;((M.words[v - 10] = ((4194303 & _) << 4) | (x >>> 22)), (x = _))
                  }
                  ;((x >>>= 22),
                    (M.words[v - 10] = x),
                    x === 0 && M.length > 10 ? (M.length -= 10) : (M.length -= 9))
                }),
                (B.prototype.imulK = function (M) {
                  ;((M.words[M.length] = 0), (M.words[M.length + 1] = 0), (M.length += 2))
                  for (var R = 0, k = 0; k < M.length; k++) {
                    var v = 0 | M.words[k]
                    ;((R += 977 * v),
                      (M.words[k] = 67108863 & R),
                      (R = 64 * v + ((R / 67108864) | 0)))
                  }
                  return (
                    M.words[M.length - 1] === 0 &&
                      (M.length--, M.words[M.length - 1] === 0 && M.length--),
                    M
                  )
                }),
                l(E, I),
                l(O, I),
                l(P, I),
                (P.prototype.imulK = function (M) {
                  for (var R = 0, k = 0; k < M.length; k++) {
                    var v = 19 * (0 | M.words[k]) + R,
                      x = 67108863 & v
                    ;((v >>>= 26), (M.words[k] = x), (R = v))
                  }
                  return (R !== 0 && (M.words[M.length++] = R), M)
                }),
                (c._prime = function (M) {
                  if (T[M]) return T[M]
                  var R
                  if (M === 'k256') R = new B()
                  else if (M === 'p224') R = new E()
                  else if (M === 'p192') R = new O()
                  else {
                    if (M !== 'p25519') throw new Error('Unknown prime ' + M)
                    R = new P()
                  }
                  return ((T[M] = R), R)
                }),
                ($.prototype._verify1 = function (M) {
                  ;(a(M.negative === 0, 'red works only with positives'),
                    a(M.red, 'red works only with red numbers'))
                }),
                ($.prototype._verify2 = function (M, R) {
                  ;(a((M.negative | R.negative) == 0, 'red works only with positives'),
                    a(M.red && M.red === R.red, 'red works only with red numbers'))
                }),
                ($.prototype.imod = function (M) {
                  return this.prime
                    ? this.prime.ireduce(M)._forceRed(this)
                    : M.umod(this.m)._forceRed(this)
                }),
                ($.prototype.neg = function (M) {
                  return M.isZero() ? M.clone() : this.m.sub(M)._forceRed(this)
                }),
                ($.prototype.add = function (M, R) {
                  this._verify2(M, R)
                  var k = M.add(R)
                  return (k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this))
                }),
                ($.prototype.iadd = function (M, R) {
                  this._verify2(M, R)
                  var k = M.iadd(R)
                  return (k.cmp(this.m) >= 0 && k.isub(this.m), k)
                }),
                ($.prototype.sub = function (M, R) {
                  this._verify2(M, R)
                  var k = M.sub(R)
                  return (k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this))
                }),
                ($.prototype.isub = function (M, R) {
                  this._verify2(M, R)
                  var k = M.isub(R)
                  return (k.cmpn(0) < 0 && k.iadd(this.m), k)
                }),
                ($.prototype.shl = function (M, R) {
                  return (this._verify1(M), this.imod(M.ushln(R)))
                }),
                ($.prototype.imul = function (M, R) {
                  return (this._verify2(M, R), this.imod(M.imul(R)))
                }),
                ($.prototype.mul = function (M, R) {
                  return (this._verify2(M, R), this.imod(M.mul(R)))
                }),
                ($.prototype.isqr = function (M) {
                  return this.imul(M, M.clone())
                }),
                ($.prototype.sqr = function (M) {
                  return this.mul(M, M)
                }),
                ($.prototype.sqrt = function (M) {
                  if (M.isZero()) return M.clone()
                  var R = this.m.andln(3)
                  if ((a(R % 2 == 1), R === 3)) {
                    var k = this.m.add(new c(1)).iushrn(2)
                    return this.pow(M, k)
                  }
                  for (var v = this.m.subn(1), x = 0; !v.isZero() && v.andln(1) === 0; )
                    (x++, v.iushrn(1))
                  a(!v.isZero())
                  var _ = new c(1).toRed(this),
                    S = _.redNeg(),
                    A = this.m.subn(1).iushrn(1),
                    j = this.m.bitLength()
                  for (j = new c(2 * j * j).toRed(this); this.pow(j, A).cmp(S) !== 0; ) j.redIAdd(S)
                  for (
                    var L = this.pow(j, v),
                      H = this.pow(M, v.addn(1).iushrn(1)),
                      U = this.pow(M, v),
                      K = x;
                    U.cmp(_) !== 0;

                  ) {
                    for (var z = U, q = 0; z.cmp(_) !== 0; q++) z = z.redSqr()
                    a(q < K)
                    var D = this.pow(L, new c(1).iushln(K - q - 1))
                    ;((H = H.redMul(D)), (L = D.redSqr()), (U = U.redMul(L)), (K = q))
                  }
                  return H
                }),
                ($.prototype.invm = function (M) {
                  var R = M._invmp(this.m)
                  return R.negative !== 0 ? ((R.negative = 0), this.imod(R).redNeg()) : this.imod(R)
                }),
                ($.prototype.pow = function (M, R) {
                  if (R.isZero()) return new c(1).toRed(this)
                  if (R.cmpn(1) === 0) return M.clone()
                  var k = new Array(16)
                  ;((k[0] = new c(1).toRed(this)), (k[1] = M))
                  for (var v = 2; v < k.length; v++) k[v] = this.mul(k[v - 1], M)
                  var x = k[0],
                    _ = 0,
                    S = 0,
                    A = R.bitLength() % 26
                  for (A === 0 && (A = 26), v = R.length - 1; v >= 0; v--) {
                    for (var j = R.words[v], L = A - 1; L >= 0; L--) {
                      var H = (j >> L) & 1
                      ;(x !== k[0] && (x = this.sqr(x)),
                        H !== 0 || _ !== 0
                          ? ((_ <<= 1),
                            (_ |= H),
                            (++S === 4 || (v === 0 && L === 0)) &&
                              ((x = this.mul(x, k[_])), (S = 0), (_ = 0)))
                          : (S = 0))
                    }
                    A = 26
                  }
                  return x
                }),
                ($.prototype.convertTo = function (M) {
                  var R = M.umod(this.m)
                  return R === M ? R.clone() : R
                }),
                ($.prototype.convertFrom = function (M) {
                  var R = M.clone()
                  return ((R.red = null), R)
                }),
                (c.mont = function (M) {
                  return new F(M)
                }),
                l(F, $),
                (F.prototype.convertTo = function (M) {
                  return this.imod(M.ushln(this.shift))
                }),
                (F.prototype.convertFrom = function (M) {
                  var R = this.imod(M.mul(this.rinv))
                  return ((R.red = null), R)
                }),
                (F.prototype.imul = function (M, R) {
                  if (M.isZero() || R.isZero()) return ((M.words[0] = 0), (M.length = 1), M)
                  var k = M.imul(R),
                    v = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    x = k.isub(v).iushrn(this.shift),
                    _ = x
                  return (
                    x.cmp(this.m) >= 0
                      ? (_ = x.isub(this.m))
                      : x.cmpn(0) < 0 && (_ = x.iadd(this.m)),
                    _._forceRed(this)
                  )
                }),
                (F.prototype.mul = function (M, R) {
                  if (M.isZero() || R.isZero()) return new c(0)._forceRed(this)
                  var k = M.mul(R),
                    v = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    x = k.isub(v).iushrn(this.shift),
                    _ = x
                  return (
                    x.cmp(this.m) >= 0
                      ? (_ = x.isub(this.m))
                      : x.cmpn(0) < 0 && (_ = x.iadd(this.m)),
                    _._forceRed(this)
                  )
                }),
                (F.prototype.invm = function (M) {
                  return this.imod(M._invmp(this.m).mul(this.r2))._forceRed(this)
                }))
            })(r === void 0 || r)
          },
          { buffer: 188 },
        ],
        185: [
          function (t, r, i) {
            ;((i.byteLength = function (h) {
              var p = f(h),
                g = p[0],
                m = p[1]
              return (3 * (g + m)) / 4 - m
            }),
              (i.toByteArray = function (h) {
                var p,
                  g,
                  m = f(h),
                  y = m[0],
                  b = m[1],
                  w = new a(
                    (function (I, B, E) {
                      return (3 * (B + E)) / 4 - E
                    })(0, y, b),
                  ),
                  C = 0,
                  T = b > 0 ? y - 4 : y
                for (g = 0; g < T; g += 4)
                  ((p =
                    (o[h.charCodeAt(g)] << 18) |
                    (o[h.charCodeAt(g + 1)] << 12) |
                    (o[h.charCodeAt(g + 2)] << 6) |
                    o[h.charCodeAt(g + 3)]),
                    (w[C++] = (p >> 16) & 255),
                    (w[C++] = (p >> 8) & 255),
                    (w[C++] = 255 & p))
                return (
                  b === 2 &&
                    ((p = (o[h.charCodeAt(g)] << 2) | (o[h.charCodeAt(g + 1)] >> 4)),
                    (w[C++] = 255 & p)),
                  b === 1 &&
                    ((p =
                      (o[h.charCodeAt(g)] << 10) |
                      (o[h.charCodeAt(g + 1)] << 4) |
                      (o[h.charCodeAt(g + 2)] >> 2)),
                    (w[C++] = (p >> 8) & 255),
                    (w[C++] = 255 & p)),
                  w
                )
              }),
              (i.fromByteArray = function (h) {
                for (var p, g = h.length, m = g % 3, y = [], b = 0, w = g - m; b < w; b += 16383)
                  y.push(d(h, b, b + 16383 > w ? w : b + 16383))
                return (
                  m === 1
                    ? ((p = h[g - 1]), y.push(s[p >> 2] + s[(p << 4) & 63] + '=='))
                    : m === 2 &&
                      ((p = (h[g - 2] << 8) + h[g - 1]),
                      y.push(s[p >> 10] + s[(p >> 4) & 63] + s[(p << 2) & 63] + '=')),
                  y.join('')
                )
              }))
            for (
              var s = [],
                o = [],
                a = typeof Uint8Array < 'u' ? Uint8Array : Array,
                l = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                c = 0,
                u = l.length;
              c < u;
              ++c
            )
              ((s[c] = l[c]), (o[l.charCodeAt(c)] = c))
            function f(h) {
              var p = h.length
              if (p % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4')
              var g = h.indexOf('=')
              return (g === -1 && (g = p), [g, g === p ? 0 : 4 - (g % 4)])
            }
            function d(h, p, g) {
              for (var m, y, b = [], w = p; w < g; w += 3)
                ((m = ((h[w] << 16) & 16711680) + ((h[w + 1] << 8) & 65280) + (255 & h[w + 2])),
                  b.push(
                    s[((y = m) >> 18) & 63] + s[(y >> 12) & 63] + s[(y >> 6) & 63] + s[63 & y],
                  ))
              return b.join('')
            }
            ;((o[45] = 62), (o[95] = 63))
          },
          {},
        ],
        186: [
          function (t, r, i) {
            ;(function (s, o) {
              function a(k, v) {
                if (!k) throw new Error(v || 'Assertion failed')
              }
              function l(k, v) {
                k.super_ = v
                var x = function () {}
                ;((x.prototype = v.prototype),
                  (k.prototype = new x()),
                  (k.prototype.constructor = k))
              }
              function c(k, v, x) {
                if (c.isBN(k)) return k
                ;((this.negative = 0),
                  (this.words = null),
                  (this.length = 0),
                  (this.red = null),
                  k !== null &&
                    ((v !== 'le' && v !== 'be') || ((x = v), (v = 10)),
                    this._init(k || 0, v || 10, x || 'be')))
              }
              var u
              ;(typeof s == 'object' ? (s.exports = c) : ((void 0).BN = c),
                (c.BN = c),
                (c.wordSize = 26))
              try {
                u =
                  typeof window < 'u' && window.Buffer !== void 0
                    ? window.Buffer
                    : t('buffer').Buffer
              } catch {}
              function f(k, v) {
                var x = k.charCodeAt(v)
                return x >= 48 && x <= 57
                  ? x - 48
                  : x >= 65 && x <= 70
                    ? x - 55
                    : x >= 97 && x <= 102
                      ? x - 87
                      : void a(!1, 'Invalid character in ' + k)
              }
              function d(k, v, x) {
                var _ = f(k, x)
                return (x - 1 >= v && (_ |= f(k, x - 1) << 4), _)
              }
              function h(k, v, x, _) {
                for (var S = 0, A = 0, j = Math.min(k.length, x), L = v; L < j; L++) {
                  var H = k.charCodeAt(L) - 48
                  ;((S *= _),
                    (A = H >= 49 ? H - 49 + 10 : H >= 17 ? H - 17 + 10 : H),
                    a(H >= 0 && A < _, 'Invalid character'),
                    (S += A))
                }
                return S
              }
              function p(k, v) {
                ;((k.words = v.words),
                  (k.length = v.length),
                  (k.negative = v.negative),
                  (k.red = v.red))
              }
              if (
                ((c.isBN = function (k) {
                  return (
                    k instanceof c ||
                    (k !== null &&
                      typeof k == 'object' &&
                      k.constructor.wordSize === c.wordSize &&
                      Array.isArray(k.words))
                  )
                }),
                (c.max = function (k, v) {
                  return k.cmp(v) > 0 ? k : v
                }),
                (c.min = function (k, v) {
                  return k.cmp(v) < 0 ? k : v
                }),
                (c.prototype._init = function (k, v, x) {
                  if (typeof k == 'number') return this._initNumber(k, v, x)
                  if (typeof k == 'object') return this._initArray(k, v, x)
                  ;(v === 'hex' && (v = 16), a(v === (0 | v) && v >= 2 && v <= 36))
                  var _ = 0
                  ;((k = k.toString().replace(/\s+/g, ''))[0] === '-' && (_++, (this.negative = 1)),
                    _ < k.length &&
                      (v === 16
                        ? this._parseHex(k, _, x)
                        : (this._parseBase(k, v, _),
                          x === 'le' && this._initArray(this.toArray(), v, x))))
                }),
                (c.prototype._initNumber = function (k, v, x) {
                  ;(k < 0 && ((this.negative = 1), (k = -k)),
                    k < 67108864
                      ? ((this.words = [67108863 & k]), (this.length = 1))
                      : k < 4503599627370496
                        ? ((this.words = [67108863 & k, (k / 67108864) & 67108863]),
                          (this.length = 2))
                        : (a(k < 9007199254740992),
                          (this.words = [67108863 & k, (k / 67108864) & 67108863, 1]),
                          (this.length = 3)),
                    x === 'le' && this._initArray(this.toArray(), v, x))
                }),
                (c.prototype._initArray = function (k, v, x) {
                  if ((a(typeof k.length == 'number'), k.length <= 0))
                    return ((this.words = [0]), (this.length = 1), this)
                  ;((this.length = Math.ceil(k.length / 3)), (this.words = new Array(this.length)))
                  for (var _ = 0; _ < this.length; _++) this.words[_] = 0
                  var S,
                    A,
                    j = 0
                  if (x === 'be')
                    for (_ = k.length - 1, S = 0; _ >= 0; _ -= 3)
                      ((A = k[_] | (k[_ - 1] << 8) | (k[_ - 2] << 16)),
                        (this.words[S] |= (A << j) & 67108863),
                        (this.words[S + 1] = (A >>> (26 - j)) & 67108863),
                        (j += 24) >= 26 && ((j -= 26), S++))
                  else if (x === 'le')
                    for (_ = 0, S = 0; _ < k.length; _ += 3)
                      ((A = k[_] | (k[_ + 1] << 8) | (k[_ + 2] << 16)),
                        (this.words[S] |= (A << j) & 67108863),
                        (this.words[S + 1] = (A >>> (26 - j)) & 67108863),
                        (j += 24) >= 26 && ((j -= 26), S++))
                  return this._strip()
                }),
                (c.prototype._parseHex = function (k, v, x) {
                  ;((this.length = Math.ceil((k.length - v) / 6)),
                    (this.words = new Array(this.length)))
                  for (var _ = 0; _ < this.length; _++) this.words[_] = 0
                  var S,
                    A = 0,
                    j = 0
                  if (x === 'be')
                    for (_ = k.length - 1; _ >= v; _ -= 2)
                      ((S = d(k, v, _) << A),
                        (this.words[j] |= 67108863 & S),
                        A >= 18 ? ((A -= 18), (j += 1), (this.words[j] |= S >>> 26)) : (A += 8))
                  else
                    for (_ = (k.length - v) % 2 == 0 ? v + 1 : v; _ < k.length; _ += 2)
                      ((S = d(k, v, _) << A),
                        (this.words[j] |= 67108863 & S),
                        A >= 18 ? ((A -= 18), (j += 1), (this.words[j] |= S >>> 26)) : (A += 8))
                  this._strip()
                }),
                (c.prototype._parseBase = function (k, v, x) {
                  ;((this.words = [0]), (this.length = 1))
                  for (var _ = 0, S = 1; S <= 67108863; S *= v) _++
                  ;(_--, (S = (S / v) | 0))
                  for (
                    var A = k.length - x, j = A % _, L = Math.min(A, A - j) + x, H = 0, U = x;
                    U < L;
                    U += _
                  )
                    ((H = h(k, U, U + _, v)),
                      this.imuln(S),
                      this.words[0] + H < 67108864 ? (this.words[0] += H) : this._iaddn(H))
                  if (j !== 0) {
                    var K = 1
                    for (H = h(k, U, k.length, v), U = 0; U < j; U++) K *= v
                    ;(this.imuln(K),
                      this.words[0] + H < 67108864 ? (this.words[0] += H) : this._iaddn(H))
                  }
                  this._strip()
                }),
                (c.prototype.copy = function (k) {
                  k.words = new Array(this.length)
                  for (var v = 0; v < this.length; v++) k.words[v] = this.words[v]
                  ;((k.length = this.length), (k.negative = this.negative), (k.red = this.red))
                }),
                (c.prototype._move = function (k) {
                  p(k, this)
                }),
                (c.prototype.clone = function () {
                  var k = new c(null)
                  return (this.copy(k), k)
                }),
                (c.prototype._expand = function (k) {
                  for (; this.length < k; ) this.words[this.length++] = 0
                  return this
                }),
                (c.prototype._strip = function () {
                  for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
                  return this._normSign()
                }),
                (c.prototype._normSign = function () {
                  return (this.length === 1 && this.words[0] === 0 && (this.negative = 0), this)
                }),
                typeof Symbol < 'u' && typeof Symbol.for == 'function')
              )
                try {
                  c.prototype[Symbol.for('nodejs.util.inspect.custom')] = g
                } catch {
                  c.prototype.inspect = g
                }
              else c.prototype.inspect = g
              function g() {
                return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'
              }
              var m = [
                  '',
                  '0',
                  '00',
                  '000',
                  '0000',
                  '00000',
                  '000000',
                  '0000000',
                  '00000000',
                  '000000000',
                  '0000000000',
                  '00000000000',
                  '000000000000',
                  '0000000000000',
                  '00000000000000',
                  '000000000000000',
                  '0000000000000000',
                  '00000000000000000',
                  '000000000000000000',
                  '0000000000000000000',
                  '00000000000000000000',
                  '000000000000000000000',
                  '0000000000000000000000',
                  '00000000000000000000000',
                  '000000000000000000000000',
                  '0000000000000000000000000',
                ],
                y = [
                  0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5,
                  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                ],
                b = [
                  0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
                  43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216,
                  24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625,
                  11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393,
                  45435424, 52521875, 60466176,
                ]
              ;((c.prototype.toString = function (k, v) {
                var x
                if (((v = 0 | v || 1), (k = k || 10) === 16 || k === 'hex')) {
                  x = ''
                  for (var _ = 0, S = 0, A = 0; A < this.length; A++) {
                    var j = this.words[A],
                      L = (16777215 & ((j << _) | S)).toString(16)
                    ;((S = (j >>> (24 - _)) & 16777215),
                      (_ += 2) >= 26 && ((_ -= 26), A--),
                      (x = S !== 0 || A !== this.length - 1 ? m[6 - L.length] + L + x : L + x))
                  }
                  for (S !== 0 && (x = S.toString(16) + x); x.length % v != 0; ) x = '0' + x
                  return (this.negative !== 0 && (x = '-' + x), x)
                }
                if (k === (0 | k) && k >= 2 && k <= 36) {
                  var H = y[k],
                    U = b[k]
                  x = ''
                  var K = this.clone()
                  for (K.negative = 0; !K.isZero(); ) {
                    var z = K.modrn(U).toString(k)
                    x = (K = K.idivn(U)).isZero() ? z + x : m[H - z.length] + z + x
                  }
                  for (this.isZero() && (x = '0' + x); x.length % v != 0; ) x = '0' + x
                  return (this.negative !== 0 && (x = '-' + x), x)
                }
                a(!1, 'Base should be between 2 and 36')
              }),
                (c.prototype.toNumber = function () {
                  var k = this.words[0]
                  return (
                    this.length === 2
                      ? (k += 67108864 * this.words[1])
                      : this.length === 3 && this.words[2] === 1
                        ? (k += 4503599627370496 + 67108864 * this.words[1])
                        : this.length > 2 && a(!1, 'Number can only safely store up to 53 bits'),
                    this.negative !== 0 ? -k : k
                  )
                }),
                (c.prototype.toJSON = function () {
                  return this.toString(16, 2)
                }),
                u &&
                  (c.prototype.toBuffer = function (k, v) {
                    return this.toArrayLike(u, k, v)
                  }),
                (c.prototype.toArray = function (k, v) {
                  return this.toArrayLike(Array, k, v)
                }))
              function w(k, v, x) {
                x.negative = v.negative ^ k.negative
                var _ = (k.length + v.length) | 0
                ;((x.length = _), (_ = (_ - 1) | 0))
                var S = 0 | k.words[0],
                  A = 0 | v.words[0],
                  j = S * A,
                  L = 67108863 & j,
                  H = (j / 67108864) | 0
                x.words[0] = L
                for (var U = 1; U < _; U++) {
                  for (
                    var K = H >>> 26,
                      z = 67108863 & H,
                      q = Math.min(U, v.length - 1),
                      D = Math.max(0, U - k.length + 1);
                    D <= q;
                    D++
                  ) {
                    var N = (U - D) | 0
                    ;((K += ((j = (S = 0 | k.words[N]) * (A = 0 | v.words[D]) + z) / 67108864) | 0),
                      (z = 67108863 & j))
                  }
                  ;((x.words[U] = 0 | z), (H = 0 | K))
                }
                return (H !== 0 ? (x.words[U] = 0 | H) : x.length--, x._strip())
              }
              ;((c.prototype.toArrayLike = function (k, v, x) {
                this._strip()
                var _ = this.byteLength(),
                  S = x || Math.max(1, _)
                ;(a(_ <= S, 'byte array longer than desired length'),
                  a(S > 0, 'Requested array length <= 0'))
                var A = (function (j, L) {
                  return j.allocUnsafe ? j.allocUnsafe(L) : new j(L)
                })(k, S)
                return (this['_toArrayLike' + (v === 'le' ? 'LE' : 'BE')](A, _), A)
              }),
                (c.prototype._toArrayLikeLE = function (k, v) {
                  for (var x = 0, _ = 0, S = 0, A = 0; S < this.length; S++) {
                    var j = (this.words[S] << A) | _
                    ;((k[x++] = 255 & j),
                      x < k.length && (k[x++] = (j >> 8) & 255),
                      x < k.length && (k[x++] = (j >> 16) & 255),
                      A === 6
                        ? (x < k.length && (k[x++] = (j >> 24) & 255), (_ = 0), (A = 0))
                        : ((_ = j >>> 24), (A += 2)))
                  }
                  if (x < k.length) for (k[x++] = _; x < k.length; ) k[x++] = 0
                }),
                (c.prototype._toArrayLikeBE = function (k, v) {
                  for (var x = k.length - 1, _ = 0, S = 0, A = 0; S < this.length; S++) {
                    var j = (this.words[S] << A) | _
                    ;((k[x--] = 255 & j),
                      x >= 0 && (k[x--] = (j >> 8) & 255),
                      x >= 0 && (k[x--] = (j >> 16) & 255),
                      A === 6
                        ? (x >= 0 && (k[x--] = (j >> 24) & 255), (_ = 0), (A = 0))
                        : ((_ = j >>> 24), (A += 2)))
                  }
                  if (x >= 0) for (k[x--] = _; x >= 0; ) k[x--] = 0
                }),
                Math.clz32
                  ? (c.prototype._countBits = function (k) {
                      return 32 - Math.clz32(k)
                    })
                  : (c.prototype._countBits = function (k) {
                      var v = k,
                        x = 0
                      return (
                        v >= 4096 && ((x += 13), (v >>>= 13)),
                        v >= 64 && ((x += 7), (v >>>= 7)),
                        v >= 8 && ((x += 4), (v >>>= 4)),
                        v >= 2 && ((x += 2), (v >>>= 2)),
                        x + v
                      )
                    }),
                (c.prototype._zeroBits = function (k) {
                  if (k === 0) return 26
                  var v = k,
                    x = 0
                  return (
                    !(8191 & v) && ((x += 13), (v >>>= 13)),
                    !(127 & v) && ((x += 7), (v >>>= 7)),
                    !(15 & v) && ((x += 4), (v >>>= 4)),
                    !(3 & v) && ((x += 2), (v >>>= 2)),
                    !(1 & v) && x++,
                    x
                  )
                }),
                (c.prototype.bitLength = function () {
                  var k = this.words[this.length - 1],
                    v = this._countBits(k)
                  return 26 * (this.length - 1) + v
                }),
                (c.prototype.zeroBits = function () {
                  if (this.isZero()) return 0
                  for (var k = 0, v = 0; v < this.length; v++) {
                    var x = this._zeroBits(this.words[v])
                    if (((k += x), x !== 26)) break
                  }
                  return k
                }),
                (c.prototype.byteLength = function () {
                  return Math.ceil(this.bitLength() / 8)
                }),
                (c.prototype.toTwos = function (k) {
                  return this.negative !== 0 ? this.abs().inotn(k).iaddn(1) : this.clone()
                }),
                (c.prototype.fromTwos = function (k) {
                  return this.testn(k - 1) ? this.notn(k).iaddn(1).ineg() : this.clone()
                }),
                (c.prototype.isNeg = function () {
                  return this.negative !== 0
                }),
                (c.prototype.neg = function () {
                  return this.clone().ineg()
                }),
                (c.prototype.ineg = function () {
                  return (this.isZero() || (this.negative ^= 1), this)
                }),
                (c.prototype.iuor = function (k) {
                  for (; this.length < k.length; ) this.words[this.length++] = 0
                  for (var v = 0; v < k.length; v++) this.words[v] = this.words[v] | k.words[v]
                  return this._strip()
                }),
                (c.prototype.ior = function (k) {
                  return (a((this.negative | k.negative) == 0), this.iuor(k))
                }),
                (c.prototype.or = function (k) {
                  return this.length > k.length ? this.clone().ior(k) : k.clone().ior(this)
                }),
                (c.prototype.uor = function (k) {
                  return this.length > k.length ? this.clone().iuor(k) : k.clone().iuor(this)
                }),
                (c.prototype.iuand = function (k) {
                  var v
                  v = this.length > k.length ? k : this
                  for (var x = 0; x < v.length; x++) this.words[x] = this.words[x] & k.words[x]
                  return ((this.length = v.length), this._strip())
                }),
                (c.prototype.iand = function (k) {
                  return (a((this.negative | k.negative) == 0), this.iuand(k))
                }),
                (c.prototype.and = function (k) {
                  return this.length > k.length ? this.clone().iand(k) : k.clone().iand(this)
                }),
                (c.prototype.uand = function (k) {
                  return this.length > k.length ? this.clone().iuand(k) : k.clone().iuand(this)
                }),
                (c.prototype.iuxor = function (k) {
                  var v, x
                  this.length > k.length ? ((v = this), (x = k)) : ((v = k), (x = this))
                  for (var _ = 0; _ < x.length; _++) this.words[_] = v.words[_] ^ x.words[_]
                  if (this !== v) for (; _ < v.length; _++) this.words[_] = v.words[_]
                  return ((this.length = v.length), this._strip())
                }),
                (c.prototype.ixor = function (k) {
                  return (a((this.negative | k.negative) == 0), this.iuxor(k))
                }),
                (c.prototype.xor = function (k) {
                  return this.length > k.length ? this.clone().ixor(k) : k.clone().ixor(this)
                }),
                (c.prototype.uxor = function (k) {
                  return this.length > k.length ? this.clone().iuxor(k) : k.clone().iuxor(this)
                }),
                (c.prototype.inotn = function (k) {
                  a(typeof k == 'number' && k >= 0)
                  var v = 0 | Math.ceil(k / 26),
                    x = k % 26
                  ;(this._expand(v), x > 0 && v--)
                  for (var _ = 0; _ < v; _++) this.words[_] = 67108863 & ~this.words[_]
                  return (
                    x > 0 && (this.words[_] = ~this.words[_] & (67108863 >> (26 - x))),
                    this._strip()
                  )
                }),
                (c.prototype.notn = function (k) {
                  return this.clone().inotn(k)
                }),
                (c.prototype.setn = function (k, v) {
                  a(typeof k == 'number' && k >= 0)
                  var x = (k / 26) | 0,
                    _ = k % 26
                  return (
                    this._expand(x + 1),
                    (this.words[x] = v ? this.words[x] | (1 << _) : this.words[x] & ~(1 << _)),
                    this._strip()
                  )
                }),
                (c.prototype.iadd = function (k) {
                  var v, x, _
                  if (this.negative !== 0 && k.negative === 0)
                    return (
                      (this.negative = 0),
                      (v = this.isub(k)),
                      (this.negative ^= 1),
                      this._normSign()
                    )
                  if (this.negative === 0 && k.negative !== 0)
                    return ((k.negative = 0), (v = this.isub(k)), (k.negative = 1), v._normSign())
                  this.length > k.length ? ((x = this), (_ = k)) : ((x = k), (_ = this))
                  for (var S = 0, A = 0; A < _.length; A++)
                    ((v = (0 | x.words[A]) + (0 | _.words[A]) + S),
                      (this.words[A] = 67108863 & v),
                      (S = v >>> 26))
                  for (; S !== 0 && A < x.length; A++)
                    ((v = (0 | x.words[A]) + S), (this.words[A] = 67108863 & v), (S = v >>> 26))
                  if (((this.length = x.length), S !== 0))
                    ((this.words[this.length] = S), this.length++)
                  else if (x !== this) for (; A < x.length; A++) this.words[A] = x.words[A]
                  return this
                }),
                (c.prototype.add = function (k) {
                  var v
                  return k.negative !== 0 && this.negative === 0
                    ? ((k.negative = 0), (v = this.sub(k)), (k.negative ^= 1), v)
                    : k.negative === 0 && this.negative !== 0
                      ? ((this.negative = 0), (v = k.sub(this)), (this.negative = 1), v)
                      : this.length > k.length
                        ? this.clone().iadd(k)
                        : k.clone().iadd(this)
                }),
                (c.prototype.isub = function (k) {
                  if (k.negative !== 0) {
                    k.negative = 0
                    var v = this.iadd(k)
                    return ((k.negative = 1), v._normSign())
                  }
                  if (this.negative !== 0)
                    return (
                      (this.negative = 0),
                      this.iadd(k),
                      (this.negative = 1),
                      this._normSign()
                    )
                  var x,
                    _,
                    S = this.cmp(k)
                  if (S === 0)
                    return ((this.negative = 0), (this.length = 1), (this.words[0] = 0), this)
                  S > 0 ? ((x = this), (_ = k)) : ((x = k), (_ = this))
                  for (var A = 0, j = 0; j < _.length; j++)
                    ((A = (v = (0 | x.words[j]) - (0 | _.words[j]) + A) >> 26),
                      (this.words[j] = 67108863 & v))
                  for (; A !== 0 && j < x.length; j++)
                    ((A = (v = (0 | x.words[j]) + A) >> 26), (this.words[j] = 67108863 & v))
                  if (A === 0 && j < x.length && x !== this)
                    for (; j < x.length; j++) this.words[j] = x.words[j]
                  return (
                    (this.length = Math.max(this.length, j)),
                    x !== this && (this.negative = 1),
                    this._strip()
                  )
                }),
                (c.prototype.sub = function (k) {
                  return this.clone().isub(k)
                }))
              var C = function (k, v, x) {
                var _,
                  S,
                  A,
                  j = k.words,
                  L = v.words,
                  H = x.words,
                  U = 0,
                  K = 0 | j[0],
                  z = 8191 & K,
                  q = K >>> 13,
                  D = 0 | j[1],
                  N = 8191 & D,
                  V = D >>> 13,
                  W = 0 | j[2],
                  J = 8191 & W,
                  G = W >>> 13,
                  Z = 0 | j[3],
                  rt = 8191 & Z,
                  nt = Z >>> 13,
                  X = 0 | j[4],
                  Q = 8191 & X,
                  tt = X >>> 13,
                  st = 0 | j[5],
                  ot = 8191 & st,
                  at = st >>> 13,
                  ht = 0 | j[6],
                  dt = 8191 & ht,
                  mt = ht >>> 13,
                  bt = 0 | j[7],
                  yt = 8191 & bt,
                  vt = bt >>> 13,
                  Nt = 0 | j[8],
                  Dt = 8191 & Nt,
                  Mt = Nt >>> 13,
                  Ot = 0 | j[9],
                  Ct = 8191 & Ot,
                  xt = Ot >>> 13,
                  Rt = 0 | L[0],
                  It = 8191 & Rt,
                  Pt = Rt >>> 13,
                  ae = 0 | L[1],
                  Se = 8191 & ae,
                  zt = ae >>> 13,
                  be = 0 | L[2],
                  Ut = 8191 & be,
                  Lt = be >>> 13,
                  le = 0 | L[3],
                  ce = 8191 & le,
                  Ft = le >>> 13,
                  Qt = 0 | L[4],
                  fe = 8191 & Qt,
                  qt = Qt >>> 13,
                  Jt = 0 | L[5],
                  me = 8191 & Jt,
                  Wt = Jt >>> 13,
                  it = 0 | L[6],
                  ct = 8191 & it,
                  pt = it >>> 13,
                  _t = 0 | L[7],
                  Vt = 8191 & _t,
                  Tt = _t >>> 13,
                  te = 0 | L[8],
                  Gt = 8191 & te,
                  Ht = te >>> 13,
                  ie = 0 | L[9],
                  ee = 8191 & ie,
                  de = ie >>> 13
                ;((x.negative = k.negative ^ v.negative), (x.length = 19))
                var Le =
                  (((U + (_ = Math.imul(z, It))) | 0) +
                    ((8191 & (S = ((S = Math.imul(z, Pt)) + Math.imul(q, It)) | 0)) << 13)) |
                  0
                ;((U = ((((A = Math.imul(q, Pt)) + (S >>> 13)) | 0) + (Le >>> 26)) | 0),
                  (Le &= 67108863),
                  (_ = Math.imul(N, It)),
                  (S = ((S = Math.imul(N, Pt)) + Math.imul(V, It)) | 0),
                  (A = Math.imul(V, Pt)))
                var Te =
                  (((U + (_ = (_ + Math.imul(z, Se)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, zt)) | 0) + Math.imul(q, Se)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, zt)) | 0) + (S >>> 13)) | 0) + (Te >>> 26)) | 0),
                  (Te &= 67108863),
                  (_ = Math.imul(J, It)),
                  (S = ((S = Math.imul(J, Pt)) + Math.imul(G, It)) | 0),
                  (A = Math.imul(G, Pt)),
                  (_ = (_ + Math.imul(N, Se)) | 0),
                  (S = ((S = (S + Math.imul(N, zt)) | 0) + Math.imul(V, Se)) | 0),
                  (A = (A + Math.imul(V, zt)) | 0))
                var Ge =
                  (((U + (_ = (_ + Math.imul(z, Ut)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, Lt)) | 0) + Math.imul(q, Ut)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, Lt)) | 0) + (S >>> 13)) | 0) + (Ge >>> 26)) | 0),
                  (Ge &= 67108863),
                  (_ = Math.imul(rt, It)),
                  (S = ((S = Math.imul(rt, Pt)) + Math.imul(nt, It)) | 0),
                  (A = Math.imul(nt, Pt)),
                  (_ = (_ + Math.imul(J, Se)) | 0),
                  (S = ((S = (S + Math.imul(J, zt)) | 0) + Math.imul(G, Se)) | 0),
                  (A = (A + Math.imul(G, zt)) | 0),
                  (_ = (_ + Math.imul(N, Ut)) | 0),
                  (S = ((S = (S + Math.imul(N, Lt)) | 0) + Math.imul(V, Ut)) | 0),
                  (A = (A + Math.imul(V, Lt)) | 0))
                var Xe =
                  (((U + (_ = (_ + Math.imul(z, ce)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, Ft)) | 0) + Math.imul(q, ce)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, Ft)) | 0) + (S >>> 13)) | 0) + (Xe >>> 26)) | 0),
                  (Xe &= 67108863),
                  (_ = Math.imul(Q, It)),
                  (S = ((S = Math.imul(Q, Pt)) + Math.imul(tt, It)) | 0),
                  (A = Math.imul(tt, Pt)),
                  (_ = (_ + Math.imul(rt, Se)) | 0),
                  (S = ((S = (S + Math.imul(rt, zt)) | 0) + Math.imul(nt, Se)) | 0),
                  (A = (A + Math.imul(nt, zt)) | 0),
                  (_ = (_ + Math.imul(J, Ut)) | 0),
                  (S = ((S = (S + Math.imul(J, Lt)) | 0) + Math.imul(G, Ut)) | 0),
                  (A = (A + Math.imul(G, Lt)) | 0),
                  (_ = (_ + Math.imul(N, ce)) | 0),
                  (S = ((S = (S + Math.imul(N, Ft)) | 0) + Math.imul(V, ce)) | 0),
                  (A = (A + Math.imul(V, Ft)) | 0))
                var pn =
                  (((U + (_ = (_ + Math.imul(z, fe)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, qt)) | 0) + Math.imul(q, fe)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, qt)) | 0) + (S >>> 13)) | 0) + (pn >>> 26)) | 0),
                  (pn &= 67108863),
                  (_ = Math.imul(ot, It)),
                  (S = ((S = Math.imul(ot, Pt)) + Math.imul(at, It)) | 0),
                  (A = Math.imul(at, Pt)),
                  (_ = (_ + Math.imul(Q, Se)) | 0),
                  (S = ((S = (S + Math.imul(Q, zt)) | 0) + Math.imul(tt, Se)) | 0),
                  (A = (A + Math.imul(tt, zt)) | 0),
                  (_ = (_ + Math.imul(rt, Ut)) | 0),
                  (S = ((S = (S + Math.imul(rt, Lt)) | 0) + Math.imul(nt, Ut)) | 0),
                  (A = (A + Math.imul(nt, Lt)) | 0),
                  (_ = (_ + Math.imul(J, ce)) | 0),
                  (S = ((S = (S + Math.imul(J, Ft)) | 0) + Math.imul(G, ce)) | 0),
                  (A = (A + Math.imul(G, Ft)) | 0),
                  (_ = (_ + Math.imul(N, fe)) | 0),
                  (S = ((S = (S + Math.imul(N, qt)) | 0) + Math.imul(V, fe)) | 0),
                  (A = (A + Math.imul(V, qt)) | 0))
                var et =
                  (((U + (_ = (_ + Math.imul(z, me)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, Wt)) | 0) + Math.imul(q, me)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, Wt)) | 0) + (S >>> 13)) | 0) + (et >>> 26)) | 0),
                  (et &= 67108863),
                  (_ = Math.imul(dt, It)),
                  (S = ((S = Math.imul(dt, Pt)) + Math.imul(mt, It)) | 0),
                  (A = Math.imul(mt, Pt)),
                  (_ = (_ + Math.imul(ot, Se)) | 0),
                  (S = ((S = (S + Math.imul(ot, zt)) | 0) + Math.imul(at, Se)) | 0),
                  (A = (A + Math.imul(at, zt)) | 0),
                  (_ = (_ + Math.imul(Q, Ut)) | 0),
                  (S = ((S = (S + Math.imul(Q, Lt)) | 0) + Math.imul(tt, Ut)) | 0),
                  (A = (A + Math.imul(tt, Lt)) | 0),
                  (_ = (_ + Math.imul(rt, ce)) | 0),
                  (S = ((S = (S + Math.imul(rt, Ft)) | 0) + Math.imul(nt, ce)) | 0),
                  (A = (A + Math.imul(nt, Ft)) | 0),
                  (_ = (_ + Math.imul(J, fe)) | 0),
                  (S = ((S = (S + Math.imul(J, qt)) | 0) + Math.imul(G, fe)) | 0),
                  (A = (A + Math.imul(G, qt)) | 0),
                  (_ = (_ + Math.imul(N, me)) | 0),
                  (S = ((S = (S + Math.imul(N, Wt)) | 0) + Math.imul(V, me)) | 0),
                  (A = (A + Math.imul(V, Wt)) | 0))
                var ft =
                  (((U + (_ = (_ + Math.imul(z, ct)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, pt)) | 0) + Math.imul(q, ct)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, pt)) | 0) + (S >>> 13)) | 0) + (ft >>> 26)) | 0),
                  (ft &= 67108863),
                  (_ = Math.imul(yt, It)),
                  (S = ((S = Math.imul(yt, Pt)) + Math.imul(vt, It)) | 0),
                  (A = Math.imul(vt, Pt)),
                  (_ = (_ + Math.imul(dt, Se)) | 0),
                  (S = ((S = (S + Math.imul(dt, zt)) | 0) + Math.imul(mt, Se)) | 0),
                  (A = (A + Math.imul(mt, zt)) | 0),
                  (_ = (_ + Math.imul(ot, Ut)) | 0),
                  (S = ((S = (S + Math.imul(ot, Lt)) | 0) + Math.imul(at, Ut)) | 0),
                  (A = (A + Math.imul(at, Lt)) | 0),
                  (_ = (_ + Math.imul(Q, ce)) | 0),
                  (S = ((S = (S + Math.imul(Q, Ft)) | 0) + Math.imul(tt, ce)) | 0),
                  (A = (A + Math.imul(tt, Ft)) | 0),
                  (_ = (_ + Math.imul(rt, fe)) | 0),
                  (S = ((S = (S + Math.imul(rt, qt)) | 0) + Math.imul(nt, fe)) | 0),
                  (A = (A + Math.imul(nt, qt)) | 0),
                  (_ = (_ + Math.imul(J, me)) | 0),
                  (S = ((S = (S + Math.imul(J, Wt)) | 0) + Math.imul(G, me)) | 0),
                  (A = (A + Math.imul(G, Wt)) | 0),
                  (_ = (_ + Math.imul(N, ct)) | 0),
                  (S = ((S = (S + Math.imul(N, pt)) | 0) + Math.imul(V, ct)) | 0),
                  (A = (A + Math.imul(V, pt)) | 0))
                var gt =
                  (((U + (_ = (_ + Math.imul(z, Vt)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, Tt)) | 0) + Math.imul(q, Vt)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, Tt)) | 0) + (S >>> 13)) | 0) + (gt >>> 26)) | 0),
                  (gt &= 67108863),
                  (_ = Math.imul(Dt, It)),
                  (S = ((S = Math.imul(Dt, Pt)) + Math.imul(Mt, It)) | 0),
                  (A = Math.imul(Mt, Pt)),
                  (_ = (_ + Math.imul(yt, Se)) | 0),
                  (S = ((S = (S + Math.imul(yt, zt)) | 0) + Math.imul(vt, Se)) | 0),
                  (A = (A + Math.imul(vt, zt)) | 0),
                  (_ = (_ + Math.imul(dt, Ut)) | 0),
                  (S = ((S = (S + Math.imul(dt, Lt)) | 0) + Math.imul(mt, Ut)) | 0),
                  (A = (A + Math.imul(mt, Lt)) | 0),
                  (_ = (_ + Math.imul(ot, ce)) | 0),
                  (S = ((S = (S + Math.imul(ot, Ft)) | 0) + Math.imul(at, ce)) | 0),
                  (A = (A + Math.imul(at, Ft)) | 0),
                  (_ = (_ + Math.imul(Q, fe)) | 0),
                  (S = ((S = (S + Math.imul(Q, qt)) | 0) + Math.imul(tt, fe)) | 0),
                  (A = (A + Math.imul(tt, qt)) | 0),
                  (_ = (_ + Math.imul(rt, me)) | 0),
                  (S = ((S = (S + Math.imul(rt, Wt)) | 0) + Math.imul(nt, me)) | 0),
                  (A = (A + Math.imul(nt, Wt)) | 0),
                  (_ = (_ + Math.imul(J, ct)) | 0),
                  (S = ((S = (S + Math.imul(J, pt)) | 0) + Math.imul(G, ct)) | 0),
                  (A = (A + Math.imul(G, pt)) | 0),
                  (_ = (_ + Math.imul(N, Vt)) | 0),
                  (S = ((S = (S + Math.imul(N, Tt)) | 0) + Math.imul(V, Vt)) | 0),
                  (A = (A + Math.imul(V, Tt)) | 0))
                var wt =
                  (((U + (_ = (_ + Math.imul(z, Gt)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, Ht)) | 0) + Math.imul(q, Gt)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, Ht)) | 0) + (S >>> 13)) | 0) + (wt >>> 26)) | 0),
                  (wt &= 67108863),
                  (_ = Math.imul(Ct, It)),
                  (S = ((S = Math.imul(Ct, Pt)) + Math.imul(xt, It)) | 0),
                  (A = Math.imul(xt, Pt)),
                  (_ = (_ + Math.imul(Dt, Se)) | 0),
                  (S = ((S = (S + Math.imul(Dt, zt)) | 0) + Math.imul(Mt, Se)) | 0),
                  (A = (A + Math.imul(Mt, zt)) | 0),
                  (_ = (_ + Math.imul(yt, Ut)) | 0),
                  (S = ((S = (S + Math.imul(yt, Lt)) | 0) + Math.imul(vt, Ut)) | 0),
                  (A = (A + Math.imul(vt, Lt)) | 0),
                  (_ = (_ + Math.imul(dt, ce)) | 0),
                  (S = ((S = (S + Math.imul(dt, Ft)) | 0) + Math.imul(mt, ce)) | 0),
                  (A = (A + Math.imul(mt, Ft)) | 0),
                  (_ = (_ + Math.imul(ot, fe)) | 0),
                  (S = ((S = (S + Math.imul(ot, qt)) | 0) + Math.imul(at, fe)) | 0),
                  (A = (A + Math.imul(at, qt)) | 0),
                  (_ = (_ + Math.imul(Q, me)) | 0),
                  (S = ((S = (S + Math.imul(Q, Wt)) | 0) + Math.imul(tt, me)) | 0),
                  (A = (A + Math.imul(tt, Wt)) | 0),
                  (_ = (_ + Math.imul(rt, ct)) | 0),
                  (S = ((S = (S + Math.imul(rt, pt)) | 0) + Math.imul(nt, ct)) | 0),
                  (A = (A + Math.imul(nt, pt)) | 0),
                  (_ = (_ + Math.imul(J, Vt)) | 0),
                  (S = ((S = (S + Math.imul(J, Tt)) | 0) + Math.imul(G, Vt)) | 0),
                  (A = (A + Math.imul(G, Tt)) | 0),
                  (_ = (_ + Math.imul(N, Gt)) | 0),
                  (S = ((S = (S + Math.imul(N, Ht)) | 0) + Math.imul(V, Gt)) | 0),
                  (A = (A + Math.imul(V, Ht)) | 0))
                var $t =
                  (((U + (_ = (_ + Math.imul(z, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(z, de)) | 0) + Math.imul(q, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(q, de)) | 0) + (S >>> 13)) | 0) + ($t >>> 26)) | 0),
                  ($t &= 67108863),
                  (_ = Math.imul(Ct, Se)),
                  (S = ((S = Math.imul(Ct, zt)) + Math.imul(xt, Se)) | 0),
                  (A = Math.imul(xt, zt)),
                  (_ = (_ + Math.imul(Dt, Ut)) | 0),
                  (S = ((S = (S + Math.imul(Dt, Lt)) | 0) + Math.imul(Mt, Ut)) | 0),
                  (A = (A + Math.imul(Mt, Lt)) | 0),
                  (_ = (_ + Math.imul(yt, ce)) | 0),
                  (S = ((S = (S + Math.imul(yt, Ft)) | 0) + Math.imul(vt, ce)) | 0),
                  (A = (A + Math.imul(vt, Ft)) | 0),
                  (_ = (_ + Math.imul(dt, fe)) | 0),
                  (S = ((S = (S + Math.imul(dt, qt)) | 0) + Math.imul(mt, fe)) | 0),
                  (A = (A + Math.imul(mt, qt)) | 0),
                  (_ = (_ + Math.imul(ot, me)) | 0),
                  (S = ((S = (S + Math.imul(ot, Wt)) | 0) + Math.imul(at, me)) | 0),
                  (A = (A + Math.imul(at, Wt)) | 0),
                  (_ = (_ + Math.imul(Q, ct)) | 0),
                  (S = ((S = (S + Math.imul(Q, pt)) | 0) + Math.imul(tt, ct)) | 0),
                  (A = (A + Math.imul(tt, pt)) | 0),
                  (_ = (_ + Math.imul(rt, Vt)) | 0),
                  (S = ((S = (S + Math.imul(rt, Tt)) | 0) + Math.imul(nt, Vt)) | 0),
                  (A = (A + Math.imul(nt, Tt)) | 0),
                  (_ = (_ + Math.imul(J, Gt)) | 0),
                  (S = ((S = (S + Math.imul(J, Ht)) | 0) + Math.imul(G, Gt)) | 0),
                  (A = (A + Math.imul(G, Ht)) | 0))
                var Et =
                  (((U + (_ = (_ + Math.imul(N, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(N, de)) | 0) + Math.imul(V, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(V, de)) | 0) + (S >>> 13)) | 0) + (Et >>> 26)) | 0),
                  (Et &= 67108863),
                  (_ = Math.imul(Ct, Ut)),
                  (S = ((S = Math.imul(Ct, Lt)) + Math.imul(xt, Ut)) | 0),
                  (A = Math.imul(xt, Lt)),
                  (_ = (_ + Math.imul(Dt, ce)) | 0),
                  (S = ((S = (S + Math.imul(Dt, Ft)) | 0) + Math.imul(Mt, ce)) | 0),
                  (A = (A + Math.imul(Mt, Ft)) | 0),
                  (_ = (_ + Math.imul(yt, fe)) | 0),
                  (S = ((S = (S + Math.imul(yt, qt)) | 0) + Math.imul(vt, fe)) | 0),
                  (A = (A + Math.imul(vt, qt)) | 0),
                  (_ = (_ + Math.imul(dt, me)) | 0),
                  (S = ((S = (S + Math.imul(dt, Wt)) | 0) + Math.imul(mt, me)) | 0),
                  (A = (A + Math.imul(mt, Wt)) | 0),
                  (_ = (_ + Math.imul(ot, ct)) | 0),
                  (S = ((S = (S + Math.imul(ot, pt)) | 0) + Math.imul(at, ct)) | 0),
                  (A = (A + Math.imul(at, pt)) | 0),
                  (_ = (_ + Math.imul(Q, Vt)) | 0),
                  (S = ((S = (S + Math.imul(Q, Tt)) | 0) + Math.imul(tt, Vt)) | 0),
                  (A = (A + Math.imul(tt, Tt)) | 0),
                  (_ = (_ + Math.imul(rt, Gt)) | 0),
                  (S = ((S = (S + Math.imul(rt, Ht)) | 0) + Math.imul(nt, Gt)) | 0),
                  (A = (A + Math.imul(nt, Ht)) | 0))
                var At =
                  (((U + (_ = (_ + Math.imul(J, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(J, de)) | 0) + Math.imul(G, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(G, de)) | 0) + (S >>> 13)) | 0) + (At >>> 26)) | 0),
                  (At &= 67108863),
                  (_ = Math.imul(Ct, ce)),
                  (S = ((S = Math.imul(Ct, Ft)) + Math.imul(xt, ce)) | 0),
                  (A = Math.imul(xt, Ft)),
                  (_ = (_ + Math.imul(Dt, fe)) | 0),
                  (S = ((S = (S + Math.imul(Dt, qt)) | 0) + Math.imul(Mt, fe)) | 0),
                  (A = (A + Math.imul(Mt, qt)) | 0),
                  (_ = (_ + Math.imul(yt, me)) | 0),
                  (S = ((S = (S + Math.imul(yt, Wt)) | 0) + Math.imul(vt, me)) | 0),
                  (A = (A + Math.imul(vt, Wt)) | 0),
                  (_ = (_ + Math.imul(dt, ct)) | 0),
                  (S = ((S = (S + Math.imul(dt, pt)) | 0) + Math.imul(mt, ct)) | 0),
                  (A = (A + Math.imul(mt, pt)) | 0),
                  (_ = (_ + Math.imul(ot, Vt)) | 0),
                  (S = ((S = (S + Math.imul(ot, Tt)) | 0) + Math.imul(at, Vt)) | 0),
                  (A = (A + Math.imul(at, Tt)) | 0),
                  (_ = (_ + Math.imul(Q, Gt)) | 0),
                  (S = ((S = (S + Math.imul(Q, Ht)) | 0) + Math.imul(tt, Gt)) | 0),
                  (A = (A + Math.imul(tt, Ht)) | 0))
                var ve =
                  (((U + (_ = (_ + Math.imul(rt, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(rt, de)) | 0) + Math.imul(nt, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(nt, de)) | 0) + (S >>> 13)) | 0) + (ve >>> 26)) | 0),
                  (ve &= 67108863),
                  (_ = Math.imul(Ct, fe)),
                  (S = ((S = Math.imul(Ct, qt)) + Math.imul(xt, fe)) | 0),
                  (A = Math.imul(xt, qt)),
                  (_ = (_ + Math.imul(Dt, me)) | 0),
                  (S = ((S = (S + Math.imul(Dt, Wt)) | 0) + Math.imul(Mt, me)) | 0),
                  (A = (A + Math.imul(Mt, Wt)) | 0),
                  (_ = (_ + Math.imul(yt, ct)) | 0),
                  (S = ((S = (S + Math.imul(yt, pt)) | 0) + Math.imul(vt, ct)) | 0),
                  (A = (A + Math.imul(vt, pt)) | 0),
                  (_ = (_ + Math.imul(dt, Vt)) | 0),
                  (S = ((S = (S + Math.imul(dt, Tt)) | 0) + Math.imul(mt, Vt)) | 0),
                  (A = (A + Math.imul(mt, Tt)) | 0),
                  (_ = (_ + Math.imul(ot, Gt)) | 0),
                  (S = ((S = (S + Math.imul(ot, Ht)) | 0) + Math.imul(at, Gt)) | 0),
                  (A = (A + Math.imul(at, Ht)) | 0))
                var ue =
                  (((U + (_ = (_ + Math.imul(Q, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(Q, de)) | 0) + Math.imul(tt, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(tt, de)) | 0) + (S >>> 13)) | 0) + (ue >>> 26)) | 0),
                  (ue &= 67108863),
                  (_ = Math.imul(Ct, me)),
                  (S = ((S = Math.imul(Ct, Wt)) + Math.imul(xt, me)) | 0),
                  (A = Math.imul(xt, Wt)),
                  (_ = (_ + Math.imul(Dt, ct)) | 0),
                  (S = ((S = (S + Math.imul(Dt, pt)) | 0) + Math.imul(Mt, ct)) | 0),
                  (A = (A + Math.imul(Mt, pt)) | 0),
                  (_ = (_ + Math.imul(yt, Vt)) | 0),
                  (S = ((S = (S + Math.imul(yt, Tt)) | 0) + Math.imul(vt, Vt)) | 0),
                  (A = (A + Math.imul(vt, Tt)) | 0),
                  (_ = (_ + Math.imul(dt, Gt)) | 0),
                  (S = ((S = (S + Math.imul(dt, Ht)) | 0) + Math.imul(mt, Gt)) | 0),
                  (A = (A + Math.imul(mt, Ht)) | 0))
                var he =
                  (((U + (_ = (_ + Math.imul(ot, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(ot, de)) | 0) + Math.imul(at, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(at, de)) | 0) + (S >>> 13)) | 0) + (he >>> 26)) | 0),
                  (he &= 67108863),
                  (_ = Math.imul(Ct, ct)),
                  (S = ((S = Math.imul(Ct, pt)) + Math.imul(xt, ct)) | 0),
                  (A = Math.imul(xt, pt)),
                  (_ = (_ + Math.imul(Dt, Vt)) | 0),
                  (S = ((S = (S + Math.imul(Dt, Tt)) | 0) + Math.imul(Mt, Vt)) | 0),
                  (A = (A + Math.imul(Mt, Tt)) | 0),
                  (_ = (_ + Math.imul(yt, Gt)) | 0),
                  (S = ((S = (S + Math.imul(yt, Ht)) | 0) + Math.imul(vt, Gt)) | 0),
                  (A = (A + Math.imul(vt, Ht)) | 0))
                var Kt =
                  (((U + (_ = (_ + Math.imul(dt, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(dt, de)) | 0) + Math.imul(mt, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(mt, de)) | 0) + (S >>> 13)) | 0) + (Kt >>> 26)) | 0),
                  (Kt &= 67108863),
                  (_ = Math.imul(Ct, Vt)),
                  (S = ((S = Math.imul(Ct, Tt)) + Math.imul(xt, Vt)) | 0),
                  (A = Math.imul(xt, Tt)),
                  (_ = (_ + Math.imul(Dt, Gt)) | 0),
                  (S = ((S = (S + Math.imul(Dt, Ht)) | 0) + Math.imul(Mt, Gt)) | 0),
                  (A = (A + Math.imul(Mt, Ht)) | 0))
                var Ce =
                  (((U + (_ = (_ + Math.imul(yt, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(yt, de)) | 0) + Math.imul(vt, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(vt, de)) | 0) + (S >>> 13)) | 0) + (Ce >>> 26)) | 0),
                  (Ce &= 67108863),
                  (_ = Math.imul(Ct, Gt)),
                  (S = ((S = Math.imul(Ct, Ht)) + Math.imul(xt, Gt)) | 0),
                  (A = Math.imul(xt, Ht)))
                var Me =
                  (((U + (_ = (_ + Math.imul(Dt, ee)) | 0)) | 0) +
                    ((8191 & (S = ((S = (S + Math.imul(Dt, de)) | 0) + Math.imul(Mt, ee)) | 0)) <<
                      13)) |
                  0
                ;((U = ((((A = (A + Math.imul(Mt, de)) | 0) + (S >>> 13)) | 0) + (Me >>> 26)) | 0),
                  (Me &= 67108863))
                var Ae =
                  (((U + (_ = Math.imul(Ct, ee))) | 0) +
                    ((8191 & (S = ((S = Math.imul(Ct, de)) + Math.imul(xt, ee)) | 0)) << 13)) |
                  0
                return (
                  (U = ((((A = Math.imul(xt, de)) + (S >>> 13)) | 0) + (Ae >>> 26)) | 0),
                  (Ae &= 67108863),
                  (H[0] = Le),
                  (H[1] = Te),
                  (H[2] = Ge),
                  (H[3] = Xe),
                  (H[4] = pn),
                  (H[5] = et),
                  (H[6] = ft),
                  (H[7] = gt),
                  (H[8] = wt),
                  (H[9] = $t),
                  (H[10] = Et),
                  (H[11] = At),
                  (H[12] = ve),
                  (H[13] = ue),
                  (H[14] = he),
                  (H[15] = Kt),
                  (H[16] = Ce),
                  (H[17] = Me),
                  (H[18] = Ae),
                  U !== 0 && ((H[19] = U), x.length++),
                  x
                )
              }
              function T(k, v, x) {
                ;((x.negative = v.negative ^ k.negative), (x.length = k.length + v.length))
                for (var _ = 0, S = 0, A = 0; A < x.length - 1; A++) {
                  var j = S
                  S = 0
                  for (
                    var L = 67108863 & _,
                      H = Math.min(A, v.length - 1),
                      U = Math.max(0, A - k.length + 1);
                    U <= H;
                    U++
                  ) {
                    var K = A - U,
                      z = (0 | k.words[K]) * (0 | v.words[U]),
                      q = 67108863 & z
                    ;((L = 67108863 & (q = (q + L) | 0)),
                      (S += (j = ((j = (j + ((z / 67108864) | 0)) | 0) + (q >>> 26)) | 0) >>> 26),
                      (j &= 67108863))
                  }
                  ;((x.words[A] = L), (_ = j), (j = S))
                }
                return (_ !== 0 ? (x.words[A] = _) : x.length--, x._strip())
              }
              function I(k, v, x) {
                return T(k, v, x)
              }
              ;(Math.imul || (C = w),
                (c.prototype.mulTo = function (k, v) {
                  var x = this.length + k.length
                  return this.length === 10 && k.length === 10
                    ? C(this, k, v)
                    : x < 63
                      ? w(this, k, v)
                      : x < 1024
                        ? T(this, k, v)
                        : I(this, k, v)
                }),
                (c.prototype.mul = function (k) {
                  var v = new c(null)
                  return ((v.words = new Array(this.length + k.length)), this.mulTo(k, v))
                }),
                (c.prototype.mulf = function (k) {
                  var v = new c(null)
                  return ((v.words = new Array(this.length + k.length)), I(this, k, v))
                }),
                (c.prototype.imul = function (k) {
                  return this.clone().mulTo(k, this)
                }),
                (c.prototype.imuln = function (k) {
                  var v = k < 0
                  ;(v && (k = -k), a(typeof k == 'number'), a(k < 67108864))
                  for (var x = 0, _ = 0; _ < this.length; _++) {
                    var S = (0 | this.words[_]) * k,
                      A = (67108863 & S) + (67108863 & x)
                    ;((x >>= 26),
                      (x += (S / 67108864) | 0),
                      (x += A >>> 26),
                      (this.words[_] = 67108863 & A))
                  }
                  return (x !== 0 && ((this.words[_] = x), this.length++), v ? this.ineg() : this)
                }),
                (c.prototype.muln = function (k) {
                  return this.clone().imuln(k)
                }),
                (c.prototype.sqr = function () {
                  return this.mul(this)
                }),
                (c.prototype.isqr = function () {
                  return this.imul(this.clone())
                }),
                (c.prototype.pow = function (k) {
                  var v = (function (A) {
                    for (var j = new Array(A.bitLength()), L = 0; L < j.length; L++) {
                      var H = (L / 26) | 0,
                        U = L % 26
                      j[L] = (A.words[H] >>> U) & 1
                    }
                    return j
                  })(k)
                  if (v.length === 0) return new c(1)
                  for (var x = this, _ = 0; _ < v.length && v[_] === 0; _++, x = x.sqr());
                  if (++_ < v.length)
                    for (var S = x.sqr(); _ < v.length; _++, S = S.sqr())
                      v[_] !== 0 && (x = x.mul(S))
                  return x
                }),
                (c.prototype.iushln = function (k) {
                  a(typeof k == 'number' && k >= 0)
                  var v,
                    x = k % 26,
                    _ = (k - x) / 26,
                    S = (67108863 >>> (26 - x)) << (26 - x)
                  if (x !== 0) {
                    var A = 0
                    for (v = 0; v < this.length; v++) {
                      var j = this.words[v] & S,
                        L = ((0 | this.words[v]) - j) << x
                      ;((this.words[v] = L | A), (A = j >>> (26 - x)))
                    }
                    A && ((this.words[v] = A), this.length++)
                  }
                  if (_ !== 0) {
                    for (v = this.length - 1; v >= 0; v--) this.words[v + _] = this.words[v]
                    for (v = 0; v < _; v++) this.words[v] = 0
                    this.length += _
                  }
                  return this._strip()
                }),
                (c.prototype.ishln = function (k) {
                  return (a(this.negative === 0), this.iushln(k))
                }),
                (c.prototype.iushrn = function (k, v, x) {
                  var _
                  ;(a(typeof k == 'number' && k >= 0), (_ = v ? (v - (v % 26)) / 26 : 0))
                  var S = k % 26,
                    A = Math.min((k - S) / 26, this.length),
                    j = 67108863 ^ ((67108863 >>> S) << S),
                    L = x
                  if (((_ -= A), (_ = Math.max(0, _)), L)) {
                    for (var H = 0; H < A; H++) L.words[H] = this.words[H]
                    L.length = A
                  }
                  if (A !== 0)
                    if (this.length > A)
                      for (this.length -= A, H = 0; H < this.length; H++)
                        this.words[H] = this.words[H + A]
                    else ((this.words[0] = 0), (this.length = 1))
                  var U = 0
                  for (H = this.length - 1; H >= 0 && (U !== 0 || H >= _); H--) {
                    var K = 0 | this.words[H]
                    ;((this.words[H] = (U << (26 - S)) | (K >>> S)), (U = K & j))
                  }
                  return (
                    L && U !== 0 && (L.words[L.length++] = U),
                    this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                    this._strip()
                  )
                }),
                (c.prototype.ishrn = function (k, v, x) {
                  return (a(this.negative === 0), this.iushrn(k, v, x))
                }),
                (c.prototype.shln = function (k) {
                  return this.clone().ishln(k)
                }),
                (c.prototype.ushln = function (k) {
                  return this.clone().iushln(k)
                }),
                (c.prototype.shrn = function (k) {
                  return this.clone().ishrn(k)
                }),
                (c.prototype.ushrn = function (k) {
                  return this.clone().iushrn(k)
                }),
                (c.prototype.testn = function (k) {
                  a(typeof k == 'number' && k >= 0)
                  var v = k % 26,
                    x = (k - v) / 26,
                    _ = 1 << v
                  return !(this.length <= x) && !!(this.words[x] & _)
                }),
                (c.prototype.imaskn = function (k) {
                  a(typeof k == 'number' && k >= 0)
                  var v = k % 26,
                    x = (k - v) / 26
                  if (
                    (a(this.negative === 0, 'imaskn works only with positive numbers'),
                    this.length <= x)
                  )
                    return this
                  if ((v !== 0 && x++, (this.length = Math.min(x, this.length)), v !== 0)) {
                    var _ = 67108863 ^ ((67108863 >>> v) << v)
                    this.words[this.length - 1] &= _
                  }
                  return this._strip()
                }),
                (c.prototype.maskn = function (k) {
                  return this.clone().imaskn(k)
                }),
                (c.prototype.iaddn = function (k) {
                  return (
                    a(typeof k == 'number'),
                    a(k < 67108864),
                    k < 0
                      ? this.isubn(-k)
                      : this.negative !== 0
                        ? this.length === 1 && (0 | this.words[0]) <= k
                          ? ((this.words[0] = k - (0 | this.words[0])), (this.negative = 0), this)
                          : ((this.negative = 0), this.isubn(k), (this.negative = 1), this)
                        : this._iaddn(k)
                  )
                }),
                (c.prototype._iaddn = function (k) {
                  this.words[0] += k
                  for (var v = 0; v < this.length && this.words[v] >= 67108864; v++)
                    ((this.words[v] -= 67108864),
                      v === this.length - 1 ? (this.words[v + 1] = 1) : this.words[v + 1]++)
                  return ((this.length = Math.max(this.length, v + 1)), this)
                }),
                (c.prototype.isubn = function (k) {
                  if ((a(typeof k == 'number'), a(k < 67108864), k < 0)) return this.iaddn(-k)
                  if (this.negative !== 0)
                    return ((this.negative = 0), this.iaddn(k), (this.negative = 1), this)
                  if (((this.words[0] -= k), this.length === 1 && this.words[0] < 0))
                    ((this.words[0] = -this.words[0]), (this.negative = 1))
                  else
                    for (var v = 0; v < this.length && this.words[v] < 0; v++)
                      ((this.words[v] += 67108864), (this.words[v + 1] -= 1))
                  return this._strip()
                }),
                (c.prototype.addn = function (k) {
                  return this.clone().iaddn(k)
                }),
                (c.prototype.subn = function (k) {
                  return this.clone().isubn(k)
                }),
                (c.prototype.iabs = function () {
                  return ((this.negative = 0), this)
                }),
                (c.prototype.abs = function () {
                  return this.clone().iabs()
                }),
                (c.prototype._ishlnsubmul = function (k, v, x) {
                  var _,
                    S,
                    A = k.length + x
                  this._expand(A)
                  var j = 0
                  for (_ = 0; _ < k.length; _++) {
                    S = (0 | this.words[_ + x]) + j
                    var L = (0 | k.words[_]) * v
                    ;((j = ((S -= 67108863 & L) >> 26) - ((L / 67108864) | 0)),
                      (this.words[_ + x] = 67108863 & S))
                  }
                  for (; _ < this.length - x; _++)
                    ((j = (S = (0 | this.words[_ + x]) + j) >> 26),
                      (this.words[_ + x] = 67108863 & S))
                  if (j === 0) return this._strip()
                  for (a(j === -1), j = 0, _ = 0; _ < this.length; _++)
                    ((j = (S = -(0 | this.words[_]) + j) >> 26), (this.words[_] = 67108863 & S))
                  return ((this.negative = 1), this._strip())
                }),
                (c.prototype._wordDiv = function (k, v) {
                  var x = (this.length, k.length),
                    _ = this.clone(),
                    S = k,
                    A = 0 | S.words[S.length - 1]
                  ;(x = 26 - this._countBits(A)) !== 0 &&
                    ((S = S.ushln(x)), _.iushln(x), (A = 0 | S.words[S.length - 1]))
                  var j,
                    L = _.length - S.length
                  if (v !== 'mod') {
                    ;(((j = new c(null)).length = L + 1), (j.words = new Array(j.length)))
                    for (var H = 0; H < j.length; H++) j.words[H] = 0
                  }
                  var U = _.clone()._ishlnsubmul(S, 1, L)
                  U.negative === 0 && ((_ = U), j && (j.words[L] = 1))
                  for (var K = L - 1; K >= 0; K--) {
                    var z = 67108864 * (0 | _.words[S.length + K]) + (0 | _.words[S.length + K - 1])
                    for (
                      z = Math.min((z / A) | 0, 67108863), _._ishlnsubmul(S, z, K);
                      _.negative !== 0;

                    )
                      (z--,
                        (_.negative = 0),
                        _._ishlnsubmul(S, 1, K),
                        _.isZero() || (_.negative ^= 1))
                    j && (j.words[K] = z)
                  }
                  return (
                    j && j._strip(),
                    _._strip(),
                    v !== 'div' && x !== 0 && _.iushrn(x),
                    { div: j || null, mod: _ }
                  )
                }),
                (c.prototype.divmod = function (k, v, x) {
                  return (
                    a(!k.isZero()),
                    this.isZero()
                      ? { div: new c(0), mod: new c(0) }
                      : this.negative !== 0 && k.negative === 0
                        ? ((A = this.neg().divmod(k, v)),
                          v !== 'mod' && (_ = A.div.neg()),
                          v !== 'div' && ((S = A.mod.neg()), x && S.negative !== 0 && S.iadd(k)),
                          { div: _, mod: S })
                        : this.negative === 0 && k.negative !== 0
                          ? ((A = this.divmod(k.neg(), v)),
                            v !== 'mod' && (_ = A.div.neg()),
                            { div: _, mod: A.mod })
                          : this.negative & k.negative
                            ? ((A = this.neg().divmod(k.neg(), v)),
                              v !== 'div' &&
                                ((S = A.mod.neg()), x && S.negative !== 0 && S.isub(k)),
                              { div: A.div, mod: S })
                            : k.length > this.length || this.cmp(k) < 0
                              ? { div: new c(0), mod: this }
                              : k.length === 1
                                ? v === 'div'
                                  ? { div: this.divn(k.words[0]), mod: null }
                                  : v === 'mod'
                                    ? { div: null, mod: new c(this.modrn(k.words[0])) }
                                    : {
                                        div: this.divn(k.words[0]),
                                        mod: new c(this.modrn(k.words[0])),
                                      }
                                : this._wordDiv(k, v)
                  )
                  var _, S, A
                }),
                (c.prototype.div = function (k) {
                  return this.divmod(k, 'div', !1).div
                }),
                (c.prototype.mod = function (k) {
                  return this.divmod(k, 'mod', !1).mod
                }),
                (c.prototype.umod = function (k) {
                  return this.divmod(k, 'mod', !0).mod
                }),
                (c.prototype.divRound = function (k) {
                  var v = this.divmod(k)
                  if (v.mod.isZero()) return v.div
                  var x = v.div.negative !== 0 ? v.mod.isub(k) : v.mod,
                    _ = k.ushrn(1),
                    S = k.andln(1),
                    A = x.cmp(_)
                  return A < 0 || (S === 1 && A === 0)
                    ? v.div
                    : v.div.negative !== 0
                      ? v.div.isubn(1)
                      : v.div.iaddn(1)
                }),
                (c.prototype.modrn = function (k) {
                  var v = k < 0
                  ;(v && (k = -k), a(k <= 67108863))
                  for (var x = (1 << 26) % k, _ = 0, S = this.length - 1; S >= 0; S--)
                    _ = (x * _ + (0 | this.words[S])) % k
                  return v ? -_ : _
                }),
                (c.prototype.modn = function (k) {
                  return this.modrn(k)
                }),
                (c.prototype.idivn = function (k) {
                  var v = k < 0
                  ;(v && (k = -k), a(k <= 67108863))
                  for (var x = 0, _ = this.length - 1; _ >= 0; _--) {
                    var S = (0 | this.words[_]) + 67108864 * x
                    ;((this.words[_] = (S / k) | 0), (x = S % k))
                  }
                  return (this._strip(), v ? this.ineg() : this)
                }),
                (c.prototype.divn = function (k) {
                  return this.clone().idivn(k)
                }),
                (c.prototype.egcd = function (k) {
                  ;(a(k.negative === 0), a(!k.isZero()))
                  var v = this,
                    x = k.clone()
                  v = v.negative !== 0 ? v.umod(k) : v.clone()
                  for (
                    var _ = new c(1), S = new c(0), A = new c(0), j = new c(1), L = 0;
                    v.isEven() && x.isEven();

                  )
                    (v.iushrn(1), x.iushrn(1), ++L)
                  for (var H = x.clone(), U = v.clone(); !v.isZero(); ) {
                    for (var K = 0, z = 1; !(v.words[0] & z) && K < 26; ++K, z <<= 1);
                    if (K > 0)
                      for (v.iushrn(K); K-- > 0; )
                        ((_.isOdd() || S.isOdd()) && (_.iadd(H), S.isub(U)),
                          _.iushrn(1),
                          S.iushrn(1))
                    for (var q = 0, D = 1; !(x.words[0] & D) && q < 26; ++q, D <<= 1);
                    if (q > 0)
                      for (x.iushrn(q); q-- > 0; )
                        ((A.isOdd() || j.isOdd()) && (A.iadd(H), j.isub(U)),
                          A.iushrn(1),
                          j.iushrn(1))
                    v.cmp(x) >= 0
                      ? (v.isub(x), _.isub(A), S.isub(j))
                      : (x.isub(v), A.isub(_), j.isub(S))
                  }
                  return { a: A, b: j, gcd: x.iushln(L) }
                }),
                (c.prototype._invmp = function (k) {
                  ;(a(k.negative === 0), a(!k.isZero()))
                  var v = this,
                    x = k.clone()
                  v = v.negative !== 0 ? v.umod(k) : v.clone()
                  for (
                    var _, S = new c(1), A = new c(0), j = x.clone();
                    v.cmpn(1) > 0 && x.cmpn(1) > 0;

                  ) {
                    for (var L = 0, H = 1; !(v.words[0] & H) && L < 26; ++L, H <<= 1);
                    if (L > 0) for (v.iushrn(L); L-- > 0; ) (S.isOdd() && S.iadd(j), S.iushrn(1))
                    for (var U = 0, K = 1; !(x.words[0] & K) && U < 26; ++U, K <<= 1);
                    if (U > 0) for (x.iushrn(U); U-- > 0; ) (A.isOdd() && A.iadd(j), A.iushrn(1))
                    v.cmp(x) >= 0 ? (v.isub(x), S.isub(A)) : (x.isub(v), A.isub(S))
                  }
                  return ((_ = v.cmpn(1) === 0 ? S : A).cmpn(0) < 0 && _.iadd(k), _)
                }),
                (c.prototype.gcd = function (k) {
                  if (this.isZero()) return k.abs()
                  if (k.isZero()) return this.abs()
                  var v = this.clone(),
                    x = k.clone()
                  ;((v.negative = 0), (x.negative = 0))
                  for (var _ = 0; v.isEven() && x.isEven(); _++) (v.iushrn(1), x.iushrn(1))
                  for (;;) {
                    for (; v.isEven(); ) v.iushrn(1)
                    for (; x.isEven(); ) x.iushrn(1)
                    var S = v.cmp(x)
                    if (S < 0) {
                      var A = v
                      ;((v = x), (x = A))
                    } else if (S === 0 || x.cmpn(1) === 0) break
                    v.isub(x)
                  }
                  return x.iushln(_)
                }),
                (c.prototype.invm = function (k) {
                  return this.egcd(k).a.umod(k)
                }),
                (c.prototype.isEven = function () {
                  return (1 & this.words[0]) == 0
                }),
                (c.prototype.isOdd = function () {
                  return (1 & this.words[0]) == 1
                }),
                (c.prototype.andln = function (k) {
                  return this.words[0] & k
                }),
                (c.prototype.bincn = function (k) {
                  a(typeof k == 'number')
                  var v = k % 26,
                    x = (k - v) / 26,
                    _ = 1 << v
                  if (this.length <= x) return (this._expand(x + 1), (this.words[x] |= _), this)
                  for (var S = _, A = x; S !== 0 && A < this.length; A++) {
                    var j = 0 | this.words[A]
                    ;((S = (j += S) >>> 26), (j &= 67108863), (this.words[A] = j))
                  }
                  return (S !== 0 && ((this.words[A] = S), this.length++), this)
                }),
                (c.prototype.isZero = function () {
                  return this.length === 1 && this.words[0] === 0
                }),
                (c.prototype.cmpn = function (k) {
                  var v,
                    x = k < 0
                  if (this.negative !== 0 && !x) return -1
                  if (this.negative === 0 && x) return 1
                  if ((this._strip(), this.length > 1)) v = 1
                  else {
                    ;(x && (k = -k), a(k <= 67108863, 'Number is too big'))
                    var _ = 0 | this.words[0]
                    v = _ === k ? 0 : _ < k ? -1 : 1
                  }
                  return this.negative !== 0 ? 0 | -v : v
                }),
                (c.prototype.cmp = function (k) {
                  if (this.negative !== 0 && k.negative === 0) return -1
                  if (this.negative === 0 && k.negative !== 0) return 1
                  var v = this.ucmp(k)
                  return this.negative !== 0 ? 0 | -v : v
                }),
                (c.prototype.ucmp = function (k) {
                  if (this.length > k.length) return 1
                  if (this.length < k.length) return -1
                  for (var v = 0, x = this.length - 1; x >= 0; x--) {
                    var _ = 0 | this.words[x],
                      S = 0 | k.words[x]
                    if (_ !== S) {
                      _ < S ? (v = -1) : _ > S && (v = 1)
                      break
                    }
                  }
                  return v
                }),
                (c.prototype.gtn = function (k) {
                  return this.cmpn(k) === 1
                }),
                (c.prototype.gt = function (k) {
                  return this.cmp(k) === 1
                }),
                (c.prototype.gten = function (k) {
                  return this.cmpn(k) >= 0
                }),
                (c.prototype.gte = function (k) {
                  return this.cmp(k) >= 0
                }),
                (c.prototype.ltn = function (k) {
                  return this.cmpn(k) === -1
                }),
                (c.prototype.lt = function (k) {
                  return this.cmp(k) === -1
                }),
                (c.prototype.lten = function (k) {
                  return this.cmpn(k) <= 0
                }),
                (c.prototype.lte = function (k) {
                  return this.cmp(k) <= 0
                }),
                (c.prototype.eqn = function (k) {
                  return this.cmpn(k) === 0
                }),
                (c.prototype.eq = function (k) {
                  return this.cmp(k) === 0
                }),
                (c.red = function (k) {
                  return new M(k)
                }),
                (c.prototype.toRed = function (k) {
                  return (
                    a(!this.red, 'Already a number in reduction context'),
                    a(this.negative === 0, 'red works only with positives'),
                    k.convertTo(this)._forceRed(k)
                  )
                }),
                (c.prototype.fromRed = function () {
                  return (
                    a(this.red, 'fromRed works only with numbers in reduction context'),
                    this.red.convertFrom(this)
                  )
                }),
                (c.prototype._forceRed = function (k) {
                  return ((this.red = k), this)
                }),
                (c.prototype.forceRed = function (k) {
                  return (a(!this.red, 'Already a number in reduction context'), this._forceRed(k))
                }),
                (c.prototype.redAdd = function (k) {
                  return (a(this.red, 'redAdd works only with red numbers'), this.red.add(this, k))
                }),
                (c.prototype.redIAdd = function (k) {
                  return (
                    a(this.red, 'redIAdd works only with red numbers'),
                    this.red.iadd(this, k)
                  )
                }),
                (c.prototype.redSub = function (k) {
                  return (a(this.red, 'redSub works only with red numbers'), this.red.sub(this, k))
                }),
                (c.prototype.redISub = function (k) {
                  return (
                    a(this.red, 'redISub works only with red numbers'),
                    this.red.isub(this, k)
                  )
                }),
                (c.prototype.redShl = function (k) {
                  return (a(this.red, 'redShl works only with red numbers'), this.red.shl(this, k))
                }),
                (c.prototype.redMul = function (k) {
                  return (
                    a(this.red, 'redMul works only with red numbers'),
                    this.red._verify2(this, k),
                    this.red.mul(this, k)
                  )
                }),
                (c.prototype.redIMul = function (k) {
                  return (
                    a(this.red, 'redMul works only with red numbers'),
                    this.red._verify2(this, k),
                    this.red.imul(this, k)
                  )
                }),
                (c.prototype.redSqr = function () {
                  return (
                    a(this.red, 'redSqr works only with red numbers'),
                    this.red._verify1(this),
                    this.red.sqr(this)
                  )
                }),
                (c.prototype.redISqr = function () {
                  return (
                    a(this.red, 'redISqr works only with red numbers'),
                    this.red._verify1(this),
                    this.red.isqr(this)
                  )
                }),
                (c.prototype.redSqrt = function () {
                  return (
                    a(this.red, 'redSqrt works only with red numbers'),
                    this.red._verify1(this),
                    this.red.sqrt(this)
                  )
                }),
                (c.prototype.redInvm = function () {
                  return (
                    a(this.red, 'redInvm works only with red numbers'),
                    this.red._verify1(this),
                    this.red.invm(this)
                  )
                }),
                (c.prototype.redNeg = function () {
                  return (
                    a(this.red, 'redNeg works only with red numbers'),
                    this.red._verify1(this),
                    this.red.neg(this)
                  )
                }),
                (c.prototype.redPow = function (k) {
                  return (
                    a(this.red && !k.red, 'redPow(normalNum)'),
                    this.red._verify1(this),
                    this.red.pow(this, k)
                  )
                }))
              var B = { k256: null, p224: null, p192: null, p25519: null }
              function E(k, v) {
                ;((this.name = k),
                  (this.p = new c(v, 16)),
                  (this.n = this.p.bitLength()),
                  (this.k = new c(1).iushln(this.n).isub(this.p)),
                  (this.tmp = this._tmp()))
              }
              function O() {
                E.call(
                  this,
                  'k256',
                  'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
                )
              }
              function P() {
                E.call(
                  this,
                  'p224',
                  'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
                )
              }
              function $() {
                E.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff')
              }
              function F() {
                E.call(
                  this,
                  '25519',
                  '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                )
              }
              function M(k) {
                if (typeof k == 'string') {
                  var v = c._prime(k)
                  ;((this.m = v.p), (this.prime = v))
                } else
                  (a(k.gtn(1), 'modulus must be greater than 1'), (this.m = k), (this.prime = null))
              }
              function R(k) {
                ;(M.call(this, k),
                  (this.shift = this.m.bitLength()),
                  this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
                  (this.r = new c(1).iushln(this.shift)),
                  (this.r2 = this.imod(this.r.sqr())),
                  (this.rinv = this.r._invmp(this.m)),
                  (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
                  (this.minv = this.minv.umod(this.r)),
                  (this.minv = this.r.sub(this.minv)))
              }
              ;((E.prototype._tmp = function () {
                var k = new c(null)
                return ((k.words = new Array(Math.ceil(this.n / 13))), k)
              }),
                (E.prototype.ireduce = function (k) {
                  var v,
                    x = k
                  do
                    (this.split(x, this.tmp),
                      (v = (x = (x = this.imulK(x)).iadd(this.tmp)).bitLength()))
                  while (v > this.n)
                  var _ = v < this.n ? -1 : x.ucmp(this.p)
                  return (
                    _ === 0
                      ? ((x.words[0] = 0), (x.length = 1))
                      : _ > 0
                        ? x.isub(this.p)
                        : x.strip !== void 0
                          ? x.strip()
                          : x._strip(),
                    x
                  )
                }),
                (E.prototype.split = function (k, v) {
                  k.iushrn(this.n, 0, v)
                }),
                (E.prototype.imulK = function (k) {
                  return k.imul(this.k)
                }),
                l(O, E),
                (O.prototype.split = function (k, v) {
                  for (var x = Math.min(k.length, 9), _ = 0; _ < x; _++) v.words[_] = k.words[_]
                  if (((v.length = x), k.length <= 9))
                    return ((k.words[0] = 0), void (k.length = 1))
                  var S = k.words[9]
                  for (v.words[v.length++] = 4194303 & S, _ = 10; _ < k.length; _++) {
                    var A = 0 | k.words[_]
                    ;((k.words[_ - 10] = ((4194303 & A) << 4) | (S >>> 22)), (S = A))
                  }
                  ;((S >>>= 22),
                    (k.words[_ - 10] = S),
                    S === 0 && k.length > 10 ? (k.length -= 10) : (k.length -= 9))
                }),
                (O.prototype.imulK = function (k) {
                  ;((k.words[k.length] = 0), (k.words[k.length + 1] = 0), (k.length += 2))
                  for (var v = 0, x = 0; x < k.length; x++) {
                    var _ = 0 | k.words[x]
                    ;((v += 977 * _),
                      (k.words[x] = 67108863 & v),
                      (v = 64 * _ + ((v / 67108864) | 0)))
                  }
                  return (
                    k.words[k.length - 1] === 0 &&
                      (k.length--, k.words[k.length - 1] === 0 && k.length--),
                    k
                  )
                }),
                l(P, E),
                l($, E),
                l(F, E),
                (F.prototype.imulK = function (k) {
                  for (var v = 0, x = 0; x < k.length; x++) {
                    var _ = 19 * (0 | k.words[x]) + v,
                      S = 67108863 & _
                    ;((_ >>>= 26), (k.words[x] = S), (v = _))
                  }
                  return (v !== 0 && (k.words[k.length++] = v), k)
                }),
                (c._prime = function (k) {
                  if (B[k]) return B[k]
                  var v
                  if (k === 'k256') v = new O()
                  else if (k === 'p224') v = new P()
                  else if (k === 'p192') v = new $()
                  else {
                    if (k !== 'p25519') throw new Error('Unknown prime ' + k)
                    v = new F()
                  }
                  return ((B[k] = v), v)
                }),
                (M.prototype._verify1 = function (k) {
                  ;(a(k.negative === 0, 'red works only with positives'),
                    a(k.red, 'red works only with red numbers'))
                }),
                (M.prototype._verify2 = function (k, v) {
                  ;(a((k.negative | v.negative) == 0, 'red works only with positives'),
                    a(k.red && k.red === v.red, 'red works only with red numbers'))
                }),
                (M.prototype.imod = function (k) {
                  return this.prime
                    ? this.prime.ireduce(k)._forceRed(this)
                    : (p(k, k.umod(this.m)._forceRed(this)), k)
                }),
                (M.prototype.neg = function (k) {
                  return k.isZero() ? k.clone() : this.m.sub(k)._forceRed(this)
                }),
                (M.prototype.add = function (k, v) {
                  this._verify2(k, v)
                  var x = k.add(v)
                  return (x.cmp(this.m) >= 0 && x.isub(this.m), x._forceRed(this))
                }),
                (M.prototype.iadd = function (k, v) {
                  this._verify2(k, v)
                  var x = k.iadd(v)
                  return (x.cmp(this.m) >= 0 && x.isub(this.m), x)
                }),
                (M.prototype.sub = function (k, v) {
                  this._verify2(k, v)
                  var x = k.sub(v)
                  return (x.cmpn(0) < 0 && x.iadd(this.m), x._forceRed(this))
                }),
                (M.prototype.isub = function (k, v) {
                  this._verify2(k, v)
                  var x = k.isub(v)
                  return (x.cmpn(0) < 0 && x.iadd(this.m), x)
                }),
                (M.prototype.shl = function (k, v) {
                  return (this._verify1(k), this.imod(k.ushln(v)))
                }),
                (M.prototype.imul = function (k, v) {
                  return (this._verify2(k, v), this.imod(k.imul(v)))
                }),
                (M.prototype.mul = function (k, v) {
                  return (this._verify2(k, v), this.imod(k.mul(v)))
                }),
                (M.prototype.isqr = function (k) {
                  return this.imul(k, k.clone())
                }),
                (M.prototype.sqr = function (k) {
                  return this.mul(k, k)
                }),
                (M.prototype.sqrt = function (k) {
                  if (k.isZero()) return k.clone()
                  var v = this.m.andln(3)
                  if ((a(v % 2 == 1), v === 3)) {
                    var x = this.m.add(new c(1)).iushrn(2)
                    return this.pow(k, x)
                  }
                  for (var _ = this.m.subn(1), S = 0; !_.isZero() && _.andln(1) === 0; )
                    (S++, _.iushrn(1))
                  a(!_.isZero())
                  var A = new c(1).toRed(this),
                    j = A.redNeg(),
                    L = this.m.subn(1).iushrn(1),
                    H = this.m.bitLength()
                  for (H = new c(2 * H * H).toRed(this); this.pow(H, L).cmp(j) !== 0; ) H.redIAdd(j)
                  for (
                    var U = this.pow(H, _),
                      K = this.pow(k, _.addn(1).iushrn(1)),
                      z = this.pow(k, _),
                      q = S;
                    z.cmp(A) !== 0;

                  ) {
                    for (var D = z, N = 0; D.cmp(A) !== 0; N++) D = D.redSqr()
                    a(N < q)
                    var V = this.pow(U, new c(1).iushln(q - N - 1))
                    ;((K = K.redMul(V)), (U = V.redSqr()), (z = z.redMul(U)), (q = N))
                  }
                  return K
                }),
                (M.prototype.invm = function (k) {
                  var v = k._invmp(this.m)
                  return v.negative !== 0 ? ((v.negative = 0), this.imod(v).redNeg()) : this.imod(v)
                }),
                (M.prototype.pow = function (k, v) {
                  if (v.isZero()) return new c(1).toRed(this)
                  if (v.cmpn(1) === 0) return k.clone()
                  var x = new Array(16)
                  ;((x[0] = new c(1).toRed(this)), (x[1] = k))
                  for (var _ = 2; _ < x.length; _++) x[_] = this.mul(x[_ - 1], k)
                  var S = x[0],
                    A = 0,
                    j = 0,
                    L = v.bitLength() % 26
                  for (L === 0 && (L = 26), _ = v.length - 1; _ >= 0; _--) {
                    for (var H = v.words[_], U = L - 1; U >= 0; U--) {
                      var K = (H >> U) & 1
                      ;(S !== x[0] && (S = this.sqr(S)),
                        K !== 0 || A !== 0
                          ? ((A <<= 1),
                            (A |= K),
                            (++j === 4 || (_ === 0 && U === 0)) &&
                              ((S = this.mul(S, x[A])), (j = 0), (A = 0)))
                          : (j = 0))
                    }
                    L = 26
                  }
                  return S
                }),
                (M.prototype.convertTo = function (k) {
                  var v = k.umod(this.m)
                  return v === k ? v.clone() : v
                }),
                (M.prototype.convertFrom = function (k) {
                  var v = k.clone()
                  return ((v.red = null), v)
                }),
                (c.mont = function (k) {
                  return new R(k)
                }),
                l(R, M),
                (R.prototype.convertTo = function (k) {
                  return this.imod(k.ushln(this.shift))
                }),
                (R.prototype.convertFrom = function (k) {
                  var v = this.imod(k.mul(this.rinv))
                  return ((v.red = null), v)
                }),
                (R.prototype.imul = function (k, v) {
                  if (k.isZero() || v.isZero()) return ((k.words[0] = 0), (k.length = 1), k)
                  var x = k.imul(v),
                    _ = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    S = x.isub(_).iushrn(this.shift),
                    A = S
                  return (
                    S.cmp(this.m) >= 0
                      ? (A = S.isub(this.m))
                      : S.cmpn(0) < 0 && (A = S.iadd(this.m)),
                    A._forceRed(this)
                  )
                }),
                (R.prototype.mul = function (k, v) {
                  if (k.isZero() || v.isZero()) return new c(0)._forceRed(this)
                  var x = k.mul(v),
                    _ = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    S = x.isub(_).iushrn(this.shift),
                    A = S
                  return (
                    S.cmp(this.m) >= 0
                      ? (A = S.isub(this.m))
                      : S.cmpn(0) < 0 && (A = S.iadd(this.m)),
                    A._forceRed(this)
                  )
                }),
                (R.prototype.invm = function (k) {
                  return this.imod(k._invmp(this.m).mul(this.r2))._forceRed(this)
                }))
            })(r === void 0 || r)
          },
          { buffer: 188 },
        ],
        187: [
          function (t, r, i) {
            var s
            function o(l) {
              this.rand = l
            }
            if (
              ((r.exports = function (l) {
                return (s || (s = new o(null)), s.generate(l))
              }),
              (r.exports.Rand = o),
              (o.prototype.generate = function (l) {
                return this._rand(l)
              }),
              (o.prototype._rand = function (l) {
                if (this.rand.getBytes) return this.rand.getBytes(l)
                for (var c = new Uint8Array(l), u = 0; u < c.length; u++) c[u] = this.rand.getByte()
                return c
              }),
              typeof self == 'object')
            )
              self.crypto && self.crypto.getRandomValues
                ? (o.prototype._rand = function (l) {
                    var c = new Uint8Array(l)
                    return (self.crypto.getRandomValues(c), c)
                  })
                : self.msCrypto && self.msCrypto.getRandomValues
                  ? (o.prototype._rand = function (l) {
                      var c = new Uint8Array(l)
                      return (self.msCrypto.getRandomValues(c), c)
                    })
                  : typeof window == 'object' &&
                    (o.prototype._rand = function () {
                      throw new Error('Not implemented yet')
                    })
            else
              try {
                var a = t('crypto')
                if (typeof a.randomBytes != 'function') throw new Error('Not supported')
                o.prototype._rand = function (l) {
                  return a.randomBytes(l)
                }
              } catch {}
          },
          { crypto: 188 },
        ],
        188: [function (t, r, i) {}, {}],
        189: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer
            function o(d) {
              s.isBuffer(d) || (d = s.from(d))
              for (var h = (d.length / 4) | 0, p = new Array(h), g = 0; g < h; g++)
                p[g] = d.readUInt32BE(4 * g)
              return p
            }
            function a(d) {
              for (; 0 < d.length; d++) d[0] = 0
            }
            function l(d, h, p, g, m) {
              for (
                var y,
                  b,
                  w,
                  C,
                  T = p[0],
                  I = p[1],
                  B = p[2],
                  E = p[3],
                  O = d[0] ^ h[0],
                  P = d[1] ^ h[1],
                  $ = d[2] ^ h[2],
                  F = d[3] ^ h[3],
                  M = 4,
                  R = 1;
                R < m;
                R++
              )
                ((y = T[O >>> 24] ^ I[(P >>> 16) & 255] ^ B[($ >>> 8) & 255] ^ E[255 & F] ^ h[M++]),
                  (b =
                    T[P >>> 24] ^ I[($ >>> 16) & 255] ^ B[(F >>> 8) & 255] ^ E[255 & O] ^ h[M++]),
                  (w =
                    T[$ >>> 24] ^ I[(F >>> 16) & 255] ^ B[(O >>> 8) & 255] ^ E[255 & P] ^ h[M++]),
                  (C =
                    T[F >>> 24] ^ I[(O >>> 16) & 255] ^ B[(P >>> 8) & 255] ^ E[255 & $] ^ h[M++]),
                  (O = y),
                  (P = b),
                  ($ = w),
                  (F = C))
              return (
                (y =
                  ((g[O >>> 24] << 24) |
                    (g[(P >>> 16) & 255] << 16) |
                    (g[($ >>> 8) & 255] << 8) |
                    g[255 & F]) ^
                  h[M++]),
                (b =
                  ((g[P >>> 24] << 24) |
                    (g[($ >>> 16) & 255] << 16) |
                    (g[(F >>> 8) & 255] << 8) |
                    g[255 & O]) ^
                  h[M++]),
                (w =
                  ((g[$ >>> 24] << 24) |
                    (g[(F >>> 16) & 255] << 16) |
                    (g[(O >>> 8) & 255] << 8) |
                    g[255 & P]) ^
                  h[M++]),
                (C =
                  ((g[F >>> 24] << 24) |
                    (g[(O >>> 16) & 255] << 16) |
                    (g[(P >>> 8) & 255] << 8) |
                    g[255 & $]) ^
                  h[M++]),
                [(y >>>= 0), (b >>>= 0), (w >>>= 0), (C >>>= 0)]
              )
            }
            var c = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
              u = (function () {
                for (var d = new Array(256), h = 0; h < 256; h++)
                  d[h] = h < 128 ? h << 1 : (h << 1) ^ 283
                for (
                  var p = [],
                    g = [],
                    m = [[], [], [], []],
                    y = [[], [], [], []],
                    b = 0,
                    w = 0,
                    C = 0;
                  C < 256;
                  ++C
                ) {
                  var T = w ^ (w << 1) ^ (w << 2) ^ (w << 3) ^ (w << 4)
                  ;((T = (T >>> 8) ^ (255 & T) ^ 99), (p[b] = T), (g[T] = b))
                  var I = d[b],
                    B = d[I],
                    E = d[B],
                    O = (257 * d[T]) ^ (16843008 * T)
                  ;((m[0][b] = (O << 24) | (O >>> 8)),
                    (m[1][b] = (O << 16) | (O >>> 16)),
                    (m[2][b] = (O << 8) | (O >>> 24)),
                    (m[3][b] = O),
                    (O = (16843009 * E) ^ (65537 * B) ^ (257 * I) ^ (16843008 * b)),
                    (y[0][T] = (O << 24) | (O >>> 8)),
                    (y[1][T] = (O << 16) | (O >>> 16)),
                    (y[2][T] = (O << 8) | (O >>> 24)),
                    (y[3][T] = O),
                    b === 0 ? (b = w = 1) : ((b = I ^ d[d[d[E ^ I]]]), (w ^= d[d[w]])))
                }
                return { SBOX: p, INV_SBOX: g, SUB_MIX: m, INV_SUB_MIX: y }
              })()
            function f(d) {
              ;((this._key = o(d)), this._reset())
            }
            ;((f.blockSize = 16),
              (f.keySize = 32),
              (f.prototype.blockSize = f.blockSize),
              (f.prototype.keySize = f.keySize),
              (f.prototype._reset = function () {
                for (
                  var d = this._key, h = d.length, p = h + 6, g = 4 * (p + 1), m = [], y = 0;
                  y < h;
                  y++
                )
                  m[y] = d[y]
                for (y = h; y < g; y++) {
                  var b = m[y - 1]
                  ;(y % h == 0
                    ? ((b = (b << 8) | (b >>> 24)),
                      (b =
                        (u.SBOX[b >>> 24] << 24) |
                        (u.SBOX[(b >>> 16) & 255] << 16) |
                        (u.SBOX[(b >>> 8) & 255] << 8) |
                        u.SBOX[255 & b]),
                      (b ^= c[(y / h) | 0] << 24))
                    : h > 6 &&
                      y % h == 4 &&
                      (b =
                        (u.SBOX[b >>> 24] << 24) |
                        (u.SBOX[(b >>> 16) & 255] << 16) |
                        (u.SBOX[(b >>> 8) & 255] << 8) |
                        u.SBOX[255 & b]),
                    (m[y] = m[y - h] ^ b))
                }
                for (var w = [], C = 0; C < g; C++) {
                  var T = g - C,
                    I = m[T - (C % 4 ? 0 : 4)]
                  w[C] =
                    C < 4 || T <= 4
                      ? I
                      : u.INV_SUB_MIX[0][u.SBOX[I >>> 24]] ^
                        u.INV_SUB_MIX[1][u.SBOX[(I >>> 16) & 255]] ^
                        u.INV_SUB_MIX[2][u.SBOX[(I >>> 8) & 255]] ^
                        u.INV_SUB_MIX[3][u.SBOX[255 & I]]
                }
                ;((this._nRounds = p), (this._keySchedule = m), (this._invKeySchedule = w))
              }),
              (f.prototype.encryptBlockRaw = function (d) {
                return l((d = o(d)), this._keySchedule, u.SUB_MIX, u.SBOX, this._nRounds)
              }),
              (f.prototype.encryptBlock = function (d) {
                var h = this.encryptBlockRaw(d),
                  p = s.allocUnsafe(16)
                return (
                  p.writeUInt32BE(h[0], 0),
                  p.writeUInt32BE(h[1], 4),
                  p.writeUInt32BE(h[2], 8),
                  p.writeUInt32BE(h[3], 12),
                  p
                )
              }),
              (f.prototype.decryptBlock = function (d) {
                var h = (d = o(d))[1]
                ;((d[1] = d[3]), (d[3] = h))
                var p = l(d, this._invKeySchedule, u.INV_SUB_MIX, u.INV_SBOX, this._nRounds),
                  g = s.allocUnsafe(16)
                return (
                  g.writeUInt32BE(p[0], 0),
                  g.writeUInt32BE(p[3], 4),
                  g.writeUInt32BE(p[2], 8),
                  g.writeUInt32BE(p[1], 12),
                  g
                )
              }),
              (f.prototype.scrub = function () {
                ;(a(this._keySchedule), a(this._invKeySchedule), a(this._key))
              }),
              (r.exports.AES = f))
          },
          { 'safe-buffer': 494 },
        ],
        190: [
          function (t, r, i) {
            var s = t('./aes'),
              o = t('safe-buffer').Buffer,
              a = t('cipher-base'),
              l = t('inherits'),
              c = t('./ghash'),
              u = t('buffer-xor'),
              f = t('./incr32')
            function d(h, p, g, m) {
              a.call(this)
              var y = o.alloc(4, 0)
              this._cipher = new s.AES(p)
              var b = this._cipher.encryptBlock(y)
              ;((this._ghash = new c(b)),
                (g = (function (w, C, T) {
                  if (C.length === 12)
                    return (
                      (w._finID = o.concat([C, o.from([0, 0, 0, 1])])),
                      o.concat([C, o.from([0, 0, 0, 2])])
                    )
                  var I = new c(T),
                    B = C.length,
                    E = B % 16
                  ;(I.update(C),
                    E && ((E = 16 - E), I.update(o.alloc(E, 0))),
                    I.update(o.alloc(8, 0)))
                  var O = 8 * B,
                    P = o.alloc(8)
                  ;(P.writeUIntBE(O, 0, 8), I.update(P), (w._finID = I.state))
                  var $ = o.from(w._finID)
                  return (f($), $)
                })(this, g, b)),
                (this._prev = o.from(g)),
                (this._cache = o.allocUnsafe(0)),
                (this._secCache = o.allocUnsafe(0)),
                (this._decrypt = m),
                (this._alen = 0),
                (this._len = 0),
                (this._mode = h),
                (this._authTag = null),
                (this._called = !1))
            }
            ;(l(d, a),
              (d.prototype._update = function (h) {
                if (!this._called && this._alen) {
                  var p = 16 - (this._alen % 16)
                  p < 16 && ((p = o.alloc(p, 0)), this._ghash.update(p))
                }
                this._called = !0
                var g = this._mode.encrypt(this, h)
                return (
                  this._decrypt ? this._ghash.update(h) : this._ghash.update(g),
                  (this._len += h.length),
                  g
                )
              }),
              (d.prototype._final = function () {
                if (this._decrypt && !this._authTag)
                  throw new Error('Unsupported state or unable to authenticate data')
                var h = u(
                  this._ghash.final(8 * this._alen, 8 * this._len),
                  this._cipher.encryptBlock(this._finID),
                )
                if (
                  this._decrypt &&
                  (function (p, g) {
                    var m = 0
                    p.length !== g.length && m++
                    for (var y = Math.min(p.length, g.length), b = 0; b < y; ++b) m += p[b] ^ g[b]
                    return m
                  })(h, this._authTag)
                )
                  throw new Error('Unsupported state or unable to authenticate data')
                ;((this._authTag = h), this._cipher.scrub())
              }),
              (d.prototype.getAuthTag = function () {
                if (this._decrypt || !o.isBuffer(this._authTag))
                  throw new Error('Attempting to get auth tag in unsupported state')
                return this._authTag
              }),
              (d.prototype.setAuthTag = function (h) {
                if (!this._decrypt)
                  throw new Error('Attempting to set auth tag in unsupported state')
                this._authTag = h
              }),
              (d.prototype.setAAD = function (h) {
                if (this._called) throw new Error('Attempting to set AAD in unsupported state')
                ;(this._ghash.update(h), (this._alen += h.length))
              }),
              (r.exports = d))
          },
          {
            './aes': 189,
            './ghash': 194,
            './incr32': 195,
            'buffer-xor': 219,
            'cipher-base': 221,
            inherits: 440,
            'safe-buffer': 494,
          },
        ],
        191: [
          function (t, r, i) {
            var s = t('./encrypter'),
              o = t('./decrypter'),
              a = t('./modes/list.json')
            ;((i.createCipher = i.Cipher = s.createCipher),
              (i.createCipheriv = i.Cipheriv = s.createCipheriv),
              (i.createDecipher = i.Decipher = o.createDecipher),
              (i.createDecipheriv = i.Decipheriv = o.createDecipheriv),
              (i.listCiphers = i.getCiphers =
                function () {
                  return Object.keys(a)
                }))
          },
          { './decrypter': 192, './encrypter': 193, './modes/list.json': 203 },
        ],
        192: [
          function (t, r, i) {
            var s = t('./authCipher'),
              o = t('safe-buffer').Buffer,
              a = t('./modes'),
              l = t('./streamCipher'),
              c = t('cipher-base'),
              u = t('./aes'),
              f = t('evp_bytestokey')
            function d(g, m, y) {
              ;(c.call(this),
                (this._cache = new h()),
                (this._last = void 0),
                (this._cipher = new u.AES(m)),
                (this._prev = o.from(y)),
                (this._mode = g),
                (this._autopadding = !0))
            }
            function h() {
              this.cache = o.allocUnsafe(0)
            }
            function p(g, m, y) {
              var b = a[g.toLowerCase()]
              if (!b) throw new TypeError('invalid suite type')
              if ((typeof y == 'string' && (y = o.from(y)), b.mode !== 'GCM' && y.length !== b.iv))
                throw new TypeError('invalid iv length ' + y.length)
              if ((typeof m == 'string' && (m = o.from(m)), m.length !== b.key / 8))
                throw new TypeError('invalid key length ' + m.length)
              return b.type === 'stream'
                ? new l(b.module, m, y, !0)
                : b.type === 'auth'
                  ? new s(b.module, m, y, !0)
                  : new d(b.module, m, y)
            }
            ;(t('inherits')(d, c),
              (d.prototype._update = function (g) {
                var m, y
                this._cache.add(g)
                for (var b = []; (m = this._cache.get(this._autopadding)); )
                  ((y = this._mode.decrypt(this, m)), b.push(y))
                return o.concat(b)
              }),
              (d.prototype._final = function () {
                var g = this._cache.flush()
                if (this._autopadding)
                  return (function (m) {
                    var y = m[15]
                    if (y < 1 || y > 16) throw new Error('unable to decrypt data')
                    for (var b = -1; ++b < y; )
                      if (m[b + (16 - y)] !== y) throw new Error('unable to decrypt data')
                    if (y !== 16) return m.slice(0, 16 - y)
                  })(this._mode.decrypt(this, g))
                if (g) throw new Error('data not multiple of block length')
              }),
              (d.prototype.setAutoPadding = function (g) {
                return ((this._autopadding = !!g), this)
              }),
              (h.prototype.add = function (g) {
                this.cache = o.concat([this.cache, g])
              }),
              (h.prototype.get = function (g) {
                var m
                if (g) {
                  if (this.cache.length > 16)
                    return ((m = this.cache.slice(0, 16)), (this.cache = this.cache.slice(16)), m)
                } else if (this.cache.length >= 16)
                  return ((m = this.cache.slice(0, 16)), (this.cache = this.cache.slice(16)), m)
                return null
              }),
              (h.prototype.flush = function () {
                if (this.cache.length) return this.cache
              }),
              (i.createDecipher = function (g, m) {
                var y = a[g.toLowerCase()]
                if (!y) throw new TypeError('invalid suite type')
                var b = f(m, !1, y.key, y.iv)
                return p(g, b.key, b.iv)
              }),
              (i.createDecipheriv = p))
          },
          {
            './aes': 189,
            './authCipher': 190,
            './modes': 202,
            './streamCipher': 205,
            'cipher-base': 221,
            evp_bytestokey: 423,
            inherits: 440,
            'safe-buffer': 494,
          },
        ],
        193: [
          function (t, r, i) {
            var s = t('./modes'),
              o = t('./authCipher'),
              a = t('safe-buffer').Buffer,
              l = t('./streamCipher'),
              c = t('cipher-base'),
              u = t('./aes'),
              f = t('evp_bytestokey')
            function d(m, y, b) {
              ;(c.call(this),
                (this._cache = new p()),
                (this._cipher = new u.AES(y)),
                (this._prev = a.from(b)),
                (this._mode = m),
                (this._autopadding = !0))
            }
            ;(t('inherits')(d, c),
              (d.prototype._update = function (m) {
                var y, b
                this._cache.add(m)
                for (var w = []; (y = this._cache.get()); )
                  ((b = this._mode.encrypt(this, y)), w.push(b))
                return a.concat(w)
              }))
            var h = a.alloc(16, 16)
            function p() {
              this.cache = a.allocUnsafe(0)
            }
            function g(m, y, b) {
              var w = s[m.toLowerCase()]
              if (!w) throw new TypeError('invalid suite type')
              if ((typeof y == 'string' && (y = a.from(y)), y.length !== w.key / 8))
                throw new TypeError('invalid key length ' + y.length)
              if ((typeof b == 'string' && (b = a.from(b)), w.mode !== 'GCM' && b.length !== w.iv))
                throw new TypeError('invalid iv length ' + b.length)
              return w.type === 'stream'
                ? new l(w.module, y, b)
                : w.type === 'auth'
                  ? new o(w.module, y, b)
                  : new d(w.module, y, b)
            }
            ;((d.prototype._final = function () {
              var m = this._cache.flush()
              if (this._autopadding)
                return ((m = this._mode.encrypt(this, m)), this._cipher.scrub(), m)
              if (!m.equals(h))
                throw (this._cipher.scrub(), new Error('data not multiple of block length'))
            }),
              (d.prototype.setAutoPadding = function (m) {
                return ((this._autopadding = !!m), this)
              }),
              (p.prototype.add = function (m) {
                this.cache = a.concat([this.cache, m])
              }),
              (p.prototype.get = function () {
                if (this.cache.length > 15) {
                  var m = this.cache.slice(0, 16)
                  return ((this.cache = this.cache.slice(16)), m)
                }
                return null
              }),
              (p.prototype.flush = function () {
                for (var m = 16 - this.cache.length, y = a.allocUnsafe(m), b = -1; ++b < m; )
                  y.writeUInt8(m, b)
                return a.concat([this.cache, y])
              }),
              (i.createCipheriv = g),
              (i.createCipher = function (m, y) {
                var b = s[m.toLowerCase()]
                if (!b) throw new TypeError('invalid suite type')
                var w = f(y, !1, b.key, b.iv)
                return g(m, w.key, w.iv)
              }))
          },
          {
            './aes': 189,
            './authCipher': 190,
            './modes': 202,
            './streamCipher': 205,
            'cipher-base': 221,
            evp_bytestokey: 423,
            inherits: 440,
            'safe-buffer': 494,
          },
        ],
        194: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = s.alloc(16, 0)
            function a(c) {
              var u = s.allocUnsafe(16)
              return (
                u.writeUInt32BE(c[0] >>> 0, 0),
                u.writeUInt32BE(c[1] >>> 0, 4),
                u.writeUInt32BE(c[2] >>> 0, 8),
                u.writeUInt32BE(c[3] >>> 0, 12),
                u
              )
            }
            function l(c) {
              ;((this.h = c), (this.state = s.alloc(16, 0)), (this.cache = s.allocUnsafe(0)))
            }
            ;((l.prototype.ghash = function (c) {
              for (var u = -1; ++u < c.length; ) this.state[u] ^= c[u]
              this._multiply()
            }),
              (l.prototype._multiply = function () {
                for (
                  var c,
                    u,
                    f,
                    d = [
                      (c = this.h).readUInt32BE(0),
                      c.readUInt32BE(4),
                      c.readUInt32BE(8),
                      c.readUInt32BE(12),
                    ],
                    h = [0, 0, 0, 0],
                    p = -1;
                  ++p < 128;

                ) {
                  for (
                    this.state[~~(p / 8)] & (1 << (7 - (p % 8))) &&
                      ((h[0] ^= d[0]), (h[1] ^= d[1]), (h[2] ^= d[2]), (h[3] ^= d[3])),
                      f = (1 & d[3]) != 0,
                      u = 3;
                    u > 0;
                    u--
                  )
                    d[u] = (d[u] >>> 1) | ((1 & d[u - 1]) << 31)
                  ;((d[0] = d[0] >>> 1), f && (d[0] = d[0] ^ (225 << 24)))
                }
                this.state = a(h)
              }),
              (l.prototype.update = function (c) {
                var u
                for (this.cache = s.concat([this.cache, c]); this.cache.length >= 16; )
                  ((u = this.cache.slice(0, 16)),
                    (this.cache = this.cache.slice(16)),
                    this.ghash(u))
              }),
              (l.prototype.final = function (c, u) {
                return (
                  this.cache.length && this.ghash(s.concat([this.cache, o], 16)),
                  this.ghash(a([0, c, 0, u])),
                  this.state
                )
              }),
              (r.exports = l))
          },
          { 'safe-buffer': 494 },
        ],
        195: [
          function (t, r, i) {
            r.exports = function (s) {
              for (var o, a = s.length; a--; ) {
                if ((o = s.readUInt8(a)) !== 255) {
                  ;(o++, s.writeUInt8(o, a))
                  break
                }
                s.writeUInt8(0, a)
              }
            }
          },
          {},
        ],
        196: [
          function (t, r, i) {
            var s = t('buffer-xor')
            ;((i.encrypt = function (o, a) {
              var l = s(a, o._prev)
              return ((o._prev = o._cipher.encryptBlock(l)), o._prev)
            }),
              (i.decrypt = function (o, a) {
                var l = o._prev
                o._prev = a
                var c = o._cipher.decryptBlock(a)
                return s(c, l)
              }))
          },
          { 'buffer-xor': 219 },
        ],
        197: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('buffer-xor')
            function a(l, c, u) {
              var f = c.length,
                d = o(c, l._cache)
              return ((l._cache = l._cache.slice(f)), (l._prev = s.concat([l._prev, u ? c : d])), d)
            }
            i.encrypt = function (l, c, u) {
              for (var f, d = s.allocUnsafe(0); c.length; ) {
                if (
                  (l._cache.length === 0 &&
                    ((l._cache = l._cipher.encryptBlock(l._prev)), (l._prev = s.allocUnsafe(0))),
                  !(l._cache.length <= c.length))
                ) {
                  d = s.concat([d, a(l, c, u)])
                  break
                }
                ;((f = l._cache.length),
                  (d = s.concat([d, a(l, c.slice(0, f), u)])),
                  (c = c.slice(f)))
              }
              return d
            }
          },
          { 'buffer-xor': 219, 'safe-buffer': 494 },
        ],
        198: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer
            function o(l, c, u) {
              for (var f, d, h = -1, p = 0; ++h < 8; )
                ((f = c & (1 << (7 - h)) ? 128 : 0),
                  (p += (128 & (d = l._cipher.encryptBlock(l._prev)[0] ^ f)) >> h % 8),
                  (l._prev = a(l._prev, u ? f : d)))
              return p
            }
            function a(l, c) {
              var u = l.length,
                f = -1,
                d = s.allocUnsafe(l.length)
              for (l = s.concat([l, s.from([c])]); ++f < u; ) d[f] = (l[f] << 1) | (l[f + 1] >> 7)
              return d
            }
            i.encrypt = function (l, c, u) {
              for (var f = c.length, d = s.allocUnsafe(f), h = -1; ++h < f; ) d[h] = o(l, c[h], u)
              return d
            }
          },
          { 'safe-buffer': 494 },
        ],
        199: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer
            function o(a, l, c) {
              var u = a._cipher.encryptBlock(a._prev)[0] ^ l
              return ((a._prev = s.concat([a._prev.slice(1), s.from([c ? l : u])])), u)
            }
            i.encrypt = function (a, l, c) {
              for (var u = l.length, f = s.allocUnsafe(u), d = -1; ++d < u; ) f[d] = o(a, l[d], c)
              return f
            }
          },
          { 'safe-buffer': 494 },
        ],
        200: [
          function (t, r, i) {
            var s = t('buffer-xor'),
              o = t('safe-buffer').Buffer,
              a = t('../incr32')
            function l(c) {
              var u = c._cipher.encryptBlockRaw(c._prev)
              return (a(c._prev), u)
            }
            i.encrypt = function (c, u) {
              var f = Math.ceil(u.length / 16),
                d = c._cache.length
              c._cache = o.concat([c._cache, o.allocUnsafe(16 * f)])
              for (var h = 0; h < f; h++) {
                var p = l(c),
                  g = d + 16 * h
                ;(c._cache.writeUInt32BE(p[0], g + 0),
                  c._cache.writeUInt32BE(p[1], g + 4),
                  c._cache.writeUInt32BE(p[2], g + 8),
                  c._cache.writeUInt32BE(p[3], g + 12))
              }
              var m = c._cache.slice(0, u.length)
              return ((c._cache = c._cache.slice(u.length)), s(u, m))
            }
          },
          { '../incr32': 195, 'buffer-xor': 219, 'safe-buffer': 494 },
        ],
        201: [
          function (t, r, i) {
            ;((i.encrypt = function (s, o) {
              return s._cipher.encryptBlock(o)
            }),
              (i.decrypt = function (s, o) {
                return s._cipher.decryptBlock(o)
              }))
          },
          {},
        ],
        202: [
          function (t, r, i) {
            var s = {
                ECB: t('./ecb'),
                CBC: t('./cbc'),
                CFB: t('./cfb'),
                CFB8: t('./cfb8'),
                CFB1: t('./cfb1'),
                OFB: t('./ofb'),
                CTR: t('./ctr'),
                GCM: t('./ctr'),
              },
              o = t('./list.json')
            for (var a in o) o[a].module = s[o[a].mode]
            r.exports = o
          },
          {
            './cbc': 196,
            './cfb': 197,
            './cfb1': 198,
            './cfb8': 199,
            './ctr': 200,
            './ecb': 201,
            './list.json': 203,
            './ofb': 204,
          },
        ],
        203: [
          function (t, r, i) {
            r.exports = {
              'aes-128-ecb': { cipher: 'AES', key: 128, iv: 0, mode: 'ECB', type: 'block' },
              'aes-192-ecb': { cipher: 'AES', key: 192, iv: 0, mode: 'ECB', type: 'block' },
              'aes-256-ecb': { cipher: 'AES', key: 256, iv: 0, mode: 'ECB', type: 'block' },
              'aes-128-cbc': { cipher: 'AES', key: 128, iv: 16, mode: 'CBC', type: 'block' },
              'aes-192-cbc': { cipher: 'AES', key: 192, iv: 16, mode: 'CBC', type: 'block' },
              'aes-256-cbc': { cipher: 'AES', key: 256, iv: 16, mode: 'CBC', type: 'block' },
              aes128: { cipher: 'AES', key: 128, iv: 16, mode: 'CBC', type: 'block' },
              aes192: { cipher: 'AES', key: 192, iv: 16, mode: 'CBC', type: 'block' },
              aes256: { cipher: 'AES', key: 256, iv: 16, mode: 'CBC', type: 'block' },
              'aes-128-cfb': { cipher: 'AES', key: 128, iv: 16, mode: 'CFB', type: 'stream' },
              'aes-192-cfb': { cipher: 'AES', key: 192, iv: 16, mode: 'CFB', type: 'stream' },
              'aes-256-cfb': { cipher: 'AES', key: 256, iv: 16, mode: 'CFB', type: 'stream' },
              'aes-128-cfb8': { cipher: 'AES', key: 128, iv: 16, mode: 'CFB8', type: 'stream' },
              'aes-192-cfb8': { cipher: 'AES', key: 192, iv: 16, mode: 'CFB8', type: 'stream' },
              'aes-256-cfb8': { cipher: 'AES', key: 256, iv: 16, mode: 'CFB8', type: 'stream' },
              'aes-128-cfb1': { cipher: 'AES', key: 128, iv: 16, mode: 'CFB1', type: 'stream' },
              'aes-192-cfb1': { cipher: 'AES', key: 192, iv: 16, mode: 'CFB1', type: 'stream' },
              'aes-256-cfb1': { cipher: 'AES', key: 256, iv: 16, mode: 'CFB1', type: 'stream' },
              'aes-128-ofb': { cipher: 'AES', key: 128, iv: 16, mode: 'OFB', type: 'stream' },
              'aes-192-ofb': { cipher: 'AES', key: 192, iv: 16, mode: 'OFB', type: 'stream' },
              'aes-256-ofb': { cipher: 'AES', key: 256, iv: 16, mode: 'OFB', type: 'stream' },
              'aes-128-ctr': { cipher: 'AES', key: 128, iv: 16, mode: 'CTR', type: 'stream' },
              'aes-192-ctr': { cipher: 'AES', key: 192, iv: 16, mode: 'CTR', type: 'stream' },
              'aes-256-ctr': { cipher: 'AES', key: 256, iv: 16, mode: 'CTR', type: 'stream' },
              'aes-128-gcm': { cipher: 'AES', key: 128, iv: 12, mode: 'GCM', type: 'auth' },
              'aes-192-gcm': { cipher: 'AES', key: 192, iv: 12, mode: 'GCM', type: 'auth' },
              'aes-256-gcm': { cipher: 'AES', key: 256, iv: 12, mode: 'GCM', type: 'auth' },
            }
          },
          {},
        ],
        204: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = t('buffer-xor')
                function a(l) {
                  return ((l._prev = l._cipher.encryptBlock(l._prev)), l._prev)
                }
                i.encrypt = function (l, c) {
                  for (; l._cache.length < c.length; ) l._cache = s.concat([l._cache, a(l)])
                  var u = l._cache.slice(0, c.length)
                  return ((l._cache = l._cache.slice(c.length)), o(c, u))
                }
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { buffer: 220, 'buffer-xor': 219 },
        ],
        205: [
          function (t, r, i) {
            var s = t('./aes'),
              o = t('safe-buffer').Buffer,
              a = t('cipher-base')
            function l(c, u, f, d) {
              ;(a.call(this),
                (this._cipher = new s.AES(u)),
                (this._prev = o.from(f)),
                (this._cache = o.allocUnsafe(0)),
                (this._secCache = o.allocUnsafe(0)),
                (this._decrypt = d),
                (this._mode = c))
            }
            ;(t('inherits')(l, a),
              (l.prototype._update = function (c) {
                return this._mode.encrypt(this, c, this._decrypt)
              }),
              (l.prototype._final = function () {
                this._cipher.scrub()
              }),
              (r.exports = l))
          },
          { './aes': 189, 'cipher-base': 221, inherits: 440, 'safe-buffer': 494 },
        ],
        206: [
          function (t, r, i) {
            var s = t('browserify-des'),
              o = t('browserify-aes/browser'),
              a = t('browserify-aes/modes'),
              l = t('browserify-des/modes'),
              c = t('evp_bytestokey')
            function u(d, h, p) {
              if (((d = d.toLowerCase()), a[d])) return o.createCipheriv(d, h, p)
              if (l[d]) return new s({ key: h, iv: p, mode: d })
              throw new TypeError('invalid suite type')
            }
            function f(d, h, p) {
              if (((d = d.toLowerCase()), a[d])) return o.createDecipheriv(d, h, p)
              if (l[d]) return new s({ key: h, iv: p, mode: d, decrypt: !0 })
              throw new TypeError('invalid suite type')
            }
            ;((i.createCipher = i.Cipher =
              function (d, h) {
                var p, g
                if (((d = d.toLowerCase()), a[d])) ((p = a[d].key), (g = a[d].iv))
                else {
                  if (!l[d]) throw new TypeError('invalid suite type')
                  ;((p = 8 * l[d].key), (g = l[d].iv))
                }
                var m = c(h, !1, p, g)
                return u(d, m.key, m.iv)
              }),
              (i.createCipheriv = i.Cipheriv = u),
              (i.createDecipher = i.Decipher =
                function (d, h) {
                  var p, g
                  if (((d = d.toLowerCase()), a[d])) ((p = a[d].key), (g = a[d].iv))
                  else {
                    if (!l[d]) throw new TypeError('invalid suite type')
                    ;((p = 8 * l[d].key), (g = l[d].iv))
                  }
                  var m = c(h, !1, p, g)
                  return f(d, m.key, m.iv)
                }),
              (i.createDecipheriv = i.Decipheriv = f),
              (i.listCiphers = i.getCiphers =
                function () {
                  return Object.keys(l).concat(o.getCiphers())
                }))
          },
          {
            'browserify-aes/browser': 191,
            'browserify-aes/modes': 202,
            'browserify-des': 207,
            'browserify-des/modes': 208,
            evp_bytestokey: 423,
          },
        ],
        207: [
          function (t, r, i) {
            var s = t('cipher-base'),
              o = t('des.js'),
              a = t('inherits'),
              l = t('safe-buffer').Buffer,
              c = {
                'des-ede3-cbc': o.CBC.instantiate(o.EDE),
                'des-ede3': o.EDE,
                'des-ede-cbc': o.CBC.instantiate(o.EDE),
                'des-ede': o.EDE,
                'des-cbc': o.CBC.instantiate(o.DES),
                'des-ecb': o.DES,
              }
            function u(f) {
              s.call(this)
              var d,
                h = f.mode.toLowerCase(),
                p = c[h]
              d = f.decrypt ? 'decrypt' : 'encrypt'
              var g = f.key
              ;(l.isBuffer(g) || (g = l.from(g)),
                (h !== 'des-ede' && h !== 'des-ede-cbc') || (g = l.concat([g, g.slice(0, 8)])))
              var m = f.iv
              ;(l.isBuffer(m) || (m = l.from(m)),
                (this._des = p.create({ key: g, iv: m, type: d })))
            }
            ;((c.des = c['des-cbc']),
              (c.des3 = c['des-ede3-cbc']),
              (r.exports = u),
              a(u, s),
              (u.prototype._update = function (f) {
                return l.from(this._des.update(f))
              }),
              (u.prototype._final = function () {
                return l.from(this._des.final())
              }))
          },
          { 'cipher-base': 221, 'des.js': 394, inherits: 440, 'safe-buffer': 494 },
        ],
        208: [
          function (t, r, i) {
            ;((i['des-ecb'] = { key: 8, iv: 0 }),
              (i['des-cbc'] = i.des = { key: 8, iv: 8 }),
              (i['des-ede3-cbc'] = i.des3 = { key: 24, iv: 8 }),
              (i['des-ede3'] = { key: 24, iv: 0 }),
              (i['des-ede-cbc'] = { key: 16, iv: 8 }),
              (i['des-ede'] = { key: 16, iv: 0 }))
          },
          {},
        ],
        209: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = t('bn.js'),
                  a = t('randombytes')
                function l(u) {
                  var f,
                    d = u.modulus.byteLength()
                  do f = new o(a(d))
                  while (f.cmp(u.modulus) >= 0 || !f.umod(u.prime1) || !f.umod(u.prime2))
                  return f
                }
                function c(u, f) {
                  var d = (function (B) {
                      var E = l(B)
                      return {
                        blinder: E.toRed(o.mont(B.modulus))
                          .redPow(new o(B.publicExponent))
                          .fromRed(),
                        unblinder: E.invm(B.modulus),
                      }
                    })(f),
                    h = f.modulus.byteLength(),
                    p = new o(u).mul(d.blinder).umod(f.modulus),
                    g = p.toRed(o.mont(f.prime1)),
                    m = p.toRed(o.mont(f.prime2)),
                    y = f.coefficient,
                    b = f.prime1,
                    w = f.prime2,
                    C = g.redPow(f.exponent1).fromRed(),
                    T = m.redPow(f.exponent2).fromRed(),
                    I = C.isub(T).imul(y).umod(b).imul(w)
                  return T.iadd(I).imul(d.unblinder).umod(f.modulus).toArrayLike(s, 'be', h)
                }
                ;((c.getr = l), (r.exports = c))
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { 'bn.js': 186, buffer: 220, randombytes: 475 },
        ],
        210: [
          function (t, r, i) {
            r.exports = t('./browser/algorithms.json')
          },
          { './browser/algorithms.json': 211 },
        ],
        211: [
          function (t, r, i) {
            r.exports = {
              sha224WithRSAEncryption: {
                sign: 'rsa',
                hash: 'sha224',
                id: '302d300d06096086480165030402040500041c',
              },
              'RSA-SHA224': {
                sign: 'ecdsa/rsa',
                hash: 'sha224',
                id: '302d300d06096086480165030402040500041c',
              },
              sha256WithRSAEncryption: {
                sign: 'rsa',
                hash: 'sha256',
                id: '3031300d060960864801650304020105000420',
              },
              'RSA-SHA256': {
                sign: 'ecdsa/rsa',
                hash: 'sha256',
                id: '3031300d060960864801650304020105000420',
              },
              sha384WithRSAEncryption: {
                sign: 'rsa',
                hash: 'sha384',
                id: '3041300d060960864801650304020205000430',
              },
              'RSA-SHA384': {
                sign: 'ecdsa/rsa',
                hash: 'sha384',
                id: '3041300d060960864801650304020205000430',
              },
              sha512WithRSAEncryption: {
                sign: 'rsa',
                hash: 'sha512',
                id: '3051300d060960864801650304020305000440',
              },
              'RSA-SHA512': {
                sign: 'ecdsa/rsa',
                hash: 'sha512',
                id: '3051300d060960864801650304020305000440',
              },
              'RSA-SHA1': { sign: 'rsa', hash: 'sha1', id: '3021300906052b0e03021a05000414' },
              'ecdsa-with-SHA1': { sign: 'ecdsa', hash: 'sha1', id: '' },
              sha256: { sign: 'ecdsa', hash: 'sha256', id: '' },
              sha224: { sign: 'ecdsa', hash: 'sha224', id: '' },
              sha384: { sign: 'ecdsa', hash: 'sha384', id: '' },
              sha512: { sign: 'ecdsa', hash: 'sha512', id: '' },
              'DSA-SHA': { sign: 'dsa', hash: 'sha1', id: '' },
              'DSA-SHA1': { sign: 'dsa', hash: 'sha1', id: '' },
              DSA: { sign: 'dsa', hash: 'sha1', id: '' },
              'DSA-WITH-SHA224': { sign: 'dsa', hash: 'sha224', id: '' },
              'DSA-SHA224': { sign: 'dsa', hash: 'sha224', id: '' },
              'DSA-WITH-SHA256': { sign: 'dsa', hash: 'sha256', id: '' },
              'DSA-SHA256': { sign: 'dsa', hash: 'sha256', id: '' },
              'DSA-WITH-SHA384': { sign: 'dsa', hash: 'sha384', id: '' },
              'DSA-SHA384': { sign: 'dsa', hash: 'sha384', id: '' },
              'DSA-WITH-SHA512': { sign: 'dsa', hash: 'sha512', id: '' },
              'DSA-SHA512': { sign: 'dsa', hash: 'sha512', id: '' },
              'DSA-RIPEMD160': { sign: 'dsa', hash: 'rmd160', id: '' },
              ripemd160WithRSA: {
                sign: 'rsa',
                hash: 'rmd160',
                id: '3021300906052b2403020105000414',
              },
              'RSA-RIPEMD160': {
                sign: 'rsa',
                hash: 'rmd160',
                id: '3021300906052b2403020105000414',
              },
              md5WithRSAEncryption: {
                sign: 'rsa',
                hash: 'md5',
                id: '3020300c06082a864886f70d020505000410',
              },
              'RSA-MD5': { sign: 'rsa', hash: 'md5', id: '3020300c06082a864886f70d020505000410' },
            }
          },
          {},
        ],
        212: [
          function (t, r, i) {
            r.exports = {
              '1.3.132.0.10': 'secp256k1',
              '1.3.132.0.33': 'p224',
              '1.2.840.10045.3.1.1': 'p192',
              '1.2.840.10045.3.1.7': 'p256',
              '1.3.132.0.34': 'p384',
              '1.3.132.0.35': 'p521',
            }
          },
          {},
        ],
        213: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('create-hash'),
              a = t('readable-stream'),
              l = t('inherits'),
              c = t('./sign'),
              u = t('./verify'),
              f = t('./algorithms.json')
            function d(m) {
              a.Writable.call(this)
              var y = f[m]
              if (!y) throw new Error('Unknown message digest')
              ;((this._hashType = y.hash),
                (this._hash = o(y.hash)),
                (this._tag = y.id),
                (this._signType = y.sign))
            }
            function h(m) {
              a.Writable.call(this)
              var y = f[m]
              if (!y) throw new Error('Unknown message digest')
              ;((this._hash = o(y.hash)), (this._tag = y.id), (this._signType = y.sign))
            }
            function p(m) {
              return new d(m)
            }
            function g(m) {
              return new h(m)
            }
            ;(Object.keys(f).forEach(function (m) {
              ;((f[m].id = s.from(f[m].id, 'hex')), (f[m.toLowerCase()] = f[m]))
            }),
              l(d, a.Writable),
              (d.prototype._write = function (m, y, b) {
                ;(this._hash.update(m), b())
              }),
              (d.prototype.update = function (m, y) {
                return (typeof m == 'string' && (m = s.from(m, y)), this._hash.update(m), this)
              }),
              (d.prototype.sign = function (m, y) {
                this.end()
                var b = this._hash.digest(),
                  w = c(b, m, this._hashType, this._signType, this._tag)
                return y ? w.toString(y) : w
              }),
              l(h, a.Writable),
              (h.prototype._write = function (m, y, b) {
                ;(this._hash.update(m), b())
              }),
              (h.prototype.update = function (m, y) {
                return (typeof m == 'string' && (m = s.from(m, y)), this._hash.update(m), this)
              }),
              (h.prototype.verify = function (m, y, b) {
                ;(typeof y == 'string' && (y = s.from(y, b)), this.end())
                var w = this._hash.digest()
                return u(y, w, m, this._signType, this._tag)
              }),
              (r.exports = { Sign: p, Verify: g, createSign: p, createVerify: g }))
          },
          {
            './algorithms.json': 211,
            './sign': 214,
            './verify': 215,
            'create-hash': 386,
            inherits: 440,
            'readable-stream': 491,
            'safe-buffer': 494,
          },
        ],
        214: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('create-hmac'),
              a = t('browserify-rsa'),
              l = t('elliptic').ec,
              c = t('bn.js'),
              u = t('parse-asn1'),
              f = t('./curves.json')
            function d(m, y, b, w) {
              if ((m = s.from(m.toArray())).length < y.byteLength()) {
                var C = s.alloc(y.byteLength() - m.length)
                m = s.concat([C, m])
              }
              var T = b.length,
                I = (function (O, P) {
                  O = (O = h(O, P)).mod(P)
                  var $ = s.from(O.toArray())
                  if ($.length < P.byteLength()) {
                    var F = s.alloc(P.byteLength() - $.length)
                    $ = s.concat([F, $])
                  }
                  return $
                })(b, y),
                B = s.alloc(T)
              B.fill(1)
              var E = s.alloc(T)
              return (
                (E = o(w, E)
                  .update(B)
                  .update(s.from([0]))
                  .update(m)
                  .update(I)
                  .digest()),
                (B = o(w, E).update(B).digest()),
                {
                  k: (E = o(w, E)
                    .update(B)
                    .update(s.from([1]))
                    .update(m)
                    .update(I)
                    .digest()),
                  v: (B = o(w, E).update(B).digest()),
                }
              )
            }
            function h(m, y) {
              var b = new c(m),
                w = (m.length << 3) - y.bitLength()
              return (w > 0 && b.ishrn(w), b)
            }
            function p(m, y, b) {
              var w, C
              do {
                for (w = s.alloc(0); 8 * w.length < m.bitLength(); )
                  ((y.v = o(b, y.k).update(y.v).digest()), (w = s.concat([w, y.v])))
                ;((C = h(w, m)),
                  (y.k = o(b, y.k)
                    .update(y.v)
                    .update(s.from([0]))
                    .digest()),
                  (y.v = o(b, y.k).update(y.v).digest()))
              } while (C.cmp(m) !== -1)
              return C
            }
            function g(m, y, b, w) {
              return m.toRed(c.mont(b)).redPow(y).fromRed().mod(w)
            }
            ;((r.exports = function (m, y, b, w, C) {
              var T = u(y)
              if (T.curve) {
                if (w !== 'ecdsa' && w !== 'ecdsa/rsa') throw new Error('wrong private key type')
                return (function (O, P) {
                  var $ = f[P.curve.join('.')]
                  if (!$) throw new Error('unknown curve ' + P.curve.join('.'))
                  var F = new l($).keyFromPrivate(P.privateKey).sign(O)
                  return s.from(F.toDER())
                })(m, T)
              }
              if (T.type === 'dsa') {
                if (w !== 'dsa') throw new Error('wrong private key type')
                return (function (O, P, $) {
                  for (
                    var F,
                      M = P.params.priv_key,
                      R = P.params.p,
                      k = P.params.q,
                      v = P.params.g,
                      x = new c(0),
                      _ = h(O, k).mod(k),
                      S = !1,
                      A = d(M, k, O, $);
                    S === !1;

                  )
                    ((F = p(k, A, $)),
                      (x = g(v, F, R, k)),
                      (S = F.invm(k)
                        .imul(_.add(M.mul(x)))
                        .mod(k)).cmpn(0) === 0 && ((S = !1), (x = new c(0))))
                  return (function (j, L) {
                    ;((j = j.toArray()),
                      (L = L.toArray()),
                      128 & j[0] && (j = [0].concat(j)),
                      128 & L[0] && (L = [0].concat(L)))
                    var H = [48, j.length + L.length + 4, 2, j.length]
                    return ((H = H.concat(j, [2, L.length], L)), s.from(H))
                  })(x, S)
                })(m, T, b)
              }
              if (w !== 'rsa' && w !== 'ecdsa/rsa') throw new Error('wrong private key type')
              m = s.concat([C, m])
              for (var I = T.modulus.byteLength(), B = [0, 1]; m.length + B.length + 1 < I; )
                B.push(255)
              B.push(0)
              for (var E = -1; ++E < m.length; ) B.push(m[E])
              return a(B, T)
            }),
              (r.exports.getKey = d),
              (r.exports.makeKey = p))
          },
          {
            './curves.json': 212,
            'bn.js': 186,
            'browserify-rsa': 209,
            'create-hmac': 388,
            elliptic: 405,
            'parse-asn1': 459,
            'safe-buffer': 494,
          },
        ],
        215: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('bn.js'),
              a = t('elliptic').ec,
              l = t('parse-asn1'),
              c = t('./curves.json')
            function u(f, d) {
              if (f.cmpn(0) <= 0) throw new Error('invalid sig')
              if (f.cmp(d) >= d) throw new Error('invalid sig')
            }
            r.exports = function (f, d, h, p, g) {
              var m = l(h)
              if (m.type === 'ec') {
                if (p !== 'ecdsa' && p !== 'ecdsa/rsa') throw new Error('wrong public key type')
                return (function (B, E, O) {
                  var P = c[O.data.algorithm.curve.join('.')]
                  if (!P) throw new Error('unknown curve ' + O.data.algorithm.curve.join('.'))
                  var $ = new a(P),
                    F = O.data.subjectPrivateKey.data
                  return $.verify(E, B, F)
                })(f, d, m)
              }
              if (m.type === 'dsa') {
                if (p !== 'dsa') throw new Error('wrong public key type')
                return (function (B, E, O) {
                  var P = O.data.p,
                    $ = O.data.q,
                    F = O.data.g,
                    M = O.data.pub_key,
                    R = l.signature.decode(B, 'der'),
                    k = R.s,
                    v = R.r
                  ;(u(k, $), u(v, $))
                  var x = o.mont(P),
                    _ = k.invm($)
                  return (
                    F.toRed(x)
                      .redPow(new o(E).mul(_).mod($))
                      .fromRed()
                      .mul(M.toRed(x).redPow(v.mul(_).mod($)).fromRed())
                      .mod(P)
                      .mod($)
                      .cmp(v) === 0
                  )
                })(f, d, m)
              }
              if (p !== 'rsa' && p !== 'ecdsa/rsa') throw new Error('wrong public key type')
              d = s.concat([g, d])
              for (var y = m.modulus.byteLength(), b = [1], w = 0; d.length + b.length + 2 < y; )
                (b.push(255), w++)
              b.push(0)
              for (var C = -1; ++C < d.length; ) b.push(d[C])
              b = s.from(b)
              var T = o.mont(m.modulus)
              ;((f = (f = new o(f).toRed(T)).redPow(new o(m.publicExponent))),
                (f = s.from(f.fromRed().toArray())))
              var I = w < 8 ? 1 : 0
              for (
                y = Math.min(f.length, b.length), f.length !== b.length && (I = 1), C = -1;
                ++C < y;

              )
                I |= f[C] ^ b[C]
              return I === 0
            }
          },
          {
            './curves.json': 212,
            'bn.js': 186,
            elliptic: 405,
            'parse-asn1': 459,
            'safe-buffer': 494,
          },
        ],
        216: [function (t, r, i) {}, {}],
        217: [
          function (t, r, i) {
            var s = t('buffer'),
              o = s.Buffer
            function a(c, u) {
              for (var f in c) u[f] = c[f]
            }
            function l(c, u, f) {
              return o(c, u, f)
            }
            ;(o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow
              ? (r.exports = s)
              : (a(s, i), (i.Buffer = l)),
              a(o, l),
              (l.from = function (c, u, f) {
                if (typeof c == 'number') throw new TypeError('Argument must not be a number')
                return o(c, u, f)
              }),
              (l.alloc = function (c, u, f) {
                if (typeof c != 'number') throw new TypeError('Argument must be a number')
                var d = o(c)
                return (
                  u !== void 0 ? (typeof f == 'string' ? d.fill(u, f) : d.fill(u)) : d.fill(0),
                  d
                )
              }),
              (l.allocUnsafe = function (c) {
                if (typeof c != 'number') throw new TypeError('Argument must be a number')
                return o(c)
              }),
              (l.allocUnsafeSlow = function (c) {
                if (typeof c != 'number') throw new TypeError('Argument must be a number')
                return s.SlowBuffer(c)
              }))
          },
          { buffer: 220 },
        ],
        218: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o =
                s.isEncoding ||
                function (m) {
                  switch ((m = '' + m) && m.toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                    case 'raw':
                      return !0
                    default:
                      return !1
                  }
                }
            function a(m) {
              var y
              switch (
                ((this.encoding = (function (b) {
                  var w = (function (C) {
                    if (!C) return 'utf8'
                    for (var T; ; )
                      switch (C) {
                        case 'utf8':
                        case 'utf-8':
                          return 'utf8'
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                          return 'utf16le'
                        case 'latin1':
                        case 'binary':
                          return 'latin1'
                        case 'base64':
                        case 'ascii':
                        case 'hex':
                          return C
                        default:
                          if (T) return
                          ;((C = ('' + C).toLowerCase()), (T = !0))
                      }
                  })(b)
                  if (typeof w != 'string' && (s.isEncoding === o || !o(b)))
                    throw new Error('Unknown encoding: ' + b)
                  return w || b
                })(m)),
                this.encoding)
              ) {
                case 'utf16le':
                  ;((this.text = u), (this.end = f), (y = 4))
                  break
                case 'utf8':
                  ;((this.fillLast = c), (y = 4))
                  break
                case 'base64':
                  ;((this.text = d), (this.end = h), (y = 3))
                  break
                default:
                  return ((this.write = p), void (this.end = g))
              }
              ;((this.lastNeed = 0), (this.lastTotal = 0), (this.lastChar = s.allocUnsafe(y)))
            }
            function l(m) {
              return m <= 127
                ? 0
                : m >> 5 == 6
                  ? 2
                  : m >> 4 == 14
                    ? 3
                    : m >> 3 == 30
                      ? 4
                      : m >> 6 == 2
                        ? -1
                        : -2
            }
            function c(m) {
              var y = this.lastTotal - this.lastNeed,
                b = (function (w, C, T) {
                  if ((192 & C[0]) != 128) return ((w.lastNeed = 0), '')
                  if (w.lastNeed > 1 && C.length > 1) {
                    if ((192 & C[1]) != 128) return ((w.lastNeed = 1), '')
                    if (w.lastNeed > 2 && C.length > 2 && (192 & C[2]) != 128)
                      return ((w.lastNeed = 2), '')
                  }
                })(this, m)
              return b !== void 0
                ? b
                : this.lastNeed <= m.length
                  ? (m.copy(this.lastChar, y, 0, this.lastNeed),
                    this.lastChar.toString(this.encoding, 0, this.lastTotal))
                  : (m.copy(this.lastChar, y, 0, m.length), void (this.lastNeed -= m.length))
            }
            function u(m, y) {
              if ((m.length - y) % 2 == 0) {
                var b = m.toString('utf16le', y)
                if (b) {
                  var w = b.charCodeAt(b.length - 1)
                  if (w >= 55296 && w <= 56319)
                    return (
                      (this.lastNeed = 2),
                      (this.lastTotal = 4),
                      (this.lastChar[0] = m[m.length - 2]),
                      (this.lastChar[1] = m[m.length - 1]),
                      b.slice(0, -1)
                    )
                }
                return b
              }
              return (
                (this.lastNeed = 1),
                (this.lastTotal = 2),
                (this.lastChar[0] = m[m.length - 1]),
                m.toString('utf16le', y, m.length - 1)
              )
            }
            function f(m) {
              var y = m && m.length ? this.write(m) : ''
              if (this.lastNeed) {
                var b = this.lastTotal - this.lastNeed
                return y + this.lastChar.toString('utf16le', 0, b)
              }
              return y
            }
            function d(m, y) {
              var b = (m.length - y) % 3
              return b === 0
                ? m.toString('base64', y)
                : ((this.lastNeed = 3 - b),
                  (this.lastTotal = 3),
                  b === 1
                    ? (this.lastChar[0] = m[m.length - 1])
                    : ((this.lastChar[0] = m[m.length - 2]), (this.lastChar[1] = m[m.length - 1])),
                  m.toString('base64', y, m.length - b))
            }
            function h(m) {
              var y = m && m.length ? this.write(m) : ''
              return this.lastNeed ? y + this.lastChar.toString('base64', 0, 3 - this.lastNeed) : y
            }
            function p(m) {
              return m.toString(this.encoding)
            }
            function g(m) {
              return m && m.length ? this.write(m) : ''
            }
            ;((i.StringDecoder = a),
              (a.prototype.write = function (m) {
                if (m.length === 0) return ''
                var y, b
                if (this.lastNeed) {
                  if ((y = this.fillLast(m)) === void 0) return ''
                  ;((b = this.lastNeed), (this.lastNeed = 0))
                } else b = 0
                return b < m.length ? (y ? y + this.text(m, b) : this.text(m, b)) : y || ''
              }),
              (a.prototype.end = function (m) {
                var y = m && m.length ? this.write(m) : ''
                return this.lastNeed ? y + '' : y
              }),
              (a.prototype.text = function (m, y) {
                var b = (function (C, T, I) {
                  var B = T.length - 1
                  if (B < I) return 0
                  var E = l(T[B])
                  return E >= 0
                    ? (E > 0 && (C.lastNeed = E - 1), E)
                    : --B < I || E === -2
                      ? 0
                      : (E = l(T[B])) >= 0
                        ? (E > 0 && (C.lastNeed = E - 2), E)
                        : --B < I || E === -2
                          ? 0
                          : (E = l(T[B])) >= 0
                            ? (E > 0 && (E === 2 ? (E = 0) : (C.lastNeed = E - 3)), E)
                            : 0
                })(this, m, y)
                if (!this.lastNeed) return m.toString('utf8', y)
                this.lastTotal = b
                var w = m.length - (b - this.lastNeed)
                return (m.copy(this.lastChar, 0, w), m.toString('utf8', y, w))
              }),
              (a.prototype.fillLast = function (m) {
                if (this.lastNeed <= m.length)
                  return (
                    m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
                    this.lastChar.toString(this.encoding, 0, this.lastTotal)
                  )
                ;(m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, m.length),
                  (this.lastNeed -= m.length))
              }))
          },
          { 'safe-buffer': 217 },
        ],
        219: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                r.exports = function (o, a) {
                  for (var l = Math.min(o.length, a.length), c = new s(l), u = 0; u < l; ++u)
                    c[u] = o[u] ^ a[u]
                  return c
                }
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { buffer: 220 },
        ],
        220: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = t('base64-js'),
                  a = t('ieee754')
                ;((i.Buffer = c),
                  (i.SlowBuffer = function (D) {
                    return (+D != D && (D = 0), c.alloc(+D))
                  }),
                  (i.INSPECT_MAX_BYTES = 50))
                function l(D) {
                  if (D > 2147483647)
                    throw new RangeError('The value "' + D + '" is invalid for option "size"')
                  var N = new Uint8Array(D)
                  return ((N.__proto__ = c.prototype), N)
                }
                function c(D, N, V) {
                  if (typeof D == 'number') {
                    if (typeof N == 'string')
                      throw new TypeError(
                        'The "string" argument must be of type string. Received type number',
                      )
                    return d(D)
                  }
                  return u(D, N, V)
                }
                function u(D, N, V) {
                  if (typeof D == 'string')
                    return (function (G, Z) {
                      if (((typeof Z == 'string' && Z !== '') || (Z = 'utf8'), !c.isEncoding(Z)))
                        throw new TypeError('Unknown encoding: ' + Z)
                      var rt = 0 | g(G, Z),
                        nt = l(rt),
                        X = nt.write(G, Z)
                      return (X !== rt && (nt = nt.slice(0, X)), nt)
                    })(D, N)
                  if (ArrayBuffer.isView(D)) return h(D)
                  if (D == null)
                    throw TypeError(
                      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                        typeof D,
                    )
                  if (z(D, ArrayBuffer) || (D && z(D.buffer, ArrayBuffer)))
                    return (function (G, Z, rt) {
                      if (Z < 0 || G.byteLength < Z)
                        throw new RangeError('"offset" is outside of buffer bounds')
                      if (G.byteLength < Z + (rt || 0))
                        throw new RangeError('"length" is outside of buffer bounds')
                      var nt
                      return (
                        (nt =
                          Z === void 0 && rt === void 0
                            ? new Uint8Array(G)
                            : rt === void 0
                              ? new Uint8Array(G, Z)
                              : new Uint8Array(G, Z, rt)),
                        (nt.__proto__ = c.prototype),
                        nt
                      )
                    })(D, N, V)
                  if (typeof D == 'number')
                    throw new TypeError(
                      'The "value" argument must not be of type number. Received type number',
                    )
                  var W = D.valueOf && D.valueOf()
                  if (W != null && W !== D) return c.from(W, N, V)
                  var J = (function (G) {
                    if (c.isBuffer(G)) {
                      var Z = 0 | p(G.length),
                        rt = l(Z)
                      return (rt.length === 0 || G.copy(rt, 0, 0, Z), rt)
                    }
                    if (G.length !== void 0)
                      return typeof G.length != 'number' || q(G.length) ? l(0) : h(G)
                    if (G.type === 'Buffer' && Array.isArray(G.data)) return h(G.data)
                  })(D)
                  if (J) return J
                  if (
                    typeof Symbol < 'u' &&
                    Symbol.toPrimitive != null &&
                    typeof D[Symbol.toPrimitive] == 'function'
                  )
                    return c.from(D[Symbol.toPrimitive]('string'), N, V)
                  throw new TypeError(
                    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                      typeof D,
                  )
                }
                function f(D) {
                  if (typeof D != 'number')
                    throw new TypeError('"size" argument must be of type number')
                  if (D < 0)
                    throw new RangeError('The value "' + D + '" is invalid for option "size"')
                }
                function d(D) {
                  return (f(D), l(D < 0 ? 0 : 0 | p(D)))
                }
                function h(D) {
                  for (var N = D.length < 0 ? 0 : 0 | p(D.length), V = l(N), W = 0; W < N; W += 1)
                    V[W] = 255 & D[W]
                  return V
                }
                function p(D) {
                  if (D >= 2147483647)
                    throw new RangeError(
                      'Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes',
                    )
                  return 0 | D
                }
                function g(D, N) {
                  if (c.isBuffer(D)) return D.length
                  if (ArrayBuffer.isView(D) || z(D, ArrayBuffer)) return D.byteLength
                  if (typeof D != 'string')
                    throw new TypeError(
                      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                        typeof D,
                    )
                  var V = D.length,
                    W = arguments.length > 2 && arguments[2] === !0
                  if (!W && V === 0) return 0
                  for (var J = !1; ; )
                    switch (N) {
                      case 'ascii':
                      case 'latin1':
                      case 'binary':
                        return V
                      case 'utf8':
                      case 'utf-8':
                        return H(D).length
                      case 'ucs2':
                      case 'ucs-2':
                      case 'utf16le':
                      case 'utf-16le':
                        return 2 * V
                      case 'hex':
                        return V >>> 1
                      case 'base64':
                        return U(D).length
                      default:
                        if (J) return W ? -1 : H(D).length
                        ;((N = ('' + N).toLowerCase()), (J = !0))
                    }
                }
                function m(D, N, V) {
                  var W = !1
                  if (
                    ((N === void 0 || N < 0) && (N = 0),
                    N > this.length ||
                      ((V === void 0 || V > this.length) && (V = this.length), V <= 0) ||
                      (V >>>= 0) <= (N >>>= 0))
                  )
                    return ''
                  for (D || (D = 'utf8'); ; )
                    switch (D) {
                      case 'hex':
                        return R(this, N, V)
                      case 'utf8':
                      case 'utf-8':
                        return $(this, N, V)
                      case 'ascii':
                        return F(this, N, V)
                      case 'latin1':
                      case 'binary':
                        return M(this, N, V)
                      case 'base64':
                        return P(this, N, V)
                      case 'ucs2':
                      case 'ucs-2':
                      case 'utf16le':
                      case 'utf-16le':
                        return k(this, N, V)
                      default:
                        if (W) throw new TypeError('Unknown encoding: ' + D)
                        ;((D = (D + '').toLowerCase()), (W = !0))
                    }
                }
                function y(D, N, V) {
                  var W = D[N]
                  ;((D[N] = D[V]), (D[V] = W))
                }
                function b(D, N, V, W, J) {
                  if (D.length === 0) return -1
                  if (
                    (typeof V == 'string'
                      ? ((W = V), (V = 0))
                      : V > 2147483647
                        ? (V = 2147483647)
                        : V < -2147483648 && (V = -2147483648),
                    q((V = +V)) && (V = J ? 0 : D.length - 1),
                    V < 0 && (V = D.length + V),
                    V >= D.length)
                  ) {
                    if (J) return -1
                    V = D.length - 1
                  } else if (V < 0) {
                    if (!J) return -1
                    V = 0
                  }
                  if ((typeof N == 'string' && (N = c.from(N, W)), c.isBuffer(N)))
                    return N.length === 0 ? -1 : w(D, N, V, W, J)
                  if (typeof N == 'number')
                    return (
                      (N &= 255),
                      typeof Uint8Array.prototype.indexOf == 'function'
                        ? J
                          ? Uint8Array.prototype.indexOf.call(D, N, V)
                          : Uint8Array.prototype.lastIndexOf.call(D, N, V)
                        : w(D, [N], V, W, J)
                    )
                  throw new TypeError('val must be string, number or Buffer')
                }
                function w(D, N, V, W, J) {
                  var G,
                    Z = 1,
                    rt = D.length,
                    nt = N.length
                  if (
                    W !== void 0 &&
                    ((W = String(W).toLowerCase()) === 'ucs2' ||
                      W === 'ucs-2' ||
                      W === 'utf16le' ||
                      W === 'utf-16le')
                  ) {
                    if (D.length < 2 || N.length < 2) return -1
                    ;((Z = 2), (rt /= 2), (nt /= 2), (V /= 2))
                  }
                  function X(ot, at) {
                    return Z === 1 ? ot[at] : ot.readUInt16BE(at * Z)
                  }
                  if (J) {
                    var Q = -1
                    for (G = V; G < rt; G++)
                      if (X(D, G) === X(N, Q === -1 ? 0 : G - Q)) {
                        if ((Q === -1 && (Q = G), G - Q + 1 === nt)) return Q * Z
                      } else (Q !== -1 && (G -= G - Q), (Q = -1))
                  } else
                    for (V + nt > rt && (V = rt - nt), G = V; G >= 0; G--) {
                      for (var tt = !0, st = 0; st < nt; st++)
                        if (X(D, G + st) !== X(N, st)) {
                          tt = !1
                          break
                        }
                      if (tt) return G
                    }
                  return -1
                }
                function C(D, N, V, W) {
                  V = Number(V) || 0
                  var J = D.length - V
                  W ? (W = Number(W)) > J && (W = J) : (W = J)
                  var G = N.length
                  W > G / 2 && (W = G / 2)
                  for (var Z = 0; Z < W; ++Z) {
                    var rt = parseInt(N.substr(2 * Z, 2), 16)
                    if (q(rt)) return Z
                    D[V + Z] = rt
                  }
                  return Z
                }
                function T(D, N, V, W) {
                  return K(H(N, D.length - V), D, V, W)
                }
                function I(D, N, V, W) {
                  return K(
                    (function (J) {
                      for (var G = [], Z = 0; Z < J.length; ++Z) G.push(255 & J.charCodeAt(Z))
                      return G
                    })(N),
                    D,
                    V,
                    W,
                  )
                }
                function B(D, N, V, W) {
                  return I(D, N, V, W)
                }
                function E(D, N, V, W) {
                  return K(U(N), D, V, W)
                }
                function O(D, N, V, W) {
                  return K(
                    (function (J, G) {
                      for (var Z, rt, nt, X = [], Q = 0; Q < J.length && !((G -= 2) < 0); ++Q)
                        ((Z = J.charCodeAt(Q)),
                          (rt = Z >> 8),
                          (nt = Z % 256),
                          X.push(nt),
                          X.push(rt))
                      return X
                    })(N, D.length - V),
                    D,
                    V,
                    W,
                  )
                }
                function P(D, N, V) {
                  return N === 0 && V === D.length
                    ? o.fromByteArray(D)
                    : o.fromByteArray(D.slice(N, V))
                }
                function $(D, N, V) {
                  V = Math.min(D.length, V)
                  for (var W = [], J = N; J < V; ) {
                    var G,
                      Z,
                      rt,
                      nt,
                      X = D[J],
                      Q = null,
                      tt = X > 239 ? 4 : X > 223 ? 3 : X > 191 ? 2 : 1
                    if (J + tt <= V)
                      switch (tt) {
                        case 1:
                          X < 128 && (Q = X)
                          break
                        case 2:
                          ;(192 & (G = D[J + 1])) == 128 &&
                            (nt = ((31 & X) << 6) | (63 & G)) > 127 &&
                            (Q = nt)
                          break
                        case 3:
                          ;((G = D[J + 1]),
                            (Z = D[J + 2]),
                            (192 & G) == 128 &&
                              (192 & Z) == 128 &&
                              (nt = ((15 & X) << 12) | ((63 & G) << 6) | (63 & Z)) > 2047 &&
                              (nt < 55296 || nt > 57343) &&
                              (Q = nt))
                          break
                        case 4:
                          ;((G = D[J + 1]),
                            (Z = D[J + 2]),
                            (rt = D[J + 3]),
                            (192 & G) == 128 &&
                              (192 & Z) == 128 &&
                              (192 & rt) == 128 &&
                              (nt =
                                ((15 & X) << 18) | ((63 & G) << 12) | ((63 & Z) << 6) | (63 & rt)) >
                                65535 &&
                              nt < 1114112 &&
                              (Q = nt))
                      }
                    ;(Q === null
                      ? ((Q = 65533), (tt = 1))
                      : Q > 65535 &&
                        ((Q -= 65536),
                        W.push(((Q >>> 10) & 1023) | 55296),
                        (Q = 56320 | (1023 & Q))),
                      W.push(Q),
                      (J += tt))
                  }
                  return (function (st) {
                    var ot = st.length
                    if (ot <= 4096) return String.fromCharCode.apply(String, st)
                    for (var at = '', ht = 0; ht < ot; )
                      at += String.fromCharCode.apply(String, st.slice(ht, (ht += 4096)))
                    return at
                  })(W)
                }
                ;((i.kMaxLength = 2147483647),
                  (c.TYPED_ARRAY_SUPPORT = (function () {
                    try {
                      var D = new Uint8Array(1)
                      return (
                        (D.__proto__ = {
                          __proto__: Uint8Array.prototype,
                          foo: function () {
                            return 42
                          },
                        }),
                        D.foo() === 42
                      )
                    } catch {
                      return !1
                    }
                  })()),
                  c.TYPED_ARRAY_SUPPORT ||
                    typeof console > 'u' ||
                    typeof console.error != 'function' ||
                    console.error(
                      'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.',
                    ),
                  Object.defineProperty(c.prototype, 'parent', {
                    enumerable: !0,
                    get: function () {
                      if (c.isBuffer(this)) return this.buffer
                    },
                  }),
                  Object.defineProperty(c.prototype, 'offset', {
                    enumerable: !0,
                    get: function () {
                      if (c.isBuffer(this)) return this.byteOffset
                    },
                  }),
                  typeof Symbol < 'u' &&
                    Symbol.species != null &&
                    c[Symbol.species] === c &&
                    Object.defineProperty(c, Symbol.species, {
                      value: null,
                      configurable: !0,
                      enumerable: !1,
                      writable: !1,
                    }),
                  (c.poolSize = 8192),
                  (c.from = function (D, N, V) {
                    return u(D, N, V)
                  }),
                  (c.prototype.__proto__ = Uint8Array.prototype),
                  (c.__proto__ = Uint8Array),
                  (c.alloc = function (D, N, V) {
                    return (function (W, J, G) {
                      return (
                        f(W),
                        W <= 0
                          ? l(W)
                          : J !== void 0
                            ? typeof G == 'string'
                              ? l(W).fill(J, G)
                              : l(W).fill(J)
                            : l(W)
                      )
                    })(D, N, V)
                  }),
                  (c.allocUnsafe = function (D) {
                    return d(D)
                  }),
                  (c.allocUnsafeSlow = function (D) {
                    return d(D)
                  }),
                  (c.isBuffer = function (D) {
                    return D != null && D._isBuffer === !0 && D !== c.prototype
                  }),
                  (c.compare = function (D, N) {
                    if (
                      (z(D, Uint8Array) && (D = c.from(D, D.offset, D.byteLength)),
                      z(N, Uint8Array) && (N = c.from(N, N.offset, N.byteLength)),
                      !c.isBuffer(D) || !c.isBuffer(N))
                    )
                      throw new TypeError(
                        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
                      )
                    if (D === N) return 0
                    for (var V = D.length, W = N.length, J = 0, G = Math.min(V, W); J < G; ++J)
                      if (D[J] !== N[J]) {
                        ;((V = D[J]), (W = N[J]))
                        break
                      }
                    return V < W ? -1 : W < V ? 1 : 0
                  }),
                  (c.isEncoding = function (D) {
                    switch (String(D).toLowerCase()) {
                      case 'hex':
                      case 'utf8':
                      case 'utf-8':
                      case 'ascii':
                      case 'latin1':
                      case 'binary':
                      case 'base64':
                      case 'ucs2':
                      case 'ucs-2':
                      case 'utf16le':
                      case 'utf-16le':
                        return !0
                      default:
                        return !1
                    }
                  }),
                  (c.concat = function (D, N) {
                    if (!Array.isArray(D))
                      throw new TypeError('"list" argument must be an Array of Buffers')
                    if (D.length === 0) return c.alloc(0)
                    var V
                    if (N === void 0) for (N = 0, V = 0; V < D.length; ++V) N += D[V].length
                    var W = c.allocUnsafe(N),
                      J = 0
                    for (V = 0; V < D.length; ++V) {
                      var G = D[V]
                      if ((z(G, Uint8Array) && (G = c.from(G)), !c.isBuffer(G)))
                        throw new TypeError('"list" argument must be an Array of Buffers')
                      ;(G.copy(W, J), (J += G.length))
                    }
                    return W
                  }),
                  (c.byteLength = g),
                  (c.prototype._isBuffer = !0),
                  (c.prototype.swap16 = function () {
                    var D = this.length
                    if (D % 2 != 0)
                      throw new RangeError('Buffer size must be a multiple of 16-bits')
                    for (var N = 0; N < D; N += 2) y(this, N, N + 1)
                    return this
                  }),
                  (c.prototype.swap32 = function () {
                    var D = this.length
                    if (D % 4 != 0)
                      throw new RangeError('Buffer size must be a multiple of 32-bits')
                    for (var N = 0; N < D; N += 4) (y(this, N, N + 3), y(this, N + 1, N + 2))
                    return this
                  }),
                  (c.prototype.swap64 = function () {
                    var D = this.length
                    if (D % 8 != 0)
                      throw new RangeError('Buffer size must be a multiple of 64-bits')
                    for (var N = 0; N < D; N += 8)
                      (y(this, N, N + 7),
                        y(this, N + 1, N + 6),
                        y(this, N + 2, N + 5),
                        y(this, N + 3, N + 4))
                    return this
                  }),
                  (c.prototype.toString = function () {
                    var D = this.length
                    return D === 0
                      ? ''
                      : arguments.length === 0
                        ? $(this, 0, D)
                        : m.apply(this, arguments)
                  }),
                  (c.prototype.toLocaleString = c.prototype.toString),
                  (c.prototype.equals = function (D) {
                    if (!c.isBuffer(D)) throw new TypeError('Argument must be a Buffer')
                    return this === D || c.compare(this, D) === 0
                  }),
                  (c.prototype.inspect = function () {
                    var D = '',
                      N = i.INSPECT_MAX_BYTES
                    return (
                      (D = this.toString('hex', 0, N)
                        .replace(/(.{2})/g, '$1 ')
                        .trim()),
                      this.length > N && (D += ' ... '),
                      '<Buffer ' + D + '>'
                    )
                  }),
                  (c.prototype.compare = function (D, N, V, W, J) {
                    if (
                      (z(D, Uint8Array) && (D = c.from(D, D.offset, D.byteLength)), !c.isBuffer(D))
                    )
                      throw new TypeError(
                        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                          typeof D,
                      )
                    if (
                      (N === void 0 && (N = 0),
                      V === void 0 && (V = D ? D.length : 0),
                      W === void 0 && (W = 0),
                      J === void 0 && (J = this.length),
                      N < 0 || V > D.length || W < 0 || J > this.length)
                    )
                      throw new RangeError('out of range index')
                    if (W >= J && N >= V) return 0
                    if (W >= J) return -1
                    if (N >= V) return 1
                    if (this === D) return 0
                    for (
                      var G = (J >>>= 0) - (W >>>= 0),
                        Z = (V >>>= 0) - (N >>>= 0),
                        rt = Math.min(G, Z),
                        nt = this.slice(W, J),
                        X = D.slice(N, V),
                        Q = 0;
                      Q < rt;
                      ++Q
                    )
                      if (nt[Q] !== X[Q]) {
                        ;((G = nt[Q]), (Z = X[Q]))
                        break
                      }
                    return G < Z ? -1 : Z < G ? 1 : 0
                  }),
                  (c.prototype.includes = function (D, N, V) {
                    return this.indexOf(D, N, V) !== -1
                  }),
                  (c.prototype.indexOf = function (D, N, V) {
                    return b(this, D, N, V, !0)
                  }),
                  (c.prototype.lastIndexOf = function (D, N, V) {
                    return b(this, D, N, V, !1)
                  }),
                  (c.prototype.write = function (D, N, V, W) {
                    if (N === void 0) ((W = 'utf8'), (V = this.length), (N = 0))
                    else if (V === void 0 && typeof N == 'string')
                      ((W = N), (V = this.length), (N = 0))
                    else {
                      if (!isFinite(N))
                        throw new Error(
                          'Buffer.write(string, encoding, offset[, length]) is no longer supported',
                        )
                      ;((N >>>= 0),
                        isFinite(V)
                          ? ((V >>>= 0), W === void 0 && (W = 'utf8'))
                          : ((W = V), (V = void 0)))
                    }
                    var J = this.length - N
                    if (
                      ((V === void 0 || V > J) && (V = J),
                      (D.length > 0 && (V < 0 || N < 0)) || N > this.length)
                    )
                      throw new RangeError('Attempt to write outside buffer bounds')
                    W || (W = 'utf8')
                    for (var G = !1; ; )
                      switch (W) {
                        case 'hex':
                          return C(this, D, N, V)
                        case 'utf8':
                        case 'utf-8':
                          return T(this, D, N, V)
                        case 'ascii':
                          return I(this, D, N, V)
                        case 'latin1':
                        case 'binary':
                          return B(this, D, N, V)
                        case 'base64':
                          return E(this, D, N, V)
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                          return O(this, D, N, V)
                        default:
                          if (G) throw new TypeError('Unknown encoding: ' + W)
                          ;((W = ('' + W).toLowerCase()), (G = !0))
                      }
                  }),
                  (c.prototype.toJSON = function () {
                    return {
                      type: 'Buffer',
                      data: Array.prototype.slice.call(this._arr || this, 0),
                    }
                  }))
                function F(D, N, V) {
                  var W = ''
                  V = Math.min(D.length, V)
                  for (var J = N; J < V; ++J) W += String.fromCharCode(127 & D[J])
                  return W
                }
                function M(D, N, V) {
                  var W = ''
                  V = Math.min(D.length, V)
                  for (var J = N; J < V; ++J) W += String.fromCharCode(D[J])
                  return W
                }
                function R(D, N, V) {
                  var W = D.length
                  ;((!N || N < 0) && (N = 0), (!V || V < 0 || V > W) && (V = W))
                  for (var J = '', G = N; G < V; ++G) J += L(D[G])
                  return J
                }
                function k(D, N, V) {
                  for (var W = D.slice(N, V), J = '', G = 0; G < W.length; G += 2)
                    J += String.fromCharCode(W[G] + 256 * W[G + 1])
                  return J
                }
                function v(D, N, V) {
                  if (D % 1 != 0 || D < 0) throw new RangeError('offset is not uint')
                  if (D + N > V) throw new RangeError('Trying to access beyond buffer length')
                }
                function x(D, N, V, W, J, G) {
                  if (!c.isBuffer(D))
                    throw new TypeError('"buffer" argument must be a Buffer instance')
                  if (N > J || N < G) throw new RangeError('"value" argument is out of bounds')
                  if (V + W > D.length) throw new RangeError('Index out of range')
                }
                function _(D, N, V, W, J, G) {
                  if (V + W > D.length) throw new RangeError('Index out of range')
                  if (V < 0) throw new RangeError('Index out of range')
                }
                function S(D, N, V, W, J) {
                  return (
                    (N = +N),
                    (V >>>= 0),
                    J || _(D, 0, V, 4),
                    a.write(D, N, V, W, 23, 4),
                    V + 4
                  )
                }
                function A(D, N, V, W, J) {
                  return (
                    (N = +N),
                    (V >>>= 0),
                    J || _(D, 0, V, 8),
                    a.write(D, N, V, W, 52, 8),
                    V + 8
                  )
                }
                ;((c.prototype.slice = function (D, N) {
                  var V = this.length
                  ;((D = ~~D) < 0 ? (D += V) < 0 && (D = 0) : D > V && (D = V),
                    (N = N === void 0 ? V : ~~N) < 0 ? (N += V) < 0 && (N = 0) : N > V && (N = V),
                    N < D && (N = D))
                  var W = this.subarray(D, N)
                  return ((W.__proto__ = c.prototype), W)
                }),
                  (c.prototype.readUIntLE = function (D, N, V) {
                    ;((D >>>= 0), (N >>>= 0), V || v(D, N, this.length))
                    for (var W = this[D], J = 1, G = 0; ++G < N && (J *= 256); )
                      W += this[D + G] * J
                    return W
                  }),
                  (c.prototype.readUIntBE = function (D, N, V) {
                    ;((D >>>= 0), (N >>>= 0), V || v(D, N, this.length))
                    for (var W = this[D + --N], J = 1; N > 0 && (J *= 256); ) W += this[D + --N] * J
                    return W
                  }),
                  (c.prototype.readUInt8 = function (D, N) {
                    return ((D >>>= 0), N || v(D, 1, this.length), this[D])
                  }),
                  (c.prototype.readUInt16LE = function (D, N) {
                    return ((D >>>= 0), N || v(D, 2, this.length), this[D] | (this[D + 1] << 8))
                  }),
                  (c.prototype.readUInt16BE = function (D, N) {
                    return ((D >>>= 0), N || v(D, 2, this.length), (this[D] << 8) | this[D + 1])
                  }),
                  (c.prototype.readUInt32LE = function (D, N) {
                    return (
                      (D >>>= 0),
                      N || v(D, 4, this.length),
                      (this[D] | (this[D + 1] << 8) | (this[D + 2] << 16)) + 16777216 * this[D + 3]
                    )
                  }),
                  (c.prototype.readUInt32BE = function (D, N) {
                    return (
                      (D >>>= 0),
                      N || v(D, 4, this.length),
                      16777216 * this[D] + ((this[D + 1] << 16) | (this[D + 2] << 8) | this[D + 3])
                    )
                  }),
                  (c.prototype.readIntLE = function (D, N, V) {
                    ;((D >>>= 0), (N >>>= 0), V || v(D, N, this.length))
                    for (var W = this[D], J = 1, G = 0; ++G < N && (J *= 256); )
                      W += this[D + G] * J
                    return (W >= (J *= 128) && (W -= Math.pow(2, 8 * N)), W)
                  }),
                  (c.prototype.readIntBE = function (D, N, V) {
                    ;((D >>>= 0), (N >>>= 0), V || v(D, N, this.length))
                    for (var W = N, J = 1, G = this[D + --W]; W > 0 && (J *= 256); )
                      G += this[D + --W] * J
                    return (G >= (J *= 128) && (G -= Math.pow(2, 8 * N)), G)
                  }),
                  (c.prototype.readInt8 = function (D, N) {
                    return (
                      (D >>>= 0),
                      N || v(D, 1, this.length),
                      128 & this[D] ? -1 * (255 - this[D] + 1) : this[D]
                    )
                  }),
                  (c.prototype.readInt16LE = function (D, N) {
                    ;((D >>>= 0), N || v(D, 2, this.length))
                    var V = this[D] | (this[D + 1] << 8)
                    return 32768 & V ? 4294901760 | V : V
                  }),
                  (c.prototype.readInt16BE = function (D, N) {
                    ;((D >>>= 0), N || v(D, 2, this.length))
                    var V = this[D + 1] | (this[D] << 8)
                    return 32768 & V ? 4294901760 | V : V
                  }),
                  (c.prototype.readInt32LE = function (D, N) {
                    return (
                      (D >>>= 0),
                      N || v(D, 4, this.length),
                      this[D] | (this[D + 1] << 8) | (this[D + 2] << 16) | (this[D + 3] << 24)
                    )
                  }),
                  (c.prototype.readInt32BE = function (D, N) {
                    return (
                      (D >>>= 0),
                      N || v(D, 4, this.length),
                      (this[D] << 24) | (this[D + 1] << 16) | (this[D + 2] << 8) | this[D + 3]
                    )
                  }),
                  (c.prototype.readFloatLE = function (D, N) {
                    return ((D >>>= 0), N || v(D, 4, this.length), a.read(this, D, !0, 23, 4))
                  }),
                  (c.prototype.readFloatBE = function (D, N) {
                    return ((D >>>= 0), N || v(D, 4, this.length), a.read(this, D, !1, 23, 4))
                  }),
                  (c.prototype.readDoubleLE = function (D, N) {
                    return ((D >>>= 0), N || v(D, 8, this.length), a.read(this, D, !0, 52, 8))
                  }),
                  (c.prototype.readDoubleBE = function (D, N) {
                    return ((D >>>= 0), N || v(D, 8, this.length), a.read(this, D, !1, 52, 8))
                  }),
                  (c.prototype.writeUIntLE = function (D, N, V, W) {
                    ;((D = +D),
                      (N >>>= 0),
                      (V >>>= 0),
                      W || x(this, D, N, V, Math.pow(2, 8 * V) - 1, 0))
                    var J = 1,
                      G = 0
                    for (this[N] = 255 & D; ++G < V && (J *= 256); ) this[N + G] = (D / J) & 255
                    return N + V
                  }),
                  (c.prototype.writeUIntBE = function (D, N, V, W) {
                    ;((D = +D),
                      (N >>>= 0),
                      (V >>>= 0),
                      W || x(this, D, N, V, Math.pow(2, 8 * V) - 1, 0))
                    var J = V - 1,
                      G = 1
                    for (this[N + J] = 255 & D; --J >= 0 && (G *= 256); )
                      this[N + J] = (D / G) & 255
                    return N + V
                  }),
                  (c.prototype.writeUInt8 = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 1, 255, 0),
                      (this[N] = 255 & D),
                      N + 1
                    )
                  }),
                  (c.prototype.writeUInt16LE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 2, 65535, 0),
                      (this[N] = 255 & D),
                      (this[N + 1] = D >>> 8),
                      N + 2
                    )
                  }),
                  (c.prototype.writeUInt16BE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 2, 65535, 0),
                      (this[N] = D >>> 8),
                      (this[N + 1] = 255 & D),
                      N + 2
                    )
                  }),
                  (c.prototype.writeUInt32LE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 4, 4294967295, 0),
                      (this[N + 3] = D >>> 24),
                      (this[N + 2] = D >>> 16),
                      (this[N + 1] = D >>> 8),
                      (this[N] = 255 & D),
                      N + 4
                    )
                  }),
                  (c.prototype.writeUInt32BE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 4, 4294967295, 0),
                      (this[N] = D >>> 24),
                      (this[N + 1] = D >>> 16),
                      (this[N + 2] = D >>> 8),
                      (this[N + 3] = 255 & D),
                      N + 4
                    )
                  }),
                  (c.prototype.writeIntLE = function (D, N, V, W) {
                    if (((D = +D), (N >>>= 0), !W)) {
                      var J = Math.pow(2, 8 * V - 1)
                      x(this, D, N, V, J - 1, -J)
                    }
                    var G = 0,
                      Z = 1,
                      rt = 0
                    for (this[N] = 255 & D; ++G < V && (Z *= 256); )
                      (D < 0 && rt === 0 && this[N + G - 1] !== 0 && (rt = 1),
                        (this[N + G] = (((D / Z) >> 0) - rt) & 255))
                    return N + V
                  }),
                  (c.prototype.writeIntBE = function (D, N, V, W) {
                    if (((D = +D), (N >>>= 0), !W)) {
                      var J = Math.pow(2, 8 * V - 1)
                      x(this, D, N, V, J - 1, -J)
                    }
                    var G = V - 1,
                      Z = 1,
                      rt = 0
                    for (this[N + G] = 255 & D; --G >= 0 && (Z *= 256); )
                      (D < 0 && rt === 0 && this[N + G + 1] !== 0 && (rt = 1),
                        (this[N + G] = (((D / Z) >> 0) - rt) & 255))
                    return N + V
                  }),
                  (c.prototype.writeInt8 = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 1, 127, -128),
                      D < 0 && (D = 255 + D + 1),
                      (this[N] = 255 & D),
                      N + 1
                    )
                  }),
                  (c.prototype.writeInt16LE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 2, 32767, -32768),
                      (this[N] = 255 & D),
                      (this[N + 1] = D >>> 8),
                      N + 2
                    )
                  }),
                  (c.prototype.writeInt16BE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 2, 32767, -32768),
                      (this[N] = D >>> 8),
                      (this[N + 1] = 255 & D),
                      N + 2
                    )
                  }),
                  (c.prototype.writeInt32LE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 4, 2147483647, -2147483648),
                      (this[N] = 255 & D),
                      (this[N + 1] = D >>> 8),
                      (this[N + 2] = D >>> 16),
                      (this[N + 3] = D >>> 24),
                      N + 4
                    )
                  }),
                  (c.prototype.writeInt32BE = function (D, N, V) {
                    return (
                      (D = +D),
                      (N >>>= 0),
                      V || x(this, D, N, 4, 2147483647, -2147483648),
                      D < 0 && (D = 4294967295 + D + 1),
                      (this[N] = D >>> 24),
                      (this[N + 1] = D >>> 16),
                      (this[N + 2] = D >>> 8),
                      (this[N + 3] = 255 & D),
                      N + 4
                    )
                  }),
                  (c.prototype.writeFloatLE = function (D, N, V) {
                    return S(this, D, N, !0, V)
                  }),
                  (c.prototype.writeFloatBE = function (D, N, V) {
                    return S(this, D, N, !1, V)
                  }),
                  (c.prototype.writeDoubleLE = function (D, N, V) {
                    return A(this, D, N, !0, V)
                  }),
                  (c.prototype.writeDoubleBE = function (D, N, V) {
                    return A(this, D, N, !1, V)
                  }),
                  (c.prototype.copy = function (D, N, V, W) {
                    if (!c.isBuffer(D)) throw new TypeError('argument should be a Buffer')
                    if (
                      (V || (V = 0),
                      W || W === 0 || (W = this.length),
                      N >= D.length && (N = D.length),
                      N || (N = 0),
                      W > 0 && W < V && (W = V),
                      W === V || D.length === 0 || this.length === 0)
                    )
                      return 0
                    if (N < 0) throw new RangeError('targetStart out of bounds')
                    if (V < 0 || V >= this.length) throw new RangeError('Index out of range')
                    if (W < 0) throw new RangeError('sourceEnd out of bounds')
                    ;(W > this.length && (W = this.length),
                      D.length - N < W - V && (W = D.length - N + V))
                    var J = W - V
                    if (this === D && typeof Uint8Array.prototype.copyWithin == 'function')
                      this.copyWithin(N, V, W)
                    else if (this === D && V < N && N < W)
                      for (var G = J - 1; G >= 0; --G) D[G + N] = this[G + V]
                    else Uint8Array.prototype.set.call(D, this.subarray(V, W), N)
                    return J
                  }),
                  (c.prototype.fill = function (D, N, V, W) {
                    if (typeof D == 'string') {
                      if (
                        (typeof N == 'string'
                          ? ((W = N), (N = 0), (V = this.length))
                          : typeof V == 'string' && ((W = V), (V = this.length)),
                        W !== void 0 && typeof W != 'string')
                      )
                        throw new TypeError('encoding must be a string')
                      if (typeof W == 'string' && !c.isEncoding(W))
                        throw new TypeError('Unknown encoding: ' + W)
                      if (D.length === 1) {
                        var J = D.charCodeAt(0)
                        ;((W === 'utf8' && J < 128) || W === 'latin1') && (D = J)
                      }
                    } else typeof D == 'number' && (D &= 255)
                    if (N < 0 || this.length < N || this.length < V)
                      throw new RangeError('Out of range index')
                    if (V <= N) return this
                    var G
                    if (
                      ((N >>>= 0),
                      (V = V === void 0 ? this.length : V >>> 0),
                      D || (D = 0),
                      typeof D == 'number')
                    )
                      for (G = N; G < V; ++G) this[G] = D
                    else {
                      var Z = c.isBuffer(D) ? D : c.from(D, W),
                        rt = Z.length
                      if (rt === 0)
                        throw new TypeError('The value "' + D + '" is invalid for argument "value"')
                      for (G = 0; G < V - N; ++G) this[G + N] = Z[G % rt]
                    }
                    return this
                  }))
                var j = /[^+/0-9A-Za-z-_]/g
                function L(D) {
                  return D < 16 ? '0' + D.toString(16) : D.toString(16)
                }
                function H(D, N) {
                  var V
                  N = N || 1 / 0
                  for (var W = D.length, J = null, G = [], Z = 0; Z < W; ++Z) {
                    if ((V = D.charCodeAt(Z)) > 55295 && V < 57344) {
                      if (!J) {
                        if (V > 56319) {
                          ;(N -= 3) > -1 && G.push(239, 191, 189)
                          continue
                        }
                        if (Z + 1 === W) {
                          ;(N -= 3) > -1 && G.push(239, 191, 189)
                          continue
                        }
                        J = V
                        continue
                      }
                      if (V < 56320) {
                        ;((N -= 3) > -1 && G.push(239, 191, 189), (J = V))
                        continue
                      }
                      V = 65536 + (((J - 55296) << 10) | (V - 56320))
                    } else J && (N -= 3) > -1 && G.push(239, 191, 189)
                    if (((J = null), V < 128)) {
                      if ((N -= 1) < 0) break
                      G.push(V)
                    } else if (V < 2048) {
                      if ((N -= 2) < 0) break
                      G.push((V >> 6) | 192, (63 & V) | 128)
                    } else if (V < 65536) {
                      if ((N -= 3) < 0) break
                      G.push((V >> 12) | 224, ((V >> 6) & 63) | 128, (63 & V) | 128)
                    } else {
                      if (!(V < 1114112)) throw new Error('Invalid code point')
                      if ((N -= 4) < 0) break
                      G.push(
                        (V >> 18) | 240,
                        ((V >> 12) & 63) | 128,
                        ((V >> 6) & 63) | 128,
                        (63 & V) | 128,
                      )
                    }
                  }
                  return G
                }
                function U(D) {
                  return o.toByteArray(
                    (function (N) {
                      if ((N = (N = N.split('=')[0]).trim().replace(j, '')).length < 2) return ''
                      for (; N.length % 4 != 0; ) N += '='
                      return N
                    })(D),
                  )
                }
                function K(D, N, V, W) {
                  for (var J = 0; J < W && !(J + V >= N.length || J >= D.length); ++J)
                    N[J + V] = D[J]
                  return J
                }
                function z(D, N) {
                  return (
                    D instanceof N ||
                    (D != null &&
                      D.constructor != null &&
                      D.constructor.name != null &&
                      D.constructor.name === N.name)
                  )
                }
                function q(D) {
                  return D != D
                }
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { 'base64-js': 185, buffer: 220, ieee754: 439 },
        ],
        221: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('stream').Transform,
              a = t('string_decoder').StringDecoder
            function l(c) {
              ;(o.call(this),
                (this.hashMode = typeof c == 'string'),
                this.hashMode
                  ? (this[c] = this._finalOrDigest)
                  : (this.final = this._finalOrDigest),
                this._final && ((this.__final = this._final), (this._final = null)),
                (this._decoder = null),
                (this._encoding = null))
            }
            ;(t('inherits')(l, o),
              (l.prototype.update = function (c, u, f) {
                typeof c == 'string' && (c = s.from(c, u))
                var d = this._update(c)
                return this.hashMode ? this : (f && (d = this._toString(d, f)), d)
              }),
              (l.prototype.setAutoPadding = function () {}),
              (l.prototype.getAuthTag = function () {
                throw new Error('trying to get auth tag in unsupported state')
              }),
              (l.prototype.setAuthTag = function () {
                throw new Error('trying to set auth tag in unsupported state')
              }),
              (l.prototype.setAAD = function () {
                throw new Error('trying to set aad in unsupported state')
              }),
              (l.prototype._transform = function (c, u, f) {
                var d
                try {
                  this.hashMode ? this._update(c) : this.push(this._update(c))
                } catch (h) {
                  d = h
                } finally {
                  f(d)
                }
              }),
              (l.prototype._flush = function (c) {
                var u
                try {
                  this.push(this.__final())
                } catch (f) {
                  u = f
                }
                c(u)
              }),
              (l.prototype._finalOrDigest = function (c) {
                var u = this.__final() || s.alloc(0)
                return (c && (u = this._toString(u, c, !0)), u)
              }),
              (l.prototype._toString = function (c, u, f) {
                if (
                  (this._decoder || ((this._decoder = new a(u)), (this._encoding = u)),
                  this._encoding !== u)
                )
                  throw new Error("can't switch encodings")
                var d = this._decoder.write(c)
                return (f && (d += this._decoder.end()), d)
              }),
              (r.exports = l))
          },
          { inherits: 440, 'safe-buffer': 494, stream: 505, string_decoder: 218 },
        ],
        222: [
          function (t, r, i) {
            var s = t('../internals/is-callable'),
              o = t('../internals/try-to-string'),
              a = TypeError
            r.exports = function (l) {
              if (s(l)) return l
              throw new a(o(l) + ' is not a function')
            }
          },
          { '../internals/is-callable': 285, '../internals/try-to-string': 349 },
        ],
        223: [
          function (t, r, i) {
            var s = t('../internals/is-constructor'),
              o = t('../internals/try-to-string'),
              a = TypeError
            r.exports = function (l) {
              if (s(l)) return l
              throw new a(o(l) + ' is not a constructor')
            }
          },
          { '../internals/is-constructor': 286, '../internals/try-to-string': 349 },
        ],
        224: [
          function (t, r, i) {
            var s = t('../internals/is-callable'),
              o = String,
              a = TypeError
            r.exports = function (l) {
              if (typeof l == 'object' || s(l)) return l
              throw new a("Can't set " + o(l) + ' as a prototype')
            }
          },
          { '../internals/is-callable': 285 },
        ],
        225: [
          function (t, r, i) {
            var s = t('../internals/well-known-symbol'),
              o = t('../internals/object-create'),
              a = t('../internals/object-define-property').f,
              l = s('unscopables'),
              c = Array.prototype
            ;(c[l] === void 0 && a(c, l, { configurable: !0, value: o(null) }),
              (r.exports = function (u) {
                c[l][u] = !0
              }))
          },
          {
            '../internals/object-create': 306,
            '../internals/object-define-property': 308,
            '../internals/well-known-symbol': 357,
          },
        ],
        226: [
          function (t, r, i) {
            var s = t('../internals/object-is-prototype-of'),
              o = TypeError
            r.exports = function (a, l) {
              if (s(l, a)) return a
              throw new o('Incorrect invocation')
            }
          },
          { '../internals/object-is-prototype-of': 314 },
        ],
        227: [
          function (t, r, i) {
            var s = t('../internals/is-object'),
              o = String,
              a = TypeError
            r.exports = function (l) {
              if (s(l)) return l
              throw new a(o(l) + ' is not an object')
            }
          },
          { '../internals/is-object': 289 },
        ],
        228: [
          function (t, r, i) {
            var s = t('../internals/to-indexed-object'),
              o = t('../internals/to-absolute-index'),
              a = t('../internals/length-of-array-like'),
              l = function (c) {
                return function (u, f, d) {
                  var h,
                    p = s(u),
                    g = a(p),
                    m = o(d, g)
                  if (c && f != f) {
                    for (; g > m; ) if ((h = p[m++]) != h) return !0
                  } else for (; g > m; m++) if ((c || m in p) && p[m] === f) return c || m || 0
                  return !c && -1
                }
              }
            r.exports = { includes: l(!0), indexOf: l(!1) }
          },
          {
            '../internals/length-of-array-like': 299,
            '../internals/to-absolute-index': 340,
            '../internals/to-indexed-object': 341,
          },
        ],
        229: [
          function (t, r, i) {
            var s = t('../internals/function-bind-context'),
              o = t('../internals/function-uncurry-this'),
              a = t('../internals/indexed-object'),
              l = t('../internals/to-object'),
              c = t('../internals/length-of-array-like'),
              u = t('../internals/array-species-create'),
              f = o([].push),
              d = function (h) {
                var p = h === 1,
                  g = h === 2,
                  m = h === 3,
                  y = h === 4,
                  b = h === 6,
                  w = h === 7,
                  C = h === 5 || b
                return function (T, I, B, E) {
                  for (
                    var O,
                      P,
                      $ = l(T),
                      F = a($),
                      M = s(I, B),
                      R = c(F),
                      k = 0,
                      v = E || u,
                      x = p ? v(T, R) : g || w ? v(T, 0) : void 0;
                    R > k;
                    k++
                  )
                    if ((C || k in F) && ((P = M((O = F[k]), k, $)), h))
                      if (p) x[k] = P
                      else if (P)
                        switch (h) {
                          case 3:
                            return !0
                          case 5:
                            return O
                          case 6:
                            return k
                          case 2:
                            f(x, O)
                        }
                      else
                        switch (h) {
                          case 4:
                            return !1
                          case 7:
                            f(x, O)
                        }
                  return b ? -1 : m || y ? y : x
                }
              }
            r.exports = {
              forEach: d(0),
              map: d(1),
              filter: d(2),
              some: d(3),
              every: d(4),
              find: d(5),
              findIndex: d(6),
              filterReject: d(7),
            }
          },
          {
            '../internals/array-species-create': 233,
            '../internals/function-bind-context': 262,
            '../internals/function-uncurry-this': 268,
            '../internals/indexed-object': 280,
            '../internals/length-of-array-like': 299,
            '../internals/to-object': 344,
          },
        ],
        230: [
          function (t, r, i) {
            var s = t('../internals/to-absolute-index'),
              o = t('../internals/length-of-array-like'),
              a = t('../internals/create-property'),
              l = Array,
              c = Math.max
            r.exports = function (u, f, d) {
              for (
                var h = o(u),
                  p = s(f, h),
                  g = s(d === void 0 ? h : d, h),
                  m = l(c(g - p, 0)),
                  y = 0;
                p < g;
                p++, y++
              )
                a(m, y, u[p])
              return ((m.length = y), m)
            }
          },
          {
            '../internals/create-property': 243,
            '../internals/length-of-array-like': 299,
            '../internals/to-absolute-index': 340,
          },
        ],
        231: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this')
            r.exports = s([].slice)
          },
          { '../internals/function-uncurry-this': 268 },
        ],
        232: [
          function (t, r, i) {
            var s = t('../internals/is-array'),
              o = t('../internals/is-constructor'),
              a = t('../internals/is-object'),
              l = t('../internals/well-known-symbol')('species'),
              c = Array
            r.exports = function (u) {
              var f
              return (
                s(u) &&
                  ((f = u.constructor),
                  ((o(f) && (f === c || s(f.prototype))) || (a(f) && (f = f[l]) === null)) &&
                    (f = void 0)),
                f === void 0 ? c : f
              )
            }
          },
          {
            '../internals/is-array': 284,
            '../internals/is-constructor': 286,
            '../internals/is-object': 289,
            '../internals/well-known-symbol': 357,
          },
        ],
        233: [
          function (t, r, i) {
            var s = t('../internals/array-species-constructor')
            r.exports = function (o, a) {
              return new (s(o))(a === 0 ? 0 : a)
            }
          },
          { '../internals/array-species-constructor': 232 },
        ],
        234: [
          function (t, r, i) {
            var s = t('../internals/well-known-symbol')('iterator'),
              o = !1
            try {
              var a = 0,
                l = {
                  next: function () {
                    return { done: !!a++ }
                  },
                  return: function () {
                    o = !0
                  },
                }
              ;((l[s] = function () {
                return this
              }),
                Array.from(l, function () {
                  throw 2
                }))
            } catch {}
            r.exports = function (c, u) {
              try {
                if (!u && !o) return !1
              } catch {
                return !1
              }
              var f = !1
              try {
                var d = {}
                ;((d[s] = function () {
                  return {
                    next: function () {
                      return { done: (f = !0) }
                    },
                  }
                }),
                  c(d))
              } catch {}
              return f
            }
          },
          { '../internals/well-known-symbol': 357 },
        ],
        235: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = s({}.toString),
              a = s(''.slice)
            r.exports = function (l) {
              return a(o(l), 8, -1)
            }
          },
          { '../internals/function-uncurry-this': 268 },
        ],
        236: [
          function (t, r, i) {
            var s = t('../internals/to-string-tag-support'),
              o = t('../internals/is-callable'),
              a = t('../internals/classof-raw'),
              l = t('../internals/well-known-symbol')('toStringTag'),
              c = Object,
              u =
                a(
                  (function () {
                    return arguments
                  })(),
                ) === 'Arguments'
            r.exports = s
              ? a
              : function (f) {
                  var d, h, p
                  return f === void 0
                    ? 'Undefined'
                    : f === null
                      ? 'Null'
                      : typeof (h = (function (g, m) {
                            try {
                              return g[m]
                            } catch {}
                          })((d = c(f)), l)) == 'string'
                        ? h
                        : u
                          ? a(d)
                          : (p = a(d)) === 'Object' && o(d.callee)
                            ? 'Arguments'
                            : p
                }
          },
          {
            '../internals/classof-raw': 235,
            '../internals/is-callable': 285,
            '../internals/to-string-tag-support': 347,
            '../internals/well-known-symbol': 357,
          },
        ],
        237: [
          function (t, r, i) {
            var s = t('../internals/has-own-property'),
              o = t('../internals/own-keys'),
              a = t('../internals/object-get-own-property-descriptor'),
              l = t('../internals/object-define-property')
            r.exports = function (c, u, f) {
              for (var d = o(u), h = l.f, p = a.f, g = 0; g < d.length; g++) {
                var m = d[g]
                s(c, m) || (f && s(f, m)) || h(c, m, p(u, m))
              }
            }
          },
          {
            '../internals/has-own-property': 275,
            '../internals/object-define-property': 308,
            '../internals/object-get-own-property-descriptor': 309,
            '../internals/own-keys': 321,
          },
        ],
        238: [
          function (t, r, i) {
            var s = t('../internals/well-known-symbol')('match')
            r.exports = function (o) {
              var a = /./
              try {
                '/./'[o](a)
              } catch {
                try {
                  return ((a[s] = !1), '/./'[o](a))
                } catch {}
              }
              return !1
            }
          },
          { '../internals/well-known-symbol': 357 },
        ],
        239: [
          function (t, r, i) {
            var s = t('../internals/fails')
            r.exports = !s(function () {
              function o() {}
              return (
                (o.prototype.constructor = null),
                Object.getPrototypeOf(new o()) !== o.prototype
              )
            })
          },
          { '../internals/fails': 260 },
        ],
        240: [
          function (t, r, i) {
            r.exports = function (s, o) {
              return { value: s, done: o }
            }
          },
          {},
        ],
        241: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/object-define-property'),
              a = t('../internals/create-property-descriptor')
            r.exports = s
              ? function (l, c, u) {
                  return o.f(l, c, a(1, u))
                }
              : function (l, c, u) {
                  return ((l[c] = u), l)
                }
          },
          {
            '../internals/create-property-descriptor': 242,
            '../internals/descriptors': 247,
            '../internals/object-define-property': 308,
          },
        ],
        242: [
          function (t, r, i) {
            r.exports = function (s, o) {
              return { enumerable: !(1 & s), configurable: !(2 & s), writable: !(4 & s), value: o }
            }
          },
          {},
        ],
        243: [
          function (t, r, i) {
            var s = t('../internals/to-property-key'),
              o = t('../internals/object-define-property'),
              a = t('../internals/create-property-descriptor')
            r.exports = function (l, c, u) {
              var f = s(c)
              f in l ? o.f(l, f, a(0, u)) : (l[f] = u)
            }
          },
          {
            '../internals/create-property-descriptor': 242,
            '../internals/object-define-property': 308,
            '../internals/to-property-key': 346,
          },
        ],
        244: [
          function (t, r, i) {
            var s = t('../internals/make-built-in'),
              o = t('../internals/object-define-property')
            r.exports = function (a, l, c) {
              return (
                c.get && s(c.get, l, { getter: !0 }),
                c.set && s(c.set, l, { setter: !0 }),
                o.f(a, l, c)
              )
            }
          },
          { '../internals/make-built-in': 300, '../internals/object-define-property': 308 },
        ],
        245: [
          function (t, r, i) {
            var s = t('../internals/is-callable'),
              o = t('../internals/object-define-property'),
              a = t('../internals/make-built-in'),
              l = t('../internals/define-global-property')
            r.exports = function (c, u, f, d) {
              d || (d = {})
              var h = d.enumerable,
                p = d.name !== void 0 ? d.name : u
              if ((s(f) && a(f, p, d), d.global)) h ? (c[u] = f) : l(u, f)
              else {
                try {
                  d.unsafe ? c[u] && (h = !0) : delete c[u]
                } catch {}
                h
                  ? (c[u] = f)
                  : o.f(c, u, {
                      value: f,
                      enumerable: !1,
                      configurable: !d.nonConfigurable,
                      writable: !d.nonWritable,
                    })
              }
              return c
            }
          },
          {
            '../internals/define-global-property': 246,
            '../internals/is-callable': 285,
            '../internals/make-built-in': 300,
            '../internals/object-define-property': 308,
          },
        ],
        246: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = Object.defineProperty
            r.exports = function (a, l) {
              try {
                o(s, a, { value: l, configurable: !0, writable: !0 })
              } catch {
                s[a] = l
              }
              return l
            }
          },
          { '../internals/global': 274 },
        ],
        247: [
          function (t, r, i) {
            var s = t('../internals/fails')
            r.exports = !s(function () {
              return (
                Object.defineProperty({}, 1, {
                  get: function () {
                    return 7
                  },
                })[1] !== 7
              )
            })
          },
          { '../internals/fails': 260 },
        ],
        248: [
          function (t, r, i) {
            var s = typeof document == 'object' && document.all,
              o = s === void 0 && s !== void 0
            r.exports = { all: s, IS_HTMLDDA: o }
          },
          {},
        ],
        249: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/is-object'),
              a = s.document,
              l = o(a) && o(a.createElement)
            r.exports = function (c) {
              return l ? a.createElement(c) : {}
            }
          },
          { '../internals/global': 274, '../internals/is-object': 289 },
        ],
        250: [
          function (t, r, i) {
            var s = t('../internals/engine-is-deno'),
              o = t('../internals/engine-is-node')
            r.exports = !s && !o && typeof window == 'object' && typeof document == 'object'
          },
          { '../internals/engine-is-deno': 251, '../internals/engine-is-node': 254 },
        ],
        251: [
          function (t, r, i) {
            r.exports = typeof Deno == 'object' && Deno && typeof Deno.version == 'object'
          },
          {},
        ],
        252: [
          function (t, r, i) {
            var s = t('../internals/engine-user-agent')
            r.exports = /ipad|iphone|ipod/i.test(s) && typeof Pebble < 'u'
          },
          { '../internals/engine-user-agent': 256 },
        ],
        253: [
          function (t, r, i) {
            var s = t('../internals/engine-user-agent')
            r.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(s)
          },
          { '../internals/engine-user-agent': 256 },
        ],
        254: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/classof-raw')
            r.exports = o(s.process) === 'process'
          },
          { '../internals/classof-raw': 235, '../internals/global': 274 },
        ],
        255: [
          function (t, r, i) {
            var s = t('../internals/engine-user-agent')
            r.exports = /web0s(?!.*chrome)/i.test(s)
          },
          { '../internals/engine-user-agent': 256 },
        ],
        256: [
          function (t, r, i) {
            r.exports = (typeof navigator < 'u' && String(navigator.userAgent)) || ''
          },
          {},
        ],
        257: [
          function (t, r, i) {
            var s,
              o,
              a = t('../internals/global'),
              l = t('../internals/engine-user-agent'),
              c = a.process,
              u = a.Deno,
              f = (c && c.versions) || (u && u.version),
              d = f && f.v8
            ;(d && (o = (s = d.split('.'))[0] > 0 && s[0] < 4 ? 1 : +(s[0] + s[1])),
              !o &&
                l &&
                (!(s = l.match(/Edge\/(\d+)/)) || s[1] >= 74) &&
                (s = l.match(/Chrome\/(\d+)/)) &&
                (o = +s[1]),
              (r.exports = o))
          },
          { '../internals/engine-user-agent': 256, '../internals/global': 274 },
        ],
        258: [
          function (t, r, i) {
            r.exports = [
              'constructor',
              'hasOwnProperty',
              'isPrototypeOf',
              'propertyIsEnumerable',
              'toLocaleString',
              'toString',
              'valueOf',
            ]
          },
          {},
        ],
        259: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/object-get-own-property-descriptor').f,
              a = t('../internals/create-non-enumerable-property'),
              l = t('../internals/define-built-in'),
              c = t('../internals/define-global-property'),
              u = t('../internals/copy-constructor-properties'),
              f = t('../internals/is-forced')
            r.exports = function (d, h) {
              var p,
                g,
                m,
                y,
                b,
                w = d.target,
                C = d.global,
                T = d.stat
              if ((p = C ? s : T ? s[w] || c(w, {}) : (s[w] || {}).prototype))
                for (g in h) {
                  if (
                    ((y = h[g]),
                    (m = d.dontCallGetSet ? (b = o(p, g)) && b.value : p[g]),
                    !f(C ? g : w + (T ? '.' : '#') + g, d.forced) && m !== void 0)
                  ) {
                    if (typeof y == typeof m) continue
                    u(y, m)
                  }
                  ;((d.sham || (m && m.sham)) && a(y, 'sham', !0), l(p, g, y, d))
                }
            }
          },
          {
            '../internals/copy-constructor-properties': 237,
            '../internals/create-non-enumerable-property': 241,
            '../internals/define-built-in': 245,
            '../internals/define-global-property': 246,
            '../internals/global': 274,
            '../internals/is-forced': 287,
            '../internals/object-get-own-property-descriptor': 309,
          },
        ],
        260: [
          function (t, r, i) {
            r.exports = function (s) {
              try {
                return !!s()
              } catch {
                return !0
              }
            }
          },
          {},
        ],
        261: [
          function (t, r, i) {
            var s = t('../internals/function-bind-native'),
              o = Function.prototype,
              a = o.apply,
              l = o.call
            r.exports =
              (typeof Reflect == 'object' && Reflect.apply) ||
              (s
                ? l.bind(a)
                : function () {
                    return l.apply(a, arguments)
                  })
          },
          { '../internals/function-bind-native': 263 },
        ],
        262: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this-clause'),
              o = t('../internals/a-callable'),
              a = t('../internals/function-bind-native'),
              l = s(s.bind)
            r.exports = function (c, u) {
              return (
                o(c),
                u === void 0
                  ? c
                  : a
                    ? l(c, u)
                    : function () {
                        return c.apply(u, arguments)
                      }
              )
            }
          },
          {
            '../internals/a-callable': 222,
            '../internals/function-bind-native': 263,
            '../internals/function-uncurry-this-clause': 267,
          },
        ],
        263: [
          function (t, r, i) {
            var s = t('../internals/fails')
            r.exports = !s(function () {
              var o = function () {}.bind()
              return typeof o != 'function' || o.hasOwnProperty('prototype')
            })
          },
          { '../internals/fails': 260 },
        ],
        264: [
          function (t, r, i) {
            var s = t('../internals/function-bind-native'),
              o = Function.prototype.call
            r.exports = s
              ? o.bind(o)
              : function () {
                  return o.apply(o, arguments)
                }
          },
          { '../internals/function-bind-native': 263 },
        ],
        265: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/has-own-property'),
              a = Function.prototype,
              l = s && Object.getOwnPropertyDescriptor,
              c = o(a, 'name'),
              u = c && function () {}.name === 'something',
              f = c && (!s || (s && l(a, 'name').configurable))
            r.exports = { EXISTS: c, PROPER: u, CONFIGURABLE: f }
          },
          { '../internals/descriptors': 247, '../internals/has-own-property': 275 },
        ],
        266: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/a-callable')
            r.exports = function (a, l, c) {
              try {
                return s(o(Object.getOwnPropertyDescriptor(a, l)[c]))
              } catch {}
            }
          },
          { '../internals/a-callable': 222, '../internals/function-uncurry-this': 268 },
        ],
        267: [
          function (t, r, i) {
            var s = t('../internals/classof-raw'),
              o = t('../internals/function-uncurry-this')
            r.exports = function (a) {
              if (s(a) === 'Function') return o(a)
            }
          },
          { '../internals/classof-raw': 235, '../internals/function-uncurry-this': 268 },
        ],
        268: [
          function (t, r, i) {
            var s = t('../internals/function-bind-native'),
              o = Function.prototype,
              a = o.call,
              l = s && o.bind.bind(a, a)
            r.exports = s
              ? l
              : function (c) {
                  return function () {
                    return a.apply(c, arguments)
                  }
                }
          },
          { '../internals/function-bind-native': 263 },
        ],
        269: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/is-callable'),
              a = function (l) {
                return o(l) ? l : void 0
              }
            r.exports = function (l, c) {
              return arguments.length < 2 ? a(s[l]) : s[l] && s[l][c]
            }
          },
          { '../internals/global': 274, '../internals/is-callable': 285 },
        ],
        270: [
          function (t, r, i) {
            var s = t('../internals/classof'),
              o = t('../internals/get-method'),
              a = t('../internals/is-null-or-undefined'),
              l = t('../internals/iterators'),
              c = t('../internals/well-known-symbol')('iterator')
            r.exports = function (u) {
              if (!a(u)) return o(u, c) || o(u, '@@iterator') || l[s(u)]
            }
          },
          {
            '../internals/classof': 236,
            '../internals/get-method': 273,
            '../internals/is-null-or-undefined': 288,
            '../internals/iterators': 298,
            '../internals/well-known-symbol': 357,
          },
        ],
        271: [
          function (t, r, i) {
            var s = t('../internals/function-call'),
              o = t('../internals/a-callable'),
              a = t('../internals/an-object'),
              l = t('../internals/try-to-string'),
              c = t('../internals/get-iterator-method'),
              u = TypeError
            r.exports = function (f, d) {
              var h = arguments.length < 2 ? c(f) : d
              if (o(h)) return a(s(h, f))
              throw new u(l(f) + ' is not iterable')
            }
          },
          {
            '../internals/a-callable': 222,
            '../internals/an-object': 227,
            '../internals/function-call': 264,
            '../internals/get-iterator-method': 270,
            '../internals/try-to-string': 349,
          },
        ],
        272: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/is-array'),
              a = t('../internals/is-callable'),
              l = t('../internals/classof-raw'),
              c = t('../internals/to-string'),
              u = s([].push)
            r.exports = function (f) {
              if (a(f)) return f
              if (o(f)) {
                for (var d = f.length, h = [], p = 0; p < d; p++) {
                  var g = f[p]
                  typeof g == 'string'
                    ? u(h, g)
                    : (typeof g != 'number' && l(g) !== 'Number' && l(g) !== 'String') || u(h, c(g))
                }
                var m = h.length,
                  y = !0
                return function (b, w) {
                  if (y) return ((y = !1), w)
                  if (o(this)) return w
                  for (var C = 0; C < m; C++) if (h[C] === b) return w
                }
              }
            }
          },
          {
            '../internals/classof-raw': 235,
            '../internals/function-uncurry-this': 268,
            '../internals/is-array': 284,
            '../internals/is-callable': 285,
            '../internals/to-string': 348,
          },
        ],
        273: [
          function (t, r, i) {
            var s = t('../internals/a-callable'),
              o = t('../internals/is-null-or-undefined')
            r.exports = function (a, l) {
              var c = a[l]
              return o(c) ? void 0 : s(c)
            }
          },
          { '../internals/a-callable': 222, '../internals/is-null-or-undefined': 288 },
        ],
        274: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = function (a) {
                  return a && a.Math === Math && a
                }
                r.exports =
                  o(typeof globalThis == 'object' && globalThis) ||
                  o(typeof window == 'object' && window) ||
                  o(typeof self == 'object' && self) ||
                  o(typeof s == 'object' && s) ||
                  (function () {
                    return this
                  })() ||
                  this ||
                  Function('return this')()
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {},
        ],
        275: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/to-object'),
              a = s({}.hasOwnProperty)
            r.exports =
              Object.hasOwn ||
              function (l, c) {
                return a(o(l), c)
              }
          },
          { '../internals/function-uncurry-this': 268, '../internals/to-object': 344 },
        ],
        276: [
          function (t, r, i) {
            r.exports = {}
          },
          {},
        ],
        277: [
          function (t, r, i) {
            r.exports = function (s, o) {
              try {
                arguments.length === 1 ? console.error(s) : console.error(s, o)
              } catch {}
            }
          },
          {},
        ],
        278: [
          function (t, r, i) {
            var s = t('../internals/get-built-in')
            r.exports = s('document', 'documentElement')
          },
          { '../internals/get-built-in': 269 },
        ],
        279: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/fails'),
              a = t('../internals/document-create-element')
            r.exports =
              !s &&
              !o(function () {
                return (
                  Object.defineProperty(a('div'), 'a', {
                    get: function () {
                      return 7
                    },
                  }).a !== 7
                )
              })
          },
          {
            '../internals/descriptors': 247,
            '../internals/document-create-element': 249,
            '../internals/fails': 260,
          },
        ],
        280: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/fails'),
              a = t('../internals/classof-raw'),
              l = Object,
              c = s(''.split)
            r.exports = o(function () {
              return !l('z').propertyIsEnumerable(0)
            })
              ? function (u) {
                  return a(u) === 'String' ? c(u, '') : l(u)
                }
              : l
          },
          {
            '../internals/classof-raw': 235,
            '../internals/fails': 260,
            '../internals/function-uncurry-this': 268,
          },
        ],
        281: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/is-callable'),
              a = t('../internals/shared-store'),
              l = s(Function.toString)
            ;(o(a.inspectSource) ||
              (a.inspectSource = function (c) {
                return l(c)
              }),
              (r.exports = a.inspectSource))
          },
          {
            '../internals/function-uncurry-this': 268,
            '../internals/is-callable': 285,
            '../internals/shared-store': 333,
          },
        ],
        282: [
          function (t, r, i) {
            var s,
              o,
              a,
              l = t('../internals/weak-map-basic-detection'),
              c = t('../internals/global'),
              u = t('../internals/is-object'),
              f = t('../internals/create-non-enumerable-property'),
              d = t('../internals/has-own-property'),
              h = t('../internals/shared-store'),
              p = t('../internals/shared-key'),
              g = t('../internals/hidden-keys'),
              m = c.TypeError,
              y = c.WeakMap
            if (l || h.state) {
              var b = h.state || (h.state = new y())
              ;((b.get = b.get),
                (b.has = b.has),
                (b.set = b.set),
                (s = function (C, T) {
                  if (b.has(C)) throw new m('Object already initialized')
                  return ((T.facade = C), b.set(C, T), T)
                }),
                (o = function (C) {
                  return b.get(C) || {}
                }),
                (a = function (C) {
                  return b.has(C)
                }))
            } else {
              var w = p('state')
              ;((g[w] = !0),
                (s = function (C, T) {
                  if (d(C, w)) throw new m('Object already initialized')
                  return ((T.facade = C), f(C, w, T), T)
                }),
                (o = function (C) {
                  return d(C, w) ? C[w] : {}
                }),
                (a = function (C) {
                  return d(C, w)
                }))
            }
            r.exports = {
              set: s,
              get: o,
              has: a,
              enforce: function (C) {
                return a(C) ? o(C) : s(C, {})
              },
              getterFor: function (C) {
                return function (T) {
                  var I
                  if (!u(T) || (I = o(T)).type !== C)
                    throw new m('Incompatible receiver, ' + C + ' required')
                  return I
                }
              },
            }
          },
          {
            '../internals/create-non-enumerable-property': 241,
            '../internals/global': 274,
            '../internals/has-own-property': 275,
            '../internals/hidden-keys': 276,
            '../internals/is-object': 289,
            '../internals/shared-key': 332,
            '../internals/shared-store': 333,
            '../internals/weak-map-basic-detection': 354,
          },
        ],
        283: [
          function (t, r, i) {
            var s = t('../internals/well-known-symbol'),
              o = t('../internals/iterators'),
              a = s('iterator'),
              l = Array.prototype
            r.exports = function (c) {
              return c !== void 0 && (o.Array === c || l[a] === c)
            }
          },
          { '../internals/iterators': 298, '../internals/well-known-symbol': 357 },
        ],
        284: [
          function (t, r, i) {
            var s = t('../internals/classof-raw')
            r.exports =
              Array.isArray ||
              function (o) {
                return s(o) === 'Array'
              }
          },
          { '../internals/classof-raw': 235 },
        ],
        285: [
          function (t, r, i) {
            var s = t('../internals/document-all'),
              o = s.all
            r.exports = s.IS_HTMLDDA
              ? function (a) {
                  return typeof a == 'function' || a === o
                }
              : function (a) {
                  return typeof a == 'function'
                }
          },
          { '../internals/document-all': 248 },
        ],
        286: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/fails'),
              a = t('../internals/is-callable'),
              l = t('../internals/classof'),
              c = t('../internals/get-built-in'),
              u = t('../internals/inspect-source'),
              f = function () {},
              d = [],
              h = c('Reflect', 'construct'),
              p = /^\s*(?:class|function)\b/,
              g = s(p.exec),
              m = !p.test(f),
              y = function (w) {
                if (!a(w)) return !1
                try {
                  return (h(f, d, w), !0)
                } catch {
                  return !1
                }
              },
              b = function (w) {
                if (!a(w)) return !1
                switch (l(w)) {
                  case 'AsyncFunction':
                  case 'GeneratorFunction':
                  case 'AsyncGeneratorFunction':
                    return !1
                }
                try {
                  return m || !!g(p, u(w))
                } catch {
                  return !0
                }
              }
            ;((b.sham = !0),
              (r.exports =
                !h ||
                o(function () {
                  var w
                  return (
                    y(y.call) ||
                    !y(Object) ||
                    !y(function () {
                      w = !0
                    }) ||
                    w
                  )
                })
                  ? b
                  : y))
          },
          {
            '../internals/classof': 236,
            '../internals/fails': 260,
            '../internals/function-uncurry-this': 268,
            '../internals/get-built-in': 269,
            '../internals/inspect-source': 281,
            '../internals/is-callable': 285,
          },
        ],
        287: [
          function (t, r, i) {
            var s = t('../internals/fails'),
              o = t('../internals/is-callable'),
              a = /#|\.prototype\./,
              l = function (h, p) {
                var g = u[c(h)]
                return g === d || (g !== f && (o(p) ? s(p) : !!p))
              },
              c = (l.normalize = function (h) {
                return String(h).replace(a, '.').toLowerCase()
              }),
              u = (l.data = {}),
              f = (l.NATIVE = 'N'),
              d = (l.POLYFILL = 'P')
            r.exports = l
          },
          { '../internals/fails': 260, '../internals/is-callable': 285 },
        ],
        288: [
          function (t, r, i) {
            r.exports = function (s) {
              return s == null
            }
          },
          {},
        ],
        289: [
          function (t, r, i) {
            var s = t('../internals/is-callable'),
              o = t('../internals/document-all'),
              a = o.all
            r.exports = o.IS_HTMLDDA
              ? function (l) {
                  return typeof l == 'object' ? l !== null : s(l) || l === a
                }
              : function (l) {
                  return typeof l == 'object' ? l !== null : s(l)
                }
          },
          { '../internals/document-all': 248, '../internals/is-callable': 285 },
        ],
        290: [
          function (t, r, i) {
            r.exports = !1
          },
          {},
        ],
        291: [
          function (t, r, i) {
            var s = t('../internals/is-object'),
              o = t('../internals/classof-raw'),
              a = t('../internals/well-known-symbol')('match')
            r.exports = function (l) {
              var c
              return s(l) && ((c = l[a]) !== void 0 ? !!c : o(l) === 'RegExp')
            }
          },
          {
            '../internals/classof-raw': 235,
            '../internals/is-object': 289,
            '../internals/well-known-symbol': 357,
          },
        ],
        292: [
          function (t, r, i) {
            var s = t('../internals/get-built-in'),
              o = t('../internals/is-callable'),
              a = t('../internals/object-is-prototype-of'),
              l = t('../internals/use-symbol-as-uid'),
              c = Object
            r.exports = l
              ? function (u) {
                  return typeof u == 'symbol'
                }
              : function (u) {
                  var f = s('Symbol')
                  return o(f) && a(f.prototype, c(u))
                }
          },
          {
            '../internals/get-built-in': 269,
            '../internals/is-callable': 285,
            '../internals/object-is-prototype-of': 314,
            '../internals/use-symbol-as-uid': 351,
          },
        ],
        293: [
          function (t, r, i) {
            var s = t('../internals/function-bind-context'),
              o = t('../internals/function-call'),
              a = t('../internals/an-object'),
              l = t('../internals/try-to-string'),
              c = t('../internals/is-array-iterator-method'),
              u = t('../internals/length-of-array-like'),
              f = t('../internals/object-is-prototype-of'),
              d = t('../internals/get-iterator'),
              h = t('../internals/get-iterator-method'),
              p = t('../internals/iterator-close'),
              g = TypeError,
              m = function (b, w) {
                ;((this.stopped = b), (this.result = w))
              },
              y = m.prototype
            r.exports = function (b, w, C) {
              var T,
                I,
                B,
                E,
                O,
                P,
                $,
                F = C && C.that,
                M = !(!C || !C.AS_ENTRIES),
                R = !(!C || !C.IS_RECORD),
                k = !(!C || !C.IS_ITERATOR),
                v = !(!C || !C.INTERRUPTED),
                x = s(w, F),
                _ = function (A) {
                  return (T && p(T, 'normal', A), new m(!0, A))
                },
                S = function (A) {
                  return M ? (a(A), v ? x(A[0], A[1], _) : x(A[0], A[1])) : v ? x(A, _) : x(A)
                }
              if (R) T = b.iterator
              else if (k) T = b
              else {
                if (!(I = h(b))) throw new g(l(b) + ' is not iterable')
                if (c(I)) {
                  for (B = 0, E = u(b); E > B; B++) if ((O = S(b[B])) && f(y, O)) return O
                  return new m(!1)
                }
                T = d(b, I)
              }
              for (P = R ? b.next : T.next; !($ = o(P, T)).done; ) {
                try {
                  O = S($.value)
                } catch (A) {
                  p(T, 'throw', A)
                }
                if (typeof O == 'object' && O && f(y, O)) return O
              }
              return new m(!1)
            }
          },
          {
            '../internals/an-object': 227,
            '../internals/function-bind-context': 262,
            '../internals/function-call': 264,
            '../internals/get-iterator': 271,
            '../internals/get-iterator-method': 270,
            '../internals/is-array-iterator-method': 283,
            '../internals/iterator-close': 294,
            '../internals/length-of-array-like': 299,
            '../internals/object-is-prototype-of': 314,
            '../internals/try-to-string': 349,
          },
        ],
        294: [
          function (t, r, i) {
            var s = t('../internals/function-call'),
              o = t('../internals/an-object'),
              a = t('../internals/get-method')
            r.exports = function (l, c, u) {
              var f, d
              o(l)
              try {
                if (!(f = a(l, 'return'))) {
                  if (c === 'throw') throw u
                  return u
                }
                f = s(f, l)
              } catch (h) {
                ;((d = !0), (f = h))
              }
              if (c === 'throw') throw u
              if (d) throw f
              return (o(f), u)
            }
          },
          {
            '../internals/an-object': 227,
            '../internals/function-call': 264,
            '../internals/get-method': 273,
          },
        ],
        295: [
          function (t, r, i) {
            var s = t('../internals/iterators-core').IteratorPrototype,
              o = t('../internals/object-create'),
              a = t('../internals/create-property-descriptor'),
              l = t('../internals/set-to-string-tag'),
              c = t('../internals/iterators'),
              u = function () {
                return this
              }
            r.exports = function (f, d, h, p) {
              var g = d + ' Iterator'
              return ((f.prototype = o(s, { next: a(+!p, h) })), l(f, g, !1, !0), (c[g] = u), f)
            }
          },
          {
            '../internals/create-property-descriptor': 242,
            '../internals/iterators': 298,
            '../internals/iterators-core': 297,
            '../internals/object-create': 306,
            '../internals/set-to-string-tag': 331,
          },
        ],
        296: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/function-call'),
              a = t('../internals/is-pure'),
              l = t('../internals/function-name'),
              c = t('../internals/is-callable'),
              u = t('../internals/iterator-create-constructor'),
              f = t('../internals/object-get-prototype-of'),
              d = t('../internals/object-set-prototype-of'),
              h = t('../internals/set-to-string-tag'),
              p = t('../internals/create-non-enumerable-property'),
              g = t('../internals/define-built-in'),
              m = t('../internals/well-known-symbol'),
              y = t('../internals/iterators'),
              b = t('../internals/iterators-core'),
              w = l.PROPER,
              C = l.CONFIGURABLE,
              T = b.IteratorPrototype,
              I = b.BUGGY_SAFARI_ITERATORS,
              B = m('iterator'),
              E = function () {
                return this
              }
            r.exports = function (O, P, $, F, M, R, k) {
              u($, P, F)
              var v,
                x,
                _,
                S = function (z) {
                  if (z === M && U) return U
                  if (!I && z && z in L) return L[z]
                  switch (z) {
                    case 'keys':
                    case 'values':
                    case 'entries':
                      return function () {
                        return new $(this, z)
                      }
                  }
                  return function () {
                    return new $(this)
                  }
                },
                A = P + ' Iterator',
                j = !1,
                L = O.prototype,
                H = L[B] || L['@@iterator'] || (M && L[M]),
                U = (!I && H) || S(M),
                K = (P === 'Array' && L.entries) || H
              if (
                (K &&
                  (v = f(K.call(new O()))) !== Object.prototype &&
                  v.next &&
                  (a || f(v) === T || (d ? d(v, T) : c(v[B]) || g(v, B, E)),
                  h(v, A, !0, !0),
                  a && (y[A] = E)),
                w &&
                  M === 'values' &&
                  H &&
                  H.name !== 'values' &&
                  (!a && C
                    ? p(L, 'name', 'values')
                    : ((j = !0),
                      (U = function () {
                        return o(H, this)
                      }))),
                M)
              )
                if (
                  ((x = { values: S('values'), keys: R ? U : S('keys'), entries: S('entries') }), k)
                )
                  for (_ in x) (I || j || !(_ in L)) && g(L, _, x[_])
                else s({ target: P, proto: !0, forced: I || j }, x)
              return ((a && !k) || L[B] === U || g(L, B, U, { name: M }), (y[P] = U), x)
            }
          },
          {
            '../internals/create-non-enumerable-property': 241,
            '../internals/define-built-in': 245,
            '../internals/export': 259,
            '../internals/function-call': 264,
            '../internals/function-name': 265,
            '../internals/is-callable': 285,
            '../internals/is-pure': 290,
            '../internals/iterator-create-constructor': 295,
            '../internals/iterators': 298,
            '../internals/iterators-core': 297,
            '../internals/object-get-prototype-of': 313,
            '../internals/object-set-prototype-of': 318,
            '../internals/set-to-string-tag': 331,
            '../internals/well-known-symbol': 357,
          },
        ],
        297: [
          function (t, r, i) {
            var s,
              o,
              a,
              l = t('../internals/fails'),
              c = t('../internals/is-callable'),
              u = t('../internals/is-object'),
              f = t('../internals/object-create'),
              d = t('../internals/object-get-prototype-of'),
              h = t('../internals/define-built-in'),
              p = t('../internals/well-known-symbol'),
              g = t('../internals/is-pure'),
              m = p('iterator'),
              y = !1
            ;([].keys &&
              ('next' in (a = [].keys())
                ? (o = d(d(a))) !== Object.prototype && (s = o)
                : (y = !0)),
              !u(s) ||
              l(function () {
                var b = {}
                return s[m].call(b) !== b
              })
                ? (s = {})
                : g && (s = f(s)),
              c(s[m]) ||
                h(s, m, function () {
                  return this
                }),
              (r.exports = { IteratorPrototype: s, BUGGY_SAFARI_ITERATORS: y }))
          },
          {
            '../internals/define-built-in': 245,
            '../internals/fails': 260,
            '../internals/is-callable': 285,
            '../internals/is-object': 289,
            '../internals/is-pure': 290,
            '../internals/object-create': 306,
            '../internals/object-get-prototype-of': 313,
            '../internals/well-known-symbol': 357,
          },
        ],
        298: [
          function (t, r, i) {
            arguments[4][276][0].apply(i, arguments)
          },
          { dup: 276 },
        ],
        299: [
          function (t, r, i) {
            var s = t('../internals/to-length')
            r.exports = function (o) {
              return s(o.length)
            }
          },
          { '../internals/to-length': 343 },
        ],
        300: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/fails'),
              a = t('../internals/is-callable'),
              l = t('../internals/has-own-property'),
              c = t('../internals/descriptors'),
              u = t('../internals/function-name').CONFIGURABLE,
              f = t('../internals/inspect-source'),
              d = t('../internals/internal-state'),
              h = d.enforce,
              p = d.get,
              g = String,
              m = Object.defineProperty,
              y = s(''.slice),
              b = s(''.replace),
              w = s([].join),
              C =
                c &&
                !o(function () {
                  return m(function () {}, 'length', { value: 8 }).length !== 8
                }),
              T = String(String).split('String'),
              I = (r.exports = function (B, E, O) {
                ;(y(g(E), 0, 7) === 'Symbol(' &&
                  (E = '[' + b(g(E), /^Symbol\(([^)]*)\)/, '$1') + ']'),
                  O && O.getter && (E = 'get ' + E),
                  O && O.setter && (E = 'set ' + E),
                  (!l(B, 'name') || (u && B.name !== E)) &&
                    (c ? m(B, 'name', { value: E, configurable: !0 }) : (B.name = E)),
                  C &&
                    O &&
                    l(O, 'arity') &&
                    B.length !== O.arity &&
                    m(B, 'length', { value: O.arity }))
                try {
                  O && l(O, 'constructor') && O.constructor
                    ? c && m(B, 'prototype', { writable: !1 })
                    : B.prototype && (B.prototype = void 0)
                } catch {}
                var P = h(B)
                return (l(P, 'source') || (P.source = w(T, typeof E == 'string' ? E : '')), B)
              })
            Function.prototype.toString = I(function () {
              return (a(this) && p(this).source) || f(this)
            }, 'toString')
          },
          {
            '../internals/descriptors': 247,
            '../internals/fails': 260,
            '../internals/function-name': 265,
            '../internals/function-uncurry-this': 268,
            '../internals/has-own-property': 275,
            '../internals/inspect-source': 281,
            '../internals/internal-state': 282,
            '../internals/is-callable': 285,
          },
        ],
        301: [
          function (t, r, i) {
            var s = Math.ceil,
              o = Math.floor
            r.exports =
              Math.trunc ||
              function (a) {
                var l = +a
                return (l > 0 ? o : s)(l)
              }
          },
          {},
        ],
        302: [
          function (t, r, i) {
            var s,
              o,
              a,
              l,
              c,
              u = t('../internals/global'),
              f = t('../internals/function-bind-context'),
              d = t('../internals/object-get-own-property-descriptor').f,
              h = t('../internals/task').set,
              p = t('../internals/queue'),
              g = t('../internals/engine-is-ios'),
              m = t('../internals/engine-is-ios-pebble'),
              y = t('../internals/engine-is-webos-webkit'),
              b = t('../internals/engine-is-node'),
              w = u.MutationObserver || u.WebKitMutationObserver,
              C = u.document,
              T = u.process,
              I = u.Promise,
              B = d(u, 'queueMicrotask'),
              E = B && B.value
            if (!E) {
              var O = new p(),
                P = function () {
                  var $, F
                  for (b && ($ = T.domain) && $.exit(); (F = O.get()); )
                    try {
                      F()
                    } catch (M) {
                      throw (O.head && s(), M)
                    }
                  $ && $.enter()
                }
              ;(g || b || y || !w || !C
                ? !m && I && I.resolve
                  ? (((l = I.resolve(void 0)).constructor = I),
                    (c = f(l.then, l)),
                    (s = function () {
                      c(P)
                    }))
                  : b
                    ? (s = function () {
                        T.nextTick(P)
                      })
                    : ((h = f(h, u)),
                      (s = function () {
                        h(P)
                      }))
                : ((o = !0),
                  (a = C.createTextNode('')),
                  new w(P).observe(a, { characterData: !0 }),
                  (s = function () {
                    a.data = o = !o
                  })),
                (E = function ($) {
                  ;(O.head || s(), O.add($))
                }))
            }
            r.exports = E
          },
          {
            '../internals/engine-is-ios': 253,
            '../internals/engine-is-ios-pebble': 252,
            '../internals/engine-is-node': 254,
            '../internals/engine-is-webos-webkit': 255,
            '../internals/function-bind-context': 262,
            '../internals/global': 274,
            '../internals/object-get-own-property-descriptor': 309,
            '../internals/queue': 328,
            '../internals/task': 339,
          },
        ],
        303: [
          function (t, r, i) {
            var s = t('../internals/a-callable'),
              o = TypeError,
              a = function (l) {
                var c, u
                ;((this.promise = new l(function (f, d) {
                  if (c !== void 0 || u !== void 0) throw new o('Bad Promise constructor')
                  ;((c = f), (u = d))
                })),
                  (this.resolve = s(c)),
                  (this.reject = s(u)))
              }
            r.exports.f = function (l) {
              return new a(l)
            }
          },
          { '../internals/a-callable': 222 },
        ],
        304: [
          function (t, r, i) {
            var s = t('../internals/is-regexp'),
              o = TypeError
            r.exports = function (a) {
              if (s(a)) throw new o("The method doesn't accept regular expressions")
              return a
            }
          },
          { '../internals/is-regexp': 291 },
        ],
        305: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/function-uncurry-this'),
              a = t('../internals/function-call'),
              l = t('../internals/fails'),
              c = t('../internals/object-keys'),
              u = t('../internals/object-get-own-property-symbols'),
              f = t('../internals/object-property-is-enumerable'),
              d = t('../internals/to-object'),
              h = t('../internals/indexed-object'),
              p = Object.assign,
              g = Object.defineProperty,
              m = o([].concat)
            r.exports =
              !p ||
              l(function () {
                if (
                  s &&
                  p(
                    { b: 1 },
                    p(
                      g({}, 'a', {
                        enumerable: !0,
                        get: function () {
                          g(this, 'b', { value: 3, enumerable: !1 })
                        },
                      }),
                      { b: 2 },
                    ),
                  ).b !== 1
                )
                  return !0
                var y = {},
                  b = {},
                  w = Symbol('assign detection')
                return (
                  (y[w] = 7),
                  'abcdefghijklmnopqrst'.split('').forEach(function (C) {
                    b[C] = C
                  }),
                  p({}, y)[w] !== 7 || c(p({}, b)).join('') !== 'abcdefghijklmnopqrst'
                )
              })
                ? function (y, b) {
                    for (var w = d(y), C = arguments.length, T = 1, I = u.f, B = f.f; C > T; )
                      for (
                        var E,
                          O = h(arguments[T++]),
                          P = I ? m(c(O), I(O)) : c(O),
                          $ = P.length,
                          F = 0;
                        $ > F;

                      )
                        ((E = P[F++]), (s && !a(B, O, E)) || (w[E] = O[E]))
                    return w
                  }
                : p
          },
          {
            '../internals/descriptors': 247,
            '../internals/fails': 260,
            '../internals/function-call': 264,
            '../internals/function-uncurry-this': 268,
            '../internals/indexed-object': 280,
            '../internals/object-get-own-property-symbols': 312,
            '../internals/object-keys': 316,
            '../internals/object-property-is-enumerable': 317,
            '../internals/to-object': 344,
          },
        ],
        306: [
          function (t, r, i) {
            var s,
              o = t('../internals/an-object'),
              a = t('../internals/object-define-properties'),
              l = t('../internals/enum-bug-keys'),
              c = t('../internals/hidden-keys'),
              u = t('../internals/html'),
              f = t('../internals/document-create-element'),
              d = t('../internals/shared-key'),
              h = d('IE_PROTO'),
              p = function () {},
              g = function (b) {
                return '<script>' + b + '<\/script>'
              },
              m = function (b) {
                ;(b.write(g('')), b.close())
                var w = b.parentWindow.Object
                return ((b = null), w)
              },
              y = function () {
                try {
                  s = new ActiveXObject('htmlfile')
                } catch {}
                var b, w
                y =
                  typeof document < 'u'
                    ? document.domain && s
                      ? m(s)
                      : (((w = f('iframe')).style.display = 'none'),
                        u.appendChild(w),
                        (w.src = 'javascript:'),
                        (b = w.contentWindow.document).open(),
                        b.write(g('document.F=Object')),
                        b.close(),
                        b.F)
                    : m(s)
                for (var C = l.length; C--; ) delete y.prototype[l[C]]
                return y()
              }
            ;((c[h] = !0),
              (r.exports =
                Object.create ||
                function (b, w) {
                  var C
                  return (
                    b !== null
                      ? ((p.prototype = o(b)), (C = new p()), (p.prototype = null), (C[h] = b))
                      : (C = y()),
                    w === void 0 ? C : a.f(C, w)
                  )
                }))
          },
          {
            '../internals/an-object': 227,
            '../internals/document-create-element': 249,
            '../internals/enum-bug-keys': 258,
            '../internals/hidden-keys': 276,
            '../internals/html': 278,
            '../internals/object-define-properties': 307,
            '../internals/shared-key': 332,
          },
        ],
        307: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/v8-prototype-define-bug'),
              a = t('../internals/object-define-property'),
              l = t('../internals/an-object'),
              c = t('../internals/to-indexed-object'),
              u = t('../internals/object-keys')
            i.f =
              s && !o
                ? Object.defineProperties
                : function (f, d) {
                    l(f)
                    for (var h, p = c(d), g = u(d), m = g.length, y = 0; m > y; )
                      a.f(f, (h = g[y++]), p[h])
                    return f
                  }
          },
          {
            '../internals/an-object': 227,
            '../internals/descriptors': 247,
            '../internals/object-define-property': 308,
            '../internals/object-keys': 316,
            '../internals/to-indexed-object': 341,
            '../internals/v8-prototype-define-bug': 352,
          },
        ],
        308: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/ie8-dom-define'),
              a = t('../internals/v8-prototype-define-bug'),
              l = t('../internals/an-object'),
              c = t('../internals/to-property-key'),
              u = TypeError,
              f = Object.defineProperty,
              d = Object.getOwnPropertyDescriptor
            i.f = s
              ? a
                ? function (h, p, g) {
                    if (
                      (l(h),
                      (p = c(p)),
                      l(g),
                      typeof h == 'function' &&
                        p === 'prototype' &&
                        'value' in g &&
                        'writable' in g &&
                        !g.writable)
                    ) {
                      var m = d(h, p)
                      m &&
                        m.writable &&
                        ((h[p] = g.value),
                        (g = {
                          configurable: 'configurable' in g ? g.configurable : m.configurable,
                          enumerable: 'enumerable' in g ? g.enumerable : m.enumerable,
                          writable: !1,
                        }))
                    }
                    return f(h, p, g)
                  }
                : f
              : function (h, p, g) {
                  if ((l(h), (p = c(p)), l(g), o))
                    try {
                      return f(h, p, g)
                    } catch {}
                  if ('get' in g || 'set' in g) throw new u('Accessors not supported')
                  return ('value' in g && (h[p] = g.value), h)
                }
          },
          {
            '../internals/an-object': 227,
            '../internals/descriptors': 247,
            '../internals/ie8-dom-define': 279,
            '../internals/to-property-key': 346,
            '../internals/v8-prototype-define-bug': 352,
          },
        ],
        309: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/function-call'),
              a = t('../internals/object-property-is-enumerable'),
              l = t('../internals/create-property-descriptor'),
              c = t('../internals/to-indexed-object'),
              u = t('../internals/to-property-key'),
              f = t('../internals/has-own-property'),
              d = t('../internals/ie8-dom-define'),
              h = Object.getOwnPropertyDescriptor
            i.f = s
              ? h
              : function (p, g) {
                  if (((p = c(p)), (g = u(g)), d))
                    try {
                      return h(p, g)
                    } catch {}
                  if (f(p, g)) return l(!o(a.f, p, g), p[g])
                }
          },
          {
            '../internals/create-property-descriptor': 242,
            '../internals/descriptors': 247,
            '../internals/function-call': 264,
            '../internals/has-own-property': 275,
            '../internals/ie8-dom-define': 279,
            '../internals/object-property-is-enumerable': 317,
            '../internals/to-indexed-object': 341,
            '../internals/to-property-key': 346,
          },
        ],
        310: [
          function (t, r, i) {
            var s = t('../internals/classof-raw'),
              o = t('../internals/to-indexed-object'),
              a = t('../internals/object-get-own-property-names').f,
              l = t('../internals/array-slice-simple'),
              c =
                typeof window == 'object' && window && Object.getOwnPropertyNames
                  ? Object.getOwnPropertyNames(window)
                  : []
            r.exports.f = function (u) {
              return c && s(u) === 'Window'
                ? (function (f) {
                    try {
                      return a(f)
                    } catch {
                      return l(c)
                    }
                  })(u)
                : a(o(u))
            }
          },
          {
            '../internals/array-slice-simple': 230,
            '../internals/classof-raw': 235,
            '../internals/object-get-own-property-names': 311,
            '../internals/to-indexed-object': 341,
          },
        ],
        311: [
          function (t, r, i) {
            var s = t('../internals/object-keys-internal'),
              o = t('../internals/enum-bug-keys').concat('length', 'prototype')
            i.f =
              Object.getOwnPropertyNames ||
              function (a) {
                return s(a, o)
              }
          },
          { '../internals/enum-bug-keys': 258, '../internals/object-keys-internal': 315 },
        ],
        312: [
          function (t, r, i) {
            i.f = Object.getOwnPropertySymbols
          },
          {},
        ],
        313: [
          function (t, r, i) {
            var s = t('../internals/has-own-property'),
              o = t('../internals/is-callable'),
              a = t('../internals/to-object'),
              l = t('../internals/shared-key'),
              c = t('../internals/correct-prototype-getter'),
              u = l('IE_PROTO'),
              f = Object,
              d = f.prototype
            r.exports = c
              ? f.getPrototypeOf
              : function (h) {
                  var p = a(h)
                  if (s(p, u)) return p[u]
                  var g = p.constructor
                  return o(g) && p instanceof g ? g.prototype : p instanceof f ? d : null
                }
          },
          {
            '../internals/correct-prototype-getter': 239,
            '../internals/has-own-property': 275,
            '../internals/is-callable': 285,
            '../internals/shared-key': 332,
            '../internals/to-object': 344,
          },
        ],
        314: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this')
            r.exports = s({}.isPrototypeOf)
          },
          { '../internals/function-uncurry-this': 268 },
        ],
        315: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = t('../internals/has-own-property'),
              a = t('../internals/to-indexed-object'),
              l = t('../internals/array-includes').indexOf,
              c = t('../internals/hidden-keys'),
              u = s([].push)
            r.exports = function (f, d) {
              var h,
                p = a(f),
                g = 0,
                m = []
              for (h in p) !o(c, h) && o(p, h) && u(m, h)
              for (; d.length > g; ) o(p, (h = d[g++])) && (~l(m, h) || u(m, h))
              return m
            }
          },
          {
            '../internals/array-includes': 228,
            '../internals/function-uncurry-this': 268,
            '../internals/has-own-property': 275,
            '../internals/hidden-keys': 276,
            '../internals/to-indexed-object': 341,
          },
        ],
        316: [
          function (t, r, i) {
            var s = t('../internals/object-keys-internal'),
              o = t('../internals/enum-bug-keys')
            r.exports =
              Object.keys ||
              function (a) {
                return s(a, o)
              }
          },
          { '../internals/enum-bug-keys': 258, '../internals/object-keys-internal': 315 },
        ],
        317: [
          function (t, r, i) {
            var s = {}.propertyIsEnumerable,
              o = Object.getOwnPropertyDescriptor,
              a = o && !s.call({ 1: 2 }, 1)
            i.f = a
              ? function (l) {
                  var c = o(this, l)
                  return !!c && c.enumerable
                }
              : s
          },
          {},
        ],
        318: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this-accessor'),
              o = t('../internals/an-object'),
              a = t('../internals/a-possible-prototype')
            r.exports =
              Object.setPrototypeOf ||
              ('__proto__' in {}
                ? (function () {
                    var l,
                      c = !1,
                      u = {}
                    try {
                      ;((l = s(Object.prototype, '__proto__', 'set'))(u, []),
                        (c = u instanceof Array))
                    } catch {}
                    return function (f, d) {
                      return (o(f), a(d), c ? l(f, d) : (f.__proto__ = d), f)
                    }
                  })()
                : void 0)
          },
          {
            '../internals/a-possible-prototype': 224,
            '../internals/an-object': 227,
            '../internals/function-uncurry-this-accessor': 266,
          },
        ],
        319: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/fails'),
              a = t('../internals/function-uncurry-this'),
              l = t('../internals/object-get-prototype-of'),
              c = t('../internals/object-keys'),
              u = t('../internals/to-indexed-object'),
              f = a(t('../internals/object-property-is-enumerable').f),
              d = a([].push),
              h =
                s &&
                o(function () {
                  var g = Object.create(null)
                  return ((g[2] = 2), !f(g, 2))
                }),
              p = function (g) {
                return function (m) {
                  for (
                    var y, b = u(m), w = c(b), C = h && l(b) === null, T = w.length, I = 0, B = [];
                    T > I;

                  )
                    ((y = w[I++]), (s && !(C ? y in b : f(b, y))) || d(B, g ? [y, b[y]] : b[y]))
                  return B
                }
              }
            r.exports = { entries: p(!0), values: p(!1) }
          },
          {
            '../internals/descriptors': 247,
            '../internals/fails': 260,
            '../internals/function-uncurry-this': 268,
            '../internals/object-get-prototype-of': 313,
            '../internals/object-keys': 316,
            '../internals/object-property-is-enumerable': 317,
            '../internals/to-indexed-object': 341,
          },
        ],
        320: [
          function (t, r, i) {
            var s = t('../internals/function-call'),
              o = t('../internals/is-callable'),
              a = t('../internals/is-object'),
              l = TypeError
            r.exports = function (c, u) {
              var f, d
              if (
                (u === 'string' && o((f = c.toString)) && !a((d = s(f, c)))) ||
                (o((f = c.valueOf)) && !a((d = s(f, c)))) ||
                (u !== 'string' && o((f = c.toString)) && !a((d = s(f, c))))
              )
                return d
              throw new l("Can't convert object to primitive value")
            }
          },
          {
            '../internals/function-call': 264,
            '../internals/is-callable': 285,
            '../internals/is-object': 289,
          },
        ],
        321: [
          function (t, r, i) {
            var s = t('../internals/get-built-in'),
              o = t('../internals/function-uncurry-this'),
              a = t('../internals/object-get-own-property-names'),
              l = t('../internals/object-get-own-property-symbols'),
              c = t('../internals/an-object'),
              u = o([].concat)
            r.exports =
              s('Reflect', 'ownKeys') ||
              function (f) {
                var d = a.f(c(f)),
                  h = l.f
                return h ? u(d, h(f)) : d
              }
          },
          {
            '../internals/an-object': 227,
            '../internals/function-uncurry-this': 268,
            '../internals/get-built-in': 269,
            '../internals/object-get-own-property-names': 311,
            '../internals/object-get-own-property-symbols': 312,
          },
        ],
        322: [
          function (t, r, i) {
            var s = t('../internals/global')
            r.exports = s
          },
          { '../internals/global': 274 },
        ],
        323: [
          function (t, r, i) {
            r.exports = function (s) {
              try {
                return { error: !1, value: s() }
              } catch (o) {
                return { error: !0, value: o }
              }
            }
          },
          {},
        ],
        324: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/promise-native-constructor'),
              a = t('../internals/is-callable'),
              l = t('../internals/is-forced'),
              c = t('../internals/inspect-source'),
              u = t('../internals/well-known-symbol'),
              f = t('../internals/engine-is-browser'),
              d = t('../internals/engine-is-deno'),
              h = t('../internals/is-pure'),
              p = t('../internals/engine-v8-version'),
              g = o && o.prototype,
              m = u('species'),
              y = !1,
              b = a(s.PromiseRejectionEvent),
              w = l('Promise', function () {
                var C = c(o),
                  T = C !== String(o)
                if ((!T && p === 66) || (h && (!g.catch || !g.finally))) return !0
                if (!p || p < 51 || !/native code/.test(C)) {
                  var I = new o(function (E) {
                      E(1)
                    }),
                    B = function (E) {
                      E(
                        function () {},
                        function () {},
                      )
                    }
                  if ((((I.constructor = {})[m] = B), !(y = I.then(function () {}) instanceof B)))
                    return !0
                }
                return !T && (f || d) && !b
              })
            r.exports = { CONSTRUCTOR: w, REJECTION_EVENT: b, SUBCLASSING: y }
          },
          {
            '../internals/engine-is-browser': 250,
            '../internals/engine-is-deno': 251,
            '../internals/engine-v8-version': 257,
            '../internals/global': 274,
            '../internals/inspect-source': 281,
            '../internals/is-callable': 285,
            '../internals/is-forced': 287,
            '../internals/is-pure': 290,
            '../internals/promise-native-constructor': 325,
            '../internals/well-known-symbol': 357,
          },
        ],
        325: [
          function (t, r, i) {
            var s = t('../internals/global')
            r.exports = s.Promise
          },
          { '../internals/global': 274 },
        ],
        326: [
          function (t, r, i) {
            var s = t('../internals/an-object'),
              o = t('../internals/is-object'),
              a = t('../internals/new-promise-capability')
            r.exports = function (l, c) {
              if ((s(l), o(c) && c.constructor === l)) return c
              var u = a.f(l)
              return ((0, u.resolve)(c), u.promise)
            }
          },
          {
            '../internals/an-object': 227,
            '../internals/is-object': 289,
            '../internals/new-promise-capability': 303,
          },
        ],
        327: [
          function (t, r, i) {
            var s = t('../internals/promise-native-constructor'),
              o = t('../internals/check-correctness-of-iteration'),
              a = t('../internals/promise-constructor-detection').CONSTRUCTOR
            r.exports =
              a ||
              !o(function (l) {
                s.all(l).then(void 0, function () {})
              })
          },
          {
            '../internals/check-correctness-of-iteration': 234,
            '../internals/promise-constructor-detection': 324,
            '../internals/promise-native-constructor': 325,
          },
        ],
        328: [
          function (t, r, i) {
            var s = function () {
              ;((this.head = null), (this.tail = null))
            }
            ;((s.prototype = {
              add: function (o) {
                var a = { item: o, next: null },
                  l = this.tail
                ;(l ? (l.next = a) : (this.head = a), (this.tail = a))
              },
              get: function () {
                var o = this.head
                if (o) return ((this.head = o.next) === null && (this.tail = null), o.item)
              },
            }),
              (r.exports = s))
          },
          {},
        ],
        329: [
          function (t, r, i) {
            var s = t('../internals/is-null-or-undefined'),
              o = TypeError
            r.exports = function (a) {
              if (s(a)) throw new o("Can't call method on " + a)
              return a
            }
          },
          { '../internals/is-null-or-undefined': 288 },
        ],
        330: [
          function (t, r, i) {
            var s = t('../internals/get-built-in'),
              o = t('../internals/define-built-in-accessor'),
              a = t('../internals/well-known-symbol'),
              l = t('../internals/descriptors'),
              c = a('species')
            r.exports = function (u) {
              var f = s(u)
              l &&
                f &&
                !f[c] &&
                o(f, c, {
                  configurable: !0,
                  get: function () {
                    return this
                  },
                })
            }
          },
          {
            '../internals/define-built-in-accessor': 244,
            '../internals/descriptors': 247,
            '../internals/get-built-in': 269,
            '../internals/well-known-symbol': 357,
          },
        ],
        331: [
          function (t, r, i) {
            var s = t('../internals/object-define-property').f,
              o = t('../internals/has-own-property'),
              a = t('../internals/well-known-symbol')('toStringTag')
            r.exports = function (l, c, u) {
              ;(l && !u && (l = l.prototype),
                l && !o(l, a) && s(l, a, { configurable: !0, value: c }))
            }
          },
          {
            '../internals/has-own-property': 275,
            '../internals/object-define-property': 308,
            '../internals/well-known-symbol': 357,
          },
        ],
        332: [
          function (t, r, i) {
            var s = t('../internals/shared'),
              o = t('../internals/uid'),
              a = s('keys')
            r.exports = function (l) {
              return a[l] || (a[l] = o(l))
            }
          },
          { '../internals/shared': 334, '../internals/uid': 350 },
        ],
        333: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/define-global-property'),
              a = s['__core-js_shared__'] || o('__core-js_shared__', {})
            r.exports = a
          },
          { '../internals/define-global-property': 246, '../internals/global': 274 },
        ],
        334: [
          function (t, r, i) {
            var s = t('../internals/is-pure'),
              o = t('../internals/shared-store')
            ;(r.exports = function (a, l) {
              return o[a] || (o[a] = l !== void 0 ? l : {})
            })('versions', []).push({
              version: '3.33.0',
              mode: s ? 'pure' : 'global',
              copyright: ' 2014-2023 Denis Pushkarev (zloirock.ru)',
              license: 'https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE',
              source: 'https://github.com/zloirock/core-js',
            })
          },
          { '../internals/is-pure': 290, '../internals/shared-store': 333 },
        ],
        335: [
          function (t, r, i) {
            var s = t('../internals/an-object'),
              o = t('../internals/a-constructor'),
              a = t('../internals/is-null-or-undefined'),
              l = t('../internals/well-known-symbol')('species')
            r.exports = function (c, u) {
              var f,
                d = s(c).constructor
              return d === void 0 || a((f = s(d)[l])) ? u : o(f)
            }
          },
          {
            '../internals/a-constructor': 223,
            '../internals/an-object': 227,
            '../internals/is-null-or-undefined': 288,
            '../internals/well-known-symbol': 357,
          },
        ],
        336: [
          function (t, r, i) {
            var s = t('../internals/engine-v8-version'),
              o = t('../internals/fails'),
              a = t('../internals/global').String
            r.exports =
              !!Object.getOwnPropertySymbols &&
              !o(function () {
                var l = Symbol('symbol detection')
                return !a(l) || !(Object(l) instanceof Symbol) || (!Symbol.sham && s && s < 41)
              })
          },
          {
            '../internals/engine-v8-version': 257,
            '../internals/fails': 260,
            '../internals/global': 274,
          },
        ],
        337: [
          function (t, r, i) {
            var s = t('../internals/function-call'),
              o = t('../internals/get-built-in'),
              a = t('../internals/well-known-symbol'),
              l = t('../internals/define-built-in')
            r.exports = function () {
              var c = o('Symbol'),
                u = c && c.prototype,
                f = u && u.valueOf,
                d = a('toPrimitive')
              u &&
                !u[d] &&
                l(
                  u,
                  d,
                  function (h) {
                    return s(f, this)
                  },
                  { arity: 1 },
                )
            }
          },
          {
            '../internals/define-built-in': 245,
            '../internals/function-call': 264,
            '../internals/get-built-in': 269,
            '../internals/well-known-symbol': 357,
          },
        ],
        338: [
          function (t, r, i) {
            var s = t('../internals/symbol-constructor-detection')
            r.exports = s && !!Symbol.for && !!Symbol.keyFor
          },
          { '../internals/symbol-constructor-detection': 336 },
        ],
        339: [
          function (t, r, i) {
            var s,
              o,
              a,
              l,
              c = t('../internals/global'),
              u = t('../internals/function-apply'),
              f = t('../internals/function-bind-context'),
              d = t('../internals/is-callable'),
              h = t('../internals/has-own-property'),
              p = t('../internals/fails'),
              g = t('../internals/html'),
              m = t('../internals/array-slice'),
              y = t('../internals/document-create-element'),
              b = t('../internals/validate-arguments-length'),
              w = t('../internals/engine-is-ios'),
              C = t('../internals/engine-is-node'),
              T = c.setImmediate,
              I = c.clearImmediate,
              B = c.process,
              E = c.Dispatch,
              O = c.Function,
              P = c.MessageChannel,
              $ = c.String,
              F = 0,
              M = {}
            p(function () {
              s = c.location
            })
            var R = function (_) {
                if (h(M, _)) {
                  var S = M[_]
                  ;(delete M[_], S())
                }
              },
              k = function (_) {
                return function () {
                  R(_)
                }
              },
              v = function (_) {
                R(_.data)
              },
              x = function (_) {
                c.postMessage($(_), s.protocol + '//' + s.host)
              }
            ;((T && I) ||
              ((T = function (_) {
                b(arguments.length, 1)
                var S = d(_) ? _ : O(_),
                  A = m(arguments, 1)
                return (
                  (M[++F] = function () {
                    u(S, void 0, A)
                  }),
                  o(F),
                  F
                )
              }),
              (I = function (_) {
                delete M[_]
              }),
              C
                ? (o = function (_) {
                    B.nextTick(k(_))
                  })
                : E && E.now
                  ? (o = function (_) {
                      E.now(k(_))
                    })
                  : P && !w
                    ? ((l = (a = new P()).port2),
                      (a.port1.onmessage = v),
                      (o = f(l.postMessage, l)))
                    : c.addEventListener &&
                        d(c.postMessage) &&
                        !c.importScripts &&
                        s &&
                        s.protocol !== 'file:' &&
                        !p(x)
                      ? ((o = x), c.addEventListener('message', v, !1))
                      : (o =
                          'onreadystatechange' in y('script')
                            ? function (_) {
                                g.appendChild(y('script')).onreadystatechange = function () {
                                  ;(g.removeChild(this), R(_))
                                }
                              }
                            : function (_) {
                                setTimeout(k(_), 0)
                              })),
              (r.exports = { set: T, clear: I }))
          },
          {
            '../internals/array-slice': 231,
            '../internals/document-create-element': 249,
            '../internals/engine-is-ios': 253,
            '../internals/engine-is-node': 254,
            '../internals/fails': 260,
            '../internals/function-apply': 261,
            '../internals/function-bind-context': 262,
            '../internals/global': 274,
            '../internals/has-own-property': 275,
            '../internals/html': 278,
            '../internals/is-callable': 285,
            '../internals/validate-arguments-length': 353,
          },
        ],
        340: [
          function (t, r, i) {
            var s = t('../internals/to-integer-or-infinity'),
              o = Math.max,
              a = Math.min
            r.exports = function (l, c) {
              var u = s(l)
              return u < 0 ? o(u + c, 0) : a(u, c)
            }
          },
          { '../internals/to-integer-or-infinity': 342 },
        ],
        341: [
          function (t, r, i) {
            var s = t('../internals/indexed-object'),
              o = t('../internals/require-object-coercible')
            r.exports = function (a) {
              return s(o(a))
            }
          },
          { '../internals/indexed-object': 280, '../internals/require-object-coercible': 329 },
        ],
        342: [
          function (t, r, i) {
            var s = t('../internals/math-trunc')
            r.exports = function (o) {
              var a = +o
              return a != a || a === 0 ? 0 : s(a)
            }
          },
          { '../internals/math-trunc': 301 },
        ],
        343: [
          function (t, r, i) {
            var s = t('../internals/to-integer-or-infinity'),
              o = Math.min
            r.exports = function (a) {
              return a > 0 ? o(s(a), 9007199254740991) : 0
            }
          },
          { '../internals/to-integer-or-infinity': 342 },
        ],
        344: [
          function (t, r, i) {
            var s = t('../internals/require-object-coercible'),
              o = Object
            r.exports = function (a) {
              return o(s(a))
            }
          },
          { '../internals/require-object-coercible': 329 },
        ],
        345: [
          function (t, r, i) {
            var s = t('../internals/function-call'),
              o = t('../internals/is-object'),
              a = t('../internals/is-symbol'),
              l = t('../internals/get-method'),
              c = t('../internals/ordinary-to-primitive'),
              u = t('../internals/well-known-symbol'),
              f = TypeError,
              d = u('toPrimitive')
            r.exports = function (h, p) {
              if (!o(h) || a(h)) return h
              var g,
                m = l(h, d)
              if (m) {
                if ((p === void 0 && (p = 'default'), (g = s(m, h, p)), !o(g) || a(g))) return g
                throw new f("Can't convert object to primitive value")
              }
              return (p === void 0 && (p = 'number'), c(h, p))
            }
          },
          {
            '../internals/function-call': 264,
            '../internals/get-method': 273,
            '../internals/is-object': 289,
            '../internals/is-symbol': 292,
            '../internals/ordinary-to-primitive': 320,
            '../internals/well-known-symbol': 357,
          },
        ],
        346: [
          function (t, r, i) {
            var s = t('../internals/to-primitive'),
              o = t('../internals/is-symbol')
            r.exports = function (a) {
              var l = s(a, 'string')
              return o(l) ? l : l + ''
            }
          },
          { '../internals/is-symbol': 292, '../internals/to-primitive': 345 },
        ],
        347: [
          function (t, r, i) {
            var s = {}
            ;((s[t('../internals/well-known-symbol')('toStringTag')] = 'z'),
              (r.exports = String(s) === '[object z]'))
          },
          { '../internals/well-known-symbol': 357 },
        ],
        348: [
          function (t, r, i) {
            var s = t('../internals/classof'),
              o = String
            r.exports = function (a) {
              if (s(a) === 'Symbol')
                throw new TypeError('Cannot convert a Symbol value to a string')
              return o(a)
            }
          },
          { '../internals/classof': 236 },
        ],
        349: [
          function (t, r, i) {
            var s = String
            r.exports = function (o) {
              try {
                return s(o)
              } catch {
                return 'Object'
              }
            }
          },
          {},
        ],
        350: [
          function (t, r, i) {
            var s = t('../internals/function-uncurry-this'),
              o = 0,
              a = Math.random(),
              l = s((1).toString)
            r.exports = function (c) {
              return 'Symbol(' + (c === void 0 ? '' : c) + ')_' + l(++o + a, 36)
            }
          },
          { '../internals/function-uncurry-this': 268 },
        ],
        351: [
          function (t, r, i) {
            var s = t('../internals/symbol-constructor-detection')
            r.exports = s && !Symbol.sham && typeof Symbol.iterator == 'symbol'
          },
          { '../internals/symbol-constructor-detection': 336 },
        ],
        352: [
          function (t, r, i) {
            var s = t('../internals/descriptors'),
              o = t('../internals/fails')
            r.exports =
              s &&
              o(function () {
                return (
                  Object.defineProperty(function () {}, 'prototype', { value: 42, writable: !1 })
                    .prototype !== 42
                )
              })
          },
          { '../internals/descriptors': 247, '../internals/fails': 260 },
        ],
        353: [
          function (t, r, i) {
            var s = TypeError
            r.exports = function (o, a) {
              if (o < a) throw new s('Not enough arguments')
              return o
            }
          },
          {},
        ],
        354: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/is-callable'),
              a = s.WeakMap
            r.exports = o(a) && /native code/.test(String(a))
          },
          { '../internals/global': 274, '../internals/is-callable': 285 },
        ],
        355: [
          function (t, r, i) {
            var s = t('../internals/path'),
              o = t('../internals/has-own-property'),
              a = t('../internals/well-known-symbol-wrapped'),
              l = t('../internals/object-define-property').f
            r.exports = function (c) {
              var u = s.Symbol || (s.Symbol = {})
              o(u, c) || l(u, c, { value: a.f(c) })
            }
          },
          {
            '../internals/has-own-property': 275,
            '../internals/object-define-property': 308,
            '../internals/path': 322,
            '../internals/well-known-symbol-wrapped': 356,
          },
        ],
        356: [
          function (t, r, i) {
            var s = t('../internals/well-known-symbol')
            i.f = s
          },
          { '../internals/well-known-symbol': 357 },
        ],
        357: [
          function (t, r, i) {
            var s = t('../internals/global'),
              o = t('../internals/shared'),
              a = t('../internals/has-own-property'),
              l = t('../internals/uid'),
              c = t('../internals/symbol-constructor-detection'),
              u = t('../internals/use-symbol-as-uid'),
              f = s.Symbol,
              d = o('wks'),
              h = u ? f.for || f : (f && f.withoutSetter) || l
            r.exports = function (p) {
              return (a(d, p) || (d[p] = c && a(f, p) ? f[p] : h('Symbol.' + p)), d[p])
            }
          },
          {
            '../internals/global': 274,
            '../internals/has-own-property': 275,
            '../internals/shared': 334,
            '../internals/symbol-constructor-detection': 336,
            '../internals/uid': 350,
            '../internals/use-symbol-as-uid': 351,
          },
        ],
        358: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/array-iteration').findIndex,
              a = t('../internals/add-to-unscopables'),
              l = !0
            ;('findIndex' in [] &&
              Array(1).findIndex(function () {
                l = !1
              }),
              s(
                { target: 'Array', proto: !0, forced: l },
                {
                  findIndex: function (c) {
                    return o(this, c, arguments.length > 1 ? arguments[1] : void 0)
                  },
                },
              ),
              a('findIndex'))
          },
          {
            '../internals/add-to-unscopables': 225,
            '../internals/array-iteration': 229,
            '../internals/export': 259,
          },
        ],
        359: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/array-iteration').find,
              a = t('../internals/add-to-unscopables'),
              l = !0
            ;('find' in [] &&
              Array(1).find(function () {
                l = !1
              }),
              s(
                { target: 'Array', proto: !0, forced: l },
                {
                  find: function (c) {
                    return o(this, c, arguments.length > 1 ? arguments[1] : void 0)
                  },
                },
              ),
              a('find'))
          },
          {
            '../internals/add-to-unscopables': 225,
            '../internals/array-iteration': 229,
            '../internals/export': 259,
          },
        ],
        360: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/array-includes').includes,
              a = t('../internals/fails'),
              l = t('../internals/add-to-unscopables')
            ;(s(
              {
                target: 'Array',
                proto: !0,
                forced: a(function () {
                  return !Array(1).includes()
                }),
              },
              {
                includes: function (c) {
                  return o(this, c, arguments.length > 1 ? arguments[1] : void 0)
                },
              },
            ),
              l('includes'))
          },
          {
            '../internals/add-to-unscopables': 225,
            '../internals/array-includes': 228,
            '../internals/export': 259,
            '../internals/fails': 260,
          },
        ],
        361: [
          function (t, r, i) {
            var s = t('../internals/to-indexed-object'),
              o = t('../internals/add-to-unscopables'),
              a = t('../internals/iterators'),
              l = t('../internals/internal-state'),
              c = t('../internals/object-define-property').f,
              u = t('../internals/iterator-define'),
              f = t('../internals/create-iter-result-object'),
              d = t('../internals/is-pure'),
              h = t('../internals/descriptors'),
              p = l.set,
              g = l.getterFor('Array Iterator')
            r.exports = u(
              Array,
              'Array',
              function (y, b) {
                p(this, { type: 'Array Iterator', target: s(y), index: 0, kind: b })
              },
              function () {
                var y = g(this),
                  b = y.target,
                  w = y.kind,
                  C = y.index++
                if (!b || C >= b.length) return ((y.target = void 0), f(void 0, !0))
                switch (w) {
                  case 'keys':
                    return f(C, !1)
                  case 'values':
                    return f(b[C], !1)
                }
                return f([C, b[C]], !1)
              },
              'values',
            )
            var m = (a.Arguments = a.Array)
            if ((o('keys'), o('values'), o('entries'), !d && h && m.name !== 'values'))
              try {
                c(m, 'name', { value: 'values' })
              } catch {}
          },
          {
            '../internals/add-to-unscopables': 225,
            '../internals/create-iter-result-object': 240,
            '../internals/descriptors': 247,
            '../internals/internal-state': 282,
            '../internals/is-pure': 290,
            '../internals/iterator-define': 296,
            '../internals/iterators': 298,
            '../internals/object-define-property': 308,
            '../internals/to-indexed-object': 341,
          },
        ],
        362: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/get-built-in'),
              a = t('../internals/function-apply'),
              l = t('../internals/function-call'),
              c = t('../internals/function-uncurry-this'),
              u = t('../internals/fails'),
              f = t('../internals/is-callable'),
              d = t('../internals/is-symbol'),
              h = t('../internals/array-slice'),
              p = t('../internals/get-json-replacer-function'),
              g = t('../internals/symbol-constructor-detection'),
              m = String,
              y = o('JSON', 'stringify'),
              b = c(/./.exec),
              w = c(''.charAt),
              C = c(''.charCodeAt),
              T = c(''.replace),
              I = c((1).toString),
              B = /[\uD800-\uDFFF]/g,
              E = /^[\uD800-\uDBFF]$/,
              O = /^[\uDC00-\uDFFF]$/,
              P =
                !g ||
                u(function () {
                  var R = o('Symbol')('stringify detection')
                  return y([R]) !== '[null]' || y({ a: R }) !== '{}' || y(Object(R)) !== '{}'
                }),
              $ = u(function () {
                return y('\uDF06\uD834') !== '"\\udf06\\ud834"' || y('\uDEAD') !== '"\\udead"'
              }),
              F = function (R, k) {
                var v = h(arguments),
                  x = p(k)
                if (f(x) || (R !== void 0 && !d(R)))
                  return (
                    (v[1] = function (_, S) {
                      if ((f(x) && (S = l(x, this, m(_), S)), !d(S))) return S
                    }),
                    a(y, null, v)
                  )
              },
              M = function (R, k, v) {
                var x = w(v, k - 1),
                  _ = w(v, k + 1)
                return (b(E, R) && !b(O, _)) || (b(O, R) && !b(E, x)) ? '\\u' + I(C(R, 0), 16) : R
              }
            y &&
              s(
                { target: 'JSON', stat: !0, arity: 3, forced: P || $ },
                {
                  stringify: function (R, k, v) {
                    var x = h(arguments),
                      _ = a(P ? F : y, null, x)
                    return $ && typeof _ == 'string' ? T(_, B, M) : _
                  },
                },
              )
          },
          {
            '../internals/array-slice': 231,
            '../internals/export': 259,
            '../internals/fails': 260,
            '../internals/function-apply': 261,
            '../internals/function-call': 264,
            '../internals/function-uncurry-this': 268,
            '../internals/get-built-in': 269,
            '../internals/get-json-replacer-function': 272,
            '../internals/is-callable': 285,
            '../internals/is-symbol': 292,
            '../internals/symbol-constructor-detection': 336,
          },
        ],
        363: [
          function (t, r, i) {
            t('../internals/export')(
              { target: 'Number', stat: !0 },
              {
                isNaN: function (s) {
                  return s != s
                },
              },
            )
          },
          { '../internals/export': 259 },
        ],
        364: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/object-assign')
            s({ target: 'Object', stat: !0, arity: 2, forced: Object.assign !== o }, { assign: o })
          },
          { '../internals/export': 259, '../internals/object-assign': 305 },
        ],
        365: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/symbol-constructor-detection'),
              a = t('../internals/fails'),
              l = t('../internals/object-get-own-property-symbols'),
              c = t('../internals/to-object')
            s(
              {
                target: 'Object',
                stat: !0,
                forced:
                  !o ||
                  a(function () {
                    l.f(1)
                  }),
              },
              {
                getOwnPropertySymbols: function (u) {
                  var f = l.f
                  return f ? f(c(u)) : []
                },
              },
            )
          },
          {
            '../internals/export': 259,
            '../internals/fails': 260,
            '../internals/object-get-own-property-symbols': 312,
            '../internals/symbol-constructor-detection': 336,
            '../internals/to-object': 344,
          },
        ],
        366: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/to-object'),
              a = t('../internals/object-keys')
            s(
              {
                target: 'Object',
                stat: !0,
                forced: t('../internals/fails')(function () {
                  a(1)
                }),
              },
              {
                keys: function (l) {
                  return a(o(l))
                },
              },
            )
          },
          {
            '../internals/export': 259,
            '../internals/fails': 260,
            '../internals/object-keys': 316,
            '../internals/to-object': 344,
          },
        ],
        367: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/object-to-array').values
            s(
              { target: 'Object', stat: !0 },
              {
                values: function (a) {
                  return o(a)
                },
              },
            )
          },
          { '../internals/export': 259, '../internals/object-to-array': 319 },
        ],
        368: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/function-call'),
              a = t('../internals/a-callable'),
              l = t('../internals/new-promise-capability'),
              c = t('../internals/perform'),
              u = t('../internals/iterate')
            s(
              {
                target: 'Promise',
                stat: !0,
                forced: t('../internals/promise-statics-incorrect-iteration'),
              },
              {
                all: function (f) {
                  var d = this,
                    h = l.f(d),
                    p = h.resolve,
                    g = h.reject,
                    m = c(function () {
                      var y = a(d.resolve),
                        b = [],
                        w = 0,
                        C = 1
                      ;(u(f, function (T) {
                        var I = w++,
                          B = !1
                        ;(C++,
                          o(y, d, T).then(function (E) {
                            B || ((B = !0), (b[I] = E), --C || p(b))
                          }, g))
                      }),
                        --C || p(b))
                    })
                  return (m.error && g(m.value), h.promise)
                },
              },
            )
          },
          {
            '../internals/a-callable': 222,
            '../internals/export': 259,
            '../internals/function-call': 264,
            '../internals/iterate': 293,
            '../internals/new-promise-capability': 303,
            '../internals/perform': 323,
            '../internals/promise-statics-incorrect-iteration': 327,
          },
        ],
        369: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/is-pure'),
              a = t('../internals/promise-constructor-detection').CONSTRUCTOR,
              l = t('../internals/promise-native-constructor'),
              c = t('../internals/get-built-in'),
              u = t('../internals/is-callable'),
              f = t('../internals/define-built-in'),
              d = l && l.prototype
            if (
              (s(
                { target: 'Promise', proto: !0, forced: a, real: !0 },
                {
                  catch: function (p) {
                    return this.then(void 0, p)
                  },
                },
              ),
              !o && u(l))
            ) {
              var h = c('Promise').prototype.catch
              d.catch !== h && f(d, 'catch', h, { unsafe: !0 })
            }
          },
          {
            '../internals/define-built-in': 245,
            '../internals/export': 259,
            '../internals/get-built-in': 269,
            '../internals/is-callable': 285,
            '../internals/is-pure': 290,
            '../internals/promise-constructor-detection': 324,
            '../internals/promise-native-constructor': 325,
          },
        ],
        370: [
          function (t, r, i) {
            var s,
              o,
              a,
              l = t('../internals/export'),
              c = t('../internals/is-pure'),
              u = t('../internals/engine-is-node'),
              f = t('../internals/global'),
              d = t('../internals/function-call'),
              h = t('../internals/define-built-in'),
              p = t('../internals/object-set-prototype-of'),
              g = t('../internals/set-to-string-tag'),
              m = t('../internals/set-species'),
              y = t('../internals/a-callable'),
              b = t('../internals/is-callable'),
              w = t('../internals/is-object'),
              C = t('../internals/an-instance'),
              T = t('../internals/species-constructor'),
              I = t('../internals/task').set,
              B = t('../internals/microtask'),
              E = t('../internals/host-report-errors'),
              O = t('../internals/perform'),
              P = t('../internals/queue'),
              $ = t('../internals/internal-state'),
              F = t('../internals/promise-native-constructor'),
              M = t('../internals/promise-constructor-detection'),
              R = t('../internals/new-promise-capability'),
              k = M.CONSTRUCTOR,
              v = M.REJECTION_EVENT,
              x = M.SUBCLASSING,
              _ = $.getterFor('Promise'),
              S = $.set,
              A = F && F.prototype,
              j = F,
              L = A,
              H = f.TypeError,
              U = f.document,
              K = f.process,
              z = R.f,
              q = z,
              D = !!(U && U.createEvent && f.dispatchEvent),
              N = function (tt) {
                var st
                return !(!w(tt) || !b((st = tt.then))) && st
              },
              V = function (tt, st) {
                var ot,
                  at,
                  ht,
                  dt = st.value,
                  mt = st.state === 1,
                  bt = mt ? tt.ok : tt.fail,
                  yt = tt.resolve,
                  vt = tt.reject,
                  Nt = tt.domain
                try {
                  bt
                    ? (mt || (st.rejection === 2 && rt(st), (st.rejection = 1)),
                      bt === !0
                        ? (ot = dt)
                        : (Nt && Nt.enter(), (ot = bt(dt)), Nt && (Nt.exit(), (ht = !0))),
                      ot === tt.promise
                        ? vt(new H('Promise-chain cycle'))
                        : (at = N(ot))
                          ? d(at, ot, yt, vt)
                          : yt(ot))
                    : vt(dt)
                } catch (Dt) {
                  ;(Nt && !ht && Nt.exit(), vt(Dt))
                }
              },
              W = function (tt, st) {
                tt.notified ||
                  ((tt.notified = !0),
                  B(function () {
                    for (var ot, at = tt.reactions; (ot = at.get()); ) V(ot, tt)
                    ;((tt.notified = !1), st && !tt.rejection && G(tt))
                  }))
              },
              J = function (tt, st, ot) {
                var at, ht
                ;(D
                  ? (((at = U.createEvent('Event')).promise = st),
                    (at.reason = ot),
                    at.initEvent(tt, !1, !0),
                    f.dispatchEvent(at))
                  : (at = { promise: st, reason: ot }),
                  !v && (ht = f['on' + tt])
                    ? ht(at)
                    : tt === 'unhandledrejection' && E('Unhandled promise rejection', ot))
              },
              G = function (tt) {
                d(I, f, function () {
                  var st,
                    ot = tt.facade,
                    at = tt.value
                  if (
                    Z(tt) &&
                    ((st = O(function () {
                      u ? K.emit('unhandledRejection', at, ot) : J('unhandledrejection', ot, at)
                    })),
                    (tt.rejection = u || Z(tt) ? 2 : 1),
                    st.error)
                  )
                    throw st.value
                })
              },
              Z = function (tt) {
                return tt.rejection !== 1 && !tt.parent
              },
              rt = function (tt) {
                d(I, f, function () {
                  var st = tt.facade
                  u ? K.emit('rejectionHandled', st) : J('rejectionhandled', st, tt.value)
                })
              },
              nt = function (tt, st, ot) {
                return function (at) {
                  tt(st, at, ot)
                }
              },
              X = function (tt, st, ot) {
                tt.done ||
                  ((tt.done = !0), ot && (tt = ot), (tt.value = st), (tt.state = 2), W(tt, !0))
              },
              Q = function (tt, st, ot) {
                if (!tt.done) {
                  ;((tt.done = !0), ot && (tt = ot))
                  try {
                    if (tt.facade === st) throw new H("Promise can't be resolved itself")
                    var at = N(st)
                    at
                      ? B(function () {
                          var ht = { done: !1 }
                          try {
                            d(at, st, nt(Q, ht, tt), nt(X, ht, tt))
                          } catch (dt) {
                            X(ht, dt, tt)
                          }
                        })
                      : ((tt.value = st), (tt.state = 1), W(tt, !1))
                  } catch (ht) {
                    X({ done: !1 }, ht, tt)
                  }
                }
              }
            if (
              k &&
              ((L = (j = function (tt) {
                ;(C(this, L), y(tt), d(s, this))
                var st = _(this)
                try {
                  tt(nt(Q, st), nt(X, st))
                } catch (ot) {
                  X(st, ot)
                }
              }).prototype),
              ((s = function (tt) {
                S(this, {
                  type: 'Promise',
                  done: !1,
                  notified: !1,
                  parent: !1,
                  reactions: new P(),
                  rejection: !1,
                  state: 0,
                  value: void 0,
                })
              }).prototype = h(L, 'then', function (tt, st) {
                var ot = _(this),
                  at = z(T(this, j))
                return (
                  (ot.parent = !0),
                  (at.ok = !b(tt) || tt),
                  (at.fail = b(st) && st),
                  (at.domain = u ? K.domain : void 0),
                  ot.state === 0
                    ? ot.reactions.add(at)
                    : B(function () {
                        V(at, ot)
                      }),
                  at.promise
                )
              })),
              (o = function () {
                var tt = new s(),
                  st = _(tt)
                ;((this.promise = tt), (this.resolve = nt(Q, st)), (this.reject = nt(X, st)))
              }),
              (R.f = z =
                function (tt) {
                  return tt === j || tt === void 0 ? new o(tt) : q(tt)
                }),
              !c && b(F) && A !== Object.prototype)
            ) {
              ;((a = A.then),
                x ||
                  h(
                    A,
                    'then',
                    function (tt, st) {
                      var ot = this
                      return new j(function (at, ht) {
                        d(a, ot, at, ht)
                      }).then(tt, st)
                    },
                    { unsafe: !0 },
                  ))
              try {
                delete A.constructor
              } catch {}
              p && p(A, L)
            }
            ;(l({ global: !0, constructor: !0, wrap: !0, forced: k }, { Promise: j }),
              g(j, 'Promise', !1, !0),
              m('Promise'))
          },
          {
            '../internals/a-callable': 222,
            '../internals/an-instance': 226,
            '../internals/define-built-in': 245,
            '../internals/engine-is-node': 254,
            '../internals/export': 259,
            '../internals/function-call': 264,
            '../internals/global': 274,
            '../internals/host-report-errors': 277,
            '../internals/internal-state': 282,
            '../internals/is-callable': 285,
            '../internals/is-object': 289,
            '../internals/is-pure': 290,
            '../internals/microtask': 302,
            '../internals/new-promise-capability': 303,
            '../internals/object-set-prototype-of': 318,
            '../internals/perform': 323,
            '../internals/promise-constructor-detection': 324,
            '../internals/promise-native-constructor': 325,
            '../internals/queue': 328,
            '../internals/set-species': 330,
            '../internals/set-to-string-tag': 331,
            '../internals/species-constructor': 335,
            '../internals/task': 339,
          },
        ],
        371: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/is-pure'),
              a = t('../internals/promise-native-constructor'),
              l = t('../internals/fails'),
              c = t('../internals/get-built-in'),
              u = t('../internals/is-callable'),
              f = t('../internals/species-constructor'),
              d = t('../internals/promise-resolve'),
              h = t('../internals/define-built-in'),
              p = a && a.prototype
            if (
              (s(
                {
                  target: 'Promise',
                  proto: !0,
                  real: !0,
                  forced:
                    !!a &&
                    l(function () {
                      p.finally.call({ then: function () {} }, function () {})
                    }),
                },
                {
                  finally: function (m) {
                    var y = f(this, c('Promise')),
                      b = u(m)
                    return this.then(
                      b
                        ? function (w) {
                            return d(y, m()).then(function () {
                              return w
                            })
                          }
                        : m,
                      b
                        ? function (w) {
                            return d(y, m()).then(function () {
                              throw w
                            })
                          }
                        : m,
                    )
                  },
                },
              ),
              !o && u(a))
            ) {
              var g = c('Promise').prototype.finally
              p.finally !== g && h(p, 'finally', g, { unsafe: !0 })
            }
          },
          {
            '../internals/define-built-in': 245,
            '../internals/export': 259,
            '../internals/fails': 260,
            '../internals/get-built-in': 269,
            '../internals/is-callable': 285,
            '../internals/is-pure': 290,
            '../internals/promise-native-constructor': 325,
            '../internals/promise-resolve': 326,
            '../internals/species-constructor': 335,
          },
        ],
        372: [
          function (t, r, i) {
            ;(t('../modules/es.promise.constructor'),
              t('../modules/es.promise.all'),
              t('../modules/es.promise.catch'),
              t('../modules/es.promise.race'),
              t('../modules/es.promise.reject'),
              t('../modules/es.promise.resolve'))
          },
          {
            '../modules/es.promise.all': 368,
            '../modules/es.promise.catch': 369,
            '../modules/es.promise.constructor': 370,
            '../modules/es.promise.race': 373,
            '../modules/es.promise.reject': 374,
            '../modules/es.promise.resolve': 375,
          },
        ],
        373: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/function-call'),
              a = t('../internals/a-callable'),
              l = t('../internals/new-promise-capability'),
              c = t('../internals/perform'),
              u = t('../internals/iterate')
            s(
              {
                target: 'Promise',
                stat: !0,
                forced: t('../internals/promise-statics-incorrect-iteration'),
              },
              {
                race: function (f) {
                  var d = this,
                    h = l.f(d),
                    p = h.reject,
                    g = c(function () {
                      var m = a(d.resolve)
                      u(f, function (y) {
                        o(m, d, y).then(h.resolve, p)
                      })
                    })
                  return (g.error && p(g.value), h.promise)
                },
              },
            )
          },
          {
            '../internals/a-callable': 222,
            '../internals/export': 259,
            '../internals/function-call': 264,
            '../internals/iterate': 293,
            '../internals/new-promise-capability': 303,
            '../internals/perform': 323,
            '../internals/promise-statics-incorrect-iteration': 327,
          },
        ],
        374: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/function-call'),
              a = t('../internals/new-promise-capability')
            s(
              {
                target: 'Promise',
                stat: !0,
                forced: t('../internals/promise-constructor-detection').CONSTRUCTOR,
              },
              {
                reject: function (l) {
                  var c = a.f(this)
                  return (o(c.reject, void 0, l), c.promise)
                },
              },
            )
          },
          {
            '../internals/export': 259,
            '../internals/function-call': 264,
            '../internals/new-promise-capability': 303,
            '../internals/promise-constructor-detection': 324,
          },
        ],
        375: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/get-built-in'),
              a = t('../internals/is-pure'),
              l = t('../internals/promise-native-constructor'),
              c = t('../internals/promise-constructor-detection').CONSTRUCTOR,
              u = t('../internals/promise-resolve'),
              f = o('Promise'),
              d = a && !c
            s(
              { target: 'Promise', stat: !0, forced: a || c },
              {
                resolve: function (h) {
                  return u(d && this === f ? l : this, h)
                },
              },
            )
          },
          {
            '../internals/export': 259,
            '../internals/get-built-in': 269,
            '../internals/is-pure': 290,
            '../internals/promise-constructor-detection': 324,
            '../internals/promise-native-constructor': 325,
            '../internals/promise-resolve': 326,
          },
        ],
        376: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/function-uncurry-this'),
              a = t('../internals/to-absolute-index'),
              l = RangeError,
              c = String.fromCharCode,
              u = String.fromCodePoint,
              f = o([].join)
            s(
              { target: 'String', stat: !0, arity: 1, forced: !!u && u.length !== 1 },
              {
                fromCodePoint: function (d) {
                  for (var h, p = [], g = arguments.length, m = 0; g > m; ) {
                    if (((h = +arguments[m++]), a(h, 1114111) !== h))
                      throw new l(h + ' is not a valid code point')
                    p[m] = h < 65536 ? c(h) : c(55296 + ((h -= 65536) >> 10), (h % 1024) + 56320)
                  }
                  return f(p, '')
                },
              },
            )
          },
          {
            '../internals/export': 259,
            '../internals/function-uncurry-this': 268,
            '../internals/to-absolute-index': 340,
          },
        ],
        377: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/function-uncurry-this'),
              a = t('../internals/not-a-regexp'),
              l = t('../internals/require-object-coercible'),
              c = t('../internals/to-string'),
              u = t('../internals/correct-is-regexp-logic'),
              f = o(''.indexOf)
            s(
              { target: 'String', proto: !0, forced: !u('includes') },
              {
                includes: function (d) {
                  return !!~f(c(l(this)), c(a(d)), arguments.length > 1 ? arguments[1] : void 0)
                },
              },
            )
          },
          {
            '../internals/correct-is-regexp-logic': 238,
            '../internals/export': 259,
            '../internals/function-uncurry-this': 268,
            '../internals/not-a-regexp': 304,
            '../internals/require-object-coercible': 329,
            '../internals/to-string': 348,
          },
        ],
        378: [
          function (t, r, i) {
            t('../internals/well-known-symbol-define')('asyncIterator')
          },
          { '../internals/well-known-symbol-define': 355 },
        ],
        379: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/global'),
              a = t('../internals/function-call'),
              l = t('../internals/function-uncurry-this'),
              c = t('../internals/is-pure'),
              u = t('../internals/descriptors'),
              f = t('../internals/symbol-constructor-detection'),
              d = t('../internals/fails'),
              h = t('../internals/has-own-property'),
              p = t('../internals/object-is-prototype-of'),
              g = t('../internals/an-object'),
              m = t('../internals/to-indexed-object'),
              y = t('../internals/to-property-key'),
              b = t('../internals/to-string'),
              w = t('../internals/create-property-descriptor'),
              C = t('../internals/object-create'),
              T = t('../internals/object-keys'),
              I = t('../internals/object-get-own-property-names'),
              B = t('../internals/object-get-own-property-names-external'),
              E = t('../internals/object-get-own-property-symbols'),
              O = t('../internals/object-get-own-property-descriptor'),
              P = t('../internals/object-define-property'),
              $ = t('../internals/object-define-properties'),
              F = t('../internals/object-property-is-enumerable'),
              M = t('../internals/define-built-in'),
              R = t('../internals/define-built-in-accessor'),
              k = t('../internals/shared'),
              v = t('../internals/shared-key'),
              x = t('../internals/hidden-keys'),
              _ = t('../internals/uid'),
              S = t('../internals/well-known-symbol'),
              A = t('../internals/well-known-symbol-wrapped'),
              j = t('../internals/well-known-symbol-define'),
              L = t('../internals/symbol-define-to-primitive'),
              H = t('../internals/set-to-string-tag'),
              U = t('../internals/internal-state'),
              K = t('../internals/array-iteration').forEach,
              z = v('hidden'),
              q = U.set,
              D = U.getterFor('Symbol'),
              N = Object.prototype,
              V = o.Symbol,
              W = V && V.prototype,
              J = o.RangeError,
              G = o.TypeError,
              Z = o.QObject,
              rt = O.f,
              nt = P.f,
              X = B.f,
              Q = F.f,
              tt = l([].push),
              st = k('symbols'),
              ot = k('op-symbols'),
              at = k('wks'),
              ht = !Z || !Z.prototype || !Z.prototype.findChild,
              dt = function (Ct, xt, Rt) {
                var It = rt(N, xt)
                ;(It && delete N[xt], nt(Ct, xt, Rt), It && Ct !== N && nt(N, xt, It))
              },
              mt =
                u &&
                d(function () {
                  return (
                    C(
                      nt({}, 'a', {
                        get: function () {
                          return nt(this, 'a', { value: 7 }).a
                        },
                      }),
                    ).a !== 7
                  )
                })
                  ? dt
                  : nt,
              bt = function (Ct, xt) {
                var Rt = (st[Ct] = C(W))
                return (
                  q(Rt, { type: 'Symbol', tag: Ct, description: xt }),
                  u || (Rt.description = xt),
                  Rt
                )
              },
              yt = function (Ct, xt, Rt) {
                ;(Ct === N && yt(ot, xt, Rt), g(Ct))
                var It = y(xt)
                return (
                  g(Rt),
                  h(st, It)
                    ? (Rt.enumerable
                        ? (h(Ct, z) && Ct[z][It] && (Ct[z][It] = !1),
                          (Rt = C(Rt, { enumerable: w(0, !1) })))
                        : (h(Ct, z) || nt(Ct, z, w(1, {})), (Ct[z][It] = !0)),
                      mt(Ct, It, Rt))
                    : nt(Ct, It, Rt)
                )
              },
              vt = function (Ct, xt) {
                g(Ct)
                var Rt = m(xt),
                  It = T(Rt).concat(Ot(Rt))
                return (
                  K(It, function (Pt) {
                    ;(u && !a(Nt, Rt, Pt)) || yt(Ct, Pt, Rt[Pt])
                  }),
                  Ct
                )
              },
              Nt = function (Ct) {
                var xt = y(Ct),
                  Rt = a(Q, this, xt)
                return (
                  !(this === N && h(st, xt) && !h(ot, xt)) &&
                  (!(Rt || !h(this, xt) || !h(st, xt) || (h(this, z) && this[z][xt])) || Rt)
                )
              },
              Dt = function (Ct, xt) {
                var Rt = m(Ct),
                  It = y(xt)
                if (Rt !== N || !h(st, It) || h(ot, It)) {
                  var Pt = rt(Rt, It)
                  return (!Pt || !h(st, It) || (h(Rt, z) && Rt[z][It]) || (Pt.enumerable = !0), Pt)
                }
              },
              Mt = function (Ct) {
                var xt = X(m(Ct)),
                  Rt = []
                return (
                  K(xt, function (It) {
                    h(st, It) || h(x, It) || tt(Rt, It)
                  }),
                  Rt
                )
              },
              Ot = function (Ct) {
                var xt = Ct === N,
                  Rt = X(xt ? ot : m(Ct)),
                  It = []
                return (
                  K(Rt, function (Pt) {
                    !h(st, Pt) || (xt && !h(N, Pt)) || tt(It, st[Pt])
                  }),
                  It
                )
              }
            ;(f ||
              (M(
                (W = (V = function () {
                  if (p(W, this)) throw new G('Symbol is not a constructor')
                  var Ct = arguments.length && arguments[0] !== void 0 ? b(arguments[0]) : void 0,
                    xt = _(Ct),
                    Rt = function (It) {
                      ;(this === N && a(Rt, ot, It),
                        h(this, z) && h(this[z], xt) && (this[z][xt] = !1))
                      var Pt = w(1, It)
                      try {
                        mt(this, xt, Pt)
                      } catch (ae) {
                        if (!(ae instanceof J)) throw ae
                        dt(this, xt, Pt)
                      }
                    }
                  return (u && ht && mt(N, xt, { configurable: !0, set: Rt }), bt(xt, Ct))
                }).prototype),
                'toString',
                function () {
                  return D(this).tag
                },
              ),
              M(V, 'withoutSetter', function (Ct) {
                return bt(_(Ct), Ct)
              }),
              (F.f = Nt),
              (P.f = yt),
              ($.f = vt),
              (O.f = Dt),
              (I.f = B.f = Mt),
              (E.f = Ot),
              (A.f = function (Ct) {
                return bt(S(Ct), Ct)
              }),
              u &&
                (R(W, 'description', {
                  configurable: !0,
                  get: function () {
                    return D(this).description
                  },
                }),
                c || M(N, 'propertyIsEnumerable', Nt, { unsafe: !0 }))),
              s({ global: !0, constructor: !0, wrap: !0, forced: !f, sham: !f }, { Symbol: V }),
              K(T(at), function (Ct) {
                j(Ct)
              }),
              s(
                { target: 'Symbol', stat: !0, forced: !f },
                {
                  useSetter: function () {
                    ht = !0
                  },
                  useSimple: function () {
                    ht = !1
                  },
                },
              ),
              s(
                { target: 'Object', stat: !0, forced: !f, sham: !u },
                {
                  create: function (Ct, xt) {
                    return xt === void 0 ? C(Ct) : vt(C(Ct), xt)
                  },
                  defineProperty: yt,
                  defineProperties: vt,
                  getOwnPropertyDescriptor: Dt,
                },
              ),
              s({ target: 'Object', stat: !0, forced: !f }, { getOwnPropertyNames: Mt }),
              L(),
              H(V, 'Symbol'),
              (x[z] = !0))
          },
          {
            '../internals/an-object': 227,
            '../internals/array-iteration': 229,
            '../internals/create-property-descriptor': 242,
            '../internals/define-built-in': 245,
            '../internals/define-built-in-accessor': 244,
            '../internals/descriptors': 247,
            '../internals/export': 259,
            '../internals/fails': 260,
            '../internals/function-call': 264,
            '../internals/function-uncurry-this': 268,
            '../internals/global': 274,
            '../internals/has-own-property': 275,
            '../internals/hidden-keys': 276,
            '../internals/internal-state': 282,
            '../internals/is-pure': 290,
            '../internals/object-create': 306,
            '../internals/object-define-properties': 307,
            '../internals/object-define-property': 308,
            '../internals/object-get-own-property-descriptor': 309,
            '../internals/object-get-own-property-names': 311,
            '../internals/object-get-own-property-names-external': 310,
            '../internals/object-get-own-property-symbols': 312,
            '../internals/object-is-prototype-of': 314,
            '../internals/object-keys': 316,
            '../internals/object-property-is-enumerable': 317,
            '../internals/set-to-string-tag': 331,
            '../internals/shared': 334,
            '../internals/shared-key': 332,
            '../internals/symbol-constructor-detection': 336,
            '../internals/symbol-define-to-primitive': 337,
            '../internals/to-indexed-object': 341,
            '../internals/to-property-key': 346,
            '../internals/to-string': 348,
            '../internals/uid': 350,
            '../internals/well-known-symbol': 357,
            '../internals/well-known-symbol-define': 355,
            '../internals/well-known-symbol-wrapped': 356,
          },
        ],
        380: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/get-built-in'),
              a = t('../internals/has-own-property'),
              l = t('../internals/to-string'),
              c = t('../internals/shared'),
              u = t('../internals/symbol-registry-detection'),
              f = c('string-to-symbol-registry'),
              d = c('symbol-to-string-registry')
            s(
              { target: 'Symbol', stat: !0, forced: !u },
              {
                for: function (h) {
                  var p = l(h)
                  if (a(f, p)) return f[p]
                  var g = o('Symbol')(p)
                  return ((f[p] = g), (d[g] = p), g)
                },
              },
            )
          },
          {
            '../internals/export': 259,
            '../internals/get-built-in': 269,
            '../internals/has-own-property': 275,
            '../internals/shared': 334,
            '../internals/symbol-registry-detection': 338,
            '../internals/to-string': 348,
          },
        ],
        381: [
          function (t, r, i) {
            ;(t('../modules/es.symbol.constructor'),
              t('../modules/es.symbol.for'),
              t('../modules/es.symbol.key-for'),
              t('../modules/es.json.stringify'),
              t('../modules/es.object.get-own-property-symbols'))
          },
          {
            '../modules/es.json.stringify': 362,
            '../modules/es.object.get-own-property-symbols': 365,
            '../modules/es.symbol.constructor': 379,
            '../modules/es.symbol.for': 380,
            '../modules/es.symbol.key-for': 382,
          },
        ],
        382: [
          function (t, r, i) {
            var s = t('../internals/export'),
              o = t('../internals/has-own-property'),
              a = t('../internals/is-symbol'),
              l = t('../internals/try-to-string'),
              c = t('../internals/shared'),
              u = t('../internals/symbol-registry-detection'),
              f = c('symbol-to-string-registry')
            s(
              { target: 'Symbol', stat: !0, forced: !u },
              {
                keyFor: function (d) {
                  if (!a(d)) throw new TypeError(l(d) + ' is not a symbol')
                  if (o(f, d)) return f[d]
                },
              },
            )
          },
          {
            '../internals/export': 259,
            '../internals/has-own-property': 275,
            '../internals/is-symbol': 292,
            '../internals/shared': 334,
            '../internals/symbol-registry-detection': 338,
            '../internals/try-to-string': 349,
          },
        ],
        383: [
          function (t, r, i) {
            function s(o) {
              return Object.prototype.toString.call(o)
            }
            ;((i.isArray = function (o) {
              return Array.isArray ? Array.isArray(o) : s(o) === '[object Array]'
            }),
              (i.isBoolean = function (o) {
                return typeof o == 'boolean'
              }),
              (i.isNull = function (o) {
                return o === null
              }),
              (i.isNullOrUndefined = function (o) {
                return o == null
              }),
              (i.isNumber = function (o) {
                return typeof o == 'number'
              }),
              (i.isString = function (o) {
                return typeof o == 'string'
              }),
              (i.isSymbol = function (o) {
                return typeof o == 'symbol'
              }),
              (i.isUndefined = function (o) {
                return o === void 0
              }),
              (i.isRegExp = function (o) {
                return s(o) === '[object RegExp]'
              }),
              (i.isObject = function (o) {
                return typeof o == 'object' && o !== null
              }),
              (i.isDate = function (o) {
                return s(o) === '[object Date]'
              }),
              (i.isError = function (o) {
                return s(o) === '[object Error]' || o instanceof Error
              }),
              (i.isFunction = function (o) {
                return typeof o == 'function'
              }),
              (i.isPrimitive = function (o) {
                return (
                  o === null ||
                  typeof o == 'boolean' ||
                  typeof o == 'number' ||
                  typeof o == 'string' ||
                  typeof o == 'symbol' ||
                  o === void 0
                )
              }),
              (i.isBuffer = t('buffer').Buffer.isBuffer))
          },
          { buffer: 220 },
        ],
        384: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = t('elliptic'),
                  a = t('bn.js')
                r.exports = function (f) {
                  return new c(f)
                }
                var l = {
                  secp256k1: { name: 'secp256k1', byteLength: 32 },
                  secp224r1: { name: 'p224', byteLength: 28 },
                  prime256v1: { name: 'p256', byteLength: 32 },
                  prime192v1: { name: 'p192', byteLength: 24 },
                  ed25519: { name: 'ed25519', byteLength: 32 },
                  secp384r1: { name: 'p384', byteLength: 48 },
                  secp521r1: { name: 'p521', byteLength: 66 },
                }
                function c(f) {
                  ;((this.curveType = l[f]),
                    this.curveType || (this.curveType = { name: f }),
                    (this.curve = new o.ec(this.curveType.name)),
                    (this.keys = void 0))
                }
                function u(f, d, h) {
                  Array.isArray(f) || (f = f.toArray())
                  var p = new s(f)
                  if (h && p.length < h) {
                    var g = new s(h - p.length)
                    ;(g.fill(0), (p = s.concat([g, p])))
                  }
                  return d ? p.toString(d) : p
                }
                ;((l.p224 = l.secp224r1),
                  (l.p256 = l.secp256r1 = l.prime256v1),
                  (l.p192 = l.secp192r1 = l.prime192v1),
                  (l.p384 = l.secp384r1),
                  (l.p521 = l.secp521r1),
                  (c.prototype.generateKeys = function (f, d) {
                    return ((this.keys = this.curve.genKeyPair()), this.getPublicKey(f, d))
                  }),
                  (c.prototype.computeSecret = function (f, d, h) {
                    return (
                      (d = d || 'utf8'),
                      s.isBuffer(f) || (f = new s(f, d)),
                      u(
                        this.curve.keyFromPublic(f).getPublic().mul(this.keys.getPrivate()).getX(),
                        h,
                        this.curveType.byteLength,
                      )
                    )
                  }),
                  (c.prototype.getPublicKey = function (f, d) {
                    var h = this.keys.getPublic(d === 'compressed', !0)
                    return (
                      d === 'hybrid' && (h[h.length - 1] % 2 ? (h[0] = 7) : (h[0] = 6)),
                      u(h, f)
                    )
                  }),
                  (c.prototype.getPrivateKey = function (f) {
                    return u(this.keys.getPrivate(), f)
                  }),
                  (c.prototype.setPublicKey = function (f, d) {
                    return (
                      (d = d || 'utf8'),
                      s.isBuffer(f) || (f = new s(f, d)),
                      this.keys._importPublic(f),
                      this
                    )
                  }),
                  (c.prototype.setPrivateKey = function (f, d) {
                    ;((d = d || 'utf8'), s.isBuffer(f) || (f = new s(f, d)))
                    var h = new a(f)
                    return (
                      (h = h.toString(16)),
                      (this.keys = this.curve.genKeyPair()),
                      this.keys._importPrivate(h),
                      this
                    )
                  }))
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { 'bn.js': 385, buffer: 220, elliptic: 405 },
        ],
        385: [
          function (t, r, i) {
            arguments[4][184][0].apply(i, arguments)
          },
          { buffer: 188, dup: 184 },
        ],
        386: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('md5.js'),
              a = t('ripemd160'),
              l = t('sha.js'),
              c = t('cipher-base')
            function u(f) {
              ;(c.call(this, 'digest'), (this._hash = f))
            }
            ;(s(u, c),
              (u.prototype._update = function (f) {
                this._hash.update(f)
              }),
              (u.prototype._final = function () {
                return this._hash.digest()
              }),
              (r.exports = function (f) {
                return (f = f.toLowerCase()) === 'md5'
                  ? new o()
                  : f === 'rmd160' || f === 'ripemd160'
                    ? new a()
                    : new u(l(f))
              }))
          },
          { 'cipher-base': 221, inherits: 440, 'md5.js': 450, ripemd160: 493, 'sha.js': 498 },
        ],
        387: [
          function (t, r, i) {
            var s = t('md5.js')
            r.exports = function (o) {
              return new s().update(o).digest()
            }
          },
          { 'md5.js': 450 },
        ],
        388: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('./legacy'),
              a = t('cipher-base'),
              l = t('safe-buffer').Buffer,
              c = t('create-hash/md5'),
              u = t('ripemd160'),
              f = t('sha.js'),
              d = l.alloc(128)
            function h(p, g) {
              ;(a.call(this, 'digest'), typeof g == 'string' && (g = l.from(g)))
              var m = p === 'sha512' || p === 'sha384' ? 128 : 64
              ;((this._alg = p),
                (this._key = g),
                g.length > m
                  ? (g = (p === 'rmd160' ? new u() : f(p)).update(g).digest())
                  : g.length < m && (g = l.concat([g, d], m)))
              for (
                var y = (this._ipad = l.allocUnsafe(m)), b = (this._opad = l.allocUnsafe(m)), w = 0;
                w < m;
                w++
              )
                ((y[w] = 54 ^ g[w]), (b[w] = 92 ^ g[w]))
              ;((this._hash = p === 'rmd160' ? new u() : f(p)), this._hash.update(y))
            }
            ;(s(h, a),
              (h.prototype._update = function (p) {
                this._hash.update(p)
              }),
              (h.prototype._final = function () {
                var p = this._hash.digest()
                return (this._alg === 'rmd160' ? new u() : f(this._alg))
                  .update(this._opad)
                  .update(p)
                  .digest()
              }),
              (r.exports = function (p, g) {
                return (p = p.toLowerCase()) === 'rmd160' || p === 'ripemd160'
                  ? new h('rmd160', g)
                  : p === 'md5'
                    ? new o(c, g)
                    : new h(p, g)
              }))
          },
          {
            './legacy': 389,
            'cipher-base': 221,
            'create-hash/md5': 387,
            inherits: 440,
            ripemd160: 493,
            'safe-buffer': 494,
            'sha.js': 498,
          },
        ],
        389: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('safe-buffer').Buffer,
              a = t('cipher-base'),
              l = o.alloc(128)
            function c(u, f) {
              ;(a.call(this, 'digest'),
                typeof f == 'string' && (f = o.from(f)),
                (this._alg = u),
                (this._key = f),
                f.length > 64 ? (f = u(f)) : f.length < 64 && (f = o.concat([f, l], 64)))
              for (
                var d = (this._ipad = o.allocUnsafe(64)),
                  h = (this._opad = o.allocUnsafe(64)),
                  p = 0;
                p < 64;
                p++
              )
                ((d[p] = 54 ^ f[p]), (h[p] = 92 ^ f[p]))
              this._hash = [d]
            }
            ;(s(c, a),
              (c.prototype._update = function (u) {
                this._hash.push(u)
              }),
              (c.prototype._final = function () {
                var u = this._alg(o.concat(this._hash))
                return this._alg(o.concat([this._opad, u]))
              }),
              (r.exports = c))
          },
          { 'cipher-base': 221, inherits: 440, 'safe-buffer': 494 },
        ],
        390: [
          function (t, r, i) {
            ;((i.randomBytes = i.rng = i.pseudoRandomBytes = i.prng = t('randombytes')),
              (i.createHash = i.Hash = t('create-hash')),
              (i.createHmac = i.Hmac = t('create-hmac')))
            var s = t('browserify-sign/algos'),
              o = Object.keys(s),
              a = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(o)
            i.getHashes = function () {
              return a
            }
            var l = t('pbkdf2')
            ;((i.pbkdf2 = l.pbkdf2), (i.pbkdf2Sync = l.pbkdf2Sync))
            var c = t('browserify-cipher')
            ;((i.Cipher = c.Cipher),
              (i.createCipher = c.createCipher),
              (i.Cipheriv = c.Cipheriv),
              (i.createCipheriv = c.createCipheriv),
              (i.Decipher = c.Decipher),
              (i.createDecipher = c.createDecipher),
              (i.Decipheriv = c.Decipheriv),
              (i.createDecipheriv = c.createDecipheriv),
              (i.getCiphers = c.getCiphers),
              (i.listCiphers = c.listCiphers))
            var u = t('diffie-hellman')
            ;((i.DiffieHellmanGroup = u.DiffieHellmanGroup),
              (i.createDiffieHellmanGroup = u.createDiffieHellmanGroup),
              (i.getDiffieHellman = u.getDiffieHellman),
              (i.createDiffieHellman = u.createDiffieHellman),
              (i.DiffieHellman = u.DiffieHellman))
            var f = t('browserify-sign')
            ;((i.createSign = f.createSign),
              (i.Sign = f.Sign),
              (i.createVerify = f.createVerify),
              (i.Verify = f.Verify),
              (i.createECDH = t('create-ecdh')))
            var d = t('public-encrypt')
            ;((i.publicEncrypt = d.publicEncrypt),
              (i.privateEncrypt = d.privateEncrypt),
              (i.publicDecrypt = d.publicDecrypt),
              (i.privateDecrypt = d.privateDecrypt))
            var h = t('randomfill')
            ;((i.randomFill = h.randomFill),
              (i.randomFillSync = h.randomFillSync),
              (i.createCredentials = function () {
                throw new Error(
                  [
                    'sorry, createCredentials is not implemented yet',
                    'we accept pull requests',
                    'https://github.com/crypto-browserify/crypto-browserify',
                  ].join(`
`),
                )
              }),
              (i.constants = {
                DH_CHECK_P_NOT_SAFE_PRIME: 2,
                DH_CHECK_P_NOT_PRIME: 1,
                DH_UNABLE_TO_CHECK_GENERATOR: 4,
                DH_NOT_SUITABLE_GENERATOR: 8,
                NPN_ENABLED: 1,
                ALPN_ENABLED: 1,
                RSA_PKCS1_PADDING: 1,
                RSA_SSLV23_PADDING: 2,
                RSA_NO_PADDING: 3,
                RSA_PKCS1_OAEP_PADDING: 4,
                RSA_X931_PADDING: 5,
                RSA_PKCS1_PSS_PADDING: 6,
                POINT_CONVERSION_COMPRESSED: 2,
                POINT_CONVERSION_UNCOMPRESSED: 4,
                POINT_CONVERSION_HYBRID: 6,
              }))
          },
          {
            'browserify-cipher': 206,
            'browserify-sign': 213,
            'browserify-sign/algos': 210,
            'create-ecdh': 384,
            'create-hash': 386,
            'create-hmac': 388,
            'diffie-hellman': 400,
            pbkdf2: 460,
            'public-encrypt': 468,
            randombytes: 475,
            randomfill: 476,
          },
        ],
        391: [
          function (t, r, i) {
            ;(function (s, o) {
              typeof i == 'object' && r !== void 0
                ? (r.exports = o())
                : ((s = typeof globalThis < 'u' ? globalThis : s || self).dayjs = o())
            })(void 0, function () {
              var s = 6e4,
                o = 36e5,
                a = 'millisecond',
                l = 'second',
                c = 'minute',
                u = 'hour',
                f = 'day',
                d = 'week',
                h = 'month',
                p = 'quarter',
                g = 'year',
                m = 'date',
                y = 'Invalid Date',
                b =
                  /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
                w =
                  /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
                C = {
                  name: 'en',
                  weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
                  months:
                    'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                      '_',
                    ),
                  ordinal: function (v) {
                    var x = ['th', 'st', 'nd', 'rd'],
                      _ = v % 100
                    return '[' + v + (x[(_ - 20) % 10] || x[_] || x[0]) + ']'
                  },
                },
                T = function (v, x, _) {
                  var S = String(v)
                  return !S || S.length >= x ? v : '' + Array(x + 1 - S.length).join(_) + v
                },
                I = {
                  s: T,
                  z: function (v) {
                    var x = -v.utcOffset(),
                      _ = Math.abs(x),
                      S = Math.floor(_ / 60),
                      A = _ % 60
                    return (x <= 0 ? '+' : '-') + T(S, 2, '0') + ':' + T(A, 2, '0')
                  },
                  m: function v(x, _) {
                    if (x.date() < _.date()) return -v(_, x)
                    var S = 12 * (_.year() - x.year()) + (_.month() - x.month()),
                      A = x.clone().add(S, h),
                      j = _ - A < 0,
                      L = x.clone().add(S + (j ? -1 : 1), h)
                    return +(-(S + (_ - A) / (j ? A - L : L - A)) || 0)
                  },
                  a: function (v) {
                    return v < 0 ? Math.ceil(v) || 0 : Math.floor(v)
                  },
                  p: function (v) {
                    return (
                      { M: h, y: g, w: d, d: f, D: m, h: u, m: c, s: l, ms: a, Q: p }[v] ||
                      String(v || '')
                        .toLowerCase()
                        .replace(/s$/, '')
                    )
                  },
                  u: function (v) {
                    return v === void 0
                  },
                },
                B = 'en',
                E = {}
              E[B] = C
              var O = '$isDayjsObject',
                P = function (v) {
                  return v instanceof R || !(!v || !v[O])
                },
                $ = function v(x, _, S) {
                  var A
                  if (!x) return B
                  if (typeof x == 'string') {
                    var j = x.toLowerCase()
                    ;(E[j] && (A = j), _ && ((E[j] = _), (A = j)))
                    var L = x.split('-')
                    if (!A && L.length > 1) return v(L[0])
                  } else {
                    var H = x.name
                    ;((E[H] = x), (A = H))
                  }
                  return (!S && A && (B = A), A || (!S && B))
                },
                F = function (v, x) {
                  if (P(v)) return v.clone()
                  var _ = typeof x == 'object' ? x : {}
                  return ((_.date = v), (_.args = arguments), new R(_))
                },
                M = I
              ;((M.l = $),
                (M.i = P),
                (M.w = function (v, x) {
                  return F(v, { locale: x.$L, utc: x.$u, x: x.$x, $offset: x.$offset })
                }))
              var R = (function () {
                  function v(_) {
                    ;((this.$L = $(_.locale, null, !0)),
                      this.parse(_),
                      (this.$x = this.$x || _.x || {}),
                      (this[O] = !0))
                  }
                  var x = v.prototype
                  return (
                    (x.parse = function (_) {
                      ;((this.$d = (function (S) {
                        var A = S.date,
                          j = S.utc
                        if (A === null) return new Date(NaN)
                        if (M.u(A)) return new Date()
                        if (A instanceof Date) return new Date(A)
                        if (typeof A == 'string' && !/Z$/i.test(A)) {
                          var L = A.match(b)
                          if (L) {
                            var H = L[2] - 1 || 0,
                              U = (L[7] || '0').substring(0, 3)
                            return j
                              ? new Date(
                                  Date.UTC(L[1], H, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, U),
                                )
                              : new Date(L[1], H, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, U)
                          }
                        }
                        return new Date(A)
                      })(_)),
                        this.init())
                    }),
                    (x.init = function () {
                      var _ = this.$d
                      ;((this.$y = _.getFullYear()),
                        (this.$M = _.getMonth()),
                        (this.$D = _.getDate()),
                        (this.$W = _.getDay()),
                        (this.$H = _.getHours()),
                        (this.$m = _.getMinutes()),
                        (this.$s = _.getSeconds()),
                        (this.$ms = _.getMilliseconds()))
                    }),
                    (x.$utils = function () {
                      return M
                    }),
                    (x.isValid = function () {
                      return this.$d.toString() !== y
                    }),
                    (x.isSame = function (_, S) {
                      var A = F(_)
                      return this.startOf(S) <= A && A <= this.endOf(S)
                    }),
                    (x.isAfter = function (_, S) {
                      return F(_) < this.startOf(S)
                    }),
                    (x.isBefore = function (_, S) {
                      return this.endOf(S) < F(_)
                    }),
                    (x.$g = function (_, S, A) {
                      return M.u(_) ? this[S] : this.set(A, _)
                    }),
                    (x.unix = function () {
                      return Math.floor(this.valueOf() / 1e3)
                    }),
                    (x.valueOf = function () {
                      return this.$d.getTime()
                    }),
                    (x.startOf = function (_, S) {
                      var A = this,
                        j = !!M.u(S) || S,
                        L = M.p(_),
                        H = function (W, J) {
                          var G = M.w(A.$u ? Date.UTC(A.$y, J, W) : new Date(A.$y, J, W), A)
                          return j ? G : G.endOf(f)
                        },
                        U = function (W, J) {
                          return M.w(
                            A.toDate()[W].apply(
                              A.toDate('s'),
                              (j ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(J),
                            ),
                            A,
                          )
                        },
                        K = this.$W,
                        z = this.$M,
                        q = this.$D,
                        D = 'set' + (this.$u ? 'UTC' : '')
                      switch (L) {
                        case g:
                          return j ? H(1, 0) : H(31, 11)
                        case h:
                          return j ? H(1, z) : H(0, z + 1)
                        case d:
                          var N = this.$locale().weekStart || 0,
                            V = (K < N ? K + 7 : K) - N
                          return H(j ? q - V : q + (6 - V), z)
                        case f:
                        case m:
                          return U(D + 'Hours', 0)
                        case u:
                          return U(D + 'Minutes', 1)
                        case c:
                          return U(D + 'Seconds', 2)
                        case l:
                          return U(D + 'Milliseconds', 3)
                        default:
                          return this.clone()
                      }
                    }),
                    (x.endOf = function (_) {
                      return this.startOf(_, !1)
                    }),
                    (x.$set = function (_, S) {
                      var A,
                        j = M.p(_),
                        L = 'set' + (this.$u ? 'UTC' : ''),
                        H = ((A = {}),
                        (A[f] = L + 'Date'),
                        (A[m] = L + 'Date'),
                        (A[h] = L + 'Month'),
                        (A[g] = L + 'FullYear'),
                        (A[u] = L + 'Hours'),
                        (A[c] = L + 'Minutes'),
                        (A[l] = L + 'Seconds'),
                        (A[a] = L + 'Milliseconds'),
                        A)[j],
                        U = j === f ? this.$D + (S - this.$W) : S
                      if (j === h || j === g) {
                        var K = this.clone().set(m, 1)
                        ;(K.$d[H](U),
                          K.init(),
                          (this.$d = K.set(m, Math.min(this.$D, K.daysInMonth())).$d))
                      } else H && this.$d[H](U)
                      return (this.init(), this)
                    }),
                    (x.set = function (_, S) {
                      return this.clone().$set(_, S)
                    }),
                    (x.get = function (_) {
                      return this[M.p(_)]()
                    }),
                    (x.add = function (_, S) {
                      var A,
                        j = this
                      _ = Number(_)
                      var L = M.p(S),
                        H = function (z) {
                          var q = F(j)
                          return M.w(q.date(q.date() + Math.round(z * _)), j)
                        }
                      if (L === h) return this.set(h, this.$M + _)
                      if (L === g) return this.set(g, this.$y + _)
                      if (L === f) return H(1)
                      if (L === d) return H(7)
                      var U = ((A = {}), (A[c] = s), (A[u] = o), (A[l] = 1e3), A)[L] || 1,
                        K = this.$d.getTime() + _ * U
                      return M.w(K, this)
                    }),
                    (x.subtract = function (_, S) {
                      return this.add(-1 * _, S)
                    }),
                    (x.format = function (_) {
                      var S = this,
                        A = this.$locale()
                      if (!this.isValid()) return A.invalidDate || y
                      var j = _ || 'YYYY-MM-DDTHH:mm:ssZ',
                        L = M.z(this),
                        H = this.$H,
                        U = this.$m,
                        K = this.$M,
                        z = A.weekdays,
                        q = A.months,
                        D = A.meridiem,
                        N = function (J, G, Z, rt) {
                          return (J && (J[G] || J(S, j))) || Z[G].slice(0, rt)
                        },
                        V = function (J) {
                          return M.s(H % 12 || 12, J, '0')
                        },
                        W =
                          D ||
                          function (J, G, Z) {
                            var rt = J < 12 ? 'AM' : 'PM'
                            return Z ? rt.toLowerCase() : rt
                          }
                      return j.replace(w, function (J, G) {
                        return (
                          G ||
                          (function (Z) {
                            switch (Z) {
                              case 'YY':
                                return String(S.$y).slice(-2)
                              case 'YYYY':
                                return M.s(S.$y, 4, '0')
                              case 'M':
                                return K + 1
                              case 'MM':
                                return M.s(K + 1, 2, '0')
                              case 'MMM':
                                return N(A.monthsShort, K, q, 3)
                              case 'MMMM':
                                return N(q, K)
                              case 'D':
                                return S.$D
                              case 'DD':
                                return M.s(S.$D, 2, '0')
                              case 'd':
                                return String(S.$W)
                              case 'dd':
                                return N(A.weekdaysMin, S.$W, z, 2)
                              case 'ddd':
                                return N(A.weekdaysShort, S.$W, z, 3)
                              case 'dddd':
                                return z[S.$W]
                              case 'H':
                                return String(H)
                              case 'HH':
                                return M.s(H, 2, '0')
                              case 'h':
                                return V(1)
                              case 'hh':
                                return V(2)
                              case 'a':
                                return W(H, U, !0)
                              case 'A':
                                return W(H, U, !1)
                              case 'm':
                                return String(U)
                              case 'mm':
                                return M.s(U, 2, '0')
                              case 's':
                                return String(S.$s)
                              case 'ss':
                                return M.s(S.$s, 2, '0')
                              case 'SSS':
                                return M.s(S.$ms, 3, '0')
                              case 'Z':
                                return L
                            }
                            return null
                          })(J) ||
                          L.replace(':', '')
                        )
                      })
                    }),
                    (x.utcOffset = function () {
                      return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                    }),
                    (x.diff = function (_, S, A) {
                      var j,
                        L = this,
                        H = M.p(S),
                        U = F(_),
                        K = (U.utcOffset() - this.utcOffset()) * s,
                        z = this - U,
                        q = function () {
                          return M.m(L, U)
                        }
                      switch (H) {
                        case g:
                          j = q() / 12
                          break
                        case h:
                          j = q()
                          break
                        case p:
                          j = q() / 3
                          break
                        case d:
                          j = (z - K) / 6048e5
                          break
                        case f:
                          j = (z - K) / 864e5
                          break
                        case u:
                          j = z / o
                          break
                        case c:
                          j = z / s
                          break
                        case l:
                          j = z / 1e3
                          break
                        default:
                          j = z
                      }
                      return A ? j : M.a(j)
                    }),
                    (x.daysInMonth = function () {
                      return this.endOf(h).$D
                    }),
                    (x.$locale = function () {
                      return E[this.$L]
                    }),
                    (x.locale = function (_, S) {
                      if (!_) return this.$L
                      var A = this.clone(),
                        j = $(_, S, !0)
                      return (j && (A.$L = j), A)
                    }),
                    (x.clone = function () {
                      return M.w(this.$d, this)
                    }),
                    (x.toDate = function () {
                      return new Date(this.valueOf())
                    }),
                    (x.toJSON = function () {
                      return this.isValid() ? this.toISOString() : null
                    }),
                    (x.toISOString = function () {
                      return this.$d.toISOString()
                    }),
                    (x.toString = function () {
                      return this.$d.toUTCString()
                    }),
                    v
                  )
                })(),
                k = R.prototype
              return (
                (F.prototype = k),
                [
                  ['$ms', a],
                  ['$s', l],
                  ['$m', c],
                  ['$H', u],
                  ['$W', f],
                  ['$M', h],
                  ['$y', g],
                  ['$D', m],
                ].forEach(function (v) {
                  k[v[1]] = function (x) {
                    return this.$g(x, v[0], v[1])
                  }
                }),
                (F.extend = function (v, x) {
                  return (v.$i || (v(x, R, F), (v.$i = !0)), F)
                }),
                (F.locale = $),
                (F.isDayjs = P),
                (F.unix = function (v) {
                  return F(1e3 * v)
                }),
                (F.en = E[B]),
                (F.Ls = E),
                (F.p = {}),
                F
              )
            })
          },
          {},
        ],
        392: [
          function (t, r, i) {
            ;(function (s, o) {
              typeof i == 'object' && r !== void 0
                ? (r.exports = o())
                : ((s =
                    typeof globalThis < 'u'
                      ? globalThis
                      : s || self).dayjs_plugin_customParseFormat = o())
            })(void 0, function () {
              var s = {
                  LTS: 'h:mm:ss A',
                  LT: 'h:mm A',
                  L: 'MM/DD/YYYY',
                  LL: 'MMMM D, YYYY',
                  LLL: 'MMMM D, YYYY h:mm A',
                  LLLL: 'dddd, MMMM D, YYYY h:mm A',
                },
                o =
                  /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
                a = /\d\d/,
                l = /\d\d?/,
                c = /\d*[^-_:/,()\s\d]+/,
                u = {},
                f = function (b) {
                  return (b = +b) + (b > 68 ? 1900 : 2e3)
                },
                d = function (b) {
                  return function (w) {
                    this[b] = +w
                  }
                },
                h = [
                  /[+-]\d\d:?(\d\d)?|Z/,
                  function (b) {
                    ;(this.zone || (this.zone = {})).offset = (function (w) {
                      if (!w || w === 'Z') return 0
                      var C = w.match(/([+-]|\d\d)/g),
                        T = 60 * C[1] + (+C[2] || 0)
                      return T === 0 ? 0 : C[0] === '+' ? -T : T
                    })(b)
                  },
                ],
                p = function (b) {
                  var w = u[b]
                  return w && (w.indexOf ? w : w.s.concat(w.f))
                },
                g = function (b, w) {
                  var C,
                    T = u.meridiem
                  if (T) {
                    for (var I = 1; I <= 24; I += 1)
                      if (b.indexOf(T(I, 0, w)) > -1) {
                        C = I > 12
                        break
                      }
                  } else C = b === (w ? 'pm' : 'PM')
                  return C
                },
                m = {
                  A: [
                    c,
                    function (b) {
                      this.afternoon = g(b, !1)
                    },
                  ],
                  a: [
                    c,
                    function (b) {
                      this.afternoon = g(b, !0)
                    },
                  ],
                  S: [
                    /\d/,
                    function (b) {
                      this.milliseconds = 100 * +b
                    },
                  ],
                  SS: [
                    a,
                    function (b) {
                      this.milliseconds = 10 * +b
                    },
                  ],
                  SSS: [
                    /\d{3}/,
                    function (b) {
                      this.milliseconds = +b
                    },
                  ],
                  s: [l, d('seconds')],
                  ss: [l, d('seconds')],
                  m: [l, d('minutes')],
                  mm: [l, d('minutes')],
                  H: [l, d('hours')],
                  h: [l, d('hours')],
                  HH: [l, d('hours')],
                  hh: [l, d('hours')],
                  D: [l, d('day')],
                  DD: [a, d('day')],
                  Do: [
                    c,
                    function (b) {
                      var w = u.ordinal,
                        C = b.match(/\d+/)
                      if (((this.day = C[0]), w))
                        for (var T = 1; T <= 31; T += 1)
                          w(T).replace(/\[|\]/g, '') === b && (this.day = T)
                    },
                  ],
                  M: [l, d('month')],
                  MM: [a, d('month')],
                  MMM: [
                    c,
                    function (b) {
                      var w = p('months'),
                        C =
                          (
                            p('monthsShort') ||
                            w.map(function (T) {
                              return T.slice(0, 3)
                            })
                          ).indexOf(b) + 1
                      if (C < 1) throw new Error()
                      this.month = C % 12 || C
                    },
                  ],
                  MMMM: [
                    c,
                    function (b) {
                      var w = p('months').indexOf(b) + 1
                      if (w < 1) throw new Error()
                      this.month = w % 12 || w
                    },
                  ],
                  Y: [/[+-]?\d+/, d('year')],
                  YY: [
                    a,
                    function (b) {
                      this.year = f(b)
                    },
                  ],
                  YYYY: [/\d{4}/, d('year')],
                  Z: h,
                  ZZ: h,
                }
              function y(b) {
                var w, C
                ;((w = b), (C = u && u.formats))
                for (
                  var T = (b = w.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (F, M, R) {
                      var k = R && R.toUpperCase()
                      return (
                        M ||
                        C[R] ||
                        s[R] ||
                        C[k].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (v, x, _) {
                          return x || _.slice(1)
                        })
                      )
                    })).match(o),
                    I = T.length,
                    B = 0;
                  B < I;
                  B += 1
                ) {
                  var E = T[B],
                    O = m[E],
                    P = O && O[0],
                    $ = O && O[1]
                  T[B] = $ ? { regex: P, parser: $ } : E.replace(/^\[|\]$/g, '')
                }
                return function (F) {
                  for (var M = {}, R = 0, k = 0; R < I; R += 1) {
                    var v = T[R]
                    if (typeof v == 'string') k += v.length
                    else {
                      var x = v.regex,
                        _ = v.parser,
                        S = F.slice(k),
                        A = x.exec(S)[0]
                      ;(_.call(M, A), (F = F.replace(A, '')))
                    }
                  }
                  return (
                    (function (j) {
                      var L = j.afternoon
                      if (L !== void 0) {
                        var H = j.hours
                        ;(L ? H < 12 && (j.hours += 12) : H === 12 && (j.hours = 0),
                          delete j.afternoon)
                      }
                    })(M),
                    M
                  )
                }
              }
              return function (b, w, C) {
                ;((C.p.customParseFormat = !0),
                  b && b.parseTwoDigitYear && (f = b.parseTwoDigitYear))
                var T = w.prototype,
                  I = T.parse
                T.parse = function (B) {
                  var E = B.date,
                    O = B.utc,
                    P = B.args
                  this.$u = O
                  var $ = P[1]
                  if (typeof $ == 'string') {
                    var F = P[2] === !0,
                      M = P[3] === !0,
                      R = F || M,
                      k = P[2]
                    ;(M && (k = P[2]),
                      (u = this.$locale()),
                      !F && k && (u = C.Ls[k]),
                      (this.$d = (function (S, A, j) {
                        try {
                          if (['x', 'X'].indexOf(A) > -1) return new Date((A === 'X' ? 1e3 : 1) * S)
                          var L = y(A)(S),
                            H = L.year,
                            U = L.month,
                            K = L.day,
                            z = L.hours,
                            q = L.minutes,
                            D = L.seconds,
                            N = L.milliseconds,
                            V = L.zone,
                            W = new Date(),
                            J = K || (H || U ? 1 : W.getDate()),
                            G = H || W.getFullYear(),
                            Z = 0
                          ;(H && !U) || (Z = U > 0 ? U - 1 : W.getMonth())
                          var rt = z || 0,
                            nt = q || 0,
                            X = D || 0,
                            Q = N || 0
                          return V
                            ? new Date(Date.UTC(G, Z, J, rt, nt, X, Q + 60 * V.offset * 1e3))
                            : j
                              ? new Date(Date.UTC(G, Z, J, rt, nt, X, Q))
                              : new Date(G, Z, J, rt, nt, X, Q)
                        } catch {
                          return new Date('')
                        }
                      })(E, $, O)),
                      this.init(),
                      k && k !== !0 && (this.$L = this.locale(k).$L),
                      R && E != this.format($) && (this.$d = new Date('')),
                      (u = {}))
                  } else if ($ instanceof Array)
                    for (var v = $.length, x = 1; x <= v; x += 1) {
                      P[1] = $[x - 1]
                      var _ = C.apply(this, P)
                      if (_.isValid()) {
                        ;((this.$d = _.$d), (this.$L = _.$L), this.init())
                        break
                      }
                      x === v && (this.$d = new Date(''))
                    }
                  else I.call(this, B)
                }
              }
            })
          },
          {},
        ],
        393: [
          function (t, r, i) {
            ;(function (s, o) {
              typeof i == 'object' && r !== void 0
                ? (r.exports = o())
                : ((s = typeof globalThis < 'u' ? globalThis : s || self).dayjs_plugin_utc = o())
            })(void 0, function () {
              var s = 'minute',
                o = /[+-]\d\d(?::?\d\d)?/g,
                a = /([+-]|\d\d)/g
              return function (l, c, u) {
                var f = c.prototype
                ;((u.utc = function (b) {
                  var w = { date: b, utc: !0, args: arguments }
                  return new c(w)
                }),
                  (f.utc = function (b) {
                    var w = u(this.toDate(), { locale: this.$L, utc: !0 })
                    return b ? w.add(this.utcOffset(), s) : w
                  }),
                  (f.local = function () {
                    return u(this.toDate(), { locale: this.$L, utc: !1 })
                  }))
                var d = f.parse
                f.parse = function (b) {
                  ;(b.utc && (this.$u = !0),
                    this.$utils().u(b.$offset) || (this.$offset = b.$offset),
                    d.call(this, b))
                }
                var h = f.init
                f.init = function () {
                  if (this.$u) {
                    var b = this.$d
                    ;((this.$y = b.getUTCFullYear()),
                      (this.$M = b.getUTCMonth()),
                      (this.$D = b.getUTCDate()),
                      (this.$W = b.getUTCDay()),
                      (this.$H = b.getUTCHours()),
                      (this.$m = b.getUTCMinutes()),
                      (this.$s = b.getUTCSeconds()),
                      (this.$ms = b.getUTCMilliseconds()))
                  } else h.call(this)
                }
                var p = f.utcOffset
                f.utcOffset = function (b, w) {
                  var C = this.$utils().u
                  if (C(b)) return this.$u ? 0 : C(this.$offset) ? p.call(this) : this.$offset
                  if (
                    typeof b == 'string' &&
                    (b = (function (E) {
                      E === void 0 && (E = '')
                      var O = E.match(o)
                      if (!O) return null
                      var P = ('' + O[0]).match(a) || ['-', 0, 0],
                        $ = P[0],
                        F = 60 * +P[1] + +P[2]
                      return F === 0 ? 0 : $ === '+' ? F : -F
                    })(b)) === null
                  )
                    return this
                  var T = Math.abs(b) <= 16 ? 60 * b : b,
                    I = this
                  if (w) return ((I.$offset = T), (I.$u = b === 0), I)
                  if (b !== 0) {
                    var B = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset()
                    ;(((I = this.local().add(T + B, s)).$offset = T), (I.$x.$localOffset = B))
                  } else I = this.utc()
                  return I
                }
                var g = f.format
                ;((f.format = function (b) {
                  var w = b || (this.$u ? 'YYYY-MM-DDTHH:mm:ss[Z]' : '')
                  return g.call(this, w)
                }),
                  (f.valueOf = function () {
                    var b = this.$utils().u(this.$offset)
                      ? 0
                      : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset())
                    return this.$d.valueOf() - 6e4 * b
                  }),
                  (f.isUTC = function () {
                    return !!this.$u
                  }),
                  (f.toISOString = function () {
                    return this.toDate().toISOString()
                  }),
                  (f.toString = function () {
                    return this.toDate().toUTCString()
                  }))
                var m = f.toDate
                f.toDate = function (b) {
                  return b === 's' && this.$offset
                    ? u(this.format('YYYY-MM-DD HH:mm:ss:SSS')).toDate()
                    : m.call(this)
                }
                var y = f.diff
                f.diff = function (b, w, C) {
                  if (b && this.$u === b.$u) return y.call(this, b, w, C)
                  var T = this.local(),
                    I = u(b).local()
                  return y.call(T, I, w, C)
                }
              }
            })
          },
          {},
        ],
        394: [
          function (t, r, i) {
            ;((i.utils = t('./des/utils')),
              (i.Cipher = t('./des/cipher')),
              (i.DES = t('./des/des')),
              (i.CBC = t('./des/cbc')),
              (i.EDE = t('./des/ede')))
          },
          {
            './des/cbc': 395,
            './des/cipher': 396,
            './des/des': 397,
            './des/ede': 398,
            './des/utils': 399,
          },
        ],
        395: [
          function (t, r, i) {
            var s = t('minimalistic-assert'),
              o = t('inherits'),
              a = {}
            function l(c) {
              ;(s.equal(c.length, 8, 'Invalid IV length'), (this.iv = new Array(8)))
              for (var u = 0; u < this.iv.length; u++) this.iv[u] = c[u]
            }
            ;((i.instantiate = function (c) {
              function u(p) {
                ;(c.call(this, p), this._cbcInit())
              }
              o(u, c)
              for (var f = Object.keys(a), d = 0; d < f.length; d++) {
                var h = f[d]
                u.prototype[h] = a[h]
              }
              return (
                (u.create = function (p) {
                  return new u(p)
                }),
                u
              )
            }),
              (a._cbcInit = function () {
                var c = new l(this.options.iv)
                this._cbcState = c
              }),
              (a._update = function (c, u, f, d) {
                var h = this._cbcState,
                  p = this.constructor.super_.prototype,
                  g = h.iv
                if (this.type === 'encrypt') {
                  for (var m = 0; m < this.blockSize; m++) g[m] ^= c[u + m]
                  for (p._update.call(this, g, 0, f, d), m = 0; m < this.blockSize; m++)
                    g[m] = f[d + m]
                } else {
                  for (p._update.call(this, c, u, f, d), m = 0; m < this.blockSize; m++)
                    f[d + m] ^= g[m]
                  for (m = 0; m < this.blockSize; m++) g[m] = c[u + m]
                }
              }))
          },
          { inherits: 440, 'minimalistic-assert': 453 },
        ],
        396: [
          function (t, r, i) {
            var s = t('minimalistic-assert')
            function o(a) {
              ;((this.options = a),
                (this.type = this.options.type),
                (this.blockSize = 8),
                this._init(),
                (this.buffer = new Array(this.blockSize)),
                (this.bufferOff = 0),
                (this.padding = a.padding !== !1))
            }
            ;((r.exports = o),
              (o.prototype._init = function () {}),
              (o.prototype.update = function (a) {
                return a.length === 0
                  ? []
                  : this.type === 'decrypt'
                    ? this._updateDecrypt(a)
                    : this._updateEncrypt(a)
              }),
              (o.prototype._buffer = function (a, l) {
                for (
                  var c = Math.min(this.buffer.length - this.bufferOff, a.length - l), u = 0;
                  u < c;
                  u++
                )
                  this.buffer[this.bufferOff + u] = a[l + u]
                return ((this.bufferOff += c), c)
              }),
              (o.prototype._flushBuffer = function (a, l) {
                return (this._update(this.buffer, 0, a, l), (this.bufferOff = 0), this.blockSize)
              }),
              (o.prototype._updateEncrypt = function (a) {
                var l = 0,
                  c = 0,
                  u = ((this.bufferOff + a.length) / this.blockSize) | 0,
                  f = new Array(u * this.blockSize)
                this.bufferOff !== 0 &&
                  ((l += this._buffer(a, l)),
                  this.bufferOff === this.buffer.length && (c += this._flushBuffer(f, c)))
                for (
                  var d = a.length - ((a.length - l) % this.blockSize);
                  l < d;
                  l += this.blockSize
                )
                  (this._update(a, l, f, c), (c += this.blockSize))
                for (; l < a.length; l++, this.bufferOff++) this.buffer[this.bufferOff] = a[l]
                return f
              }),
              (o.prototype._updateDecrypt = function (a) {
                for (
                  var l = 0,
                    c = 0,
                    u = Math.ceil((this.bufferOff + a.length) / this.blockSize) - 1,
                    f = new Array(u * this.blockSize);
                  u > 0;
                  u--
                )
                  ((l += this._buffer(a, l)), (c += this._flushBuffer(f, c)))
                return ((l += this._buffer(a, l)), f)
              }),
              (o.prototype.final = function (a) {
                var l, c
                return (
                  a && (l = this.update(a)),
                  (c = this.type === 'encrypt' ? this._finalEncrypt() : this._finalDecrypt()),
                  l ? l.concat(c) : c
                )
              }),
              (o.prototype._pad = function (a, l) {
                if (l === 0) return !1
                for (; l < a.length; ) a[l++] = 0
                return !0
              }),
              (o.prototype._finalEncrypt = function () {
                if (!this._pad(this.buffer, this.bufferOff)) return []
                var a = new Array(this.blockSize)
                return (this._update(this.buffer, 0, a, 0), a)
              }),
              (o.prototype._unpad = function (a) {
                return a
              }),
              (o.prototype._finalDecrypt = function () {
                s.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt')
                var a = new Array(this.blockSize)
                return (this._flushBuffer(a, 0), this._unpad(a))
              }))
          },
          { 'minimalistic-assert': 453 },
        ],
        397: [
          function (t, r, i) {
            var s = t('minimalistic-assert'),
              o = t('inherits'),
              a = t('./utils'),
              l = t('./cipher')
            function c() {
              ;((this.tmp = new Array(2)), (this.keys = null))
            }
            function u(d) {
              l.call(this, d)
              var h = new c()
              ;((this._desState = h), this.deriveKeys(h, d.key))
            }
            ;(o(u, l),
              (r.exports = u),
              (u.create = function (d) {
                return new u(d)
              }))
            var f = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
            ;((u.prototype.deriveKeys = function (d, h) {
              ;((d.keys = new Array(32)), s.equal(h.length, this.blockSize, 'Invalid key length'))
              var p = a.readUInt32BE(h, 0),
                g = a.readUInt32BE(h, 4)
              ;(a.pc1(p, g, d.tmp, 0), (p = d.tmp[0]), (g = d.tmp[1]))
              for (var m = 0; m < d.keys.length; m += 2) {
                var y = f[m >>> 1]
                ;((p = a.r28shl(p, y)), (g = a.r28shl(g, y)), a.pc2(p, g, d.keys, m))
              }
            }),
              (u.prototype._update = function (d, h, p, g) {
                var m = this._desState,
                  y = a.readUInt32BE(d, h),
                  b = a.readUInt32BE(d, h + 4)
                ;(a.ip(y, b, m.tmp, 0),
                  (y = m.tmp[0]),
                  (b = m.tmp[1]),
                  this.type === 'encrypt'
                    ? this._encrypt(m, y, b, m.tmp, 0)
                    : this._decrypt(m, y, b, m.tmp, 0),
                  (y = m.tmp[0]),
                  (b = m.tmp[1]),
                  a.writeUInt32BE(p, y, g),
                  a.writeUInt32BE(p, b, g + 4))
              }),
              (u.prototype._pad = function (d, h) {
                if (this.padding === !1) return !1
                for (var p = d.length - h, g = h; g < d.length; g++) d[g] = p
                return !0
              }),
              (u.prototype._unpad = function (d) {
                if (this.padding === !1) return d
                for (var h = d[d.length - 1], p = d.length - h; p < d.length; p++) s.equal(d[p], h)
                return d.slice(0, d.length - h)
              }),
              (u.prototype._encrypt = function (d, h, p, g, m) {
                for (var y = h, b = p, w = 0; w < d.keys.length; w += 2) {
                  var C = d.keys[w],
                    T = d.keys[w + 1]
                  ;(a.expand(b, d.tmp, 0), (C ^= d.tmp[0]), (T ^= d.tmp[1]))
                  var I = a.substitute(C, T),
                    B = b
                  ;((b = (y ^ a.permute(I)) >>> 0), (y = B))
                }
                a.rip(b, y, g, m)
              }),
              (u.prototype._decrypt = function (d, h, p, g, m) {
                for (var y = p, b = h, w = d.keys.length - 2; w >= 0; w -= 2) {
                  var C = d.keys[w],
                    T = d.keys[w + 1]
                  ;(a.expand(y, d.tmp, 0), (C ^= d.tmp[0]), (T ^= d.tmp[1]))
                  var I = a.substitute(C, T),
                    B = y
                  ;((y = (b ^ a.permute(I)) >>> 0), (b = B))
                }
                a.rip(y, b, g, m)
              }))
          },
          { './cipher': 396, './utils': 399, inherits: 440, 'minimalistic-assert': 453 },
        ],
        398: [
          function (t, r, i) {
            var s = t('minimalistic-assert'),
              o = t('inherits'),
              a = t('./cipher'),
              l = t('./des')
            function c(f, d) {
              s.equal(d.length, 24, 'Invalid key length')
              var h = d.slice(0, 8),
                p = d.slice(8, 16),
                g = d.slice(16, 24)
              this.ciphers =
                f === 'encrypt'
                  ? [
                      l.create({ type: 'encrypt', key: h }),
                      l.create({ type: 'decrypt', key: p }),
                      l.create({ type: 'encrypt', key: g }),
                    ]
                  : [
                      l.create({ type: 'decrypt', key: g }),
                      l.create({ type: 'encrypt', key: p }),
                      l.create({ type: 'decrypt', key: h }),
                    ]
            }
            function u(f) {
              a.call(this, f)
              var d = new c(this.type, this.options.key)
              this._edeState = d
            }
            ;(o(u, a),
              (r.exports = u),
              (u.create = function (f) {
                return new u(f)
              }),
              (u.prototype._update = function (f, d, h, p) {
                var g = this._edeState
                ;(g.ciphers[0]._update(f, d, h, p),
                  g.ciphers[1]._update(h, p, h, p),
                  g.ciphers[2]._update(h, p, h, p))
              }),
              (u.prototype._pad = l.prototype._pad),
              (u.prototype._unpad = l.prototype._unpad))
          },
          { './cipher': 396, './des': 397, inherits: 440, 'minimalistic-assert': 453 },
        ],
        399: [
          function (t, r, i) {
            ;((i.readUInt32BE = function (l, c) {
              return ((l[0 + c] << 24) | (l[1 + c] << 16) | (l[2 + c] << 8) | l[3 + c]) >>> 0
            }),
              (i.writeUInt32BE = function (l, c, u) {
                ;((l[0 + u] = c >>> 24),
                  (l[1 + u] = (c >>> 16) & 255),
                  (l[2 + u] = (c >>> 8) & 255),
                  (l[3 + u] = 255 & c))
              }),
              (i.ip = function (l, c, u, f) {
                for (var d = 0, h = 0, p = 6; p >= 0; p -= 2) {
                  for (var g = 0; g <= 24; g += 8) ((d <<= 1), (d |= (c >>> (g + p)) & 1))
                  for (g = 0; g <= 24; g += 8) ((d <<= 1), (d |= (l >>> (g + p)) & 1))
                }
                for (p = 6; p >= 0; p -= 2) {
                  for (g = 1; g <= 25; g += 8) ((h <<= 1), (h |= (c >>> (g + p)) & 1))
                  for (g = 1; g <= 25; g += 8) ((h <<= 1), (h |= (l >>> (g + p)) & 1))
                }
                ;((u[f + 0] = d >>> 0), (u[f + 1] = h >>> 0))
              }),
              (i.rip = function (l, c, u, f) {
                for (var d = 0, h = 0, p = 0; p < 4; p++)
                  for (var g = 24; g >= 0; g -= 8)
                    ((d <<= 1), (d |= (c >>> (g + p)) & 1), (d <<= 1), (d |= (l >>> (g + p)) & 1))
                for (p = 4; p < 8; p++)
                  for (g = 24; g >= 0; g -= 8)
                    ((h <<= 1), (h |= (c >>> (g + p)) & 1), (h <<= 1), (h |= (l >>> (g + p)) & 1))
                ;((u[f + 0] = d >>> 0), (u[f + 1] = h >>> 0))
              }),
              (i.pc1 = function (l, c, u, f) {
                for (var d = 0, h = 0, p = 7; p >= 5; p--) {
                  for (var g = 0; g <= 24; g += 8) ((d <<= 1), (d |= (c >> (g + p)) & 1))
                  for (g = 0; g <= 24; g += 8) ((d <<= 1), (d |= (l >> (g + p)) & 1))
                }
                for (g = 0; g <= 24; g += 8) ((d <<= 1), (d |= (c >> (g + p)) & 1))
                for (p = 1; p <= 3; p++) {
                  for (g = 0; g <= 24; g += 8) ((h <<= 1), (h |= (c >> (g + p)) & 1))
                  for (g = 0; g <= 24; g += 8) ((h <<= 1), (h |= (l >> (g + p)) & 1))
                }
                for (g = 0; g <= 24; g += 8) ((h <<= 1), (h |= (l >> (g + p)) & 1))
                ;((u[f + 0] = d >>> 0), (u[f + 1] = h >>> 0))
              }),
              (i.r28shl = function (l, c) {
                return ((l << c) & 268435455) | (l >>> (28 - c))
              }))
            var s = [
              14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15,
              26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27,
              24,
            ]
            ;((i.pc2 = function (l, c, u, f) {
              for (var d = 0, h = 0, p = s.length >>> 1, g = 0; g < p; g++)
                ((d <<= 1), (d |= (l >>> s[g]) & 1))
              for (g = p; g < s.length; g++) ((h <<= 1), (h |= (c >>> s[g]) & 1))
              ;((u[f + 0] = d >>> 0), (u[f + 1] = h >>> 0))
            }),
              (i.expand = function (l, c, u) {
                var f = 0,
                  d = 0
                f = ((1 & l) << 5) | (l >>> 27)
                for (var h = 23; h >= 15; h -= 4) ((f <<= 6), (f |= (l >>> h) & 63))
                for (h = 11; h >= 3; h -= 4) ((d |= (l >>> h) & 63), (d <<= 6))
                ;((d |= ((31 & l) << 1) | (l >>> 31)), (c[u + 0] = f >>> 0), (c[u + 1] = d >>> 0))
              }))
            var o = [
              14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5,
              9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12,
              11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2,
              3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7,
              10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14,
              15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14,
              11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4,
              1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6,
              15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15,
              9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2,
              4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15,
              10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
              15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9,
              7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14,
              3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0,
              11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9,
              5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10,
              14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8,
              6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2,
              11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3,
              5, 5, 6, 8, 11,
            ]
            i.substitute = function (l, c) {
              for (var u = 0, f = 0; f < 4; f++)
                ((u <<= 4), (u |= o[64 * f + ((l >>> (18 - 6 * f)) & 63)]))
              for (f = 0; f < 4; f++)
                ((u <<= 4), (u |= o[256 + 64 * f + ((c >>> (18 - 6 * f)) & 63)]))
              return u >>> 0
            }
            var a = [
              16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29,
              23, 13, 19, 2, 26, 10, 21, 28, 7,
            ]
            ;((i.permute = function (l) {
              for (var c = 0, u = 0; u < a.length; u++) ((c <<= 1), (c |= (l >>> a[u]) & 1))
              return c >>> 0
            }),
              (i.padSplit = function (l, c, u) {
                for (var f = l.toString(2); f.length < c; ) f = '0' + f
                for (var d = [], h = 0; h < c; h += u) d.push(f.slice(h, h + u))
                return d.join(' ')
              }))
          },
          {},
        ],
        400: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = t('./lib/generatePrime'),
                  a = t('./lib/primes.json'),
                  l = t('./lib/dh'),
                  c = { binary: !0, hex: !0, base64: !0 }
                ;((i.DiffieHellmanGroup =
                  i.createDiffieHellmanGroup =
                  i.getDiffieHellman =
                    function (u) {
                      var f = new s(a[u].prime, 'hex'),
                        d = new s(a[u].gen, 'hex')
                      return new l(f, d)
                    }),
                  (i.createDiffieHellman = i.DiffieHellman =
                    function u(f, d, h, p) {
                      return s.isBuffer(d) || c[d] === void 0
                        ? u(f, 'binary', d, h)
                        : ((d = d || 'binary'),
                          (p = p || 'binary'),
                          (h = h || new s([2])),
                          s.isBuffer(h) || (h = new s(h, p)),
                          typeof f == 'number'
                            ? new l(o(f, h), h, !0)
                            : (s.isBuffer(f) || (f = new s(f, d)), new l(f, h, !0)))
                    }))
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          { './lib/dh': 401, './lib/generatePrime': 402, './lib/primes.json': 403, buffer: 220 },
        ],
        401: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = t('bn.js'),
                  a = new (t('miller-rabin'))(),
                  l = new o(24),
                  c = new o(11),
                  u = new o(10),
                  f = new o(3),
                  d = new o(7),
                  h = t('./generatePrime'),
                  p = t('randombytes')
                function g(C, T) {
                  return (
                    (T = T || 'utf8'),
                    s.isBuffer(C) || (C = new s(C, T)),
                    (this._pub = new o(C)),
                    this
                  )
                }
                function m(C, T) {
                  return (
                    (T = T || 'utf8'),
                    s.isBuffer(C) || (C = new s(C, T)),
                    (this._priv = new o(C)),
                    this
                  )
                }
                r.exports = b
                var y = {}
                function b(C, T, I) {
                  ;(this.setGenerator(T),
                    (this.__prime = new o(C)),
                    (this._prime = o.mont(this.__prime)),
                    (this._primeLen = C.length),
                    (this._pub = void 0),
                    (this._priv = void 0),
                    (this._primeCode = void 0),
                    I ? ((this.setPublicKey = g), (this.setPrivateKey = m)) : (this._primeCode = 8))
                }
                function w(C, T) {
                  var I = new s(C.toArray())
                  return T ? I.toString(T) : I
                }
                ;(Object.defineProperty(b.prototype, 'verifyError', {
                  enumerable: !0,
                  get: function () {
                    return (
                      typeof this._primeCode != 'number' &&
                        (this._primeCode = (function (C, T) {
                          var I = T.toString('hex'),
                            B = [I, C.toString(16)].join('_')
                          if (B in y) return y[B]
                          var E,
                            O = 0
                          if (C.isEven() || !h.simpleSieve || !h.fermatTest(C) || !a.test(C))
                            return (
                              (O += 1),
                              (O += I === '02' || I === '05' ? 8 : 4),
                              (y[B] = O),
                              O
                            )
                          switch ((a.test(C.shrn(1)) || (O += 2), I)) {
                            case '02':
                              C.mod(l).cmp(c) && (O += 8)
                              break
                            case '05':
                              ;(E = C.mod(u)).cmp(f) && E.cmp(d) && (O += 8)
                              break
                            default:
                              O += 4
                          }
                          return ((y[B] = O), O)
                        })(this.__prime, this.__gen)),
                      this._primeCode
                    )
                  },
                }),
                  (b.prototype.generateKeys = function () {
                    return (
                      this._priv || (this._priv = new o(p(this._primeLen))),
                      (this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed()),
                      this.getPublicKey()
                    )
                  }),
                  (b.prototype.computeSecret = function (C) {
                    var T = (C = (C = new o(C)).toRed(this._prime)).redPow(this._priv).fromRed(),
                      I = new s(T.toArray()),
                      B = this.getPrime()
                    if (I.length < B.length) {
                      var E = new s(B.length - I.length)
                      ;(E.fill(0), (I = s.concat([E, I])))
                    }
                    return I
                  }),
                  (b.prototype.getPublicKey = function (C) {
                    return w(this._pub, C)
                  }),
                  (b.prototype.getPrivateKey = function (C) {
                    return w(this._priv, C)
                  }),
                  (b.prototype.getPrime = function (C) {
                    return w(this.__prime, C)
                  }),
                  (b.prototype.getGenerator = function (C) {
                    return w(this._gen, C)
                  }),
                  (b.prototype.setGenerator = function (C, T) {
                    return (
                      (T = T || 'utf8'),
                      s.isBuffer(C) || (C = new s(C, T)),
                      (this.__gen = C),
                      (this._gen = new o(C)),
                      this
                    )
                  }))
              }).call(this)
            }).call(this, t('buffer').Buffer)
          },
          {
            './generatePrime': 402,
            'bn.js': 404,
            buffer: 220,
            'miller-rabin': 451,
            randombytes: 475,
          },
        ],
        402: [
          function (t, r, i) {
            var s = t('randombytes')
            ;((r.exports = C), (C.simpleSieve = b), (C.fermatTest = w))
            var o = t('bn.js'),
              a = new o(24),
              l = new (t('miller-rabin'))(),
              c = new o(1),
              u = new o(2),
              f = new o(5),
              d = (new o(16), new o(8), new o(10)),
              h = new o(3),
              p = (new o(7), new o(11)),
              g = new o(4),
              m = (new o(12), null)
            function y() {
              if (m !== null) return m
              var T = []
              T[0] = 2
              for (var I = 1, B = 3; B < 1048576; B += 2) {
                for (
                  var E = Math.ceil(Math.sqrt(B)), O = 0;
                  O < I && T[O] <= E && B % T[O] != 0;
                  O++
                );
                ;(I !== O && T[O] <= E) || (T[I++] = B)
              }
              return ((m = T), T)
            }
            function b(T) {
              for (var I = y(), B = 0; B < I.length; B++)
                if (T.modn(I[B]) === 0) return T.cmpn(I[B]) === 0
              return !0
            }
            function w(T) {
              var I = o.mont(T)
              return u.toRed(I).redPow(T.subn(1)).fromRed().cmpn(1) === 0
            }
            function C(T, I) {
              if (T < 16) return new o(I === 2 || I === 5 ? [140, 123] : [140, 39])
              var B, E
              for (I = new o(I); ; ) {
                for (B = new o(s(Math.ceil(T / 8))); B.bitLength() > T; ) B.ishrn(1)
                if ((B.isEven() && B.iadd(c), B.testn(1) || B.iadd(u), I.cmp(u))) {
                  if (!I.cmp(f)) for (; B.mod(d).cmp(h); ) B.iadd(g)
                } else for (; B.mod(a).cmp(p); ) B.iadd(g)
                if (b((E = B.shrn(1))) && b(B) && w(E) && w(B) && l.test(E) && l.test(B)) return B
              }
            }
          },
          { 'bn.js': 404, 'miller-rabin': 451, randombytes: 475 },
        ],
        403: [
          function (t, r, i) {
            r.exports = {
              modp1: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff',
              },
              modp2: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff',
              },
              modp5: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff',
              },
              modp14: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff',
              },
              modp15: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff',
              },
              modp16: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff',
              },
              modp17: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff',
              },
              modp18: {
                gen: '02',
                prime:
                  'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff',
              },
            }
          },
          {},
        ],
        404: [
          function (t, r, i) {
            arguments[4][184][0].apply(i, arguments)
          },
          { buffer: 188, dup: 184 },
        ],
        405: [
          function (t, r, i) {
            var s = i
            ;((s.version = t('../package.json').version),
              (s.utils = t('./elliptic/utils')),
              (s.rand = t('brorand')),
              (s.curve = t('./elliptic/curve')),
              (s.curves = t('./elliptic/curves')),
              (s.ec = t('./elliptic/ec')),
              (s.eddsa = t('./elliptic/eddsa')))
          },
          {
            '../package.json': 421,
            './elliptic/curve': 408,
            './elliptic/curves': 411,
            './elliptic/ec': 412,
            './elliptic/eddsa': 415,
            './elliptic/utils': 419,
            brorand: 187,
          },
        ],
        406: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('../utils'),
              a = o.getNAF,
              l = o.getJSF,
              c = o.assert
            function u(d, h) {
              ;((this.type = d),
                (this.p = new s(h.p, 16)),
                (this.red = h.prime ? s.red(h.prime) : s.mont(this.p)),
                (this.zero = new s(0).toRed(this.red)),
                (this.one = new s(1).toRed(this.red)),
                (this.two = new s(2).toRed(this.red)),
                (this.n = h.n && new s(h.n, 16)),
                (this.g = h.g && this.pointFromJSON(h.g, h.gRed)),
                (this._wnafT1 = new Array(4)),
                (this._wnafT2 = new Array(4)),
                (this._wnafT3 = new Array(4)),
                (this._wnafT4 = new Array(4)),
                (this._bitLength = this.n ? this.n.bitLength() : 0))
              var p = this.n && this.p.div(this.n)
              !p || p.cmpn(100) > 0
                ? (this.redN = null)
                : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)))
            }
            function f(d, h) {
              ;((this.curve = d), (this.type = h), (this.precomputed = null))
            }
            ;((r.exports = u),
              (u.prototype.point = function () {
                throw new Error('Not implemented')
              }),
              (u.prototype.validate = function () {
                throw new Error('Not implemented')
              }),
              (u.prototype._fixedNafMul = function (d, h) {
                c(d.precomputed)
                var p = d._getDoubles(),
                  g = a(h, 1, this._bitLength),
                  m = (1 << (p.step + 1)) - (p.step % 2 == 0 ? 2 : 1)
                m /= 3
                var y,
                  b,
                  w = []
                for (y = 0; y < g.length; y += p.step) {
                  b = 0
                  for (var C = y + p.step - 1; C >= y; C--) b = (b << 1) + g[C]
                  w.push(b)
                }
                for (
                  var T = this.jpoint(null, null, null), I = this.jpoint(null, null, null), B = m;
                  B > 0;
                  B--
                ) {
                  for (y = 0; y < w.length; y++)
                    (b = w[y]) === B
                      ? (I = I.mixedAdd(p.points[y]))
                      : b === -B && (I = I.mixedAdd(p.points[y].neg()))
                  T = T.add(I)
                }
                return T.toP()
              }),
              (u.prototype._wnafMul = function (d, h) {
                var p = 4,
                  g = d._getNAFPoints(p)
                p = g.wnd
                for (
                  var m = g.points,
                    y = a(h, p, this._bitLength),
                    b = this.jpoint(null, null, null),
                    w = y.length - 1;
                  w >= 0;
                  w--
                ) {
                  for (var C = 0; w >= 0 && y[w] === 0; w--) C++
                  if ((w >= 0 && C++, (b = b.dblp(C)), w < 0)) break
                  var T = y[w]
                  ;(c(T !== 0),
                    (b =
                      d.type === 'affine'
                        ? T > 0
                          ? b.mixedAdd(m[(T - 1) >> 1])
                          : b.mixedAdd(m[(-T - 1) >> 1].neg())
                        : T > 0
                          ? b.add(m[(T - 1) >> 1])
                          : b.add(m[(-T - 1) >> 1].neg())))
                }
                return d.type === 'affine' ? b.toP() : b
              }),
              (u.prototype._wnafMulAdd = function (d, h, p, g, m) {
                var y,
                  b,
                  w,
                  C = this._wnafT1,
                  T = this._wnafT2,
                  I = this._wnafT3,
                  B = 0
                for (y = 0; y < g; y++) {
                  var E = (w = h[y])._getNAFPoints(d)
                  ;((C[y] = E.wnd), (T[y] = E.points))
                }
                for (y = g - 1; y >= 1; y -= 2) {
                  var O = y - 1,
                    P = y
                  if (C[O] === 1 && C[P] === 1) {
                    var $ = [h[O], null, null, h[P]]
                    h[O].y.cmp(h[P].y) === 0
                      ? (($[1] = h[O].add(h[P])), ($[2] = h[O].toJ().mixedAdd(h[P].neg())))
                      : h[O].y.cmp(h[P].y.redNeg()) === 0
                        ? (($[1] = h[O].toJ().mixedAdd(h[P])), ($[2] = h[O].add(h[P].neg())))
                        : (($[1] = h[O].toJ().mixedAdd(h[P])),
                          ($[2] = h[O].toJ().mixedAdd(h[P].neg())))
                    var F = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
                      M = l(p[O], p[P])
                    for (
                      B = Math.max(M[0].length, B), I[O] = new Array(B), I[P] = new Array(B), b = 0;
                      b < B;
                      b++
                    ) {
                      var R = 0 | M[0][b],
                        k = 0 | M[1][b]
                      ;((I[O][b] = F[3 * (R + 1) + (k + 1)]), (I[P][b] = 0), (T[O] = $))
                    }
                  } else
                    ((I[O] = a(p[O], C[O], this._bitLength)),
                      (I[P] = a(p[P], C[P], this._bitLength)),
                      (B = Math.max(I[O].length, B)),
                      (B = Math.max(I[P].length, B)))
                }
                var v = this.jpoint(null, null, null),
                  x = this._wnafT4
                for (y = B; y >= 0; y--) {
                  for (var _ = 0; y >= 0; ) {
                    var S = !0
                    for (b = 0; b < g; b++) ((x[b] = 0 | I[b][y]), x[b] !== 0 && (S = !1))
                    if (!S) break
                    ;(_++, y--)
                  }
                  if ((y >= 0 && _++, (v = v.dblp(_)), y < 0)) break
                  for (b = 0; b < g; b++) {
                    var A = x[b]
                    A !== 0 &&
                      (A > 0 ? (w = T[b][(A - 1) >> 1]) : A < 0 && (w = T[b][(-A - 1) >> 1].neg()),
                      (v = w.type === 'affine' ? v.mixedAdd(w) : v.add(w)))
                  }
                }
                for (y = 0; y < g; y++) T[y] = null
                return m ? v : v.toP()
              }),
              (u.BasePoint = f),
              (f.prototype.eq = function () {
                throw new Error('Not implemented')
              }),
              (f.prototype.validate = function () {
                return this.curve.validate(this)
              }),
              (u.prototype.decodePoint = function (d, h) {
                d = o.toArray(d, h)
                var p = this.p.byteLength()
                if ((d[0] === 4 || d[0] === 6 || d[0] === 7) && d.length - 1 == 2 * p)
                  return (
                    d[0] === 6
                      ? c(d[d.length - 1] % 2 == 0)
                      : d[0] === 7 && c(d[d.length - 1] % 2 == 1),
                    this.point(d.slice(1, 1 + p), d.slice(1 + p, 1 + 2 * p))
                  )
                if ((d[0] === 2 || d[0] === 3) && d.length - 1 === p)
                  return this.pointFromX(d.slice(1, 1 + p), d[0] === 3)
                throw new Error('Unknown point format')
              }),
              (f.prototype.encodeCompressed = function (d) {
                return this.encode(d, !0)
              }),
              (f.prototype._encode = function (d) {
                var h = this.curve.p.byteLength(),
                  p = this.getX().toArray('be', h)
                return d
                  ? [this.getY().isEven() ? 2 : 3].concat(p)
                  : [4].concat(p, this.getY().toArray('be', h))
              }),
              (f.prototype.encode = function (d, h) {
                return o.encode(this._encode(h), d)
              }),
              (f.prototype.precompute = function (d) {
                if (this.precomputed) return this
                var h = { doubles: null, naf: null, beta: null }
                return (
                  (h.naf = this._getNAFPoints(8)),
                  (h.doubles = this._getDoubles(4, d)),
                  (h.beta = this._getBeta()),
                  (this.precomputed = h),
                  this
                )
              }),
              (f.prototype._hasDoubles = function (d) {
                if (!this.precomputed) return !1
                var h = this.precomputed.doubles
                return !!h && h.points.length >= Math.ceil((d.bitLength() + 1) / h.step)
              }),
              (f.prototype._getDoubles = function (d, h) {
                if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles
                for (var p = [this], g = this, m = 0; m < h; m += d) {
                  for (var y = 0; y < d; y++) g = g.dbl()
                  p.push(g)
                }
                return { step: d, points: p }
              }),
              (f.prototype._getNAFPoints = function (d) {
                if (this.precomputed && this.precomputed.naf) return this.precomputed.naf
                for (
                  var h = [this], p = (1 << d) - 1, g = p === 1 ? null : this.dbl(), m = 1;
                  m < p;
                  m++
                )
                  h[m] = h[m - 1].add(g)
                return { wnd: d, points: h }
              }),
              (f.prototype._getBeta = function () {
                return null
              }),
              (f.prototype.dblp = function (d) {
                for (var h = this, p = 0; p < d; p++) h = h.dbl()
                return h
              }))
          },
          { '../utils': 419, 'bn.js': 420 },
        ],
        407: [
          function (t, r, i) {
            var s = t('../utils'),
              o = t('bn.js'),
              a = t('inherits'),
              l = t('./base'),
              c = s.assert
            function u(d) {
              ;((this.twisted = (0 | d.a) != 1),
                (this.mOneA = this.twisted && (0 | d.a) == -1),
                (this.extended = this.mOneA),
                l.call(this, 'edwards', d),
                (this.a = new o(d.a, 16).umod(this.red.m)),
                (this.a = this.a.toRed(this.red)),
                (this.c = new o(d.c, 16).toRed(this.red)),
                (this.c2 = this.c.redSqr()),
                (this.d = new o(d.d, 16).toRed(this.red)),
                (this.dd = this.d.redAdd(this.d)),
                c(!this.twisted || this.c.fromRed().cmpn(1) === 0),
                (this.oneC = (0 | d.c) == 1))
            }
            function f(d, h, p, g, m) {
              ;(l.BasePoint.call(this, d, 'projective'),
                h === null && p === null && g === null
                  ? ((this.x = this.curve.zero),
                    (this.y = this.curve.one),
                    (this.z = this.curve.one),
                    (this.t = this.curve.zero),
                    (this.zOne = !0))
                  : ((this.x = new o(h, 16)),
                    (this.y = new o(p, 16)),
                    (this.z = g ? new o(g, 16) : this.curve.one),
                    (this.t = m && new o(m, 16)),
                    this.x.red || (this.x = this.x.toRed(this.curve.red)),
                    this.y.red || (this.y = this.y.toRed(this.curve.red)),
                    this.z.red || (this.z = this.z.toRed(this.curve.red)),
                    this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
                    (this.zOne = this.z === this.curve.one),
                    this.curve.extended &&
                      !this.t &&
                      ((this.t = this.x.redMul(this.y)),
                      this.zOne || (this.t = this.t.redMul(this.z.redInvm())))))
            }
            ;(a(u, l),
              (r.exports = u),
              (u.prototype._mulA = function (d) {
                return this.mOneA ? d.redNeg() : this.a.redMul(d)
              }),
              (u.prototype._mulC = function (d) {
                return this.oneC ? d : this.c.redMul(d)
              }),
              (u.prototype.jpoint = function (d, h, p, g) {
                return this.point(d, h, p, g)
              }),
              (u.prototype.pointFromX = function (d, h) {
                ;(d = new o(d, 16)).red || (d = d.toRed(this.red))
                var p = d.redSqr(),
                  g = this.c2.redSub(this.a.redMul(p)),
                  m = this.one.redSub(this.c2.redMul(this.d).redMul(p)),
                  y = g.redMul(m.redInvm()),
                  b = y.redSqrt()
                if (b.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error('invalid point')
                var w = b.fromRed().isOdd()
                return (((h && !w) || (!h && w)) && (b = b.redNeg()), this.point(d, b))
              }),
              (u.prototype.pointFromY = function (d, h) {
                ;(d = new o(d, 16)).red || (d = d.toRed(this.red))
                var p = d.redSqr(),
                  g = p.redSub(this.c2),
                  m = p.redMul(this.d).redMul(this.c2).redSub(this.a),
                  y = g.redMul(m.redInvm())
                if (y.cmp(this.zero) === 0) {
                  if (h) throw new Error('invalid point')
                  return this.point(this.zero, d)
                }
                var b = y.redSqrt()
                if (b.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error('invalid point')
                return (b.fromRed().isOdd() !== h && (b = b.redNeg()), this.point(b, d))
              }),
              (u.prototype.validate = function (d) {
                if (d.isInfinity()) return !0
                d.normalize()
                var h = d.x.redSqr(),
                  p = d.y.redSqr(),
                  g = h.redMul(this.a).redAdd(p),
                  m = this.c2.redMul(this.one.redAdd(this.d.redMul(h).redMul(p)))
                return g.cmp(m) === 0
              }),
              a(f, l.BasePoint),
              (u.prototype.pointFromJSON = function (d) {
                return f.fromJSON(this, d)
              }),
              (u.prototype.point = function (d, h, p, g) {
                return new f(this, d, h, p, g)
              }),
              (f.fromJSON = function (d, h) {
                return new f(d, h[0], h[1], h[2])
              }),
              (f.prototype.inspect = function () {
                return this.isInfinity()
                  ? '<EC Point Infinity>'
                  : '<EC Point x: ' +
                      this.x.fromRed().toString(16, 2) +
                      ' y: ' +
                      this.y.fromRed().toString(16, 2) +
                      ' z: ' +
                      this.z.fromRed().toString(16, 2) +
                      '>'
              }),
              (f.prototype.isInfinity = function () {
                return (
                  this.x.cmpn(0) === 0 &&
                  (this.y.cmp(this.z) === 0 || (this.zOne && this.y.cmp(this.curve.c) === 0))
                )
              }),
              (f.prototype._extDbl = function () {
                var d = this.x.redSqr(),
                  h = this.y.redSqr(),
                  p = this.z.redSqr()
                p = p.redIAdd(p)
                var g = this.curve._mulA(d),
                  m = this.x.redAdd(this.y).redSqr().redISub(d).redISub(h),
                  y = g.redAdd(h),
                  b = y.redSub(p),
                  w = g.redSub(h),
                  C = m.redMul(b),
                  T = y.redMul(w),
                  I = m.redMul(w),
                  B = b.redMul(y)
                return this.curve.point(C, T, B, I)
              }),
              (f.prototype._projDbl = function () {
                var d,
                  h,
                  p,
                  g,
                  m,
                  y,
                  b = this.x.redAdd(this.y).redSqr(),
                  w = this.x.redSqr(),
                  C = this.y.redSqr()
                if (this.curve.twisted) {
                  var T = (g = this.curve._mulA(w)).redAdd(C)
                  this.zOne
                    ? ((d = b.redSub(w).redSub(C).redMul(T.redSub(this.curve.two))),
                      (h = T.redMul(g.redSub(C))),
                      (p = T.redSqr().redSub(T).redSub(T)))
                    : ((m = this.z.redSqr()),
                      (y = T.redSub(m).redISub(m)),
                      (d = b.redSub(w).redISub(C).redMul(y)),
                      (h = T.redMul(g.redSub(C))),
                      (p = T.redMul(y)))
                } else
                  ((g = w.redAdd(C)),
                    (m = this.curve._mulC(this.z).redSqr()),
                    (y = g.redSub(m).redSub(m)),
                    (d = this.curve._mulC(b.redISub(g)).redMul(y)),
                    (h = this.curve._mulC(g).redMul(w.redISub(C))),
                    (p = g.redMul(y)))
                return this.curve.point(d, h, p)
              }),
              (f.prototype.dbl = function () {
                return this.isInfinity()
                  ? this
                  : this.curve.extended
                    ? this._extDbl()
                    : this._projDbl()
              }),
              (f.prototype._extAdd = function (d) {
                var h = this.y.redSub(this.x).redMul(d.y.redSub(d.x)),
                  p = this.y.redAdd(this.x).redMul(d.y.redAdd(d.x)),
                  g = this.t.redMul(this.curve.dd).redMul(d.t),
                  m = this.z.redMul(d.z.redAdd(d.z)),
                  y = p.redSub(h),
                  b = m.redSub(g),
                  w = m.redAdd(g),
                  C = p.redAdd(h),
                  T = y.redMul(b),
                  I = w.redMul(C),
                  B = y.redMul(C),
                  E = b.redMul(w)
                return this.curve.point(T, I, E, B)
              }),
              (f.prototype._projAdd = function (d) {
                var h,
                  p,
                  g = this.z.redMul(d.z),
                  m = g.redSqr(),
                  y = this.x.redMul(d.x),
                  b = this.y.redMul(d.y),
                  w = this.curve.d.redMul(y).redMul(b),
                  C = m.redSub(w),
                  T = m.redAdd(w),
                  I = this.x.redAdd(this.y).redMul(d.x.redAdd(d.y)).redISub(y).redISub(b),
                  B = g.redMul(C).redMul(I)
                return (
                  this.curve.twisted
                    ? ((h = g.redMul(T).redMul(b.redSub(this.curve._mulA(y)))), (p = C.redMul(T)))
                    : ((h = g.redMul(T).redMul(b.redSub(y))), (p = this.curve._mulC(C).redMul(T))),
                  this.curve.point(B, h, p)
                )
              }),
              (f.prototype.add = function (d) {
                return this.isInfinity()
                  ? d
                  : d.isInfinity()
                    ? this
                    : this.curve.extended
                      ? this._extAdd(d)
                      : this._projAdd(d)
              }),
              (f.prototype.mul = function (d) {
                return this._hasDoubles(d)
                  ? this.curve._fixedNafMul(this, d)
                  : this.curve._wnafMul(this, d)
              }),
              (f.prototype.mulAdd = function (d, h, p) {
                return this.curve._wnafMulAdd(1, [this, h], [d, p], 2, !1)
              }),
              (f.prototype.jmulAdd = function (d, h, p) {
                return this.curve._wnafMulAdd(1, [this, h], [d, p], 2, !0)
              }),
              (f.prototype.normalize = function () {
                if (this.zOne) return this
                var d = this.z.redInvm()
                return (
                  (this.x = this.x.redMul(d)),
                  (this.y = this.y.redMul(d)),
                  this.t && (this.t = this.t.redMul(d)),
                  (this.z = this.curve.one),
                  (this.zOne = !0),
                  this
                )
              }),
              (f.prototype.neg = function () {
                return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
              }),
              (f.prototype.getX = function () {
                return (this.normalize(), this.x.fromRed())
              }),
              (f.prototype.getY = function () {
                return (this.normalize(), this.y.fromRed())
              }),
              (f.prototype.eq = function (d) {
                return (
                  this === d || (this.getX().cmp(d.getX()) === 0 && this.getY().cmp(d.getY()) === 0)
                )
              }),
              (f.prototype.eqXToP = function (d) {
                var h = d.toRed(this.curve.red).redMul(this.z)
                if (this.x.cmp(h) === 0) return !0
                for (var p = d.clone(), g = this.curve.redN.redMul(this.z); ; ) {
                  if ((p.iadd(this.curve.n), p.cmp(this.curve.p) >= 0)) return !1
                  if ((h.redIAdd(g), this.x.cmp(h) === 0)) return !0
                }
              }),
              (f.prototype.toP = f.prototype.normalize),
              (f.prototype.mixedAdd = f.prototype.add))
          },
          { '../utils': 419, './base': 406, 'bn.js': 420, inherits: 440 },
        ],
        408: [
          function (t, r, i) {
            var s = i
            ;((s.base = t('./base')),
              (s.short = t('./short')),
              (s.mont = t('./mont')),
              (s.edwards = t('./edwards')))
          },
          { './base': 406, './edwards': 407, './mont': 409, './short': 410 },
        ],
        409: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('inherits'),
              a = t('./base'),
              l = t('../utils')
            function c(f) {
              ;(a.call(this, 'mont', f),
                (this.a = new s(f.a, 16).toRed(this.red)),
                (this.b = new s(f.b, 16).toRed(this.red)),
                (this.i4 = new s(4).toRed(this.red).redInvm()),
                (this.two = new s(2).toRed(this.red)),
                (this.a24 = this.i4.redMul(this.a.redAdd(this.two))))
            }
            function u(f, d, h) {
              ;(a.BasePoint.call(this, f, 'projective'),
                d === null && h === null
                  ? ((this.x = this.curve.one), (this.z = this.curve.zero))
                  : ((this.x = new s(d, 16)),
                    (this.z = new s(h, 16)),
                    this.x.red || (this.x = this.x.toRed(this.curve.red)),
                    this.z.red || (this.z = this.z.toRed(this.curve.red))))
            }
            ;(o(c, a),
              (r.exports = c),
              (c.prototype.validate = function (f) {
                var d = f.normalize().x,
                  h = d.redSqr(),
                  p = h.redMul(d).redAdd(h.redMul(this.a)).redAdd(d)
                return p.redSqrt().redSqr().cmp(p) === 0
              }),
              o(u, a.BasePoint),
              (c.prototype.decodePoint = function (f, d) {
                return this.point(l.toArray(f, d), 1)
              }),
              (c.prototype.point = function (f, d) {
                return new u(this, f, d)
              }),
              (c.prototype.pointFromJSON = function (f) {
                return u.fromJSON(this, f)
              }),
              (u.prototype.precompute = function () {}),
              (u.prototype._encode = function () {
                return this.getX().toArray('be', this.curve.p.byteLength())
              }),
              (u.fromJSON = function (f, d) {
                return new u(f, d[0], d[1] || f.one)
              }),
              (u.prototype.inspect = function () {
                return this.isInfinity()
                  ? '<EC Point Infinity>'
                  : '<EC Point x: ' +
                      this.x.fromRed().toString(16, 2) +
                      ' z: ' +
                      this.z.fromRed().toString(16, 2) +
                      '>'
              }),
              (u.prototype.isInfinity = function () {
                return this.z.cmpn(0) === 0
              }),
              (u.prototype.dbl = function () {
                var f = this.x.redAdd(this.z).redSqr(),
                  d = this.x.redSub(this.z).redSqr(),
                  h = f.redSub(d),
                  p = f.redMul(d),
                  g = h.redMul(d.redAdd(this.curve.a24.redMul(h)))
                return this.curve.point(p, g)
              }),
              (u.prototype.add = function () {
                throw new Error('Not supported on Montgomery curve')
              }),
              (u.prototype.diffAdd = function (f, d) {
                var h = this.x.redAdd(this.z),
                  p = this.x.redSub(this.z),
                  g = f.x.redAdd(f.z),
                  m = f.x.redSub(f.z).redMul(h),
                  y = g.redMul(p),
                  b = d.z.redMul(m.redAdd(y).redSqr()),
                  w = d.x.redMul(m.redISub(y).redSqr())
                return this.curve.point(b, w)
              }),
              (u.prototype.mul = function (f) {
                for (
                  var d = f.clone(), h = this, p = this.curve.point(null, null), g = [];
                  d.cmpn(0) !== 0;
                  d.iushrn(1)
                )
                  g.push(d.andln(1))
                for (var m = g.length - 1; m >= 0; m--)
                  g[m] === 0
                    ? ((h = h.diffAdd(p, this)), (p = p.dbl()))
                    : ((p = h.diffAdd(p, this)), (h = h.dbl()))
                return p
              }),
              (u.prototype.mulAdd = function () {
                throw new Error('Not supported on Montgomery curve')
              }),
              (u.prototype.jumlAdd = function () {
                throw new Error('Not supported on Montgomery curve')
              }),
              (u.prototype.eq = function (f) {
                return this.getX().cmp(f.getX()) === 0
              }),
              (u.prototype.normalize = function () {
                return ((this.x = this.x.redMul(this.z.redInvm())), (this.z = this.curve.one), this)
              }),
              (u.prototype.getX = function () {
                return (this.normalize(), this.x.fromRed())
              }))
          },
          { '../utils': 419, './base': 406, 'bn.js': 420, inherits: 440 },
        ],
        410: [
          function (t, r, i) {
            var s = t('../utils'),
              o = t('bn.js'),
              a = t('inherits'),
              l = t('./base'),
              c = s.assert
            function u(h) {
              ;(l.call(this, 'short', h),
                (this.a = new o(h.a, 16).toRed(this.red)),
                (this.b = new o(h.b, 16).toRed(this.red)),
                (this.tinv = this.two.redInvm()),
                (this.zeroA = this.a.fromRed().cmpn(0) === 0),
                (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
                (this.endo = this._getEndomorphism(h)),
                (this._endoWnafT1 = new Array(4)),
                (this._endoWnafT2 = new Array(4)))
            }
            function f(h, p, g, m) {
              ;(l.BasePoint.call(this, h, 'affine'),
                p === null && g === null
                  ? ((this.x = null), (this.y = null), (this.inf = !0))
                  : ((this.x = new o(p, 16)),
                    (this.y = new o(g, 16)),
                    m && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
                    this.x.red || (this.x = this.x.toRed(this.curve.red)),
                    this.y.red || (this.y = this.y.toRed(this.curve.red)),
                    (this.inf = !1)))
            }
            function d(h, p, g, m) {
              ;(l.BasePoint.call(this, h, 'jacobian'),
                p === null && g === null && m === null
                  ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new o(0)))
                  : ((this.x = new o(p, 16)), (this.y = new o(g, 16)), (this.z = new o(m, 16))),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.y.red || (this.y = this.y.toRed(this.curve.red)),
                this.z.red || (this.z = this.z.toRed(this.curve.red)),
                (this.zOne = this.z === this.curve.one))
            }
            ;(a(u, l),
              (r.exports = u),
              (u.prototype._getEndomorphism = function (h) {
                if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
                  var p, g
                  if (h.beta) p = new o(h.beta, 16).toRed(this.red)
                  else {
                    var m = this._getEndoRoots(this.p)
                    p = (p = m[0].cmp(m[1]) < 0 ? m[0] : m[1]).toRed(this.red)
                  }
                  if (h.lambda) g = new o(h.lambda, 16)
                  else {
                    var y = this._getEndoRoots(this.n)
                    this.g.mul(y[0]).x.cmp(this.g.x.redMul(p)) === 0
                      ? (g = y[0])
                      : ((g = y[1]), c(this.g.mul(g).x.cmp(this.g.x.redMul(p)) === 0))
                  }
                  return {
                    beta: p,
                    lambda: g,
                    basis: h.basis
                      ? h.basis.map(function (b) {
                          return { a: new o(b.a, 16), b: new o(b.b, 16) }
                        })
                      : this._getEndoBasis(g),
                  }
                }
              }),
              (u.prototype._getEndoRoots = function (h) {
                var p = h === this.p ? this.red : o.mont(h),
                  g = new o(2).toRed(p).redInvm(),
                  m = g.redNeg(),
                  y = new o(3).toRed(p).redNeg().redSqrt().redMul(g)
                return [m.redAdd(y).fromRed(), m.redSub(y).fromRed()]
              }),
              (u.prototype._getEndoBasis = function (h) {
                for (
                  var p,
                    g,
                    m,
                    y,
                    b,
                    w,
                    C,
                    T,
                    I,
                    B = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
                    E = h,
                    O = this.n.clone(),
                    P = new o(1),
                    $ = new o(0),
                    F = new o(0),
                    M = new o(1),
                    R = 0;
                  E.cmpn(0) !== 0;

                ) {
                  var k = O.div(E)
                  ;((T = O.sub(k.mul(E))), (I = F.sub(k.mul(P))))
                  var v = M.sub(k.mul($))
                  if (!m && T.cmp(B) < 0) ((p = C.neg()), (g = P), (m = T.neg()), (y = I))
                  else if (m && ++R == 2) break
                  ;((C = T), (O = E), (E = T), (F = P), (P = I), (M = $), ($ = v))
                }
                ;((b = T.neg()), (w = I))
                var x = m.sqr().add(y.sqr())
                return (
                  b.sqr().add(w.sqr()).cmp(x) >= 0 && ((b = p), (w = g)),
                  m.negative && ((m = m.neg()), (y = y.neg())),
                  b.negative && ((b = b.neg()), (w = w.neg())),
                  [
                    { a: m, b: y },
                    { a: b, b: w },
                  ]
                )
              }),
              (u.prototype._endoSplit = function (h) {
                var p = this.endo.basis,
                  g = p[0],
                  m = p[1],
                  y = m.b.mul(h).divRound(this.n),
                  b = g.b.neg().mul(h).divRound(this.n),
                  w = y.mul(g.a),
                  C = b.mul(m.a),
                  T = y.mul(g.b),
                  I = b.mul(m.b)
                return { k1: h.sub(w).sub(C), k2: T.add(I).neg() }
              }),
              (u.prototype.pointFromX = function (h, p) {
                ;(h = new o(h, 16)).red || (h = h.toRed(this.red))
                var g = h.redSqr().redMul(h).redIAdd(h.redMul(this.a)).redIAdd(this.b),
                  m = g.redSqrt()
                if (m.redSqr().redSub(g).cmp(this.zero) !== 0) throw new Error('invalid point')
                var y = m.fromRed().isOdd()
                return (((p && !y) || (!p && y)) && (m = m.redNeg()), this.point(h, m))
              }),
              (u.prototype.validate = function (h) {
                if (h.inf) return !0
                var p = h.x,
                  g = h.y,
                  m = this.a.redMul(p),
                  y = p.redSqr().redMul(p).redIAdd(m).redIAdd(this.b)
                return g.redSqr().redISub(y).cmpn(0) === 0
              }),
              (u.prototype._endoWnafMulAdd = function (h, p, g) {
                for (var m = this._endoWnafT1, y = this._endoWnafT2, b = 0; b < h.length; b++) {
                  var w = this._endoSplit(p[b]),
                    C = h[b],
                    T = C._getBeta()
                  ;(w.k1.negative && (w.k1.ineg(), (C = C.neg(!0))),
                    w.k2.negative && (w.k2.ineg(), (T = T.neg(!0))),
                    (m[2 * b] = C),
                    (m[2 * b + 1] = T),
                    (y[2 * b] = w.k1),
                    (y[2 * b + 1] = w.k2))
                }
                for (var I = this._wnafMulAdd(1, m, y, 2 * b, g), B = 0; B < 2 * b; B++)
                  ((m[B] = null), (y[B] = null))
                return I
              }),
              a(f, l.BasePoint),
              (u.prototype.point = function (h, p, g) {
                return new f(this, h, p, g)
              }),
              (u.prototype.pointFromJSON = function (h, p) {
                return f.fromJSON(this, h, p)
              }),
              (f.prototype._getBeta = function () {
                if (this.curve.endo) {
                  var h = this.precomputed
                  if (h && h.beta) return h.beta
                  var p = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y)
                  if (h) {
                    var g = this.curve,
                      m = function (y) {
                        return g.point(y.x.redMul(g.endo.beta), y.y)
                      }
                    ;((h.beta = p),
                      (p.precomputed = {
                        beta: null,
                        naf: h.naf && { wnd: h.naf.wnd, points: h.naf.points.map(m) },
                        doubles: h.doubles && {
                          step: h.doubles.step,
                          points: h.doubles.points.map(m),
                        },
                      }))
                  }
                  return p
                }
              }),
              (f.prototype.toJSON = function () {
                return this.precomputed
                  ? [
                      this.x,
                      this.y,
                      this.precomputed && {
                        doubles: this.precomputed.doubles && {
                          step: this.precomputed.doubles.step,
                          points: this.precomputed.doubles.points.slice(1),
                        },
                        naf: this.precomputed.naf && {
                          wnd: this.precomputed.naf.wnd,
                          points: this.precomputed.naf.points.slice(1),
                        },
                      },
                    ]
                  : [this.x, this.y]
              }),
              (f.fromJSON = function (h, p, g) {
                typeof p == 'string' && (p = JSON.parse(p))
                var m = h.point(p[0], p[1], g)
                if (!p[2]) return m
                function y(w) {
                  return h.point(w[0], w[1], g)
                }
                var b = p[2]
                return (
                  (m.precomputed = {
                    beta: null,
                    doubles: b.doubles && {
                      step: b.doubles.step,
                      points: [m].concat(b.doubles.points.map(y)),
                    },
                    naf: b.naf && { wnd: b.naf.wnd, points: [m].concat(b.naf.points.map(y)) },
                  }),
                  m
                )
              }),
              (f.prototype.inspect = function () {
                return this.isInfinity()
                  ? '<EC Point Infinity>'
                  : '<EC Point x: ' +
                      this.x.fromRed().toString(16, 2) +
                      ' y: ' +
                      this.y.fromRed().toString(16, 2) +
                      '>'
              }),
              (f.prototype.isInfinity = function () {
                return this.inf
              }),
              (f.prototype.add = function (h) {
                if (this.inf) return h
                if (h.inf) return this
                if (this.eq(h)) return this.dbl()
                if (this.neg().eq(h)) return this.curve.point(null, null)
                if (this.x.cmp(h.x) === 0) return this.curve.point(null, null)
                var p = this.y.redSub(h.y)
                p.cmpn(0) !== 0 && (p = p.redMul(this.x.redSub(h.x).redInvm()))
                var g = p.redSqr().redISub(this.x).redISub(h.x),
                  m = p.redMul(this.x.redSub(g)).redISub(this.y)
                return this.curve.point(g, m)
              }),
              (f.prototype.dbl = function () {
                if (this.inf) return this
                var h = this.y.redAdd(this.y)
                if (h.cmpn(0) === 0) return this.curve.point(null, null)
                var p = this.curve.a,
                  g = this.x.redSqr(),
                  m = h.redInvm(),
                  y = g.redAdd(g).redIAdd(g).redIAdd(p).redMul(m),
                  b = y.redSqr().redISub(this.x.redAdd(this.x)),
                  w = y.redMul(this.x.redSub(b)).redISub(this.y)
                return this.curve.point(b, w)
              }),
              (f.prototype.getX = function () {
                return this.x.fromRed()
              }),
              (f.prototype.getY = function () {
                return this.y.fromRed()
              }),
              (f.prototype.mul = function (h) {
                return (
                  (h = new o(h, 16)),
                  this.isInfinity()
                    ? this
                    : this._hasDoubles(h)
                      ? this.curve._fixedNafMul(this, h)
                      : this.curve.endo
                        ? this.curve._endoWnafMulAdd([this], [h])
                        : this.curve._wnafMul(this, h)
                )
              }),
              (f.prototype.mulAdd = function (h, p, g) {
                var m = [this, p],
                  y = [h, g]
                return this.curve.endo
                  ? this.curve._endoWnafMulAdd(m, y)
                  : this.curve._wnafMulAdd(1, m, y, 2)
              }),
              (f.prototype.jmulAdd = function (h, p, g) {
                var m = [this, p],
                  y = [h, g]
                return this.curve.endo
                  ? this.curve._endoWnafMulAdd(m, y, !0)
                  : this.curve._wnafMulAdd(1, m, y, 2, !0)
              }),
              (f.prototype.eq = function (h) {
                return (
                  this === h ||
                  (this.inf === h.inf &&
                    (this.inf || (this.x.cmp(h.x) === 0 && this.y.cmp(h.y) === 0)))
                )
              }),
              (f.prototype.neg = function (h) {
                if (this.inf) return this
                var p = this.curve.point(this.x, this.y.redNeg())
                if (h && this.precomputed) {
                  var g = this.precomputed,
                    m = function (y) {
                      return y.neg()
                    }
                  p.precomputed = {
                    naf: g.naf && { wnd: g.naf.wnd, points: g.naf.points.map(m) },
                    doubles: g.doubles && { step: g.doubles.step, points: g.doubles.points.map(m) },
                  }
                }
                return p
              }),
              (f.prototype.toJ = function () {
                return this.inf
                  ? this.curve.jpoint(null, null, null)
                  : this.curve.jpoint(this.x, this.y, this.curve.one)
              }),
              a(d, l.BasePoint),
              (u.prototype.jpoint = function (h, p, g) {
                return new d(this, h, p, g)
              }),
              (d.prototype.toP = function () {
                if (this.isInfinity()) return this.curve.point(null, null)
                var h = this.z.redInvm(),
                  p = h.redSqr(),
                  g = this.x.redMul(p),
                  m = this.y.redMul(p).redMul(h)
                return this.curve.point(g, m)
              }),
              (d.prototype.neg = function () {
                return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
              }),
              (d.prototype.add = function (h) {
                if (this.isInfinity()) return h
                if (h.isInfinity()) return this
                var p = h.z.redSqr(),
                  g = this.z.redSqr(),
                  m = this.x.redMul(p),
                  y = h.x.redMul(g),
                  b = this.y.redMul(p.redMul(h.z)),
                  w = h.y.redMul(g.redMul(this.z)),
                  C = m.redSub(y),
                  T = b.redSub(w)
                if (C.cmpn(0) === 0)
                  return T.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
                var I = C.redSqr(),
                  B = I.redMul(C),
                  E = m.redMul(I),
                  O = T.redSqr().redIAdd(B).redISub(E).redISub(E),
                  P = T.redMul(E.redISub(O)).redISub(b.redMul(B)),
                  $ = this.z.redMul(h.z).redMul(C)
                return this.curve.jpoint(O, P, $)
              }),
              (d.prototype.mixedAdd = function (h) {
                if (this.isInfinity()) return h.toJ()
                if (h.isInfinity()) return this
                var p = this.z.redSqr(),
                  g = this.x,
                  m = h.x.redMul(p),
                  y = this.y,
                  b = h.y.redMul(p).redMul(this.z),
                  w = g.redSub(m),
                  C = y.redSub(b)
                if (w.cmpn(0) === 0)
                  return C.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
                var T = w.redSqr(),
                  I = T.redMul(w),
                  B = g.redMul(T),
                  E = C.redSqr().redIAdd(I).redISub(B).redISub(B),
                  O = C.redMul(B.redISub(E)).redISub(y.redMul(I)),
                  P = this.z.redMul(w)
                return this.curve.jpoint(E, O, P)
              }),
              (d.prototype.dblp = function (h) {
                if (h === 0) return this
                if (this.isInfinity()) return this
                if (!h) return this.dbl()
                var p
                if (this.curve.zeroA || this.curve.threeA) {
                  var g = this
                  for (p = 0; p < h; p++) g = g.dbl()
                  return g
                }
                var m = this.curve.a,
                  y = this.curve.tinv,
                  b = this.x,
                  w = this.y,
                  C = this.z,
                  T = C.redSqr().redSqr(),
                  I = w.redAdd(w)
                for (p = 0; p < h; p++) {
                  var B = b.redSqr(),
                    E = I.redSqr(),
                    O = E.redSqr(),
                    P = B.redAdd(B).redIAdd(B).redIAdd(m.redMul(T)),
                    $ = b.redMul(E),
                    F = P.redSqr().redISub($.redAdd($)),
                    M = $.redISub(F),
                    R = P.redMul(M)
                  R = R.redIAdd(R).redISub(O)
                  var k = I.redMul(C)
                  ;(p + 1 < h && (T = T.redMul(O)), (b = F), (C = k), (I = R))
                }
                return this.curve.jpoint(b, I.redMul(y), C)
              }),
              (d.prototype.dbl = function () {
                return this.isInfinity()
                  ? this
                  : this.curve.zeroA
                    ? this._zeroDbl()
                    : this.curve.threeA
                      ? this._threeDbl()
                      : this._dbl()
              }),
              (d.prototype._zeroDbl = function () {
                var h, p, g
                if (this.zOne) {
                  var m = this.x.redSqr(),
                    y = this.y.redSqr(),
                    b = y.redSqr(),
                    w = this.x.redAdd(y).redSqr().redISub(m).redISub(b)
                  w = w.redIAdd(w)
                  var C = m.redAdd(m).redIAdd(m),
                    T = C.redSqr().redISub(w).redISub(w),
                    I = b.redIAdd(b)
                  ;((I = (I = I.redIAdd(I)).redIAdd(I)),
                    (h = T),
                    (p = C.redMul(w.redISub(T)).redISub(I)),
                    (g = this.y.redAdd(this.y)))
                } else {
                  var B = this.x.redSqr(),
                    E = this.y.redSqr(),
                    O = E.redSqr(),
                    P = this.x.redAdd(E).redSqr().redISub(B).redISub(O)
                  P = P.redIAdd(P)
                  var $ = B.redAdd(B).redIAdd(B),
                    F = $.redSqr(),
                    M = O.redIAdd(O)
                  ;((M = (M = M.redIAdd(M)).redIAdd(M)),
                    (h = F.redISub(P).redISub(P)),
                    (p = $.redMul(P.redISub(h)).redISub(M)),
                    (g = (g = this.y.redMul(this.z)).redIAdd(g)))
                }
                return this.curve.jpoint(h, p, g)
              }),
              (d.prototype._threeDbl = function () {
                var h, p, g
                if (this.zOne) {
                  var m = this.x.redSqr(),
                    y = this.y.redSqr(),
                    b = y.redSqr(),
                    w = this.x.redAdd(y).redSqr().redISub(m).redISub(b)
                  w = w.redIAdd(w)
                  var C = m.redAdd(m).redIAdd(m).redIAdd(this.curve.a),
                    T = C.redSqr().redISub(w).redISub(w)
                  h = T
                  var I = b.redIAdd(b)
                  ;((I = (I = I.redIAdd(I)).redIAdd(I)),
                    (p = C.redMul(w.redISub(T)).redISub(I)),
                    (g = this.y.redAdd(this.y)))
                } else {
                  var B = this.z.redSqr(),
                    E = this.y.redSqr(),
                    O = this.x.redMul(E),
                    P = this.x.redSub(B).redMul(this.x.redAdd(B))
                  P = P.redAdd(P).redIAdd(P)
                  var $ = O.redIAdd(O),
                    F = ($ = $.redIAdd($)).redAdd($)
                  ;((h = P.redSqr().redISub(F)),
                    (g = this.y.redAdd(this.z).redSqr().redISub(E).redISub(B)))
                  var M = E.redSqr()
                  ;((M = (M = (M = M.redIAdd(M)).redIAdd(M)).redIAdd(M)),
                    (p = P.redMul($.redISub(h)).redISub(M)))
                }
                return this.curve.jpoint(h, p, g)
              }),
              (d.prototype._dbl = function () {
                var h = this.curve.a,
                  p = this.x,
                  g = this.y,
                  m = this.z,
                  y = m.redSqr().redSqr(),
                  b = p.redSqr(),
                  w = g.redSqr(),
                  C = b.redAdd(b).redIAdd(b).redIAdd(h.redMul(y)),
                  T = p.redAdd(p),
                  I = (T = T.redIAdd(T)).redMul(w),
                  B = C.redSqr().redISub(I.redAdd(I)),
                  E = I.redISub(B),
                  O = w.redSqr()
                O = (O = (O = O.redIAdd(O)).redIAdd(O)).redIAdd(O)
                var P = C.redMul(E).redISub(O),
                  $ = g.redAdd(g).redMul(m)
                return this.curve.jpoint(B, P, $)
              }),
              (d.prototype.trpl = function () {
                if (!this.curve.zeroA) return this.dbl().add(this)
                var h = this.x.redSqr(),
                  p = this.y.redSqr(),
                  g = this.z.redSqr(),
                  m = p.redSqr(),
                  y = h.redAdd(h).redIAdd(h),
                  b = y.redSqr(),
                  w = this.x.redAdd(p).redSqr().redISub(h).redISub(m),
                  C = (w = (w = (w = w.redIAdd(w)).redAdd(w).redIAdd(w)).redISub(b)).redSqr(),
                  T = m.redIAdd(m)
                T = (T = (T = T.redIAdd(T)).redIAdd(T)).redIAdd(T)
                var I = y.redIAdd(w).redSqr().redISub(b).redISub(C).redISub(T),
                  B = p.redMul(I)
                B = (B = B.redIAdd(B)).redIAdd(B)
                var E = this.x.redMul(C).redISub(B)
                E = (E = E.redIAdd(E)).redIAdd(E)
                var O = this.y.redMul(I.redMul(T.redISub(I)).redISub(w.redMul(C)))
                O = (O = (O = O.redIAdd(O)).redIAdd(O)).redIAdd(O)
                var P = this.z.redAdd(w).redSqr().redISub(g).redISub(C)
                return this.curve.jpoint(E, O, P)
              }),
              (d.prototype.mul = function (h, p) {
                return ((h = new o(h, p)), this.curve._wnafMul(this, h))
              }),
              (d.prototype.eq = function (h) {
                if (h.type === 'affine') return this.eq(h.toJ())
                if (this === h) return !0
                var p = this.z.redSqr(),
                  g = h.z.redSqr()
                if (this.x.redMul(g).redISub(h.x.redMul(p)).cmpn(0) !== 0) return !1
                var m = p.redMul(this.z),
                  y = g.redMul(h.z)
                return this.y.redMul(y).redISub(h.y.redMul(m)).cmpn(0) === 0
              }),
              (d.prototype.eqXToP = function (h) {
                var p = this.z.redSqr(),
                  g = h.toRed(this.curve.red).redMul(p)
                if (this.x.cmp(g) === 0) return !0
                for (var m = h.clone(), y = this.curve.redN.redMul(p); ; ) {
                  if ((m.iadd(this.curve.n), m.cmp(this.curve.p) >= 0)) return !1
                  if ((g.redIAdd(y), this.x.cmp(g) === 0)) return !0
                }
              }),
              (d.prototype.inspect = function () {
                return this.isInfinity()
                  ? '<EC JPoint Infinity>'
                  : '<EC JPoint x: ' +
                      this.x.toString(16, 2) +
                      ' y: ' +
                      this.y.toString(16, 2) +
                      ' z: ' +
                      this.z.toString(16, 2) +
                      '>'
              }),
              (d.prototype.isInfinity = function () {
                return this.z.cmpn(0) === 0
              }))
          },
          { '../utils': 419, './base': 406, 'bn.js': 420, inherits: 440 },
        ],
        411: [
          function (t, r, i) {
            var s,
              o = i,
              a = t('hash.js'),
              l = t('./curve'),
              c = t('./utils').assert
            function u(d) {
              ;(d.type === 'short'
                ? (this.curve = new l.short(d))
                : d.type === 'edwards'
                  ? (this.curve = new l.edwards(d))
                  : (this.curve = new l.mont(d)),
                (this.g = this.curve.g),
                (this.n = this.curve.n),
                (this.hash = d.hash),
                c(this.g.validate(), 'Invalid curve'),
                c(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O'))
            }
            function f(d, h) {
              Object.defineProperty(o, d, {
                configurable: !0,
                enumerable: !0,
                get: function () {
                  var p = new u(h)
                  return (
                    Object.defineProperty(o, d, { configurable: !0, enumerable: !0, value: p }),
                    p
                  )
                },
              })
            }
            ;((o.PresetCurve = u),
              f('p192', {
                type: 'short',
                prime: 'p192',
                p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
                b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
                n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
                hash: a.sha256,
                gRed: !1,
                g: [
                  '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
                  '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
                ],
              }),
              f('p224', {
                type: 'short',
                prime: 'p224',
                p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
                b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
                n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
                hash: a.sha256,
                gRed: !1,
                g: [
                  'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
                  'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
                ],
              }),
              f('p256', {
                type: 'short',
                prime: null,
                p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
                a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
                b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
                n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
                hash: a.sha256,
                gRed: !1,
                g: [
                  '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
                  '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
                ],
              }),
              f('p384', {
                type: 'short',
                prime: null,
                p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff',
                a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc',
                b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
                n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
                hash: a.sha384,
                gRed: !1,
                g: [
                  'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7',
                  '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
                ],
              }),
              f('p521', {
                type: 'short',
                prime: null,
                p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff',
                a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc',
                b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
                n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
                hash: a.sha512,
                gRed: !1,
                g: [
                  '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
                  '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650',
                ],
              }),
              f('curve25519', {
                type: 'mont',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '76d06',
                b: '1',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: a.sha256,
                gRed: !1,
                g: ['9'],
              }),
              f('ed25519', {
                type: 'edwards',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '-1',
                c: '1',
                d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: a.sha256,
                gRed: !1,
                g: [
                  '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
                  '6666666666666666666666666666666666666666666666666666666666666658',
                ],
              }))
            try {
              s = t('./precomputed/secp256k1')
            } catch {
              s = void 0
            }
            f('secp256k1', {
              type: 'short',
              prime: 'k256',
              p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
              a: '0',
              b: '7',
              n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
              h: '1',
              hash: a.sha256,
              beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
              lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
              basis: [
                { a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' },
                { a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' },
              ],
              gRed: !1,
              g: [
                '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
                '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                s,
              ],
            })
          },
          { './curve': 408, './precomputed/secp256k1': 418, './utils': 419, 'hash.js': 426 },
        ],
        412: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('hmac-drbg'),
              a = t('../utils'),
              l = t('../curves'),
              c = t('brorand'),
              u = a.assert,
              f = t('./key'),
              d = t('./signature')
            function h(p) {
              if (!(this instanceof h)) return new h(p)
              ;(typeof p == 'string' &&
                (u(Object.prototype.hasOwnProperty.call(l, p), 'Unknown curve ' + p), (p = l[p])),
                p instanceof l.PresetCurve && (p = { curve: p }),
                (this.curve = p.curve.curve),
                (this.n = this.curve.n),
                (this.nh = this.n.ushrn(1)),
                (this.g = this.curve.g),
                (this.g = p.curve.g),
                this.g.precompute(p.curve.n.bitLength() + 1),
                (this.hash = p.hash || p.curve.hash))
            }
            ;((r.exports = h),
              (h.prototype.keyPair = function (p) {
                return new f(this, p)
              }),
              (h.prototype.keyFromPrivate = function (p, g) {
                return f.fromPrivate(this, p, g)
              }),
              (h.prototype.keyFromPublic = function (p, g) {
                return f.fromPublic(this, p, g)
              }),
              (h.prototype.genKeyPair = function (p) {
                p || (p = {})
                for (
                  var g = new o({
                      hash: this.hash,
                      pers: p.pers,
                      persEnc: p.persEnc || 'utf8',
                      entropy: p.entropy || c(this.hash.hmacStrength),
                      entropyEnc: (p.entropy && p.entropyEnc) || 'utf8',
                      nonce: this.n.toArray(),
                    }),
                    m = this.n.byteLength(),
                    y = this.n.sub(new s(2));
                  ;

                ) {
                  var b = new s(g.generate(m))
                  if (!(b.cmp(y) > 0)) return (b.iaddn(1), this.keyFromPrivate(b))
                }
              }),
              (h.prototype._truncateToN = function (p, g) {
                var m = 8 * p.byteLength() - this.n.bitLength()
                return (m > 0 && (p = p.ushrn(m)), !g && p.cmp(this.n) >= 0 ? p.sub(this.n) : p)
              }),
              (h.prototype.sign = function (p, g, m, y) {
                ;(typeof m == 'object' && ((y = m), (m = null)),
                  y || (y = {}),
                  (g = this.keyFromPrivate(g, m)),
                  (p = this._truncateToN(new s(p, 16))))
                for (
                  var b = this.n.byteLength(),
                    w = g.getPrivate().toArray('be', b),
                    C = p.toArray('be', b),
                    T = new o({
                      hash: this.hash,
                      entropy: w,
                      nonce: C,
                      pers: y.pers,
                      persEnc: y.persEnc || 'utf8',
                    }),
                    I = this.n.sub(new s(1)),
                    B = 0;
                  ;
                  B++
                ) {
                  var E = y.k ? y.k(B) : new s(T.generate(this.n.byteLength()))
                  if (!((E = this._truncateToN(E, !0)).cmpn(1) <= 0 || E.cmp(I) >= 0)) {
                    var O = this.g.mul(E)
                    if (!O.isInfinity()) {
                      var P = O.getX(),
                        $ = P.umod(this.n)
                      if ($.cmpn(0) !== 0) {
                        var F = E.invm(this.n).mul($.mul(g.getPrivate()).iadd(p))
                        if ((F = F.umod(this.n)).cmpn(0) !== 0) {
                          var M = (O.getY().isOdd() ? 1 : 0) | (P.cmp($) !== 0 ? 2 : 0)
                          return (
                            y.canonical && F.cmp(this.nh) > 0 && ((F = this.n.sub(F)), (M ^= 1)),
                            new d({ r: $, s: F, recoveryParam: M })
                          )
                        }
                      }
                    }
                  }
                }
              }),
              (h.prototype.verify = function (p, g, m, y) {
                ;((p = this._truncateToN(new s(p, 16))), (m = this.keyFromPublic(m, y)))
                var b = (g = new d(g, 'hex')).r,
                  w = g.s
                if (b.cmpn(1) < 0 || b.cmp(this.n) >= 0 || w.cmpn(1) < 0 || w.cmp(this.n) >= 0)
                  return !1
                var C,
                  T = w.invm(this.n),
                  I = T.mul(p).umod(this.n),
                  B = T.mul(b).umod(this.n)
                return this.curve._maxwellTrick
                  ? !(C = this.g.jmulAdd(I, m.getPublic(), B)).isInfinity() && C.eqXToP(b)
                  : !(C = this.g.mulAdd(I, m.getPublic(), B)).isInfinity() &&
                      C.getX().umod(this.n).cmp(b) === 0
              }),
              (h.prototype.recoverPubKey = function (p, g, m, y) {
                ;(u((3 & m) === m, 'The recovery param is more than two bits'), (g = new d(g, y)))
                var b = this.n,
                  w = new s(p),
                  C = g.r,
                  T = g.s,
                  I = 1 & m,
                  B = m >> 1
                if (C.cmp(this.curve.p.umod(this.curve.n)) >= 0 && B)
                  throw new Error('Unable to find sencond key candinate')
                C = B ? this.curve.pointFromX(C.add(this.curve.n), I) : this.curve.pointFromX(C, I)
                var E = g.r.invm(b),
                  O = b.sub(w).mul(E).umod(b),
                  P = T.mul(E).umod(b)
                return this.g.mulAdd(O, C, P)
              }),
              (h.prototype.getKeyRecoveryParam = function (p, g, m, y) {
                if ((g = new d(g, y)).recoveryParam !== null) return g.recoveryParam
                for (var b = 0; b < 4; b++) {
                  var w
                  try {
                    w = this.recoverPubKey(p, g, b)
                  } catch {
                    continue
                  }
                  if (w.eq(m)) return b
                }
                throw new Error('Unable to find valid recovery factor')
              }))
          },
          {
            '../curves': 411,
            '../utils': 419,
            './key': 413,
            './signature': 414,
            'bn.js': 420,
            brorand: 187,
            'hmac-drbg': 438,
          },
        ],
        413: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('../utils').assert
            function a(l, c) {
              ;((this.ec = l),
                (this.priv = null),
                (this.pub = null),
                c.priv && this._importPrivate(c.priv, c.privEnc),
                c.pub && this._importPublic(c.pub, c.pubEnc))
            }
            ;((r.exports = a),
              (a.fromPublic = function (l, c, u) {
                return c instanceof a ? c : new a(l, { pub: c, pubEnc: u })
              }),
              (a.fromPrivate = function (l, c, u) {
                return c instanceof a ? c : new a(l, { priv: c, privEnc: u })
              }),
              (a.prototype.validate = function () {
                var l = this.getPublic()
                return l.isInfinity()
                  ? { result: !1, reason: 'Invalid public key' }
                  : l.validate()
                    ? l.mul(this.ec.curve.n).isInfinity()
                      ? { result: !0, reason: null }
                      : { result: !1, reason: 'Public key * N != O' }
                    : { result: !1, reason: 'Public key is not a point' }
              }),
              (a.prototype.getPublic = function (l, c) {
                return (
                  typeof l == 'string' && ((c = l), (l = null)),
                  this.pub || (this.pub = this.ec.g.mul(this.priv)),
                  c ? this.pub.encode(c, l) : this.pub
                )
              }),
              (a.prototype.getPrivate = function (l) {
                return l === 'hex' ? this.priv.toString(16, 2) : this.priv
              }),
              (a.prototype._importPrivate = function (l, c) {
                ;((this.priv = new s(l, c || 16)), (this.priv = this.priv.umod(this.ec.curve.n)))
              }),
              (a.prototype._importPublic = function (l, c) {
                if (l.x || l.y)
                  return (
                    this.ec.curve.type === 'mont'
                      ? o(l.x, 'Need x coordinate')
                      : (this.ec.curve.type !== 'short' && this.ec.curve.type !== 'edwards') ||
                        o(l.x && l.y, 'Need both x and y coordinate'),
                    void (this.pub = this.ec.curve.point(l.x, l.y))
                  )
                this.pub = this.ec.curve.decodePoint(l, c)
              }),
              (a.prototype.derive = function (l) {
                return (
                  l.validate() || o(l.validate(), 'public point not validated'),
                  l.mul(this.priv).getX()
                )
              }),
              (a.prototype.sign = function (l, c, u) {
                return this.ec.sign(l, this, c, u)
              }),
              (a.prototype.verify = function (l, c) {
                return this.ec.verify(l, c, this)
              }),
              (a.prototype.inspect = function () {
                return (
                  '<Key priv: ' +
                  (this.priv && this.priv.toString(16, 2)) +
                  ' pub: ' +
                  (this.pub && this.pub.inspect()) +
                  ' >'
                )
              }))
          },
          { '../utils': 419, 'bn.js': 420 },
        ],
        414: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('../utils'),
              a = o.assert
            function l(h, p) {
              if (h instanceof l) return h
              this._importDER(h, p) ||
                (a(h.r && h.s, 'Signature without r or s'),
                (this.r = new s(h.r, 16)),
                (this.s = new s(h.s, 16)),
                h.recoveryParam === void 0
                  ? (this.recoveryParam = null)
                  : (this.recoveryParam = h.recoveryParam))
            }
            function c() {
              this.place = 0
            }
            function u(h, p) {
              var g = h[p.place++]
              if (!(128 & g)) return g
              var m = 15 & g
              if (m === 0 || m > 4) return !1
              for (var y = 0, b = 0, w = p.place; b < m; b++, w++)
                ((y <<= 8), (y |= h[w]), (y >>>= 0))
              return !(y <= 127) && ((p.place = w), y)
            }
            function f(h) {
              for (var p = 0, g = h.length - 1; !h[p] && !(128 & h[p + 1]) && p < g; ) p++
              return p === 0 ? h : h.slice(p)
            }
            function d(h, p) {
              if (p < 128) h.push(p)
              else {
                var g = 1 + ((Math.log(p) / Math.LN2) >>> 3)
                for (h.push(128 | g); --g; ) h.push((p >>> (g << 3)) & 255)
                h.push(p)
              }
            }
            ;((r.exports = l),
              (l.prototype._importDER = function (h, p) {
                h = o.toArray(h, p)
                var g = new c()
                if (h[g.place++] !== 48) return !1
                var m = u(h, g)
                if (m === !1 || m + g.place !== h.length || h[g.place++] !== 2) return !1
                var y = u(h, g)
                if (y === !1) return !1
                var b = h.slice(g.place, y + g.place)
                if (((g.place += y), h[g.place++] !== 2)) return !1
                var w = u(h, g)
                if (w === !1 || h.length !== w + g.place) return !1
                var C = h.slice(g.place, w + g.place)
                if (b[0] === 0) {
                  if (!(128 & b[1])) return !1
                  b = b.slice(1)
                }
                if (C[0] === 0) {
                  if (!(128 & C[1])) return !1
                  C = C.slice(1)
                }
                return ((this.r = new s(b)), (this.s = new s(C)), (this.recoveryParam = null), !0)
              }),
              (l.prototype.toDER = function (h) {
                var p = this.r.toArray(),
                  g = this.s.toArray()
                for (
                  128 & p[0] && (p = [0].concat(p)),
                    128 & g[0] && (g = [0].concat(g)),
                    p = f(p),
                    g = f(g);
                  !(g[0] || 128 & g[1]);

                )
                  g = g.slice(1)
                var m = [2]
                ;(d(m, p.length), (m = m.concat(p)).push(2), d(m, g.length))
                var y = m.concat(g),
                  b = [48]
                return (d(b, y.length), (b = b.concat(y)), o.encode(b, h))
              }))
          },
          { '../utils': 419, 'bn.js': 420 },
        ],
        415: [
          function (t, r, i) {
            var s = t('hash.js'),
              o = t('../curves'),
              a = t('../utils'),
              l = a.assert,
              c = a.parseBytes,
              u = t('./key'),
              f = t('./signature')
            function d(h) {
              if ((l(h === 'ed25519', 'only tested with ed25519 so far'), !(this instanceof d)))
                return new d(h)
              ;((h = o[h].curve),
                (this.curve = h),
                (this.g = h.g),
                this.g.precompute(h.n.bitLength() + 1),
                (this.pointClass = h.point().constructor),
                (this.encodingLength = Math.ceil(h.n.bitLength() / 8)),
                (this.hash = s.sha512))
            }
            ;((r.exports = d),
              (d.prototype.sign = function (h, p) {
                h = c(h)
                var g = this.keyFromSecret(p),
                  m = this.hashInt(g.messagePrefix(), h),
                  y = this.g.mul(m),
                  b = this.encodePoint(y),
                  w = this.hashInt(b, g.pubBytes(), h).mul(g.priv()),
                  C = m.add(w).umod(this.curve.n)
                return this.makeSignature({ R: y, S: C, Rencoded: b })
              }),
              (d.prototype.verify = function (h, p, g) {
                ;((h = c(h)), (p = this.makeSignature(p)))
                var m = this.keyFromPublic(g),
                  y = this.hashInt(p.Rencoded(), m.pubBytes(), h),
                  b = this.g.mul(p.S())
                return p.R().add(m.pub().mul(y)).eq(b)
              }),
              (d.prototype.hashInt = function () {
                for (var h = this.hash(), p = 0; p < arguments.length; p++) h.update(arguments[p])
                return a.intFromLE(h.digest()).umod(this.curve.n)
              }),
              (d.prototype.keyFromPublic = function (h) {
                return u.fromPublic(this, h)
              }),
              (d.prototype.keyFromSecret = function (h) {
                return u.fromSecret(this, h)
              }),
              (d.prototype.makeSignature = function (h) {
                return h instanceof f ? h : new f(this, h)
              }),
              (d.prototype.encodePoint = function (h) {
                var p = h.getY().toArray('le', this.encodingLength)
                return ((p[this.encodingLength - 1] |= h.getX().isOdd() ? 128 : 0), p)
              }),
              (d.prototype.decodePoint = function (h) {
                var p = (h = a.parseBytes(h)).length - 1,
                  g = h.slice(0, p).concat(-129 & h[p]),
                  m = (128 & h[p]) != 0,
                  y = a.intFromLE(g)
                return this.curve.pointFromY(y, m)
              }),
              (d.prototype.encodeInt = function (h) {
                return h.toArray('le', this.encodingLength)
              }),
              (d.prototype.decodeInt = function (h) {
                return a.intFromLE(h)
              }),
              (d.prototype.isPoint = function (h) {
                return h instanceof this.pointClass
              }))
          },
          { '../curves': 411, '../utils': 419, './key': 416, './signature': 417, 'hash.js': 426 },
        ],
        416: [
          function (t, r, i) {
            var s = t('../utils'),
              o = s.assert,
              a = s.parseBytes,
              l = s.cachedProperty
            function c(u, f) {
              ;((this.eddsa = u),
                (this._secret = a(f.secret)),
                u.isPoint(f.pub) ? (this._pub = f.pub) : (this._pubBytes = a(f.pub)))
            }
            ;((c.fromPublic = function (u, f) {
              return f instanceof c ? f : new c(u, { pub: f })
            }),
              (c.fromSecret = function (u, f) {
                return f instanceof c ? f : new c(u, { secret: f })
              }),
              (c.prototype.secret = function () {
                return this._secret
              }),
              l(c, 'pubBytes', function () {
                return this.eddsa.encodePoint(this.pub())
              }),
              l(c, 'pub', function () {
                return this._pubBytes
                  ? this.eddsa.decodePoint(this._pubBytes)
                  : this.eddsa.g.mul(this.priv())
              }),
              l(c, 'privBytes', function () {
                var u = this.eddsa,
                  f = this.hash(),
                  d = u.encodingLength - 1,
                  h = f.slice(0, u.encodingLength)
                return ((h[0] &= 248), (h[d] &= 127), (h[d] |= 64), h)
              }),
              l(c, 'priv', function () {
                return this.eddsa.decodeInt(this.privBytes())
              }),
              l(c, 'hash', function () {
                return this.eddsa.hash().update(this.secret()).digest()
              }),
              l(c, 'messagePrefix', function () {
                return this.hash().slice(this.eddsa.encodingLength)
              }),
              (c.prototype.sign = function (u) {
                return (o(this._secret, 'KeyPair can only verify'), this.eddsa.sign(u, this))
              }),
              (c.prototype.verify = function (u, f) {
                return this.eddsa.verify(u, f, this)
              }),
              (c.prototype.getSecret = function (u) {
                return (o(this._secret, 'KeyPair is public only'), s.encode(this.secret(), u))
              }),
              (c.prototype.getPublic = function (u) {
                return s.encode(this.pubBytes(), u)
              }),
              (r.exports = c))
          },
          { '../utils': 419 },
        ],
        417: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('../utils'),
              a = o.assert,
              l = o.cachedProperty,
              c = o.parseBytes
            function u(f, d) {
              ;((this.eddsa = f),
                typeof d != 'object' && (d = c(d)),
                Array.isArray(d) &&
                  (d = { R: d.slice(0, f.encodingLength), S: d.slice(f.encodingLength) }),
                a(d.R && d.S, 'Signature without R or S'),
                f.isPoint(d.R) && (this._R = d.R),
                d.S instanceof s && (this._S = d.S),
                (this._Rencoded = Array.isArray(d.R) ? d.R : d.Rencoded),
                (this._Sencoded = Array.isArray(d.S) ? d.S : d.Sencoded))
            }
            ;(l(u, 'S', function () {
              return this.eddsa.decodeInt(this.Sencoded())
            }),
              l(u, 'R', function () {
                return this.eddsa.decodePoint(this.Rencoded())
              }),
              l(u, 'Rencoded', function () {
                return this.eddsa.encodePoint(this.R())
              }),
              l(u, 'Sencoded', function () {
                return this.eddsa.encodeInt(this.S())
              }),
              (u.prototype.toBytes = function () {
                return this.Rencoded().concat(this.Sencoded())
              }),
              (u.prototype.toHex = function () {
                return o.encode(this.toBytes(), 'hex').toUpperCase()
              }),
              (r.exports = u))
          },
          { '../utils': 419, 'bn.js': 420 },
        ],
        418: [
          function (t, r, i) {
            r.exports = {
              doubles: {
                step: 4,
                points: [
                  [
                    'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                    'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
                  ],
                  [
                    '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                    '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
                  ],
                  [
                    '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                    'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
                  ],
                  [
                    '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                    '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
                  ],
                  [
                    '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                    '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
                  ],
                  [
                    '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                    '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
                  ],
                  [
                    'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                    '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
                  ],
                  [
                    '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                    'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
                  ],
                  [
                    'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                    '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
                  ],
                  [
                    'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                    'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
                  ],
                  [
                    'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                    '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
                  ],
                  [
                    '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                    '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
                  ],
                  [
                    '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                    '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
                  ],
                  [
                    '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                    '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
                  ],
                  [
                    '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                    '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
                  ],
                  [
                    '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                    '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
                  ],
                  [
                    '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                    '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
                  ],
                  [
                    '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                    '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
                  ],
                  [
                    '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                    'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
                  ],
                  [
                    'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                    '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
                  ],
                  [
                    'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                    '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
                  ],
                  [
                    '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                    '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
                  ],
                  [
                    '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                    '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
                  ],
                  [
                    'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                    '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
                  ],
                  [
                    '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                    'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
                  ],
                  [
                    'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                    '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
                  ],
                  [
                    'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                    'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
                  ],
                  [
                    'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                    '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
                  ],
                  [
                    'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                    'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
                  ],
                  [
                    'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                    '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
                  ],
                  [
                    '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                    'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
                  ],
                  [
                    '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                    '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
                  ],
                  [
                    'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                    '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
                  ],
                  [
                    '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                    'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
                  ],
                  [
                    'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                    '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
                  ],
                  [
                    'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                    '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
                  ],
                  [
                    'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                    'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
                  ],
                  [
                    '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                    '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
                  ],
                  [
                    '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                    '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
                  ],
                  [
                    '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                    'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
                  ],
                  [
                    '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                    '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
                  ],
                  [
                    'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                    '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
                  ],
                  [
                    '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                    '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
                  ],
                  [
                    '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                    'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
                  ],
                  [
                    '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                    '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
                  ],
                  [
                    'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                    '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
                  ],
                  [
                    '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                    'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
                  ],
                  [
                    'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                    'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
                  ],
                  [
                    'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                    '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
                  ],
                  [
                    '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                    'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
                  ],
                  [
                    '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                    'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
                  ],
                  [
                    'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                    '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
                  ],
                  [
                    'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                    '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
                  ],
                  [
                    'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                    '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
                  ],
                  [
                    '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                    'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
                  ],
                  [
                    '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                    '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
                  ],
                  [
                    'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                    'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
                  ],
                  [
                    '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                    'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
                  ],
                  [
                    '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                    '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
                  ],
                  [
                    '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                    '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
                  ],
                  [
                    'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                    'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
                  ],
                  [
                    '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                    '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
                  ],
                  [
                    '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                    '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
                  ],
                  [
                    'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                    '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
                  ],
                  [
                    'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                    'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
                  ],
                ],
              },
              naf: {
                wnd: 7,
                points: [
                  [
                    'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                    '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
                  ],
                  [
                    '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                    'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
                  ],
                  [
                    '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                    '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
                  ],
                  [
                    'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                    'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
                  ],
                  [
                    '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                    'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
                  ],
                  [
                    'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                    'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
                  ],
                  [
                    'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                    '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
                  ],
                  [
                    'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                    '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
                  ],
                  [
                    '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                    '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
                  ],
                  [
                    '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                    '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
                  ],
                  [
                    '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                    '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
                  ],
                  [
                    '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                    '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
                  ],
                  [
                    'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                    'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
                  ],
                  [
                    'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                    '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
                  ],
                  [
                    '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                    'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
                  ],
                  [
                    '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                    'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
                  ],
                  [
                    '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                    '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
                  ],
                  [
                    '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                    '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
                  ],
                  [
                    '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                    '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
                  ],
                  [
                    '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                    'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
                  ],
                  [
                    'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                    'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
                  ],
                  [
                    '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                    '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
                  ],
                  [
                    '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                    '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
                  ],
                  [
                    'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                    'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
                  ],
                  [
                    '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                    '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
                  ],
                  [
                    'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                    'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
                  ],
                  [
                    'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                    'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
                  ],
                  [
                    '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                    '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
                  ],
                  [
                    '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                    '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
                  ],
                  [
                    '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                    '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
                  ],
                  [
                    'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                    '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
                  ],
                  [
                    '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                    '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
                  ],
                  [
                    'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                    '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
                  ],
                  [
                    '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                    'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
                  ],
                  [
                    '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                    'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
                  ],
                  [
                    'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                    'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
                  ],
                  [
                    '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                    '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
                  ],
                  [
                    '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                    'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
                  ],
                  [
                    'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                    'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
                  ],
                  [
                    '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                    '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
                  ],
                  [
                    '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                    'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
                  ],
                  [
                    '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                    '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
                  ],
                  [
                    '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                    'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
                  ],
                  [
                    'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                    '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
                  ],
                  [
                    '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                    '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
                  ],
                  [
                    '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                    'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
                  ],
                  [
                    '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                    'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
                  ],
                  [
                    'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                    'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
                  ],
                  [
                    'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                    'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
                  ],
                  [
                    '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                    '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
                  ],
                  [
                    '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                    '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
                  ],
                  [
                    'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                    '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
                  ],
                  [
                    'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                    'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
                  ],
                  [
                    '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                    '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
                  ],
                  [
                    '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                    '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
                  ],
                  [
                    'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                    '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
                  ],
                  [
                    '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                    '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
                  ],
                  [
                    'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                    'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
                  ],
                  [
                    '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                    'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
                  ],
                  [
                    '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                    '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
                  ],
                  [
                    'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                    '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
                  ],
                  [
                    'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                    '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
                  ],
                  [
                    '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                    '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
                  ],
                  [
                    '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                    '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
                  ],
                  [
                    '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                    'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
                  ],
                  [
                    '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                    'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
                  ],
                  [
                    '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                    '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
                  ],
                  [
                    '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                    '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
                  ],
                  [
                    '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                    '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
                  ],
                  [
                    '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                    'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
                  ],
                  [
                    'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                    'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
                  ],
                  [
                    '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                    'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
                  ],
                  [
                    'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                    '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
                  ],
                  [
                    'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                    '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
                  ],
                  [
                    'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                    '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
                  ],
                  [
                    'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                    '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
                  ],
                  [
                    '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                    'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
                  ],
                  [
                    '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                    '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
                  ],
                  [
                    '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                    'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
                  ],
                  [
                    'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                    'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
                  ],
                  [
                    'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                    '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
                  ],
                  [
                    'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                    'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
                  ],
                  [
                    'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                    '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
                  ],
                  [
                    '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                    '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
                  ],
                  [
                    'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                    '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
                  ],
                  [
                    'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                    '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
                  ],
                  [
                    '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                    '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
                  ],
                  [
                    '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                    'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
                  ],
                  [
                    'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                    '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
                  ],
                  [
                    'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                    '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
                  ],
                  [
                    'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                    '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
                  ],
                  [
                    '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                    '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
                  ],
                  [
                    'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                    'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
                  ],
                  [
                    '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                    'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
                  ],
                  [
                    'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                    'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
                  ],
                  [
                    'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                    '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
                  ],
                  [
                    '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                    'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
                  ],
                  [
                    'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                    '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
                  ],
                  [
                    'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                    '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
                  ],
                  [
                    'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                    '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
                  ],
                  [
                    '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                    'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
                  ],
                  [
                    '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                    'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
                  ],
                  [
                    'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                    '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
                  ],
                  [
                    '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                    'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
                  ],
                  [
                    '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                    '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
                  ],
                  [
                    '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                    'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
                  ],
                  [
                    'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                    'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
                  ],
                  [
                    '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                    'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
                  ],
                  [
                    '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                    '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
                  ],
                  [
                    '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                    'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
                  ],
                  [
                    '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                    '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
                  ],
                  [
                    'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                    'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
                  ],
                  [
                    '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                    '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
                  ],
                  [
                    'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                    '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
                  ],
                  [
                    '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                    '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
                  ],
                  [
                    'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                    'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
                  ],
                  [
                    'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                    '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
                  ],
                  [
                    'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                    'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
                  ],
                  [
                    '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                    'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
                  ],
                  [
                    '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                    '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
                  ],
                  [
                    '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                    'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
                  ],
                  [
                    '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                    '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
                  ],
                  [
                    '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                    '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
                  ],
                  [
                    '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                    'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
                  ],
                  [
                    '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                    '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
                  ],
                  [
                    '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                    '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
                  ],
                  [
                    '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                    '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
                  ],
                ],
              },
            }
          },
          {},
        ],
        419: [
          function (t, r, i) {
            var s = i,
              o = t('bn.js'),
              a = t('minimalistic-assert'),
              l = t('minimalistic-crypto-utils')
            ;((s.assert = a),
              (s.toArray = l.toArray),
              (s.zero2 = l.zero2),
              (s.toHex = l.toHex),
              (s.encode = l.encode),
              (s.getNAF = function (c, u, f) {
                var d = new Array(Math.max(c.bitLength(), f) + 1)
                d.fill(0)
                for (var h = 1 << (u + 1), p = c.clone(), g = 0; g < d.length; g++) {
                  var m,
                    y = p.andln(h - 1)
                  ;(p.isOdd() ? ((m = y > (h >> 1) - 1 ? (h >> 1) - y : y), p.isubn(m)) : (m = 0),
                    (d[g] = m),
                    p.iushrn(1))
                }
                return d
              }),
              (s.getJSF = function (c, u) {
                var f = [[], []]
                ;((c = c.clone()), (u = u.clone()))
                for (var d, h = 0, p = 0; c.cmpn(-h) > 0 || u.cmpn(-p) > 0; ) {
                  var g,
                    m,
                    y = (c.andln(3) + h) & 3,
                    b = (u.andln(3) + p) & 3
                  ;(y === 3 && (y = -1),
                    b === 3 && (b = -1),
                    (g =
                      1 & y
                        ? ((d = (c.andln(7) + h) & 7) !== 3 && d !== 5) || b !== 2
                          ? y
                          : -y
                        : 0),
                    f[0].push(g),
                    (m =
                      1 & b
                        ? ((d = (u.andln(7) + p) & 7) !== 3 && d !== 5) || y !== 2
                          ? b
                          : -b
                        : 0),
                    f[1].push(m),
                    2 * h === g + 1 && (h = 1 - h),
                    2 * p === m + 1 && (p = 1 - p),
                    c.iushrn(1),
                    u.iushrn(1))
                }
                return f
              }),
              (s.cachedProperty = function (c, u, f) {
                var d = '_' + u
                c.prototype[u] = function () {
                  return this[d] !== void 0 ? this[d] : (this[d] = f.call(this))
                }
              }),
              (s.parseBytes = function (c) {
                return typeof c == 'string' ? s.toArray(c, 'hex') : c
              }),
              (s.intFromLE = function (c) {
                return new o(c, 'hex', 'le')
              }))
          },
          { 'bn.js': 420, 'minimalistic-assert': 453, 'minimalistic-crypto-utils': 454 },
        ],
        420: [
          function (t, r, i) {
            arguments[4][184][0].apply(i, arguments)
          },
          { buffer: 188, dup: 184 },
        ],
        421: [
          function (t, r, i) {
            r.exports = {
              name: 'elliptic',
              version: '6.5.4',
              description: 'EC cryptography',
              main: 'lib/elliptic.js',
              files: ['lib'],
              scripts: {
                lint: 'eslint lib test',
                'lint:fix': 'npm run lint -- --fix',
                unit: 'istanbul test _mocha --reporter=spec test/index.js',
                test: 'npm run lint && npm run unit',
                version: 'grunt dist && git add dist/',
              },
              repository: { type: 'git', url: 'git@github.com:indutny/elliptic' },
              keywords: ['EC', 'Elliptic', 'curve', 'Cryptography'],
              author: 'Fedor Indutny <fedor@indutny.com>',
              license: 'MIT',
              bugs: { url: 'https://github.com/indutny/elliptic/issues' },
              homepage: 'https://github.com/indutny/elliptic',
              devDependencies: {
                brfs: '^2.0.2',
                coveralls: '^3.1.0',
                eslint: '^7.6.0',
                grunt: '^1.2.1',
                'grunt-browserify': '^5.3.0',
                'grunt-cli': '^1.3.2',
                'grunt-contrib-connect': '^3.0.0',
                'grunt-contrib-copy': '^1.0.0',
                'grunt-contrib-uglify': '^5.0.0',
                'grunt-mocha-istanbul': '^5.0.2',
                'grunt-saucelabs': '^9.0.1',
                istanbul: '^0.4.5',
                mocha: '^8.0.1',
              },
              dependencies: {
                'bn.js': '^4.11.9',
                brorand: '^1.1.0',
                'hash.js': '^1.0.0',
                'hmac-drbg': '^1.0.1',
                inherits: '^2.0.4',
                'minimalistic-assert': '^1.0.1',
                'minimalistic-crypto-utils': '^1.0.1',
              },
            }
          },
          {},
        ],
        422: [
          function (t, r, i) {
            var s =
                Object.create ||
                function (E) {
                  var O = function () {}
                  return ((O.prototype = E), new O())
                },
              o =
                Object.keys ||
                function (E) {
                  var O = []
                  for (var P in E) Object.prototype.hasOwnProperty.call(E, P) && O.push(P)
                  return P
                },
              a =
                Function.prototype.bind ||
                function (E) {
                  var O = this
                  return function () {
                    return O.apply(E, arguments)
                  }
                }
            function l() {
              ;((this._events && Object.prototype.hasOwnProperty.call(this, '_events')) ||
                ((this._events = s(null)), (this._eventsCount = 0)),
                (this._maxListeners = this._maxListeners || void 0))
            }
            ;((r.exports = l),
              (l.EventEmitter = l),
              (l.prototype._events = void 0),
              (l.prototype._maxListeners = void 0))
            var c,
              u = 10
            try {
              var f = {}
              ;(Object.defineProperty && Object.defineProperty(f, 'x', { value: 0 }),
                (c = f.x === 0))
            } catch {
              c = !1
            }
            function d(E) {
              return E._maxListeners === void 0 ? l.defaultMaxListeners : E._maxListeners
            }
            function h(E, O, P) {
              if (O) E.call(P)
              else for (var $ = E.length, F = B(E, $), M = 0; M < $; ++M) F[M].call(P)
            }
            function p(E, O, P, $) {
              if (O) E.call(P, $)
              else for (var F = E.length, M = B(E, F), R = 0; R < F; ++R) M[R].call(P, $)
            }
            function g(E, O, P, $, F) {
              if (O) E.call(P, $, F)
              else for (var M = E.length, R = B(E, M), k = 0; k < M; ++k) R[k].call(P, $, F)
            }
            function m(E, O, P, $, F, M) {
              if (O) E.call(P, $, F, M)
              else for (var R = E.length, k = B(E, R), v = 0; v < R; ++v) k[v].call(P, $, F, M)
            }
            function y(E, O, P, $) {
              if (O) E.apply(P, $)
              else for (var F = E.length, M = B(E, F), R = 0; R < F; ++R) M[R].apply(P, $)
            }
            function b(E, O, P, $) {
              var F, M, R
              if (typeof P != 'function')
                throw new TypeError('"listener" argument must be a function')
              if (
                ((M = E._events)
                  ? (M.newListener &&
                      (E.emit('newListener', O, P.listener ? P.listener : P), (M = E._events)),
                    (R = M[O]))
                  : ((M = E._events = s(null)), (E._eventsCount = 0)),
                R)
              ) {
                if (
                  (typeof R == 'function'
                    ? (R = M[O] = $ ? [P, R] : [R, P])
                    : $
                      ? R.unshift(P)
                      : R.push(P),
                  !R.warned && (F = d(E)) && F > 0 && R.length > F)
                ) {
                  R.warned = !0
                  var k = new Error(
                    'Possible EventEmitter memory leak detected. ' +
                      R.length +
                      ' "' +
                      String(O) +
                      '" listeners added. Use emitter.setMaxListeners() to increase limit.',
                  )
                  ;((k.name = 'MaxListenersExceededWarning'),
                    (k.emitter = E),
                    (k.type = O),
                    (k.count = R.length),
                    typeof console == 'object' &&
                      console.warn &&
                      console.warn('%s: %s', k.name, k.message))
                }
              } else ((R = M[O] = P), ++E._eventsCount)
              return E
            }
            function w() {
              if (!this.fired)
                switch (
                  (this.target.removeListener(this.type, this.wrapFn),
                  (this.fired = !0),
                  arguments.length)
                ) {
                  case 0:
                    return this.listener.call(this.target)
                  case 1:
                    return this.listener.call(this.target, arguments[0])
                  case 2:
                    return this.listener.call(this.target, arguments[0], arguments[1])
                  case 3:
                    return this.listener.call(this.target, arguments[0], arguments[1], arguments[2])
                  default:
                    for (var E = new Array(arguments.length), O = 0; O < E.length; ++O)
                      E[O] = arguments[O]
                    this.listener.apply(this.target, E)
                }
            }
            function C(E, O, P) {
              var $ = { fired: !1, wrapFn: void 0, target: E, type: O, listener: P },
                F = a.call(w, $)
              return ((F.listener = P), ($.wrapFn = F), F)
            }
            function T(E, O, P) {
              var $ = E._events
              if (!$) return []
              var F = $[O]
              return F
                ? typeof F == 'function'
                  ? P
                    ? [F.listener || F]
                    : [F]
                  : P
                    ? (function (M) {
                        for (var R = new Array(M.length), k = 0; k < R.length; ++k)
                          R[k] = M[k].listener || M[k]
                        return R
                      })(F)
                    : B(F, F.length)
                : []
            }
            function I(E) {
              var O = this._events
              if (O) {
                var P = O[E]
                if (typeof P == 'function') return 1
                if (P) return P.length
              }
              return 0
            }
            function B(E, O) {
              for (var P = new Array(O), $ = 0; $ < O; ++$) P[$] = E[$]
              return P
            }
            ;(c
              ? Object.defineProperty(l, 'defaultMaxListeners', {
                  enumerable: !0,
                  get: function () {
                    return u
                  },
                  set: function (E) {
                    if (typeof E != 'number' || E < 0 || E != E)
                      throw new TypeError('"defaultMaxListeners" must be a positive number')
                    u = E
                  },
                })
              : (l.defaultMaxListeners = u),
              (l.prototype.setMaxListeners = function (E) {
                if (typeof E != 'number' || E < 0 || isNaN(E))
                  throw new TypeError('"n" argument must be a positive number')
                return ((this._maxListeners = E), this)
              }),
              (l.prototype.getMaxListeners = function () {
                return d(this)
              }),
              (l.prototype.emit = function (E) {
                var O,
                  P,
                  $,
                  F,
                  M,
                  R,
                  k = E === 'error'
                if ((R = this._events)) k = k && R.error == null
                else if (!k) return !1
                if (k) {
                  if ((arguments.length > 1 && (O = arguments[1]), O instanceof Error)) throw O
                  var v = new Error('Unhandled "error" event. (' + O + ')')
                  throw ((v.context = O), v)
                }
                if (!(P = R[E])) return !1
                var x = typeof P == 'function'
                switch (($ = arguments.length)) {
                  case 1:
                    h(P, x, this)
                    break
                  case 2:
                    p(P, x, this, arguments[1])
                    break
                  case 3:
                    g(P, x, this, arguments[1], arguments[2])
                    break
                  case 4:
                    m(P, x, this, arguments[1], arguments[2], arguments[3])
                    break
                  default:
                    for (F = new Array($ - 1), M = 1; M < $; M++) F[M - 1] = arguments[M]
                    y(P, x, this, F)
                }
                return !0
              }),
              (l.prototype.addListener = function (E, O) {
                return b(this, E, O, !1)
              }),
              (l.prototype.on = l.prototype.addListener),
              (l.prototype.prependListener = function (E, O) {
                return b(this, E, O, !0)
              }),
              (l.prototype.once = function (E, O) {
                if (typeof O != 'function')
                  throw new TypeError('"listener" argument must be a function')
                return (this.on(E, C(this, E, O)), this)
              }),
              (l.prototype.prependOnceListener = function (E, O) {
                if (typeof O != 'function')
                  throw new TypeError('"listener" argument must be a function')
                return (this.prependListener(E, C(this, E, O)), this)
              }),
              (l.prototype.removeListener = function (E, O) {
                var P, $, F, M, R
                if (typeof O != 'function')
                  throw new TypeError('"listener" argument must be a function')
                if (!($ = this._events)) return this
                if (!(P = $[E])) return this
                if (P === O || P.listener === O)
                  --this._eventsCount == 0
                    ? (this._events = s(null))
                    : (delete $[E],
                      $.removeListener && this.emit('removeListener', E, P.listener || O))
                else if (typeof P != 'function') {
                  for (F = -1, M = P.length - 1; M >= 0; M--)
                    if (P[M] === O || P[M].listener === O) {
                      ;((R = P[M].listener), (F = M))
                      break
                    }
                  if (F < 0) return this
                  ;(F === 0
                    ? P.shift()
                    : (function (k, v) {
                        for (var x = v, _ = x + 1, S = k.length; _ < S; x += 1, _ += 1) k[x] = k[_]
                        k.pop()
                      })(P, F),
                    P.length === 1 && ($[E] = P[0]),
                    $.removeListener && this.emit('removeListener', E, R || O))
                }
                return this
              }),
              (l.prototype.removeAllListeners = function (E) {
                var O, P, $
                if (!(P = this._events)) return this
                if (!P.removeListener)
                  return (
                    arguments.length === 0
                      ? ((this._events = s(null)), (this._eventsCount = 0))
                      : P[E] && (--this._eventsCount == 0 ? (this._events = s(null)) : delete P[E]),
                    this
                  )
                if (arguments.length === 0) {
                  var F,
                    M = o(P)
                  for ($ = 0; $ < M.length; ++$)
                    (F = M[$]) !== 'removeListener' && this.removeAllListeners(F)
                  return (
                    this.removeAllListeners('removeListener'),
                    (this._events = s(null)),
                    (this._eventsCount = 0),
                    this
                  )
                }
                if (typeof (O = P[E]) == 'function') this.removeListener(E, O)
                else if (O) for ($ = O.length - 1; $ >= 0; $--) this.removeListener(E, O[$])
                return this
              }),
              (l.prototype.listeners = function (E) {
                return T(this, E, !0)
              }),
              (l.prototype.rawListeners = function (E) {
                return T(this, E, !1)
              }),
              (l.listenerCount = function (E, O) {
                return typeof E.listenerCount == 'function' ? E.listenerCount(O) : I.call(E, O)
              }),
              (l.prototype.listenerCount = I),
              (l.prototype.eventNames = function () {
                return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : []
              }))
          },
          {},
        ],
        423: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('md5.js')
            r.exports = function (a, l, c, u) {
              if (
                (s.isBuffer(a) || (a = s.from(a, 'binary')),
                l && (s.isBuffer(l) || (l = s.from(l, 'binary')), l.length !== 8))
              )
                throw new RangeError('salt should be Buffer with 8 byte length')
              for (
                var f = c / 8, d = s.alloc(f), h = s.alloc(u || 0), p = s.alloc(0);
                f > 0 || u > 0;

              ) {
                var g = new o()
                ;(g.update(p), g.update(a), l && g.update(l), (p = g.digest()))
                var m = 0
                if (f > 0) {
                  var y = d.length - f
                  ;((m = Math.min(f, p.length)), p.copy(d, y, 0, m), (f -= m))
                }
                if (m < p.length && u > 0) {
                  var b = h.length - u,
                    w = Math.min(u, p.length - m)
                  ;(p.copy(h, b, m, m + w), (u -= w))
                }
              }
              return (p.fill(0), { key: d, iv: h })
            }
          },
          { 'md5.js': 450, 'safe-buffer': 494 },
        ],
        424: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.CsvParserStream =
                i.ParserOptions =
                i.parseFile =
                i.parseStream =
                i.parseString =
                i.parse =
                i.FormatterOptions =
                i.CsvFormatterStream =
                i.writeToPath =
                i.writeToString =
                i.writeToBuffer =
                i.writeToStream =
                i.write =
                i.format =
                  void 0))
            var s = t('@fast-csv/format')
            ;(Object.defineProperty(i, 'format', {
              enumerable: !0,
              get: function () {
                return s.format
              },
            }),
              Object.defineProperty(i, 'write', {
                enumerable: !0,
                get: function () {
                  return s.write
                },
              }),
              Object.defineProperty(i, 'writeToStream', {
                enumerable: !0,
                get: function () {
                  return s.writeToStream
                },
              }),
              Object.defineProperty(i, 'writeToBuffer', {
                enumerable: !0,
                get: function () {
                  return s.writeToBuffer
                },
              }),
              Object.defineProperty(i, 'writeToString', {
                enumerable: !0,
                get: function () {
                  return s.writeToString
                },
              }),
              Object.defineProperty(i, 'writeToPath', {
                enumerable: !0,
                get: function () {
                  return s.writeToPath
                },
              }),
              Object.defineProperty(i, 'CsvFormatterStream', {
                enumerable: !0,
                get: function () {
                  return s.CsvFormatterStream
                },
              }),
              Object.defineProperty(i, 'FormatterOptions', {
                enumerable: !0,
                get: function () {
                  return s.FormatterOptions
                },
              }))
            var o = t('@fast-csv/parse')
            ;(Object.defineProperty(i, 'parse', {
              enumerable: !0,
              get: function () {
                return o.parse
              },
            }),
              Object.defineProperty(i, 'parseString', {
                enumerable: !0,
                get: function () {
                  return o.parseString
                },
              }),
              Object.defineProperty(i, 'parseStream', {
                enumerable: !0,
                get: function () {
                  return o.parseStream
                },
              }),
              Object.defineProperty(i, 'parseFile', {
                enumerable: !0,
                get: function () {
                  return o.parseFile
                },
              }),
              Object.defineProperty(i, 'ParserOptions', {
                enumerable: !0,
                get: function () {
                  return o.ParserOptions
                },
              }),
              Object.defineProperty(i, 'CsvParserStream', {
                enumerable: !0,
                get: function () {
                  return o.CsvParserStream
                },
              }))
          },
          { '@fast-csv/format': 151, '@fast-csv/parse': 155 },
        ],
        425: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('readable-stream').Transform
            function a(l) {
              ;(o.call(this),
                (this._block = s.allocUnsafe(l)),
                (this._blockSize = l),
                (this._blockOffset = 0),
                (this._length = [0, 0, 0, 0]),
                (this._finalized = !1))
            }
            ;(t('inherits')(a, o),
              (a.prototype._transform = function (l, c, u) {
                var f = null
                try {
                  this.update(l, c)
                } catch (d) {
                  f = d
                }
                u(f)
              }),
              (a.prototype._flush = function (l) {
                var c = null
                try {
                  this.push(this.digest())
                } catch (u) {
                  c = u
                }
                l(c)
              }),
              (a.prototype.update = function (l, c) {
                if (
                  ((function (g, m) {
                    if (!s.isBuffer(g) && typeof g != 'string')
                      throw new TypeError(m + ' must be a string or a buffer')
                  })(l, 'Data'),
                  this._finalized)
                )
                  throw new Error('Digest already called')
                s.isBuffer(l) || (l = s.from(l, c))
                for (
                  var u = this._block, f = 0;
                  this._blockOffset + l.length - f >= this._blockSize;

                ) {
                  for (var d = this._blockOffset; d < this._blockSize; ) u[d++] = l[f++]
                  ;(this._update(), (this._blockOffset = 0))
                }
                for (; f < l.length; ) u[this._blockOffset++] = l[f++]
                for (var h = 0, p = 8 * l.length; p > 0; ++h)
                  ((this._length[h] += p),
                    (p = (this._length[h] / 4294967296) | 0) > 0 &&
                      (this._length[h] -= 4294967296 * p))
                return this
              }),
              (a.prototype._update = function () {
                throw new Error('_update is not implemented')
              }),
              (a.prototype.digest = function (l) {
                if (this._finalized) throw new Error('Digest already called')
                this._finalized = !0
                var c = this._digest()
                ;(l !== void 0 && (c = c.toString(l)), this._block.fill(0), (this._blockOffset = 0))
                for (var u = 0; u < 4; ++u) this._length[u] = 0
                return c
              }),
              (a.prototype._digest = function () {
                throw new Error('_digest is not implemented')
              }),
              (r.exports = a))
          },
          { inherits: 440, 'readable-stream': 491, 'safe-buffer': 494 },
        ],
        426: [
          function (t, r, i) {
            var s = i
            ;((s.utils = t('./hash/utils')),
              (s.common = t('./hash/common')),
              (s.sha = t('./hash/sha')),
              (s.ripemd = t('./hash/ripemd')),
              (s.hmac = t('./hash/hmac')),
              (s.sha1 = s.sha.sha1),
              (s.sha256 = s.sha.sha256),
              (s.sha224 = s.sha.sha224),
              (s.sha384 = s.sha.sha384),
              (s.sha512 = s.sha.sha512),
              (s.ripemd160 = s.ripemd.ripemd160))
          },
          {
            './hash/common': 427,
            './hash/hmac': 428,
            './hash/ripemd': 429,
            './hash/sha': 430,
            './hash/utils': 437,
          },
        ],
        427: [
          function (t, r, i) {
            var s = t('./utils'),
              o = t('minimalistic-assert')
            function a() {
              ;((this.pending = null),
                (this.pendingTotal = 0),
                (this.blockSize = this.constructor.blockSize),
                (this.outSize = this.constructor.outSize),
                (this.hmacStrength = this.constructor.hmacStrength),
                (this.padLength = this.constructor.padLength / 8),
                (this.endian = 'big'),
                (this._delta8 = this.blockSize / 8),
                (this._delta32 = this.blockSize / 32))
            }
            ;((i.BlockHash = a),
              (a.prototype.update = function (l, c) {
                if (
                  ((l = s.toArray(l, c)),
                  this.pending ? (this.pending = this.pending.concat(l)) : (this.pending = l),
                  (this.pendingTotal += l.length),
                  this.pending.length >= this._delta8)
                ) {
                  var u = (l = this.pending).length % this._delta8
                  ;((this.pending = l.slice(l.length - u, l.length)),
                    this.pending.length === 0 && (this.pending = null),
                    (l = s.join32(l, 0, l.length - u, this.endian)))
                  for (var f = 0; f < l.length; f += this._delta32)
                    this._update(l, f, f + this._delta32)
                }
                return this
              }),
              (a.prototype.digest = function (l) {
                return (this.update(this._pad()), o(this.pending === null), this._digest(l))
              }),
              (a.prototype._pad = function () {
                var l = this.pendingTotal,
                  c = this._delta8,
                  u = c - ((l + this.padLength) % c),
                  f = new Array(u + this.padLength)
                f[0] = 128
                for (var d = 1; d < u; d++) f[d] = 0
                if (((l <<= 3), this.endian === 'big')) {
                  for (var h = 8; h < this.padLength; h++) f[d++] = 0
                  ;((f[d++] = 0),
                    (f[d++] = 0),
                    (f[d++] = 0),
                    (f[d++] = 0),
                    (f[d++] = (l >>> 24) & 255),
                    (f[d++] = (l >>> 16) & 255),
                    (f[d++] = (l >>> 8) & 255),
                    (f[d++] = 255 & l))
                } else
                  for (
                    f[d++] = 255 & l,
                      f[d++] = (l >>> 8) & 255,
                      f[d++] = (l >>> 16) & 255,
                      f[d++] = (l >>> 24) & 255,
                      f[d++] = 0,
                      f[d++] = 0,
                      f[d++] = 0,
                      f[d++] = 0,
                      h = 8;
                    h < this.padLength;
                    h++
                  )
                    f[d++] = 0
                return f
              }))
          },
          { './utils': 437, 'minimalistic-assert': 453 },
        ],
        428: [
          function (t, r, i) {
            var s = t('./utils'),
              o = t('minimalistic-assert')
            function a(l, c, u) {
              if (!(this instanceof a)) return new a(l, c, u)
              ;((this.Hash = l),
                (this.blockSize = l.blockSize / 8),
                (this.outSize = l.outSize / 8),
                (this.inner = null),
                (this.outer = null),
                this._init(s.toArray(c, u)))
            }
            ;((r.exports = a),
              (a.prototype._init = function (l) {
                ;(l.length > this.blockSize && (l = new this.Hash().update(l).digest()),
                  o(l.length <= this.blockSize))
                for (var c = l.length; c < this.blockSize; c++) l.push(0)
                for (c = 0; c < l.length; c++) l[c] ^= 54
                for (this.inner = new this.Hash().update(l), c = 0; c < l.length; c++) l[c] ^= 106
                this.outer = new this.Hash().update(l)
              }),
              (a.prototype.update = function (l, c) {
                return (this.inner.update(l, c), this)
              }),
              (a.prototype.digest = function (l) {
                return (this.outer.update(this.inner.digest()), this.outer.digest(l))
              }))
          },
          { './utils': 437, 'minimalistic-assert': 453 },
        ],
        429: [
          function (t, r, i) {
            var s = t('./utils'),
              o = t('./common'),
              a = s.rotl32,
              l = s.sum32,
              c = s.sum32_3,
              u = s.sum32_4,
              f = o.BlockHash
            function d() {
              if (!(this instanceof d)) return new d()
              ;(f.call(this),
                (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
                (this.endian = 'little'))
            }
            function h(C, T, I, B) {
              return C <= 15
                ? T ^ I ^ B
                : C <= 31
                  ? (T & I) | (~T & B)
                  : C <= 47
                    ? (T | ~I) ^ B
                    : C <= 63
                      ? (T & B) | (I & ~B)
                      : T ^ (I | ~B)
            }
            function p(C) {
              return C <= 15
                ? 0
                : C <= 31
                  ? 1518500249
                  : C <= 47
                    ? 1859775393
                    : C <= 63
                      ? 2400959708
                      : 2840853838
            }
            function g(C) {
              return C <= 15
                ? 1352829926
                : C <= 31
                  ? 1548603684
                  : C <= 47
                    ? 1836072691
                    : C <= 63
                      ? 2053994217
                      : 0
            }
            ;(s.inherits(d, f),
              (i.ripemd160 = d),
              (d.blockSize = 512),
              (d.outSize = 160),
              (d.hmacStrength = 192),
              (d.padLength = 64),
              (d.prototype._update = function (C, T) {
                for (
                  var I = this.h[0],
                    B = this.h[1],
                    E = this.h[2],
                    O = this.h[3],
                    P = this.h[4],
                    $ = I,
                    F = B,
                    M = E,
                    R = O,
                    k = P,
                    v = 0;
                  v < 80;
                  v++
                ) {
                  var x = l(a(u(I, h(v, B, E, O), C[m[v] + T], p(v)), b[v]), P)
                  ;((I = P),
                    (P = O),
                    (O = a(E, 10)),
                    (E = B),
                    (B = x),
                    (x = l(a(u($, h(79 - v, F, M, R), C[y[v] + T], g(v)), w[v]), k)),
                    ($ = k),
                    (k = R),
                    (R = a(M, 10)),
                    (M = F),
                    (F = x))
                }
                ;((x = c(this.h[1], E, R)),
                  (this.h[1] = c(this.h[2], O, k)),
                  (this.h[2] = c(this.h[3], P, $)),
                  (this.h[3] = c(this.h[4], I, F)),
                  (this.h[4] = c(this.h[0], B, M)),
                  (this.h[0] = x))
              }),
              (d.prototype._digest = function (C) {
                return C === 'hex' ? s.toHex32(this.h, 'little') : s.split32(this.h, 'little')
              }))
            var m = [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12,
                0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9,
                11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3,
                8, 11, 6, 15, 13,
              ],
              y = [
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14,
                15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6,
                4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13,
                14, 0, 3, 9, 11,
              ],
              b = [
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15,
                7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12,
                5, 12, 13, 14, 11, 8, 5, 6,
              ],
              w = [
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11,
                7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6,
                8, 13, 6, 5, 15, 13, 11, 11,
              ]
          },
          { './common': 427, './utils': 437 },
        ],
        430: [
          function (t, r, i) {
            ;((i.sha1 = t('./sha/1')),
              (i.sha224 = t('./sha/224')),
              (i.sha256 = t('./sha/256')),
              (i.sha384 = t('./sha/384')),
              (i.sha512 = t('./sha/512')))
          },
          {
            './sha/1': 431,
            './sha/224': 432,
            './sha/256': 433,
            './sha/384': 434,
            './sha/512': 435,
          },
        ],
        431: [
          function (t, r, i) {
            var s = t('../utils'),
              o = t('../common'),
              a = t('./common'),
              l = s.rotl32,
              c = s.sum32,
              u = s.sum32_5,
              f = a.ft_1,
              d = o.BlockHash,
              h = [1518500249, 1859775393, 2400959708, 3395469782]
            function p() {
              if (!(this instanceof p)) return new p()
              ;(d.call(this),
                (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
                (this.W = new Array(80)))
            }
            ;(s.inherits(p, d),
              (r.exports = p),
              (p.blockSize = 512),
              (p.outSize = 160),
              (p.hmacStrength = 80),
              (p.padLength = 64),
              (p.prototype._update = function (g, m) {
                for (var y = this.W, b = 0; b < 16; b++) y[b] = g[m + b]
                for (; b < y.length; b++) y[b] = l(y[b - 3] ^ y[b - 8] ^ y[b - 14] ^ y[b - 16], 1)
                var w = this.h[0],
                  C = this.h[1],
                  T = this.h[2],
                  I = this.h[3],
                  B = this.h[4]
                for (b = 0; b < y.length; b++) {
                  var E = ~~(b / 20),
                    O = u(l(w, 5), f(E, C, T, I), B, y[b], h[E])
                  ;((B = I), (I = T), (T = l(C, 30)), (C = w), (w = O))
                }
                ;((this.h[0] = c(this.h[0], w)),
                  (this.h[1] = c(this.h[1], C)),
                  (this.h[2] = c(this.h[2], T)),
                  (this.h[3] = c(this.h[3], I)),
                  (this.h[4] = c(this.h[4], B)))
              }),
              (p.prototype._digest = function (g) {
                return g === 'hex' ? s.toHex32(this.h, 'big') : s.split32(this.h, 'big')
              }))
          },
          { '../common': 427, '../utils': 437, './common': 436 },
        ],
        432: [
          function (t, r, i) {
            var s = t('../utils'),
              o = t('./256')
            function a() {
              if (!(this instanceof a)) return new a()
              ;(o.call(this),
                (this.h = [
                  3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839,
                  3204075428,
                ]))
            }
            ;(s.inherits(a, o),
              (r.exports = a),
              (a.blockSize = 512),
              (a.outSize = 224),
              (a.hmacStrength = 192),
              (a.padLength = 64),
              (a.prototype._digest = function (l) {
                return l === 'hex'
                  ? s.toHex32(this.h.slice(0, 7), 'big')
                  : s.split32(this.h.slice(0, 7), 'big')
              }))
          },
          { '../utils': 437, './256': 433 },
        ],
        433: [
          function (t, r, i) {
            var s = t('../utils'),
              o = t('../common'),
              a = t('./common'),
              l = t('minimalistic-assert'),
              c = s.sum32,
              u = s.sum32_4,
              f = s.sum32_5,
              d = a.ch32,
              h = a.maj32,
              p = a.s0_256,
              g = a.s1_256,
              m = a.g0_256,
              y = a.g1_256,
              b = o.BlockHash,
              w = [
                1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,
                2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
                2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
                1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
                3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372,
                1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
                3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734,
                506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
                1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
                3329325298,
              ]
            function C() {
              if (!(this instanceof C)) return new C()
              ;(b.call(this),
                (this.h = [
                  1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,
                  1541459225,
                ]),
                (this.k = w),
                (this.W = new Array(64)))
            }
            ;(s.inherits(C, b),
              (r.exports = C),
              (C.blockSize = 512),
              (C.outSize = 256),
              (C.hmacStrength = 192),
              (C.padLength = 64),
              (C.prototype._update = function (T, I) {
                for (var B = this.W, E = 0; E < 16; E++) B[E] = T[I + E]
                for (; E < B.length; E++) B[E] = u(y(B[E - 2]), B[E - 7], m(B[E - 15]), B[E - 16])
                var O = this.h[0],
                  P = this.h[1],
                  $ = this.h[2],
                  F = this.h[3],
                  M = this.h[4],
                  R = this.h[5],
                  k = this.h[6],
                  v = this.h[7]
                for (l(this.k.length === B.length), E = 0; E < B.length; E++) {
                  var x = f(v, g(M), d(M, R, k), this.k[E], B[E]),
                    _ = c(p(O), h(O, P, $))
                  ;((v = k),
                    (k = R),
                    (R = M),
                    (M = c(F, x)),
                    (F = $),
                    ($ = P),
                    (P = O),
                    (O = c(x, _)))
                }
                ;((this.h[0] = c(this.h[0], O)),
                  (this.h[1] = c(this.h[1], P)),
                  (this.h[2] = c(this.h[2], $)),
                  (this.h[3] = c(this.h[3], F)),
                  (this.h[4] = c(this.h[4], M)),
                  (this.h[5] = c(this.h[5], R)),
                  (this.h[6] = c(this.h[6], k)),
                  (this.h[7] = c(this.h[7], v)))
              }),
              (C.prototype._digest = function (T) {
                return T === 'hex' ? s.toHex32(this.h, 'big') : s.split32(this.h, 'big')
              }))
          },
          { '../common': 427, '../utils': 437, './common': 436, 'minimalistic-assert': 453 },
        ],
        434: [
          function (t, r, i) {
            var s = t('../utils'),
              o = t('./512')
            function a() {
              if (!(this instanceof a)) return new a()
              ;(o.call(this),
                (this.h = [
                  3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360,
                  4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525,
                  1694076839, 1203062813, 3204075428,
                ]))
            }
            ;(s.inherits(a, o),
              (r.exports = a),
              (a.blockSize = 1024),
              (a.outSize = 384),
              (a.hmacStrength = 192),
              (a.padLength = 128),
              (a.prototype._digest = function (l) {
                return l === 'hex'
                  ? s.toHex32(this.h.slice(0, 12), 'big')
                  : s.split32(this.h.slice(0, 12), 'big')
              }))
          },
          { '../utils': 437, './512': 435 },
        ],
        435: [
          function (t, r, i) {
            var s = t('../utils'),
              o = t('../common'),
              a = t('minimalistic-assert'),
              l = s.rotr64_hi,
              c = s.rotr64_lo,
              u = s.shr64_hi,
              f = s.shr64_lo,
              d = s.sum64,
              h = s.sum64_hi,
              p = s.sum64_lo,
              g = s.sum64_4_hi,
              m = s.sum64_4_lo,
              y = s.sum64_5_hi,
              b = s.sum64_5_lo,
              w = o.BlockHash,
              C = [
                1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573,
                2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579,
                2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278,
                1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113,
                2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774,
                944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
                1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882,
                3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956,
                3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895,
                168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485,
                1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350,
                1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
                3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804,
                1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752,
                506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571,
                3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
                1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424,
                442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
                3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606,
                3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270,
                289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971,
                1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158,
                1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
              ]
            function T() {
              if (!(this instanceof T)) return new T()
              ;(w.call(this),
                (this.h = [
                  1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
                  2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635,
                  4215389547, 1541459225, 327033209,
                ]),
                (this.k = C),
                (this.W = new Array(160)))
            }
            function I(_, S, A, j, L) {
              var H = (_ & A) ^ (~_ & L)
              return (H < 0 && (H += 4294967296), H)
            }
            function B(_, S, A, j, L, H) {
              var U = (S & j) ^ (~S & H)
              return (U < 0 && (U += 4294967296), U)
            }
            function E(_, S, A, j, L) {
              var H = (_ & A) ^ (_ & L) ^ (A & L)
              return (H < 0 && (H += 4294967296), H)
            }
            function O(_, S, A, j, L, H) {
              var U = (S & j) ^ (S & H) ^ (j & H)
              return (U < 0 && (U += 4294967296), U)
            }
            function P(_, S) {
              var A = l(_, S, 28) ^ l(S, _, 2) ^ l(S, _, 7)
              return (A < 0 && (A += 4294967296), A)
            }
            function $(_, S) {
              var A = c(_, S, 28) ^ c(S, _, 2) ^ c(S, _, 7)
              return (A < 0 && (A += 4294967296), A)
            }
            function F(_, S) {
              var A = l(_, S, 14) ^ l(_, S, 18) ^ l(S, _, 9)
              return (A < 0 && (A += 4294967296), A)
            }
            function M(_, S) {
              var A = c(_, S, 14) ^ c(_, S, 18) ^ c(S, _, 9)
              return (A < 0 && (A += 4294967296), A)
            }
            function R(_, S) {
              var A = l(_, S, 1) ^ l(_, S, 8) ^ u(_, S, 7)
              return (A < 0 && (A += 4294967296), A)
            }
            function k(_, S) {
              var A = c(_, S, 1) ^ c(_, S, 8) ^ f(_, S, 7)
              return (A < 0 && (A += 4294967296), A)
            }
            function v(_, S) {
              var A = l(_, S, 19) ^ l(S, _, 29) ^ u(_, S, 6)
              return (A < 0 && (A += 4294967296), A)
            }
            function x(_, S) {
              var A = c(_, S, 19) ^ c(S, _, 29) ^ f(_, S, 6)
              return (A < 0 && (A += 4294967296), A)
            }
            ;(s.inherits(T, w),
              (r.exports = T),
              (T.blockSize = 1024),
              (T.outSize = 512),
              (T.hmacStrength = 192),
              (T.padLength = 128),
              (T.prototype._prepareBlock = function (_, S) {
                for (var A = this.W, j = 0; j < 32; j++) A[j] = _[S + j]
                for (; j < A.length; j += 2) {
                  var L = v(A[j - 4], A[j - 3]),
                    H = x(A[j - 4], A[j - 3]),
                    U = A[j - 14],
                    K = A[j - 13],
                    z = R(A[j - 30], A[j - 29]),
                    q = k(A[j - 30], A[j - 29]),
                    D = A[j - 32],
                    N = A[j - 31]
                  ;((A[j] = g(L, H, U, K, z, q, D, N)), (A[j + 1] = m(L, H, U, K, z, q, D, N)))
                }
              }),
              (T.prototype._update = function (_, S) {
                this._prepareBlock(_, S)
                var A = this.W,
                  j = this.h[0],
                  L = this.h[1],
                  H = this.h[2],
                  U = this.h[3],
                  K = this.h[4],
                  z = this.h[5],
                  q = this.h[6],
                  D = this.h[7],
                  N = this.h[8],
                  V = this.h[9],
                  W = this.h[10],
                  J = this.h[11],
                  G = this.h[12],
                  Z = this.h[13],
                  rt = this.h[14],
                  nt = this.h[15]
                a(this.k.length === A.length)
                for (var X = 0; X < A.length; X += 2) {
                  var Q = rt,
                    tt = nt,
                    st = F(N, V),
                    ot = M(N, V),
                    at = I(N, V, W, J, G),
                    ht = B(N, V, W, J, G, Z),
                    dt = this.k[X],
                    mt = this.k[X + 1],
                    bt = A[X],
                    yt = A[X + 1],
                    vt = y(Q, tt, st, ot, at, ht, dt, mt, bt, yt),
                    Nt = b(Q, tt, st, ot, at, ht, dt, mt, bt, yt)
                  ;((Q = P(j, L)),
                    (tt = $(j, L)),
                    (st = E(j, L, H, U, K)),
                    (ot = O(j, L, H, U, K, z)))
                  var Dt = h(Q, tt, st, ot),
                    Mt = p(Q, tt, st, ot)
                  ;((rt = G),
                    (nt = Z),
                    (G = W),
                    (Z = J),
                    (W = N),
                    (J = V),
                    (N = h(q, D, vt, Nt)),
                    (V = p(D, D, vt, Nt)),
                    (q = K),
                    (D = z),
                    (K = H),
                    (z = U),
                    (H = j),
                    (U = L),
                    (j = h(vt, Nt, Dt, Mt)),
                    (L = p(vt, Nt, Dt, Mt)))
                }
                ;(d(this.h, 0, j, L),
                  d(this.h, 2, H, U),
                  d(this.h, 4, K, z),
                  d(this.h, 6, q, D),
                  d(this.h, 8, N, V),
                  d(this.h, 10, W, J),
                  d(this.h, 12, G, Z),
                  d(this.h, 14, rt, nt))
              }),
              (T.prototype._digest = function (_) {
                return _ === 'hex' ? s.toHex32(this.h, 'big') : s.split32(this.h, 'big')
              }))
          },
          { '../common': 427, '../utils': 437, 'minimalistic-assert': 453 },
        ],
        436: [
          function (t, r, i) {
            var s = t('../utils').rotr32
            function o(c, u, f) {
              return (c & u) ^ (~c & f)
            }
            function a(c, u, f) {
              return (c & u) ^ (c & f) ^ (u & f)
            }
            function l(c, u, f) {
              return c ^ u ^ f
            }
            ;((i.ft_1 = function (c, u, f, d) {
              return c === 0
                ? o(u, f, d)
                : c === 1 || c === 3
                  ? l(u, f, d)
                  : c === 2
                    ? a(u, f, d)
                    : void 0
            }),
              (i.ch32 = o),
              (i.maj32 = a),
              (i.p32 = l),
              (i.s0_256 = function (c) {
                return s(c, 2) ^ s(c, 13) ^ s(c, 22)
              }),
              (i.s1_256 = function (c) {
                return s(c, 6) ^ s(c, 11) ^ s(c, 25)
              }),
              (i.g0_256 = function (c) {
                return s(c, 7) ^ s(c, 18) ^ (c >>> 3)
              }),
              (i.g1_256 = function (c) {
                return s(c, 17) ^ s(c, 19) ^ (c >>> 10)
              }))
          },
          { '../utils': 437 },
        ],
        437: [
          function (t, r, i) {
            var s = t('minimalistic-assert'),
              o = t('inherits')
            function a(f, d) {
              return (
                (64512 & f.charCodeAt(d)) == 55296 &&
                !(d < 0 || d + 1 >= f.length) &&
                (64512 & f.charCodeAt(d + 1)) == 56320
              )
            }
            function l(f) {
              return (
                ((f >>> 24) | ((f >>> 8) & 65280) | ((f << 8) & 16711680) | ((255 & f) << 24)) >>> 0
              )
            }
            function c(f) {
              return f.length === 1 ? '0' + f : f
            }
            function u(f) {
              return f.length === 7
                ? '0' + f
                : f.length === 6
                  ? '00' + f
                  : f.length === 5
                    ? '000' + f
                    : f.length === 4
                      ? '0000' + f
                      : f.length === 3
                        ? '00000' + f
                        : f.length === 2
                          ? '000000' + f
                          : f.length === 1
                            ? '0000000' + f
                            : f
            }
            ;((i.inherits = o),
              (i.toArray = function (f, d) {
                if (Array.isArray(f)) return f.slice()
                if (!f) return []
                var h = []
                if (typeof f == 'string')
                  if (d) {
                    if (d === 'hex')
                      for (
                        (f = f.replace(/[^a-z0-9]+/gi, '')).length % 2 != 0 && (f = '0' + f), g = 0;
                        g < f.length;
                        g += 2
                      )
                        h.push(parseInt(f[g] + f[g + 1], 16))
                  } else
                    for (var p = 0, g = 0; g < f.length; g++) {
                      var m = f.charCodeAt(g)
                      m < 128
                        ? (h[p++] = m)
                        : m < 2048
                          ? ((h[p++] = (m >> 6) | 192), (h[p++] = (63 & m) | 128))
                          : a(f, g)
                            ? ((m = 65536 + ((1023 & m) << 10) + (1023 & f.charCodeAt(++g))),
                              (h[p++] = (m >> 18) | 240),
                              (h[p++] = ((m >> 12) & 63) | 128),
                              (h[p++] = ((m >> 6) & 63) | 128),
                              (h[p++] = (63 & m) | 128))
                            : ((h[p++] = (m >> 12) | 224),
                              (h[p++] = ((m >> 6) & 63) | 128),
                              (h[p++] = (63 & m) | 128))
                    }
                else for (g = 0; g < f.length; g++) h[g] = 0 | f[g]
                return h
              }),
              (i.toHex = function (f) {
                for (var d = '', h = 0; h < f.length; h++) d += c(f[h].toString(16))
                return d
              }),
              (i.htonl = l),
              (i.toHex32 = function (f, d) {
                for (var h = '', p = 0; p < f.length; p++) {
                  var g = f[p]
                  ;(d === 'little' && (g = l(g)), (h += u(g.toString(16))))
                }
                return h
              }),
              (i.zero2 = c),
              (i.zero8 = u),
              (i.join32 = function (f, d, h, p) {
                var g = h - d
                s(g % 4 == 0)
                for (var m = new Array(g / 4), y = 0, b = d; y < m.length; y++, b += 4) {
                  var w
                  ;((w =
                    p === 'big'
                      ? (f[b] << 24) | (f[b + 1] << 16) | (f[b + 2] << 8) | f[b + 3]
                      : (f[b + 3] << 24) | (f[b + 2] << 16) | (f[b + 1] << 8) | f[b]),
                    (m[y] = w >>> 0))
                }
                return m
              }),
              (i.split32 = function (f, d) {
                for (var h = new Array(4 * f.length), p = 0, g = 0; p < f.length; p++, g += 4) {
                  var m = f[p]
                  d === 'big'
                    ? ((h[g] = m >>> 24),
                      (h[g + 1] = (m >>> 16) & 255),
                      (h[g + 2] = (m >>> 8) & 255),
                      (h[g + 3] = 255 & m))
                    : ((h[g + 3] = m >>> 24),
                      (h[g + 2] = (m >>> 16) & 255),
                      (h[g + 1] = (m >>> 8) & 255),
                      (h[g] = 255 & m))
                }
                return h
              }),
              (i.rotr32 = function (f, d) {
                return (f >>> d) | (f << (32 - d))
              }),
              (i.rotl32 = function (f, d) {
                return (f << d) | (f >>> (32 - d))
              }),
              (i.sum32 = function (f, d) {
                return (f + d) >>> 0
              }),
              (i.sum32_3 = function (f, d, h) {
                return (f + d + h) >>> 0
              }),
              (i.sum32_4 = function (f, d, h, p) {
                return (f + d + h + p) >>> 0
              }),
              (i.sum32_5 = function (f, d, h, p, g) {
                return (f + d + h + p + g) >>> 0
              }),
              (i.sum64 = function (f, d, h, p) {
                var g = f[d],
                  m = (p + f[d + 1]) >>> 0,
                  y = (m < p ? 1 : 0) + h + g
                ;((f[d] = y >>> 0), (f[d + 1] = m))
              }),
              (i.sum64_hi = function (f, d, h, p) {
                return (((d + p) >>> 0 < d ? 1 : 0) + f + h) >>> 0
              }),
              (i.sum64_lo = function (f, d, h, p) {
                return (d + p) >>> 0
              }),
              (i.sum64_4_hi = function (f, d, h, p, g, m, y, b) {
                var w = 0,
                  C = d
                return (
                  (w += (C = (C + p) >>> 0) < d ? 1 : 0),
                  (w += (C = (C + m) >>> 0) < m ? 1 : 0),
                  (f + h + g + y + (w += (C = (C + b) >>> 0) < b ? 1 : 0)) >>> 0
                )
              }),
              (i.sum64_4_lo = function (f, d, h, p, g, m, y, b) {
                return (d + p + m + b) >>> 0
              }),
              (i.sum64_5_hi = function (f, d, h, p, g, m, y, b, w, C) {
                var T = 0,
                  I = d
                return (
                  (T += (I = (I + p) >>> 0) < d ? 1 : 0),
                  (T += (I = (I + m) >>> 0) < m ? 1 : 0),
                  (T += (I = (I + b) >>> 0) < b ? 1 : 0),
                  (f + h + g + y + w + (T += (I = (I + C) >>> 0) < C ? 1 : 0)) >>> 0
                )
              }),
              (i.sum64_5_lo = function (f, d, h, p, g, m, y, b, w, C) {
                return (d + p + m + b + C) >>> 0
              }),
              (i.rotr64_hi = function (f, d, h) {
                return ((d << (32 - h)) | (f >>> h)) >>> 0
              }),
              (i.rotr64_lo = function (f, d, h) {
                return ((f << (32 - h)) | (d >>> h)) >>> 0
              }),
              (i.shr64_hi = function (f, d, h) {
                return f >>> h
              }),
              (i.shr64_lo = function (f, d, h) {
                return ((f << (32 - h)) | (d >>> h)) >>> 0
              }))
          },
          { inherits: 440, 'minimalistic-assert': 453 },
        ],
        438: [
          function (t, r, i) {
            var s = t('hash.js'),
              o = t('minimalistic-crypto-utils'),
              a = t('minimalistic-assert')
            function l(c) {
              if (!(this instanceof l)) return new l(c)
              ;((this.hash = c.hash),
                (this.predResist = !!c.predResist),
                (this.outLen = this.hash.outSize),
                (this.minEntropy = c.minEntropy || this.hash.hmacStrength),
                (this._reseed = null),
                (this.reseedInterval = null),
                (this.K = null),
                (this.V = null))
              var u = o.toArray(c.entropy, c.entropyEnc || 'hex'),
                f = o.toArray(c.nonce, c.nonceEnc || 'hex'),
                d = o.toArray(c.pers, c.persEnc || 'hex')
              ;(a(
                u.length >= this.minEntropy / 8,
                'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits',
              ),
                this._init(u, f, d))
            }
            ;((r.exports = l),
              (l.prototype._init = function (c, u, f) {
                var d = c.concat(u).concat(f)
                ;((this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8)))
                for (var h = 0; h < this.V.length; h++) ((this.K[h] = 0), (this.V[h] = 1))
                ;(this._update(d), (this._reseed = 1), (this.reseedInterval = 281474976710656))
              }),
              (l.prototype._hmac = function () {
                return new s.hmac(this.hash, this.K)
              }),
              (l.prototype._update = function (c) {
                var u = this._hmac().update(this.V).update([0])
                ;(c && (u = u.update(c)),
                  (this.K = u.digest()),
                  (this.V = this._hmac().update(this.V).digest()),
                  c &&
                    ((this.K = this._hmac().update(this.V).update([1]).update(c).digest()),
                    (this.V = this._hmac().update(this.V).digest())))
              }),
              (l.prototype.reseed = function (c, u, f, d) {
                ;(typeof u != 'string' && ((d = f), (f = u), (u = null)),
                  (c = o.toArray(c, u)),
                  (f = o.toArray(f, d)),
                  a(
                    c.length >= this.minEntropy / 8,
                    'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits',
                  ),
                  this._update(c.concat(f || [])),
                  (this._reseed = 1))
              }),
              (l.prototype.generate = function (c, u, f, d) {
                if (this._reseed > this.reseedInterval) throw new Error('Reseed is required')
                ;(typeof u != 'string' && ((d = f), (f = u), (u = null)),
                  f && ((f = o.toArray(f, d || 'hex')), this._update(f)))
                for (var h = []; h.length < c; )
                  ((this.V = this._hmac().update(this.V).digest()), (h = h.concat(this.V)))
                var p = h.slice(0, c)
                return (this._update(f), this._reseed++, o.encode(p, u))
              }))
          },
          { 'hash.js': 426, 'minimalistic-assert': 453, 'minimalistic-crypto-utils': 454 },
        ],
        439: [
          function (t, r, i) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ ;((i.read =
              function (s, o, a, l, c) {
                var u,
                  f,
                  d = 8 * c - l - 1,
                  h = (1 << d) - 1,
                  p = h >> 1,
                  g = -7,
                  m = a ? c - 1 : 0,
                  y = a ? -1 : 1,
                  b = s[o + m]
                for (
                  m += y, u = b & ((1 << -g) - 1), b >>= -g, g += d;
                  g > 0;
                  u = 256 * u + s[o + m], m += y, g -= 8
                );
                for (
                  f = u & ((1 << -g) - 1), u >>= -g, g += l;
                  g > 0;
                  f = 256 * f + s[o + m], m += y, g -= 8
                );
                if (u === 0) u = 1 - p
                else {
                  if (u === h) return f ? NaN : (1 / 0) * (b ? -1 : 1)
                  ;((f += Math.pow(2, l)), (u -= p))
                }
                return (b ? -1 : 1) * f * Math.pow(2, u - l)
              }),
              (i.write = function (s, o, a, l, c, u) {
                var f,
                  d,
                  h,
                  p = 8 * u - c - 1,
                  g = (1 << p) - 1,
                  m = g >> 1,
                  y = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                  b = l ? 0 : u - 1,
                  w = l ? 1 : -1,
                  C = o < 0 || (o === 0 && 1 / o < 0) ? 1 : 0
                for (
                  o = Math.abs(o),
                    isNaN(o) || o === 1 / 0
                      ? ((d = isNaN(o) ? 1 : 0), (f = g))
                      : ((f = Math.floor(Math.log(o) / Math.LN2)),
                        o * (h = Math.pow(2, -f)) < 1 && (f--, (h *= 2)),
                        (o += f + m >= 1 ? y / h : y * Math.pow(2, 1 - m)) * h >= 2 &&
                          (f++, (h /= 2)),
                        f + m >= g
                          ? ((d = 0), (f = g))
                          : f + m >= 1
                            ? ((d = (o * h - 1) * Math.pow(2, c)), (f += m))
                            : ((d = o * Math.pow(2, m - 1) * Math.pow(2, c)), (f = 0)));
                  c >= 8;
                  s[a + b] = 255 & d, b += w, d /= 256, c -= 8
                );
                for (f = (f << c) | d, p += c; p > 0; s[a + b] = 255 & f, b += w, f /= 256, p -= 8);
                s[a + b - w] |= 128 * C
              }))
          },
          {},
        ],
        440: [
          function (t, r, i) {
            typeof Object.create == 'function'
              ? (r.exports = function (s, o) {
                  o &&
                    ((s.super_ = o),
                    (s.prototype = Object.create(o.prototype, {
                      constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 },
                    })))
                })
              : (r.exports = function (s, o) {
                  if (o) {
                    s.super_ = o
                    var a = function () {}
                    ;((a.prototype = o.prototype),
                      (s.prototype = new a()),
                      (s.prototype.constructor = s))
                  }
                })
          },
          {},
        ],
        441: [
          function (t, r, i) {
            ;(function (s, o, a, l, c, u, f, d) {
              ;(function () {
                /*!

	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
	<http://stuartk.com/jszip>

	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

	JSZip uses the library pako released under the MIT license :
	https://github.com/nodeca/pako/blob/main/LICENSE
	*/ ;(function (h) {
                  typeof i == 'object' && r !== void 0
                    ? (r.exports = h())
                    : ((typeof window < 'u'
                        ? window
                        : o !== void 0
                          ? o
                          : typeof self < 'u'
                            ? self
                            : this
                      ).JSZip = h())
                })(function () {
                  return (function h(p, g, m) {
                    function y(C, T) {
                      if (!g[C]) {
                        if (!p[C]) {
                          var I = typeof t == 'function' && t
                          if (!T && I) return I(C, !0)
                          if (b) return b(C, !0)
                          var B = new Error("Cannot find module '" + C + "'")
                          throw ((B.code = 'MODULE_NOT_FOUND'), B)
                        }
                        var E = (g[C] = { exports: {} })
                        p[C][0].call(
                          E.exports,
                          function (O) {
                            return y(p[C][1][O] || O)
                          },
                          E,
                          E.exports,
                          h,
                          p,
                          g,
                          m,
                        )
                      }
                      return g[C].exports
                    }
                    for (var b = typeof t == 'function' && t, w = 0; w < m.length; w++) y(m[w])
                    return y
                  })(
                    {
                      1: [
                        function (h, p, g) {
                          var m = h('./utils'),
                            y = h('./support'),
                            b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
                          ;((g.encode = function (w) {
                            for (
                              var C,
                                T,
                                I,
                                B,
                                E,
                                O,
                                P,
                                $ = [],
                                F = 0,
                                M = w.length,
                                R = M,
                                k = m.getTypeOf(w) !== 'string';
                              F < w.length;

                            )
                              ((R = M - F),
                                (I = k
                                  ? ((C = w[F++]), (T = F < M ? w[F++] : 0), F < M ? w[F++] : 0)
                                  : ((C = w.charCodeAt(F++)),
                                    (T = F < M ? w.charCodeAt(F++) : 0),
                                    F < M ? w.charCodeAt(F++) : 0)),
                                (B = C >> 2),
                                (E = ((3 & C) << 4) | (T >> 4)),
                                (O = 1 < R ? ((15 & T) << 2) | (I >> 6) : 64),
                                (P = 2 < R ? 63 & I : 64),
                                $.push(b.charAt(B) + b.charAt(E) + b.charAt(O) + b.charAt(P)))
                            return $.join('')
                          }),
                            (g.decode = function (w) {
                              var C,
                                T,
                                I,
                                B,
                                E,
                                O,
                                P = 0,
                                $ = 0,
                                F = 'data:'
                              if (w.substr(0, F.length) === F)
                                throw new Error('Invalid base64 input, it looks like a data url.')
                              var M,
                                R = (3 * (w = w.replace(/[^A-Za-z0-9+/=]/g, '')).length) / 4
                              if (
                                (w.charAt(w.length - 1) === b.charAt(64) && R--,
                                w.charAt(w.length - 2) === b.charAt(64) && R--,
                                R % 1 != 0)
                              )
                                throw new Error('Invalid base64 input, bad content length.')
                              for (
                                M = y.uint8array ? new Uint8Array(0 | R) : new Array(0 | R);
                                P < w.length;

                              )
                                ((C =
                                  (b.indexOf(w.charAt(P++)) << 2) |
                                  ((B = b.indexOf(w.charAt(P++))) >> 4)),
                                  (T = ((15 & B) << 4) | ((E = b.indexOf(w.charAt(P++))) >> 2)),
                                  (I = ((3 & E) << 6) | (O = b.indexOf(w.charAt(P++)))),
                                  (M[$++] = C),
                                  E !== 64 && (M[$++] = T),
                                  O !== 64 && (M[$++] = I))
                              return M
                            }))
                        },
                        { './support': 30, './utils': 32 },
                      ],
                      2: [
                        function (h, p, g) {
                          var m = h('./external'),
                            y = h('./stream/DataWorker'),
                            b = h('./stream/Crc32Probe'),
                            w = h('./stream/DataLengthProbe')
                          function C(T, I, B, E, O) {
                            ;((this.compressedSize = T),
                              (this.uncompressedSize = I),
                              (this.crc32 = B),
                              (this.compression = E),
                              (this.compressedContent = O))
                          }
                          ;((C.prototype = {
                            getContentWorker: function () {
                              var T = new y(m.Promise.resolve(this.compressedContent))
                                  .pipe(this.compression.uncompressWorker())
                                  .pipe(new w('data_length')),
                                I = this
                              return (
                                T.on('end', function () {
                                  if (this.streamInfo.data_length !== I.uncompressedSize)
                                    throw new Error('Bug : uncompressed data size mismatch')
                                }),
                                T
                              )
                            },
                            getCompressedWorker: function () {
                              return new y(m.Promise.resolve(this.compressedContent))
                                .withStreamInfo('compressedSize', this.compressedSize)
                                .withStreamInfo('uncompressedSize', this.uncompressedSize)
                                .withStreamInfo('crc32', this.crc32)
                                .withStreamInfo('compression', this.compression)
                            },
                          }),
                            (C.createWorkerFrom = function (T, I, B) {
                              return T.pipe(new b())
                                .pipe(new w('uncompressedSize'))
                                .pipe(I.compressWorker(B))
                                .pipe(new w('compressedSize'))
                                .withStreamInfo('compression', I)
                            }),
                            (p.exports = C))
                        },
                        {
                          './external': 6,
                          './stream/Crc32Probe': 25,
                          './stream/DataLengthProbe': 26,
                          './stream/DataWorker': 27,
                        },
                      ],
                      3: [
                        function (h, p, g) {
                          var m = h('./stream/GenericWorker')
                          ;((g.STORE = {
                            magic: '\0\0',
                            compressWorker: function () {
                              return new m('STORE compression')
                            },
                            uncompressWorker: function () {
                              return new m('STORE decompression')
                            },
                          }),
                            (g.DEFLATE = h('./flate')))
                        },
                        { './flate': 7, './stream/GenericWorker': 28 },
                      ],
                      4: [
                        function (h, p, g) {
                          var m = h('./utils'),
                            y = (function () {
                              for (var b, w = [], C = 0; C < 256; C++) {
                                b = C
                                for (var T = 0; T < 8; T++)
                                  b = 1 & b ? 3988292384 ^ (b >>> 1) : b >>> 1
                                w[C] = b
                              }
                              return w
                            })()
                          p.exports = function (b, w) {
                            return b !== void 0 && b.length
                              ? m.getTypeOf(b) !== 'string'
                                ? (function (C, T, I, B) {
                                    var E = y,
                                      O = 0 + I
                                    C ^= -1
                                    for (var P = 0; P < O; P++) C = (C >>> 8) ^ E[255 & (C ^ T[P])]
                                    return -1 ^ C
                                  })(0 | w, b, b.length)
                                : (function (C, T, I, B) {
                                    var E = y,
                                      O = 0 + I
                                    C ^= -1
                                    for (var P = 0; P < O; P++)
                                      C = (C >>> 8) ^ E[255 & (C ^ T.charCodeAt(P))]
                                    return -1 ^ C
                                  })(0 | w, b, b.length)
                              : 0
                          }
                        },
                        { './utils': 32 },
                      ],
                      5: [
                        function (h, p, g) {
                          ;((g.base64 = !1),
                            (g.binary = !1),
                            (g.dir = !1),
                            (g.createFolders = !0),
                            (g.date = null),
                            (g.compression = null),
                            (g.compressionOptions = null),
                            (g.comment = null),
                            (g.unixPermissions = null),
                            (g.dosPermissions = null))
                        },
                        {},
                      ],
                      6: [
                        function (h, p, g) {
                          var m
                          ;((m = typeof Promise < 'u' ? Promise : h('lie')),
                            (p.exports = { Promise: m }))
                        },
                        { lie: 37 },
                      ],
                      7: [
                        function (h, p, g) {
                          var m =
                              typeof Uint8Array < 'u' &&
                              typeof Uint16Array < 'u' &&
                              typeof Uint32Array < 'u',
                            y = h('pako'),
                            b = h('./utils'),
                            w = h('./stream/GenericWorker'),
                            C = m ? 'uint8array' : 'array'
                          function T(I, B) {
                            ;(w.call(this, 'FlateWorker/' + I),
                              (this._pako = null),
                              (this._pakoAction = I),
                              (this._pakoOptions = B),
                              (this.meta = {}))
                          }
                          ;((g.magic = '\b\0'),
                            b.inherits(T, w),
                            (T.prototype.processChunk = function (I) {
                              ;((this.meta = I.meta),
                                this._pako === null && this._createPako(),
                                this._pako.push(b.transformTo(C, I.data), !1))
                            }),
                            (T.prototype.flush = function () {
                              ;(w.prototype.flush.call(this),
                                this._pako === null && this._createPako(),
                                this._pako.push([], !0))
                            }),
                            (T.prototype.cleanUp = function () {
                              ;(w.prototype.cleanUp.call(this), (this._pako = null))
                            }),
                            (T.prototype._createPako = function () {
                              this._pako = new y[this._pakoAction]({
                                raw: !0,
                                level: this._pakoOptions.level || -1,
                              })
                              var I = this
                              this._pako.onData = function (B) {
                                I.push({ data: B, meta: I.meta })
                              }
                            }),
                            (g.compressWorker = function (I) {
                              return new T('Deflate', I)
                            }),
                            (g.uncompressWorker = function () {
                              return new T('Inflate', {})
                            }))
                        },
                        { './stream/GenericWorker': 28, './utils': 32, pako: 38 },
                      ],
                      8: [
                        function (h, p, g) {
                          function m(E, O) {
                            var P,
                              $ = ''
                            for (P = 0; P < O; P++)
                              (($ += String.fromCharCode(255 & E)), (E >>>= 8))
                            return $
                          }
                          function y(E, O, P, $, F, M) {
                            var R,
                              k,
                              v = E.file,
                              x = E.compression,
                              _ = M !== C.utf8encode,
                              S = b.transformTo('string', M(v.name)),
                              A = b.transformTo('string', C.utf8encode(v.name)),
                              j = v.comment,
                              L = b.transformTo('string', M(j)),
                              H = b.transformTo('string', C.utf8encode(j)),
                              U = A.length !== v.name.length,
                              K = H.length !== j.length,
                              z = '',
                              q = '',
                              D = '',
                              N = v.dir,
                              V = v.date,
                              W = { crc32: 0, compressedSize: 0, uncompressedSize: 0 }
                            ;(O && !P) ||
                              ((W.crc32 = E.crc32),
                              (W.compressedSize = E.compressedSize),
                              (W.uncompressedSize = E.uncompressedSize))
                            var J = 0
                            ;(O && (J |= 8), _ || (!U && !K) || (J |= 2048))
                            var G = 0,
                              Z = 0
                            ;(N && (G |= 16),
                              F === 'UNIX'
                                ? ((Z = 798),
                                  (G |= (function (nt, X) {
                                    var Q = nt
                                    return (nt || (Q = X ? 16893 : 33204), (65535 & Q) << 16)
                                  })(v.unixPermissions, N)))
                                : ((Z = 20),
                                  (G |= (function (nt) {
                                    return 63 & (nt || 0)
                                  })(v.dosPermissions))),
                              (R = V.getUTCHours()),
                              (R <<= 6),
                              (R |= V.getUTCMinutes()),
                              (R <<= 5),
                              (R |= V.getUTCSeconds() / 2),
                              (k = V.getUTCFullYear() - 1980),
                              (k <<= 4),
                              (k |= V.getUTCMonth() + 1),
                              (k <<= 5),
                              (k |= V.getUTCDate()),
                              U &&
                                ((q = m(1, 1) + m(T(S), 4) + A), (z += 'up' + m(q.length, 2) + q)),
                              K &&
                                ((D = m(1, 1) + m(T(L), 4) + H), (z += 'uc' + m(D.length, 2) + D)))
                            var rt = ''
                            return (
                              (rt += `
\0`),
                              (rt += m(J, 2)),
                              (rt += x.magic),
                              (rt += m(R, 2)),
                              (rt += m(k, 2)),
                              (rt += m(W.crc32, 4)),
                              (rt += m(W.compressedSize, 4)),
                              (rt += m(W.uncompressedSize, 4)),
                              (rt += m(S.length, 2)),
                              (rt += m(z.length, 2)),
                              {
                                fileRecord: I.LOCAL_FILE_HEADER + rt + S + z,
                                dirRecord:
                                  I.CENTRAL_FILE_HEADER +
                                  m(Z, 2) +
                                  rt +
                                  m(L.length, 2) +
                                  '\0\0\0\0' +
                                  m(G, 4) +
                                  m($, 4) +
                                  S +
                                  z +
                                  L,
                              }
                            )
                          }
                          var b = h('../utils'),
                            w = h('../stream/GenericWorker'),
                            C = h('../utf8'),
                            T = h('../crc32'),
                            I = h('../signature')
                          function B(E, O, P, $) {
                            ;(w.call(this, 'ZipFileWorker'),
                              (this.bytesWritten = 0),
                              (this.zipComment = O),
                              (this.zipPlatform = P),
                              (this.encodeFileName = $),
                              (this.streamFiles = E),
                              (this.accumulate = !1),
                              (this.contentBuffer = []),
                              (this.dirRecords = []),
                              (this.currentSourceOffset = 0),
                              (this.entriesCount = 0),
                              (this.currentFile = null),
                              (this._sources = []))
                          }
                          ;(b.inherits(B, w),
                            (B.prototype.push = function (E) {
                              var O = E.meta.percent || 0,
                                P = this.entriesCount,
                                $ = this._sources.length
                              this.accumulate
                                ? this.contentBuffer.push(E)
                                : ((this.bytesWritten += E.data.length),
                                  w.prototype.push.call(this, {
                                    data: E.data,
                                    meta: {
                                      currentFile: this.currentFile,
                                      percent: P ? (O + 100 * (P - $ - 1)) / P : 100,
                                    },
                                  }))
                            }),
                            (B.prototype.openedSource = function (E) {
                              ;((this.currentSourceOffset = this.bytesWritten),
                                (this.currentFile = E.file.name))
                              var O = this.streamFiles && !E.file.dir
                              if (O) {
                                var P = y(
                                  E,
                                  O,
                                  !1,
                                  this.currentSourceOffset,
                                  this.zipPlatform,
                                  this.encodeFileName,
                                )
                                this.push({ data: P.fileRecord, meta: { percent: 0 } })
                              } else this.accumulate = !0
                            }),
                            (B.prototype.closedSource = function (E) {
                              this.accumulate = !1
                              var O = this.streamFiles && !E.file.dir,
                                P = y(
                                  E,
                                  O,
                                  !0,
                                  this.currentSourceOffset,
                                  this.zipPlatform,
                                  this.encodeFileName,
                                )
                              if ((this.dirRecords.push(P.dirRecord), O))
                                this.push({
                                  data: (function ($) {
                                    return (
                                      I.DATA_DESCRIPTOR +
                                      m($.crc32, 4) +
                                      m($.compressedSize, 4) +
                                      m($.uncompressedSize, 4)
                                    )
                                  })(E),
                                  meta: { percent: 100 },
                                })
                              else
                                for (
                                  this.push({ data: P.fileRecord, meta: { percent: 0 } });
                                  this.contentBuffer.length;

                                )
                                  this.push(this.contentBuffer.shift())
                              this.currentFile = null
                            }),
                            (B.prototype.flush = function () {
                              for (
                                var E = this.bytesWritten, O = 0;
                                O < this.dirRecords.length;
                                O++
                              )
                                this.push({ data: this.dirRecords[O], meta: { percent: 100 } })
                              var P = this.bytesWritten - E,
                                $ = (function (F, M, R, k, v) {
                                  var x = b.transformTo('string', v(k))
                                  return (
                                    I.CENTRAL_DIRECTORY_END +
                                    '\0\0\0\0' +
                                    m(F, 2) +
                                    m(F, 2) +
                                    m(M, 4) +
                                    m(R, 4) +
                                    m(x.length, 2) +
                                    x
                                  )
                                })(
                                  this.dirRecords.length,
                                  P,
                                  E,
                                  this.zipComment,
                                  this.encodeFileName,
                                )
                              this.push({ data: $, meta: { percent: 100 } })
                            }),
                            (B.prototype.prepareNextSource = function () {
                              ;((this.previous = this._sources.shift()),
                                this.openedSource(this.previous.streamInfo),
                                this.isPaused ? this.previous.pause() : this.previous.resume())
                            }),
                            (B.prototype.registerPrevious = function (E) {
                              this._sources.push(E)
                              var O = this
                              return (
                                E.on('data', function (P) {
                                  O.processChunk(P)
                                }),
                                E.on('end', function () {
                                  ;(O.closedSource(O.previous.streamInfo),
                                    O._sources.length ? O.prepareNextSource() : O.end())
                                }),
                                E.on('error', function (P) {
                                  O.error(P)
                                }),
                                this
                              )
                            }),
                            (B.prototype.resume = function () {
                              return (
                                !!w.prototype.resume.call(this) &&
                                (!this.previous && this._sources.length
                                  ? (this.prepareNextSource(), !0)
                                  : this.previous || this._sources.length || this.generatedError
                                    ? void 0
                                    : (this.end(), !0))
                              )
                            }),
                            (B.prototype.error = function (E) {
                              var O = this._sources
                              if (!w.prototype.error.call(this, E)) return !1
                              for (var P = 0; P < O.length; P++)
                                try {
                                  O[P].error(E)
                                } catch {}
                              return !0
                            }),
                            (B.prototype.lock = function () {
                              w.prototype.lock.call(this)
                              for (var E = this._sources, O = 0; O < E.length; O++) E[O].lock()
                            }),
                            (p.exports = B))
                        },
                        {
                          '../crc32': 4,
                          '../signature': 23,
                          '../stream/GenericWorker': 28,
                          '../utf8': 31,
                          '../utils': 32,
                        },
                      ],
                      9: [
                        function (h, p, g) {
                          var m = h('../compressions'),
                            y = h('./ZipFileWorker')
                          g.generateWorker = function (b, w, C) {
                            var T = new y(w.streamFiles, C, w.platform, w.encodeFileName),
                              I = 0
                            try {
                              ;(b.forEach(function (B, E) {
                                I++
                                var O = (function (M, R) {
                                    var k = M || R,
                                      v = m[k]
                                    if (!v)
                                      throw new Error(k + ' is not a valid compression method !')
                                    return v
                                  })(E.options.compression, w.compression),
                                  P = E.options.compressionOptions || w.compressionOptions || {},
                                  $ = E.dir,
                                  F = E.date
                                E._compressWorker(O, P)
                                  .withStreamInfo('file', {
                                    name: B,
                                    dir: $,
                                    date: F,
                                    comment: E.comment || '',
                                    unixPermissions: E.unixPermissions,
                                    dosPermissions: E.dosPermissions,
                                  })
                                  .pipe(T)
                              }),
                                (T.entriesCount = I))
                            } catch (B) {
                              T.error(B)
                            }
                            return T
                          }
                        },
                        { '../compressions': 3, './ZipFileWorker': 8 },
                      ],
                      10: [
                        function (h, p, g) {
                          function m() {
                            if (!(this instanceof m)) return new m()
                            if (arguments.length)
                              throw new Error(
                                'The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.',
                              )
                            ;((this.files = Object.create(null)),
                              (this.comment = null),
                              (this.root = ''),
                              (this.clone = function () {
                                var y = new m()
                                for (var b in this) typeof this[b] != 'function' && (y[b] = this[b])
                                return y
                              }))
                          }
                          ;(((m.prototype = h('./object')).loadAsync = h('./load')),
                            (m.support = h('./support')),
                            (m.defaults = h('./defaults')),
                            (m.version = '3.10.1'),
                            (m.loadAsync = function (y, b) {
                              return new m().loadAsync(y, b)
                            }),
                            (m.external = h('./external')),
                            (p.exports = m))
                        },
                        {
                          './defaults': 5,
                          './external': 6,
                          './load': 11,
                          './object': 15,
                          './support': 30,
                        },
                      ],
                      11: [
                        function (h, p, g) {
                          var m = h('./utils'),
                            y = h('./external'),
                            b = h('./utf8'),
                            w = h('./zipEntries'),
                            C = h('./stream/Crc32Probe'),
                            T = h('./nodejsUtils')
                          function I(B) {
                            return new y.Promise(function (E, O) {
                              var P = B.decompressed.getContentWorker().pipe(new C())
                              P.on('error', function ($) {
                                O($)
                              })
                                .on('end', function () {
                                  P.streamInfo.crc32 !== B.decompressed.crc32
                                    ? O(new Error('Corrupted zip : CRC32 mismatch'))
                                    : E()
                                })
                                .resume()
                            })
                          }
                          p.exports = function (B, E) {
                            var O = this
                            return (
                              (E = m.extend(E || {}, {
                                base64: !1,
                                checkCRC32: !1,
                                optimizedBinaryString: !1,
                                createFolders: !1,
                                decodeFileName: b.utf8decode,
                              })),
                              T.isNode && T.isStream(B)
                                ? y.Promise.reject(
                                    new Error(
                                      "JSZip can't accept a stream when loading a zip file.",
                                    ),
                                  )
                                : m
                                    .prepareContent(
                                      'the loaded zip file',
                                      B,
                                      !0,
                                      E.optimizedBinaryString,
                                      E.base64,
                                    )
                                    .then(function (P) {
                                      var $ = new w(E)
                                      return ($.load(P), $)
                                    })
                                    .then(function (P) {
                                      var $ = [y.Promise.resolve(P)],
                                        F = P.files
                                      if (E.checkCRC32)
                                        for (var M = 0; M < F.length; M++) $.push(I(F[M]))
                                      return y.Promise.all($)
                                    })
                                    .then(function (P) {
                                      for (
                                        var $ = P.shift(), F = $.files, M = 0;
                                        M < F.length;
                                        M++
                                      ) {
                                        var R = F[M],
                                          k = R.fileNameStr,
                                          v = m.resolve(R.fileNameStr)
                                        ;(O.file(v, R.decompressed, {
                                          binary: !0,
                                          optimizedBinaryString: !0,
                                          date: R.date,
                                          dir: R.dir,
                                          comment: R.fileCommentStr.length
                                            ? R.fileCommentStr
                                            : null,
                                          unixPermissions: R.unixPermissions,
                                          dosPermissions: R.dosPermissions,
                                          createFolders: E.createFolders,
                                        }),
                                          R.dir || (O.file(v).unsafeOriginalName = k))
                                      }
                                      return ($.zipComment.length && (O.comment = $.zipComment), O)
                                    })
                            )
                          }
                        },
                        {
                          './external': 6,
                          './nodejsUtils': 14,
                          './stream/Crc32Probe': 25,
                          './utf8': 31,
                          './utils': 32,
                          './zipEntries': 33,
                        },
                      ],
                      12: [
                        function (h, p, g) {
                          var m = h('../utils'),
                            y = h('../stream/GenericWorker')
                          function b(w, C) {
                            ;(y.call(this, 'Nodejs stream input adapter for ' + w),
                              (this._upstreamEnded = !1),
                              this._bindStream(C))
                          }
                          ;(m.inherits(b, y),
                            (b.prototype._bindStream = function (w) {
                              var C = this
                              ;((this._stream = w).pause(),
                                w
                                  .on('data', function (T) {
                                    C.push({ data: T, meta: { percent: 0 } })
                                  })
                                  .on('error', function (T) {
                                    C.isPaused ? (this.generatedError = T) : C.error(T)
                                  })
                                  .on('end', function () {
                                    C.isPaused ? (C._upstreamEnded = !0) : C.end()
                                  }))
                            }),
                            (b.prototype.pause = function () {
                              return !!y.prototype.pause.call(this) && (this._stream.pause(), !0)
                            }),
                            (b.prototype.resume = function () {
                              return (
                                !!y.prototype.resume.call(this) &&
                                (this._upstreamEnded ? this.end() : this._stream.resume(), !0)
                              )
                            }),
                            (p.exports = b))
                        },
                        { '../stream/GenericWorker': 28, '../utils': 32 },
                      ],
                      13: [
                        function (h, p, g) {
                          var m = h('readable-stream').Readable
                          function y(b, w, C) {
                            ;(m.call(this, w), (this._helper = b))
                            var T = this
                            b.on('data', function (I, B) {
                              ;(T.push(I) || T._helper.pause(), C && C(B))
                            })
                              .on('error', function (I) {
                                T.emit('error', I)
                              })
                              .on('end', function () {
                                T.push(null)
                              })
                          }
                          ;(h('../utils').inherits(y, m),
                            (y.prototype._read = function () {
                              this._helper.resume()
                            }),
                            (p.exports = y))
                        },
                        { '../utils': 32, 'readable-stream': 16 },
                      ],
                      14: [
                        function (h, p, g) {
                          p.exports = {
                            isNode: a !== void 0,
                            newBufferFrom: function (m, y) {
                              if (a.from && a.from !== Uint8Array.from) return a.from(m, y)
                              if (typeof m == 'number')
                                throw new Error('The "data" argument must not be a number')
                              return new a(m, y)
                            },
                            allocBuffer: function (m) {
                              if (a.alloc) return a.alloc(m)
                              var y = new a(m)
                              return (y.fill(0), y)
                            },
                            isBuffer: function (m) {
                              return a.isBuffer(m)
                            },
                            isStream: function (m) {
                              return (
                                m &&
                                typeof m.on == 'function' &&
                                typeof m.pause == 'function' &&
                                typeof m.resume == 'function'
                              )
                            },
                          }
                        },
                        {},
                      ],
                      15: [
                        function (h, p, g) {
                          function m(v, x, _) {
                            var S,
                              A = b.getTypeOf(x),
                              j = b.extend(_ || {}, T)
                            ;((j.date = j.date || new Date()),
                              j.compression !== null &&
                                (j.compression = j.compression.toUpperCase()),
                              typeof j.unixPermissions == 'string' &&
                                (j.unixPermissions = parseInt(j.unixPermissions, 8)),
                              j.unixPermissions && 16384 & j.unixPermissions && (j.dir = !0),
                              j.dosPermissions && 16 & j.dosPermissions && (j.dir = !0),
                              j.dir && (v = F(v)),
                              j.createFolders && (S = $(v)) && M.call(this, S, !0))
                            var L = A === 'string' && j.binary === !1 && j.base64 === !1
                            ;((_ && _.binary !== void 0) || (j.binary = !L),
                              ((x instanceof I && x.uncompressedSize === 0) ||
                                j.dir ||
                                !x ||
                                x.length === 0) &&
                                ((j.base64 = !1),
                                (j.binary = !0),
                                (x = ''),
                                (j.compression = 'STORE'),
                                (A = 'string')))
                            var H
                            H =
                              x instanceof I || x instanceof w
                                ? x
                                : O.isNode && O.isStream(x)
                                  ? new P(v, x)
                                  : b.prepareContent(
                                      v,
                                      x,
                                      j.binary,
                                      j.optimizedBinaryString,
                                      j.base64,
                                    )
                            var U = new B(v, H, j)
                            this.files[v] = U
                          }
                          var y = h('./utf8'),
                            b = h('./utils'),
                            w = h('./stream/GenericWorker'),
                            C = h('./stream/StreamHelper'),
                            T = h('./defaults'),
                            I = h('./compressedObject'),
                            B = h('./zipObject'),
                            E = h('./generate'),
                            O = h('./nodejsUtils'),
                            P = h('./nodejs/NodejsStreamInputAdapter'),
                            $ = function (v) {
                              v.slice(-1) === '/' && (v = v.substring(0, v.length - 1))
                              var x = v.lastIndexOf('/')
                              return 0 < x ? v.substring(0, x) : ''
                            },
                            F = function (v) {
                              return (v.slice(-1) !== '/' && (v += '/'), v)
                            },
                            M = function (v, x) {
                              return (
                                (x = x !== void 0 ? x : T.createFolders),
                                (v = F(v)),
                                this.files[v] ||
                                  m.call(this, v, null, { dir: !0, createFolders: x }),
                                this.files[v]
                              )
                            }
                          function R(v) {
                            return Object.prototype.toString.call(v) === '[object RegExp]'
                          }
                          var k = {
                            load: function () {
                              throw new Error(
                                'This method has been removed in JSZip 3.0, please check the upgrade guide.',
                              )
                            },
                            forEach: function (v) {
                              var x, _, S
                              for (x in this.files)
                                ((S = this.files[x]),
                                  (_ = x.slice(this.root.length, x.length)) &&
                                    x.slice(0, this.root.length) === this.root &&
                                    v(_, S))
                            },
                            filter: function (v) {
                              var x = []
                              return (
                                this.forEach(function (_, S) {
                                  v(_, S) && x.push(S)
                                }),
                                x
                              )
                            },
                            file: function (v, x, _) {
                              if (arguments.length !== 1)
                                return ((v = this.root + v), m.call(this, v, x, _), this)
                              if (R(v)) {
                                var S = v
                                return this.filter(function (j, L) {
                                  return !L.dir && S.test(j)
                                })
                              }
                              var A = this.files[this.root + v]
                              return A && !A.dir ? A : null
                            },
                            folder: function (v) {
                              if (!v) return this
                              if (R(v))
                                return this.filter(function (A, j) {
                                  return j.dir && v.test(A)
                                })
                              var x = this.root + v,
                                _ = M.call(this, x),
                                S = this.clone()
                              return ((S.root = _.name), S)
                            },
                            remove: function (v) {
                              v = this.root + v
                              var x = this.files[v]
                              if (
                                (x || (v.slice(-1) !== '/' && (v += '/'), (x = this.files[v])),
                                x && !x.dir)
                              )
                                delete this.files[v]
                              else
                                for (
                                  var _ = this.filter(function (A, j) {
                                      return j.name.slice(0, v.length) === v
                                    }),
                                    S = 0;
                                  S < _.length;
                                  S++
                                )
                                  delete this.files[_[S].name]
                              return this
                            },
                            generate: function () {
                              throw new Error(
                                'This method has been removed in JSZip 3.0, please check the upgrade guide.',
                              )
                            },
                            generateInternalStream: function (v) {
                              var x,
                                _ = {}
                              try {
                                if (
                                  (((_ = b.extend(v || {}, {
                                    streamFiles: !1,
                                    compression: 'STORE',
                                    compressionOptions: null,
                                    type: '',
                                    platform: 'DOS',
                                    comment: null,
                                    mimeType: 'application/zip',
                                    encodeFileName: y.utf8encode,
                                  })).type = _.type.toLowerCase()),
                                  (_.compression = _.compression.toUpperCase()),
                                  _.type === 'binarystring' && (_.type = 'string'),
                                  !_.type)
                                )
                                  throw new Error('No output type specified.')
                                ;(b.checkSupport(_.type),
                                  (_.platform !== 'darwin' &&
                                    _.platform !== 'freebsd' &&
                                    _.platform !== 'linux' &&
                                    _.platform !== 'sunos') ||
                                    (_.platform = 'UNIX'),
                                  _.platform === 'win32' && (_.platform = 'DOS'))
                                var S = _.comment || this.comment || ''
                                x = E.generateWorker(this, _, S)
                              } catch (A) {
                                ;(x = new w('error')).error(A)
                              }
                              return new C(x, _.type || 'string', _.mimeType)
                            },
                            generateAsync: function (v, x) {
                              return this.generateInternalStream(v).accumulate(x)
                            },
                            generateNodeStream: function (v, x) {
                              return (
                                (v = v || {}).type || (v.type = 'nodebuffer'),
                                this.generateInternalStream(v).toNodejsStream(x)
                              )
                            },
                          }
                          p.exports = k
                        },
                        {
                          './compressedObject': 2,
                          './defaults': 5,
                          './generate': 9,
                          './nodejs/NodejsStreamInputAdapter': 12,
                          './nodejsUtils': 14,
                          './stream/GenericWorker': 28,
                          './stream/StreamHelper': 29,
                          './utf8': 31,
                          './utils': 32,
                          './zipObject': 35,
                        },
                      ],
                      16: [
                        function (h, p, g) {
                          p.exports = h('stream')
                        },
                        { stream: void 0 },
                      ],
                      17: [
                        function (h, p, g) {
                          var m = h('./DataReader')
                          function y(b) {
                            m.call(this, b)
                            for (var w = 0; w < this.data.length; w++) b[w] = 255 & b[w]
                          }
                          ;(h('../utils').inherits(y, m),
                            (y.prototype.byteAt = function (b) {
                              return this.data[this.zero + b]
                            }),
                            (y.prototype.lastIndexOfSignature = function (b) {
                              for (
                                var w = b.charCodeAt(0),
                                  C = b.charCodeAt(1),
                                  T = b.charCodeAt(2),
                                  I = b.charCodeAt(3),
                                  B = this.length - 4;
                                0 <= B;
                                --B
                              )
                                if (
                                  this.data[B] === w &&
                                  this.data[B + 1] === C &&
                                  this.data[B + 2] === T &&
                                  this.data[B + 3] === I
                                )
                                  return B - this.zero
                              return -1
                            }),
                            (y.prototype.readAndCheckSignature = function (b) {
                              var w = b.charCodeAt(0),
                                C = b.charCodeAt(1),
                                T = b.charCodeAt(2),
                                I = b.charCodeAt(3),
                                B = this.readData(4)
                              return w === B[0] && C === B[1] && T === B[2] && I === B[3]
                            }),
                            (y.prototype.readData = function (b) {
                              if ((this.checkOffset(b), b === 0)) return []
                              var w = this.data.slice(
                                this.zero + this.index,
                                this.zero + this.index + b,
                              )
                              return ((this.index += b), w)
                            }),
                            (p.exports = y))
                        },
                        { '../utils': 32, './DataReader': 18 },
                      ],
                      18: [
                        function (h, p, g) {
                          var m = h('../utils')
                          function y(b) {
                            ;((this.data = b),
                              (this.length = b.length),
                              (this.index = 0),
                              (this.zero = 0))
                          }
                          ;((y.prototype = {
                            checkOffset: function (b) {
                              this.checkIndex(this.index + b)
                            },
                            checkIndex: function (b) {
                              if (this.length < this.zero + b || b < 0)
                                throw new Error(
                                  'End of data reached (data length = ' +
                                    this.length +
                                    ', asked index = ' +
                                    b +
                                    '). Corrupted zip ?',
                                )
                            },
                            setIndex: function (b) {
                              ;(this.checkIndex(b), (this.index = b))
                            },
                            skip: function (b) {
                              this.setIndex(this.index + b)
                            },
                            byteAt: function () {},
                            readInt: function (b) {
                              var w,
                                C = 0
                              for (
                                this.checkOffset(b), w = this.index + b - 1;
                                w >= this.index;
                                w--
                              )
                                C = (C << 8) + this.byteAt(w)
                              return ((this.index += b), C)
                            },
                            readString: function (b) {
                              return m.transformTo('string', this.readData(b))
                            },
                            readData: function () {},
                            lastIndexOfSignature: function () {},
                            readAndCheckSignature: function () {},
                            readDate: function () {
                              var b = this.readInt(4)
                              return new Date(
                                Date.UTC(
                                  1980 + ((b >> 25) & 127),
                                  ((b >> 21) & 15) - 1,
                                  (b >> 16) & 31,
                                  (b >> 11) & 31,
                                  (b >> 5) & 63,
                                  (31 & b) << 1,
                                ),
                              )
                            },
                          }),
                            (p.exports = y))
                        },
                        { '../utils': 32 },
                      ],
                      19: [
                        function (h, p, g) {
                          var m = h('./Uint8ArrayReader')
                          function y(b) {
                            m.call(this, b)
                          }
                          ;(h('../utils').inherits(y, m),
                            (y.prototype.readData = function (b) {
                              this.checkOffset(b)
                              var w = this.data.slice(
                                this.zero + this.index,
                                this.zero + this.index + b,
                              )
                              return ((this.index += b), w)
                            }),
                            (p.exports = y))
                        },
                        { '../utils': 32, './Uint8ArrayReader': 21 },
                      ],
                      20: [
                        function (h, p, g) {
                          var m = h('./DataReader')
                          function y(b) {
                            m.call(this, b)
                          }
                          ;(h('../utils').inherits(y, m),
                            (y.prototype.byteAt = function (b) {
                              return this.data.charCodeAt(this.zero + b)
                            }),
                            (y.prototype.lastIndexOfSignature = function (b) {
                              return this.data.lastIndexOf(b) - this.zero
                            }),
                            (y.prototype.readAndCheckSignature = function (b) {
                              return b === this.readData(4)
                            }),
                            (y.prototype.readData = function (b) {
                              this.checkOffset(b)
                              var w = this.data.slice(
                                this.zero + this.index,
                                this.zero + this.index + b,
                              )
                              return ((this.index += b), w)
                            }),
                            (p.exports = y))
                        },
                        { '../utils': 32, './DataReader': 18 },
                      ],
                      21: [
                        function (h, p, g) {
                          var m = h('./ArrayReader')
                          function y(b) {
                            m.call(this, b)
                          }
                          ;(h('../utils').inherits(y, m),
                            (y.prototype.readData = function (b) {
                              if ((this.checkOffset(b), b === 0)) return new Uint8Array(0)
                              var w = this.data.subarray(
                                this.zero + this.index,
                                this.zero + this.index + b,
                              )
                              return ((this.index += b), w)
                            }),
                            (p.exports = y))
                        },
                        { '../utils': 32, './ArrayReader': 17 },
                      ],
                      22: [
                        function (h, p, g) {
                          var m = h('../utils'),
                            y = h('../support'),
                            b = h('./ArrayReader'),
                            w = h('./StringReader'),
                            C = h('./NodeBufferReader'),
                            T = h('./Uint8ArrayReader')
                          p.exports = function (I) {
                            var B = m.getTypeOf(I)
                            return (
                              m.checkSupport(B),
                              B !== 'string' || y.uint8array
                                ? B === 'nodebuffer'
                                  ? new C(I)
                                  : y.uint8array
                                    ? new T(m.transformTo('uint8array', I))
                                    : new b(m.transformTo('array', I))
                                : new w(I)
                            )
                          }
                        },
                        {
                          '../support': 30,
                          '../utils': 32,
                          './ArrayReader': 17,
                          './NodeBufferReader': 19,
                          './StringReader': 20,
                          './Uint8ArrayReader': 21,
                        },
                      ],
                      23: [
                        function (h, p, g) {
                          ;((g.LOCAL_FILE_HEADER = 'PK'),
                            (g.CENTRAL_FILE_HEADER = 'PK'),
                            (g.CENTRAL_DIRECTORY_END = 'PK'),
                            (g.ZIP64_CENTRAL_DIRECTORY_LOCATOR = 'PK\x07'),
                            (g.ZIP64_CENTRAL_DIRECTORY_END = 'PK'),
                            (g.DATA_DESCRIPTOR = 'PK\x07\b'))
                        },
                        {},
                      ],
                      24: [
                        function (h, p, g) {
                          var m = h('./GenericWorker'),
                            y = h('../utils')
                          function b(w) {
                            ;(m.call(this, 'ConvertWorker to ' + w), (this.destType = w))
                          }
                          ;(y.inherits(b, m),
                            (b.prototype.processChunk = function (w) {
                              this.push({
                                data: y.transformTo(this.destType, w.data),
                                meta: w.meta,
                              })
                            }),
                            (p.exports = b))
                        },
                        { '../utils': 32, './GenericWorker': 28 },
                      ],
                      25: [
                        function (h, p, g) {
                          var m = h('./GenericWorker'),
                            y = h('../crc32')
                          function b() {
                            ;(m.call(this, 'Crc32Probe'), this.withStreamInfo('crc32', 0))
                          }
                          ;(h('../utils').inherits(b, m),
                            (b.prototype.processChunk = function (w) {
                              ;((this.streamInfo.crc32 = y(w.data, this.streamInfo.crc32 || 0)),
                                this.push(w))
                            }),
                            (p.exports = b))
                        },
                        { '../crc32': 4, '../utils': 32, './GenericWorker': 28 },
                      ],
                      26: [
                        function (h, p, g) {
                          var m = h('../utils'),
                            y = h('./GenericWorker')
                          function b(w) {
                            ;(y.call(this, 'DataLengthProbe for ' + w),
                              (this.propName = w),
                              this.withStreamInfo(w, 0))
                          }
                          ;(m.inherits(b, y),
                            (b.prototype.processChunk = function (w) {
                              if (w) {
                                var C = this.streamInfo[this.propName] || 0
                                this.streamInfo[this.propName] = C + w.data.length
                              }
                              y.prototype.processChunk.call(this, w)
                            }),
                            (p.exports = b))
                        },
                        { '../utils': 32, './GenericWorker': 28 },
                      ],
                      27: [
                        function (h, p, g) {
                          var m = h('../utils'),
                            y = h('./GenericWorker')
                          function b(w) {
                            y.call(this, 'DataWorker')
                            var C = this
                            ;((this.dataIsReady = !1),
                              (this.index = 0),
                              (this.max = 0),
                              (this.data = null),
                              (this.type = ''),
                              (this._tickScheduled = !1),
                              w.then(
                                function (T) {
                                  ;((C.dataIsReady = !0),
                                    (C.data = T),
                                    (C.max = (T && T.length) || 0),
                                    (C.type = m.getTypeOf(T)),
                                    C.isPaused || C._tickAndRepeat())
                                },
                                function (T) {
                                  C.error(T)
                                },
                              ))
                          }
                          ;(m.inherits(b, y),
                            (b.prototype.cleanUp = function () {
                              ;(y.prototype.cleanUp.call(this), (this.data = null))
                            }),
                            (b.prototype.resume = function () {
                              return (
                                !!y.prototype.resume.call(this) &&
                                (!this._tickScheduled &&
                                  this.dataIsReady &&
                                  ((this._tickScheduled = !0),
                                  m.delay(this._tickAndRepeat, [], this)),
                                !0)
                              )
                            }),
                            (b.prototype._tickAndRepeat = function () {
                              ;((this._tickScheduled = !1),
                                this.isPaused ||
                                  this.isFinished ||
                                  (this._tick(),
                                  this.isFinished ||
                                    (m.delay(this._tickAndRepeat, [], this),
                                    (this._tickScheduled = !0))))
                            }),
                            (b.prototype._tick = function () {
                              if (this.isPaused || this.isFinished) return !1
                              var w = null,
                                C = Math.min(this.max, this.index + 16384)
                              if (this.index >= this.max) return this.end()
                              switch (this.type) {
                                case 'string':
                                  w = this.data.substring(this.index, C)
                                  break
                                case 'uint8array':
                                  w = this.data.subarray(this.index, C)
                                  break
                                case 'array':
                                case 'nodebuffer':
                                  w = this.data.slice(this.index, C)
                              }
                              return (
                                (this.index = C),
                                this.push({
                                  data: w,
                                  meta: { percent: this.max ? (this.index / this.max) * 100 : 0 },
                                })
                              )
                            }),
                            (p.exports = b))
                        },
                        { '../utils': 32, './GenericWorker': 28 },
                      ],
                      28: [
                        function (h, p, g) {
                          function m(y) {
                            ;((this.name = y || 'default'),
                              (this.streamInfo = {}),
                              (this.generatedError = null),
                              (this.extraStreamInfo = {}),
                              (this.isPaused = !0),
                              (this.isFinished = !1),
                              (this.isLocked = !1),
                              (this._listeners = { data: [], end: [], error: [] }),
                              (this.previous = null))
                          }
                          ;((m.prototype = {
                            push: function (y) {
                              this.emit('data', y)
                            },
                            end: function () {
                              if (this.isFinished) return !1
                              this.flush()
                              try {
                                ;(this.emit('end'), this.cleanUp(), (this.isFinished = !0))
                              } catch (y) {
                                this.emit('error', y)
                              }
                              return !0
                            },
                            error: function (y) {
                              return (
                                !this.isFinished &&
                                (this.isPaused
                                  ? (this.generatedError = y)
                                  : ((this.isFinished = !0),
                                    this.emit('error', y),
                                    this.previous && this.previous.error(y),
                                    this.cleanUp()),
                                !0)
                              )
                            },
                            on: function (y, b) {
                              return (this._listeners[y].push(b), this)
                            },
                            cleanUp: function () {
                              ;((this.streamInfo =
                                this.generatedError =
                                this.extraStreamInfo =
                                  null),
                                (this._listeners = []))
                            },
                            emit: function (y, b) {
                              if (this._listeners[y])
                                for (var w = 0; w < this._listeners[y].length; w++)
                                  this._listeners[y][w].call(this, b)
                            },
                            pipe: function (y) {
                              return y.registerPrevious(this)
                            },
                            registerPrevious: function (y) {
                              if (this.isLocked)
                                throw new Error("The stream '" + this + "' has already been used.")
                              ;((this.streamInfo = y.streamInfo),
                                this.mergeStreamInfo(),
                                (this.previous = y))
                              var b = this
                              return (
                                y.on('data', function (w) {
                                  b.processChunk(w)
                                }),
                                y.on('end', function () {
                                  b.end()
                                }),
                                y.on('error', function (w) {
                                  b.error(w)
                                }),
                                this
                              )
                            },
                            pause: function () {
                              return (
                                !this.isPaused &&
                                !this.isFinished &&
                                ((this.isPaused = !0), this.previous && this.previous.pause(), !0)
                              )
                            },
                            resume: function () {
                              if (!this.isPaused || this.isFinished) return !1
                              var y = (this.isPaused = !1)
                              return (
                                this.generatedError && (this.error(this.generatedError), (y = !0)),
                                this.previous && this.previous.resume(),
                                !y
                              )
                            },
                            flush: function () {},
                            processChunk: function (y) {
                              this.push(y)
                            },
                            withStreamInfo: function (y, b) {
                              return ((this.extraStreamInfo[y] = b), this.mergeStreamInfo(), this)
                            },
                            mergeStreamInfo: function () {
                              for (var y in this.extraStreamInfo)
                                Object.prototype.hasOwnProperty.call(this.extraStreamInfo, y) &&
                                  (this.streamInfo[y] = this.extraStreamInfo[y])
                            },
                            lock: function () {
                              if (this.isLocked)
                                throw new Error("The stream '" + this + "' has already been used.")
                              ;((this.isLocked = !0), this.previous && this.previous.lock())
                            },
                            toString: function () {
                              var y = 'Worker ' + this.name
                              return this.previous ? this.previous + ' -> ' + y : y
                            },
                          }),
                            (p.exports = m))
                        },
                        {},
                      ],
                      29: [
                        function (h, p, g) {
                          var m = h('../utils'),
                            y = h('./ConvertWorker'),
                            b = h('./GenericWorker'),
                            w = h('../base64'),
                            C = h('../support'),
                            T = h('../external'),
                            I = null
                          if (C.nodestream)
                            try {
                              I = h('../nodejs/NodejsStreamOutputAdapter')
                            } catch {}
                          function B(E, O, P) {
                            var $ = O
                            switch (O) {
                              case 'blob':
                              case 'arraybuffer':
                                $ = 'uint8array'
                                break
                              case 'base64':
                                $ = 'string'
                            }
                            try {
                              ;((this._internalType = $),
                                (this._outputType = O),
                                (this._mimeType = P),
                                m.checkSupport($),
                                (this._worker = E.pipe(new y($))),
                                E.lock())
                            } catch (F) {
                              ;((this._worker = new b('error')), this._worker.error(F))
                            }
                          }
                          ;((B.prototype = {
                            accumulate: function (E) {
                              return (function (O, P) {
                                return new T.Promise(function ($, F) {
                                  var M = [],
                                    R = O._internalType,
                                    k = O._outputType,
                                    v = O._mimeType
                                  O.on('data', function (x, _) {
                                    ;(M.push(x), P && P(_))
                                  })
                                    .on('error', function (x) {
                                      ;((M = []), F(x))
                                    })
                                    .on('end', function () {
                                      try {
                                        var x = (function (_, S, A) {
                                          switch (_) {
                                            case 'blob':
                                              return m.newBlob(m.transformTo('arraybuffer', S), A)
                                            case 'base64':
                                              return w.encode(S)
                                            default:
                                              return m.transformTo(_, S)
                                          }
                                        })(
                                          k,
                                          (function (_, S) {
                                            var A,
                                              j = 0,
                                              L = null,
                                              H = 0
                                            for (A = 0; A < S.length; A++) H += S[A].length
                                            switch (_) {
                                              case 'string':
                                                return S.join('')
                                              case 'array':
                                                return Array.prototype.concat.apply([], S)
                                              case 'uint8array':
                                                for (
                                                  L = new Uint8Array(H), A = 0;
                                                  A < S.length;
                                                  A++
                                                )
                                                  (L.set(S[A], j), (j += S[A].length))
                                                return L
                                              case 'nodebuffer':
                                                return a.concat(S)
                                              default:
                                                throw new Error(
                                                  "concat : unsupported type '" + _ + "'",
                                                )
                                            }
                                          })(R, M),
                                          v,
                                        )
                                        $(x)
                                      } catch (_) {
                                        F(_)
                                      }
                                      M = []
                                    })
                                    .resume()
                                })
                              })(this, E)
                            },
                            on: function (E, O) {
                              var P = this
                              return (
                                E === 'data'
                                  ? this._worker.on(E, function ($) {
                                      O.call(P, $.data, $.meta)
                                    })
                                  : this._worker.on(E, function () {
                                      m.delay(O, arguments, P)
                                    }),
                                this
                              )
                            },
                            resume: function () {
                              return (m.delay(this._worker.resume, [], this._worker), this)
                            },
                            pause: function () {
                              return (this._worker.pause(), this)
                            },
                            toNodejsStream: function (E) {
                              if ((m.checkSupport('nodestream'), this._outputType !== 'nodebuffer'))
                                throw new Error(
                                  this._outputType + ' is not supported by this method',
                                )
                              return new I(
                                this,
                                { objectMode: this._outputType !== 'nodebuffer' },
                                E,
                              )
                            },
                          }),
                            (p.exports = B))
                        },
                        {
                          '../base64': 1,
                          '../external': 6,
                          '../nodejs/NodejsStreamOutputAdapter': 13,
                          '../support': 30,
                          '../utils': 32,
                          './ConvertWorker': 24,
                          './GenericWorker': 28,
                        },
                      ],
                      30: [
                        function (h, p, g) {
                          if (
                            ((g.base64 = !0),
                            (g.array = !0),
                            (g.string = !0),
                            (g.arraybuffer = typeof ArrayBuffer < 'u' && typeof Uint8Array < 'u'),
                            (g.nodebuffer = a !== void 0),
                            (g.uint8array = typeof Uint8Array < 'u'),
                            typeof ArrayBuffer > 'u')
                          )
                            g.blob = !1
                          else {
                            var m = new ArrayBuffer(0)
                            try {
                              g.blob = new Blob([m], { type: 'application/zip' }).size === 0
                            } catch {
                              try {
                                var y = new (self.BlobBuilder ||
                                  self.WebKitBlobBuilder ||
                                  self.MozBlobBuilder ||
                                  self.MSBlobBuilder)()
                                ;(y.append(m), (g.blob = y.getBlob('application/zip').size === 0))
                              } catch {
                                g.blob = !1
                              }
                            }
                          }
                          try {
                            g.nodestream = !!h('readable-stream').Readable
                          } catch {
                            g.nodestream = !1
                          }
                        },
                        { 'readable-stream': 16 },
                      ],
                      31: [
                        function (h, p, g) {
                          for (
                            var m = h('./utils'),
                              y = h('./support'),
                              b = h('./nodejsUtils'),
                              w = h('./stream/GenericWorker'),
                              C = new Array(256),
                              T = 0;
                            T < 256;
                            T++
                          )
                            C[T] =
                              252 <= T
                                ? 6
                                : 248 <= T
                                  ? 5
                                  : 240 <= T
                                    ? 4
                                    : 224 <= T
                                      ? 3
                                      : 192 <= T
                                        ? 2
                                        : 1
                          function I() {
                            ;(w.call(this, 'utf-8 decode'), (this.leftOver = null))
                          }
                          function B() {
                            w.call(this, 'utf-8 encode')
                          }
                          ;((C[254] = C[254] = 1),
                            (g.utf8encode = function (E) {
                              return y.nodebuffer
                                ? b.newBufferFrom(E, 'utf-8')
                                : (function (O) {
                                    var P,
                                      $,
                                      F,
                                      M,
                                      R,
                                      k = O.length,
                                      v = 0
                                    for (M = 0; M < k; M++)
                                      ((64512 & ($ = O.charCodeAt(M))) == 55296 &&
                                        M + 1 < k &&
                                        (64512 & (F = O.charCodeAt(M + 1))) == 56320 &&
                                        (($ = 65536 + (($ - 55296) << 10) + (F - 56320)), M++),
                                        (v += $ < 128 ? 1 : $ < 2048 ? 2 : $ < 65536 ? 3 : 4))
                                    for (
                                      P = y.uint8array ? new Uint8Array(v) : new Array(v),
                                        M = R = 0;
                                      R < v;
                                      M++
                                    )
                                      ((64512 & ($ = O.charCodeAt(M))) == 55296 &&
                                        M + 1 < k &&
                                        (64512 & (F = O.charCodeAt(M + 1))) == 56320 &&
                                        (($ = 65536 + (($ - 55296) << 10) + (F - 56320)), M++),
                                        $ < 128
                                          ? (P[R++] = $)
                                          : ($ < 2048
                                              ? (P[R++] = 192 | ($ >>> 6))
                                              : ($ < 65536
                                                  ? (P[R++] = 224 | ($ >>> 12))
                                                  : ((P[R++] = 240 | ($ >>> 18)),
                                                    (P[R++] = 128 | (($ >>> 12) & 63))),
                                                (P[R++] = 128 | (($ >>> 6) & 63))),
                                            (P[R++] = 128 | (63 & $))))
                                    return P
                                  })(E)
                            }),
                            (g.utf8decode = function (E) {
                              return y.nodebuffer
                                ? m.transformTo('nodebuffer', E).toString('utf-8')
                                : (function (O) {
                                    var P,
                                      $,
                                      F,
                                      M,
                                      R = O.length,
                                      k = new Array(2 * R)
                                    for (P = $ = 0; P < R; )
                                      if ((F = O[P++]) < 128) k[$++] = F
                                      else if (4 < (M = C[F])) ((k[$++] = 65533), (P += M - 1))
                                      else {
                                        for (F &= M === 2 ? 31 : M === 3 ? 15 : 7; 1 < M && P < R; )
                                          ((F = (F << 6) | (63 & O[P++])), M--)
                                        1 < M
                                          ? (k[$++] = 65533)
                                          : F < 65536
                                            ? (k[$++] = F)
                                            : ((F -= 65536),
                                              (k[$++] = 55296 | ((F >> 10) & 1023)),
                                              (k[$++] = 56320 | (1023 & F)))
                                      }
                                    return (
                                      k.length !== $ &&
                                        (k.subarray ? (k = k.subarray(0, $)) : (k.length = $)),
                                      m.applyFromCharCode(k)
                                    )
                                  })((E = m.transformTo(y.uint8array ? 'uint8array' : 'array', E)))
                            }),
                            m.inherits(I, w),
                            (I.prototype.processChunk = function (E) {
                              var O = m.transformTo(y.uint8array ? 'uint8array' : 'array', E.data)
                              if (this.leftOver && this.leftOver.length) {
                                if (y.uint8array) {
                                  var P = O
                                  ;((O = new Uint8Array(P.length + this.leftOver.length)).set(
                                    this.leftOver,
                                    0,
                                  ),
                                    O.set(P, this.leftOver.length))
                                } else O = this.leftOver.concat(O)
                                this.leftOver = null
                              }
                              var $ = (function (M, R) {
                                  var k
                                  for (
                                    (R = R || M.length) > M.length && (R = M.length), k = R - 1;
                                    0 <= k && (192 & M[k]) == 128;

                                  )
                                    k--
                                  return k < 0 || k === 0 ? R : k + C[M[k]] > R ? k : R
                                })(O),
                                F = O
                              ;($ !== O.length &&
                                (y.uint8array
                                  ? ((F = O.subarray(0, $)),
                                    (this.leftOver = O.subarray($, O.length)))
                                  : ((F = O.slice(0, $)), (this.leftOver = O.slice($, O.length)))),
                                this.push({ data: g.utf8decode(F), meta: E.meta }))
                            }),
                            (I.prototype.flush = function () {
                              this.leftOver &&
                                this.leftOver.length &&
                                (this.push({ data: g.utf8decode(this.leftOver), meta: {} }),
                                (this.leftOver = null))
                            }),
                            (g.Utf8DecodeWorker = I),
                            m.inherits(B, w),
                            (B.prototype.processChunk = function (E) {
                              this.push({ data: g.utf8encode(E.data), meta: E.meta })
                            }),
                            (g.Utf8EncodeWorker = B))
                        },
                        {
                          './nodejsUtils': 14,
                          './stream/GenericWorker': 28,
                          './support': 30,
                          './utils': 32,
                        },
                      ],
                      32: [
                        function (h, p, g) {
                          var m = h('./support'),
                            y = h('./base64'),
                            b = h('./nodejsUtils'),
                            w = h('./external')
                          function C(P) {
                            return P
                          }
                          function T(P, $) {
                            for (var F = 0; F < P.length; ++F) $[F] = 255 & P.charCodeAt(F)
                            return $
                          }
                          ;(h('setimmediate'),
                            (g.newBlob = function (P, $) {
                              g.checkSupport('blob')
                              try {
                                return new Blob([P], { type: $ })
                              } catch {
                                try {
                                  var F = new (self.BlobBuilder ||
                                    self.WebKitBlobBuilder ||
                                    self.MozBlobBuilder ||
                                    self.MSBlobBuilder)()
                                  return (F.append(P), F.getBlob($))
                                } catch {
                                  throw new Error("Bug : can't construct the Blob.")
                                }
                              }
                            }))
                          var I = {
                            stringifyByChunk: function (P, $, F) {
                              var M = [],
                                R = 0,
                                k = P.length
                              if (k <= F) return String.fromCharCode.apply(null, P)
                              for (; R < k; )
                                ($ === 'array' || $ === 'nodebuffer'
                                  ? M.push(
                                      String.fromCharCode.apply(
                                        null,
                                        P.slice(R, Math.min(R + F, k)),
                                      ),
                                    )
                                  : M.push(
                                      String.fromCharCode.apply(
                                        null,
                                        P.subarray(R, Math.min(R + F, k)),
                                      ),
                                    ),
                                  (R += F))
                              return M.join('')
                            },
                            stringifyByChar: function (P) {
                              for (var $ = '', F = 0; F < P.length; F++)
                                $ += String.fromCharCode(P[F])
                              return $
                            },
                            applyCanBeUsed: {
                              uint8array: (function () {
                                try {
                                  return (
                                    m.uint8array &&
                                    String.fromCharCode.apply(null, new Uint8Array(1)).length === 1
                                  )
                                } catch {
                                  return !1
                                }
                              })(),
                              nodebuffer: (function () {
                                try {
                                  return (
                                    m.nodebuffer &&
                                    String.fromCharCode.apply(null, b.allocBuffer(1)).length === 1
                                  )
                                } catch {
                                  return !1
                                }
                              })(),
                            },
                          }
                          function B(P) {
                            var $ = 65536,
                              F = g.getTypeOf(P),
                              M = !0
                            if (
                              (F === 'uint8array'
                                ? (M = I.applyCanBeUsed.uint8array)
                                : F === 'nodebuffer' && (M = I.applyCanBeUsed.nodebuffer),
                              M)
                            )
                              for (; 1 < $; )
                                try {
                                  return I.stringifyByChunk(P, F, $)
                                } catch {
                                  $ = Math.floor($ / 2)
                                }
                            return I.stringifyByChar(P)
                          }
                          function E(P, $) {
                            for (var F = 0; F < P.length; F++) $[F] = P[F]
                            return $
                          }
                          g.applyFromCharCode = B
                          var O = {}
                          ;((O.string = {
                            string: C,
                            array: function (P) {
                              return T(P, new Array(P.length))
                            },
                            arraybuffer: function (P) {
                              return O.string.uint8array(P).buffer
                            },
                            uint8array: function (P) {
                              return T(P, new Uint8Array(P.length))
                            },
                            nodebuffer: function (P) {
                              return T(P, b.allocBuffer(P.length))
                            },
                          }),
                            (O.array = {
                              string: B,
                              array: C,
                              arraybuffer: function (P) {
                                return new Uint8Array(P).buffer
                              },
                              uint8array: function (P) {
                                return new Uint8Array(P)
                              },
                              nodebuffer: function (P) {
                                return b.newBufferFrom(P)
                              },
                            }),
                            (O.arraybuffer = {
                              string: function (P) {
                                return B(new Uint8Array(P))
                              },
                              array: function (P) {
                                return E(new Uint8Array(P), new Array(P.byteLength))
                              },
                              arraybuffer: C,
                              uint8array: function (P) {
                                return new Uint8Array(P)
                              },
                              nodebuffer: function (P) {
                                return b.newBufferFrom(new Uint8Array(P))
                              },
                            }),
                            (O.uint8array = {
                              string: B,
                              array: function (P) {
                                return E(P, new Array(P.length))
                              },
                              arraybuffer: function (P) {
                                return P.buffer
                              },
                              uint8array: C,
                              nodebuffer: function (P) {
                                return b.newBufferFrom(P)
                              },
                            }),
                            (O.nodebuffer = {
                              string: B,
                              array: function (P) {
                                return E(P, new Array(P.length))
                              },
                              arraybuffer: function (P) {
                                return O.nodebuffer.uint8array(P).buffer
                              },
                              uint8array: function (P) {
                                return E(P, new Uint8Array(P.length))
                              },
                              nodebuffer: C,
                            }),
                            (g.transformTo = function (P, $) {
                              if ((($ = $ || ''), !P)) return $
                              g.checkSupport(P)
                              var F = g.getTypeOf($)
                              return O[F][P]($)
                            }),
                            (g.resolve = function (P) {
                              for (var $ = P.split('/'), F = [], M = 0; M < $.length; M++) {
                                var R = $[M]
                                R === '.' ||
                                  (R === '' && M !== 0 && M !== $.length - 1) ||
                                  (R === '..' ? F.pop() : F.push(R))
                              }
                              return F.join('/')
                            }),
                            (g.getTypeOf = function (P) {
                              return typeof P == 'string'
                                ? 'string'
                                : Object.prototype.toString.call(P) === '[object Array]'
                                  ? 'array'
                                  : m.nodebuffer && b.isBuffer(P)
                                    ? 'nodebuffer'
                                    : m.uint8array && P instanceof Uint8Array
                                      ? 'uint8array'
                                      : m.arraybuffer && P instanceof ArrayBuffer
                                        ? 'arraybuffer'
                                        : void 0
                            }),
                            (g.checkSupport = function (P) {
                              if (!m[P.toLowerCase()])
                                throw new Error(P + ' is not supported by this platform')
                            }),
                            (g.MAX_VALUE_16BITS = 65535),
                            (g.MAX_VALUE_32BITS = -1),
                            (g.pretty = function (P) {
                              var $,
                                F,
                                M = ''
                              for (F = 0; F < (P || '').length; F++)
                                M +=
                                  '\\x' +
                                  (($ = P.charCodeAt(F)) < 16 ? '0' : '') +
                                  $.toString(16).toUpperCase()
                              return M
                            }),
                            (g.delay = function (P, $, F) {
                              d(function () {
                                P.apply(F || null, $ || [])
                              })
                            }),
                            (g.inherits = function (P, $) {
                              function F() {}
                              ;((F.prototype = $.prototype), (P.prototype = new F()))
                            }),
                            (g.extend = function () {
                              var P,
                                $,
                                F = {}
                              for (P = 0; P < arguments.length; P++)
                                for ($ in arguments[P])
                                  Object.prototype.hasOwnProperty.call(arguments[P], $) &&
                                    F[$] === void 0 &&
                                    (F[$] = arguments[P][$])
                              return F
                            }),
                            (g.prepareContent = function (P, $, F, M, R) {
                              return w.Promise.resolve($)
                                .then(function (k) {
                                  return m.blob &&
                                    (k instanceof Blob ||
                                      ['[object File]', '[object Blob]'].indexOf(
                                        Object.prototype.toString.call(k),
                                      ) !== -1) &&
                                    typeof FileReader < 'u'
                                    ? new w.Promise(function (v, x) {
                                        var _ = new FileReader()
                                        ;((_.onload = function (S) {
                                          v(S.target.result)
                                        }),
                                          (_.onerror = function (S) {
                                            x(S.target.error)
                                          }),
                                          _.readAsArrayBuffer(k))
                                      })
                                    : k
                                })
                                .then(function (k) {
                                  var v = g.getTypeOf(k)
                                  return v
                                    ? (v === 'arraybuffer'
                                        ? (k = g.transformTo('uint8array', k))
                                        : v === 'string' &&
                                          (R
                                            ? (k = y.decode(k))
                                            : F &&
                                              M !== !0 &&
                                              (k = (function (x) {
                                                return T(
                                                  x,
                                                  m.uint8array
                                                    ? new Uint8Array(x.length)
                                                    : new Array(x.length),
                                                )
                                              })(k))),
                                      k)
                                    : w.Promise.reject(
                                        new Error(
                                          "Can't read the data of '" +
                                            P +
                                            "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?",
                                        ),
                                      )
                                })
                            }))
                        },
                        {
                          './base64': 1,
                          './external': 6,
                          './nodejsUtils': 14,
                          './support': 30,
                          setimmediate: 54,
                        },
                      ],
                      33: [
                        function (h, p, g) {
                          var m = h('./reader/readerFor'),
                            y = h('./utils'),
                            b = h('./signature'),
                            w = h('./zipEntry'),
                            C = h('./support')
                          function T(I) {
                            ;((this.files = []), (this.loadOptions = I))
                          }
                          ;((T.prototype = {
                            checkSignature: function (I) {
                              if (!this.reader.readAndCheckSignature(I)) {
                                this.reader.index -= 4
                                var B = this.reader.readString(4)
                                throw new Error(
                                  'Corrupted zip or bug: unexpected signature (' +
                                    y.pretty(B) +
                                    ', expected ' +
                                    y.pretty(I) +
                                    ')',
                                )
                              }
                            },
                            isSignature: function (I, B) {
                              var E = this.reader.index
                              this.reader.setIndex(I)
                              var O = this.reader.readString(4) === B
                              return (this.reader.setIndex(E), O)
                            },
                            readBlockEndOfCentral: function () {
                              ;((this.diskNumber = this.reader.readInt(2)),
                                (this.diskWithCentralDirStart = this.reader.readInt(2)),
                                (this.centralDirRecordsOnThisDisk = this.reader.readInt(2)),
                                (this.centralDirRecords = this.reader.readInt(2)),
                                (this.centralDirSize = this.reader.readInt(4)),
                                (this.centralDirOffset = this.reader.readInt(4)),
                                (this.zipCommentLength = this.reader.readInt(2)))
                              var I = this.reader.readData(this.zipCommentLength),
                                B = C.uint8array ? 'uint8array' : 'array',
                                E = y.transformTo(B, I)
                              this.zipComment = this.loadOptions.decodeFileName(E)
                            },
                            readBlockZip64EndOfCentral: function () {
                              ;((this.zip64EndOfCentralSize = this.reader.readInt(8)),
                                this.reader.skip(4),
                                (this.diskNumber = this.reader.readInt(4)),
                                (this.diskWithCentralDirStart = this.reader.readInt(4)),
                                (this.centralDirRecordsOnThisDisk = this.reader.readInt(8)),
                                (this.centralDirRecords = this.reader.readInt(8)),
                                (this.centralDirSize = this.reader.readInt(8)),
                                (this.centralDirOffset = this.reader.readInt(8)),
                                (this.zip64ExtensibleData = {}))
                              for (var I, B, E, O = this.zip64EndOfCentralSize - 44; 0 < O; )
                                ((I = this.reader.readInt(2)),
                                  (B = this.reader.readInt(4)),
                                  (E = this.reader.readData(B)),
                                  (this.zip64ExtensibleData[I] = { id: I, length: B, value: E }))
                            },
                            readBlockZip64EndOfCentralLocator: function () {
                              if (
                                ((this.diskWithZip64CentralDirStart = this.reader.readInt(4)),
                                (this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8)),
                                (this.disksCount = this.reader.readInt(4)),
                                1 < this.disksCount)
                              )
                                throw new Error('Multi-volumes zip are not supported')
                            },
                            readLocalFiles: function () {
                              var I, B
                              for (I = 0; I < this.files.length; I++)
                                ((B = this.files[I]),
                                  this.reader.setIndex(B.localHeaderOffset),
                                  this.checkSignature(b.LOCAL_FILE_HEADER),
                                  B.readLocalPart(this.reader),
                                  B.handleUTF8(),
                                  B.processAttributes())
                            },
                            readCentralDir: function () {
                              var I
                              for (
                                this.reader.setIndex(this.centralDirOffset);
                                this.reader.readAndCheckSignature(b.CENTRAL_FILE_HEADER);

                              )
                                ((I = new w(
                                  { zip64: this.zip64 },
                                  this.loadOptions,
                                )).readCentralPart(this.reader),
                                  this.files.push(I))
                              if (
                                this.centralDirRecords !== this.files.length &&
                                this.centralDirRecords !== 0 &&
                                this.files.length === 0
                              )
                                throw new Error(
                                  'Corrupted zip or bug: expected ' +
                                    this.centralDirRecords +
                                    ' records in central dir, got ' +
                                    this.files.length,
                                )
                            },
                            readEndOfCentral: function () {
                              var I = this.reader.lastIndexOfSignature(b.CENTRAL_DIRECTORY_END)
                              if (I < 0)
                                throw this.isSignature(0, b.LOCAL_FILE_HEADER)
                                  ? new Error("Corrupted zip: can't find end of central directory")
                                  : new Error(
                                      "Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html",
                                    )
                              this.reader.setIndex(I)
                              var B = I
                              if (
                                (this.checkSignature(b.CENTRAL_DIRECTORY_END),
                                this.readBlockEndOfCentral(),
                                this.diskNumber === y.MAX_VALUE_16BITS ||
                                  this.diskWithCentralDirStart === y.MAX_VALUE_16BITS ||
                                  this.centralDirRecordsOnThisDisk === y.MAX_VALUE_16BITS ||
                                  this.centralDirRecords === y.MAX_VALUE_16BITS ||
                                  this.centralDirSize === y.MAX_VALUE_32BITS ||
                                  this.centralDirOffset === y.MAX_VALUE_32BITS)
                              ) {
                                if (
                                  ((this.zip64 = !0),
                                  (I = this.reader.lastIndexOfSignature(
                                    b.ZIP64_CENTRAL_DIRECTORY_LOCATOR,
                                  )) < 0)
                                )
                                  throw new Error(
                                    "Corrupted zip: can't find the ZIP64 end of central directory locator",
                                  )
                                if (
                                  (this.reader.setIndex(I),
                                  this.checkSignature(b.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                                  this.readBlockZip64EndOfCentralLocator(),
                                  !this.isSignature(
                                    this.relativeOffsetEndOfZip64CentralDir,
                                    b.ZIP64_CENTRAL_DIRECTORY_END,
                                  ) &&
                                    ((this.relativeOffsetEndOfZip64CentralDir =
                                      this.reader.lastIndexOfSignature(
                                        b.ZIP64_CENTRAL_DIRECTORY_END,
                                      )),
                                    this.relativeOffsetEndOfZip64CentralDir < 0))
                                )
                                  throw new Error(
                                    "Corrupted zip: can't find the ZIP64 end of central directory",
                                  )
                                ;(this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                                  this.checkSignature(b.ZIP64_CENTRAL_DIRECTORY_END),
                                  this.readBlockZip64EndOfCentral())
                              }
                              var E = this.centralDirOffset + this.centralDirSize
                              this.zip64 && ((E += 20), (E += 12 + this.zip64EndOfCentralSize))
                              var O = B - E
                              if (0 < O)
                                this.isSignature(B, b.CENTRAL_FILE_HEADER) || (this.reader.zero = O)
                              else if (O < 0)
                                throw new Error('Corrupted zip: missing ' + Math.abs(O) + ' bytes.')
                            },
                            prepareReader: function (I) {
                              this.reader = m(I)
                            },
                            load: function (I) {
                              ;(this.prepareReader(I),
                                this.readEndOfCentral(),
                                this.readCentralDir(),
                                this.readLocalFiles())
                            },
                          }),
                            (p.exports = T))
                        },
                        {
                          './reader/readerFor': 22,
                          './signature': 23,
                          './support': 30,
                          './utils': 32,
                          './zipEntry': 34,
                        },
                      ],
                      34: [
                        function (h, p, g) {
                          var m = h('./reader/readerFor'),
                            y = h('./utils'),
                            b = h('./compressedObject'),
                            w = h('./crc32'),
                            C = h('./utf8'),
                            T = h('./compressions'),
                            I = h('./support')
                          function B(E, O) {
                            ;((this.options = E), (this.loadOptions = O))
                          }
                          ;((B.prototype = {
                            isEncrypted: function () {
                              return (1 & this.bitFlag) == 1
                            },
                            useUTF8: function () {
                              return (2048 & this.bitFlag) == 2048
                            },
                            readLocalPart: function (E) {
                              var O, P
                              if (
                                (E.skip(22),
                                (this.fileNameLength = E.readInt(2)),
                                (P = E.readInt(2)),
                                (this.fileName = E.readData(this.fileNameLength)),
                                E.skip(P),
                                this.compressedSize === -1 || this.uncompressedSize === -1)
                              )
                                throw new Error(
                                  "Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)",
                                )
                              if (
                                (O = (function ($) {
                                  for (var F in T)
                                    if (
                                      Object.prototype.hasOwnProperty.call(T, F) &&
                                      T[F].magic === $
                                    )
                                      return T[F]
                                  return null
                                })(this.compressionMethod)) === null
                              )
                                throw new Error(
                                  'Corrupted zip : compression ' +
                                    y.pretty(this.compressionMethod) +
                                    ' unknown (inner file : ' +
                                    y.transformTo('string', this.fileName) +
                                    ')',
                                )
                              this.decompressed = new b(
                                this.compressedSize,
                                this.uncompressedSize,
                                this.crc32,
                                O,
                                E.readData(this.compressedSize),
                              )
                            },
                            readCentralPart: function (E) {
                              ;((this.versionMadeBy = E.readInt(2)),
                                E.skip(2),
                                (this.bitFlag = E.readInt(2)),
                                (this.compressionMethod = E.readString(2)),
                                (this.date = E.readDate()),
                                (this.crc32 = E.readInt(4)),
                                (this.compressedSize = E.readInt(4)),
                                (this.uncompressedSize = E.readInt(4)))
                              var O = E.readInt(2)
                              if (
                                ((this.extraFieldsLength = E.readInt(2)),
                                (this.fileCommentLength = E.readInt(2)),
                                (this.diskNumberStart = E.readInt(2)),
                                (this.internalFileAttributes = E.readInt(2)),
                                (this.externalFileAttributes = E.readInt(4)),
                                (this.localHeaderOffset = E.readInt(4)),
                                this.isEncrypted())
                              )
                                throw new Error('Encrypted zip are not supported')
                              ;(E.skip(O),
                                this.readExtraFields(E),
                                this.parseZIP64ExtraField(E),
                                (this.fileComment = E.readData(this.fileCommentLength)))
                            },
                            processAttributes: function () {
                              ;((this.unixPermissions = null), (this.dosPermissions = null))
                              var E = this.versionMadeBy >> 8
                              ;((this.dir = !!(16 & this.externalFileAttributes)),
                                E == 0 && (this.dosPermissions = 63 & this.externalFileAttributes),
                                E == 3 &&
                                  (this.unixPermissions =
                                    (this.externalFileAttributes >> 16) & 65535),
                                this.dir || this.fileNameStr.slice(-1) !== '/' || (this.dir = !0))
                            },
                            parseZIP64ExtraField: function () {
                              if (this.extraFields[1]) {
                                var E = m(this.extraFields[1].value)
                                ;(this.uncompressedSize === y.MAX_VALUE_32BITS &&
                                  (this.uncompressedSize = E.readInt(8)),
                                  this.compressedSize === y.MAX_VALUE_32BITS &&
                                    (this.compressedSize = E.readInt(8)),
                                  this.localHeaderOffset === y.MAX_VALUE_32BITS &&
                                    (this.localHeaderOffset = E.readInt(8)),
                                  this.diskNumberStart === y.MAX_VALUE_32BITS &&
                                    (this.diskNumberStart = E.readInt(4)))
                              }
                            },
                            readExtraFields: function (E) {
                              var O,
                                P,
                                $,
                                F = E.index + this.extraFieldsLength
                              for (this.extraFields || (this.extraFields = {}); E.index + 4 < F; )
                                ((O = E.readInt(2)),
                                  (P = E.readInt(2)),
                                  ($ = E.readData(P)),
                                  (this.extraFields[O] = { id: O, length: P, value: $ }))
                              E.setIndex(F)
                            },
                            handleUTF8: function () {
                              var E = I.uint8array ? 'uint8array' : 'array'
                              if (this.useUTF8())
                                ((this.fileNameStr = C.utf8decode(this.fileName)),
                                  (this.fileCommentStr = C.utf8decode(this.fileComment)))
                              else {
                                var O = this.findExtraFieldUnicodePath()
                                if (O !== null) this.fileNameStr = O
                                else {
                                  var P = y.transformTo(E, this.fileName)
                                  this.fileNameStr = this.loadOptions.decodeFileName(P)
                                }
                                var $ = this.findExtraFieldUnicodeComment()
                                if ($ !== null) this.fileCommentStr = $
                                else {
                                  var F = y.transformTo(E, this.fileComment)
                                  this.fileCommentStr = this.loadOptions.decodeFileName(F)
                                }
                              }
                            },
                            findExtraFieldUnicodePath: function () {
                              var E = this.extraFields[28789]
                              if (E) {
                                var O = m(E.value)
                                return O.readInt(1) !== 1 || w(this.fileName) !== O.readInt(4)
                                  ? null
                                  : C.utf8decode(O.readData(E.length - 5))
                              }
                              return null
                            },
                            findExtraFieldUnicodeComment: function () {
                              var E = this.extraFields[25461]
                              if (E) {
                                var O = m(E.value)
                                return O.readInt(1) !== 1 || w(this.fileComment) !== O.readInt(4)
                                  ? null
                                  : C.utf8decode(O.readData(E.length - 5))
                              }
                              return null
                            },
                          }),
                            (p.exports = B))
                        },
                        {
                          './compressedObject': 2,
                          './compressions': 3,
                          './crc32': 4,
                          './reader/readerFor': 22,
                          './support': 30,
                          './utf8': 31,
                          './utils': 32,
                        },
                      ],
                      35: [
                        function (h, p, g) {
                          function m(O, P, $) {
                            ;((this.name = O),
                              (this.dir = $.dir),
                              (this.date = $.date),
                              (this.comment = $.comment),
                              (this.unixPermissions = $.unixPermissions),
                              (this.dosPermissions = $.dosPermissions),
                              (this._data = P),
                              (this._dataBinary = $.binary),
                              (this.options = {
                                compression: $.compression,
                                compressionOptions: $.compressionOptions,
                              }))
                          }
                          var y = h('./stream/StreamHelper'),
                            b = h('./stream/DataWorker'),
                            w = h('./utf8'),
                            C = h('./compressedObject'),
                            T = h('./stream/GenericWorker')
                          m.prototype = {
                            internalStream: function (O) {
                              var P = null,
                                $ = 'string'
                              try {
                                if (!O) throw new Error('No output type specified.')
                                var F = ($ = O.toLowerCase()) === 'string' || $ === 'text'
                                ;(($ !== 'binarystring' && $ !== 'text') || ($ = 'string'),
                                  (P = this._decompressWorker()))
                                var M = !this._dataBinary
                                ;(M && !F && (P = P.pipe(new w.Utf8EncodeWorker())),
                                  !M && F && (P = P.pipe(new w.Utf8DecodeWorker())))
                              } catch (R) {
                                ;(P = new T('error')).error(R)
                              }
                              return new y(P, $, '')
                            },
                            async: function (O, P) {
                              return this.internalStream(O).accumulate(P)
                            },
                            nodeStream: function (O, P) {
                              return this.internalStream(O || 'nodebuffer').toNodejsStream(P)
                            },
                            _compressWorker: function (O, P) {
                              if (
                                this._data instanceof C &&
                                this._data.compression.magic === O.magic
                              )
                                return this._data.getCompressedWorker()
                              var $ = this._decompressWorker()
                              return (
                                this._dataBinary || ($ = $.pipe(new w.Utf8EncodeWorker())),
                                C.createWorkerFrom($, O, P)
                              )
                            },
                            _decompressWorker: function () {
                              return this._data instanceof C
                                ? this._data.getContentWorker()
                                : this._data instanceof T
                                  ? this._data
                                  : new b(this._data)
                            },
                          }
                          for (
                            var I = [
                                'asText',
                                'asBinary',
                                'asNodeBuffer',
                                'asUint8Array',
                                'asArrayBuffer',
                              ],
                              B = function () {
                                throw new Error(
                                  'This method has been removed in JSZip 3.0, please check the upgrade guide.',
                                )
                              },
                              E = 0;
                            E < I.length;
                            E++
                          )
                            m.prototype[I[E]] = B
                          p.exports = m
                        },
                        {
                          './compressedObject': 2,
                          './stream/DataWorker': 27,
                          './stream/GenericWorker': 28,
                          './stream/StreamHelper': 29,
                          './utf8': 31,
                        },
                      ],
                      36: [
                        function (h, p, g) {
                          ;(function (m) {
                            var y,
                              b,
                              w = m.MutationObserver || m.WebKitMutationObserver
                            if (w) {
                              var C = 0,
                                T = new w(O),
                                I = m.document.createTextNode('')
                              ;(T.observe(I, { characterData: !0 }),
                                (y = function () {
                                  I.data = C = ++C % 2
                                }))
                            } else if (m.setImmediate || m.MessageChannel === void 0)
                              y =
                                'document' in m &&
                                'onreadystatechange' in m.document.createElement('script')
                                  ? function () {
                                      var P = m.document.createElement('script')
                                      ;((P.onreadystatechange = function () {
                                        ;(O(),
                                          (P.onreadystatechange = null),
                                          P.parentNode.removeChild(P),
                                          (P = null))
                                      }),
                                        m.document.documentElement.appendChild(P))
                                    }
                                  : function () {
                                      setTimeout(O, 0)
                                    }
                            else {
                              var B = new m.MessageChannel()
                              ;((B.port1.onmessage = O),
                                (y = function () {
                                  B.port2.postMessage(0)
                                }))
                            }
                            var E = []
                            function O() {
                              var P, $
                              b = !0
                              for (var F = E.length; F; ) {
                                for ($ = E, E = [], P = -1; ++P < F; ) $[P]()
                                F = E.length
                              }
                              b = !1
                            }
                            p.exports = function (P) {
                              E.push(P) !== 1 || b || y()
                            }
                          }).call(
                            this,
                            o !== void 0
                              ? o
                              : typeof self < 'u'
                                ? self
                                : typeof window < 'u'
                                  ? window
                                  : {},
                          )
                        },
                        {},
                      ],
                      37: [
                        function (h, p, g) {
                          var m = h('immediate')
                          function y() {}
                          var b = {},
                            w = ['REJECTED'],
                            C = ['FULFILLED'],
                            T = ['PENDING']
                          function I(F) {
                            if (typeof F != 'function')
                              throw new TypeError('resolver must be a function')
                            ;((this.state = T),
                              (this.queue = []),
                              (this.outcome = void 0),
                              F !== y && P(this, F))
                          }
                          function B(F, M, R) {
                            ;((this.promise = F),
                              typeof M == 'function' &&
                                ((this.onFulfilled = M),
                                (this.callFulfilled = this.otherCallFulfilled)),
                              typeof R == 'function' &&
                                ((this.onRejected = R),
                                (this.callRejected = this.otherCallRejected)))
                          }
                          function E(F, M, R) {
                            m(function () {
                              var k
                              try {
                                k = M(R)
                              } catch (v) {
                                return b.reject(F, v)
                              }
                              k === F
                                ? b.reject(F, new TypeError('Cannot resolve promise with itself'))
                                : b.resolve(F, k)
                            })
                          }
                          function O(F) {
                            var M = F && F.then
                            if (
                              F &&
                              (typeof F == 'object' || typeof F == 'function') &&
                              typeof M == 'function'
                            )
                              return function () {
                                M.apply(F, arguments)
                              }
                          }
                          function P(F, M) {
                            var R = !1
                            function k(_) {
                              R || ((R = !0), b.reject(F, _))
                            }
                            function v(_) {
                              R || ((R = !0), b.resolve(F, _))
                            }
                            var x = $(function () {
                              M(v, k)
                            })
                            x.status === 'error' && k(x.value)
                          }
                          function $(F, M) {
                            var R = {}
                            try {
                              ;((R.value = F(M)), (R.status = 'success'))
                            } catch (k) {
                              ;((R.status = 'error'), (R.value = k))
                            }
                            return R
                          }
                          ;(((p.exports = I).prototype.finally = function (F) {
                            if (typeof F != 'function') return this
                            var M = this.constructor
                            return this.then(
                              function (R) {
                                return M.resolve(F()).then(function () {
                                  return R
                                })
                              },
                              function (R) {
                                return M.resolve(F()).then(function () {
                                  throw R
                                })
                              },
                            )
                          }),
                            (I.prototype.catch = function (F) {
                              return this.then(null, F)
                            }),
                            (I.prototype.then = function (F, M) {
                              if (
                                (typeof F != 'function' && this.state === C) ||
                                (typeof M != 'function' && this.state === w)
                              )
                                return this
                              var R = new this.constructor(y)
                              return (
                                this.state !== T
                                  ? E(R, this.state === C ? F : M, this.outcome)
                                  : this.queue.push(new B(R, F, M)),
                                R
                              )
                            }),
                            (B.prototype.callFulfilled = function (F) {
                              b.resolve(this.promise, F)
                            }),
                            (B.prototype.otherCallFulfilled = function (F) {
                              E(this.promise, this.onFulfilled, F)
                            }),
                            (B.prototype.callRejected = function (F) {
                              b.reject(this.promise, F)
                            }),
                            (B.prototype.otherCallRejected = function (F) {
                              E(this.promise, this.onRejected, F)
                            }),
                            (b.resolve = function (F, M) {
                              var R = $(O, M)
                              if (R.status === 'error') return b.reject(F, R.value)
                              var k = R.value
                              if (k) P(F, k)
                              else {
                                ;((F.state = C), (F.outcome = M))
                                for (var v = -1, x = F.queue.length; ++v < x; )
                                  F.queue[v].callFulfilled(M)
                              }
                              return F
                            }),
                            (b.reject = function (F, M) {
                              ;((F.state = w), (F.outcome = M))
                              for (var R = -1, k = F.queue.length; ++R < k; )
                                F.queue[R].callRejected(M)
                              return F
                            }),
                            (I.resolve = function (F) {
                              return F instanceof this ? F : b.resolve(new this(y), F)
                            }),
                            (I.reject = function (F) {
                              var M = new this(y)
                              return b.reject(M, F)
                            }),
                            (I.all = function (F) {
                              var M = this
                              if (Object.prototype.toString.call(F) !== '[object Array]')
                                return this.reject(new TypeError('must be an array'))
                              var R = F.length,
                                k = !1
                              if (!R) return this.resolve([])
                              for (var v = new Array(R), x = 0, _ = -1, S = new this(y); ++_ < R; )
                                A(F[_], _)
                              return S
                              function A(j, L) {
                                M.resolve(j).then(
                                  function (H) {
                                    ;((v[L] = H), ++x !== R || k || ((k = !0), b.resolve(S, v)))
                                  },
                                  function (H) {
                                    k || ((k = !0), b.reject(S, H))
                                  },
                                )
                              }
                            }),
                            (I.race = function (F) {
                              if (Object.prototype.toString.call(F) !== '[object Array]')
                                return this.reject(new TypeError('must be an array'))
                              var M = F.length,
                                R = !1
                              if (!M) return this.resolve([])
                              for (var k, v = -1, x = new this(y); ++v < M; )
                                ((k = F[v]),
                                  this.resolve(k).then(
                                    function (_) {
                                      R || ((R = !0), b.resolve(x, _))
                                    },
                                    function (_) {
                                      R || ((R = !0), b.reject(x, _))
                                    },
                                  ))
                              return x
                            }))
                        },
                        { immediate: 36 },
                      ],
                      38: [
                        function (h, p, g) {
                          var m = {}
                          ;((0, h('./lib/utils/common').assign)(
                            m,
                            h('./lib/deflate'),
                            h('./lib/inflate'),
                            h('./lib/zlib/constants'),
                          ),
                            (p.exports = m))
                        },
                        {
                          './lib/deflate': 39,
                          './lib/inflate': 40,
                          './lib/utils/common': 41,
                          './lib/zlib/constants': 44,
                        },
                      ],
                      39: [
                        function (h, p, g) {
                          var m = h('./zlib/deflate'),
                            y = h('./utils/common'),
                            b = h('./utils/strings'),
                            w = h('./zlib/messages'),
                            C = h('./zlib/zstream'),
                            T = Object.prototype.toString
                          function I(E) {
                            if (!(this instanceof I)) return new I(E)
                            this.options = y.assign(
                              {
                                level: -1,
                                method: 8,
                                chunkSize: 16384,
                                windowBits: 15,
                                memLevel: 8,
                                strategy: 0,
                                to: '',
                              },
                              E || {},
                            )
                            var O = this.options
                            ;(O.raw && 0 < O.windowBits
                              ? (O.windowBits = -O.windowBits)
                              : O.gzip &&
                                0 < O.windowBits &&
                                O.windowBits < 16 &&
                                (O.windowBits += 16),
                              (this.err = 0),
                              (this.msg = ''),
                              (this.ended = !1),
                              (this.chunks = []),
                              (this.strm = new C()),
                              (this.strm.avail_out = 0))
                            var P = m.deflateInit2(
                              this.strm,
                              O.level,
                              O.method,
                              O.windowBits,
                              O.memLevel,
                              O.strategy,
                            )
                            if (P !== 0) throw new Error(w[P])
                            if (
                              (O.header && m.deflateSetHeader(this.strm, O.header), O.dictionary)
                            ) {
                              var $
                              if (
                                (($ =
                                  typeof O.dictionary == 'string'
                                    ? b.string2buf(O.dictionary)
                                    : T.call(O.dictionary) === '[object ArrayBuffer]'
                                      ? new Uint8Array(O.dictionary)
                                      : O.dictionary),
                                (P = m.deflateSetDictionary(this.strm, $)) !== 0)
                              )
                                throw new Error(w[P])
                              this._dict_set = !0
                            }
                          }
                          function B(E, O) {
                            var P = new I(O)
                            if ((P.push(E, !0), P.err)) throw P.msg || w[P.err]
                            return P.result
                          }
                          ;((I.prototype.push = function (E, O) {
                            var P,
                              $,
                              F = this.strm,
                              M = this.options.chunkSize
                            if (this.ended) return !1
                            ;(($ = O === ~~O ? O : O === !0 ? 4 : 0),
                              typeof E == 'string'
                                ? (F.input = b.string2buf(E))
                                : T.call(E) === '[object ArrayBuffer]'
                                  ? (F.input = new Uint8Array(E))
                                  : (F.input = E),
                              (F.next_in = 0),
                              (F.avail_in = F.input.length))
                            do {
                              if (
                                (F.avail_out === 0 &&
                                  ((F.output = new y.Buf8(M)), (F.next_out = 0), (F.avail_out = M)),
                                (P = m.deflate(F, $)) !== 1 && P !== 0)
                              )
                                return (this.onEnd(P), !(this.ended = !0))
                              ;(F.avail_out !== 0 && (F.avail_in !== 0 || ($ !== 4 && $ !== 2))) ||
                                (this.options.to === 'string'
                                  ? this.onData(b.buf2binstring(y.shrinkBuf(F.output, F.next_out)))
                                  : this.onData(y.shrinkBuf(F.output, F.next_out)))
                            } while ((0 < F.avail_in || F.avail_out === 0) && P !== 1)
                            return $ === 4
                              ? ((P = m.deflateEnd(this.strm)),
                                this.onEnd(P),
                                (this.ended = !0),
                                P === 0)
                              : $ !== 2 || (this.onEnd(0), !(F.avail_out = 0))
                          }),
                            (I.prototype.onData = function (E) {
                              this.chunks.push(E)
                            }),
                            (I.prototype.onEnd = function (E) {
                              ;(E === 0 &&
                                (this.options.to === 'string'
                                  ? (this.result = this.chunks.join(''))
                                  : (this.result = y.flattenChunks(this.chunks))),
                                (this.chunks = []),
                                (this.err = E),
                                (this.msg = this.strm.msg))
                            }),
                            (g.Deflate = I),
                            (g.deflate = B),
                            (g.deflateRaw = function (E, O) {
                              return (((O = O || {}).raw = !0), B(E, O))
                            }),
                            (g.gzip = function (E, O) {
                              return (((O = O || {}).gzip = !0), B(E, O))
                            }))
                        },
                        {
                          './utils/common': 41,
                          './utils/strings': 42,
                          './zlib/deflate': 46,
                          './zlib/messages': 51,
                          './zlib/zstream': 53,
                        },
                      ],
                      40: [
                        function (h, p, g) {
                          var m = h('./zlib/inflate'),
                            y = h('./utils/common'),
                            b = h('./utils/strings'),
                            w = h('./zlib/constants'),
                            C = h('./zlib/messages'),
                            T = h('./zlib/zstream'),
                            I = h('./zlib/gzheader'),
                            B = Object.prototype.toString
                          function E(P) {
                            if (!(this instanceof E)) return new E(P)
                            this.options = y.assign(
                              { chunkSize: 16384, windowBits: 0, to: '' },
                              P || {},
                            )
                            var $ = this.options
                            ;($.raw &&
                              0 <= $.windowBits &&
                              $.windowBits < 16 &&
                              (($.windowBits = -$.windowBits),
                              $.windowBits === 0 && ($.windowBits = -15)),
                              !(0 <= $.windowBits && $.windowBits < 16) ||
                                (P && P.windowBits) ||
                                ($.windowBits += 32),
                              15 < $.windowBits &&
                                $.windowBits < 48 &&
                                !(15 & $.windowBits) &&
                                ($.windowBits |= 15),
                              (this.err = 0),
                              (this.msg = ''),
                              (this.ended = !1),
                              (this.chunks = []),
                              (this.strm = new T()),
                              (this.strm.avail_out = 0))
                            var F = m.inflateInit2(this.strm, $.windowBits)
                            if (F !== w.Z_OK) throw new Error(C[F])
                            ;((this.header = new I()), m.inflateGetHeader(this.strm, this.header))
                          }
                          function O(P, $) {
                            var F = new E($)
                            if ((F.push(P, !0), F.err)) throw F.msg || C[F.err]
                            return F.result
                          }
                          ;((E.prototype.push = function (P, $) {
                            var F,
                              M,
                              R,
                              k,
                              v,
                              x,
                              _ = this.strm,
                              S = this.options.chunkSize,
                              A = this.options.dictionary,
                              j = !1
                            if (this.ended) return !1
                            ;((M = $ === ~~$ ? $ : $ === !0 ? w.Z_FINISH : w.Z_NO_FLUSH),
                              typeof P == 'string'
                                ? (_.input = b.binstring2buf(P))
                                : B.call(P) === '[object ArrayBuffer]'
                                  ? (_.input = new Uint8Array(P))
                                  : (_.input = P),
                              (_.next_in = 0),
                              (_.avail_in = _.input.length))
                            do {
                              if (
                                (_.avail_out === 0 &&
                                  ((_.output = new y.Buf8(S)), (_.next_out = 0), (_.avail_out = S)),
                                (F = m.inflate(_, w.Z_NO_FLUSH)) === w.Z_NEED_DICT &&
                                  A &&
                                  ((x =
                                    typeof A == 'string'
                                      ? b.string2buf(A)
                                      : B.call(A) === '[object ArrayBuffer]'
                                        ? new Uint8Array(A)
                                        : A),
                                  (F = m.inflateSetDictionary(this.strm, x))),
                                F === w.Z_BUF_ERROR && j === !0 && ((F = w.Z_OK), (j = !1)),
                                F !== w.Z_STREAM_END && F !== w.Z_OK)
                              )
                                return (this.onEnd(F), !(this.ended = !0))
                              ;(_.next_out &&
                                ((_.avail_out !== 0 &&
                                  F !== w.Z_STREAM_END &&
                                  (_.avail_in !== 0 ||
                                    (M !== w.Z_FINISH && M !== w.Z_SYNC_FLUSH))) ||
                                  (this.options.to === 'string'
                                    ? ((R = b.utf8border(_.output, _.next_out)),
                                      (k = _.next_out - R),
                                      (v = b.buf2string(_.output, R)),
                                      (_.next_out = k),
                                      (_.avail_out = S - k),
                                      k && y.arraySet(_.output, _.output, R, k, 0),
                                      this.onData(v))
                                    : this.onData(y.shrinkBuf(_.output, _.next_out)))),
                                _.avail_in === 0 && _.avail_out === 0 && (j = !0))
                            } while ((0 < _.avail_in || _.avail_out === 0) && F !== w.Z_STREAM_END)
                            return (
                              F === w.Z_STREAM_END && (M = w.Z_FINISH),
                              M === w.Z_FINISH
                                ? ((F = m.inflateEnd(this.strm)),
                                  this.onEnd(F),
                                  (this.ended = !0),
                                  F === w.Z_OK)
                                : M !== w.Z_SYNC_FLUSH || (this.onEnd(w.Z_OK), !(_.avail_out = 0))
                            )
                          }),
                            (E.prototype.onData = function (P) {
                              this.chunks.push(P)
                            }),
                            (E.prototype.onEnd = function (P) {
                              ;(P === w.Z_OK &&
                                (this.options.to === 'string'
                                  ? (this.result = this.chunks.join(''))
                                  : (this.result = y.flattenChunks(this.chunks))),
                                (this.chunks = []),
                                (this.err = P),
                                (this.msg = this.strm.msg))
                            }),
                            (g.Inflate = E),
                            (g.inflate = O),
                            (g.inflateRaw = function (P, $) {
                              return ((($ = $ || {}).raw = !0), O(P, $))
                            }),
                            (g.ungzip = O))
                        },
                        {
                          './utils/common': 41,
                          './utils/strings': 42,
                          './zlib/constants': 44,
                          './zlib/gzheader': 47,
                          './zlib/inflate': 49,
                          './zlib/messages': 51,
                          './zlib/zstream': 53,
                        },
                      ],
                      41: [
                        function (h, p, g) {
                          var m =
                            typeof Uint8Array < 'u' &&
                            typeof Uint16Array < 'u' &&
                            typeof Int32Array < 'u'
                          ;((g.assign = function (w) {
                            for (var C = Array.prototype.slice.call(arguments, 1); C.length; ) {
                              var T = C.shift()
                              if (T) {
                                if (typeof T != 'object')
                                  throw new TypeError(T + 'must be non-object')
                                for (var I in T) T.hasOwnProperty(I) && (w[I] = T[I])
                              }
                            }
                            return w
                          }),
                            (g.shrinkBuf = function (w, C) {
                              return w.length === C
                                ? w
                                : w.subarray
                                  ? w.subarray(0, C)
                                  : ((w.length = C), w)
                            }))
                          var y = {
                              arraySet: function (w, C, T, I, B) {
                                if (C.subarray && w.subarray) w.set(C.subarray(T, T + I), B)
                                else for (var E = 0; E < I; E++) w[B + E] = C[T + E]
                              },
                              flattenChunks: function (w) {
                                var C, T, I, B, E, O
                                for (C = I = 0, T = w.length; C < T; C++) I += w[C].length
                                for (O = new Uint8Array(I), C = B = 0, T = w.length; C < T; C++)
                                  ((E = w[C]), O.set(E, B), (B += E.length))
                                return O
                              },
                            },
                            b = {
                              arraySet: function (w, C, T, I, B) {
                                for (var E = 0; E < I; E++) w[B + E] = C[T + E]
                              },
                              flattenChunks: function (w) {
                                return [].concat.apply([], w)
                              },
                            }
                          ;((g.setTyped = function (w) {
                            w
                              ? ((g.Buf8 = Uint8Array),
                                (g.Buf16 = Uint16Array),
                                (g.Buf32 = Int32Array),
                                g.assign(g, y))
                              : ((g.Buf8 = Array),
                                (g.Buf16 = Array),
                                (g.Buf32 = Array),
                                g.assign(g, b))
                          }),
                            g.setTyped(m))
                        },
                        {},
                      ],
                      42: [
                        function (h, p, g) {
                          var m = h('./common'),
                            y = !0,
                            b = !0
                          try {
                            String.fromCharCode.apply(null, [0])
                          } catch {
                            y = !1
                          }
                          try {
                            String.fromCharCode.apply(null, new Uint8Array(1))
                          } catch {
                            b = !1
                          }
                          for (var w = new m.Buf8(256), C = 0; C < 256; C++)
                            w[C] =
                              252 <= C
                                ? 6
                                : 248 <= C
                                  ? 5
                                  : 240 <= C
                                    ? 4
                                    : 224 <= C
                                      ? 3
                                      : 192 <= C
                                        ? 2
                                        : 1
                          function T(I, B) {
                            if (B < 65537 && ((I.subarray && b) || (!I.subarray && y)))
                              return String.fromCharCode.apply(null, m.shrinkBuf(I, B))
                            for (var E = '', O = 0; O < B; O++) E += String.fromCharCode(I[O])
                            return E
                          }
                          ;((w[254] = w[254] = 1),
                            (g.string2buf = function (I) {
                              var B,
                                E,
                                O,
                                P,
                                $,
                                F = I.length,
                                M = 0
                              for (P = 0; P < F; P++)
                                ((64512 & (E = I.charCodeAt(P))) == 55296 &&
                                  P + 1 < F &&
                                  (64512 & (O = I.charCodeAt(P + 1))) == 56320 &&
                                  ((E = 65536 + ((E - 55296) << 10) + (O - 56320)), P++),
                                  (M += E < 128 ? 1 : E < 2048 ? 2 : E < 65536 ? 3 : 4))
                              for (B = new m.Buf8(M), P = $ = 0; $ < M; P++)
                                ((64512 & (E = I.charCodeAt(P))) == 55296 &&
                                  P + 1 < F &&
                                  (64512 & (O = I.charCodeAt(P + 1))) == 56320 &&
                                  ((E = 65536 + ((E - 55296) << 10) + (O - 56320)), P++),
                                  E < 128
                                    ? (B[$++] = E)
                                    : (E < 2048
                                        ? (B[$++] = 192 | (E >>> 6))
                                        : (E < 65536
                                            ? (B[$++] = 224 | (E >>> 12))
                                            : ((B[$++] = 240 | (E >>> 18)),
                                              (B[$++] = 128 | ((E >>> 12) & 63))),
                                          (B[$++] = 128 | ((E >>> 6) & 63))),
                                      (B[$++] = 128 | (63 & E))))
                              return B
                            }),
                            (g.buf2binstring = function (I) {
                              return T(I, I.length)
                            }),
                            (g.binstring2buf = function (I) {
                              for (var B = new m.Buf8(I.length), E = 0, O = B.length; E < O; E++)
                                B[E] = I.charCodeAt(E)
                              return B
                            }),
                            (g.buf2string = function (I, B) {
                              var E,
                                O,
                                P,
                                $,
                                F = B || I.length,
                                M = new Array(2 * F)
                              for (E = O = 0; E < F; )
                                if ((P = I[E++]) < 128) M[O++] = P
                                else if (4 < ($ = w[P])) ((M[O++] = 65533), (E += $ - 1))
                                else {
                                  for (P &= $ === 2 ? 31 : $ === 3 ? 15 : 7; 1 < $ && E < F; )
                                    ((P = (P << 6) | (63 & I[E++])), $--)
                                  1 < $
                                    ? (M[O++] = 65533)
                                    : P < 65536
                                      ? (M[O++] = P)
                                      : ((P -= 65536),
                                        (M[O++] = 55296 | ((P >> 10) & 1023)),
                                        (M[O++] = 56320 | (1023 & P)))
                                }
                              return T(M, O)
                            }),
                            (g.utf8border = function (I, B) {
                              var E
                              for (
                                (B = B || I.length) > I.length && (B = I.length), E = B - 1;
                                0 <= E && (192 & I[E]) == 128;

                              )
                                E--
                              return E < 0 || E === 0 ? B : E + w[I[E]] > B ? E : B
                            }))
                        },
                        { './common': 41 },
                      ],
                      43: [
                        function (h, p, g) {
                          p.exports = function (m, y, b, w) {
                            for (
                              var C = (65535 & m) | 0, T = ((m >>> 16) & 65535) | 0, I = 0;
                              b !== 0;

                            ) {
                              for (
                                b -= I = 2e3 < b ? 2e3 : b;
                                (T = (T + (C = (C + y[w++]) | 0)) | 0), --I;

                              );
                              ;((C %= 65521), (T %= 65521))
                            }
                            return C | (T << 16) | 0
                          }
                        },
                        {},
                      ],
                      44: [
                        function (h, p, g) {
                          p.exports = {
                            Z_NO_FLUSH: 0,
                            Z_PARTIAL_FLUSH: 1,
                            Z_SYNC_FLUSH: 2,
                            Z_FULL_FLUSH: 3,
                            Z_FINISH: 4,
                            Z_BLOCK: 5,
                            Z_TREES: 6,
                            Z_OK: 0,
                            Z_STREAM_END: 1,
                            Z_NEED_DICT: 2,
                            Z_ERRNO: -1,
                            Z_STREAM_ERROR: -2,
                            Z_DATA_ERROR: -3,
                            Z_BUF_ERROR: -5,
                            Z_NO_COMPRESSION: 0,
                            Z_BEST_SPEED: 1,
                            Z_BEST_COMPRESSION: 9,
                            Z_DEFAULT_COMPRESSION: -1,
                            Z_FILTERED: 1,
                            Z_HUFFMAN_ONLY: 2,
                            Z_RLE: 3,
                            Z_FIXED: 4,
                            Z_DEFAULT_STRATEGY: 0,
                            Z_BINARY: 0,
                            Z_TEXT: 1,
                            Z_UNKNOWN: 2,
                            Z_DEFLATED: 8,
                          }
                        },
                        {},
                      ],
                      45: [
                        function (h, p, g) {
                          var m = (function () {
                            for (var y, b = [], w = 0; w < 256; w++) {
                              y = w
                              for (var C = 0; C < 8; C++)
                                y = 1 & y ? 3988292384 ^ (y >>> 1) : y >>> 1
                              b[w] = y
                            }
                            return b
                          })()
                          p.exports = function (y, b, w, C) {
                            var T = m,
                              I = C + w
                            y ^= -1
                            for (var B = C; B < I; B++) y = (y >>> 8) ^ T[255 & (y ^ b[B])]
                            return -1 ^ y
                          }
                        },
                        {},
                      ],
                      46: [
                        function (h, p, g) {
                          var m,
                            y = h('../utils/common'),
                            b = h('./trees'),
                            w = h('./adler32'),
                            C = h('./crc32'),
                            T = h('./messages'),
                            I = -2,
                            B = 258,
                            E = 262,
                            O = 113
                          function P(z, q) {
                            return ((z.msg = T[q]), q)
                          }
                          function $(z) {
                            return (z << 1) - (4 < z ? 9 : 0)
                          }
                          function F(z) {
                            for (var q = z.length; 0 <= --q; ) z[q] = 0
                          }
                          function M(z) {
                            var q = z.state,
                              D = q.pending
                            ;(D > z.avail_out && (D = z.avail_out),
                              D !== 0 &&
                                (y.arraySet(z.output, q.pending_buf, q.pending_out, D, z.next_out),
                                (z.next_out += D),
                                (q.pending_out += D),
                                (z.total_out += D),
                                (z.avail_out -= D),
                                (q.pending -= D),
                                q.pending === 0 && (q.pending_out = 0)))
                          }
                          function R(z, q) {
                            ;(b._tr_flush_block(
                              z,
                              0 <= z.block_start ? z.block_start : -1,
                              z.strstart - z.block_start,
                              q,
                            ),
                              (z.block_start = z.strstart),
                              M(z.strm))
                          }
                          function k(z, q) {
                            z.pending_buf[z.pending++] = q
                          }
                          function v(z, q) {
                            ;((z.pending_buf[z.pending++] = (q >>> 8) & 255),
                              (z.pending_buf[z.pending++] = 255 & q))
                          }
                          function x(z, q) {
                            var D,
                              N,
                              V = z.max_chain_length,
                              W = z.strstart,
                              J = z.prev_length,
                              G = z.nice_match,
                              Z = z.strstart > z.w_size - E ? z.strstart - (z.w_size - E) : 0,
                              rt = z.window,
                              nt = z.w_mask,
                              X = z.prev,
                              Q = z.strstart + B,
                              tt = rt[W + J - 1],
                              st = rt[W + J]
                            ;(z.prev_length >= z.good_match && (V >>= 2),
                              G > z.lookahead && (G = z.lookahead))
                            do
                              if (
                                rt[(D = q) + J] === st &&
                                rt[D + J - 1] === tt &&
                                rt[D] === rt[W] &&
                                rt[++D] === rt[W + 1]
                              ) {
                                ;((W += 2), D++)
                                do;
                                while (
                                  rt[++W] === rt[++D] &&
                                  rt[++W] === rt[++D] &&
                                  rt[++W] === rt[++D] &&
                                  rt[++W] === rt[++D] &&
                                  rt[++W] === rt[++D] &&
                                  rt[++W] === rt[++D] &&
                                  rt[++W] === rt[++D] &&
                                  rt[++W] === rt[++D] &&
                                  W < Q
                                )
                                if (((N = B - (Q - W)), (W = Q - B), J < N)) {
                                  if (((z.match_start = q), G <= (J = N))) break
                                  ;((tt = rt[W + J - 1]), (st = rt[W + J]))
                                }
                              }
                            while ((q = X[q & nt]) > Z && --V != 0)
                            return J <= z.lookahead ? J : z.lookahead
                          }
                          function _(z) {
                            var q,
                              D,
                              N,
                              V,
                              W,
                              J,
                              G,
                              Z,
                              rt,
                              nt,
                              X = z.w_size
                            do {
                              if (
                                ((V = z.window_size - z.lookahead - z.strstart),
                                z.strstart >= X + (X - E))
                              ) {
                                for (
                                  y.arraySet(z.window, z.window, X, X, 0),
                                    z.match_start -= X,
                                    z.strstart -= X,
                                    z.block_start -= X,
                                    q = D = z.hash_size;
                                  (N = z.head[--q]), (z.head[q] = X <= N ? N - X : 0), --D;

                                );
                                for (
                                  q = D = X;
                                  (N = z.prev[--q]), (z.prev[q] = X <= N ? N - X : 0), --D;

                                );
                                V += X
                              }
                              if (z.strm.avail_in === 0) break
                              if (
                                ((J = z.strm),
                                (G = z.window),
                                (Z = z.strstart + z.lookahead),
                                (nt = void 0),
                                (rt = V) < (nt = J.avail_in) && (nt = rt),
                                (D =
                                  nt === 0
                                    ? 0
                                    : ((J.avail_in -= nt),
                                      y.arraySet(G, J.input, J.next_in, nt, Z),
                                      J.state.wrap === 1
                                        ? (J.adler = w(J.adler, G, nt, Z))
                                        : J.state.wrap === 2 && (J.adler = C(J.adler, G, nt, Z)),
                                      (J.next_in += nt),
                                      (J.total_in += nt),
                                      nt)),
                                (z.lookahead += D),
                                z.lookahead + z.insert >= 3)
                              )
                                for (
                                  W = z.strstart - z.insert,
                                    z.ins_h = z.window[W],
                                    z.ins_h =
                                      ((z.ins_h << z.hash_shift) ^ z.window[W + 1]) & z.hash_mask;
                                  z.insert &&
                                  ((z.ins_h =
                                    ((z.ins_h << z.hash_shift) ^ z.window[W + 3 - 1]) &
                                    z.hash_mask),
                                  (z.prev[W & z.w_mask] = z.head[z.ins_h]),
                                  (z.head[z.ins_h] = W),
                                  W++,
                                  z.insert--,
                                  !(z.lookahead + z.insert < 3));

                                );
                            } while (z.lookahead < E && z.strm.avail_in !== 0)
                          }
                          function S(z, q) {
                            for (var D, N; ; ) {
                              if (z.lookahead < E) {
                                if ((_(z), z.lookahead < E && q === 0)) return 1
                                if (z.lookahead === 0) break
                              }
                              if (
                                ((D = 0),
                                z.lookahead >= 3 &&
                                  ((z.ins_h =
                                    ((z.ins_h << z.hash_shift) ^ z.window[z.strstart + 3 - 1]) &
                                    z.hash_mask),
                                  (D = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h]),
                                  (z.head[z.ins_h] = z.strstart)),
                                D !== 0 &&
                                  z.strstart - D <= z.w_size - E &&
                                  (z.match_length = x(z, D)),
                                z.match_length >= 3)
                              )
                                if (
                                  ((N = b._tr_tally(
                                    z,
                                    z.strstart - z.match_start,
                                    z.match_length - 3,
                                  )),
                                  (z.lookahead -= z.match_length),
                                  z.match_length <= z.max_lazy_match && z.lookahead >= 3)
                                ) {
                                  for (
                                    z.match_length--;
                                    z.strstart++,
                                      (z.ins_h =
                                        ((z.ins_h << z.hash_shift) ^ z.window[z.strstart + 3 - 1]) &
                                        z.hash_mask),
                                      (D = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h]),
                                      (z.head[z.ins_h] = z.strstart),
                                      --z.match_length != 0;

                                  );
                                  z.strstart++
                                } else
                                  ((z.strstart += z.match_length),
                                    (z.match_length = 0),
                                    (z.ins_h = z.window[z.strstart]),
                                    (z.ins_h =
                                      ((z.ins_h << z.hash_shift) ^ z.window[z.strstart + 1]) &
                                      z.hash_mask))
                              else
                                ((N = b._tr_tally(z, 0, z.window[z.strstart])),
                                  z.lookahead--,
                                  z.strstart++)
                              if (N && (R(z, !1), z.strm.avail_out === 0)) return 1
                            }
                            return (
                              (z.insert = z.strstart < 2 ? z.strstart : 2),
                              q === 4
                                ? (R(z, !0), z.strm.avail_out === 0 ? 3 : 4)
                                : z.last_lit && (R(z, !1), z.strm.avail_out === 0)
                                  ? 1
                                  : 2
                            )
                          }
                          function A(z, q) {
                            for (var D, N, V; ; ) {
                              if (z.lookahead < E) {
                                if ((_(z), z.lookahead < E && q === 0)) return 1
                                if (z.lookahead === 0) break
                              }
                              if (
                                ((D = 0),
                                z.lookahead >= 3 &&
                                  ((z.ins_h =
                                    ((z.ins_h << z.hash_shift) ^ z.window[z.strstart + 3 - 1]) &
                                    z.hash_mask),
                                  (D = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h]),
                                  (z.head[z.ins_h] = z.strstart)),
                                (z.prev_length = z.match_length),
                                (z.prev_match = z.match_start),
                                (z.match_length = 2),
                                D !== 0 &&
                                  z.prev_length < z.max_lazy_match &&
                                  z.strstart - D <= z.w_size - E &&
                                  ((z.match_length = x(z, D)),
                                  z.match_length <= 5 &&
                                    (z.strategy === 1 ||
                                      (z.match_length === 3 &&
                                        4096 < z.strstart - z.match_start)) &&
                                    (z.match_length = 2)),
                                z.prev_length >= 3 && z.match_length <= z.prev_length)
                              ) {
                                for (
                                  V = z.strstart + z.lookahead - 3,
                                    N = b._tr_tally(
                                      z,
                                      z.strstart - 1 - z.prev_match,
                                      z.prev_length - 3,
                                    ),
                                    z.lookahead -= z.prev_length - 1,
                                    z.prev_length -= 2;
                                  ++z.strstart <= V &&
                                    ((z.ins_h =
                                      ((z.ins_h << z.hash_shift) ^ z.window[z.strstart + 3 - 1]) &
                                      z.hash_mask),
                                    (D = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h]),
                                    (z.head[z.ins_h] = z.strstart)),
                                    --z.prev_length != 0;

                                );
                                if (
                                  ((z.match_available = 0),
                                  (z.match_length = 2),
                                  z.strstart++,
                                  N && (R(z, !1), z.strm.avail_out === 0))
                                )
                                  return 1
                              } else if (z.match_available) {
                                if (
                                  ((N = b._tr_tally(z, 0, z.window[z.strstart - 1])) && R(z, !1),
                                  z.strstart++,
                                  z.lookahead--,
                                  z.strm.avail_out === 0)
                                )
                                  return 1
                              } else ((z.match_available = 1), z.strstart++, z.lookahead--)
                            }
                            return (
                              z.match_available &&
                                ((N = b._tr_tally(z, 0, z.window[z.strstart - 1])),
                                (z.match_available = 0)),
                              (z.insert = z.strstart < 2 ? z.strstart : 2),
                              q === 4
                                ? (R(z, !0), z.strm.avail_out === 0 ? 3 : 4)
                                : z.last_lit && (R(z, !1), z.strm.avail_out === 0)
                                  ? 1
                                  : 2
                            )
                          }
                          function j(z, q, D, N, V) {
                            ;((this.good_length = z),
                              (this.max_lazy = q),
                              (this.nice_length = D),
                              (this.max_chain = N),
                              (this.func = V))
                          }
                          function L() {
                            ;((this.strm = null),
                              (this.status = 0),
                              (this.pending_buf = null),
                              (this.pending_buf_size = 0),
                              (this.pending_out = 0),
                              (this.pending = 0),
                              (this.wrap = 0),
                              (this.gzhead = null),
                              (this.gzindex = 0),
                              (this.method = 8),
                              (this.last_flush = -1),
                              (this.w_size = 0),
                              (this.w_bits = 0),
                              (this.w_mask = 0),
                              (this.window = null),
                              (this.window_size = 0),
                              (this.prev = null),
                              (this.head = null),
                              (this.ins_h = 0),
                              (this.hash_size = 0),
                              (this.hash_bits = 0),
                              (this.hash_mask = 0),
                              (this.hash_shift = 0),
                              (this.block_start = 0),
                              (this.match_length = 0),
                              (this.prev_match = 0),
                              (this.match_available = 0),
                              (this.strstart = 0),
                              (this.match_start = 0),
                              (this.lookahead = 0),
                              (this.prev_length = 0),
                              (this.max_chain_length = 0),
                              (this.max_lazy_match = 0),
                              (this.level = 0),
                              (this.strategy = 0),
                              (this.good_match = 0),
                              (this.nice_match = 0),
                              (this.dyn_ltree = new y.Buf16(1146)),
                              (this.dyn_dtree = new y.Buf16(122)),
                              (this.bl_tree = new y.Buf16(78)),
                              F(this.dyn_ltree),
                              F(this.dyn_dtree),
                              F(this.bl_tree),
                              (this.l_desc = null),
                              (this.d_desc = null),
                              (this.bl_desc = null),
                              (this.bl_count = new y.Buf16(16)),
                              (this.heap = new y.Buf16(573)),
                              F(this.heap),
                              (this.heap_len = 0),
                              (this.heap_max = 0),
                              (this.depth = new y.Buf16(573)),
                              F(this.depth),
                              (this.l_buf = 0),
                              (this.lit_bufsize = 0),
                              (this.last_lit = 0),
                              (this.d_buf = 0),
                              (this.opt_len = 0),
                              (this.static_len = 0),
                              (this.matches = 0),
                              (this.insert = 0),
                              (this.bi_buf = 0),
                              (this.bi_valid = 0))
                          }
                          function H(z) {
                            var q
                            return z && z.state
                              ? ((z.total_in = z.total_out = 0),
                                (z.data_type = 2),
                                ((q = z.state).pending = 0),
                                (q.pending_out = 0),
                                q.wrap < 0 && (q.wrap = -q.wrap),
                                (q.status = q.wrap ? 42 : O),
                                (z.adler = q.wrap === 2 ? 0 : 1),
                                (q.last_flush = 0),
                                b._tr_init(q),
                                0)
                              : P(z, I)
                          }
                          function U(z) {
                            var q = H(z)
                            return (
                              q === 0 &&
                                (function (D) {
                                  ;((D.window_size = 2 * D.w_size),
                                    F(D.head),
                                    (D.max_lazy_match = m[D.level].max_lazy),
                                    (D.good_match = m[D.level].good_length),
                                    (D.nice_match = m[D.level].nice_length),
                                    (D.max_chain_length = m[D.level].max_chain),
                                    (D.strstart = 0),
                                    (D.block_start = 0),
                                    (D.lookahead = 0),
                                    (D.insert = 0),
                                    (D.match_length = D.prev_length = 2),
                                    (D.match_available = 0),
                                    (D.ins_h = 0))
                                })(z.state),
                              q
                            )
                          }
                          function K(z, q, D, N, V, W) {
                            if (!z) return I
                            var J = 1
                            if (
                              (q === -1 && (q = 6),
                              N < 0 ? ((J = 0), (N = -N)) : 15 < N && ((J = 2), (N -= 16)),
                              V < 1 ||
                                9 < V ||
                                D !== 8 ||
                                N < 8 ||
                                15 < N ||
                                q < 0 ||
                                9 < q ||
                                W < 0 ||
                                4 < W)
                            )
                              return P(z, I)
                            N === 8 && (N = 9)
                            var G = new L()
                            return (
                              ((z.state = G).strm = z),
                              (G.wrap = J),
                              (G.gzhead = null),
                              (G.w_bits = N),
                              (G.w_size = 1 << G.w_bits),
                              (G.w_mask = G.w_size - 1),
                              (G.hash_bits = V + 7),
                              (G.hash_size = 1 << G.hash_bits),
                              (G.hash_mask = G.hash_size - 1),
                              (G.hash_shift = ~~((G.hash_bits + 3 - 1) / 3)),
                              (G.window = new y.Buf8(2 * G.w_size)),
                              (G.head = new y.Buf16(G.hash_size)),
                              (G.prev = new y.Buf16(G.w_size)),
                              (G.lit_bufsize = 1 << (V + 6)),
                              (G.pending_buf_size = 4 * G.lit_bufsize),
                              (G.pending_buf = new y.Buf8(G.pending_buf_size)),
                              (G.d_buf = 1 * G.lit_bufsize),
                              (G.l_buf = 3 * G.lit_bufsize),
                              (G.level = q),
                              (G.strategy = W),
                              (G.method = D),
                              U(z)
                            )
                          }
                          ;((m = [
                            new j(0, 0, 0, 0, function (z, q) {
                              var D = 65535
                              for (D > z.pending_buf_size - 5 && (D = z.pending_buf_size - 5); ; ) {
                                if (z.lookahead <= 1) {
                                  if ((_(z), z.lookahead === 0 && q === 0)) return 1
                                  if (z.lookahead === 0) break
                                }
                                ;((z.strstart += z.lookahead), (z.lookahead = 0))
                                var N = z.block_start + D
                                if (
                                  ((z.strstart === 0 || z.strstart >= N) &&
                                    ((z.lookahead = z.strstart - N),
                                    (z.strstart = N),
                                    R(z, !1),
                                    z.strm.avail_out === 0)) ||
                                  (z.strstart - z.block_start >= z.w_size - E &&
                                    (R(z, !1), z.strm.avail_out === 0))
                                )
                                  return 1
                              }
                              return (
                                (z.insert = 0),
                                q === 4
                                  ? (R(z, !0), z.strm.avail_out === 0 ? 3 : 4)
                                  : (z.strstart > z.block_start && (R(z, !1), z.strm.avail_out), 1)
                              )
                            }),
                            new j(4, 4, 8, 4, S),
                            new j(4, 5, 16, 8, S),
                            new j(4, 6, 32, 32, S),
                            new j(4, 4, 16, 16, A),
                            new j(8, 16, 32, 32, A),
                            new j(8, 16, 128, 128, A),
                            new j(8, 32, 128, 256, A),
                            new j(32, 128, 258, 1024, A),
                            new j(32, 258, 258, 4096, A),
                          ]),
                            (g.deflateInit = function (z, q) {
                              return K(z, q, 8, 15, 8, 0)
                            }),
                            (g.deflateInit2 = K),
                            (g.deflateReset = U),
                            (g.deflateResetKeep = H),
                            (g.deflateSetHeader = function (z, q) {
                              return z && z.state
                                ? z.state.wrap !== 2
                                  ? I
                                  : ((z.state.gzhead = q), 0)
                                : I
                            }),
                            (g.deflate = function (z, q) {
                              var D, N, V, W
                              if (!z || !z.state || 5 < q || q < 0) return z ? P(z, I) : I
                              if (
                                ((N = z.state),
                                !z.output ||
                                  (!z.input && z.avail_in !== 0) ||
                                  (N.status === 666 && q !== 4))
                              )
                                return P(z, z.avail_out === 0 ? -5 : I)
                              if (
                                ((N.strm = z),
                                (D = N.last_flush),
                                (N.last_flush = q),
                                N.status === 42)
                              )
                                if (N.wrap === 2)
                                  ((z.adler = 0),
                                    k(N, 31),
                                    k(N, 139),
                                    k(N, 8),
                                    N.gzhead
                                      ? (k(
                                          N,
                                          (N.gzhead.text ? 1 : 0) +
                                            (N.gzhead.hcrc ? 2 : 0) +
                                            (N.gzhead.extra ? 4 : 0) +
                                            (N.gzhead.name ? 8 : 0) +
                                            (N.gzhead.comment ? 16 : 0),
                                        ),
                                        k(N, 255 & N.gzhead.time),
                                        k(N, (N.gzhead.time >> 8) & 255),
                                        k(N, (N.gzhead.time >> 16) & 255),
                                        k(N, (N.gzhead.time >> 24) & 255),
                                        k(
                                          N,
                                          N.level === 9
                                            ? 2
                                            : 2 <= N.strategy || N.level < 2
                                              ? 4
                                              : 0,
                                        ),
                                        k(N, 255 & N.gzhead.os),
                                        N.gzhead.extra &&
                                          N.gzhead.extra.length &&
                                          (k(N, 255 & N.gzhead.extra.length),
                                          k(N, (N.gzhead.extra.length >> 8) & 255)),
                                        N.gzhead.hcrc &&
                                          (z.adler = C(z.adler, N.pending_buf, N.pending, 0)),
                                        (N.gzindex = 0),
                                        (N.status = 69))
                                      : (k(N, 0),
                                        k(N, 0),
                                        k(N, 0),
                                        k(N, 0),
                                        k(N, 0),
                                        k(
                                          N,
                                          N.level === 9
                                            ? 2
                                            : 2 <= N.strategy || N.level < 2
                                              ? 4
                                              : 0,
                                        ),
                                        k(N, 3),
                                        (N.status = O)))
                                else {
                                  var J = (8 + ((N.w_bits - 8) << 4)) << 8
                                  ;((J |=
                                    (2 <= N.strategy || N.level < 2
                                      ? 0
                                      : N.level < 6
                                        ? 1
                                        : N.level === 6
                                          ? 2
                                          : 3) << 6),
                                    N.strstart !== 0 && (J |= 32),
                                    (J += 31 - (J % 31)),
                                    (N.status = O),
                                    v(N, J),
                                    N.strstart !== 0 &&
                                      (v(N, z.adler >>> 16), v(N, 65535 & z.adler)),
                                    (z.adler = 1))
                                }
                              if (N.status === 69)
                                if (N.gzhead.extra) {
                                  for (
                                    V = N.pending;
                                    N.gzindex < (65535 & N.gzhead.extra.length) &&
                                    (N.pending !== N.pending_buf_size ||
                                      (N.gzhead.hcrc &&
                                        N.pending > V &&
                                        (z.adler = C(z.adler, N.pending_buf, N.pending - V, V)),
                                      M(z),
                                      (V = N.pending),
                                      N.pending !== N.pending_buf_size));

                                  )
                                    (k(N, 255 & N.gzhead.extra[N.gzindex]), N.gzindex++)
                                  ;(N.gzhead.hcrc &&
                                    N.pending > V &&
                                    (z.adler = C(z.adler, N.pending_buf, N.pending - V, V)),
                                    N.gzindex === N.gzhead.extra.length &&
                                      ((N.gzindex = 0), (N.status = 73)))
                                } else N.status = 73
                              if (N.status === 73)
                                if (N.gzhead.name) {
                                  V = N.pending
                                  do {
                                    if (
                                      N.pending === N.pending_buf_size &&
                                      (N.gzhead.hcrc &&
                                        N.pending > V &&
                                        (z.adler = C(z.adler, N.pending_buf, N.pending - V, V)),
                                      M(z),
                                      (V = N.pending),
                                      N.pending === N.pending_buf_size)
                                    ) {
                                      W = 1
                                      break
                                    }
                                    ;((W =
                                      N.gzindex < N.gzhead.name.length
                                        ? 255 & N.gzhead.name.charCodeAt(N.gzindex++)
                                        : 0),
                                      k(N, W))
                                  } while (W !== 0)
                                  ;(N.gzhead.hcrc &&
                                    N.pending > V &&
                                    (z.adler = C(z.adler, N.pending_buf, N.pending - V, V)),
                                    W === 0 && ((N.gzindex = 0), (N.status = 91)))
                                } else N.status = 91
                              if (N.status === 91)
                                if (N.gzhead.comment) {
                                  V = N.pending
                                  do {
                                    if (
                                      N.pending === N.pending_buf_size &&
                                      (N.gzhead.hcrc &&
                                        N.pending > V &&
                                        (z.adler = C(z.adler, N.pending_buf, N.pending - V, V)),
                                      M(z),
                                      (V = N.pending),
                                      N.pending === N.pending_buf_size)
                                    ) {
                                      W = 1
                                      break
                                    }
                                    ;((W =
                                      N.gzindex < N.gzhead.comment.length
                                        ? 255 & N.gzhead.comment.charCodeAt(N.gzindex++)
                                        : 0),
                                      k(N, W))
                                  } while (W !== 0)
                                  ;(N.gzhead.hcrc &&
                                    N.pending > V &&
                                    (z.adler = C(z.adler, N.pending_buf, N.pending - V, V)),
                                    W === 0 && (N.status = 103))
                                } else N.status = 103
                              if (
                                (N.status === 103 &&
                                  (N.gzhead.hcrc
                                    ? (N.pending + 2 > N.pending_buf_size && M(z),
                                      N.pending + 2 <= N.pending_buf_size &&
                                        (k(N, 255 & z.adler),
                                        k(N, (z.adler >> 8) & 255),
                                        (z.adler = 0),
                                        (N.status = O)))
                                    : (N.status = O)),
                                N.pending !== 0)
                              ) {
                                if ((M(z), z.avail_out === 0)) return ((N.last_flush = -1), 0)
                              } else if (z.avail_in === 0 && $(q) <= $(D) && q !== 4)
                                return P(z, -5)
                              if (N.status === 666 && z.avail_in !== 0) return P(z, -5)
                              if (
                                z.avail_in !== 0 ||
                                N.lookahead !== 0 ||
                                (q !== 0 && N.status !== 666)
                              ) {
                                var G =
                                  N.strategy === 2
                                    ? (function (Z, rt) {
                                        for (var nt; ; ) {
                                          if (Z.lookahead === 0 && (_(Z), Z.lookahead === 0)) {
                                            if (rt === 0) return 1
                                            break
                                          }
                                          if (
                                            ((Z.match_length = 0),
                                            (nt = b._tr_tally(Z, 0, Z.window[Z.strstart])),
                                            Z.lookahead--,
                                            Z.strstart++,
                                            nt && (R(Z, !1), Z.strm.avail_out === 0))
                                          )
                                            return 1
                                        }
                                        return (
                                          (Z.insert = 0),
                                          rt === 4
                                            ? (R(Z, !0), Z.strm.avail_out === 0 ? 3 : 4)
                                            : Z.last_lit && (R(Z, !1), Z.strm.avail_out === 0)
                                              ? 1
                                              : 2
                                        )
                                      })(N, q)
                                    : N.strategy === 3
                                      ? (function (Z, rt) {
                                          for (var nt, X, Q, tt, st = Z.window; ; ) {
                                            if (Z.lookahead <= B) {
                                              if ((_(Z), Z.lookahead <= B && rt === 0)) return 1
                                              if (Z.lookahead === 0) break
                                            }
                                            if (
                                              ((Z.match_length = 0),
                                              Z.lookahead >= 3 &&
                                                0 < Z.strstart &&
                                                (X = st[(Q = Z.strstart - 1)]) === st[++Q] &&
                                                X === st[++Q] &&
                                                X === st[++Q])
                                            ) {
                                              tt = Z.strstart + B
                                              do;
                                              while (
                                                X === st[++Q] &&
                                                X === st[++Q] &&
                                                X === st[++Q] &&
                                                X === st[++Q] &&
                                                X === st[++Q] &&
                                                X === st[++Q] &&
                                                X === st[++Q] &&
                                                X === st[++Q] &&
                                                Q < tt
                                              )
                                              ;((Z.match_length = B - (tt - Q)),
                                                Z.match_length > Z.lookahead &&
                                                  (Z.match_length = Z.lookahead))
                                            }
                                            if (
                                              (Z.match_length >= 3
                                                ? ((nt = b._tr_tally(Z, 1, Z.match_length - 3)),
                                                  (Z.lookahead -= Z.match_length),
                                                  (Z.strstart += Z.match_length),
                                                  (Z.match_length = 0))
                                                : ((nt = b._tr_tally(Z, 0, Z.window[Z.strstart])),
                                                  Z.lookahead--,
                                                  Z.strstart++),
                                              nt && (R(Z, !1), Z.strm.avail_out === 0))
                                            )
                                              return 1
                                          }
                                          return (
                                            (Z.insert = 0),
                                            rt === 4
                                              ? (R(Z, !0), Z.strm.avail_out === 0 ? 3 : 4)
                                              : Z.last_lit && (R(Z, !1), Z.strm.avail_out === 0)
                                                ? 1
                                                : 2
                                          )
                                        })(N, q)
                                      : m[N.level].func(N, q)
                                if (((G !== 3 && G !== 4) || (N.status = 666), G === 1 || G === 3))
                                  return (z.avail_out === 0 && (N.last_flush = -1), 0)
                                if (
                                  G === 2 &&
                                  (q === 1
                                    ? b._tr_align(N)
                                    : q !== 5 &&
                                      (b._tr_stored_block(N, 0, 0, !1),
                                      q === 3 &&
                                        (F(N.head),
                                        N.lookahead === 0 &&
                                          ((N.strstart = 0), (N.block_start = 0), (N.insert = 0)))),
                                  M(z),
                                  z.avail_out === 0)
                                )
                                  return ((N.last_flush = -1), 0)
                              }
                              return q !== 4
                                ? 0
                                : N.wrap <= 0
                                  ? 1
                                  : (N.wrap === 2
                                      ? (k(N, 255 & z.adler),
                                        k(N, (z.adler >> 8) & 255),
                                        k(N, (z.adler >> 16) & 255),
                                        k(N, (z.adler >> 24) & 255),
                                        k(N, 255 & z.total_in),
                                        k(N, (z.total_in >> 8) & 255),
                                        k(N, (z.total_in >> 16) & 255),
                                        k(N, (z.total_in >> 24) & 255))
                                      : (v(N, z.adler >>> 16), v(N, 65535 & z.adler)),
                                    M(z),
                                    0 < N.wrap && (N.wrap = -N.wrap),
                                    N.pending !== 0 ? 0 : 1)
                            }),
                            (g.deflateEnd = function (z) {
                              var q
                              return z && z.state
                                ? (q = z.state.status) !== 42 &&
                                  q !== 69 &&
                                  q !== 73 &&
                                  q !== 91 &&
                                  q !== 103 &&
                                  q !== O &&
                                  q !== 666
                                  ? P(z, I)
                                  : ((z.state = null), q === O ? P(z, -3) : 0)
                                : I
                            }),
                            (g.deflateSetDictionary = function (z, q) {
                              var D,
                                N,
                                V,
                                W,
                                J,
                                G,
                                Z,
                                rt,
                                nt = q.length
                              if (
                                !z ||
                                !z.state ||
                                (W = (D = z.state).wrap) === 2 ||
                                (W === 1 && D.status !== 42) ||
                                D.lookahead
                              )
                                return I
                              for (
                                W === 1 && (z.adler = w(z.adler, q, nt, 0)),
                                  D.wrap = 0,
                                  nt >= D.w_size &&
                                    (W === 0 &&
                                      (F(D.head),
                                      (D.strstart = 0),
                                      (D.block_start = 0),
                                      (D.insert = 0)),
                                    (rt = new y.Buf8(D.w_size)),
                                    y.arraySet(rt, q, nt - D.w_size, D.w_size, 0),
                                    (q = rt),
                                    (nt = D.w_size)),
                                  J = z.avail_in,
                                  G = z.next_in,
                                  Z = z.input,
                                  z.avail_in = nt,
                                  z.next_in = 0,
                                  z.input = q,
                                  _(D);
                                D.lookahead >= 3;

                              ) {
                                for (
                                  N = D.strstart, V = D.lookahead - 2;
                                  (D.ins_h =
                                    ((D.ins_h << D.hash_shift) ^ D.window[N + 3 - 1]) &
                                    D.hash_mask),
                                    (D.prev[N & D.w_mask] = D.head[D.ins_h]),
                                    (D.head[D.ins_h] = N),
                                    N++,
                                    --V;

                                );
                                ;((D.strstart = N), (D.lookahead = 2), _(D))
                              }
                              return (
                                (D.strstart += D.lookahead),
                                (D.block_start = D.strstart),
                                (D.insert = D.lookahead),
                                (D.lookahead = 0),
                                (D.match_length = D.prev_length = 2),
                                (D.match_available = 0),
                                (z.next_in = G),
                                (z.input = Z),
                                (z.avail_in = J),
                                (D.wrap = W),
                                0
                              )
                            }),
                            (g.deflateInfo = 'pako deflate (from Nodeca project)'))
                        },
                        {
                          '../utils/common': 41,
                          './adler32': 43,
                          './crc32': 45,
                          './messages': 51,
                          './trees': 52,
                        },
                      ],
                      47: [
                        function (h, p, g) {
                          p.exports = function () {
                            ;((this.text = 0),
                              (this.time = 0),
                              (this.xflags = 0),
                              (this.os = 0),
                              (this.extra = null),
                              (this.extra_len = 0),
                              (this.name = ''),
                              (this.comment = ''),
                              (this.hcrc = 0),
                              (this.done = !1))
                          }
                        },
                        {},
                      ],
                      48: [
                        function (h, p, g) {
                          p.exports = function (m, y) {
                            var b,
                              w,
                              C,
                              T,
                              I,
                              B,
                              E,
                              O,
                              P,
                              $,
                              F,
                              M,
                              R,
                              k,
                              v,
                              x,
                              _,
                              S,
                              A,
                              j,
                              L,
                              H,
                              U,
                              K,
                              z
                            ;((b = m.state),
                              (w = m.next_in),
                              (K = m.input),
                              (C = w + (m.avail_in - 5)),
                              (T = m.next_out),
                              (z = m.output),
                              (I = T - (y - m.avail_out)),
                              (B = T + (m.avail_out - 257)),
                              (E = b.dmax),
                              (O = b.wsize),
                              (P = b.whave),
                              ($ = b.wnext),
                              (F = b.window),
                              (M = b.hold),
                              (R = b.bits),
                              (k = b.lencode),
                              (v = b.distcode),
                              (x = (1 << b.lenbits) - 1),
                              (_ = (1 << b.distbits) - 1))
                            t: do {
                              ;(R < 15 &&
                                ((M += K[w++] << R), (R += 8), (M += K[w++] << R), (R += 8)),
                                (S = k[M & x]))
                              e: for (;;) {
                                if (((M >>>= A = S >>> 24), (R -= A), (A = (S >>> 16) & 255) == 0))
                                  z[T++] = 65535 & S
                                else {
                                  if (!(16 & A)) {
                                    if (!(64 & A)) {
                                      S = k[(65535 & S) + (M & ((1 << A) - 1))]
                                      continue e
                                    }
                                    if (32 & A) {
                                      b.mode = 12
                                      break t
                                    }
                                    ;((m.msg = 'invalid literal/length code'), (b.mode = 30))
                                    break t
                                  }
                                  ;((j = 65535 & S),
                                    (A &= 15) &&
                                      (R < A && ((M += K[w++] << R), (R += 8)),
                                      (j += M & ((1 << A) - 1)),
                                      (M >>>= A),
                                      (R -= A)),
                                    R < 15 &&
                                      ((M += K[w++] << R), (R += 8), (M += K[w++] << R), (R += 8)),
                                    (S = v[M & _]))
                                  n: for (;;) {
                                    if (
                                      ((M >>>= A = S >>> 24),
                                      (R -= A),
                                      !(16 & (A = (S >>> 16) & 255)))
                                    ) {
                                      if (!(64 & A)) {
                                        S = v[(65535 & S) + (M & ((1 << A) - 1))]
                                        continue n
                                      }
                                      ;((m.msg = 'invalid distance code'), (b.mode = 30))
                                      break t
                                    }
                                    if (
                                      ((L = 65535 & S),
                                      R < (A &= 15) &&
                                        ((M += K[w++] << R),
                                        (R += 8) < A && ((M += K[w++] << R), (R += 8))),
                                      E < (L += M & ((1 << A) - 1)))
                                    ) {
                                      ;((m.msg = 'invalid distance too far back'), (b.mode = 30))
                                      break t
                                    }
                                    if (((M >>>= A), (R -= A), (A = T - I) < L)) {
                                      if (P < (A = L - A) && b.sane) {
                                        ;((m.msg = 'invalid distance too far back'), (b.mode = 30))
                                        break t
                                      }
                                      if (((U = F), (H = 0) === $)) {
                                        if (((H += O - A), A < j)) {
                                          for (j -= A; (z[T++] = F[H++]), --A; );
                                          ;((H = T - L), (U = z))
                                        }
                                      } else if ($ < A) {
                                        if (((H += O + $ - A), (A -= $) < j)) {
                                          for (j -= A; (z[T++] = F[H++]), --A; );
                                          if (((H = 0), $ < j)) {
                                            for (j -= A = $; (z[T++] = F[H++]), --A; );
                                            ;((H = T - L), (U = z))
                                          }
                                        }
                                      } else if (((H += $ - A), A < j)) {
                                        for (j -= A; (z[T++] = F[H++]), --A; );
                                        ;((H = T - L), (U = z))
                                      }
                                      for (; 2 < j; )
                                        ((z[T++] = U[H++]),
                                          (z[T++] = U[H++]),
                                          (z[T++] = U[H++]),
                                          (j -= 3))
                                      j && ((z[T++] = U[H++]), 1 < j && (z[T++] = U[H++]))
                                    } else {
                                      for (
                                        H = T - L;
                                        (z[T++] = z[H++]),
                                          (z[T++] = z[H++]),
                                          (z[T++] = z[H++]),
                                          2 < (j -= 3);

                                      );
                                      j && ((z[T++] = z[H++]), 1 < j && (z[T++] = z[H++]))
                                    }
                                    break
                                  }
                                }
                                break
                              }
                            } while (w < C && T < B)
                            ;((w -= j = R >> 3),
                              (M &= (1 << (R -= j << 3)) - 1),
                              (m.next_in = w),
                              (m.next_out = T),
                              (m.avail_in = w < C ? C - w + 5 : 5 - (w - C)),
                              (m.avail_out = T < B ? B - T + 257 : 257 - (T - B)),
                              (b.hold = M),
                              (b.bits = R))
                          }
                        },
                        {},
                      ],
                      49: [
                        function (h, p, g) {
                          var m = h('../utils/common'),
                            y = h('./adler32'),
                            b = h('./crc32'),
                            w = h('./inffast'),
                            C = h('./inftrees'),
                            T = -2
                          function I(x) {
                            return (
                              ((x >>> 24) & 255) +
                              ((x >>> 8) & 65280) +
                              ((65280 & x) << 8) +
                              ((255 & x) << 24)
                            )
                          }
                          function B() {
                            ;((this.mode = 0),
                              (this.last = !1),
                              (this.wrap = 0),
                              (this.havedict = !1),
                              (this.flags = 0),
                              (this.dmax = 0),
                              (this.check = 0),
                              (this.total = 0),
                              (this.head = null),
                              (this.wbits = 0),
                              (this.wsize = 0),
                              (this.whave = 0),
                              (this.wnext = 0),
                              (this.window = null),
                              (this.hold = 0),
                              (this.bits = 0),
                              (this.length = 0),
                              (this.offset = 0),
                              (this.extra = 0),
                              (this.lencode = null),
                              (this.distcode = null),
                              (this.lenbits = 0),
                              (this.distbits = 0),
                              (this.ncode = 0),
                              (this.nlen = 0),
                              (this.ndist = 0),
                              (this.have = 0),
                              (this.next = null),
                              (this.lens = new m.Buf16(320)),
                              (this.work = new m.Buf16(288)),
                              (this.lendyn = null),
                              (this.distdyn = null),
                              (this.sane = 0),
                              (this.back = 0),
                              (this.was = 0))
                          }
                          function E(x) {
                            var _
                            return x && x.state
                              ? ((_ = x.state),
                                (x.total_in = x.total_out = _.total = 0),
                                (x.msg = ''),
                                _.wrap && (x.adler = 1 & _.wrap),
                                (_.mode = 1),
                                (_.last = 0),
                                (_.havedict = 0),
                                (_.dmax = 32768),
                                (_.head = null),
                                (_.hold = 0),
                                (_.bits = 0),
                                (_.lencode = _.lendyn = new m.Buf32(852)),
                                (_.distcode = _.distdyn = new m.Buf32(592)),
                                (_.sane = 1),
                                (_.back = -1),
                                0)
                              : T
                          }
                          function O(x) {
                            var _
                            return x && x.state
                              ? (((_ = x.state).wsize = 0), (_.whave = 0), (_.wnext = 0), E(x))
                              : T
                          }
                          function P(x, _) {
                            var S, A
                            return x && x.state
                              ? ((A = x.state),
                                _ < 0
                                  ? ((S = 0), (_ = -_))
                                  : ((S = 1 + (_ >> 4)), _ < 48 && (_ &= 15)),
                                _ && (_ < 8 || 15 < _)
                                  ? T
                                  : (A.window !== null && A.wbits !== _ && (A.window = null),
                                    (A.wrap = S),
                                    (A.wbits = _),
                                    O(x)))
                              : T
                          }
                          function $(x, _) {
                            var S, A
                            return x
                              ? ((A = new B()),
                                ((x.state = A).window = null),
                                (S = P(x, _)) !== 0 && (x.state = null),
                                S)
                              : T
                          }
                          var F,
                            M,
                            R = !0
                          function k(x) {
                            if (R) {
                              var _
                              for (F = new m.Buf32(512), M = new m.Buf32(32), _ = 0; _ < 144; )
                                x.lens[_++] = 8
                              for (; _ < 256; ) x.lens[_++] = 9
                              for (; _ < 280; ) x.lens[_++] = 7
                              for (; _ < 288; ) x.lens[_++] = 8
                              for (C(1, x.lens, 0, 288, F, 0, x.work, { bits: 9 }), _ = 0; _ < 32; )
                                x.lens[_++] = 5
                              ;(C(2, x.lens, 0, 32, M, 0, x.work, { bits: 5 }), (R = !1))
                            }
                            ;((x.lencode = F), (x.lenbits = 9), (x.distcode = M), (x.distbits = 5))
                          }
                          function v(x, _, S, A) {
                            var j,
                              L = x.state
                            return (
                              L.window === null &&
                                ((L.wsize = 1 << L.wbits),
                                (L.wnext = 0),
                                (L.whave = 0),
                                (L.window = new m.Buf8(L.wsize))),
                              A >= L.wsize
                                ? (m.arraySet(L.window, _, S - L.wsize, L.wsize, 0),
                                  (L.wnext = 0),
                                  (L.whave = L.wsize))
                                : (A < (j = L.wsize - L.wnext) && (j = A),
                                  m.arraySet(L.window, _, S - A, j, L.wnext),
                                  (A -= j)
                                    ? (m.arraySet(L.window, _, S - A, A, 0),
                                      (L.wnext = A),
                                      (L.whave = L.wsize))
                                    : ((L.wnext += j),
                                      L.wnext === L.wsize && (L.wnext = 0),
                                      L.whave < L.wsize && (L.whave += j))),
                              0
                            )
                          }
                          ;((g.inflateReset = O),
                            (g.inflateReset2 = P),
                            (g.inflateResetKeep = E),
                            (g.inflateInit = function (x) {
                              return $(x, 15)
                            }),
                            (g.inflateInit2 = $),
                            (g.inflate = function (x, _) {
                              var S,
                                A,
                                j,
                                L,
                                H,
                                U,
                                K,
                                z,
                                q,
                                D,
                                N,
                                V,
                                W,
                                J,
                                G,
                                Z,
                                rt,
                                nt,
                                X,
                                Q,
                                tt,
                                st,
                                ot,
                                at,
                                ht = 0,
                                dt = new m.Buf8(4),
                                mt = [
                                  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
                                ]
                              if (!x || !x.state || !x.output || (!x.input && x.avail_in !== 0))
                                return T
                              ;((S = x.state).mode === 12 && (S.mode = 13),
                                (H = x.next_out),
                                (j = x.output),
                                (K = x.avail_out),
                                (L = x.next_in),
                                (A = x.input),
                                (U = x.avail_in),
                                (z = S.hold),
                                (q = S.bits),
                                (D = U),
                                (N = K),
                                (st = 0))
                              t: for (;;)
                                switch (S.mode) {
                                  case 1:
                                    if (S.wrap === 0) {
                                      S.mode = 13
                                      break
                                    }
                                    for (; q < 16; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    if (2 & S.wrap && z === 35615) {
                                      ;((dt[(S.check = 0)] = 255 & z),
                                        (dt[1] = (z >>> 8) & 255),
                                        (S.check = b(S.check, dt, 2, 0)),
                                        (q = z = 0),
                                        (S.mode = 2))
                                      break
                                    }
                                    if (
                                      ((S.flags = 0),
                                      S.head && (S.head.done = !1),
                                      !(1 & S.wrap) || (((255 & z) << 8) + (z >> 8)) % 31)
                                    ) {
                                      ;((x.msg = 'incorrect header check'), (S.mode = 30))
                                      break
                                    }
                                    if ((15 & z) != 8) {
                                      ;((x.msg = 'unknown compression method'), (S.mode = 30))
                                      break
                                    }
                                    if (((q -= 4), (tt = 8 + (15 & (z >>>= 4))), S.wbits === 0))
                                      S.wbits = tt
                                    else if (tt > S.wbits) {
                                      ;((x.msg = 'invalid window size'), (S.mode = 30))
                                      break
                                    }
                                    ;((S.dmax = 1 << tt),
                                      (x.adler = S.check = 1),
                                      (S.mode = 512 & z ? 10 : 12),
                                      (q = z = 0))
                                    break
                                  case 2:
                                    for (; q < 16; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    if (((S.flags = z), (255 & S.flags) != 8)) {
                                      ;((x.msg = 'unknown compression method'), (S.mode = 30))
                                      break
                                    }
                                    if (57344 & S.flags) {
                                      ;((x.msg = 'unknown header flags set'), (S.mode = 30))
                                      break
                                    }
                                    ;(S.head && (S.head.text = (z >> 8) & 1),
                                      512 & S.flags &&
                                        ((dt[0] = 255 & z),
                                        (dt[1] = (z >>> 8) & 255),
                                        (S.check = b(S.check, dt, 2, 0))),
                                      (q = z = 0),
                                      (S.mode = 3))
                                  case 3:
                                    for (; q < 32; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    ;(S.head && (S.head.time = z),
                                      512 & S.flags &&
                                        ((dt[0] = 255 & z),
                                        (dt[1] = (z >>> 8) & 255),
                                        (dt[2] = (z >>> 16) & 255),
                                        (dt[3] = (z >>> 24) & 255),
                                        (S.check = b(S.check, dt, 4, 0))),
                                      (q = z = 0),
                                      (S.mode = 4))
                                  case 4:
                                    for (; q < 16; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    ;(S.head && ((S.head.xflags = 255 & z), (S.head.os = z >> 8)),
                                      512 & S.flags &&
                                        ((dt[0] = 255 & z),
                                        (dt[1] = (z >>> 8) & 255),
                                        (S.check = b(S.check, dt, 2, 0))),
                                      (q = z = 0),
                                      (S.mode = 5))
                                  case 5:
                                    if (1024 & S.flags) {
                                      for (; q < 16; ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      ;((S.length = z),
                                        S.head && (S.head.extra_len = z),
                                        512 & S.flags &&
                                          ((dt[0] = 255 & z),
                                          (dt[1] = (z >>> 8) & 255),
                                          (S.check = b(S.check, dt, 2, 0))),
                                        (q = z = 0))
                                    } else S.head && (S.head.extra = null)
                                    S.mode = 6
                                  case 6:
                                    if (
                                      1024 & S.flags &&
                                      (U < (V = S.length) && (V = U),
                                      V &&
                                        (S.head &&
                                          ((tt = S.head.extra_len - S.length),
                                          S.head.extra ||
                                            (S.head.extra = new Array(S.head.extra_len)),
                                          m.arraySet(S.head.extra, A, L, V, tt)),
                                        512 & S.flags && (S.check = b(S.check, A, V, L)),
                                        (U -= V),
                                        (L += V),
                                        (S.length -= V)),
                                      S.length)
                                    )
                                      break t
                                    ;((S.length = 0), (S.mode = 7))
                                  case 7:
                                    if (2048 & S.flags) {
                                      if (U === 0) break t
                                      for (
                                        V = 0;
                                        (tt = A[L + V++]),
                                          S.head &&
                                            tt &&
                                            S.length < 65536 &&
                                            (S.head.name += String.fromCharCode(tt)),
                                          tt && V < U;

                                      );
                                      if (
                                        (512 & S.flags && (S.check = b(S.check, A, V, L)),
                                        (U -= V),
                                        (L += V),
                                        tt)
                                      )
                                        break t
                                    } else S.head && (S.head.name = null)
                                    ;((S.length = 0), (S.mode = 8))
                                  case 8:
                                    if (4096 & S.flags) {
                                      if (U === 0) break t
                                      for (
                                        V = 0;
                                        (tt = A[L + V++]),
                                          S.head &&
                                            tt &&
                                            S.length < 65536 &&
                                            (S.head.comment += String.fromCharCode(tt)),
                                          tt && V < U;

                                      );
                                      if (
                                        (512 & S.flags && (S.check = b(S.check, A, V, L)),
                                        (U -= V),
                                        (L += V),
                                        tt)
                                      )
                                        break t
                                    } else S.head && (S.head.comment = null)
                                    S.mode = 9
                                  case 9:
                                    if (512 & S.flags) {
                                      for (; q < 16; ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      if (z !== (65535 & S.check)) {
                                        ;((x.msg = 'header crc mismatch'), (S.mode = 30))
                                        break
                                      }
                                      q = z = 0
                                    }
                                    ;(S.head &&
                                      ((S.head.hcrc = (S.flags >> 9) & 1), (S.head.done = !0)),
                                      (x.adler = S.check = 0),
                                      (S.mode = 12))
                                    break
                                  case 10:
                                    for (; q < 32; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    ;((x.adler = S.check = I(z)), (q = z = 0), (S.mode = 11))
                                  case 11:
                                    if (S.havedict === 0)
                                      return (
                                        (x.next_out = H),
                                        (x.avail_out = K),
                                        (x.next_in = L),
                                        (x.avail_in = U),
                                        (S.hold = z),
                                        (S.bits = q),
                                        2
                                      )
                                    ;((x.adler = S.check = 1), (S.mode = 12))
                                  case 12:
                                    if (_ === 5 || _ === 6) break t
                                  case 13:
                                    if (S.last) {
                                      ;((z >>>= 7 & q), (q -= 7 & q), (S.mode = 27))
                                      break
                                    }
                                    for (; q < 3; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    switch (((S.last = 1 & z), (q -= 1), 3 & (z >>>= 1))) {
                                      case 0:
                                        S.mode = 14
                                        break
                                      case 1:
                                        if ((k(S), (S.mode = 20), _ !== 6)) break
                                        ;((z >>>= 2), (q -= 2))
                                        break t
                                      case 2:
                                        S.mode = 17
                                        break
                                      case 3:
                                        ;((x.msg = 'invalid block type'), (S.mode = 30))
                                    }
                                    ;((z >>>= 2), (q -= 2))
                                    break
                                  case 14:
                                    for (z >>>= 7 & q, q -= 7 & q; q < 32; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    if ((65535 & z) != ((z >>> 16) ^ 65535)) {
                                      ;((x.msg = 'invalid stored block lengths'), (S.mode = 30))
                                      break
                                    }
                                    if (
                                      ((S.length = 65535 & z), (q = z = 0), (S.mode = 15), _ === 6)
                                    )
                                      break t
                                  case 15:
                                    S.mode = 16
                                  case 16:
                                    if ((V = S.length)) {
                                      if ((U < V && (V = U), K < V && (V = K), V === 0)) break t
                                      ;(m.arraySet(j, A, L, V, H),
                                        (U -= V),
                                        (L += V),
                                        (K -= V),
                                        (H += V),
                                        (S.length -= V))
                                      break
                                    }
                                    S.mode = 12
                                    break
                                  case 17:
                                    for (; q < 14; ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    if (
                                      ((S.nlen = 257 + (31 & z)),
                                      (z >>>= 5),
                                      (q -= 5),
                                      (S.ndist = 1 + (31 & z)),
                                      (z >>>= 5),
                                      (q -= 5),
                                      (S.ncode = 4 + (15 & z)),
                                      (z >>>= 4),
                                      (q -= 4),
                                      286 < S.nlen || 30 < S.ndist)
                                    ) {
                                      ;((x.msg = 'too many length or distance symbols'),
                                        (S.mode = 30))
                                      break
                                    }
                                    ;((S.have = 0), (S.mode = 18))
                                  case 18:
                                    for (; S.have < S.ncode; ) {
                                      for (; q < 3; ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      ;((S.lens[mt[S.have++]] = 7 & z), (z >>>= 3), (q -= 3))
                                    }
                                    for (; S.have < 19; ) S.lens[mt[S.have++]] = 0
                                    if (
                                      ((S.lencode = S.lendyn),
                                      (S.lenbits = 7),
                                      (ot = { bits: S.lenbits }),
                                      (st = C(0, S.lens, 0, 19, S.lencode, 0, S.work, ot)),
                                      (S.lenbits = ot.bits),
                                      st)
                                    ) {
                                      ;((x.msg = 'invalid code lengths set'), (S.mode = 30))
                                      break
                                    }
                                    ;((S.have = 0), (S.mode = 19))
                                  case 19:
                                    for (; S.have < S.nlen + S.ndist; ) {
                                      for (
                                        ;
                                        (Z =
                                          ((ht = S.lencode[z & ((1 << S.lenbits) - 1)]) >>> 16) &
                                          255),
                                          (rt = 65535 & ht),
                                          !((G = ht >>> 24) <= q);

                                      ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      if (rt < 16) ((z >>>= G), (q -= G), (S.lens[S.have++] = rt))
                                      else {
                                        if (rt === 16) {
                                          for (at = G + 2; q < at; ) {
                                            if (U === 0) break t
                                            ;(U--, (z += A[L++] << q), (q += 8))
                                          }
                                          if (((z >>>= G), (q -= G), S.have === 0)) {
                                            ;((x.msg = 'invalid bit length repeat'), (S.mode = 30))
                                            break
                                          }
                                          ;((tt = S.lens[S.have - 1]),
                                            (V = 3 + (3 & z)),
                                            (z >>>= 2),
                                            (q -= 2))
                                        } else if (rt === 17) {
                                          for (at = G + 3; q < at; ) {
                                            if (U === 0) break t
                                            ;(U--, (z += A[L++] << q), (q += 8))
                                          }
                                          ;((q -= G),
                                            (tt = 0),
                                            (V = 3 + (7 & (z >>>= G))),
                                            (z >>>= 3),
                                            (q -= 3))
                                        } else {
                                          for (at = G + 7; q < at; ) {
                                            if (U === 0) break t
                                            ;(U--, (z += A[L++] << q), (q += 8))
                                          }
                                          ;((q -= G),
                                            (tt = 0),
                                            (V = 11 + (127 & (z >>>= G))),
                                            (z >>>= 7),
                                            (q -= 7))
                                        }
                                        if (S.have + V > S.nlen + S.ndist) {
                                          ;((x.msg = 'invalid bit length repeat'), (S.mode = 30))
                                          break
                                        }
                                        for (; V--; ) S.lens[S.have++] = tt
                                      }
                                    }
                                    if (S.mode === 30) break
                                    if (S.lens[256] === 0) {
                                      ;((x.msg = 'invalid code -- missing end-of-block'),
                                        (S.mode = 30))
                                      break
                                    }
                                    if (
                                      ((S.lenbits = 9),
                                      (ot = { bits: S.lenbits }),
                                      (st = C(1, S.lens, 0, S.nlen, S.lencode, 0, S.work, ot)),
                                      (S.lenbits = ot.bits),
                                      st)
                                    ) {
                                      ;((x.msg = 'invalid literal/lengths set'), (S.mode = 30))
                                      break
                                    }
                                    if (
                                      ((S.distbits = 6),
                                      (S.distcode = S.distdyn),
                                      (ot = { bits: S.distbits }),
                                      (st = C(
                                        2,
                                        S.lens,
                                        S.nlen,
                                        S.ndist,
                                        S.distcode,
                                        0,
                                        S.work,
                                        ot,
                                      )),
                                      (S.distbits = ot.bits),
                                      st)
                                    ) {
                                      ;((x.msg = 'invalid distances set'), (S.mode = 30))
                                      break
                                    }
                                    if (((S.mode = 20), _ === 6)) break t
                                  case 20:
                                    S.mode = 21
                                  case 21:
                                    if (6 <= U && 258 <= K) {
                                      ;((x.next_out = H),
                                        (x.avail_out = K),
                                        (x.next_in = L),
                                        (x.avail_in = U),
                                        (S.hold = z),
                                        (S.bits = q),
                                        w(x, N),
                                        (H = x.next_out),
                                        (j = x.output),
                                        (K = x.avail_out),
                                        (L = x.next_in),
                                        (A = x.input),
                                        (U = x.avail_in),
                                        (z = S.hold),
                                        (q = S.bits),
                                        S.mode === 12 && (S.back = -1))
                                      break
                                    }
                                    for (
                                      S.back = 0;
                                      (Z =
                                        ((ht = S.lencode[z & ((1 << S.lenbits) - 1)]) >>> 16) &
                                        255),
                                        (rt = 65535 & ht),
                                        !((G = ht >>> 24) <= q);

                                    ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    if (Z && !(240 & Z)) {
                                      for (
                                        nt = G, X = Z, Q = rt;
                                        (Z =
                                          ((ht =
                                            S.lencode[Q + ((z & ((1 << (nt + X)) - 1)) >> nt)]) >>>
                                            16) &
                                          255),
                                          (rt = 65535 & ht),
                                          !(nt + (G = ht >>> 24) <= q);

                                      ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      ;((z >>>= nt), (q -= nt), (S.back += nt))
                                    }
                                    if (
                                      ((z >>>= G),
                                      (q -= G),
                                      (S.back += G),
                                      (S.length = rt),
                                      Z === 0)
                                    ) {
                                      S.mode = 26
                                      break
                                    }
                                    if (32 & Z) {
                                      ;((S.back = -1), (S.mode = 12))
                                      break
                                    }
                                    if (64 & Z) {
                                      ;((x.msg = 'invalid literal/length code'), (S.mode = 30))
                                      break
                                    }
                                    ;((S.extra = 15 & Z), (S.mode = 22))
                                  case 22:
                                    if (S.extra) {
                                      for (at = S.extra; q < at; ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      ;((S.length += z & ((1 << S.extra) - 1)),
                                        (z >>>= S.extra),
                                        (q -= S.extra),
                                        (S.back += S.extra))
                                    }
                                    ;((S.was = S.length), (S.mode = 23))
                                  case 23:
                                    for (
                                      ;
                                      (Z =
                                        ((ht = S.distcode[z & ((1 << S.distbits) - 1)]) >>> 16) &
                                        255),
                                        (rt = 65535 & ht),
                                        !((G = ht >>> 24) <= q);

                                    ) {
                                      if (U === 0) break t
                                      ;(U--, (z += A[L++] << q), (q += 8))
                                    }
                                    if (!(240 & Z)) {
                                      for (
                                        nt = G, X = Z, Q = rt;
                                        (Z =
                                          ((ht =
                                            S.distcode[Q + ((z & ((1 << (nt + X)) - 1)) >> nt)]) >>>
                                            16) &
                                          255),
                                          (rt = 65535 & ht),
                                          !(nt + (G = ht >>> 24) <= q);

                                      ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      ;((z >>>= nt), (q -= nt), (S.back += nt))
                                    }
                                    if (((z >>>= G), (q -= G), (S.back += G), 64 & Z)) {
                                      ;((x.msg = 'invalid distance code'), (S.mode = 30))
                                      break
                                    }
                                    ;((S.offset = rt), (S.extra = 15 & Z), (S.mode = 24))
                                  case 24:
                                    if (S.extra) {
                                      for (at = S.extra; q < at; ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      ;((S.offset += z & ((1 << S.extra) - 1)),
                                        (z >>>= S.extra),
                                        (q -= S.extra),
                                        (S.back += S.extra))
                                    }
                                    if (S.offset > S.dmax) {
                                      ;((x.msg = 'invalid distance too far back'), (S.mode = 30))
                                      break
                                    }
                                    S.mode = 25
                                  case 25:
                                    if (K === 0) break t
                                    if (((V = N - K), S.offset > V)) {
                                      if ((V = S.offset - V) > S.whave && S.sane) {
                                        ;((x.msg = 'invalid distance too far back'), (S.mode = 30))
                                        break
                                      }
                                      ;((W =
                                        V > S.wnext ? ((V -= S.wnext), S.wsize - V) : S.wnext - V),
                                        V > S.length && (V = S.length),
                                        (J = S.window))
                                    } else ((J = j), (W = H - S.offset), (V = S.length))
                                    for (
                                      K < V && (V = K), K -= V, S.length -= V;
                                      (j[H++] = J[W++]), --V;

                                    );
                                    S.length === 0 && (S.mode = 21)
                                    break
                                  case 26:
                                    if (K === 0) break t
                                    ;((j[H++] = S.length), K--, (S.mode = 21))
                                    break
                                  case 27:
                                    if (S.wrap) {
                                      for (; q < 32; ) {
                                        if (U === 0) break t
                                        ;(U--, (z |= A[L++] << q), (q += 8))
                                      }
                                      if (
                                        ((N -= K),
                                        (x.total_out += N),
                                        (S.total += N),
                                        N &&
                                          (x.adler = S.check =
                                            S.flags
                                              ? b(S.check, j, N, H - N)
                                              : y(S.check, j, N, H - N)),
                                        (N = K),
                                        (S.flags ? z : I(z)) !== S.check)
                                      ) {
                                        ;((x.msg = 'incorrect data check'), (S.mode = 30))
                                        break
                                      }
                                      q = z = 0
                                    }
                                    S.mode = 28
                                  case 28:
                                    if (S.wrap && S.flags) {
                                      for (; q < 32; ) {
                                        if (U === 0) break t
                                        ;(U--, (z += A[L++] << q), (q += 8))
                                      }
                                      if (z !== (4294967295 & S.total)) {
                                        ;((x.msg = 'incorrect length check'), (S.mode = 30))
                                        break
                                      }
                                      q = z = 0
                                    }
                                    S.mode = 29
                                  case 29:
                                    st = 1
                                    break t
                                  case 30:
                                    st = -3
                                    break t
                                  case 31:
                                    return -4
                                  case 32:
                                  default:
                                    return T
                                }
                              return (
                                (x.next_out = H),
                                (x.avail_out = K),
                                (x.next_in = L),
                                (x.avail_in = U),
                                (S.hold = z),
                                (S.bits = q),
                                (S.wsize ||
                                  (N !== x.avail_out && S.mode < 30 && (S.mode < 27 || _ !== 4))) &&
                                v(x, x.output, x.next_out, N - x.avail_out)
                                  ? ((S.mode = 31), -4)
                                  : ((D -= x.avail_in),
                                    (N -= x.avail_out),
                                    (x.total_in += D),
                                    (x.total_out += N),
                                    (S.total += N),
                                    S.wrap &&
                                      N &&
                                      (x.adler = S.check =
                                        S.flags
                                          ? b(S.check, j, N, x.next_out - N)
                                          : y(S.check, j, N, x.next_out - N)),
                                    (x.data_type =
                                      S.bits +
                                      (S.last ? 64 : 0) +
                                      (S.mode === 12 ? 128 : 0) +
                                      (S.mode === 20 || S.mode === 15 ? 256 : 0)),
                                    ((D == 0 && N === 0) || _ === 4) && st === 0 && (st = -5),
                                    st)
                              )
                            }),
                            (g.inflateEnd = function (x) {
                              if (!x || !x.state) return T
                              var _ = x.state
                              return (_.window && (_.window = null), (x.state = null), 0)
                            }),
                            (g.inflateGetHeader = function (x, _) {
                              var S
                              return x && x.state && 2 & (S = x.state).wrap
                                ? (((S.head = _).done = !1), 0)
                                : T
                            }),
                            (g.inflateSetDictionary = function (x, _) {
                              var S,
                                A = _.length
                              return x && x.state
                                ? (S = x.state).wrap !== 0 && S.mode !== 11
                                  ? T
                                  : S.mode === 11 && y(1, _, A, 0) !== S.check
                                    ? -3
                                    : v(x, _, A, A)
                                      ? ((S.mode = 31), -4)
                                      : ((S.havedict = 1), 0)
                                : T
                            }),
                            (g.inflateInfo = 'pako inflate (from Nodeca project)'))
                        },
                        {
                          '../utils/common': 41,
                          './adler32': 43,
                          './crc32': 45,
                          './inffast': 48,
                          './inftrees': 50,
                        },
                      ],
                      50: [
                        function (h, p, g) {
                          var m = h('../utils/common'),
                            y = [
                              3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
                              59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
                            ],
                            b = [
                              16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19,
                              19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
                            ],
                            w = [
                              1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
                              513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
                              24577, 0, 0,
                            ],
                            C = [
                              16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23,
                              23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
                            ]
                          p.exports = function (T, I, B, E, O, P, $, F) {
                            var M,
                              R,
                              k,
                              v,
                              x,
                              _,
                              S,
                              A,
                              j,
                              L = F.bits,
                              H = 0,
                              U = 0,
                              K = 0,
                              z = 0,
                              q = 0,
                              D = 0,
                              N = 0,
                              V = 0,
                              W = 0,
                              J = 0,
                              G = null,
                              Z = 0,
                              rt = new m.Buf16(16),
                              nt = new m.Buf16(16),
                              X = null,
                              Q = 0
                            for (H = 0; H <= 15; H++) rt[H] = 0
                            for (U = 0; U < E; U++) rt[I[B + U]]++
                            for (q = L, z = 15; 1 <= z && rt[z] === 0; z--);
                            if ((z < q && (q = z), z === 0))
                              return ((O[P++] = 20971520), (O[P++] = 20971520), (F.bits = 1), 0)
                            for (K = 1; K < z && rt[K] === 0; K++);
                            for (q < K && (q = K), H = V = 1; H <= 15; H++)
                              if (((V <<= 1), (V -= rt[H]) < 0)) return -1
                            if (0 < V && (T === 0 || z !== 1)) return -1
                            for (nt[1] = 0, H = 1; H < 15; H++) nt[H + 1] = nt[H] + rt[H]
                            for (U = 0; U < E; U++) I[B + U] !== 0 && ($[nt[I[B + U]]++] = U)
                            if (
                              ((_ =
                                T === 0
                                  ? ((G = X = $), 19)
                                  : T === 1
                                    ? ((G = y), (Z -= 257), (X = b), (Q -= 257), 256)
                                    : ((G = w), (X = C), -1)),
                              (H = K),
                              (x = P),
                              (N = U = J = 0),
                              (k = -1),
                              (v = (W = 1 << (D = q)) - 1),
                              (T === 1 && 852 < W) || (T === 2 && 592 < W))
                            )
                              return 1
                            for (;;) {
                              for (
                                S = H - N,
                                  j =
                                    $[U] < _
                                      ? ((A = 0), $[U])
                                      : $[U] > _
                                        ? ((A = X[Q + $[U]]), G[Z + $[U]])
                                        : ((A = 96), 0),
                                  M = 1 << (H - N),
                                  K = R = 1 << D;
                                (O[x + (J >> N) + (R -= M)] = (S << 24) | (A << 16) | j | 0),
                                  R !== 0;

                              );
                              for (M = 1 << (H - 1); J & M; ) M >>= 1
                              if (
                                (M !== 0 ? ((J &= M - 1), (J += M)) : (J = 0), U++, --rt[H] == 0)
                              ) {
                                if (H === z) break
                                H = I[B + $[U]]
                              }
                              if (q < H && (J & v) !== k) {
                                for (
                                  N === 0 && (N = q), x += K, V = 1 << (D = H - N);
                                  D + N < z && !((V -= rt[D + N]) <= 0);

                                )
                                  (D++, (V <<= 1))
                                if (((W += 1 << D), (T === 1 && 852 < W) || (T === 2 && 592 < W)))
                                  return 1
                                O[(k = J & v)] = (q << 24) | (D << 16) | (x - P) | 0
                              }
                            }
                            return (
                              J !== 0 && (O[x + J] = ((H - N) << 24) | (64 << 16) | 0),
                              (F.bits = q),
                              0
                            )
                          }
                        },
                        { '../utils/common': 41 },
                      ],
                      51: [
                        function (h, p, g) {
                          p.exports = {
                            2: 'need dictionary',
                            1: 'stream end',
                            0: '',
                            '-1': 'file error',
                            '-2': 'stream error',
                            '-3': 'data error',
                            '-4': 'insufficient memory',
                            '-5': 'buffer error',
                            '-6': 'incompatible version',
                          }
                        },
                        {},
                      ],
                      52: [
                        function (h, p, g) {
                          var m = h('../utils/common')
                          function y(X) {
                            for (var Q = X.length; 0 <= --Q; ) X[Q] = 0
                          }
                          var b = 256,
                            w = 286,
                            C = 30,
                            T = 15,
                            I = [
                              0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
                              4, 5, 5, 5, 5, 0,
                            ],
                            B = [
                              0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
                              10, 11, 11, 12, 12, 13, 13,
                            ],
                            E = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                            O = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                            P = new Array(576)
                          y(P)
                          var $ = new Array(60)
                          y($)
                          var F = new Array(512)
                          y(F)
                          var M = new Array(256)
                          y(M)
                          var R = new Array(29)
                          y(R)
                          var k,
                            v,
                            x,
                            _ = new Array(C)
                          function S(X, Q, tt, st, ot) {
                            ;((this.static_tree = X),
                              (this.extra_bits = Q),
                              (this.extra_base = tt),
                              (this.elems = st),
                              (this.max_length = ot),
                              (this.has_stree = X && X.length))
                          }
                          function A(X, Q) {
                            ;((this.dyn_tree = X), (this.max_code = 0), (this.stat_desc = Q))
                          }
                          function j(X) {
                            return X < 256 ? F[X] : F[256 + (X >>> 7)]
                          }
                          function L(X, Q) {
                            ;((X.pending_buf[X.pending++] = 255 & Q),
                              (X.pending_buf[X.pending++] = (Q >>> 8) & 255))
                          }
                          function H(X, Q, tt) {
                            X.bi_valid > 16 - tt
                              ? ((X.bi_buf |= (Q << X.bi_valid) & 65535),
                                L(X, X.bi_buf),
                                (X.bi_buf = Q >> (16 - X.bi_valid)),
                                (X.bi_valid += tt - 16))
                              : ((X.bi_buf |= (Q << X.bi_valid) & 65535), (X.bi_valid += tt))
                          }
                          function U(X, Q, tt) {
                            H(X, tt[2 * Q], tt[2 * Q + 1])
                          }
                          function K(X, Q) {
                            for (var tt = 0; (tt |= 1 & X), (X >>>= 1), (tt <<= 1), 0 < --Q; );
                            return tt >>> 1
                          }
                          function z(X, Q, tt) {
                            var st,
                              ot,
                              at = new Array(16),
                              ht = 0
                            for (st = 1; st <= T; st++) at[st] = ht = (ht + tt[st - 1]) << 1
                            for (ot = 0; ot <= Q; ot++) {
                              var dt = X[2 * ot + 1]
                              dt !== 0 && (X[2 * ot] = K(at[dt]++, dt))
                            }
                          }
                          function q(X) {
                            var Q
                            for (Q = 0; Q < w; Q++) X.dyn_ltree[2 * Q] = 0
                            for (Q = 0; Q < C; Q++) X.dyn_dtree[2 * Q] = 0
                            for (Q = 0; Q < 19; Q++) X.bl_tree[2 * Q] = 0
                            ;((X.dyn_ltree[512] = 1),
                              (X.opt_len = X.static_len = 0),
                              (X.last_lit = X.matches = 0))
                          }
                          function D(X) {
                            ;(8 < X.bi_valid
                              ? L(X, X.bi_buf)
                              : 0 < X.bi_valid && (X.pending_buf[X.pending++] = X.bi_buf),
                              (X.bi_buf = 0),
                              (X.bi_valid = 0))
                          }
                          function N(X, Q, tt, st) {
                            var ot = 2 * Q,
                              at = 2 * tt
                            return X[ot] < X[at] || (X[ot] === X[at] && st[Q] <= st[tt])
                          }
                          function V(X, Q, tt) {
                            for (
                              var st = X.heap[tt], ot = tt << 1;
                              ot <= X.heap_len &&
                              (ot < X.heap_len && N(Q, X.heap[ot + 1], X.heap[ot], X.depth) && ot++,
                              !N(Q, st, X.heap[ot], X.depth));

                            )
                              ((X.heap[tt] = X.heap[ot]), (tt = ot), (ot <<= 1))
                            X.heap[tt] = st
                          }
                          function W(X, Q, tt) {
                            var st,
                              ot,
                              at,
                              ht,
                              dt = 0
                            if (X.last_lit !== 0)
                              for (
                                ;
                                (st =
                                  (X.pending_buf[X.d_buf + 2 * dt] << 8) |
                                  X.pending_buf[X.d_buf + 2 * dt + 1]),
                                  (ot = X.pending_buf[X.l_buf + dt]),
                                  dt++,
                                  st === 0
                                    ? U(X, ot, Q)
                                    : (U(X, (at = M[ot]) + b + 1, Q),
                                      (ht = I[at]) !== 0 && H(X, (ot -= R[at]), ht),
                                      U(X, (at = j(--st)), tt),
                                      (ht = B[at]) !== 0 && H(X, (st -= _[at]), ht)),
                                  dt < X.last_lit;

                              );
                            U(X, 256, Q)
                          }
                          function J(X, Q) {
                            var tt,
                              st,
                              ot,
                              at = Q.dyn_tree,
                              ht = Q.stat_desc.static_tree,
                              dt = Q.stat_desc.has_stree,
                              mt = Q.stat_desc.elems,
                              bt = -1
                            for (X.heap_len = 0, X.heap_max = 573, tt = 0; tt < mt; tt++)
                              at[2 * tt] !== 0
                                ? ((X.heap[++X.heap_len] = bt = tt), (X.depth[tt] = 0))
                                : (at[2 * tt + 1] = 0)
                            for (; X.heap_len < 2; )
                              ((at[2 * (ot = X.heap[++X.heap_len] = bt < 2 ? ++bt : 0)] = 1),
                                (X.depth[ot] = 0),
                                X.opt_len--,
                                dt && (X.static_len -= ht[2 * ot + 1]))
                            for (Q.max_code = bt, tt = X.heap_len >> 1; 1 <= tt; tt--) V(X, at, tt)
                            for (
                              ot = mt;
                              (tt = X.heap[1]),
                                (X.heap[1] = X.heap[X.heap_len--]),
                                V(X, at, 1),
                                (st = X.heap[1]),
                                (X.heap[--X.heap_max] = tt),
                                (X.heap[--X.heap_max] = st),
                                (at[2 * ot] = at[2 * tt] + at[2 * st]),
                                (X.depth[ot] =
                                  (X.depth[tt] >= X.depth[st] ? X.depth[tt] : X.depth[st]) + 1),
                                (at[2 * tt + 1] = at[2 * st + 1] = ot),
                                (X.heap[1] = ot++),
                                V(X, at, 1),
                                2 <= X.heap_len;

                            );
                            ;((X.heap[--X.heap_max] = X.heap[1]),
                              (function (yt, vt) {
                                var Nt,
                                  Dt,
                                  Mt,
                                  Ot,
                                  Ct,
                                  xt,
                                  Rt = vt.dyn_tree,
                                  It = vt.max_code,
                                  Pt = vt.stat_desc.static_tree,
                                  ae = vt.stat_desc.has_stree,
                                  Se = vt.stat_desc.extra_bits,
                                  zt = vt.stat_desc.extra_base,
                                  be = vt.stat_desc.max_length,
                                  Ut = 0
                                for (Ot = 0; Ot <= T; Ot++) yt.bl_count[Ot] = 0
                                for (
                                  Rt[2 * yt.heap[yt.heap_max] + 1] = 0, Nt = yt.heap_max + 1;
                                  Nt < 573;
                                  Nt++
                                )
                                  (be < (Ot = Rt[2 * Rt[2 * (Dt = yt.heap[Nt]) + 1] + 1] + 1) &&
                                    ((Ot = be), Ut++),
                                    (Rt[2 * Dt + 1] = Ot),
                                    It < Dt ||
                                      (yt.bl_count[Ot]++,
                                      (Ct = 0),
                                      zt <= Dt && (Ct = Se[Dt - zt]),
                                      (xt = Rt[2 * Dt]),
                                      (yt.opt_len += xt * (Ot + Ct)),
                                      ae && (yt.static_len += xt * (Pt[2 * Dt + 1] + Ct))))
                                if (Ut !== 0) {
                                  do {
                                    for (Ot = be - 1; yt.bl_count[Ot] === 0; ) Ot--
                                    ;(yt.bl_count[Ot]--,
                                      (yt.bl_count[Ot + 1] += 2),
                                      yt.bl_count[be]--,
                                      (Ut -= 2))
                                  } while (0 < Ut)
                                  for (Ot = be; Ot !== 0; Ot--)
                                    for (Dt = yt.bl_count[Ot]; Dt !== 0; )
                                      It < (Mt = yt.heap[--Nt]) ||
                                        (Rt[2 * Mt + 1] !== Ot &&
                                          ((yt.opt_len += (Ot - Rt[2 * Mt + 1]) * Rt[2 * Mt]),
                                          (Rt[2 * Mt + 1] = Ot)),
                                        Dt--)
                                }
                              })(X, Q),
                              z(at, bt, X.bl_count))
                          }
                          function G(X, Q, tt) {
                            var st,
                              ot,
                              at = -1,
                              ht = Q[1],
                              dt = 0,
                              mt = 7,
                              bt = 4
                            for (
                              ht === 0 && ((mt = 138), (bt = 3)),
                                Q[2 * (tt + 1) + 1] = 65535,
                                st = 0;
                              st <= tt;
                              st++
                            )
                              ((ot = ht),
                                (ht = Q[2 * (st + 1) + 1]),
                                (++dt < mt && ot === ht) ||
                                  (dt < bt
                                    ? (X.bl_tree[2 * ot] += dt)
                                    : ot !== 0
                                      ? (ot !== at && X.bl_tree[2 * ot]++, X.bl_tree[32]++)
                                      : dt <= 10
                                        ? X.bl_tree[34]++
                                        : X.bl_tree[36]++,
                                  (at = ot),
                                  (bt =
                                    (dt = 0) === ht
                                      ? ((mt = 138), 3)
                                      : ot === ht
                                        ? ((mt = 6), 3)
                                        : ((mt = 7), 4))))
                          }
                          function Z(X, Q, tt) {
                            var st,
                              ot,
                              at = -1,
                              ht = Q[1],
                              dt = 0,
                              mt = 7,
                              bt = 4
                            for (ht === 0 && ((mt = 138), (bt = 3)), st = 0; st <= tt; st++)
                              if (
                                ((ot = ht), (ht = Q[2 * (st + 1) + 1]), !(++dt < mt && ot === ht))
                              ) {
                                if (dt < bt) for (; U(X, ot, X.bl_tree), --dt != 0; );
                                else
                                  ot !== 0
                                    ? (ot !== at && (U(X, ot, X.bl_tree), dt--),
                                      U(X, 16, X.bl_tree),
                                      H(X, dt - 3, 2))
                                    : dt <= 10
                                      ? (U(X, 17, X.bl_tree), H(X, dt - 3, 3))
                                      : (U(X, 18, X.bl_tree), H(X, dt - 11, 7))
                                ;((at = ot),
                                  (bt =
                                    (dt = 0) === ht
                                      ? ((mt = 138), 3)
                                      : ot === ht
                                        ? ((mt = 6), 3)
                                        : ((mt = 7), 4)))
                              }
                          }
                          y(_)
                          var rt = !1
                          function nt(X, Q, tt, st) {
                            ;(H(X, 0 + (st ? 1 : 0), 3),
                              (function (ot, at, ht, dt) {
                                ;(D(ot),
                                  L(ot, ht),
                                  L(ot, ~ht),
                                  m.arraySet(ot.pending_buf, ot.window, at, ht, ot.pending),
                                  (ot.pending += ht))
                              })(X, Q, tt))
                          }
                          ;((g._tr_init = function (X) {
                            ;(rt ||
                              ((function () {
                                var Q,
                                  tt,
                                  st,
                                  ot,
                                  at,
                                  ht = new Array(16)
                                for (ot = st = 0; ot < 28; ot++)
                                  for (R[ot] = st, Q = 0; Q < 1 << I[ot]; Q++) M[st++] = ot
                                for (M[st - 1] = ot, ot = at = 0; ot < 16; ot++)
                                  for (_[ot] = at, Q = 0; Q < 1 << B[ot]; Q++) F[at++] = ot
                                for (at >>= 7; ot < C; ot++)
                                  for (_[ot] = at << 7, Q = 0; Q < 1 << (B[ot] - 7); Q++)
                                    F[256 + at++] = ot
                                for (tt = 0; tt <= T; tt++) ht[tt] = 0
                                for (Q = 0; Q <= 143; ) ((P[2 * Q + 1] = 8), Q++, ht[8]++)
                                for (; Q <= 255; ) ((P[2 * Q + 1] = 9), Q++, ht[9]++)
                                for (; Q <= 279; ) ((P[2 * Q + 1] = 7), Q++, ht[7]++)
                                for (; Q <= 287; ) ((P[2 * Q + 1] = 8), Q++, ht[8]++)
                                for (z(P, 287, ht), Q = 0; Q < C; Q++)
                                  (($[2 * Q + 1] = 5), ($[2 * Q] = K(Q, 5)))
                                ;((k = new S(P, I, 257, w, T)),
                                  (v = new S($, B, 0, C, T)),
                                  (x = new S(new Array(0), E, 0, 19, 7)))
                              })(),
                              (rt = !0)),
                              (X.l_desc = new A(X.dyn_ltree, k)),
                              (X.d_desc = new A(X.dyn_dtree, v)),
                              (X.bl_desc = new A(X.bl_tree, x)),
                              (X.bi_buf = 0),
                              (X.bi_valid = 0),
                              q(X))
                          }),
                            (g._tr_stored_block = nt),
                            (g._tr_flush_block = function (X, Q, tt, st) {
                              var ot,
                                at,
                                ht = 0
                              ;(0 < X.level
                                ? (X.strm.data_type === 2 &&
                                    (X.strm.data_type = (function (dt) {
                                      var mt,
                                        bt = 4093624447
                                      for (mt = 0; mt <= 31; mt++, bt >>>= 1)
                                        if (1 & bt && dt.dyn_ltree[2 * mt] !== 0) return 0
                                      if (
                                        dt.dyn_ltree[18] !== 0 ||
                                        dt.dyn_ltree[20] !== 0 ||
                                        dt.dyn_ltree[26] !== 0
                                      )
                                        return 1
                                      for (mt = 32; mt < b; mt++)
                                        if (dt.dyn_ltree[2 * mt] !== 0) return 1
                                      return 0
                                    })(X)),
                                  J(X, X.l_desc),
                                  J(X, X.d_desc),
                                  (ht = (function (dt) {
                                    var mt
                                    for (
                                      G(dt, dt.dyn_ltree, dt.l_desc.max_code),
                                        G(dt, dt.dyn_dtree, dt.d_desc.max_code),
                                        J(dt, dt.bl_desc),
                                        mt = 18;
                                      3 <= mt && dt.bl_tree[2 * O[mt] + 1] === 0;
                                      mt--
                                    );
                                    return ((dt.opt_len += 3 * (mt + 1) + 5 + 5 + 4), mt)
                                  })(X)),
                                  (ot = (X.opt_len + 3 + 7) >>> 3),
                                  (at = (X.static_len + 3 + 7) >>> 3) <= ot && (ot = at))
                                : (ot = at = tt + 5),
                                tt + 4 <= ot && Q !== -1
                                  ? nt(X, Q, tt, st)
                                  : X.strategy === 4 || at === ot
                                    ? (H(X, 2 + (st ? 1 : 0), 3), W(X, P, $))
                                    : (H(X, 4 + (st ? 1 : 0), 3),
                                      (function (dt, mt, bt, yt) {
                                        var vt
                                        for (
                                          H(dt, mt - 257, 5),
                                            H(dt, bt - 1, 5),
                                            H(dt, yt - 4, 4),
                                            vt = 0;
                                          vt < yt;
                                          vt++
                                        )
                                          H(dt, dt.bl_tree[2 * O[vt] + 1], 3)
                                        ;(Z(dt, dt.dyn_ltree, mt - 1), Z(dt, dt.dyn_dtree, bt - 1))
                                      })(X, X.l_desc.max_code + 1, X.d_desc.max_code + 1, ht + 1),
                                      W(X, X.dyn_ltree, X.dyn_dtree)),
                                q(X),
                                st && D(X))
                            }),
                            (g._tr_tally = function (X, Q, tt) {
                              return (
                                (X.pending_buf[X.d_buf + 2 * X.last_lit] = (Q >>> 8) & 255),
                                (X.pending_buf[X.d_buf + 2 * X.last_lit + 1] = 255 & Q),
                                (X.pending_buf[X.l_buf + X.last_lit] = 255 & tt),
                                X.last_lit++,
                                Q === 0
                                  ? X.dyn_ltree[2 * tt]++
                                  : (X.matches++,
                                    Q--,
                                    X.dyn_ltree[2 * (M[tt] + b + 1)]++,
                                    X.dyn_dtree[2 * j(Q)]++),
                                X.last_lit === X.lit_bufsize - 1
                              )
                            }),
                            (g._tr_align = function (X) {
                              ;(H(X, 2, 3),
                                U(X, 256, P),
                                (function (Q) {
                                  Q.bi_valid === 16
                                    ? (L(Q, Q.bi_buf), (Q.bi_buf = 0), (Q.bi_valid = 0))
                                    : 8 <= Q.bi_valid &&
                                      ((Q.pending_buf[Q.pending++] = 255 & Q.bi_buf),
                                      (Q.bi_buf >>= 8),
                                      (Q.bi_valid -= 8))
                                })(X))
                            }))
                        },
                        { '../utils/common': 41 },
                      ],
                      53: [
                        function (h, p, g) {
                          p.exports = function () {
                            ;((this.input = null),
                              (this.next_in = 0),
                              (this.avail_in = 0),
                              (this.total_in = 0),
                              (this.output = null),
                              (this.next_out = 0),
                              (this.avail_out = 0),
                              (this.total_out = 0),
                              (this.msg = ''),
                              (this.state = null),
                              (this.data_type = 2),
                              (this.adler = 0))
                          }
                        },
                        {},
                      ],
                      54: [
                        function (h, p, g) {
                          ;(function (m) {
                            ;(function (y, b) {
                              if (!y.setImmediate) {
                                var w,
                                  C,
                                  T,
                                  I,
                                  B = 1,
                                  E = {},
                                  O = !1,
                                  P = y.document,
                                  $ = Object.getPrototypeOf && Object.getPrototypeOf(y)
                                ;(($ = $ && $.setTimeout ? $ : y),
                                  (w =
                                    {}.toString.call(y.process) === '[object process]'
                                      ? function (k) {
                                          s.nextTick(function () {
                                            M(k)
                                          })
                                        }
                                      : (function () {
                                            if (y.postMessage && !y.importScripts) {
                                              var k = !0,
                                                v = y.onmessage
                                              return (
                                                (y.onmessage = function () {
                                                  k = !1
                                                }),
                                                y.postMessage('', '*'),
                                                (y.onmessage = v),
                                                k
                                              )
                                            }
                                          })()
                                        ? ((I = 'setImmediate$' + Math.random() + '$'),
                                          y.addEventListener
                                            ? y.addEventListener('message', R, !1)
                                            : y.attachEvent('onmessage', R),
                                          function (k) {
                                            y.postMessage(I + k, '*')
                                          })
                                        : y.MessageChannel
                                          ? (((T = new MessageChannel()).port1.onmessage =
                                              function (k) {
                                                M(k.data)
                                              }),
                                            function (k) {
                                              T.port2.postMessage(k)
                                            })
                                          : P && 'onreadystatechange' in P.createElement('script')
                                            ? ((C = P.documentElement),
                                              function (k) {
                                                var v = P.createElement('script')
                                                ;((v.onreadystatechange = function () {
                                                  ;(M(k),
                                                    (v.onreadystatechange = null),
                                                    C.removeChild(v),
                                                    (v = null))
                                                }),
                                                  C.appendChild(v))
                                              })
                                            : function (k) {
                                                setTimeout(M, 0, k)
                                              }),
                                  ($.setImmediate = function (k) {
                                    typeof k != 'function' && (k = new Function('' + k))
                                    for (
                                      var v = new Array(arguments.length - 1), x = 0;
                                      x < v.length;
                                      x++
                                    )
                                      v[x] = arguments[x + 1]
                                    var _ = { callback: k, args: v }
                                    return ((E[B] = _), w(B), B++)
                                  }),
                                  ($.clearImmediate = F))
                              }
                              function F(k) {
                                delete E[k]
                              }
                              function M(k) {
                                if (O) setTimeout(M, 0, k)
                                else {
                                  var v = E[k]
                                  if (v) {
                                    O = !0
                                    try {
                                      ;(function (x) {
                                        var _ = x.callback,
                                          S = x.args
                                        switch (S.length) {
                                          case 0:
                                            _()
                                            break
                                          case 1:
                                            _(S[0])
                                            break
                                          case 2:
                                            _(S[0], S[1])
                                            break
                                          case 3:
                                            _(S[0], S[1], S[2])
                                            break
                                          default:
                                            _.apply(void 0, S)
                                        }
                                      })(v)
                                    } finally {
                                      ;(F(k), (O = !1))
                                    }
                                  }
                                }
                              }
                              function R(k) {
                                k.source === y &&
                                  typeof k.data == 'string' &&
                                  k.data.indexOf(I) === 0 &&
                                  M(+k.data.slice(I.length))
                              }
                            })(typeof self > 'u' ? (m === void 0 ? this : m) : self)
                          }).call(
                            this,
                            o !== void 0
                              ? o
                              : typeof self < 'u'
                                ? self
                                : typeof window < 'u'
                                  ? window
                                  : {},
                          )
                        },
                        {},
                      ],
                    },
                    {},
                    [10],
                  )(10)
                })
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
              t('buffer').Buffer,
              arguments[3],
              arguments[4],
              arguments[5],
              arguments[6],
              t('timers').setImmediate,
            )
          },
          { _process: 467, buffer: 220, timers: 523 },
        ],
        442: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = /[\\^$.*+?()[\]{}|]/g,
                  a = RegExp(o.source),
                  l = typeof s == 'object' && s && s.Object === Object && s,
                  c = typeof self == 'object' && self && self.Object === Object && self,
                  u = l || c || Function('return this')(),
                  f = Object.prototype.toString,
                  d = u.Symbol,
                  h = d ? d.prototype : void 0,
                  p = h ? h.toString : void 0
                function g(m) {
                  if (typeof m == 'string') return m
                  if (
                    (function (b) {
                      return (
                        typeof b == 'symbol' ||
                        ((function (w) {
                          return !!w && typeof w == 'object'
                        })(b) &&
                          f.call(b) == '[object Symbol]')
                      )
                    })(m)
                  )
                    return p ? p.call(m) : ''
                  var y = m + ''
                  return y == '0' && 1 / m == -1 / 0 ? '-0' : y
                }
                r.exports = function (m) {
                  var y
                  return (m = (y = m) == null ? '' : g(y)) && a.test(m) ? m.replace(o, '\\$&') : m
                }
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {},
        ],
        443: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = '[object Arguments]',
                  a = '[object Map]',
                  l = '[object Object]',
                  c = '[object Set]',
                  u = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                  f = /^\w*$/,
                  d = /^\./,
                  h =
                    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                  p = /\\(\\)?/g,
                  g = /^\[object .+?Constructor\]$/,
                  m = /^(?:0|[1-9]\d*)$/,
                  y = {}
                ;((y['[object Float32Array]'] =
                  y['[object Float64Array]'] =
                  y['[object Int8Array]'] =
                  y['[object Int16Array]'] =
                  y['[object Int32Array]'] =
                  y['[object Uint8Array]'] =
                  y['[object Uint8ClampedArray]'] =
                  y['[object Uint16Array]'] =
                  y['[object Uint32Array]'] =
                    !0),
                  (y[o] =
                    y['[object Array]'] =
                    y['[object ArrayBuffer]'] =
                    y['[object Boolean]'] =
                    y['[object DataView]'] =
                    y['[object Date]'] =
                    y['[object Error]'] =
                    y['[object Function]'] =
                    y[a] =
                    y['[object Number]'] =
                    y[l] =
                    y['[object RegExp]'] =
                    y[c] =
                    y['[object String]'] =
                    y['[object WeakMap]'] =
                      !1))
                var b = typeof s == 'object' && s && s.Object === Object && s,
                  w = typeof self == 'object' && self && self.Object === Object && self,
                  C = b || w || Function('return this')(),
                  T = typeof i == 'object' && i && !i.nodeType && i,
                  I = T && typeof r == 'object' && r && !r.nodeType && r,
                  B = I && I.exports === T && b.process,
                  E = (function () {
                    try {
                      return B && B.binding('util')
                    } catch {}
                  })(),
                  O = E && E.isTypedArray
                function P(et, ft, gt, wt) {
                  for (var $t = -1, Et = et ? et.length : 0; ++$t < Et; ) {
                    var At = et[$t]
                    ft(wt, At, gt(At), et)
                  }
                  return wt
                }
                function $(et, ft) {
                  for (var gt = -1, wt = et ? et.length : 0; ++gt < wt; )
                    if (ft(et[gt], gt, et)) return !0
                  return !1
                }
                function F(et) {
                  var ft = !1
                  if (et != null && typeof et.toString != 'function')
                    try {
                      ft = !!(et + '')
                    } catch {}
                  return ft
                }
                function M(et) {
                  var ft = -1,
                    gt = Array(et.size)
                  return (
                    et.forEach(function (wt, $t) {
                      gt[++ft] = [$t, wt]
                    }),
                    gt
                  )
                }
                function R(et) {
                  var ft = -1,
                    gt = Array(et.size)
                  return (
                    et.forEach(function (wt) {
                      gt[++ft] = wt
                    }),
                    gt
                  )
                }
                var k,
                  v,
                  x,
                  _ = Array.prototype,
                  S = Function.prototype,
                  A = Object.prototype,
                  j = C['__core-js_shared__'],
                  L = (k = /[^.]+$/.exec((j && j.keys && j.keys.IE_PROTO) || ''))
                    ? 'Symbol(src)_1.' + k
                    : '',
                  H = S.toString,
                  U = A.hasOwnProperty,
                  K = A.toString,
                  z = RegExp(
                    '^' +
                      H.call(U)
                        .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                        .replace(
                          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                          '$1.*?',
                        ) +
                      '$',
                  ),
                  q = C.Symbol,
                  D = C.Uint8Array,
                  N = A.propertyIsEnumerable,
                  V = _.splice,
                  W =
                    ((v = Object.keys),
                    (x = Object),
                    function (et) {
                      return v(x(et))
                    }),
                  J = Ft(C, 'DataView'),
                  G = Ft(C, 'Map'),
                  Z = Ft(C, 'Promise'),
                  rt = Ft(C, 'Set'),
                  nt = Ft(C, 'WeakMap'),
                  X = Ft(Object, 'create'),
                  Q = ct(J),
                  tt = ct(G),
                  st = ct(Z),
                  ot = ct(rt),
                  at = ct(nt),
                  ht = q ? q.prototype : void 0,
                  dt = ht ? ht.valueOf : void 0,
                  mt = ht ? ht.toString : void 0
                function bt(et) {
                  var ft = -1,
                    gt = et ? et.length : 0
                  for (this.clear(); ++ft < gt; ) {
                    var wt = et[ft]
                    this.set(wt[0], wt[1])
                  }
                }
                function yt(et) {
                  var ft = -1,
                    gt = et ? et.length : 0
                  for (this.clear(); ++ft < gt; ) {
                    var wt = et[ft]
                    this.set(wt[0], wt[1])
                  }
                }
                function vt(et) {
                  var ft = -1,
                    gt = et ? et.length : 0
                  for (this.clear(); ++ft < gt; ) {
                    var wt = et[ft]
                    this.set(wt[0], wt[1])
                  }
                }
                function Nt(et) {
                  var ft = -1,
                    gt = et ? et.length : 0
                  for (this.__data__ = new vt(); ++ft < gt; ) this.add(et[ft])
                }
                function Dt(et) {
                  this.__data__ = new yt(et)
                }
                function Mt(et, ft) {
                  var gt =
                      Gt(et) || te(et)
                        ? (function (At, ve) {
                            for (var ue = -1, he = Array(At); ++ue < At; ) he[ue] = ve(ue)
                            return he
                          })(et.length, String)
                        : [],
                    wt = gt.length,
                    $t = !!wt
                  for (var Et in et)
                    !U.call(et, Et) || ($t && (Et == 'length' || fe(Et, wt))) || gt.push(Et)
                  return gt
                }
                function Ot(et, ft) {
                  for (var gt = et.length; gt--; ) if (Tt(et[gt][0], ft)) return gt
                  return -1
                }
                function Ct(et, ft, gt, wt) {
                  return (
                    Rt(et, function ($t, Et, At) {
                      ft(wt, $t, gt($t), At)
                    }),
                    wt
                  )
                }
                ;((bt.prototype.clear = function () {
                  this.__data__ = X ? X(null) : {}
                }),
                  (bt.prototype.delete = function (et) {
                    return this.has(et) && delete this.__data__[et]
                  }),
                  (bt.prototype.get = function (et) {
                    var ft = this.__data__
                    if (X) {
                      var gt = ft[et]
                      return gt === '__lodash_hash_undefined__' ? void 0 : gt
                    }
                    return U.call(ft, et) ? ft[et] : void 0
                  }),
                  (bt.prototype.has = function (et) {
                    var ft = this.__data__
                    return X ? ft[et] !== void 0 : U.call(ft, et)
                  }),
                  (bt.prototype.set = function (et, ft) {
                    return (
                      (this.__data__[et] = X && ft === void 0 ? '__lodash_hash_undefined__' : ft),
                      this
                    )
                  }),
                  (yt.prototype.clear = function () {
                    this.__data__ = []
                  }),
                  (yt.prototype.delete = function (et) {
                    var ft = this.__data__,
                      gt = Ot(ft, et)
                    return !(gt < 0) && (gt == ft.length - 1 ? ft.pop() : V.call(ft, gt, 1), !0)
                  }),
                  (yt.prototype.get = function (et) {
                    var ft = this.__data__,
                      gt = Ot(ft, et)
                    return gt < 0 ? void 0 : ft[gt][1]
                  }),
                  (yt.prototype.has = function (et) {
                    return Ot(this.__data__, et) > -1
                  }),
                  (yt.prototype.set = function (et, ft) {
                    var gt = this.__data__,
                      wt = Ot(gt, et)
                    return (wt < 0 ? gt.push([et, ft]) : (gt[wt][1] = ft), this)
                  }),
                  (vt.prototype.clear = function () {
                    this.__data__ = { hash: new bt(), map: new (G || yt)(), string: new bt() }
                  }),
                  (vt.prototype.delete = function (et) {
                    return ce(this, et).delete(et)
                  }),
                  (vt.prototype.get = function (et) {
                    return ce(this, et).get(et)
                  }),
                  (vt.prototype.has = function (et) {
                    return ce(this, et).has(et)
                  }),
                  (vt.prototype.set = function (et, ft) {
                    return (ce(this, et).set(et, ft), this)
                  }),
                  (Nt.prototype.add = Nt.prototype.push =
                    function (et) {
                      return (this.__data__.set(et, '__lodash_hash_undefined__'), this)
                    }),
                  (Nt.prototype.has = function (et) {
                    return this.__data__.has(et)
                  }),
                  (Dt.prototype.clear = function () {
                    this.__data__ = new yt()
                  }),
                  (Dt.prototype.delete = function (et) {
                    return this.__data__.delete(et)
                  }),
                  (Dt.prototype.get = function (et) {
                    return this.__data__.get(et)
                  }),
                  (Dt.prototype.has = function (et) {
                    return this.__data__.has(et)
                  }),
                  (Dt.prototype.set = function (et, ft) {
                    var gt = this.__data__
                    if (gt instanceof yt) {
                      var wt = gt.__data__
                      if (!G || wt.length < 199) return (wt.push([et, ft]), this)
                      gt = this.__data__ = new vt(wt)
                    }
                    return (gt.set(et, ft), this)
                  }))
                var xt,
                  Rt =
                    ((xt = function (et, ft) {
                      return et && It(et, ft, Xe)
                    }),
                    function (et, ft) {
                      if (et == null) return et
                      if (!Ht(et)) return xt(et, ft)
                      for (
                        var gt = et.length, wt = -1, $t = Object(et);
                        ++wt < gt && ft($t[wt], wt, $t) !== !1;

                      );
                      return et
                    }),
                  It = (function (et) {
                    return function (ft, gt, wt) {
                      for (var $t = -1, Et = Object(ft), At = wt(ft), ve = At.length; ve--; ) {
                        var ue = At[++$t]
                        if (gt(Et[ue], ue, Et) === !1) break
                      }
                      return ft
                    }
                  })()
                function Pt(et, ft) {
                  for (
                    var gt = 0, wt = (ft = qt(ft, et) ? [ft] : Lt(ft)).length;
                    et != null && gt < wt;

                  )
                    et = et[it(ft[gt++])]
                  return gt && gt == wt ? et : void 0
                }
                function ae(et, ft) {
                  return et != null && ft in Object(et)
                }
                function Se(et, ft, gt, wt, $t) {
                  return (
                    et === ft ||
                    (et == null || ft == null || (!de(et) && !Le(ft))
                      ? et != et && ft != ft
                      : (function (Et, At, ve, ue, he, Kt) {
                          var Ce = Gt(Et),
                            Me = Gt(At),
                            Ae = '[object Array]',
                            ze = '[object Array]'
                          ;(Ce || (Ae = (Ae = Qt(Et)) == o ? l : Ae),
                            Me || (ze = (ze = Qt(At)) == o ? l : ze))
                          var on = Ae == l && !F(Et),
                            An = ze == l && !F(At),
                            fr = Ae == ze
                          if (fr && !on)
                            return (
                              Kt || (Kt = new Dt()),
                              Ce || Ge(Et)
                                ? le(Et, At, ve, ue, he, Kt)
                                : (function (Ee, ke, li, Qi, zl, Bn, zr) {
                                    switch (li) {
                                      case '[object DataView]':
                                        if (
                                          Ee.byteLength != ke.byteLength ||
                                          Ee.byteOffset != ke.byteOffset
                                        )
                                          return !1
                                        ;((Ee = Ee.buffer), (ke = ke.buffer))
                                      case '[object ArrayBuffer]':
                                        return !(
                                          Ee.byteLength != ke.byteLength ||
                                          !Qi(new D(Ee), new D(ke))
                                        )
                                      case '[object Boolean]':
                                      case '[object Date]':
                                      case '[object Number]':
                                        return Tt(+Ee, +ke)
                                      case '[object Error]':
                                        return Ee.name == ke.name && Ee.message == ke.message
                                      case '[object RegExp]':
                                      case '[object String]':
                                        return Ee == ke + ''
                                      case a:
                                        var ci = M
                                      case c:
                                        var ia = 2 & Bn
                                        if ((ci || (ci = R), Ee.size != ke.size && !ia)) return !1
                                        var $l = zr.get(Ee)
                                        if ($l) return $l == ke
                                        ;((Bn |= 1), zr.set(Ee, ke))
                                        var Gs = le(ci(Ee), ci(ke), Qi, zl, Bn, zr)
                                        return (zr.delete(Ee), Gs)
                                      case '[object Symbol]':
                                        if (dt) return dt.call(Ee) == dt.call(ke)
                                    }
                                    return !1
                                  })(Et, At, Ae, ve, ue, he, Kt)
                            )
                          if (!(2 & he)) {
                            var Ji = on && U.call(Et, '__wrapped__'),
                              qs = An && U.call(At, '__wrapped__')
                            if (Ji || qs) {
                              var Ws = Ji ? Et.value() : Et,
                                Ks = qs ? At.value() : At
                              return (Kt || (Kt = new Dt()), ve(Ws, Ks, ue, he, Kt))
                            }
                          }
                          return fr
                            ? (Kt || (Kt = new Dt()),
                              (function (Ee, ke, li, Qi, zl, Bn) {
                                var zr = 2 & zl,
                                  ci = Xe(Ee),
                                  ia = ci.length,
                                  $l = Xe(ke).length
                                if (ia != $l && !zr) return !1
                                for (var Gs = ia; Gs--; ) {
                                  var ui = ci[Gs]
                                  if (!(zr ? ui in ke : U.call(ke, ui))) return !1
                                }
                                var Kg = Bn.get(Ee)
                                if (Kg && Bn.get(ke)) return Kg == ke
                                var Vl = !0
                                ;(Bn.set(Ee, ke), Bn.set(ke, Ee))
                                for (var cd = zr; ++Gs < ia; ) {
                                  ui = ci[Gs]
                                  var Hl = Ee[ui],
                                    Ul = ke[ui]
                                  if (Qi)
                                    var Gg = zr
                                      ? Qi(Ul, Hl, ui, ke, Ee, Bn)
                                      : Qi(Hl, Ul, ui, Ee, ke, Bn)
                                  if (!(Gg === void 0 ? Hl === Ul || li(Hl, Ul, Qi, zl, Bn) : Gg)) {
                                    Vl = !1
                                    break
                                  }
                                  cd || (cd = ui == 'constructor')
                                }
                                if (Vl && !cd) {
                                  var ql = Ee.constructor,
                                    Wl = ke.constructor
                                  ql == Wl ||
                                    !('constructor' in Ee) ||
                                    !('constructor' in ke) ||
                                    (typeof ql == 'function' &&
                                      ql instanceof ql &&
                                      typeof Wl == 'function' &&
                                      Wl instanceof Wl) ||
                                    (Vl = !1)
                                }
                                return (Bn.delete(Ee), Bn.delete(ke), Vl)
                              })(Et, At, ve, ue, he, Kt))
                            : !1
                        })(et, ft, Se, gt, wt, $t))
                  )
                }
                function zt(et) {
                  return (
                    !(
                      !de(et) ||
                      (function (ft) {
                        return !!L && L in ft
                      })(et)
                    ) && (ie(et) || F(et) ? z : g).test(ct(et))
                  )
                }
                function be(et) {
                  return typeof et == 'function'
                    ? et
                    : et == null
                      ? pn
                      : typeof et == 'object'
                        ? Gt(et)
                          ? (function (wt, $t) {
                              return qt(wt) && Jt($t)
                                ? me(it(wt), $t)
                                : function (Et) {
                                    var At = (function (ve, ue, he) {
                                      var Kt = ve == null ? void 0 : Pt(ve, ue)
                                      return Kt === void 0 ? he : Kt
                                    })(Et, wt)
                                    return At === void 0 && At === $t
                                      ? (function (ve, ue) {
                                          return (
                                            ve != null &&
                                            (function (he, Kt, Ce) {
                                              Kt = qt(Kt, he) ? [Kt] : Lt(Kt)
                                              for (var Me, Ae = -1, ze = Kt.length; ++Ae < ze; ) {
                                                var on = it(Kt[Ae])
                                                if (!(Me = he != null && Ce(he, on))) break
                                                he = he[on]
                                              }
                                              return (
                                                Me ||
                                                (!!(ze = he ? he.length : 0) &&
                                                  ee(ze) &&
                                                  fe(on, ze) &&
                                                  (Gt(he) || te(he)))
                                              )
                                            })(ve, ue, ae)
                                          )
                                        })(Et, wt)
                                      : Se($t, At, void 0, 3)
                                  }
                            })(et[0], et[1])
                          : (function (wt) {
                              var $t = (function (Et) {
                                for (var At = Xe(Et), ve = At.length; ve--; ) {
                                  var ue = At[ve],
                                    he = Et[ue]
                                  At[ve] = [ue, he, Jt(he)]
                                }
                                return At
                              })(wt)
                              return $t.length == 1 && $t[0][2]
                                ? me($t[0][0], $t[0][1])
                                : function (Et) {
                                    return (
                                      Et === wt ||
                                      (function (At, ve, ue, he) {
                                        var Kt = ue.length,
                                          Ce = Kt
                                        if (At == null) return !Ce
                                        for (At = Object(At); Kt--; ) {
                                          var Me = ue[Kt]
                                          if (Me[2] ? Me[1] !== At[Me[0]] : !(Me[0] in At))
                                            return !1
                                        }
                                        for (; ++Kt < Ce; ) {
                                          var Ae = (Me = ue[Kt])[0],
                                            ze = At[Ae],
                                            on = Me[1]
                                          if (Me[2]) {
                                            if (ze === void 0 && !(Ae in At)) return !1
                                          } else {
                                            var An = new Dt(),
                                              fr
                                            if (!(fr === void 0 ? Se(on, ze, he, 3, An) : fr))
                                              return !1
                                          }
                                        }
                                        return !0
                                      })(Et, wt, $t)
                                    )
                                  }
                            })(et)
                        : qt((ft = et))
                          ? ((gt = it(ft)),
                            function (wt) {
                              return wt?.[gt]
                            })
                          : (function (wt) {
                              return function ($t) {
                                return Pt($t, wt)
                              }
                            })(ft)
                  var ft, gt
                }
                function Ut(et) {
                  if (
                    ((gt = (ft = et) && ft.constructor),
                    (wt = (typeof gt == 'function' && gt.prototype) || A),
                    ft !== wt)
                  )
                    return W(et)
                  var ft,
                    gt,
                    wt,
                    $t = []
                  for (var Et in Object(et)) U.call(et, Et) && Et != 'constructor' && $t.push(Et)
                  return $t
                }
                function Lt(et) {
                  return Gt(et) ? et : Wt(et)
                }
                function le(et, ft, gt, wt, $t, Et) {
                  var At = 2 & $t,
                    ve = et.length,
                    ue = ft.length
                  if (ve != ue && !(At && ue > ve)) return !1
                  var he = Et.get(et)
                  if (he && Et.get(ft)) return he == ft
                  var Kt = -1,
                    Ce = !0,
                    Me = 1 & $t ? new Nt() : void 0
                  for (Et.set(et, ft), Et.set(ft, et); ++Kt < ve; ) {
                    var Ae = et[Kt],
                      ze = ft[Kt]
                    if (wt) var on = At ? wt(ze, Ae, Kt, ft, et, Et) : wt(Ae, ze, Kt, et, ft, Et)
                    if (on !== void 0) {
                      if (on) continue
                      Ce = !1
                      break
                    }
                    if (Me) {
                      if (
                        !$(ft, function (An, fr) {
                          if (!Me.has(fr) && (Ae === An || gt(Ae, An, wt, $t, Et)))
                            return Me.add(fr)
                        })
                      ) {
                        Ce = !1
                        break
                      }
                    } else if (Ae !== ze && !gt(Ae, ze, wt, $t, Et)) {
                      Ce = !1
                      break
                    }
                  }
                  return (Et.delete(et), Et.delete(ft), Ce)
                }
                function ce(et, ft) {
                  var gt,
                    wt,
                    $t = et.__data__
                  return (
                    (wt = typeof (gt = ft)) == 'string' ||
                    wt == 'number' ||
                    wt == 'symbol' ||
                    wt == 'boolean'
                      ? gt !== '__proto__'
                      : gt === null
                  )
                    ? $t[typeof ft == 'string' ? 'string' : 'hash']
                    : $t.map
                }
                function Ft(et, ft) {
                  var gt = (function (wt, $t) {
                    return wt?.[$t]
                  })(et, ft)
                  return zt(gt) ? gt : void 0
                }
                var Qt = function (et) {
                  return K.call(et)
                }
                function fe(et, ft) {
                  return (
                    !!(ft = ft ?? 9007199254740991) &&
                    (typeof et == 'number' || m.test(et)) &&
                    et > -1 &&
                    et % 1 == 0 &&
                    et < ft
                  )
                }
                function qt(et, ft) {
                  if (Gt(et)) return !1
                  var gt = typeof et
                  return (
                    !(
                      gt != 'number' &&
                      gt != 'symbol' &&
                      gt != 'boolean' &&
                      et != null &&
                      !Te(et)
                    ) ||
                    f.test(et) ||
                    !u.test(et) ||
                    (ft != null && et in Object(ft))
                  )
                }
                function Jt(et) {
                  return et == et && !de(et)
                }
                function me(et, ft) {
                  return function (gt) {
                    return gt != null && gt[et] === ft && (ft !== void 0 || et in Object(gt))
                  }
                }
                ;((J && Qt(new J(new ArrayBuffer(1))) != '[object DataView]') ||
                  (G && Qt(new G()) != a) ||
                  (Z && Qt(Z.resolve()) != '[object Promise]') ||
                  (rt && Qt(new rt()) != c) ||
                  (nt && Qt(new nt()) != '[object WeakMap]')) &&
                  (Qt = function (et) {
                    var ft = K.call(et),
                      gt = ft == l ? et.constructor : void 0,
                      wt = gt ? ct(gt) : void 0
                    if (wt)
                      switch (wt) {
                        case Q:
                          return '[object DataView]'
                        case tt:
                          return a
                        case st:
                          return '[object Promise]'
                        case ot:
                          return c
                        case at:
                          return '[object WeakMap]'
                      }
                    return ft
                  })
                var Wt = Vt(function (et) {
                  var ft
                  et =
                    (ft = et) == null
                      ? ''
                      : (function (wt) {
                          if (typeof wt == 'string') return wt
                          if (Te(wt)) return mt ? mt.call(wt) : ''
                          var $t = wt + ''
                          return $t == '0' && 1 / wt == -1 / 0 ? '-0' : $t
                        })(ft)
                  var gt = []
                  return (
                    d.test(et) && gt.push(''),
                    et.replace(h, function (wt, $t, Et, At) {
                      gt.push(Et ? At.replace(p, '$1') : $t || wt)
                    }),
                    gt
                  )
                })
                function it(et) {
                  if (typeof et == 'string' || Te(et)) return et
                  var ft = et + ''
                  return ft == '0' && 1 / et == -1 / 0 ? '-0' : ft
                }
                function ct(et) {
                  if (et != null) {
                    try {
                      return H.call(et)
                    } catch {}
                    try {
                      return et + ''
                    } catch {}
                  }
                  return ''
                }
                var pt,
                  _t =
                    ((pt = function (et, ft, gt) {
                      U.call(et, gt) ? et[gt].push(ft) : (et[gt] = [ft])
                    }),
                    function (et, ft) {
                      var gt = Gt(et) ? P : Ct,
                        wt = {}
                      return gt(et, pt, be(ft), wt)
                    })
                function Vt(et, ft) {
                  if (typeof et != 'function' || (ft && typeof ft != 'function'))
                    throw new TypeError('Expected a function')
                  var gt = function () {
                    var wt = arguments,
                      $t = ft ? ft.apply(this, wt) : wt[0],
                      Et = gt.cache
                    if (Et.has($t)) return Et.get($t)
                    var At = et.apply(this, wt)
                    return ((gt.cache = Et.set($t, At)), At)
                  }
                  return ((gt.cache = new (Vt.Cache || vt)()), gt)
                }
                function Tt(et, ft) {
                  return et === ft || (et != et && ft != ft)
                }
                function te(et) {
                  return (
                    (function (ft) {
                      return Le(ft) && Ht(ft)
                    })(et) &&
                    U.call(et, 'callee') &&
                    (!N.call(et, 'callee') || K.call(et) == o)
                  )
                }
                Vt.Cache = vt
                var Gt = Array.isArray
                function Ht(et) {
                  return et != null && ee(et.length) && !ie(et)
                }
                function ie(et) {
                  var ft = de(et) ? K.call(et) : ''
                  return ft == '[object Function]' || ft == '[object GeneratorFunction]'
                }
                function ee(et) {
                  return typeof et == 'number' && et > -1 && et % 1 == 0 && et <= 9007199254740991
                }
                function de(et) {
                  var ft = typeof et
                  return !!et && (ft == 'object' || ft == 'function')
                }
                function Le(et) {
                  return !!et && typeof et == 'object'
                }
                function Te(et) {
                  return typeof et == 'symbol' || (Le(et) && K.call(et) == '[object Symbol]')
                }
                var Ge = O
                  ? (function (et) {
                      return function (ft) {
                        return et(ft)
                      }
                    })(O)
                  : function (et) {
                      return Le(et) && ee(et.length) && !!y[K.call(et)]
                    }
                function Xe(et) {
                  return Ht(et) ? Mt(et) : Ut(et)
                }
                function pn(et) {
                  return et
                }
                r.exports = _t
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {},
        ],
        444: [
          function (t, r, i) {
            var s = Object.prototype.toString
            r.exports = function (o) {
              return (
                o === !0 ||
                o === !1 ||
                ((function (a) {
                  return !!a && typeof a == 'object'
                })(o) &&
                  s.call(o) == '[object Boolean]')
              )
            }
          },
          {},
        ],
        445: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = '[object Arguments]',
                  a = '[object Map]',
                  l = '[object Object]',
                  c = '[object Set]',
                  u = /^\[object .+?Constructor\]$/,
                  f = /^(?:0|[1-9]\d*)$/,
                  d = {}
                ;((d['[object Float32Array]'] =
                  d['[object Float64Array]'] =
                  d['[object Int8Array]'] =
                  d['[object Int16Array]'] =
                  d['[object Int32Array]'] =
                  d['[object Uint8Array]'] =
                  d['[object Uint8ClampedArray]'] =
                  d['[object Uint16Array]'] =
                  d['[object Uint32Array]'] =
                    !0),
                  (d[o] =
                    d['[object Array]'] =
                    d['[object ArrayBuffer]'] =
                    d['[object Boolean]'] =
                    d['[object DataView]'] =
                    d['[object Date]'] =
                    d['[object Error]'] =
                    d['[object Function]'] =
                    d[a] =
                    d['[object Number]'] =
                    d[l] =
                    d['[object RegExp]'] =
                    d[c] =
                    d['[object String]'] =
                    d['[object WeakMap]'] =
                      !1))
                var h = typeof s == 'object' && s && s.Object === Object && s,
                  p = typeof self == 'object' && self && self.Object === Object && self,
                  g = h || p || Function('return this')(),
                  m = typeof i == 'object' && i && !i.nodeType && i,
                  y = m && typeof r == 'object' && r && !r.nodeType && r,
                  b = y && y.exports === m,
                  w = b && h.process,
                  C = (function () {
                    try {
                      return w && w.binding && w.binding('util')
                    } catch {}
                  })(),
                  T = C && C.isTypedArray
                function I(it, ct) {
                  for (var pt = -1, _t = it == null ? 0 : it.length; ++pt < _t; )
                    if (ct(it[pt], pt, it)) return !0
                  return !1
                }
                function B(it) {
                  var ct = -1,
                    pt = Array(it.size)
                  return (
                    it.forEach(function (_t, Vt) {
                      pt[++ct] = [Vt, _t]
                    }),
                    pt
                  )
                }
                function E(it) {
                  var ct = -1,
                    pt = Array(it.size)
                  return (
                    it.forEach(function (_t) {
                      pt[++ct] = _t
                    }),
                    pt
                  )
                }
                var O,
                  P,
                  $,
                  F = Array.prototype,
                  M = Function.prototype,
                  R = Object.prototype,
                  k = g['__core-js_shared__'],
                  v = M.toString,
                  x = R.hasOwnProperty,
                  _ = (O = /[^.]+$/.exec((k && k.keys && k.keys.IE_PROTO) || ''))
                    ? 'Symbol(src)_1.' + O
                    : '',
                  S = R.toString,
                  A = RegExp(
                    '^' +
                      v
                        .call(x)
                        .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                        .replace(
                          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                          '$1.*?',
                        ) +
                      '$',
                  ),
                  j = b ? g.Buffer : void 0,
                  L = g.Symbol,
                  H = g.Uint8Array,
                  U = R.propertyIsEnumerable,
                  K = F.splice,
                  z = L ? L.toStringTag : void 0,
                  q = Object.getOwnPropertySymbols,
                  D = j ? j.isBuffer : void 0,
                  N =
                    ((P = Object.keys),
                    ($ = Object),
                    function (it) {
                      return P($(it))
                    }),
                  V = ae(g, 'DataView'),
                  W = ae(g, 'Map'),
                  J = ae(g, 'Promise'),
                  G = ae(g, 'Set'),
                  Z = ae(g, 'WeakMap'),
                  rt = ae(Object, 'create'),
                  nt = Ut(V),
                  X = Ut(W),
                  Q = Ut(J),
                  tt = Ut(G),
                  st = Ut(Z),
                  ot = L ? L.prototype : void 0,
                  at = ot ? ot.valueOf : void 0
                function ht(it) {
                  var ct = -1,
                    pt = it == null ? 0 : it.length
                  for (this.clear(); ++ct < pt; ) {
                    var _t = it[ct]
                    this.set(_t[0], _t[1])
                  }
                }
                function dt(it) {
                  var ct = -1,
                    pt = it == null ? 0 : it.length
                  for (this.clear(); ++ct < pt; ) {
                    var _t = it[ct]
                    this.set(_t[0], _t[1])
                  }
                }
                function mt(it) {
                  var ct = -1,
                    pt = it == null ? 0 : it.length
                  for (this.clear(); ++ct < pt; ) {
                    var _t = it[ct]
                    this.set(_t[0], _t[1])
                  }
                }
                function bt(it) {
                  var ct = -1,
                    pt = it == null ? 0 : it.length
                  for (this.__data__ = new mt(); ++ct < pt; ) this.add(it[ct])
                }
                function yt(it) {
                  var ct = (this.__data__ = new dt(it))
                  this.size = ct.size
                }
                function vt(it, ct) {
                  var pt = ce(it),
                    _t = !pt && le(it),
                    Vt = !pt && !_t && Ft(it),
                    Tt = !pt && !_t && !Vt && me(it),
                    te = pt || _t || Vt || Tt,
                    Gt = te
                      ? (function (ee, de) {
                          for (var Le = -1, Te = Array(ee); ++Le < ee; ) Te[Le] = de(Le)
                          return Te
                        })(it.length, String)
                      : [],
                    Ht = Gt.length
                  for (var ie in it)
                    !x.call(it, ie) ||
                      (te &&
                        (ie == 'length' ||
                          (Vt && (ie == 'offset' || ie == 'parent')) ||
                          (Tt && (ie == 'buffer' || ie == 'byteLength' || ie == 'byteOffset')) ||
                          be(ie, Ht))) ||
                      Gt.push(ie)
                  return Gt
                }
                function Nt(it, ct) {
                  for (var pt = it.length; pt--; ) if (Lt(it[pt][0], ct)) return pt
                  return -1
                }
                function Dt(it) {
                  return it == null
                    ? it === void 0
                      ? '[object Undefined]'
                      : '[object Null]'
                    : z && z in Object(it)
                      ? (function (ct) {
                          var pt = x.call(ct, z),
                            _t = ct[z]
                          try {
                            ct[z] = void 0
                            var Vt = !0
                          } catch {}
                          var Tt = S.call(ct)
                          return (Vt && (pt ? (ct[z] = _t) : delete ct[z]), Tt)
                        })(it)
                      : (function (ct) {
                          return S.call(ct)
                        })(it)
                }
                function Mt(it) {
                  return Jt(it) && Dt(it) == o
                }
                function Ot(it, ct, pt, _t, Vt) {
                  return (
                    it === ct ||
                    (it == null || ct == null || (!Jt(it) && !Jt(ct))
                      ? it != it && ct != ct
                      : (function (Tt, te, Gt, Ht, ie, ee) {
                          var de = ce(Tt),
                            Le = ce(te),
                            Te = de ? '[object Array]' : zt(Tt),
                            Ge = Le ? '[object Array]' : zt(te),
                            Xe = (Te = Te == o ? l : Te) == l,
                            pn = (Ge = Ge == o ? l : Ge) == l,
                            et = Te == Ge
                          if (et && Ft(Tt)) {
                            if (!Ft(te)) return !1
                            ;((de = !0), (Xe = !1))
                          }
                          if (et && !Xe)
                            return (
                              ee || (ee = new yt()),
                              de || me(Tt)
                                ? Rt(Tt, te, Gt, Ht, ie, ee)
                                : (function (Et, At, ve, ue, he, Kt, Ce) {
                                    switch (ve) {
                                      case '[object DataView]':
                                        if (
                                          Et.byteLength != At.byteLength ||
                                          Et.byteOffset != At.byteOffset
                                        )
                                          return !1
                                        ;((Et = Et.buffer), (At = At.buffer))
                                      case '[object ArrayBuffer]':
                                        return !(
                                          Et.byteLength != At.byteLength ||
                                          !Kt(new H(Et), new H(At))
                                        )
                                      case '[object Boolean]':
                                      case '[object Date]':
                                      case '[object Number]':
                                        return Lt(+Et, +At)
                                      case '[object Error]':
                                        return Et.name == At.name && Et.message == At.message
                                      case '[object RegExp]':
                                      case '[object String]':
                                        return Et == At + ''
                                      case a:
                                        var Me = B
                                      case c:
                                        var Ae = 1 & ue
                                        if ((Me || (Me = E), Et.size != At.size && !Ae)) return !1
                                        var ze = Ce.get(Et)
                                        if (ze) return ze == At
                                        ;((ue |= 2), Ce.set(Et, At))
                                        var on = Rt(Me(Et), Me(At), ue, he, Kt, Ce)
                                        return (Ce.delete(Et), on)
                                      case '[object Symbol]':
                                        if (at) return at.call(Et) == at.call(At)
                                    }
                                    return !1
                                  })(Tt, te, Te, Gt, Ht, ie, ee)
                            )
                          if (!(1 & Gt)) {
                            var ft = Xe && x.call(Tt, '__wrapped__'),
                              gt = pn && x.call(te, '__wrapped__')
                            if (ft || gt) {
                              var wt = ft ? Tt.value() : Tt,
                                $t = gt ? te.value() : te
                              return (ee || (ee = new yt()), ie(wt, $t, Gt, Ht, ee))
                            }
                          }
                          return et
                            ? (ee || (ee = new yt()),
                              (function (Et, At, ve, ue, he, Kt) {
                                var Ce = 1 & ve,
                                  Me = It(Et),
                                  Ae = Me.length,
                                  ze = It(At).length
                                if (Ae != ze && !Ce) return !1
                                for (var on = Ae; on--; ) {
                                  var An = Me[on]
                                  if (!(Ce ? An in At : x.call(At, An))) return !1
                                }
                                var fr = Kt.get(Et)
                                if (fr && Kt.get(At)) return fr == At
                                var Ji = !0
                                ;(Kt.set(Et, At), Kt.set(At, Et))
                                for (var qs = Ce; ++on < Ae; ) {
                                  An = Me[on]
                                  var Ws = Et[An],
                                    Ks = At[An]
                                  if (ue)
                                    var Ee = Ce
                                      ? ue(Ks, Ws, An, At, Et, Kt)
                                      : ue(Ws, Ks, An, Et, At, Kt)
                                  if (!(Ee === void 0 ? Ws === Ks || he(Ws, Ks, ve, ue, Kt) : Ee)) {
                                    Ji = !1
                                    break
                                  }
                                  qs || (qs = An == 'constructor')
                                }
                                if (Ji && !qs) {
                                  var ke = Et.constructor,
                                    li = At.constructor
                                  ke == li ||
                                    !('constructor' in Et) ||
                                    !('constructor' in At) ||
                                    (typeof ke == 'function' &&
                                      ke instanceof ke &&
                                      typeof li == 'function' &&
                                      li instanceof li) ||
                                    (Ji = !1)
                                }
                                return (Kt.delete(Et), Kt.delete(At), Ji)
                              })(Tt, te, Gt, Ht, ie, ee))
                            : !1
                        })(it, ct, pt, _t, Ot, Vt))
                  )
                }
                function Ct(it) {
                  return (
                    !(
                      !qt(it) ||
                      (function (ct) {
                        return !!_ && _ in ct
                      })(it)
                    ) && (Qt(it) ? A : u).test(Ut(it))
                  )
                }
                function xt(it) {
                  if (
                    ((pt = (ct = it) && ct.constructor),
                    (_t = (typeof pt == 'function' && pt.prototype) || R),
                    ct !== _t)
                  )
                    return N(it)
                  var ct,
                    pt,
                    _t,
                    Vt = []
                  for (var Tt in Object(it)) x.call(it, Tt) && Tt != 'constructor' && Vt.push(Tt)
                  return Vt
                }
                function Rt(it, ct, pt, _t, Vt, Tt) {
                  var te = 1 & pt,
                    Gt = it.length,
                    Ht = ct.length
                  if (Gt != Ht && !(te && Ht > Gt)) return !1
                  var ie = Tt.get(it)
                  if (ie && Tt.get(ct)) return ie == ct
                  var ee = -1,
                    de = !0,
                    Le = 2 & pt ? new bt() : void 0
                  for (Tt.set(it, ct), Tt.set(ct, it); ++ee < Gt; ) {
                    var Te = it[ee],
                      Ge = ct[ee]
                    if (_t) var Xe = te ? _t(Ge, Te, ee, ct, it, Tt) : _t(Te, Ge, ee, it, ct, Tt)
                    if (Xe !== void 0) {
                      if (Xe) continue
                      de = !1
                      break
                    }
                    if (Le) {
                      if (
                        !I(ct, function (pn, et) {
                          if (((ft = et), !Le.has(ft) && (Te === pn || Vt(Te, pn, pt, _t, Tt))))
                            return Le.push(et)
                          var ft
                        })
                      ) {
                        de = !1
                        break
                      }
                    } else if (Te !== Ge && !Vt(Te, Ge, pt, _t, Tt)) {
                      de = !1
                      break
                    }
                  }
                  return (Tt.delete(it), Tt.delete(ct), de)
                }
                function It(it) {
                  return (function (ct, pt, _t) {
                    var Vt = pt(ct)
                    return ce(ct)
                      ? Vt
                      : (function (Tt, te) {
                          for (var Gt = -1, Ht = te.length, ie = Tt.length; ++Gt < Ht; )
                            Tt[ie + Gt] = te[Gt]
                          return Tt
                        })(Vt, _t(ct))
                  })(it, Wt, Se)
                }
                function Pt(it, ct) {
                  var pt,
                    _t,
                    Vt = it.__data__
                  return (
                    (_t = typeof (pt = ct)) == 'string' ||
                    _t == 'number' ||
                    _t == 'symbol' ||
                    _t == 'boolean'
                      ? pt !== '__proto__'
                      : pt === null
                  )
                    ? Vt[typeof ct == 'string' ? 'string' : 'hash']
                    : Vt.map
                }
                function ae(it, ct) {
                  var pt = (function (_t, Vt) {
                    return _t?.[Vt]
                  })(it, ct)
                  return Ct(pt) ? pt : void 0
                }
                ;((ht.prototype.clear = function () {
                  ;((this.__data__ = rt ? rt(null) : {}), (this.size = 0))
                }),
                  (ht.prototype.delete = function (it) {
                    var ct = this.has(it) && delete this.__data__[it]
                    return ((this.size -= ct ? 1 : 0), ct)
                  }),
                  (ht.prototype.get = function (it) {
                    var ct = this.__data__
                    if (rt) {
                      var pt = ct[it]
                      return pt === '__lodash_hash_undefined__' ? void 0 : pt
                    }
                    return x.call(ct, it) ? ct[it] : void 0
                  }),
                  (ht.prototype.has = function (it) {
                    var ct = this.__data__
                    return rt ? ct[it] !== void 0 : x.call(ct, it)
                  }),
                  (ht.prototype.set = function (it, ct) {
                    var pt = this.__data__
                    return (
                      (this.size += this.has(it) ? 0 : 1),
                      (pt[it] = rt && ct === void 0 ? '__lodash_hash_undefined__' : ct),
                      this
                    )
                  }),
                  (dt.prototype.clear = function () {
                    ;((this.__data__ = []), (this.size = 0))
                  }),
                  (dt.prototype.delete = function (it) {
                    var ct = this.__data__,
                      pt = Nt(ct, it)
                    return (
                      !(pt < 0) &&
                      (pt == ct.length - 1 ? ct.pop() : K.call(ct, pt, 1), --this.size, !0)
                    )
                  }),
                  (dt.prototype.get = function (it) {
                    var ct = this.__data__,
                      pt = Nt(ct, it)
                    return pt < 0 ? void 0 : ct[pt][1]
                  }),
                  (dt.prototype.has = function (it) {
                    return Nt(this.__data__, it) > -1
                  }),
                  (dt.prototype.set = function (it, ct) {
                    var pt = this.__data__,
                      _t = Nt(pt, it)
                    return (_t < 0 ? (++this.size, pt.push([it, ct])) : (pt[_t][1] = ct), this)
                  }),
                  (mt.prototype.clear = function () {
                    ;((this.size = 0),
                      (this.__data__ = { hash: new ht(), map: new (W || dt)(), string: new ht() }))
                  }),
                  (mt.prototype.delete = function (it) {
                    var ct = Pt(this, it).delete(it)
                    return ((this.size -= ct ? 1 : 0), ct)
                  }),
                  (mt.prototype.get = function (it) {
                    return Pt(this, it).get(it)
                  }),
                  (mt.prototype.has = function (it) {
                    return Pt(this, it).has(it)
                  }),
                  (mt.prototype.set = function (it, ct) {
                    var pt = Pt(this, it),
                      _t = pt.size
                    return (pt.set(it, ct), (this.size += pt.size == _t ? 0 : 1), this)
                  }),
                  (bt.prototype.add = bt.prototype.push =
                    function (it) {
                      return (this.__data__.set(it, '__lodash_hash_undefined__'), this)
                    }),
                  (bt.prototype.has = function (it) {
                    return this.__data__.has(it)
                  }),
                  (yt.prototype.clear = function () {
                    ;((this.__data__ = new dt()), (this.size = 0))
                  }),
                  (yt.prototype.delete = function (it) {
                    var ct = this.__data__,
                      pt = ct.delete(it)
                    return ((this.size = ct.size), pt)
                  }),
                  (yt.prototype.get = function (it) {
                    return this.__data__.get(it)
                  }),
                  (yt.prototype.has = function (it) {
                    return this.__data__.has(it)
                  }),
                  (yt.prototype.set = function (it, ct) {
                    var pt = this.__data__
                    if (pt instanceof dt) {
                      var _t = pt.__data__
                      if (!W || _t.length < 199)
                        return (_t.push([it, ct]), (this.size = ++pt.size), this)
                      pt = this.__data__ = new mt(_t)
                    }
                    return (pt.set(it, ct), (this.size = pt.size), this)
                  }))
                var Se = q
                    ? function (it) {
                        return it == null
                          ? []
                          : ((it = Object(it)),
                            (function (ct, pt) {
                              for (
                                var _t = -1, Vt = ct == null ? 0 : ct.length, Tt = 0, te = [];
                                ++_t < Vt;

                              ) {
                                var Gt = ct[_t]
                                pt(Gt, _t, ct) && (te[Tt++] = Gt)
                              }
                              return te
                            })(q(it), function (ct) {
                              return U.call(it, ct)
                            }))
                      }
                    : function () {
                        return []
                      },
                  zt = Dt
                function be(it, ct) {
                  return (
                    !!(ct = ct ?? 9007199254740991) &&
                    (typeof it == 'number' || f.test(it)) &&
                    it > -1 &&
                    it % 1 == 0 &&
                    it < ct
                  )
                }
                function Ut(it) {
                  if (it != null) {
                    try {
                      return v.call(it)
                    } catch {}
                    try {
                      return it + ''
                    } catch {}
                  }
                  return ''
                }
                function Lt(it, ct) {
                  return it === ct || (it != it && ct != ct)
                }
                ;((V && zt(new V(new ArrayBuffer(1))) != '[object DataView]') ||
                  (W && zt(new W()) != a) ||
                  (J && zt(J.resolve()) != '[object Promise]') ||
                  (G && zt(new G()) != c) ||
                  (Z && zt(new Z()) != '[object WeakMap]')) &&
                  (zt = function (it) {
                    var ct = Dt(it),
                      pt = ct == l ? it.constructor : void 0,
                      _t = pt ? Ut(pt) : ''
                    if (_t)
                      switch (_t) {
                        case nt:
                          return '[object DataView]'
                        case X:
                          return a
                        case Q:
                          return '[object Promise]'
                        case tt:
                          return c
                        case st:
                          return '[object WeakMap]'
                      }
                    return ct
                  })
                var le = Mt(
                    (function () {
                      return arguments
                    })(),
                  )
                    ? Mt
                    : function (it) {
                        return Jt(it) && x.call(it, 'callee') && !U.call(it, 'callee')
                      },
                  ce = Array.isArray,
                  Ft =
                    D ||
                    function () {
                      return !1
                    }
                function Qt(it) {
                  if (!qt(it)) return !1
                  var ct = Dt(it)
                  return (
                    ct == '[object Function]' ||
                    ct == '[object GeneratorFunction]' ||
                    ct == '[object AsyncFunction]' ||
                    ct == '[object Proxy]'
                  )
                }
                function fe(it) {
                  return typeof it == 'number' && it > -1 && it % 1 == 0 && it <= 9007199254740991
                }
                function qt(it) {
                  var ct = typeof it
                  return it != null && (ct == 'object' || ct == 'function')
                }
                function Jt(it) {
                  return it != null && typeof it == 'object'
                }
                var me = T
                  ? (function (it) {
                      return function (ct) {
                        return it(ct)
                      }
                    })(T)
                  : function (it) {
                      return Jt(it) && fe(it.length) && !!d[Dt(it)]
                    }
                function Wt(it) {
                  return (ct = it) != null && fe(ct.length) && !Qt(ct) ? vt(it) : xt(it)
                  var ct
                }
                r.exports = function (it, ct) {
                  return Ot(it, ct)
                }
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {},
        ],
        446: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = typeof s == 'object' && s && s.Object === Object && s,
                  a = typeof self == 'object' && self && self.Object === Object && self,
                  l = o || a || Function('return this')(),
                  c = Object.prototype,
                  u = c.hasOwnProperty,
                  f = c.toString,
                  d = l.Symbol,
                  h = d ? d.toStringTag : void 0
                function p(g) {
                  return g == null
                    ? g === void 0
                      ? '[object Undefined]'
                      : '[object Null]'
                    : h && h in Object(g)
                      ? (function (m) {
                          var y = u.call(m, h),
                            b = m[h]
                          try {
                            m[h] = void 0
                            var w = !0
                          } catch {}
                          var C = f.call(m)
                          return (w && (y ? (m[h] = b) : delete m[h]), C)
                        })(g)
                      : (function (m) {
                          return f.call(m)
                        })(g)
                }
                r.exports = function (g) {
                  if (
                    !(function (y) {
                      var b = typeof y
                      return y != null && (b == 'object' || b == 'function')
                    })(g)
                  )
                    return !1
                  var m = p(g)
                  return (
                    m == '[object Function]' ||
                    m == '[object GeneratorFunction]' ||
                    m == '[object AsyncFunction]' ||
                    m == '[object Proxy]'
                  )
                }
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {},
        ],
        447: [
          function (t, r, i) {
            r.exports = function (s) {
              return s == null
            }
          },
          {},
        ],
        448: [
          function (t, r, i) {
            r.exports = function (s) {
              return s === void 0
            }
          },
          {},
        ],
        449: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o = /^\[object .+?Constructor\]$/,
                  a = typeof s == 'object' && s && s.Object === Object && s,
                  l = typeof self == 'object' && self && self.Object === Object && self,
                  c = a || l || Function('return this')()
                function u(L, H) {
                  return (
                    !!(L && L.length) &&
                    (function (U, K, z) {
                      if (K != K)
                        return (function (N, V, W, J) {
                          for (var G = N.length, Z = W + -1; ++Z < G; ) if (V(N[Z], Z, N)) return Z
                          return -1
                        })(U, f, z)
                      for (var q = z - 1, D = U.length; ++q < D; ) if (U[q] === K) return q
                      return -1
                    })(L, H, 0) > -1
                  )
                }
                function f(L) {
                  return L != L
                }
                function d(L, H) {
                  return L.has(H)
                }
                function h(L) {
                  var H = -1,
                    U = Array(L.size)
                  return (
                    L.forEach(function (K) {
                      U[++H] = K
                    }),
                    U
                  )
                }
                var p,
                  g = Array.prototype,
                  m = Function.prototype,
                  y = Object.prototype,
                  b = c['__core-js_shared__'],
                  w = (p = /[^.]+$/.exec((b && b.keys && b.keys.IE_PROTO) || ''))
                    ? 'Symbol(src)_1.' + p
                    : '',
                  C = m.toString,
                  T = y.hasOwnProperty,
                  I = y.toString,
                  B = RegExp(
                    '^' +
                      C.call(T)
                        .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                        .replace(
                          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                          '$1.*?',
                        ) +
                      '$',
                  ),
                  E = g.splice,
                  O = A(c, 'Map'),
                  P = A(c, 'Set'),
                  $ = A(Object, 'create')
                function F(L) {
                  var H = -1,
                    U = L ? L.length : 0
                  for (this.clear(); ++H < U; ) {
                    var K = L[H]
                    this.set(K[0], K[1])
                  }
                }
                function M(L) {
                  var H = -1,
                    U = L ? L.length : 0
                  for (this.clear(); ++H < U; ) {
                    var K = L[H]
                    this.set(K[0], K[1])
                  }
                }
                function R(L) {
                  var H = -1,
                    U = L ? L.length : 0
                  for (this.clear(); ++H < U; ) {
                    var K = L[H]
                    this.set(K[0], K[1])
                  }
                }
                function k(L) {
                  var H = -1,
                    U = L ? L.length : 0
                  for (this.__data__ = new R(); ++H < U; ) this.add(L[H])
                }
                function v(L, H) {
                  for (var U, K, z = L.length; z--; )
                    if ((U = L[z][0]) === (K = H) || (U != U && K != K)) return z
                  return -1
                }
                function x(L) {
                  return (
                    !(!j(L) || ((H = L), w && w in H)) &&
                    ((function (U) {
                      var K = j(U) ? I.call(U) : ''
                      return K == '[object Function]' || K == '[object GeneratorFunction]'
                    })(L) ||
                    (function (U) {
                      var K = !1
                      if (U != null && typeof U.toString != 'function')
                        try {
                          K = !!(U + '')
                        } catch {}
                      return K
                    })(L)
                      ? B
                      : o
                    ).test(
                      (function (U) {
                        if (U != null) {
                          try {
                            return C.call(U)
                          } catch {}
                          try {
                            return U + ''
                          } catch {}
                        }
                        return ''
                      })(L),
                    )
                  )
                  var H
                }
                ;((F.prototype.clear = function () {
                  this.__data__ = $ ? $(null) : {}
                }),
                  (F.prototype.delete = function (L) {
                    return this.has(L) && delete this.__data__[L]
                  }),
                  (F.prototype.get = function (L) {
                    var H = this.__data__
                    if ($) {
                      var U = H[L]
                      return U === '__lodash_hash_undefined__' ? void 0 : U
                    }
                    return T.call(H, L) ? H[L] : void 0
                  }),
                  (F.prototype.has = function (L) {
                    var H = this.__data__
                    return $ ? H[L] !== void 0 : T.call(H, L)
                  }),
                  (F.prototype.set = function (L, H) {
                    return (
                      (this.__data__[L] = $ && H === void 0 ? '__lodash_hash_undefined__' : H),
                      this
                    )
                  }),
                  (M.prototype.clear = function () {
                    this.__data__ = []
                  }),
                  (M.prototype.delete = function (L) {
                    var H = this.__data__,
                      U = v(H, L)
                    return !(U < 0) && (U == H.length - 1 ? H.pop() : E.call(H, U, 1), !0)
                  }),
                  (M.prototype.get = function (L) {
                    var H = this.__data__,
                      U = v(H, L)
                    return U < 0 ? void 0 : H[U][1]
                  }),
                  (M.prototype.has = function (L) {
                    return v(this.__data__, L) > -1
                  }),
                  (M.prototype.set = function (L, H) {
                    var U = this.__data__,
                      K = v(U, L)
                    return (K < 0 ? U.push([L, H]) : (U[K][1] = H), this)
                  }),
                  (R.prototype.clear = function () {
                    this.__data__ = { hash: new F(), map: new (O || M)(), string: new F() }
                  }),
                  (R.prototype.delete = function (L) {
                    return S(this, L).delete(L)
                  }),
                  (R.prototype.get = function (L) {
                    return S(this, L).get(L)
                  }),
                  (R.prototype.has = function (L) {
                    return S(this, L).has(L)
                  }),
                  (R.prototype.set = function (L, H) {
                    return (S(this, L).set(L, H), this)
                  }),
                  (k.prototype.add = k.prototype.push =
                    function (L) {
                      return (this.__data__.set(L, '__lodash_hash_undefined__'), this)
                    }),
                  (k.prototype.has = function (L) {
                    return this.__data__.has(L)
                  }))
                var _ =
                  P && 1 / h(new P([, -0]))[1] == 1 / 0
                    ? function (L) {
                        return new P(L)
                      }
                    : function () {}
                function S(L, H) {
                  var U,
                    K,
                    z = L.__data__
                  return (
                    (K = typeof (U = H)) == 'string' ||
                    K == 'number' ||
                    K == 'symbol' ||
                    K == 'boolean'
                      ? U !== '__proto__'
                      : U === null
                  )
                    ? z[typeof H == 'string' ? 'string' : 'hash']
                    : z.map
                }
                function A(L, H) {
                  var U = (function (K, z) {
                    return K?.[z]
                  })(L, H)
                  return x(U) ? U : void 0
                }
                function j(L) {
                  var H = typeof L
                  return !!L && (H == 'object' || H == 'function')
                }
                r.exports = function (L) {
                  return L && L.length
                    ? (function (H, U, K) {
                        var z = -1,
                          q = u,
                          D = H.length,
                          N = !0,
                          V = [],
                          W = V
                        if (D >= 200) {
                          var J = _(H)
                          if (J) return h(J)
                          ;((N = !1), (q = d), (W = new k()))
                        } else W = V
                        t: for (; ++z < D; ) {
                          var G = H[z],
                            Z = G
                          if (((G = G !== 0 ? G : 0), N && Z == Z)) {
                            for (var rt = W.length; rt--; ) if (W[rt] === Z) continue t
                            V.push(G)
                          } else q(W, Z, K) || (W !== V && W.push(Z), V.push(G))
                        }
                        return V
                      })(L)
                    : []
                }
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {},
        ],
        450: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('hash-base'),
              a = t('safe-buffer').Buffer,
              l = new Array(16)
            function c() {
              ;(o.call(this, 64),
                (this._a = 1732584193),
                (this._b = 4023233417),
                (this._c = 2562383102),
                (this._d = 271733878))
            }
            function u(g, m) {
              return (g << m) | (g >>> (32 - m))
            }
            function f(g, m, y, b, w, C, T) {
              return (u((g + ((m & y) | (~m & b)) + w + C) | 0, T) + m) | 0
            }
            function d(g, m, y, b, w, C, T) {
              return (u((g + ((m & b) | (y & ~b)) + w + C) | 0, T) + m) | 0
            }
            function h(g, m, y, b, w, C, T) {
              return (u((g + (m ^ y ^ b) + w + C) | 0, T) + m) | 0
            }
            function p(g, m, y, b, w, C, T) {
              return (u((g + (y ^ (m | ~b)) + w + C) | 0, T) + m) | 0
            }
            ;(s(c, o),
              (c.prototype._update = function () {
                for (var g = l, m = 0; m < 16; ++m) g[m] = this._block.readInt32LE(4 * m)
                var y = this._a,
                  b = this._b,
                  w = this._c,
                  C = this._d
                ;((y = f(y, b, w, C, g[0], 3614090360, 7)),
                  (C = f(C, y, b, w, g[1], 3905402710, 12)),
                  (w = f(w, C, y, b, g[2], 606105819, 17)),
                  (b = f(b, w, C, y, g[3], 3250441966, 22)),
                  (y = f(y, b, w, C, g[4], 4118548399, 7)),
                  (C = f(C, y, b, w, g[5], 1200080426, 12)),
                  (w = f(w, C, y, b, g[6], 2821735955, 17)),
                  (b = f(b, w, C, y, g[7], 4249261313, 22)),
                  (y = f(y, b, w, C, g[8], 1770035416, 7)),
                  (C = f(C, y, b, w, g[9], 2336552879, 12)),
                  (w = f(w, C, y, b, g[10], 4294925233, 17)),
                  (b = f(b, w, C, y, g[11], 2304563134, 22)),
                  (y = f(y, b, w, C, g[12], 1804603682, 7)),
                  (C = f(C, y, b, w, g[13], 4254626195, 12)),
                  (w = f(w, C, y, b, g[14], 2792965006, 17)),
                  (y = d(y, (b = f(b, w, C, y, g[15], 1236535329, 22)), w, C, g[1], 4129170786, 5)),
                  (C = d(C, y, b, w, g[6], 3225465664, 9)),
                  (w = d(w, C, y, b, g[11], 643717713, 14)),
                  (b = d(b, w, C, y, g[0], 3921069994, 20)),
                  (y = d(y, b, w, C, g[5], 3593408605, 5)),
                  (C = d(C, y, b, w, g[10], 38016083, 9)),
                  (w = d(w, C, y, b, g[15], 3634488961, 14)),
                  (b = d(b, w, C, y, g[4], 3889429448, 20)),
                  (y = d(y, b, w, C, g[9], 568446438, 5)),
                  (C = d(C, y, b, w, g[14], 3275163606, 9)),
                  (w = d(w, C, y, b, g[3], 4107603335, 14)),
                  (b = d(b, w, C, y, g[8], 1163531501, 20)),
                  (y = d(y, b, w, C, g[13], 2850285829, 5)),
                  (C = d(C, y, b, w, g[2], 4243563512, 9)),
                  (w = d(w, C, y, b, g[7], 1735328473, 14)),
                  (y = h(y, (b = d(b, w, C, y, g[12], 2368359562, 20)), w, C, g[5], 4294588738, 4)),
                  (C = h(C, y, b, w, g[8], 2272392833, 11)),
                  (w = h(w, C, y, b, g[11], 1839030562, 16)),
                  (b = h(b, w, C, y, g[14], 4259657740, 23)),
                  (y = h(y, b, w, C, g[1], 2763975236, 4)),
                  (C = h(C, y, b, w, g[4], 1272893353, 11)),
                  (w = h(w, C, y, b, g[7], 4139469664, 16)),
                  (b = h(b, w, C, y, g[10], 3200236656, 23)),
                  (y = h(y, b, w, C, g[13], 681279174, 4)),
                  (C = h(C, y, b, w, g[0], 3936430074, 11)),
                  (w = h(w, C, y, b, g[3], 3572445317, 16)),
                  (b = h(b, w, C, y, g[6], 76029189, 23)),
                  (y = h(y, b, w, C, g[9], 3654602809, 4)),
                  (C = h(C, y, b, w, g[12], 3873151461, 11)),
                  (w = h(w, C, y, b, g[15], 530742520, 16)),
                  (y = p(y, (b = h(b, w, C, y, g[2], 3299628645, 23)), w, C, g[0], 4096336452, 6)),
                  (C = p(C, y, b, w, g[7], 1126891415, 10)),
                  (w = p(w, C, y, b, g[14], 2878612391, 15)),
                  (b = p(b, w, C, y, g[5], 4237533241, 21)),
                  (y = p(y, b, w, C, g[12], 1700485571, 6)),
                  (C = p(C, y, b, w, g[3], 2399980690, 10)),
                  (w = p(w, C, y, b, g[10], 4293915773, 15)),
                  (b = p(b, w, C, y, g[1], 2240044497, 21)),
                  (y = p(y, b, w, C, g[8], 1873313359, 6)),
                  (C = p(C, y, b, w, g[15], 4264355552, 10)),
                  (w = p(w, C, y, b, g[6], 2734768916, 15)),
                  (b = p(b, w, C, y, g[13], 1309151649, 21)),
                  (y = p(y, b, w, C, g[4], 4149444226, 6)),
                  (C = p(C, y, b, w, g[11], 3174756917, 10)),
                  (w = p(w, C, y, b, g[2], 718787259, 15)),
                  (b = p(b, w, C, y, g[9], 3951481745, 21)),
                  (this._a = (this._a + y) | 0),
                  (this._b = (this._b + b) | 0),
                  (this._c = (this._c + w) | 0),
                  (this._d = (this._d + C) | 0))
              }),
              (c.prototype._digest = function () {
                ;((this._block[this._blockOffset++] = 128),
                  this._blockOffset > 56 &&
                    (this._block.fill(0, this._blockOffset, 64),
                    this._update(),
                    (this._blockOffset = 0)),
                  this._block.fill(0, this._blockOffset, 56),
                  this._block.writeUInt32LE(this._length[0], 56),
                  this._block.writeUInt32LE(this._length[1], 60),
                  this._update())
                var g = a.allocUnsafe(16)
                return (
                  g.writeInt32LE(this._a, 0),
                  g.writeInt32LE(this._b, 4),
                  g.writeInt32LE(this._c, 8),
                  g.writeInt32LE(this._d, 12),
                  g
                )
              }),
              (r.exports = c))
          },
          { 'hash-base': 425, inherits: 440, 'safe-buffer': 494 },
        ],
        451: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('brorand')
            function a(l) {
              this.rand = l || new o.Rand()
            }
            ;((r.exports = a),
              (a.create = function (l) {
                return new a(l)
              }),
              (a.prototype._randbelow = function (l) {
                var c = l.bitLength(),
                  u = Math.ceil(c / 8)
                do var f = new s(this.rand.generate(u))
                while (f.cmp(l) >= 0)
                return f
              }),
              (a.prototype._randrange = function (l, c) {
                var u = c.sub(l)
                return l.add(this._randbelow(u))
              }),
              (a.prototype.test = function (l, c, u) {
                var f = l.bitLength(),
                  d = s.mont(l),
                  h = new s(1).toRed(d)
                c || (c = Math.max(1, (f / 48) | 0))
                for (var p = l.subn(1), g = 0; !p.testn(g); g++);
                for (var m = l.shrn(g), y = p.toRed(d); c > 0; c--) {
                  var b = this._randrange(new s(2), p)
                  u && u(b)
                  var w = b.toRed(d).redPow(m)
                  if (w.cmp(h) !== 0 && w.cmp(y) !== 0) {
                    for (var C = 1; C < g; C++) {
                      if ((w = w.redSqr()).cmp(h) === 0) return !1
                      if (w.cmp(y) === 0) break
                    }
                    if (C === g) return !1
                  }
                }
                return !0
              }),
              (a.prototype.getDivisor = function (l, c) {
                var u = l.bitLength(),
                  f = s.mont(l),
                  d = new s(1).toRed(f)
                c || (c = Math.max(1, (u / 48) | 0))
                for (var h = l.subn(1), p = 0; !h.testn(p); p++);
                for (var g = l.shrn(p), m = h.toRed(f); c > 0; c--) {
                  var y = this._randrange(new s(2), h),
                    b = l.gcd(y)
                  if (b.cmpn(1) !== 0) return b
                  var w = y.toRed(f).redPow(g)
                  if (w.cmp(d) !== 0 && w.cmp(m) !== 0) {
                    for (var C = 1; C < p; C++) {
                      if ((w = w.redSqr()).cmp(d) === 0) return w.fromRed().subn(1).gcd(l)
                      if (w.cmp(m) === 0) break
                    }
                    if (C === p) return (w = w.redSqr()).fromRed().subn(1).gcd(l)
                  }
                }
                return !1
              }))
          },
          { 'bn.js': 452, brorand: 187 },
        ],
        452: [
          function (t, r, i) {
            arguments[4][184][0].apply(i, arguments)
          },
          { buffer: 188, dup: 184 },
        ],
        453: [
          function (t, r, i) {
            function s(o, a) {
              if (!o) throw new Error(a || 'Assertion failed')
            }
            ;((r.exports = s),
              (s.equal = function (o, a, l) {
                if (o != a) throw new Error(l || 'Assertion failed: ' + o + ' != ' + a)
              }))
          },
          {},
        ],
        454: [
          function (t, r, i) {
            var s = i
            function o(l) {
              return l.length === 1 ? '0' + l : l
            }
            function a(l) {
              for (var c = '', u = 0; u < l.length; u++) c += o(l[u].toString(16))
              return c
            }
            ;((s.toArray = function (l, c) {
              if (Array.isArray(l)) return l.slice()
              if (!l) return []
              var u = []
              if (typeof l != 'string') {
                for (var f = 0; f < l.length; f++) u[f] = 0 | l[f]
                return u
              }
              if (c === 'hex')
                for (
                  (l = l.replace(/[^a-z0-9]+/gi, '')).length % 2 != 0 && (l = '0' + l), f = 0;
                  f < l.length;
                  f += 2
                )
                  u.push(parseInt(l[f] + l[f + 1], 16))
              else
                for (f = 0; f < l.length; f++) {
                  var d = l.charCodeAt(f),
                    h = d >> 8,
                    p = 255 & d
                  h ? u.push(h, p) : u.push(p)
                }
              return u
            }),
              (s.zero2 = o),
              (s.toHex = a),
              (s.encode = function (l, c) {
                return c === 'hex' ? a(l) : l
              }))
          },
          {},
        ],
        455: [
          function (t, r, i) {
            r.exports = {
              '2.16.840.1.101.3.4.1.1': 'aes-128-ecb',
              '2.16.840.1.101.3.4.1.2': 'aes-128-cbc',
              '2.16.840.1.101.3.4.1.3': 'aes-128-ofb',
              '2.16.840.1.101.3.4.1.4': 'aes-128-cfb',
              '2.16.840.1.101.3.4.1.21': 'aes-192-ecb',
              '2.16.840.1.101.3.4.1.22': 'aes-192-cbc',
              '2.16.840.1.101.3.4.1.23': 'aes-192-ofb',
              '2.16.840.1.101.3.4.1.24': 'aes-192-cfb',
              '2.16.840.1.101.3.4.1.41': 'aes-256-ecb',
              '2.16.840.1.101.3.4.1.42': 'aes-256-cbc',
              '2.16.840.1.101.3.4.1.43': 'aes-256-ofb',
              '2.16.840.1.101.3.4.1.44': 'aes-256-cfb',
            }
          },
          {},
        ],
        456: [
          function (t, r, i) {
            var s = t('asn1.js')
            i.certificate = t('./certificate')
            var o = s.define('RSAPrivateKey', function () {
              this.seq().obj(
                this.key('version').int(),
                this.key('modulus').int(),
                this.key('publicExponent').int(),
                this.key('privateExponent').int(),
                this.key('prime1').int(),
                this.key('prime2').int(),
                this.key('exponent1').int(),
                this.key('exponent2').int(),
                this.key('coefficient').int(),
              )
            })
            i.RSAPrivateKey = o
            var a = s.define('RSAPublicKey', function () {
              this.seq().obj(this.key('modulus').int(), this.key('publicExponent').int())
            })
            i.RSAPublicKey = a
            var l = s.define('SubjectPublicKeyInfo', function () {
              this.seq().obj(this.key('algorithm').use(c), this.key('subjectPublicKey').bitstr())
            })
            i.PublicKey = l
            var c = s.define('AlgorithmIdentifier', function () {
                this.seq().obj(
                  this.key('algorithm').objid(),
                  this.key('none').null_().optional(),
                  this.key('curve').objid().optional(),
                  this.key('params')
                    .seq()
                    .obj(this.key('p').int(), this.key('q').int(), this.key('g').int())
                    .optional(),
                )
              }),
              u = s.define('PrivateKeyInfo', function () {
                this.seq().obj(
                  this.key('version').int(),
                  this.key('algorithm').use(c),
                  this.key('subjectPrivateKey').octstr(),
                )
              })
            i.PrivateKey = u
            var f = s.define('EncryptedPrivateKeyInfo', function () {
              this.seq().obj(
                this.key('algorithm')
                  .seq()
                  .obj(
                    this.key('id').objid(),
                    this.key('decrypt')
                      .seq()
                      .obj(
                        this.key('kde')
                          .seq()
                          .obj(
                            this.key('id').objid(),
                            this.key('kdeparams')
                              .seq()
                              .obj(this.key('salt').octstr(), this.key('iters').int()),
                          ),
                        this.key('cipher')
                          .seq()
                          .obj(this.key('algo').objid(), this.key('iv').octstr()),
                      ),
                  ),
                this.key('subjectPrivateKey').octstr(),
              )
            })
            i.EncryptedPrivateKey = f
            var d = s.define('DSAPrivateKey', function () {
              this.seq().obj(
                this.key('version').int(),
                this.key('p').int(),
                this.key('q').int(),
                this.key('g').int(),
                this.key('pub_key').int(),
                this.key('priv_key').int(),
              )
            })
            ;((i.DSAPrivateKey = d),
              (i.DSAparam = s.define('DSAparam', function () {
                this.int()
              })))
            var h = s.define('ECPrivateKey', function () {
              this.seq().obj(
                this.key('version').int(),
                this.key('privateKey').octstr(),
                this.key('parameters').optional().explicit(0).use(p),
                this.key('publicKey').optional().explicit(1).bitstr(),
              )
            })
            i.ECPrivateKey = h
            var p = s.define('ECParameters', function () {
              this.choice({ namedCurve: this.objid() })
            })
            i.signature = s.define('signature', function () {
              this.seq().obj(this.key('r').int(), this.key('s').int())
            })
          },
          { './certificate': 457, 'asn1.js': 170 },
        ],
        457: [
          function (t, r, i) {
            var s = t('asn1.js'),
              o = s.define('Time', function () {
                this.choice({ utcTime: this.utctime(), generalTime: this.gentime() })
              }),
              a = s.define('AttributeTypeValue', function () {
                this.seq().obj(this.key('type').objid(), this.key('value').any())
              }),
              l = s.define('AlgorithmIdentifier', function () {
                this.seq().obj(
                  this.key('algorithm').objid(),
                  this.key('parameters').optional(),
                  this.key('curve').objid().optional(),
                )
              }),
              c = s.define('SubjectPublicKeyInfo', function () {
                this.seq().obj(this.key('algorithm').use(l), this.key('subjectPublicKey').bitstr())
              }),
              u = s.define('RelativeDistinguishedName', function () {
                this.setof(a)
              }),
              f = s.define('RDNSequence', function () {
                this.seqof(u)
              }),
              d = s.define('Name', function () {
                this.choice({ rdnSequence: this.use(f) })
              }),
              h = s.define('Validity', function () {
                this.seq().obj(this.key('notBefore').use(o), this.key('notAfter').use(o))
              }),
              p = s.define('Extension', function () {
                this.seq().obj(
                  this.key('extnID').objid(),
                  this.key('critical').bool().def(!1),
                  this.key('extnValue').octstr(),
                )
              }),
              g = s.define('TBSCertificate', function () {
                this.seq().obj(
                  this.key('version').explicit(0).int().optional(),
                  this.key('serialNumber').int(),
                  this.key('signature').use(l),
                  this.key('issuer').use(d),
                  this.key('validity').use(h),
                  this.key('subject').use(d),
                  this.key('subjectPublicKeyInfo').use(c),
                  this.key('issuerUniqueID').implicit(1).bitstr().optional(),
                  this.key('subjectUniqueID').implicit(2).bitstr().optional(),
                  this.key('extensions').explicit(3).seqof(p).optional(),
                )
              }),
              m = s.define('X509Certificate', function () {
                this.seq().obj(
                  this.key('tbsCertificate').use(g),
                  this.key('signatureAlgorithm').use(l),
                  this.key('signatureValue').bitstr(),
                )
              })
            r.exports = m
          },
          { 'asn1.js': 170 },
        ],
        458: [
          function (t, r, i) {
            var s =
                /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m,
              o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
              a = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m,
              l = t('evp_bytestokey'),
              c = t('browserify-aes'),
              u = t('safe-buffer').Buffer
            r.exports = function (f, d) {
              var h,
                p = f.toString(),
                g = p.match(s)
              if (g) {
                var m = 'aes' + g[1],
                  y = u.from(g[2], 'hex'),
                  b = u.from(g[3].replace(/[\r\n]/g, ''), 'base64'),
                  w = l(d, y.slice(0, 8), parseInt(g[1], 10)).key,
                  C = [],
                  T = c.createDecipheriv(m, w, y)
                ;(C.push(T.update(b)), C.push(T.final()), (h = u.concat(C)))
              } else {
                var I = p.match(a)
                h = u.from(I[2].replace(/[\r\n]/g, ''), 'base64')
              }
              return { tag: p.match(o)[1], data: h }
            }
          },
          { 'browserify-aes': 191, evp_bytestokey: 423, 'safe-buffer': 494 },
        ],
        459: [
          function (t, r, i) {
            var s = t('./asn1'),
              o = t('./aesid.json'),
              a = t('./fixProc'),
              l = t('browserify-aes'),
              c = t('pbkdf2'),
              u = t('safe-buffer').Buffer
            function f(d) {
              var h
              ;(typeof d != 'object' || u.isBuffer(d) || ((h = d.passphrase), (d = d.key)),
                typeof d == 'string' && (d = u.from(d)))
              var p,
                g,
                m = a(d, h),
                y = m.tag,
                b = m.data
              switch (y) {
                case 'CERTIFICATE':
                  g = s.certificate.decode(b, 'der').tbsCertificate.subjectPublicKeyInfo
                case 'PUBLIC KEY':
                  switch (
                    (g || (g = s.PublicKey.decode(b, 'der')), (p = g.algorithm.algorithm.join('.')))
                  ) {
                    case '1.2.840.113549.1.1.1':
                      return s.RSAPublicKey.decode(g.subjectPublicKey.data, 'der')
                    case '1.2.840.10045.2.1':
                      return ((g.subjectPrivateKey = g.subjectPublicKey), { type: 'ec', data: g })
                    case '1.2.840.10040.4.1':
                      return (
                        (g.algorithm.params.pub_key = s.DSAparam.decode(
                          g.subjectPublicKey.data,
                          'der',
                        )),
                        { type: 'dsa', data: g.algorithm.params }
                      )
                    default:
                      throw new Error('unknown key id ' + p)
                  }
                case 'ENCRYPTED PRIVATE KEY':
                  b = (function (w, C) {
                    var T = w.algorithm.decrypt.kde.kdeparams.salt,
                      I = parseInt(w.algorithm.decrypt.kde.kdeparams.iters.toString(), 10),
                      B = o[w.algorithm.decrypt.cipher.algo.join('.')],
                      E = w.algorithm.decrypt.cipher.iv,
                      O = w.subjectPrivateKey,
                      P = parseInt(B.split('-')[1], 10) / 8,
                      $ = c.pbkdf2Sync(C, T, I, P, 'sha1'),
                      F = l.createDecipheriv(B, $, E),
                      M = []
                    return (M.push(F.update(O)), M.push(F.final()), u.concat(M))
                  })((b = s.EncryptedPrivateKey.decode(b, 'der')), h)
                case 'PRIVATE KEY':
                  switch ((p = (g = s.PrivateKey.decode(b, 'der')).algorithm.algorithm.join('.'))) {
                    case '1.2.840.113549.1.1.1':
                      return s.RSAPrivateKey.decode(g.subjectPrivateKey, 'der')
                    case '1.2.840.10045.2.1':
                      return {
                        curve: g.algorithm.curve,
                        privateKey: s.ECPrivateKey.decode(g.subjectPrivateKey, 'der').privateKey,
                      }
                    case '1.2.840.10040.4.1':
                      return (
                        (g.algorithm.params.priv_key = s.DSAparam.decode(
                          g.subjectPrivateKey,
                          'der',
                        )),
                        { type: 'dsa', params: g.algorithm.params }
                      )
                    default:
                      throw new Error('unknown key id ' + p)
                  }
                case 'RSA PUBLIC KEY':
                  return s.RSAPublicKey.decode(b, 'der')
                case 'RSA PRIVATE KEY':
                  return s.RSAPrivateKey.decode(b, 'der')
                case 'DSA PRIVATE KEY':
                  return { type: 'dsa', params: s.DSAPrivateKey.decode(b, 'der') }
                case 'EC PRIVATE KEY':
                  return {
                    curve: (b = s.ECPrivateKey.decode(b, 'der')).parameters.value,
                    privateKey: b.privateKey,
                  }
                default:
                  throw new Error('unknown key type ' + y)
              }
            }
            ;((r.exports = f), (f.signature = s.signature))
          },
          {
            './aesid.json': 455,
            './asn1': 456,
            './fixProc': 458,
            'browserify-aes': 191,
            pbkdf2: 460,
            'safe-buffer': 494,
          },
        ],
        460: [
          function (t, r, i) {
            ;((i.pbkdf2 = t('./lib/async')), (i.pbkdf2Sync = t('./lib/sync')))
          },
          { './lib/async': 461, './lib/sync': 464 },
        ],
        461: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o,
                  a,
                  l = t('safe-buffer').Buffer,
                  c = t('./precondition'),
                  u = t('./default-encoding'),
                  f = t('./sync'),
                  d = t('./to-buffer'),
                  h = s.crypto && s.crypto.subtle,
                  p = {
                    sha: 'SHA-1',
                    'sha-1': 'SHA-1',
                    sha1: 'SHA-1',
                    sha256: 'SHA-256',
                    'sha-256': 'SHA-256',
                    sha384: 'SHA-384',
                    'sha-384': 'SHA-384',
                    'sha-512': 'SHA-512',
                    sha512: 'SHA-512',
                  },
                  g = []
                function m() {
                  return (
                    a ||
                    (a =
                      s.process && s.process.nextTick
                        ? s.process.nextTick
                        : s.queueMicrotask
                          ? s.queueMicrotask
                          : s.setImmediate
                            ? s.setImmediate
                            : s.setTimeout)
                  )
                }
                function y(b, w, C, T, I) {
                  return h
                    .importKey('raw', b, { name: 'PBKDF2' }, !1, ['deriveBits'])
                    .then(function (B) {
                      return h.deriveBits(
                        { name: 'PBKDF2', salt: w, iterations: C, hash: { name: I } },
                        B,
                        T << 3,
                      )
                    })
                    .then(function (B) {
                      return l.from(B)
                    })
                }
                r.exports = function (b, w, C, T, I, B) {
                  typeof I == 'function' && ((B = I), (I = void 0))
                  var E = p[(I = I || 'sha1').toLowerCase()]
                  if (E && typeof s.Promise == 'function') {
                    if (
                      (c(C, T),
                      (b = d(b, u, 'Password')),
                      (w = d(w, u, 'Salt')),
                      typeof B != 'function')
                    )
                      throw new Error('No callback provided to pbkdf2')
                    ;(function (O, P) {
                      O.then(
                        function ($) {
                          m()(function () {
                            P(null, $)
                          })
                        },
                        function ($) {
                          m()(function () {
                            P($)
                          })
                        },
                      )
                    })(
                      (function (O) {
                        if (
                          (s.process && !s.process.browser) ||
                          !h ||
                          !h.importKey ||
                          !h.deriveBits
                        )
                          return Promise.resolve(!1)
                        if (g[O] !== void 0) return g[O]
                        var P = y((o = o || l.alloc(8)), o, 10, 128, O)
                          .then(function () {
                            return !0
                          })
                          .catch(function () {
                            return !1
                          })
                        return ((g[O] = P), P)
                      })(E).then(function (O) {
                        return O ? y(b, w, C, T, E) : f(b, w, C, T, I)
                      }),
                      B,
                    )
                  } else
                    m()(function () {
                      var O
                      try {
                        O = f(b, w, C, T, I)
                      } catch (P) {
                        return B(P)
                      }
                      B(null, O)
                    })
                }
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {
            './default-encoding': 462,
            './precondition': 463,
            './sync': 464,
            './to-buffer': 465,
            'safe-buffer': 494,
          },
        ],
        462: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                var a
                ;(o.process && o.process.browser
                  ? (a = 'utf-8')
                  : o.process && o.process.version
                    ? (a = parseInt(s.version.split('.')[0].slice(1), 10) >= 6 ? 'utf-8' : 'binary')
                    : (a = 'utf-8'),
                  (r.exports = a))
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          { _process: 467 },
        ],
        463: [
          function (t, r, i) {
            var s = Math.pow(2, 30) - 1
            r.exports = function (o, a) {
              if (typeof o != 'number') throw new TypeError('Iterations not a number')
              if (o < 0) throw new TypeError('Bad iterations')
              if (typeof a != 'number') throw new TypeError('Key length not a number')
              if (a < 0 || a > s || a != a) throw new TypeError('Bad key length')
            }
          },
          {},
        ],
        464: [
          function (t, r, i) {
            var s = t('create-hash/md5'),
              o = t('ripemd160'),
              a = t('sha.js'),
              l = t('safe-buffer').Buffer,
              c = t('./precondition'),
              u = t('./default-encoding'),
              f = t('./to-buffer'),
              d = l.alloc(128),
              h = {
                md5: 16,
                sha1: 20,
                sha224: 28,
                sha256: 32,
                sha384: 48,
                sha512: 64,
                rmd160: 20,
                ripemd160: 20,
              }
            function p(g, m, y) {
              var b = (function (E) {
                  function O(P) {
                    return a(E).update(P).digest()
                  }
                  return E === 'rmd160' || E === 'ripemd160'
                    ? function (P) {
                        return new o().update(P).digest()
                      }
                    : E === 'md5'
                      ? s
                      : O
                })(g),
                w = g === 'sha512' || g === 'sha384' ? 128 : 64
              m.length > w ? (m = b(m)) : m.length < w && (m = l.concat([m, d], w))
              for (var C = l.allocUnsafe(w + h[g]), T = l.allocUnsafe(w + h[g]), I = 0; I < w; I++)
                ((C[I] = 54 ^ m[I]), (T[I] = 92 ^ m[I]))
              var B = l.allocUnsafe(w + y + 4)
              ;(C.copy(B, 0, 0, w),
                (this.ipad1 = B),
                (this.ipad2 = C),
                (this.opad = T),
                (this.alg = g),
                (this.blocksize = w),
                (this.hash = b),
                (this.size = h[g]))
            }
            ;((p.prototype.run = function (g, m) {
              return (
                g.copy(m, this.blocksize),
                this.hash(m).copy(this.opad, this.blocksize),
                this.hash(this.opad)
              )
            }),
              (r.exports = function (g, m, y, b, w) {
                c(y, b)
                var C = new p(
                    (w = w || 'sha1'),
                    (g = f(g, u, 'Password')),
                    (m = f(m, u, 'Salt')).length,
                  ),
                  T = l.allocUnsafe(b),
                  I = l.allocUnsafe(m.length + 4)
                m.copy(I, 0, 0, m.length)
                for (var B = 0, E = h[w], O = Math.ceil(b / E), P = 1; P <= O; P++) {
                  I.writeUInt32BE(P, m.length)
                  for (var $ = C.run(I, C.ipad1), F = $, M = 1; M < y; M++) {
                    F = C.run(F, C.ipad2)
                    for (var R = 0; R < E; R++) $[R] ^= F[R]
                  }
                  ;($.copy(T, B), (B += E))
                }
                return T
              }))
          },
          {
            './default-encoding': 462,
            './precondition': 463,
            './to-buffer': 465,
            'create-hash/md5': 387,
            ripemd160: 493,
            'safe-buffer': 494,
            'sha.js': 498,
          },
        ],
        465: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer
            r.exports = function (o, a, l) {
              if (s.isBuffer(o)) return o
              if (typeof o == 'string') return s.from(o, a)
              if (ArrayBuffer.isView(o)) return s.from(o.buffer)
              throw new TypeError(l + ' must be a string, a Buffer, a typed array or a DataView')
            }
          },
          { 'safe-buffer': 494 },
        ],
        466: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                s === void 0 ||
                !s.version ||
                s.version.indexOf('v0.') === 0 ||
                (s.version.indexOf('v1.') === 0 && s.version.indexOf('v1.8.') !== 0)
                  ? (r.exports = {
                      nextTick: function (o, a, l, c) {
                        if (typeof o != 'function')
                          throw new TypeError('"callback" argument must be a function')
                        var u,
                          f,
                          d = arguments.length
                        switch (d) {
                          case 0:
                          case 1:
                            return s.nextTick(o)
                          case 2:
                            return s.nextTick(function () {
                              o.call(null, a)
                            })
                          case 3:
                            return s.nextTick(function () {
                              o.call(null, a, l)
                            })
                          case 4:
                            return s.nextTick(function () {
                              o.call(null, a, l, c)
                            })
                          default:
                            for (u = new Array(d - 1), f = 0; f < u.length; ) u[f++] = arguments[f]
                            return s.nextTick(function () {
                              o.apply(null, u)
                            })
                        }
                      },
                    })
                  : (r.exports = s)
              }).call(this)
            }).call(this, t('_process'))
          },
          { _process: 467 },
        ],
        467: [
          function (t, r, i) {
            var s,
              o,
              a = (r.exports = {})
            function l() {
              throw new Error('setTimeout has not been defined')
            }
            function c() {
              throw new Error('clearTimeout has not been defined')
            }
            function u(w) {
              if (s === setTimeout) return setTimeout(w, 0)
              if ((s === l || !s) && setTimeout) return ((s = setTimeout), setTimeout(w, 0))
              try {
                return s(w, 0)
              } catch {
                try {
                  return s.call(null, w, 0)
                } catch {
                  return s.call(this, w, 0)
                }
              }
            }
            ;(function () {
              try {
                s = typeof setTimeout == 'function' ? setTimeout : l
              } catch {
                s = l
              }
              try {
                o = typeof clearTimeout == 'function' ? clearTimeout : c
              } catch {
                o = c
              }
            })()
            var f,
              d = [],
              h = !1,
              p = -1
            function g() {
              h && f && ((h = !1), f.length ? (d = f.concat(d)) : (p = -1), d.length && m())
            }
            function m() {
              if (!h) {
                var w = u(g)
                h = !0
                for (var C = d.length; C; ) {
                  for (f = d, d = []; ++p < C; ) f && f[p].run()
                  ;((p = -1), (C = d.length))
                }
                ;((f = null),
                  (h = !1),
                  (function (T) {
                    if (o === clearTimeout) return clearTimeout(T)
                    if ((o === c || !o) && clearTimeout)
                      return ((o = clearTimeout), clearTimeout(T))
                    try {
                      o(T)
                    } catch {
                      try {
                        return o.call(null, T)
                      } catch {
                        return o.call(this, T)
                      }
                    }
                  })(w))
              }
            }
            function y(w, C) {
              ;((this.fun = w), (this.array = C))
            }
            function b() {}
            ;((a.nextTick = function (w) {
              var C = new Array(arguments.length - 1)
              if (arguments.length > 1)
                for (var T = 1; T < arguments.length; T++) C[T - 1] = arguments[T]
              ;(d.push(new y(w, C)), d.length !== 1 || h || u(m))
            }),
              (y.prototype.run = function () {
                this.fun.apply(null, this.array)
              }),
              (a.title = 'browser'),
              (a.browser = !0),
              (a.env = {}),
              (a.argv = []),
              (a.version = ''),
              (a.versions = {}),
              (a.on = b),
              (a.addListener = b),
              (a.once = b),
              (a.off = b),
              (a.removeListener = b),
              (a.removeAllListeners = b),
              (a.emit = b),
              (a.prependListener = b),
              (a.prependOnceListener = b),
              (a.listeners = function (w) {
                return []
              }),
              (a.binding = function (w) {
                throw new Error('process.binding is not supported')
              }),
              (a.cwd = function () {
                return '/'
              }),
              (a.chdir = function (w) {
                throw new Error('process.chdir is not supported')
              }),
              (a.umask = function () {
                return 0
              }))
          },
          {},
        ],
        468: [
          function (t, r, i) {
            ;((i.publicEncrypt = t('./publicEncrypt')),
              (i.privateDecrypt = t('./privateDecrypt')),
              (i.privateEncrypt = function (s, o) {
                return i.publicEncrypt(s, o, !0)
              }),
              (i.publicDecrypt = function (s, o) {
                return i.privateDecrypt(s, o, !0)
              }))
          },
          { './privateDecrypt': 471, './publicEncrypt': 472 },
        ],
        469: [
          function (t, r, i) {
            var s = t('create-hash'),
              o = t('safe-buffer').Buffer
            function a(l) {
              var c = o.allocUnsafe(4)
              return (c.writeUInt32BE(l, 0), c)
            }
            r.exports = function (l, c) {
              for (var u, f = o.alloc(0), d = 0; f.length < c; )
                ((u = a(d++)), (f = o.concat([f, s('sha1').update(l).update(u).digest()])))
              return f.slice(0, c)
            }
          },
          { 'create-hash': 386, 'safe-buffer': 494 },
        ],
        470: [
          function (t, r, i) {
            arguments[4][184][0].apply(i, arguments)
          },
          { buffer: 188, dup: 184 },
        ],
        471: [
          function (t, r, i) {
            var s = t('parse-asn1'),
              o = t('./mgf'),
              a = t('./xor'),
              l = t('bn.js'),
              c = t('browserify-rsa'),
              u = t('create-hash'),
              f = t('./withPublic'),
              d = t('safe-buffer').Buffer
            r.exports = function (h, p, g) {
              var m
              m = h.padding ? h.padding : g ? 1 : 4
              var y,
                b = s(h),
                w = b.modulus.byteLength()
              if (p.length > w || new l(p).cmp(b.modulus) >= 0) throw new Error('decryption error')
              y = g ? f(new l(p), b) : c(p, b)
              var C = d.alloc(w - y.length)
              if (((y = d.concat([C, y], w)), m === 4))
                return (function (T, I) {
                  var B = T.modulus.byteLength(),
                    E = u('sha1').update(d.alloc(0)).digest(),
                    O = E.length
                  if (I[0] !== 0) throw new Error('decryption error')
                  var P = I.slice(1, O + 1),
                    $ = I.slice(O + 1),
                    F = a(P, o($, O)),
                    M = a($, o(F, B - O - 1))
                  if (
                    (function (k, v) {
                      ;((k = d.from(k)), (v = d.from(v)))
                      var x = 0,
                        _ = k.length
                      k.length !== v.length && (x++, (_ = Math.min(k.length, v.length)))
                      for (var S = -1; ++S < _; ) x += k[S] ^ v[S]
                      return x
                    })(E, M.slice(0, O))
                  )
                    throw new Error('decryption error')
                  for (var R = O; M[R] === 0; ) R++
                  if (M[R++] !== 1) throw new Error('decryption error')
                  return M.slice(R)
                })(b, y)
              if (m === 1)
                return (function (T, I, B) {
                  for (var E = I.slice(0, 2), O = 2, P = 0; I[O++] !== 0; )
                    if (O >= I.length) {
                      P++
                      break
                    }
                  var $ = I.slice(2, O - 1)
                  if (
                    (((E.toString('hex') !== '0002' && !B) ||
                      (E.toString('hex') !== '0001' && B)) &&
                      P++,
                    $.length < 8 && P++,
                    P)
                  )
                    throw new Error('decryption error')
                  return I.slice(O)
                })(0, y, g)
              if (m === 3) return y
              throw new Error('unknown padding')
            }
          },
          {
            './mgf': 469,
            './withPublic': 473,
            './xor': 474,
            'bn.js': 470,
            'browserify-rsa': 209,
            'create-hash': 386,
            'parse-asn1': 459,
            'safe-buffer': 494,
          },
        ],
        472: [
          function (t, r, i) {
            var s = t('parse-asn1'),
              o = t('randombytes'),
              a = t('create-hash'),
              l = t('./mgf'),
              c = t('./xor'),
              u = t('bn.js'),
              f = t('./withPublic'),
              d = t('browserify-rsa'),
              h = t('safe-buffer').Buffer
            r.exports = function (p, g, m) {
              var y
              y = p.padding ? p.padding : m ? 1 : 4
              var b,
                w = s(p)
              if (y === 4)
                b = (function (C, T) {
                  var I = C.modulus.byteLength(),
                    B = T.length,
                    E = a('sha1').update(h.alloc(0)).digest(),
                    O = E.length,
                    P = 2 * O
                  if (B > I - P - 2) throw new Error('message too long')
                  var $ = h.alloc(I - B - P - 2),
                    F = I - O - 1,
                    M = o(O),
                    R = c(h.concat([E, $, h.alloc(1, 1), T], F), l(M, F)),
                    k = c(M, l(R, O))
                  return new u(h.concat([h.alloc(1), k, R], I))
                })(w, g)
              else if (y === 1)
                b = (function (C, T, I) {
                  var B,
                    E = T.length,
                    O = C.modulus.byteLength()
                  if (E > O - 11) throw new Error('message too long')
                  return (
                    (B = I
                      ? h.alloc(O - E - 3, 255)
                      : (function (P) {
                          for (var $, F = h.allocUnsafe(P), M = 0, R = o(2 * P), k = 0; M < P; )
                            (k === R.length && ((R = o(2 * P)), (k = 0)),
                              ($ = R[k++]) && (F[M++] = $))
                          return F
                        })(O - E - 3)),
                    new u(h.concat([h.from([0, I ? 1 : 2]), B, h.alloc(1), T], O))
                  )
                })(w, g, m)
              else {
                if (y !== 3) throw new Error('unknown padding')
                if ((b = new u(g)).cmp(w.modulus) >= 0) throw new Error('data too long for modulus')
              }
              return m ? d(b, w) : f(b, w)
            }
          },
          {
            './mgf': 469,
            './withPublic': 473,
            './xor': 474,
            'bn.js': 470,
            'browserify-rsa': 209,
            'create-hash': 386,
            'parse-asn1': 459,
            randombytes: 475,
            'safe-buffer': 494,
          },
        ],
        473: [
          function (t, r, i) {
            var s = t('bn.js'),
              o = t('safe-buffer').Buffer
            r.exports = function (a, l) {
              return o.from(
                a.toRed(s.mont(l.modulus)).redPow(new s(l.publicExponent)).fromRed().toArray(),
              )
            }
          },
          { 'bn.js': 470, 'safe-buffer': 494 },
        ],
        474: [
          function (t, r, i) {
            r.exports = function (s, o) {
              for (var a = s.length, l = -1; ++l < a; ) s[l] ^= o[l]
              return s
            }
          },
          {},
        ],
        475: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                var a = t('safe-buffer').Buffer,
                  l = o.crypto || o.msCrypto
                l && l.getRandomValues
                  ? (r.exports = function (c, u) {
                      if (c > 4294967295) throw new RangeError('requested too many random bytes')
                      var f = a.allocUnsafe(c)
                      if (c > 0)
                        if (c > 65536)
                          for (var d = 0; d < c; d += 65536)
                            l.getRandomValues(f.slice(d, d + 65536))
                        else l.getRandomValues(f)
                      return typeof u == 'function'
                        ? s.nextTick(function () {
                            u(null, f)
                          })
                        : f
                    })
                  : (r.exports = function () {
                      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
                    })
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          { _process: 467, 'safe-buffer': 494 },
        ],
        476: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                function a() {
                  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
                }
                var l = t('safe-buffer'),
                  c = t('randombytes'),
                  u = l.Buffer,
                  f = l.kMaxLength,
                  d = o.crypto || o.msCrypto,
                  h = Math.pow(2, 32) - 1
                function p(y, b) {
                  if (typeof y != 'number' || y != y) throw new TypeError('offset must be a number')
                  if (y > h || y < 0) throw new TypeError('offset must be a uint32')
                  if (y > f || y > b) throw new RangeError('offset out of range')
                }
                function g(y, b, w) {
                  if (typeof y != 'number' || y != y) throw new TypeError('size must be a number')
                  if (y > h || y < 0) throw new TypeError('size must be a uint32')
                  if (y + b > w || y > f) throw new RangeError('buffer too small')
                }
                function m(y, b, w, C) {
                  if (s.browser) {
                    var T = y.buffer,
                      I = new Uint8Array(T, b, w)
                    return (
                      d.getRandomValues(I),
                      C
                        ? void s.nextTick(function () {
                            C(null, y)
                          })
                        : y
                    )
                  }
                  if (!C) return (c(w).copy(y, b), y)
                  c(w, function (B, E) {
                    if (B) return C(B)
                    ;(E.copy(y, b), C(null, y))
                  })
                }
                ;(d && d.getRandomValues) || !s.browser
                  ? ((i.randomFill = function (y, b, w, C) {
                      if (!(u.isBuffer(y) || y instanceof o.Uint8Array))
                        throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
                      if (typeof b == 'function') ((C = b), (b = 0), (w = y.length))
                      else if (typeof w == 'function') ((C = w), (w = y.length - b))
                      else if (typeof C != 'function')
                        throw new TypeError('"cb" argument must be a function')
                      return (p(b, y.length), g(w, b, y.length), m(y, b, w, C))
                    }),
                    (i.randomFillSync = function (y, b, w) {
                      if ((b === void 0 && (b = 0), !(u.isBuffer(y) || y instanceof o.Uint8Array)))
                        throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
                      return (
                        p(b, y.length),
                        w === void 0 && (w = y.length - b),
                        g(w, b, y.length),
                        m(y, b, w)
                      )
                    }))
                  : ((i.randomFill = a), (i.randomFillSync = a))
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          { _process: 467, randombytes: 475, 'safe-buffer': 494 },
        ],
        477: [
          function (t, r, i) {
            var s = {}
            function o(l, c, u) {
              u || (u = Error)
              var f = (function (d) {
                var h, p
                function g(m, y, b) {
                  return (
                    d.call(
                      this,
                      (function (w, C, T) {
                        return typeof c == 'string' ? c : c(w, C, T)
                      })(m, y, b),
                    ) || this
                  )
                }
                return (
                  (p = d),
                  ((h = g).prototype = Object.create(p.prototype)),
                  (h.prototype.constructor = h),
                  (h.__proto__ = p),
                  g
                )
              })(u)
              ;((f.prototype.name = u.name), (f.prototype.code = l), (s[l] = f))
            }
            function a(l, c) {
              if (Array.isArray(l)) {
                var u = l.length
                return (
                  (l = l.map(function (f) {
                    return String(f)
                  })),
                  u > 2
                    ? 'one of '.concat(c, ' ').concat(l.slice(0, u - 1).join(', '), ', or ') +
                      l[u - 1]
                    : u === 2
                      ? 'one of '.concat(c, ' ').concat(l[0], ' or ').concat(l[1])
                      : 'of '.concat(c, ' ').concat(l[0])
                )
              }
              return 'of '.concat(c, ' ').concat(String(l))
            }
            ;(o(
              'ERR_INVALID_OPT_VALUE',
              function (l, c) {
                return 'The value "' + c + '" is invalid for option "' + l + '"'
              },
              TypeError,
            ),
              o(
                'ERR_INVALID_ARG_TYPE',
                function (l, c, u) {
                  var f, d, h
                  if (
                    (typeof c == 'string' && ((d = 'not '), c.substr(0, d.length) === d)
                      ? ((f = 'must not be'), (c = c.replace(/^not /, '')))
                      : (f = 'must be'),
                    (function (g, m, y) {
                      return (
                        (y === void 0 || y > g.length) && (y = g.length),
                        g.substring(y - m.length, y) === m
                      )
                    })(l, ' argument'))
                  )
                    h = 'The '.concat(l, ' ').concat(f, ' ').concat(a(c, 'type'))
                  else {
                    var p = (function (g, m, y) {
                      return (
                        typeof y != 'number' && (y = 0),
                        !(y + m.length > g.length) && g.indexOf(m, y) !== -1
                      )
                    })(l, '.')
                      ? 'property'
                      : 'argument'
                    h = 'The "'.concat(l, '" ').concat(p, ' ').concat(f, ' ').concat(a(c, 'type'))
                  }
                  return (h += '. Received type '.concat(typeof u))
                },
                TypeError,
              ),
              o('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF'),
              o('ERR_METHOD_NOT_IMPLEMENTED', function (l) {
                return 'The ' + l + ' method is not implemented'
              }),
              o('ERR_STREAM_PREMATURE_CLOSE', 'Premature close'),
              o('ERR_STREAM_DESTROYED', function (l) {
                return 'Cannot call ' + l + ' after a stream was destroyed'
              }),
              o('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times'),
              o('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable'),
              o('ERR_STREAM_WRITE_AFTER_END', 'write after end'),
              o('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError),
              o(
                'ERR_UNKNOWN_ENCODING',
                function (l) {
                  return 'Unknown encoding: ' + l
                },
                TypeError,
              ),
              o('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event'),
              (r.exports.codes = s))
          },
          {},
        ],
        478: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o =
                  Object.keys ||
                  function (g) {
                    var m = []
                    for (var y in g) m.push(y)
                    return m
                  }
                r.exports = d
                var a = t('./_stream_readable'),
                  l = t('./_stream_writable')
                t('inherits')(d, a)
                for (var c = o(l.prototype), u = 0; u < c.length; u++) {
                  var f = c[u]
                  d.prototype[f] || (d.prototype[f] = l.prototype[f])
                }
                function d(g) {
                  if (!(this instanceof d)) return new d(g)
                  ;(a.call(this, g),
                    l.call(this, g),
                    (this.allowHalfOpen = !0),
                    g &&
                      (g.readable === !1 && (this.readable = !1),
                      g.writable === !1 && (this.writable = !1),
                      g.allowHalfOpen === !1 && ((this.allowHalfOpen = !1), this.once('end', h))))
                }
                function h() {
                  this._writableState.ended || s.nextTick(p, this)
                }
                function p(g) {
                  g.end()
                }
                ;(Object.defineProperty(d.prototype, 'writableHighWaterMark', {
                  enumerable: !1,
                  get: function () {
                    return this._writableState.highWaterMark
                  },
                }),
                  Object.defineProperty(d.prototype, 'writableBuffer', {
                    enumerable: !1,
                    get: function () {
                      return this._writableState && this._writableState.getBuffer()
                    },
                  }),
                  Object.defineProperty(d.prototype, 'writableLength', {
                    enumerable: !1,
                    get: function () {
                      return this._writableState.length
                    },
                  }),
                  Object.defineProperty(d.prototype, 'destroyed', {
                    enumerable: !1,
                    get: function () {
                      return (
                        this._readableState !== void 0 &&
                        this._writableState !== void 0 &&
                        this._readableState.destroyed &&
                        this._writableState.destroyed
                      )
                    },
                    set: function (g) {
                      this._readableState !== void 0 &&
                        this._writableState !== void 0 &&
                        ((this._readableState.destroyed = g), (this._writableState.destroyed = g))
                    },
                  }))
              }).call(this)
            }).call(this, t('_process'))
          },
          { './_stream_readable': 480, './_stream_writable': 482, _process: 467, inherits: 440 },
        ],
        479: [
          function (t, r, i) {
            r.exports = o
            var s = t('./_stream_transform')
            function o(a) {
              if (!(this instanceof o)) return new o(a)
              s.call(this, a)
            }
            ;(t('inherits')(o, s),
              (o.prototype._transform = function (a, l, c) {
                c(null, a)
              }))
          },
          { './_stream_transform': 481, inherits: 440 },
        ],
        480: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                var a
                ;((r.exports = F), (F.ReadableState = $), t('events').EventEmitter)
                var l = function (D, N) {
                    return D.listeners(N).length
                  },
                  c = t('./internal/streams/stream'),
                  u = t('buffer').Buffer,
                  f =
                    (o !== void 0
                      ? o
                      : typeof window < 'u'
                        ? window
                        : typeof self < 'u'
                          ? self
                          : {}
                    ).Uint8Array || function () {},
                  d,
                  h = t('util')
                d = h && h.debuglog ? h.debuglog('stream') : function () {}
                var p,
                  g,
                  m,
                  y = t('./internal/streams/buffer_list'),
                  b = t('./internal/streams/destroy'),
                  w = t('./internal/streams/state').getHighWaterMark,
                  C = t('../errors').codes,
                  T = C.ERR_INVALID_ARG_TYPE,
                  I = C.ERR_STREAM_PUSH_AFTER_EOF,
                  B = C.ERR_METHOD_NOT_IMPLEMENTED,
                  E = C.ERR_STREAM_UNSHIFT_AFTER_END_EVENT
                t('inherits')(F, c)
                var O = b.errorOrDestroy,
                  P = ['error', 'close', 'destroy', 'pause', 'resume']
                function $(D, N, V) {
                  ;((a = a || t('./_stream_duplex')),
                    (D = D || {}),
                    typeof V != 'boolean' && (V = N instanceof a),
                    (this.objectMode = !!D.objectMode),
                    V && (this.objectMode = this.objectMode || !!D.readableObjectMode),
                    (this.highWaterMark = w(this, D, 'readableHighWaterMark', V)),
                    (this.buffer = new y()),
                    (this.length = 0),
                    (this.pipes = null),
                    (this.pipesCount = 0),
                    (this.flowing = null),
                    (this.ended = !1),
                    (this.endEmitted = !1),
                    (this.reading = !1),
                    (this.sync = !0),
                    (this.needReadable = !1),
                    (this.emittedReadable = !1),
                    (this.readableListening = !1),
                    (this.resumeScheduled = !1),
                    (this.paused = !0),
                    (this.emitClose = D.emitClose !== !1),
                    (this.autoDestroy = !!D.autoDestroy),
                    (this.destroyed = !1),
                    (this.defaultEncoding = D.defaultEncoding || 'utf8'),
                    (this.awaitDrain = 0),
                    (this.readingMore = !1),
                    (this.decoder = null),
                    (this.encoding = null),
                    D.encoding &&
                      (p || (p = t('string_decoder/').StringDecoder),
                      (this.decoder = new p(D.encoding)),
                      (this.encoding = D.encoding)))
                }
                function F(D) {
                  if (((a = a || t('./_stream_duplex')), !(this instanceof F))) return new F(D)
                  var N = this instanceof a
                  ;((this._readableState = new $(D, this, N)),
                    (this.readable = !0),
                    D &&
                      (typeof D.read == 'function' && (this._read = D.read),
                      typeof D.destroy == 'function' && (this._destroy = D.destroy)),
                    c.call(this))
                }
                function M(D, N, V, W, J) {
                  d('readableAddChunk', N)
                  var G,
                    Z = D._readableState
                  if (N === null)
                    ((Z.reading = !1),
                      (function (rt, nt) {
                        if ((d('onEofChunk'), !nt.ended)) {
                          if (nt.decoder) {
                            var X = nt.decoder.end()
                            X &&
                              X.length &&
                              (nt.buffer.push(X), (nt.length += nt.objectMode ? 1 : X.length))
                          }
                          ;((nt.ended = !0),
                            nt.sync
                              ? v(rt)
                              : ((nt.needReadable = !1),
                                nt.emittedReadable || ((nt.emittedReadable = !0), x(rt))))
                        }
                      })(D, Z))
                  else if (
                    (J ||
                      (G = (function (rt, nt) {
                        var X
                        ;((Q = nt),
                          u.isBuffer(Q) ||
                            Q instanceof f ||
                            typeof nt == 'string' ||
                            nt === void 0 ||
                            rt.objectMode ||
                            (X = new T('chunk', ['string', 'Buffer', 'Uint8Array'], nt)))
                        var Q
                        return X
                      })(Z, N)),
                    G)
                  )
                    O(D, G)
                  else if (Z.objectMode || (N && N.length > 0))
                    if (
                      (typeof N == 'string' ||
                        Z.objectMode ||
                        Object.getPrototypeOf(N) === u.prototype ||
                        (N = (function (rt) {
                          return u.from(rt)
                        })(N)),
                      W)
                    )
                      Z.endEmitted ? O(D, new E()) : R(D, Z, N, !0)
                    else if (Z.ended) O(D, new I())
                    else {
                      if (Z.destroyed) return !1
                      ;((Z.reading = !1),
                        Z.decoder && !V
                          ? ((N = Z.decoder.write(N)),
                            Z.objectMode || N.length !== 0 ? R(D, Z, N, !1) : _(D, Z))
                          : R(D, Z, N, !1))
                    }
                  else W || ((Z.reading = !1), _(D, Z))
                  return !Z.ended && (Z.length < Z.highWaterMark || Z.length === 0)
                }
                function R(D, N, V, W) {
                  ;(N.flowing && N.length === 0 && !N.sync
                    ? ((N.awaitDrain = 0), D.emit('data', V))
                    : ((N.length += N.objectMode ? 1 : V.length),
                      W ? N.buffer.unshift(V) : N.buffer.push(V),
                      N.needReadable && v(D)),
                    _(D, N))
                }
                ;(Object.defineProperty(F.prototype, 'destroyed', {
                  enumerable: !1,
                  get: function () {
                    return this._readableState !== void 0 && this._readableState.destroyed
                  },
                  set: function (D) {
                    this._readableState && (this._readableState.destroyed = D)
                  },
                }),
                  (F.prototype.destroy = b.destroy),
                  (F.prototype._undestroy = b.undestroy),
                  (F.prototype._destroy = function (D, N) {
                    N(D)
                  }),
                  (F.prototype.push = function (D, N) {
                    var V,
                      W = this._readableState
                    return (
                      W.objectMode
                        ? (V = !0)
                        : typeof D == 'string' &&
                          ((N = N || W.defaultEncoding) !== W.encoding &&
                            ((D = u.from(D, N)), (N = '')),
                          (V = !0)),
                      M(this, D, N, !1, V)
                    )
                  }),
                  (F.prototype.unshift = function (D) {
                    return M(this, D, null, !0, !1)
                  }),
                  (F.prototype.isPaused = function () {
                    return this._readableState.flowing === !1
                  }),
                  (F.prototype.setEncoding = function (D) {
                    p || (p = t('string_decoder/').StringDecoder)
                    var N = new p(D)
                    ;((this._readableState.decoder = N),
                      (this._readableState.encoding = this._readableState.decoder.encoding))
                    for (var V = this._readableState.buffer.head, W = ''; V !== null; )
                      ((W += N.write(V.data)), (V = V.next))
                    return (
                      this._readableState.buffer.clear(),
                      W !== '' && this._readableState.buffer.push(W),
                      (this._readableState.length = W.length),
                      this
                    )
                  }))
                function k(D, N) {
                  return D <= 0 || (N.length === 0 && N.ended)
                    ? 0
                    : N.objectMode
                      ? 1
                      : D != D
                        ? N.flowing && N.length
                          ? N.buffer.head.data.length
                          : N.length
                        : (D > N.highWaterMark &&
                            (N.highWaterMark = (function (V) {
                              return (
                                V >= 1073741824
                                  ? (V = 1073741824)
                                  : (V--,
                                    (V |= V >>> 1),
                                    (V |= V >>> 2),
                                    (V |= V >>> 4),
                                    (V |= V >>> 8),
                                    (V |= V >>> 16),
                                    V++),
                                V
                              )
                            })(D)),
                          D <= N.length ? D : N.ended ? N.length : ((N.needReadable = !0), 0))
                }
                function v(D) {
                  var N = D._readableState
                  ;(d('emitReadable', N.needReadable, N.emittedReadable),
                    (N.needReadable = !1),
                    N.emittedReadable ||
                      (d('emitReadable', N.flowing), (N.emittedReadable = !0), s.nextTick(x, D)))
                }
                function x(D) {
                  var N = D._readableState
                  ;(d('emitReadable_', N.destroyed, N.length, N.ended),
                    N.destroyed ||
                      (!N.length && !N.ended) ||
                      (D.emit('readable'), (N.emittedReadable = !1)),
                    (N.needReadable = !N.flowing && !N.ended && N.length <= N.highWaterMark),
                    H(D))
                }
                function _(D, N) {
                  N.readingMore || ((N.readingMore = !0), s.nextTick(S, D, N))
                }
                function S(D, N) {
                  for (
                    ;
                    !N.reading &&
                    !N.ended &&
                    (N.length < N.highWaterMark || (N.flowing && N.length === 0));

                  ) {
                    var V = N.length
                    if ((d('maybeReadMore read 0'), D.read(0), V === N.length)) break
                  }
                  N.readingMore = !1
                }
                function A(D) {
                  var N = D._readableState
                  ;((N.readableListening = D.listenerCount('readable') > 0),
                    N.resumeScheduled && !N.paused
                      ? (N.flowing = !0)
                      : D.listenerCount('data') > 0 && D.resume())
                }
                function j(D) {
                  ;(d('readable nexttick read 0'), D.read(0))
                }
                function L(D, N) {
                  ;(d('resume', N.reading),
                    N.reading || D.read(0),
                    (N.resumeScheduled = !1),
                    D.emit('resume'),
                    H(D),
                    N.flowing && !N.reading && D.read(0))
                }
                function H(D) {
                  var N = D._readableState
                  for (d('flow', N.flowing); N.flowing && D.read() !== null; );
                }
                function U(D, N) {
                  return N.length === 0
                    ? null
                    : (N.objectMode
                        ? (V = N.buffer.shift())
                        : !D || D >= N.length
                          ? ((V = N.decoder
                              ? N.buffer.join('')
                              : N.buffer.length === 1
                                ? N.buffer.first()
                                : N.buffer.concat(N.length)),
                            N.buffer.clear())
                          : (V = N.buffer.consume(D, N.decoder)),
                      V)
                  var V
                }
                function K(D) {
                  var N = D._readableState
                  ;(d('endReadable', N.endEmitted),
                    N.endEmitted || ((N.ended = !0), s.nextTick(z, N, D)))
                }
                function z(D, N) {
                  if (
                    (d('endReadableNT', D.endEmitted, D.length),
                    !D.endEmitted &&
                      D.length === 0 &&
                      ((D.endEmitted = !0), (N.readable = !1), N.emit('end'), D.autoDestroy))
                  ) {
                    var V = N._writableState
                    ;(!V || (V.autoDestroy && V.finished)) && N.destroy()
                  }
                }
                function q(D, N) {
                  for (var V = 0, W = D.length; V < W; V++) if (D[V] === N) return V
                  return -1
                }
                ;((F.prototype.read = function (D) {
                  ;(d('read', D), (D = parseInt(D, 10)))
                  var N = this._readableState,
                    V = D
                  if (
                    (D !== 0 && (N.emittedReadable = !1),
                    D === 0 &&
                      N.needReadable &&
                      ((N.highWaterMark !== 0 ? N.length >= N.highWaterMark : N.length > 0) ||
                        N.ended))
                  )
                    return (
                      d('read: emitReadable', N.length, N.ended),
                      N.length === 0 && N.ended ? K(this) : v(this),
                      null
                    )
                  if ((D = k(D, N)) === 0 && N.ended) return (N.length === 0 && K(this), null)
                  var W,
                    J = N.needReadable
                  return (
                    d('need readable', J),
                    (N.length === 0 || N.length - D < N.highWaterMark) &&
                      d('length less than watermark', (J = !0)),
                    N.ended || N.reading
                      ? d('reading or ended', (J = !1))
                      : J &&
                        (d('do read'),
                        (N.reading = !0),
                        (N.sync = !0),
                        N.length === 0 && (N.needReadable = !0),
                        this._read(N.highWaterMark),
                        (N.sync = !1),
                        N.reading || (D = k(V, N))),
                    (W = D > 0 ? U(D, N) : null) === null
                      ? ((N.needReadable = N.length <= N.highWaterMark), (D = 0))
                      : ((N.length -= D), (N.awaitDrain = 0)),
                    N.length === 0 &&
                      (N.ended || (N.needReadable = !0), V !== D && N.ended && K(this)),
                    W !== null && this.emit('data', W),
                    W
                  )
                }),
                  (F.prototype._read = function (D) {
                    O(this, new B('_read()'))
                  }),
                  (F.prototype.pipe = function (D, N) {
                    var V = this,
                      W = this._readableState
                    switch (W.pipesCount) {
                      case 0:
                        W.pipes = D
                        break
                      case 1:
                        W.pipes = [W.pipes, D]
                        break
                      default:
                        W.pipes.push(D)
                    }
                    ;((W.pipesCount += 1), d('pipe count=%d opts=%j', W.pipesCount, N))
                    var J = (!N || N.end !== !1) && D !== s.stdout && D !== s.stderr ? Z : ot
                    function G(at, ht) {
                      ;(d('onunpipe'),
                        at === V &&
                          ht &&
                          ht.hasUnpiped === !1 &&
                          ((ht.hasUnpiped = !0),
                          d('cleanup'),
                          D.removeListener('close', tt),
                          D.removeListener('finish', st),
                          D.removeListener('drain', rt),
                          D.removeListener('error', Q),
                          D.removeListener('unpipe', G),
                          V.removeListener('end', Z),
                          V.removeListener('end', ot),
                          V.removeListener('data', X),
                          (nt = !0),
                          !W.awaitDrain ||
                            (D._writableState && !D._writableState.needDrain) ||
                            rt()))
                    }
                    function Z() {
                      ;(d('onend'), D.end())
                    }
                    ;(W.endEmitted ? s.nextTick(J) : V.once('end', J), D.on('unpipe', G))
                    var rt = (function (at) {
                      return function () {
                        var ht = at._readableState
                        ;(d('pipeOnDrain', ht.awaitDrain),
                          ht.awaitDrain && ht.awaitDrain--,
                          ht.awaitDrain === 0 && l(at, 'data') && ((ht.flowing = !0), H(at)))
                      }
                    })(V)
                    D.on('drain', rt)
                    var nt = !1
                    function X(at) {
                      d('ondata')
                      var ht = D.write(at)
                      ;(d('dest.write', ht),
                        ht === !1 &&
                          (((W.pipesCount === 1 && W.pipes === D) ||
                            (W.pipesCount > 1 && q(W.pipes, D) !== -1)) &&
                            !nt &&
                            (d('false write response, pause', W.awaitDrain), W.awaitDrain++),
                          V.pause()))
                    }
                    function Q(at) {
                      ;(d('onerror', at),
                        ot(),
                        D.removeListener('error', Q),
                        l(D, 'error') === 0 && O(D, at))
                    }
                    function tt() {
                      ;(D.removeListener('finish', st), ot())
                    }
                    function st() {
                      ;(d('onfinish'), D.removeListener('close', tt), ot())
                    }
                    function ot() {
                      ;(d('unpipe'), V.unpipe(D))
                    }
                    return (
                      V.on('data', X),
                      (function (at, ht, dt) {
                        if (typeof at.prependListener == 'function')
                          return at.prependListener(ht, dt)
                        at._events && at._events[ht]
                          ? Array.isArray(at._events[ht])
                            ? at._events[ht].unshift(dt)
                            : (at._events[ht] = [dt, at._events[ht]])
                          : at.on(ht, dt)
                      })(D, 'error', Q),
                      D.once('close', tt),
                      D.once('finish', st),
                      D.emit('pipe', V),
                      W.flowing || (d('pipe resume'), V.resume()),
                      D
                    )
                  }),
                  (F.prototype.unpipe = function (D) {
                    var N = this._readableState,
                      V = { hasUnpiped: !1 }
                    if (N.pipesCount === 0) return this
                    if (N.pipesCount === 1)
                      return (
                        (D && D !== N.pipes) ||
                          (D || (D = N.pipes),
                          (N.pipes = null),
                          (N.pipesCount = 0),
                          (N.flowing = !1),
                          D && D.emit('unpipe', this, V)),
                        this
                      )
                    if (!D) {
                      var W = N.pipes,
                        J = N.pipesCount
                      ;((N.pipes = null), (N.pipesCount = 0), (N.flowing = !1))
                      for (var G = 0; G < J; G++) W[G].emit('unpipe', this, { hasUnpiped: !1 })
                      return this
                    }
                    var Z = q(N.pipes, D)
                    return (
                      Z === -1 ||
                        (N.pipes.splice(Z, 1),
                        (N.pipesCount -= 1),
                        N.pipesCount === 1 && (N.pipes = N.pipes[0]),
                        D.emit('unpipe', this, V)),
                      this
                    )
                  }),
                  (F.prototype.on = function (D, N) {
                    var V = c.prototype.on.call(this, D, N),
                      W = this._readableState
                    return (
                      D === 'data'
                        ? ((W.readableListening = this.listenerCount('readable') > 0),
                          W.flowing !== !1 && this.resume())
                        : D === 'readable' &&
                          (W.endEmitted ||
                            W.readableListening ||
                            ((W.readableListening = W.needReadable = !0),
                            (W.flowing = !1),
                            (W.emittedReadable = !1),
                            d('on readable', W.length, W.reading),
                            W.length ? v(this) : W.reading || s.nextTick(j, this))),
                      V
                    )
                  }),
                  (F.prototype.addListener = F.prototype.on),
                  (F.prototype.removeListener = function (D, N) {
                    var V = c.prototype.removeListener.call(this, D, N)
                    return (D === 'readable' && s.nextTick(A, this), V)
                  }),
                  (F.prototype.removeAllListeners = function (D) {
                    var N = c.prototype.removeAllListeners.apply(this, arguments)
                    return ((D !== 'readable' && D !== void 0) || s.nextTick(A, this), N)
                  }),
                  (F.prototype.resume = function () {
                    var D = this._readableState
                    return (
                      D.flowing ||
                        (d('resume'),
                        (D.flowing = !D.readableListening),
                        (function (N, V) {
                          V.resumeScheduled || ((V.resumeScheduled = !0), s.nextTick(L, N, V))
                        })(this, D)),
                      (D.paused = !1),
                      this
                    )
                  }),
                  (F.prototype.pause = function () {
                    return (
                      d('call pause flowing=%j', this._readableState.flowing),
                      this._readableState.flowing !== !1 &&
                        (d('pause'), (this._readableState.flowing = !1), this.emit('pause')),
                      (this._readableState.paused = !0),
                      this
                    )
                  }),
                  (F.prototype.wrap = function (D) {
                    var N = this,
                      V = this._readableState,
                      W = !1
                    for (var J in (D.on('end', function () {
                      if ((d('wrapped end'), V.decoder && !V.ended)) {
                        var Z = V.decoder.end()
                        Z && Z.length && N.push(Z)
                      }
                      N.push(null)
                    }),
                    D.on('data', function (Z) {
                      ;(d('wrapped data'),
                        V.decoder && (Z = V.decoder.write(Z)),
                        (V.objectMode && Z == null) ||
                          ((V.objectMode || (Z && Z.length)) &&
                            (N.push(Z) || ((W = !0), D.pause()))))
                    }),
                    D))
                      this[J] === void 0 &&
                        typeof D[J] == 'function' &&
                        (this[J] = (function (Z) {
                          return function () {
                            return D[Z].apply(D, arguments)
                          }
                        })(J))
                    for (var G = 0; G < P.length; G++) D.on(P[G], this.emit.bind(this, P[G]))
                    return (
                      (this._read = function (Z) {
                        ;(d('wrapped _read', Z), W && ((W = !1), D.resume()))
                      }),
                      this
                    )
                  }),
                  typeof Symbol == 'function' &&
                    (F.prototype[Symbol.asyncIterator] = function () {
                      return (g === void 0 && (g = t('./internal/streams/async_iterator')), g(this))
                    }),
                  Object.defineProperty(F.prototype, 'readableHighWaterMark', {
                    enumerable: !1,
                    get: function () {
                      return this._readableState.highWaterMark
                    },
                  }),
                  Object.defineProperty(F.prototype, 'readableBuffer', {
                    enumerable: !1,
                    get: function () {
                      return this._readableState && this._readableState.buffer
                    },
                  }),
                  Object.defineProperty(F.prototype, 'readableFlowing', {
                    enumerable: !1,
                    get: function () {
                      return this._readableState.flowing
                    },
                    set: function (D) {
                      this._readableState && (this._readableState.flowing = D)
                    },
                  }),
                  (F._fromList = U),
                  Object.defineProperty(F.prototype, 'readableLength', {
                    enumerable: !1,
                    get: function () {
                      return this._readableState.length
                    },
                  }),
                  typeof Symbol == 'function' &&
                    (F.from = function (D, N) {
                      return (m === void 0 && (m = t('./internal/streams/from')), m(F, D, N))
                    }))
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {
            '../errors': 477,
            './_stream_duplex': 478,
            './internal/streams/async_iterator': 483,
            './internal/streams/buffer_list': 484,
            './internal/streams/destroy': 485,
            './internal/streams/from': 487,
            './internal/streams/state': 489,
            './internal/streams/stream': 490,
            _process: 467,
            buffer: 220,
            events: 422,
            inherits: 440,
            'string_decoder/': 522,
            util: 188,
          },
        ],
        481: [
          function (t, r, i) {
            r.exports = d
            var s = t('../errors').codes,
              o = s.ERR_METHOD_NOT_IMPLEMENTED,
              a = s.ERR_MULTIPLE_CALLBACK,
              l = s.ERR_TRANSFORM_ALREADY_TRANSFORMING,
              c = s.ERR_TRANSFORM_WITH_LENGTH_0,
              u = t('./_stream_duplex')
            function f(g, m) {
              var y = this._transformState
              y.transforming = !1
              var b = y.writecb
              if (b === null) return this.emit('error', new a())
              ;((y.writechunk = null), (y.writecb = null), m != null && this.push(m), b(g))
              var w = this._readableState
              ;((w.reading = !1),
                (w.needReadable || w.length < w.highWaterMark) && this._read(w.highWaterMark))
            }
            function d(g) {
              if (!(this instanceof d)) return new d(g)
              ;(u.call(this, g),
                (this._transformState = {
                  afterTransform: f.bind(this),
                  needTransform: !1,
                  transforming: !1,
                  writecb: null,
                  writechunk: null,
                  writeencoding: null,
                }),
                (this._readableState.needReadable = !0),
                (this._readableState.sync = !1),
                g &&
                  (typeof g.transform == 'function' && (this._transform = g.transform),
                  typeof g.flush == 'function' && (this._flush = g.flush)),
                this.on('prefinish', h))
            }
            function h() {
              var g = this
              typeof this._flush != 'function' || this._readableState.destroyed
                ? p(this, null, null)
                : this._flush(function (m, y) {
                    p(g, m, y)
                  })
            }
            function p(g, m, y) {
              if (m) return g.emit('error', m)
              if ((y != null && g.push(y), g._writableState.length)) throw new c()
              if (g._transformState.transforming) throw new l()
              return g.push(null)
            }
            ;(t('inherits')(d, u),
              (d.prototype.push = function (g, m) {
                return (
                  (this._transformState.needTransform = !1),
                  u.prototype.push.call(this, g, m)
                )
              }),
              (d.prototype._transform = function (g, m, y) {
                y(new o('_transform()'))
              }),
              (d.prototype._write = function (g, m, y) {
                var b = this._transformState
                if (((b.writecb = y), (b.writechunk = g), (b.writeencoding = m), !b.transforming)) {
                  var w = this._readableState
                  ;(b.needTransform || w.needReadable || w.length < w.highWaterMark) &&
                    this._read(w.highWaterMark)
                }
              }),
              (d.prototype._read = function (g) {
                var m = this._transformState
                m.writechunk === null || m.transforming
                  ? (m.needTransform = !0)
                  : ((m.transforming = !0),
                    this._transform(m.writechunk, m.writeencoding, m.afterTransform))
              }),
              (d.prototype._destroy = function (g, m) {
                u.prototype._destroy.call(this, g, function (y) {
                  m(y)
                })
              }))
          },
          { '../errors': 477, './_stream_duplex': 478, inherits: 440 },
        ],
        482: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                function a(S) {
                  var A = this
                  ;((this.next = null),
                    (this.entry = null),
                    (this.finish = function () {
                      ;(function (j, L, H) {
                        var U = j.entry
                        for (j.entry = null; U; ) {
                          var K = U.callback
                          ;(L.pendingcb--, K(H), (U = U.next))
                        }
                        L.corkedRequestsFree.next = j
                      })(A, S)
                    }))
                }
                var l
                ;((r.exports = F), (F.WritableState = $))
                var c = { deprecate: t('util-deprecate') },
                  u = t('./internal/streams/stream'),
                  f = t('buffer').Buffer,
                  d =
                    (o !== void 0
                      ? o
                      : typeof window < 'u'
                        ? window
                        : typeof self < 'u'
                          ? self
                          : {}
                    ).Uint8Array || function () {},
                  h,
                  p = t('./internal/streams/destroy'),
                  g = t('./internal/streams/state').getHighWaterMark,
                  m = t('../errors').codes,
                  y = m.ERR_INVALID_ARG_TYPE,
                  b = m.ERR_METHOD_NOT_IMPLEMENTED,
                  w = m.ERR_MULTIPLE_CALLBACK,
                  C = m.ERR_STREAM_CANNOT_PIPE,
                  T = m.ERR_STREAM_DESTROYED,
                  I = m.ERR_STREAM_NULL_VALUES,
                  B = m.ERR_STREAM_WRITE_AFTER_END,
                  E = m.ERR_UNKNOWN_ENCODING,
                  O = p.errorOrDestroy
                function P() {}
                function $(S, A, j) {
                  ;((l = l || t('./_stream_duplex')),
                    (S = S || {}),
                    typeof j != 'boolean' && (j = A instanceof l),
                    (this.objectMode = !!S.objectMode),
                    j && (this.objectMode = this.objectMode || !!S.writableObjectMode),
                    (this.highWaterMark = g(this, S, 'writableHighWaterMark', j)),
                    (this.finalCalled = !1),
                    (this.needDrain = !1),
                    (this.ending = !1),
                    (this.ended = !1),
                    (this.finished = !1),
                    (this.destroyed = !1))
                  var L = S.decodeStrings === !1
                  ;((this.decodeStrings = !L),
                    (this.defaultEncoding = S.defaultEncoding || 'utf8'),
                    (this.length = 0),
                    (this.writing = !1),
                    (this.corked = 0),
                    (this.sync = !0),
                    (this.bufferProcessing = !1),
                    (this.onwrite = function (H) {
                      ;(function (U, K) {
                        var z = U._writableState,
                          q = z.sync,
                          D = z.writecb
                        if (typeof D != 'function') throw new w()
                        if (
                          ((function (V) {
                            ;((V.writing = !1),
                              (V.writecb = null),
                              (V.length -= V.writelen),
                              (V.writelen = 0))
                          })(z),
                          K)
                        )
                          (function (V, W, J, G, Z) {
                            ;(--W.pendingcb,
                              J
                                ? (s.nextTick(Z, G),
                                  s.nextTick(_, V, W),
                                  (V._writableState.errorEmitted = !0),
                                  O(V, G))
                                : (Z(G), (V._writableState.errorEmitted = !0), O(V, G), _(V, W)))
                          })(U, z, q, K, D)
                        else {
                          var N = v(z) || U.destroyed
                          ;(N || z.corked || z.bufferProcessing || !z.bufferedRequest || k(U, z),
                            q ? s.nextTick(R, U, z, N, D) : R(U, z, N, D))
                        }
                      })(A, H)
                    }),
                    (this.writecb = null),
                    (this.writelen = 0),
                    (this.bufferedRequest = null),
                    (this.lastBufferedRequest = null),
                    (this.pendingcb = 0),
                    (this.prefinished = !1),
                    (this.errorEmitted = !1),
                    (this.emitClose = S.emitClose !== !1),
                    (this.autoDestroy = !!S.autoDestroy),
                    (this.bufferedRequestCount = 0),
                    (this.corkedRequestsFree = new a(this)))
                }
                function F(S) {
                  var A = this instanceof (l = l || t('./_stream_duplex'))
                  if (!A && !h.call(F, this)) return new F(S)
                  ;((this._writableState = new $(S, this, A)),
                    (this.writable = !0),
                    S &&
                      (typeof S.write == 'function' && (this._write = S.write),
                      typeof S.writev == 'function' && (this._writev = S.writev),
                      typeof S.destroy == 'function' && (this._destroy = S.destroy),
                      typeof S.final == 'function' && (this._final = S.final)),
                    u.call(this))
                }
                function M(S, A, j, L, H, U, K) {
                  ;((A.writelen = L),
                    (A.writecb = K),
                    (A.writing = !0),
                    (A.sync = !0),
                    A.destroyed
                      ? A.onwrite(new T('write'))
                      : j
                        ? S._writev(H, A.onwrite)
                        : S._write(H, U, A.onwrite),
                    (A.sync = !1))
                }
                function R(S, A, j, L) {
                  ;(j ||
                    (function (H, U) {
                      U.length === 0 && U.needDrain && ((U.needDrain = !1), H.emit('drain'))
                    })(S, A),
                    A.pendingcb--,
                    L(),
                    _(S, A))
                }
                function k(S, A) {
                  A.bufferProcessing = !0
                  var j = A.bufferedRequest
                  if (S._writev && j && j.next) {
                    var L = A.bufferedRequestCount,
                      H = new Array(L),
                      U = A.corkedRequestsFree
                    U.entry = j
                    for (var K = 0, z = !0; j; )
                      ((H[K] = j), j.isBuf || (z = !1), (j = j.next), (K += 1))
                    ;((H.allBuffers = z),
                      M(S, A, !0, A.length, H, '', U.finish),
                      A.pendingcb++,
                      (A.lastBufferedRequest = null),
                      U.next
                        ? ((A.corkedRequestsFree = U.next), (U.next = null))
                        : (A.corkedRequestsFree = new a(A)),
                      (A.bufferedRequestCount = 0))
                  } else {
                    for (; j; ) {
                      var q = j.chunk,
                        D = j.encoding,
                        N = j.callback
                      if (
                        (M(S, A, !1, A.objectMode ? 1 : q.length, q, D, N),
                        (j = j.next),
                        A.bufferedRequestCount--,
                        A.writing)
                      )
                        break
                    }
                    j === null && (A.lastBufferedRequest = null)
                  }
                  ;((A.bufferedRequest = j), (A.bufferProcessing = !1))
                }
                function v(S) {
                  return (
                    S.ending &&
                    S.length === 0 &&
                    S.bufferedRequest === null &&
                    !S.finished &&
                    !S.writing
                  )
                }
                function x(S, A) {
                  S._final(function (j) {
                    ;(A.pendingcb--,
                      j && O(S, j),
                      (A.prefinished = !0),
                      S.emit('prefinish'),
                      _(S, A))
                  })
                }
                function _(S, A) {
                  var j = v(A)
                  if (
                    j &&
                    ((function (H, U) {
                      U.prefinished ||
                        U.finalCalled ||
                        (typeof H._final != 'function' || U.destroyed
                          ? ((U.prefinished = !0), H.emit('prefinish'))
                          : (U.pendingcb++, (U.finalCalled = !0), s.nextTick(x, H, U)))
                    })(S, A),
                    A.pendingcb === 0 && ((A.finished = !0), S.emit('finish'), A.autoDestroy))
                  ) {
                    var L = S._readableState
                    ;(!L || (L.autoDestroy && L.endEmitted)) && S.destroy()
                  }
                  return j
                }
                ;(t('inherits')(F, u),
                  ($.prototype.getBuffer = function () {
                    for (var S = this.bufferedRequest, A = []; S; ) (A.push(S), (S = S.next))
                    return A
                  }),
                  (function () {
                    try {
                      Object.defineProperty($.prototype, 'buffer', {
                        get: c.deprecate(
                          function () {
                            return this.getBuffer()
                          },
                          '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
                          'DEP0003',
                        ),
                      })
                    } catch {}
                  })(),
                  typeof Symbol == 'function' &&
                  Symbol.hasInstance &&
                  typeof Function.prototype[Symbol.hasInstance] == 'function'
                    ? ((h = Function.prototype[Symbol.hasInstance]),
                      Object.defineProperty(F, Symbol.hasInstance, {
                        value: function (S) {
                          return (
                            !!h.call(this, S) || (this === F && S && S._writableState instanceof $)
                          )
                        },
                      }))
                    : (h = function (S) {
                        return S instanceof this
                      }),
                  (F.prototype.pipe = function () {
                    O(this, new C())
                  }),
                  (F.prototype.write = function (S, A, j) {
                    var L,
                      H = this._writableState,
                      U = !1,
                      K = !H.objectMode && ((L = S), f.isBuffer(L) || L instanceof d)
                    return (
                      K &&
                        !f.isBuffer(S) &&
                        (S = (function (z) {
                          return f.from(z)
                        })(S)),
                      typeof A == 'function' && ((j = A), (A = null)),
                      K ? (A = 'buffer') : A || (A = H.defaultEncoding),
                      typeof j != 'function' && (j = P),
                      H.ending
                        ? (function (z, q) {
                            var D = new B()
                            ;(O(z, D), s.nextTick(q, D))
                          })(this, j)
                        : (K ||
                            (function (z, q, D, N) {
                              var V
                              return (
                                D === null
                                  ? (V = new I())
                                  : typeof D == 'string' ||
                                    q.objectMode ||
                                    (V = new y('chunk', ['string', 'Buffer'], D)),
                                !V || (O(z, V), s.nextTick(N, V), !1)
                              )
                            })(this, H, S, j)) &&
                          (H.pendingcb++,
                          (U = (function (z, q, D, N, V, W) {
                            if (!D) {
                              var J = (function (nt, X, Q) {
                                return (
                                  nt.objectMode ||
                                    nt.decodeStrings === !1 ||
                                    typeof X != 'string' ||
                                    (X = f.from(X, Q)),
                                  X
                                )
                              })(q, N, V)
                              N !== J && ((D = !0), (V = 'buffer'), (N = J))
                            }
                            var G = q.objectMode ? 1 : N.length
                            q.length += G
                            var Z = q.length < q.highWaterMark
                            if ((Z || (q.needDrain = !0), q.writing || q.corked)) {
                              var rt = q.lastBufferedRequest
                              ;((q.lastBufferedRequest = {
                                chunk: N,
                                encoding: V,
                                isBuf: D,
                                callback: W,
                                next: null,
                              }),
                                rt
                                  ? (rt.next = q.lastBufferedRequest)
                                  : (q.bufferedRequest = q.lastBufferedRequest),
                                (q.bufferedRequestCount += 1))
                            } else M(z, q, !1, G, N, V, W)
                            return Z
                          })(this, H, K, S, A, j))),
                      U
                    )
                  }),
                  (F.prototype.cork = function () {
                    this._writableState.corked++
                  }),
                  (F.prototype.uncork = function () {
                    var S = this._writableState
                    S.corked &&
                      (S.corked--,
                      S.writing ||
                        S.corked ||
                        S.bufferProcessing ||
                        !S.bufferedRequest ||
                        k(this, S))
                  }),
                  (F.prototype.setDefaultEncoding = function (S) {
                    if (
                      (typeof S == 'string' && (S = S.toLowerCase()),
                      !(
                        [
                          'hex',
                          'utf8',
                          'utf-8',
                          'ascii',
                          'binary',
                          'base64',
                          'ucs2',
                          'ucs-2',
                          'utf16le',
                          'utf-16le',
                          'raw',
                        ].indexOf((S + '').toLowerCase()) > -1
                      ))
                    )
                      throw new E(S)
                    return ((this._writableState.defaultEncoding = S), this)
                  }),
                  Object.defineProperty(F.prototype, 'writableBuffer', {
                    enumerable: !1,
                    get: function () {
                      return this._writableState && this._writableState.getBuffer()
                    },
                  }),
                  Object.defineProperty(F.prototype, 'writableHighWaterMark', {
                    enumerable: !1,
                    get: function () {
                      return this._writableState.highWaterMark
                    },
                  }),
                  (F.prototype._write = function (S, A, j) {
                    j(new b('_write()'))
                  }),
                  (F.prototype._writev = null),
                  (F.prototype.end = function (S, A, j) {
                    var L = this._writableState
                    return (
                      typeof S == 'function'
                        ? ((j = S), (S = null), (A = null))
                        : typeof A == 'function' && ((j = A), (A = null)),
                      S != null && this.write(S, A),
                      L.corked && ((L.corked = 1), this.uncork()),
                      L.ending ||
                        (function (H, U, K) {
                          ;((U.ending = !0),
                            _(H, U),
                            K && (U.finished ? s.nextTick(K) : H.once('finish', K)),
                            (U.ended = !0),
                            (H.writable = !1))
                        })(this, L, j),
                      this
                    )
                  }),
                  Object.defineProperty(F.prototype, 'writableLength', {
                    enumerable: !1,
                    get: function () {
                      return this._writableState.length
                    },
                  }),
                  Object.defineProperty(F.prototype, 'destroyed', {
                    enumerable: !1,
                    get: function () {
                      return this._writableState !== void 0 && this._writableState.destroyed
                    },
                    set: function (S) {
                      this._writableState && (this._writableState.destroyed = S)
                    },
                  }),
                  (F.prototype.destroy = p.destroy),
                  (F.prototype._undestroy = p.undestroy),
                  (F.prototype._destroy = function (S, A) {
                    A(S)
                  }))
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {
            '../errors': 477,
            './_stream_duplex': 478,
            './internal/streams/destroy': 485,
            './internal/streams/state': 489,
            './internal/streams/stream': 490,
            _process: 467,
            buffer: 220,
            inherits: 440,
            'util-deprecate': 524,
          },
        ],
        483: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o
                function a(T, I, B) {
                  return (
                    (I = (function (E) {
                      var O = (function (P, $) {
                        if (typeof P != 'object' || P === null) return P
                        var F = P[Symbol.toPrimitive]
                        if (F !== void 0) {
                          var M = F.call(P, $)
                          if (typeof M != 'object') return M
                          throw new TypeError('@@toPrimitive must return a primitive value.')
                        }
                        return ($ === 'string' ? String : Number)(P)
                      })(E, 'string')
                      return typeof O == 'symbol' ? O : String(O)
                    })(I)) in T
                      ? Object.defineProperty(T, I, {
                          value: B,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                        })
                      : (T[I] = B),
                    T
                  )
                }
                var l = t('./end-of-stream'),
                  c = Symbol('lastResolve'),
                  u = Symbol('lastReject'),
                  f = Symbol('error'),
                  d = Symbol('ended'),
                  h = Symbol('lastPromise'),
                  p = Symbol('handlePromise'),
                  g = Symbol('stream')
                function m(T, I) {
                  return { value: T, done: I }
                }
                function y(T) {
                  var I = T[c]
                  if (I !== null) {
                    var B = T[g].read()
                    B !== null && ((T[h] = null), (T[c] = null), (T[u] = null), I(m(B, !1)))
                  }
                }
                function b(T) {
                  s.nextTick(y, T)
                }
                var w = Object.getPrototypeOf(function () {}),
                  C = Object.setPrototypeOf(
                    (a(
                      (o = {
                        get stream() {
                          return this[g]
                        },
                        next: function () {
                          var T = this,
                            I = this[f]
                          if (I !== null) return Promise.reject(I)
                          if (this[d]) return Promise.resolve(m(void 0, !0))
                          if (this[g].destroyed)
                            return new Promise(function (P, $) {
                              s.nextTick(function () {
                                T[f] ? $(T[f]) : P(m(void 0, !0))
                              })
                            })
                          var B,
                            E = this[h]
                          if (E)
                            B = new Promise(
                              (function (P, $) {
                                return function (F, M) {
                                  P.then(function () {
                                    $[d] ? F(m(void 0, !0)) : $[p](F, M)
                                  }, M)
                                }
                              })(E, this),
                            )
                          else {
                            var O = this[g].read()
                            if (O !== null) return Promise.resolve(m(O, !1))
                            B = new Promise(this[p])
                          }
                          return ((this[h] = B), B)
                        },
                      }),
                      Symbol.asyncIterator,
                      function () {
                        return this
                      },
                    ),
                    a(o, 'return', function () {
                      var T = this
                      return new Promise(function (I, B) {
                        T[g].destroy(null, function (E) {
                          E ? B(E) : I(m(void 0, !0))
                        })
                      })
                    }),
                    o),
                    w,
                  )
                r.exports = function (T) {
                  var I,
                    B = Object.create(
                      C,
                      (a((I = {}), g, { value: T, writable: !0 }),
                      a(I, c, { value: null, writable: !0 }),
                      a(I, u, { value: null, writable: !0 }),
                      a(I, f, { value: null, writable: !0 }),
                      a(I, d, { value: T._readableState.endEmitted, writable: !0 }),
                      a(I, p, {
                        value: function (E, O) {
                          var P = B[g].read()
                          P
                            ? ((B[h] = null), (B[c] = null), (B[u] = null), E(m(P, !1)))
                            : ((B[c] = E), (B[u] = O))
                        },
                        writable: !0,
                      }),
                      I),
                    )
                  return (
                    (B[h] = null),
                    l(T, function (E) {
                      if (E && E.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
                        var O = B[u]
                        return (
                          O !== null && ((B[h] = null), (B[c] = null), (B[u] = null), O(E)),
                          void (B[f] = E)
                        )
                      }
                      var P = B[c]
                      ;(P !== null &&
                        ((B[h] = null), (B[c] = null), (B[u] = null), P(m(void 0, !0))),
                        (B[d] = !0))
                    }),
                    T.on('readable', b.bind(null, B)),
                    B
                  )
                }
              }).call(this)
            }).call(this, t('_process'))
          },
          { './end-of-stream': 486, _process: 467 },
        ],
        484: [
          function (t, r, i) {
            function s(h, p) {
              var g = Object.keys(h)
              if (Object.getOwnPropertySymbols) {
                var m = Object.getOwnPropertySymbols(h)
                ;(p &&
                  (m = m.filter(function (y) {
                    return Object.getOwnPropertyDescriptor(h, y).enumerable
                  })),
                  g.push.apply(g, m))
              }
              return g
            }
            function o(h) {
              for (var p = 1; p < arguments.length; p++) {
                var g = arguments[p] != null ? arguments[p] : {}
                p % 2
                  ? s(Object(g), !0).forEach(function (m) {
                      a(h, m, g[m])
                    })
                  : Object.getOwnPropertyDescriptors
                    ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(g))
                    : s(Object(g)).forEach(function (m) {
                        Object.defineProperty(h, m, Object.getOwnPropertyDescriptor(g, m))
                      })
              }
              return h
            }
            function a(h, p, g) {
              return (
                (p = c(p)) in h
                  ? Object.defineProperty(h, p, {
                      value: g,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (h[p] = g),
                h
              )
            }
            function l(h, p) {
              for (var g = 0; g < p.length; g++) {
                var m = p[g]
                ;((m.enumerable = m.enumerable || !1),
                  (m.configurable = !0),
                  'value' in m && (m.writable = !0),
                  Object.defineProperty(h, c(m.key), m))
              }
            }
            function c(h) {
              var p = (function (g, m) {
                if (typeof g != 'object' || g === null) return g
                var y = g[Symbol.toPrimitive]
                if (y !== void 0) {
                  var b = y.call(g, m)
                  if (typeof b != 'object') return b
                  throw new TypeError('@@toPrimitive must return a primitive value.')
                }
                return (m === 'string' ? String : Number)(g)
              })(h, 'string')
              return typeof p == 'symbol' ? p : String(p)
            }
            var u = t('buffer').Buffer,
              f = t('util').inspect,
              d = (f && f.custom) || 'inspect'
            r.exports = (function () {
              function h() {
                ;((function (m, y) {
                  if (!(m instanceof y)) throw new TypeError('Cannot call a class as a function')
                })(this, h),
                  (this.head = null),
                  (this.tail = null),
                  (this.length = 0))
              }
              var p, g
              return (
                (p = h),
                (g = [
                  {
                    key: 'push',
                    value: function (m) {
                      var y = { data: m, next: null }
                      ;(this.length > 0 ? (this.tail.next = y) : (this.head = y),
                        (this.tail = y),
                        ++this.length)
                    },
                  },
                  {
                    key: 'unshift',
                    value: function (m) {
                      var y = { data: m, next: this.head }
                      ;(this.length === 0 && (this.tail = y), (this.head = y), ++this.length)
                    },
                  },
                  {
                    key: 'shift',
                    value: function () {
                      if (this.length !== 0) {
                        var m = this.head.data
                        return (
                          this.length === 1
                            ? (this.head = this.tail = null)
                            : (this.head = this.head.next),
                          --this.length,
                          m
                        )
                      }
                    },
                  },
                  {
                    key: 'clear',
                    value: function () {
                      ;((this.head = this.tail = null), (this.length = 0))
                    },
                  },
                  {
                    key: 'join',
                    value: function (m) {
                      if (this.length === 0) return ''
                      for (var y = this.head, b = '' + y.data; (y = y.next); ) b += m + y.data
                      return b
                    },
                  },
                  {
                    key: 'concat',
                    value: function (m) {
                      if (this.length === 0) return u.alloc(0)
                      for (var y, b, w, C = u.allocUnsafe(m >>> 0), T = this.head, I = 0; T; )
                        ((y = T.data),
                          (b = C),
                          (w = I),
                          u.prototype.copy.call(y, b, w),
                          (I += T.data.length),
                          (T = T.next))
                      return C
                    },
                  },
                  {
                    key: 'consume',
                    value: function (m, y) {
                      var b
                      return (
                        m < this.head.data.length
                          ? ((b = this.head.data.slice(0, m)),
                            (this.head.data = this.head.data.slice(m)))
                          : (b =
                              m === this.head.data.length
                                ? this.shift()
                                : y
                                  ? this._getString(m)
                                  : this._getBuffer(m)),
                        b
                      )
                    },
                  },
                  {
                    key: 'first',
                    value: function () {
                      return this.head.data
                    },
                  },
                  {
                    key: '_getString',
                    value: function (m) {
                      var y = this.head,
                        b = 1,
                        w = y.data
                      for (m -= w.length; (y = y.next); ) {
                        var C = y.data,
                          T = m > C.length ? C.length : m
                        if ((T === C.length ? (w += C) : (w += C.slice(0, m)), (m -= T) == 0)) {
                          T === C.length
                            ? (++b, y.next ? (this.head = y.next) : (this.head = this.tail = null))
                            : ((this.head = y), (y.data = C.slice(T)))
                          break
                        }
                        ++b
                      }
                      return ((this.length -= b), w)
                    },
                  },
                  {
                    key: '_getBuffer',
                    value: function (m) {
                      var y = u.allocUnsafe(m),
                        b = this.head,
                        w = 1
                      for (b.data.copy(y), m -= b.data.length; (b = b.next); ) {
                        var C = b.data,
                          T = m > C.length ? C.length : m
                        if ((C.copy(y, y.length - m, 0, T), (m -= T) == 0)) {
                          T === C.length
                            ? (++w, b.next ? (this.head = b.next) : (this.head = this.tail = null))
                            : ((this.head = b), (b.data = C.slice(T)))
                          break
                        }
                        ++w
                      }
                      return ((this.length -= w), y)
                    },
                  },
                  {
                    key: d,
                    value: function (m, y) {
                      return f(this, o(o({}, y), {}, { depth: 0, customInspect: !1 }))
                    },
                  },
                ]) && l(p.prototype, g),
                Object.defineProperty(p, 'prototype', { writable: !1 }),
                h
              )
            })()
          },
          { buffer: 220, util: 188 },
        ],
        485: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                function o(c, u) {
                  ;(l(c, u), a(c))
                }
                function a(c) {
                  ;(c._writableState && !c._writableState.emitClose) ||
                    (c._readableState && !c._readableState.emitClose) ||
                    c.emit('close')
                }
                function l(c, u) {
                  c.emit('error', u)
                }
                r.exports = {
                  destroy: function (c, u) {
                    var f = this,
                      d = this._readableState && this._readableState.destroyed,
                      h = this._writableState && this._writableState.destroyed
                    return d || h
                      ? (u
                          ? u(c)
                          : c &&
                            (this._writableState
                              ? this._writableState.errorEmitted ||
                                ((this._writableState.errorEmitted = !0), s.nextTick(l, this, c))
                              : s.nextTick(l, this, c)),
                        this)
                      : (this._readableState && (this._readableState.destroyed = !0),
                        this._writableState && (this._writableState.destroyed = !0),
                        this._destroy(c || null, function (p) {
                          !u && p
                            ? f._writableState
                              ? f._writableState.errorEmitted
                                ? s.nextTick(a, f)
                                : ((f._writableState.errorEmitted = !0), s.nextTick(o, f, p))
                              : s.nextTick(o, f, p)
                            : u
                              ? (s.nextTick(a, f), u(p))
                              : s.nextTick(a, f)
                        }),
                        this)
                  },
                  undestroy: function () {
                    ;(this._readableState &&
                      ((this._readableState.destroyed = !1),
                      (this._readableState.reading = !1),
                      (this._readableState.ended = !1),
                      (this._readableState.endEmitted = !1)),
                      this._writableState &&
                        ((this._writableState.destroyed = !1),
                        (this._writableState.ended = !1),
                        (this._writableState.ending = !1),
                        (this._writableState.finalCalled = !1),
                        (this._writableState.prefinished = !1),
                        (this._writableState.finished = !1),
                        (this._writableState.errorEmitted = !1)))
                  },
                  errorOrDestroy: function (c, u) {
                    var f = c._readableState,
                      d = c._writableState
                    ;(f && f.autoDestroy) || (d && d.autoDestroy)
                      ? c.destroy(u)
                      : c.emit('error', u)
                  },
                }
              }).call(this)
            }).call(this, t('_process'))
          },
          { _process: 467 },
        ],
        486: [
          function (t, r, i) {
            var s = t('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE
            function o() {}
            r.exports = function a(l, c, u) {
              if (typeof c == 'function') return a(l, null, c)
              ;(c || (c = {}),
                (u = (function (T) {
                  var I = !1
                  return function () {
                    if (!I) {
                      I = !0
                      for (var B = arguments.length, E = new Array(B), O = 0; O < B; O++)
                        E[O] = arguments[O]
                      T.apply(this, E)
                    }
                  }
                })(u || o)))
              var f = c.readable || (c.readable !== !1 && l.readable),
                d = c.writable || (c.writable !== !1 && l.writable),
                h = function () {
                  l.writable || g()
                },
                p = l._writableState && l._writableState.finished,
                g = function () {
                  ;((d = !1), (p = !0), f || u.call(l))
                },
                m = l._readableState && l._readableState.endEmitted,
                y = function () {
                  ;((f = !1), (m = !0), d || u.call(l))
                },
                b = function (T) {
                  u.call(l, T)
                },
                w = function () {
                  var T
                  return f && !m
                    ? ((l._readableState && l._readableState.ended) || (T = new s()), u.call(l, T))
                    : d && !p
                      ? ((l._writableState && l._writableState.ended) || (T = new s()),
                        u.call(l, T))
                      : void 0
                },
                C = function () {
                  l.req.on('finish', g)
                }
              return (
                (function (T) {
                  return T.setHeader && typeof T.abort == 'function'
                })(l)
                  ? (l.on('complete', g), l.on('abort', w), l.req ? C() : l.on('request', C))
                  : d && !l._writableState && (l.on('end', h), l.on('close', h)),
                l.on('end', y),
                l.on('finish', g),
                c.error !== !1 && l.on('error', b),
                l.on('close', w),
                function () {
                  ;(l.removeListener('complete', g),
                    l.removeListener('abort', w),
                    l.removeListener('request', C),
                    l.req && l.req.removeListener('finish', g),
                    l.removeListener('end', h),
                    l.removeListener('close', h),
                    l.removeListener('finish', g),
                    l.removeListener('end', y),
                    l.removeListener('error', b),
                    l.removeListener('close', w))
                }
              )
            }
          },
          { '../../../errors': 477 },
        ],
        487: [
          function (t, r, i) {
            r.exports = function () {
              throw new Error('Readable.from is not available in the browser')
            }
          },
          {},
        ],
        488: [
          function (t, r, i) {
            var s,
              o = t('../../../errors').codes,
              a = o.ERR_MISSING_ARGS,
              l = o.ERR_STREAM_DESTROYED
            function c(p) {
              if (p) throw p
            }
            function u(p, g, m, y) {
              y = (function (C) {
                var T = !1
                return function () {
                  T || ((T = !0), C.apply(void 0, arguments))
                }
              })(y)
              var b = !1
              ;(p.on('close', function () {
                b = !0
              }),
                s === void 0 && (s = t('./end-of-stream')),
                s(p, { readable: g, writable: m }, function (C) {
                  if (C) return y(C)
                  ;((b = !0), y())
                }))
              var w = !1
              return function (C) {
                if (!b && !w)
                  return (
                    (w = !0),
                    (function (T) {
                      return T.setHeader && typeof T.abort == 'function'
                    })(p)
                      ? p.abort()
                      : typeof p.destroy == 'function'
                        ? p.destroy()
                        : void y(C || new l('pipe'))
                  )
              }
            }
            function f(p) {
              p()
            }
            function d(p, g) {
              return p.pipe(g)
            }
            function h(p) {
              return p.length ? (typeof p[p.length - 1] != 'function' ? c : p.pop()) : c
            }
            r.exports = function () {
              for (var p = arguments.length, g = new Array(p), m = 0; m < p; m++)
                g[m] = arguments[m]
              var y,
                b = h(g)
              if ((Array.isArray(g[0]) && (g = g[0]), g.length < 2)) throw new a('streams')
              var w = g.map(function (C, T) {
                var I = T < g.length - 1
                return u(C, I, T > 0, function (B) {
                  ;(y || (y = B), B && w.forEach(f), I || (w.forEach(f), b(y)))
                })
              })
              return g.reduce(d)
            }
          },
          { '../../../errors': 477, './end-of-stream': 486 },
        ],
        489: [
          function (t, r, i) {
            var s = t('../../../errors').codes.ERR_INVALID_OPT_VALUE
            r.exports = {
              getHighWaterMark: function (o, a, l, c) {
                var u = (function (f, d, h) {
                  return f.highWaterMark != null ? f.highWaterMark : d ? f[h] : null
                })(a, c, l)
                if (u != null) {
                  if (!isFinite(u) || Math.floor(u) !== u || u < 0)
                    throw new s(c ? l : 'highWaterMark', u)
                  return Math.floor(u)
                }
                return o.objectMode ? 16 : 16384
              },
            }
          },
          { '../../../errors': 477 },
        ],
        490: [
          function (t, r, i) {
            r.exports = t('events').EventEmitter
          },
          { events: 422 },
        ],
        491: [
          function (t, r, i) {
            ;(((i = r.exports = t('./lib/_stream_readable.js')).Stream = i),
              (i.Readable = i),
              (i.Writable = t('./lib/_stream_writable.js')),
              (i.Duplex = t('./lib/_stream_duplex.js')),
              (i.Transform = t('./lib/_stream_transform.js')),
              (i.PassThrough = t('./lib/_stream_passthrough.js')),
              (i.finished = t('./lib/internal/streams/end-of-stream.js')),
              (i.pipeline = t('./lib/internal/streams/pipeline.js')))
          },
          {
            './lib/_stream_duplex.js': 478,
            './lib/_stream_passthrough.js': 479,
            './lib/_stream_readable.js': 480,
            './lib/_stream_transform.js': 481,
            './lib/_stream_writable.js': 482,
            './lib/internal/streams/end-of-stream.js': 486,
            './lib/internal/streams/pipeline.js': 488,
          },
        ],
        492: [
          function (t, r, i) {
            var s = (function (o) {
              var a = Object.prototype,
                l = a.hasOwnProperty,
                c =
                  Object.defineProperty ||
                  function (_, S, A) {
                    _[S] = A.value
                  },
                u = typeof Symbol == 'function' ? Symbol : {},
                f = u.iterator || '@@iterator',
                d = u.asyncIterator || '@@asyncIterator',
                h = u.toStringTag || '@@toStringTag'
              function p(_, S, A) {
                return (
                  Object.defineProperty(_, S, {
                    value: A,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  }),
                  _[S]
                )
              }
              try {
                p({}, '')
              } catch {
                p = function (S, A, j) {
                  return (S[A] = j)
                }
              }
              function g(_, S, A, j) {
                var L = S && S.prototype instanceof b ? S : b,
                  H = Object.create(L.prototype),
                  U = new k(j || [])
                return (c(H, '_invoke', { value: $(_, A, U) }), H)
              }
              function m(_, S, A) {
                try {
                  return { type: 'normal', arg: _.call(S, A) }
                } catch (j) {
                  return { type: 'throw', arg: j }
                }
              }
              o.wrap = g
              var y = {}
              function b() {}
              function w() {}
              function C() {}
              var T = {}
              p(T, f, function () {
                return this
              })
              var I = Object.getPrototypeOf,
                B = I && I(I(v([])))
              B && B !== a && l.call(B, f) && (T = B)
              var E = (C.prototype = b.prototype = Object.create(T))
              function O(_) {
                ;['next', 'throw', 'return'].forEach(function (S) {
                  p(_, S, function (A) {
                    return this._invoke(S, A)
                  })
                })
              }
              function P(_, S) {
                var A
                c(this, '_invoke', {
                  value: function (j, L) {
                    function H() {
                      return new S(function (U, K) {
                        ;(function z(q, D, N, V) {
                          var W = m(_[q], _, D)
                          if (W.type !== 'throw') {
                            var J = W.arg,
                              G = J.value
                            return G && typeof G == 'object' && l.call(G, '__await')
                              ? S.resolve(G.__await).then(
                                  function (Z) {
                                    z('next', Z, N, V)
                                  },
                                  function (Z) {
                                    z('throw', Z, N, V)
                                  },
                                )
                              : S.resolve(G).then(
                                  function (Z) {
                                    ;((J.value = Z), N(J))
                                  },
                                  function (Z) {
                                    return z('throw', Z, N, V)
                                  },
                                )
                          }
                          V(W.arg)
                        })(j, L, U, K)
                      })
                    }
                    return (A = A ? A.then(H, H) : H())
                  },
                })
              }
              function $(_, S, A) {
                var j = 'suspendedStart'
                return function (L, H) {
                  if (j === 'executing') throw new Error('Generator is already running')
                  if (j === 'completed') {
                    if (L === 'throw') throw H
                    return x()
                  }
                  for (A.method = L, A.arg = H; ; ) {
                    var U = A.delegate
                    if (U) {
                      var K = F(U, A)
                      if (K) {
                        if (K === y) continue
                        return K
                      }
                    }
                    if (A.method === 'next') A.sent = A._sent = A.arg
                    else if (A.method === 'throw') {
                      if (j === 'suspendedStart') throw ((j = 'completed'), A.arg)
                      A.dispatchException(A.arg)
                    } else A.method === 'return' && A.abrupt('return', A.arg)
                    j = 'executing'
                    var z = m(_, S, A)
                    if (z.type === 'normal') {
                      if (((j = A.done ? 'completed' : 'suspendedYield'), z.arg === y)) continue
                      return { value: z.arg, done: A.done }
                    }
                    z.type === 'throw' && ((j = 'completed'), (A.method = 'throw'), (A.arg = z.arg))
                  }
                }
              }
              function F(_, S) {
                var A = S.method,
                  j = _.iterator[A]
                if (j === void 0)
                  return (
                    (S.delegate = null),
                    (A === 'throw' &&
                      _.iterator.return &&
                      ((S.method = 'return'), (S.arg = void 0), F(_, S), S.method === 'throw')) ||
                      (A !== 'return' &&
                        ((S.method = 'throw'),
                        (S.arg = new TypeError(
                          "The iterator does not provide a '" + A + "' method",
                        )))),
                    y
                  )
                var L = m(j, _.iterator, S.arg)
                if (L.type === 'throw')
                  return ((S.method = 'throw'), (S.arg = L.arg), (S.delegate = null), y)
                var H = L.arg
                return H
                  ? H.done
                    ? ((S[_.resultName] = H.value),
                      (S.next = _.nextLoc),
                      S.method !== 'return' && ((S.method = 'next'), (S.arg = void 0)),
                      (S.delegate = null),
                      y)
                    : H
                  : ((S.method = 'throw'),
                    (S.arg = new TypeError('iterator result is not an object')),
                    (S.delegate = null),
                    y)
              }
              function M(_) {
                var S = { tryLoc: _[0] }
                ;(1 in _ && (S.catchLoc = _[1]),
                  2 in _ && ((S.finallyLoc = _[2]), (S.afterLoc = _[3])),
                  this.tryEntries.push(S))
              }
              function R(_) {
                var S = _.completion || {}
                ;((S.type = 'normal'), delete S.arg, (_.completion = S))
              }
              function k(_) {
                ;((this.tryEntries = [{ tryLoc: 'root' }]), _.forEach(M, this), this.reset(!0))
              }
              function v(_) {
                if (_) {
                  var S = _[f]
                  if (S) return S.call(_)
                  if (typeof _.next == 'function') return _
                  if (!isNaN(_.length)) {
                    var A = -1,
                      j = function L() {
                        for (; ++A < _.length; )
                          if (l.call(_, A)) return ((L.value = _[A]), (L.done = !1), L)
                        return ((L.value = void 0), (L.done = !0), L)
                      }
                    return (j.next = j)
                  }
                }
                return { next: x }
              }
              function x() {
                return { value: void 0, done: !0 }
              }
              return (
                (w.prototype = C),
                c(E, 'constructor', { value: C, configurable: !0 }),
                c(C, 'constructor', { value: w, configurable: !0 }),
                (w.displayName = p(C, h, 'GeneratorFunction')),
                (o.isGeneratorFunction = function (_) {
                  var S = typeof _ == 'function' && _.constructor
                  return !!S && (S === w || (S.displayName || S.name) === 'GeneratorFunction')
                }),
                (o.mark = function (_) {
                  return (
                    Object.setPrototypeOf
                      ? Object.setPrototypeOf(_, C)
                      : ((_.__proto__ = C), p(_, h, 'GeneratorFunction')),
                    (_.prototype = Object.create(E)),
                    _
                  )
                }),
                (o.awrap = function (_) {
                  return { __await: _ }
                }),
                O(P.prototype),
                p(P.prototype, d, function () {
                  return this
                }),
                (o.AsyncIterator = P),
                (o.async = function (_, S, A, j, L) {
                  L === void 0 && (L = Promise)
                  var H = new P(g(_, S, A, j), L)
                  return o.isGeneratorFunction(S)
                    ? H
                    : H.next().then(function (U) {
                        return U.done ? U.value : H.next()
                      })
                }),
                O(E),
                p(E, h, 'Generator'),
                p(E, f, function () {
                  return this
                }),
                p(E, 'toString', function () {
                  return '[object Generator]'
                }),
                (o.keys = function (_) {
                  var S = Object(_),
                    A = []
                  for (var j in S) A.push(j)
                  return (
                    A.reverse(),
                    function L() {
                      for (; A.length; ) {
                        var H = A.pop()
                        if (H in S) return ((L.value = H), (L.done = !1), L)
                      }
                      return ((L.done = !0), L)
                    }
                  )
                }),
                (o.values = v),
                (k.prototype = {
                  constructor: k,
                  reset: function (_) {
                    if (
                      ((this.prev = 0),
                      (this.next = 0),
                      (this.sent = this._sent = void 0),
                      (this.done = !1),
                      (this.delegate = null),
                      (this.method = 'next'),
                      (this.arg = void 0),
                      this.tryEntries.forEach(R),
                      !_)
                    )
                      for (var S in this)
                        S.charAt(0) === 't' &&
                          l.call(this, S) &&
                          !isNaN(+S.slice(1)) &&
                          (this[S] = void 0)
                  },
                  stop: function () {
                    this.done = !0
                    var _ = this.tryEntries[0].completion
                    if (_.type === 'throw') throw _.arg
                    return this.rval
                  },
                  dispatchException: function (_) {
                    if (this.done) throw _
                    var S = this
                    function A(z, q) {
                      return (
                        (H.type = 'throw'),
                        (H.arg = _),
                        (S.next = z),
                        q && ((S.method = 'next'), (S.arg = void 0)),
                        !!q
                      )
                    }
                    for (var j = this.tryEntries.length - 1; j >= 0; --j) {
                      var L = this.tryEntries[j],
                        H = L.completion
                      if (L.tryLoc === 'root') return A('end')
                      if (L.tryLoc <= this.prev) {
                        var U = l.call(L, 'catchLoc'),
                          K = l.call(L, 'finallyLoc')
                        if (U && K) {
                          if (this.prev < L.catchLoc) return A(L.catchLoc, !0)
                          if (this.prev < L.finallyLoc) return A(L.finallyLoc)
                        } else if (U) {
                          if (this.prev < L.catchLoc) return A(L.catchLoc, !0)
                        } else {
                          if (!K) throw new Error('try statement without catch or finally')
                          if (this.prev < L.finallyLoc) return A(L.finallyLoc)
                        }
                      }
                    }
                  },
                  abrupt: function (_, S) {
                    for (var A = this.tryEntries.length - 1; A >= 0; --A) {
                      var j = this.tryEntries[A]
                      if (
                        j.tryLoc <= this.prev &&
                        l.call(j, 'finallyLoc') &&
                        this.prev < j.finallyLoc
                      ) {
                        var L = j
                        break
                      }
                    }
                    L &&
                      (_ === 'break' || _ === 'continue') &&
                      L.tryLoc <= S &&
                      S <= L.finallyLoc &&
                      (L = null)
                    var H = L ? L.completion : {}
                    return (
                      (H.type = _),
                      (H.arg = S),
                      L ? ((this.method = 'next'), (this.next = L.finallyLoc), y) : this.complete(H)
                    )
                  },
                  complete: function (_, S) {
                    if (_.type === 'throw') throw _.arg
                    return (
                      _.type === 'break' || _.type === 'continue'
                        ? (this.next = _.arg)
                        : _.type === 'return'
                          ? ((this.rval = this.arg = _.arg),
                            (this.method = 'return'),
                            (this.next = 'end'))
                          : _.type === 'normal' && S && (this.next = S),
                      y
                    )
                  },
                  finish: function (_) {
                    for (var S = this.tryEntries.length - 1; S >= 0; --S) {
                      var A = this.tryEntries[S]
                      if (A.finallyLoc === _)
                        return (this.complete(A.completion, A.afterLoc), R(A), y)
                    }
                  },
                  catch: function (_) {
                    for (var S = this.tryEntries.length - 1; S >= 0; --S) {
                      var A = this.tryEntries[S]
                      if (A.tryLoc === _) {
                        var j = A.completion
                        if (j.type === 'throw') {
                          var L = j.arg
                          R(A)
                        }
                        return L
                      }
                    }
                    throw new Error('illegal catch attempt')
                  },
                  delegateYield: function (_, S, A) {
                    return (
                      (this.delegate = { iterator: v(_), resultName: S, nextLoc: A }),
                      this.method === 'next' && (this.arg = void 0),
                      y
                    )
                  },
                }),
                o
              )
            })(typeof r == 'object' ? r.exports : {})
            try {
              regeneratorRuntime = s
            } catch {
              typeof globalThis == 'object'
                ? (globalThis.regeneratorRuntime = s)
                : Function('r', 'regeneratorRuntime = r')(s)
            }
          },
          {},
        ],
        493: [
          function (t, r, i) {
            var s = t('buffer').Buffer,
              o = t('inherits'),
              a = t('hash-base'),
              l = new Array(16),
              c = [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12,
                0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9,
                11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3,
                8, 11, 6, 15, 13,
              ],
              u = [
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14,
                15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6,
                4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13,
                14, 0, 3, 9, 11,
              ],
              f = [
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15,
                7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12,
                5, 12, 13, 14, 11, 8, 5, 6,
              ],
              d = [
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11,
                7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6,
                8, 13, 6, 5, 15, 13, 11, 11,
              ],
              h = [0, 1518500249, 1859775393, 2400959708, 2840853838],
              p = [1352829926, 1548603684, 1836072691, 2053994217, 0]
            function g() {
              ;(a.call(this, 64),
                (this._a = 1732584193),
                (this._b = 4023233417),
                (this._c = 2562383102),
                (this._d = 271733878),
                (this._e = 3285377520))
            }
            function m(I, B) {
              return (I << B) | (I >>> (32 - B))
            }
            function y(I, B, E, O, P, $, F, M) {
              return (m((I + (B ^ E ^ O) + $ + F) | 0, M) + P) | 0
            }
            function b(I, B, E, O, P, $, F, M) {
              return (m((I + ((B & E) | (~B & O)) + $ + F) | 0, M) + P) | 0
            }
            function w(I, B, E, O, P, $, F, M) {
              return (m((I + ((B | ~E) ^ O) + $ + F) | 0, M) + P) | 0
            }
            function C(I, B, E, O, P, $, F, M) {
              return (m((I + ((B & O) | (E & ~O)) + $ + F) | 0, M) + P) | 0
            }
            function T(I, B, E, O, P, $, F, M) {
              return (m((I + (B ^ (E | ~O)) + $ + F) | 0, M) + P) | 0
            }
            ;(o(g, a),
              (g.prototype._update = function () {
                for (var I = l, B = 0; B < 16; ++B) I[B] = this._block.readInt32LE(4 * B)
                for (
                  var E = 0 | this._a,
                    O = 0 | this._b,
                    P = 0 | this._c,
                    $ = 0 | this._d,
                    F = 0 | this._e,
                    M = 0 | this._a,
                    R = 0 | this._b,
                    k = 0 | this._c,
                    v = 0 | this._d,
                    x = 0 | this._e,
                    _ = 0;
                  _ < 80;
                  _ += 1
                ) {
                  var S, A
                  ;(_ < 16
                    ? ((S = y(E, O, P, $, F, I[c[_]], h[0], f[_])),
                      (A = T(M, R, k, v, x, I[u[_]], p[0], d[_])))
                    : _ < 32
                      ? ((S = b(E, O, P, $, F, I[c[_]], h[1], f[_])),
                        (A = C(M, R, k, v, x, I[u[_]], p[1], d[_])))
                      : _ < 48
                        ? ((S = w(E, O, P, $, F, I[c[_]], h[2], f[_])),
                          (A = w(M, R, k, v, x, I[u[_]], p[2], d[_])))
                        : _ < 64
                          ? ((S = C(E, O, P, $, F, I[c[_]], h[3], f[_])),
                            (A = b(M, R, k, v, x, I[u[_]], p[3], d[_])))
                          : ((S = T(E, O, P, $, F, I[c[_]], h[4], f[_])),
                            (A = y(M, R, k, v, x, I[u[_]], p[4], d[_]))),
                    (E = F),
                    (F = $),
                    ($ = m(P, 10)),
                    (P = O),
                    (O = S),
                    (M = x),
                    (x = v),
                    (v = m(k, 10)),
                    (k = R),
                    (R = A))
                }
                var j = (this._b + P + v) | 0
                ;((this._b = (this._c + $ + x) | 0),
                  (this._c = (this._d + F + M) | 0),
                  (this._d = (this._e + E + R) | 0),
                  (this._e = (this._a + O + k) | 0),
                  (this._a = j))
              }),
              (g.prototype._digest = function () {
                ;((this._block[this._blockOffset++] = 128),
                  this._blockOffset > 56 &&
                    (this._block.fill(0, this._blockOffset, 64),
                    this._update(),
                    (this._blockOffset = 0)),
                  this._block.fill(0, this._blockOffset, 56),
                  this._block.writeUInt32LE(this._length[0], 56),
                  this._block.writeUInt32LE(this._length[1], 60),
                  this._update())
                var I = s.alloc ? s.alloc(20) : new s(20)
                return (
                  I.writeInt32LE(this._a, 0),
                  I.writeInt32LE(this._b, 4),
                  I.writeInt32LE(this._c, 8),
                  I.writeInt32LE(this._d, 12),
                  I.writeInt32LE(this._e, 16),
                  I
                )
              }),
              (r.exports = g))
          },
          { buffer: 220, 'hash-base': 425, inherits: 440 },
        ],
        494: [
          function (t, r, i) {
            /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var s =
                t('buffer'),
              o = s.Buffer
            function a(c, u) {
              for (var f in c) u[f] = c[f]
            }
            function l(c, u, f) {
              return o(c, u, f)
            }
            ;(o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow
              ? (r.exports = s)
              : (a(s, i), (i.Buffer = l)),
              (l.prototype = Object.create(o.prototype)),
              a(o, l),
              (l.from = function (c, u, f) {
                if (typeof c == 'number') throw new TypeError('Argument must not be a number')
                return o(c, u, f)
              }),
              (l.alloc = function (c, u, f) {
                if (typeof c != 'number') throw new TypeError('Argument must be a number')
                var d = o(c)
                return (
                  u !== void 0 ? (typeof f == 'string' ? d.fill(u, f) : d.fill(u)) : d.fill(0),
                  d
                )
              }),
              (l.allocUnsafe = function (c) {
                if (typeof c != 'number') throw new TypeError('Argument must be a number')
                return o(c)
              }),
              (l.allocUnsafeSlow = function (c) {
                if (typeof c != 'number') throw new TypeError('Argument must be a number')
                return s.SlowBuffer(c)
              }))
          },
          { buffer: 220 },
        ],
        495: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                var o,
                  a = t('buffer'),
                  l = a.Buffer,
                  c = {}
                for (o in a)
                  a.hasOwnProperty(o) && o !== 'SlowBuffer' && o !== 'Buffer' && (c[o] = a[o])
                var u = (c.Buffer = {})
                for (o in l)
                  l.hasOwnProperty(o) &&
                    o !== 'allocUnsafe' &&
                    o !== 'allocUnsafeSlow' &&
                    (u[o] = l[o])
                if (
                  ((c.Buffer.prototype = l.prototype),
                  (u.from && u.from !== Uint8Array.from) ||
                    (u.from = function (f, d, h) {
                      if (typeof f == 'number')
                        throw new TypeError(
                          'The "value" argument must not be of type number. Received type ' +
                            typeof f,
                        )
                      if (f && f.length === void 0)
                        throw new TypeError(
                          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                            typeof f,
                        )
                      return l(f, d, h)
                    }),
                  u.alloc ||
                    (u.alloc = function (f, d, h) {
                      if (typeof f != 'number')
                        throw new TypeError(
                          'The "size" argument must be of type number. Received type ' + typeof f,
                        )
                      if (f < 0 || f >= 2 * (1 << 30))
                        throw new RangeError('The value "' + f + '" is invalid for option "size"')
                      var p = l(f)
                      return (
                        d && d.length !== 0
                          ? typeof h == 'string'
                            ? p.fill(d, h)
                            : p.fill(d)
                          : p.fill(0),
                        p
                      )
                    }),
                  !c.kStringMaxLength)
                )
                  try {
                    c.kStringMaxLength = s.binding('buffer').kStringMaxLength
                  } catch {}
                ;(c.constants ||
                  ((c.constants = { MAX_LENGTH: c.kMaxLength }),
                  c.kStringMaxLength && (c.constants.MAX_STRING_LENGTH = c.kStringMaxLength)),
                  (r.exports = c))
              }).call(this)
            }).call(this, t('_process'))
          },
          { _process: 467, buffer: 220 },
        ],
        496: [
          function (t, r, i) {
            Object.defineProperty(i, '__esModule', { value: !0 })
            const s = t('xmlchars/xml/1.0/ed5'),
              o = t('xmlchars/xml/1.1/ed2'),
              a = t('xmlchars/xmlns/1.0/ed3')
            var l = s.isS,
              c = s.isChar,
              u = s.isNameStartChar,
              f = s.isNameChar,
              d = s.S_LIST,
              h = s.NAME_RE,
              p = o.isChar,
              g = a.isNCNameStartChar,
              m = a.isNCNameChar,
              y = a.NC_NAME_RE
            const b = 'http://www.w3.org/XML/1998/namespace',
              w = 'http://www.w3.org/2000/xmlns/',
              C = { __proto__: null, xml: b, xmlns: w },
              T = { __proto__: null, amp: '&', gt: '>', lt: '<', quot: '"', apos: "'" },
              I = (v) => v === 34 || v === 39,
              B = [34, 39],
              E = [...B, 91, 62],
              O = [...B, 60, 93],
              P = [61, 63, ...d],
              $ = [...d, 62, 38, 60]
            function F(v, x, _) {
              switch (x) {
                case 'xml':
                  _ !== b && v.fail(`xml prefix must be bound to ${b}.`)
                  break
                case 'xmlns':
                  _ !== w && v.fail(`xmlns prefix must be bound to ${w}.`)
              }
              switch (_) {
                case w:
                  v.fail(
                    x === ''
                      ? `the default namespace may not be set to ${_}.`
                      : `may not assign a prefix (even "xmlns") to the URI ${w}.`,
                  )
                  break
                case b:
                  switch (x) {
                    case 'xml':
                      break
                    case '':
                      v.fail(`the default namespace may not be set to ${_}.`)
                      break
                    default:
                      v.fail('may not assign the xml namespace to another prefix.')
                  }
              }
            }
            const M = (v) => y.test(v),
              R = (v) => h.test(v)
            i.EVENTS = [
              'xmldecl',
              'text',
              'processinginstruction',
              'doctype',
              'comment',
              'opentagstart',
              'attribute',
              'opentag',
              'closetag',
              'cdata',
              'error',
              'end',
              'ready',
            ]
            const k = {
              xmldecl: 'xmldeclHandler',
              text: 'textHandler',
              processinginstruction: 'piHandler',
              doctype: 'doctypeHandler',
              comment: 'commentHandler',
              opentagstart: 'openTagStartHandler',
              attribute: 'attributeHandler',
              opentag: 'openTagHandler',
              closetag: 'closeTagHandler',
              cdata: 'cdataHandler',
              error: 'errorHandler',
              end: 'endHandler',
              ready: 'readyHandler',
            }
            i.SaxesParser = class {
              constructor(v) {
                ;((this.opt = v ?? {}), (this.fragmentOpt = !!this.opt.fragment))
                const x = (this.xmlnsOpt = !!this.opt.xmlns)
                if (
                  ((this.trackPosition = this.opt.position !== !1),
                  (this.fileName = this.opt.fileName),
                  x)
                ) {
                  ;((this.nameStartCheck = g),
                    (this.nameCheck = m),
                    (this.isName = M),
                    (this.processAttribs = this.processAttribsNS),
                    (this.pushAttrib = this.pushAttribNS),
                    (this.ns = Object.assign({ __proto__: null }, C)))
                  const _ = this.opt.additionalNamespaces
                  _ != null &&
                    ((function (S, A) {
                      for (const j of Object.keys(A)) F(S, j, A[j])
                    })(this, _),
                    Object.assign(this.ns, _))
                } else
                  ((this.nameStartCheck = u),
                    (this.nameCheck = f),
                    (this.isName = R),
                    (this.processAttribs = this.processAttribsPlain),
                    (this.pushAttrib = this.pushAttribPlain))
                ;((this.stateTable = [
                  this.sBegin,
                  this.sBeginWhitespace,
                  this.sDoctype,
                  this.sDoctypeQuote,
                  this.sDTD,
                  this.sDTDQuoted,
                  this.sDTDOpenWaka,
                  this.sDTDOpenWakaBang,
                  this.sDTDComment,
                  this.sDTDCommentEnding,
                  this.sDTDCommentEnded,
                  this.sDTDPI,
                  this.sDTDPIEnding,
                  this.sText,
                  this.sEntity,
                  this.sOpenWaka,
                  this.sOpenWakaBang,
                  this.sComment,
                  this.sCommentEnding,
                  this.sCommentEnded,
                  this.sCData,
                  this.sCDataEnding,
                  this.sCDataEnding2,
                  this.sPIFirstChar,
                  this.sPIRest,
                  this.sPIBody,
                  this.sPIEnding,
                  this.sXMLDeclNameStart,
                  this.sXMLDeclName,
                  this.sXMLDeclEq,
                  this.sXMLDeclValueStart,
                  this.sXMLDeclValue,
                  this.sXMLDeclSeparator,
                  this.sXMLDeclEnding,
                  this.sOpenTag,
                  this.sOpenTagSlash,
                  this.sAttrib,
                  this.sAttribName,
                  this.sAttribNameSawWhite,
                  this.sAttribValue,
                  this.sAttribValueQuoted,
                  this.sAttribValueClosed,
                  this.sAttribValueUnquoted,
                  this.sCloseTag,
                  this.sCloseTagSawWhite,
                ]),
                  this._init())
              }
              get closed() {
                return this._closed
              }
              _init() {
                var v
                ;((this.openWakaBang = ''),
                  (this.text = ''),
                  (this.name = ''),
                  (this.piTarget = ''),
                  (this.entity = ''),
                  (this.q = null),
                  (this.tags = []),
                  (this.tag = null),
                  (this.topNS = null),
                  (this.chunk = ''),
                  (this.chunkPosition = 0),
                  (this.i = 0),
                  (this.prevI = 0),
                  (this.carriedFromPrevious = void 0),
                  (this.forbiddenState = 0),
                  (this.attribList = []))
                const { fragmentOpt: x } = this
                ;((this.state = x ? 13 : 0),
                  (this.reportedTextBeforeRoot =
                    this.reportedTextAfterRoot =
                    this.closedRoot =
                    this.sawRoot =
                      x),
                  (this.xmlDeclPossible = !x),
                  (this.xmlDeclExpects = ['version']),
                  (this.entityReturnState = void 0))
                let { defaultXMLVersion: _ } = this.opt
                if (_ === void 0) {
                  if (this.opt.forceXMLVersion === !0)
                    throw new Error('forceXMLVersion set but defaultXMLVersion is not set')
                  _ = '1.0'
                }
                ;(this.setXMLVersion(_),
                  (this.positionAtNewLine = 0),
                  (this.doctype = !1),
                  (this._closed = !1),
                  (this.xmlDecl = { version: void 0, encoding: void 0, standalone: void 0 }),
                  (this.line = 1),
                  (this.column = 0),
                  (this.ENTITIES = Object.create(T)),
                  (v = this.readyHandler) === null || v === void 0 || v.call(this))
              }
              get position() {
                return this.chunkPosition + this.i
              }
              get columnIndex() {
                return this.position - this.positionAtNewLine
              }
              on(v, x) {
                this[k[v]] = x
              }
              off(v) {
                this[k[v]] = void 0
              }
              makeError(v) {
                var x
                let _ = (x = this.fileName) !== null && x !== void 0 ? x : ''
                return (
                  this.trackPosition &&
                    (_.length > 0 && (_ += ':'), (_ += `${this.line}:${this.column}`)),
                  _.length > 0 && (_ += ': '),
                  new Error(_ + v)
                )
              }
              fail(v) {
                const x = this.makeError(v),
                  _ = this.errorHandler
                if (_ === void 0) throw x
                return (_(x), this)
              }
              write(v) {
                if (this.closed)
                  return this.fail('cannot write after close; assign an onready handler.')
                let x = !1
                ;(v === null ? ((x = !0), (v = '')) : typeof v == 'object' && (v = v.toString()),
                  this.carriedFromPrevious !== void 0 &&
                    ((v = `${this.carriedFromPrevious}${v}`), (this.carriedFromPrevious = void 0)))
                let _ = v.length
                const S = v.charCodeAt(_ - 1)
                !x &&
                  (S === 13 || (S >= 55296 && S <= 56319)) &&
                  ((this.carriedFromPrevious = v[_ - 1]), _--, (v = v.slice(0, _)))
                const { stateTable: A } = this
                for (this.chunk = v, this.i = 0; this.i < _; ) A[this.state].call(this)
                return ((this.chunkPosition += _), x ? this.end() : this)
              }
              close() {
                return this.write(null)
              }
              getCode10() {
                const { chunk: v, i: x } = this
                if (((this.prevI = x), (this.i = x + 1), x >= v.length)) return -1
                const _ = v.charCodeAt(x)
                if ((this.column++, _ < 55296)) {
                  if (_ >= 32 || _ === 9) return _
                  switch (_) {
                    case 10:
                      return (
                        this.line++,
                        (this.column = 0),
                        (this.positionAtNewLine = this.position),
                        10
                      )
                    case 13:
                      return (
                        v.charCodeAt(x + 1) === 10 && (this.i = x + 2),
                        this.line++,
                        (this.column = 0),
                        (this.positionAtNewLine = this.position),
                        -2
                      )
                    default:
                      return (this.fail('disallowed character.'), _)
                  }
                }
                if (_ > 56319)
                  return ((_ >= 57344 && _ <= 65533) || this.fail('disallowed character.'), _)
                const S = 65536 + 1024 * (_ - 55296) + (v.charCodeAt(x + 1) - 56320)
                return ((this.i = x + 2), S > 1114111 && this.fail('disallowed character.'), S)
              }
              getCode11() {
                const { chunk: v, i: x } = this
                if (((this.prevI = x), (this.i = x + 1), x >= v.length)) return -1
                const _ = v.charCodeAt(x)
                if ((this.column++, _ < 55296)) {
                  if ((_ > 31 && _ < 127) || (_ > 159 && _ !== 8232) || _ === 9) return _
                  switch (_) {
                    case 10:
                      return (
                        this.line++,
                        (this.column = 0),
                        (this.positionAtNewLine = this.position),
                        10
                      )
                    case 13: {
                      const A = v.charCodeAt(x + 1)
                      ;(A !== 10 && A !== 133) || (this.i = x + 2)
                    }
                    case 133:
                    case 8232:
                      return (
                        this.line++,
                        (this.column = 0),
                        (this.positionAtNewLine = this.position),
                        -2
                      )
                    default:
                      return (this.fail('disallowed character.'), _)
                  }
                }
                if (_ > 56319)
                  return ((_ >= 57344 && _ <= 65533) || this.fail('disallowed character.'), _)
                const S = 65536 + 1024 * (_ - 55296) + (v.charCodeAt(x + 1) - 56320)
                return ((this.i = x + 2), S > 1114111 && this.fail('disallowed character.'), S)
              }
              getCodeNorm() {
                const v = this.getCode()
                return v === -2 ? 10 : v
              }
              unget() {
                ;((this.i = this.prevI), this.column--)
              }
              captureTo(v) {
                let { i: x } = this
                const { chunk: _ } = this
                for (;;) {
                  const S = this.getCode(),
                    A = S === -2,
                    j = A ? 10 : S
                  if (j === -1 || v.includes(j)) return ((this.text += _.slice(x, this.prevI)), j)
                  A &&
                    ((this.text +=
                      _.slice(x, this.prevI) +
                      `
`),
                    (x = this.i))
                }
              }
              captureToChar(v) {
                let { i: x } = this
                const { chunk: _ } = this
                for (;;) {
                  let S = this.getCode()
                  switch (S) {
                    case -2:
                      ;((this.text +=
                        _.slice(x, this.prevI) +
                        `
`),
                        (x = this.i),
                        (S = 10))
                      break
                    case -1:
                      return ((this.text += _.slice(x)), !1)
                  }
                  if (S === v) return ((this.text += _.slice(x, this.prevI)), !0)
                }
              }
              captureNameChars() {
                const { chunk: v, i: x } = this
                for (;;) {
                  const _ = this.getCode()
                  if (_ === -1) return ((this.name += v.slice(x)), -1)
                  if (!f(_)) return ((this.name += v.slice(x, this.prevI)), _ === -2 ? 10 : _)
                }
              }
              skipSpaces() {
                for (;;) {
                  const v = this.getCodeNorm()
                  if (v === -1 || !l(v)) return v
                }
              }
              setXMLVersion(v) {
                ;((this.currentXMLVersion = v),
                  v === '1.0'
                    ? ((this.isChar = c), (this.getCode = this.getCode10))
                    : ((this.isChar = p), (this.getCode = this.getCode11)))
              }
              sBegin() {
                ;(this.chunk.charCodeAt(0) === 65279 && (this.i++, this.column++), (this.state = 1))
              }
              sBeginWhitespace() {
                const v = this.i,
                  x = this.skipSpaces()
                switch ((this.prevI !== v && (this.xmlDeclPossible = !1), x)) {
                  case 60:
                    if (((this.state = 15), this.text.length !== 0))
                      throw new Error('no-empty text at start')
                    break
                  case -1:
                    break
                  default:
                    ;(this.unget(), (this.state = 13), (this.xmlDeclPossible = !1))
                }
              }
              sDoctype() {
                var v
                const x = this.captureTo(E)
                switch (x) {
                  case 62:
                    ;((v = this.doctypeHandler) === null || v === void 0 || v.call(this, this.text),
                      (this.text = ''),
                      (this.state = 13),
                      (this.doctype = !0))
                    break
                  case -1:
                    break
                  default:
                    ;((this.text += String.fromCodePoint(x)),
                      x === 91 ? (this.state = 4) : I(x) && ((this.state = 3), (this.q = x)))
                }
              }
              sDoctypeQuote() {
                const v = this.q
                this.captureToChar(v) &&
                  ((this.text += String.fromCodePoint(v)), (this.q = null), (this.state = 2))
              }
              sDTD() {
                const v = this.captureTo(O)
                v !== -1 &&
                  ((this.text += String.fromCodePoint(v)),
                  v === 93
                    ? (this.state = 2)
                    : v === 60
                      ? (this.state = 6)
                      : I(v) && ((this.state = 5), (this.q = v)))
              }
              sDTDQuoted() {
                const v = this.q
                this.captureToChar(v) &&
                  ((this.text += String.fromCodePoint(v)), (this.state = 4), (this.q = null))
              }
              sDTDOpenWaka() {
                const v = this.getCodeNorm()
                switch (((this.text += String.fromCodePoint(v)), v)) {
                  case 33:
                    ;((this.state = 7), (this.openWakaBang = ''))
                    break
                  case 63:
                    this.state = 11
                    break
                  default:
                    this.state = 4
                }
              }
              sDTDOpenWakaBang() {
                const v = String.fromCodePoint(this.getCodeNorm()),
                  x = (this.openWakaBang += v)
                ;((this.text += v),
                  x !== '-' && ((this.state = x === '--' ? 8 : 4), (this.openWakaBang = '')))
              }
              sDTDComment() {
                this.captureToChar(45) && ((this.text += '-'), (this.state = 9))
              }
              sDTDCommentEnding() {
                const v = this.getCodeNorm()
                ;((this.text += String.fromCodePoint(v)), (this.state = v === 45 ? 10 : 8))
              }
              sDTDCommentEnded() {
                const v = this.getCodeNorm()
                ;((this.text += String.fromCodePoint(v)),
                  v === 62 ? (this.state = 4) : (this.fail('malformed comment.'), (this.state = 8)))
              }
              sDTDPI() {
                this.captureToChar(63) && ((this.text += '?'), (this.state = 12))
              }
              sDTDPIEnding() {
                const v = this.getCodeNorm()
                ;((this.text += String.fromCodePoint(v)), v === 62 && (this.state = 4))
              }
              sText() {
                this.tags.length !== 0 ? this.handleTextInRoot() : this.handleTextOutsideRoot()
              }
              sEntity() {
                let { i: v } = this
                const { chunk: x } = this
                t: for (;;)
                  switch (this.getCode()) {
                    case -2:
                      ;((this.entity +=
                        x.slice(v, this.prevI) +
                        `
`),
                        (v = this.i))
                      break
                    case 59: {
                      const { entityReturnState: _ } = this,
                        S = this.entity + x.slice(v, this.prevI)
                      let A
                      ;((this.state = _),
                        S === ''
                          ? (this.fail('empty entity name.'), (A = '&;'))
                          : ((A = this.parseEntity(S)), (this.entity = '')),
                        (_ === 13 && this.textHandler === void 0) || (this.text += A))
                      break t
                    }
                    case -1:
                      this.entity += x.slice(v)
                      break t
                  }
              }
              sOpenWaka() {
                const v = this.getCode()
                if (u(v)) ((this.state = 34), this.unget(), (this.xmlDeclPossible = !1))
                else
                  switch (v) {
                    case 47:
                      ;((this.state = 43), (this.xmlDeclPossible = !1))
                      break
                    case 33:
                      ;((this.state = 16), (this.openWakaBang = ''), (this.xmlDeclPossible = !1))
                      break
                    case 63:
                      this.state = 23
                      break
                    default:
                      ;(this.fail('disallowed character in tag name'),
                        (this.state = 13),
                        (this.xmlDeclPossible = !1))
                  }
              }
              sOpenWakaBang() {
                switch (
                  ((this.openWakaBang += String.fromCodePoint(this.getCodeNorm())),
                  this.openWakaBang)
                ) {
                  case '[CDATA[':
                    ;(this.sawRoot ||
                      this.reportedTextBeforeRoot ||
                      (this.fail('text data outside of root node.'),
                      (this.reportedTextBeforeRoot = !0)),
                      this.closedRoot &&
                        !this.reportedTextAfterRoot &&
                        (this.fail('text data outside of root node.'),
                        (this.reportedTextAfterRoot = !0)),
                      (this.state = 20),
                      (this.openWakaBang = ''))
                    break
                  case '--':
                    ;((this.state = 17), (this.openWakaBang = ''))
                    break
                  case 'DOCTYPE':
                    ;((this.state = 2),
                      (this.doctype || this.sawRoot) &&
                        this.fail('inappropriately located doctype declaration.'),
                      (this.openWakaBang = ''))
                    break
                  default:
                    this.openWakaBang.length >= 7 && this.fail('incorrect syntax.')
                }
              }
              sComment() {
                this.captureToChar(45) && (this.state = 18)
              }
              sCommentEnding() {
                var v
                const x = this.getCodeNorm()
                x === 45
                  ? ((this.state = 19),
                    (v = this.commentHandler) === null || v === void 0 || v.call(this, this.text),
                    (this.text = ''))
                  : ((this.text += '-' + String.fromCodePoint(x)), (this.state = 17))
              }
              sCommentEnded() {
                const v = this.getCodeNorm()
                v !== 62
                  ? (this.fail('malformed comment.'),
                    (this.text += '--' + String.fromCodePoint(v)),
                    (this.state = 17))
                  : (this.state = 13)
              }
              sCData() {
                this.captureToChar(93) && (this.state = 21)
              }
              sCDataEnding() {
                const v = this.getCodeNorm()
                v === 93
                  ? (this.state = 22)
                  : ((this.text += ']' + String.fromCodePoint(v)), (this.state = 20))
              }
              sCDataEnding2() {
                var v
                const x = this.getCodeNorm()
                switch (x) {
                  case 62:
                    ;((v = this.cdataHandler) === null || v === void 0 || v.call(this, this.text),
                      (this.text = ''),
                      (this.state = 13))
                    break
                  case 93:
                    this.text += ']'
                    break
                  default:
                    ;((this.text += ']]' + String.fromCodePoint(x)), (this.state = 20))
                }
              }
              sPIFirstChar() {
                const v = this.getCodeNorm()
                this.nameStartCheck(v)
                  ? ((this.piTarget += String.fromCodePoint(v)), (this.state = 24))
                  : v === 63 || l(v)
                    ? (this.fail('processing instruction without a target.'),
                      (this.state = v === 63 ? 26 : 25))
                    : (this.fail('disallowed character in processing instruction name.'),
                      (this.piTarget += String.fromCodePoint(v)),
                      (this.state = 24))
              }
              sPIRest() {
                const { chunk: v, i: x } = this
                for (;;) {
                  const _ = this.getCodeNorm()
                  if (_ === -1) return void (this.piTarget += v.slice(x))
                  if (!this.nameCheck(_)) {
                    this.piTarget += v.slice(x, this.prevI)
                    const S = _ === 63
                    S || l(_)
                      ? this.piTarget === 'xml'
                        ? (this.xmlDeclPossible ||
                            this.fail('an XML declaration must be at the start of the document.'),
                          (this.state = S ? 33 : 27))
                        : (this.state = S ? 26 : 25)
                      : (this.fail('disallowed character in processing instruction name.'),
                        (this.piTarget += String.fromCodePoint(_)))
                    break
                  }
                }
              }
              sPIBody() {
                if (this.text.length === 0) {
                  const v = this.getCodeNorm()
                  v === 63 ? (this.state = 26) : l(v) || (this.text = String.fromCodePoint(v))
                } else this.captureToChar(63) && (this.state = 26)
              }
              sPIEnding() {
                var v
                const x = this.getCodeNorm()
                if (x === 62) {
                  const { piTarget: _ } = this
                  ;(_.toLowerCase() === 'xml' &&
                    this.fail('the XML declaration must appear at the start of the document.'),
                    (v = this.piHandler) === null ||
                      v === void 0 ||
                      v.call(this, { target: _, body: this.text }),
                    (this.piTarget = this.text = ''),
                    (this.state = 13))
                } else
                  x === 63
                    ? (this.text += '?')
                    : ((this.text += '?' + String.fromCodePoint(x)), (this.state = 25))
                this.xmlDeclPossible = !1
              }
              sXMLDeclNameStart() {
                const v = this.skipSpaces()
                v !== 63
                  ? v !== -1 && ((this.state = 28), (this.name = String.fromCodePoint(v)))
                  : (this.state = 33)
              }
              sXMLDeclName() {
                const v = this.captureTo(P)
                if (v === 63)
                  return (
                    (this.state = 33),
                    (this.name += this.text),
                    (this.text = ''),
                    void this.fail('XML declaration is incomplete.')
                  )
                if (l(v) || v === 61) {
                  if (
                    ((this.name += this.text),
                    (this.text = ''),
                    !this.xmlDeclExpects.includes(this.name))
                  )
                    switch (this.name.length) {
                      case 0:
                        this.fail('did not expect any more name/value pairs.')
                        break
                      case 1:
                        this.fail(`expected the name ${this.xmlDeclExpects[0]}.`)
                        break
                      default:
                        this.fail('expected one of ' + this.xmlDeclExpects.join(', '))
                    }
                  this.state = v === 61 ? 30 : 29
                }
              }
              sXMLDeclEq() {
                const v = this.getCodeNorm()
                if (v === 63)
                  return ((this.state = 33), void this.fail('XML declaration is incomplete.'))
                l(v) || (v !== 61 && this.fail('value required.'), (this.state = 30))
              }
              sXMLDeclValueStart() {
                const v = this.getCodeNorm()
                if (v === 63)
                  return ((this.state = 33), void this.fail('XML declaration is incomplete.'))
                l(v) ||
                  (I(v) ? (this.q = v) : (this.fail('value must be quoted.'), (this.q = 32)),
                  (this.state = 31))
              }
              sXMLDeclValue() {
                const v = this.captureTo([this.q, 63])
                if (v === 63)
                  return (
                    (this.state = 33),
                    (this.text = ''),
                    void this.fail('XML declaration is incomplete.')
                  )
                if (v === -1) return
                const x = this.text
                switch (((this.text = ''), this.name)) {
                  case 'version': {
                    this.xmlDeclExpects = ['encoding', 'standalone']
                    const _ = x
                    ;((this.xmlDecl.version = _),
                      /^1\.[0-9]+$/.test(_)
                        ? this.opt.forceXMLVersion || this.setXMLVersion(_)
                        : this.fail('version number must match /^1\\.[0-9]+$/.'))
                    break
                  }
                  case 'encoding':
                    ;(/^[A-Za-z][A-Za-z0-9._-]*$/.test(x) ||
                      this.fail('encoding value must match /^[A-Za-z0-9][A-Za-z0-9._-]*$/.'),
                      (this.xmlDeclExpects = ['standalone']),
                      (this.xmlDecl.encoding = x))
                    break
                  case 'standalone':
                    ;(x !== 'yes' &&
                      x !== 'no' &&
                      this.fail('standalone value must match "yes" or "no".'),
                      (this.xmlDeclExpects = []),
                      (this.xmlDecl.standalone = x))
                }
                ;((this.name = ''), (this.state = 32))
              }
              sXMLDeclSeparator() {
                const v = this.getCodeNorm()
                v !== 63
                  ? (l(v) || (this.fail('whitespace required.'), this.unget()), (this.state = 27))
                  : (this.state = 33)
              }
              sXMLDeclEnding() {
                var v
                ;(this.getCodeNorm() === 62
                  ? (this.piTarget !== 'xml'
                      ? this.fail('processing instructions are not allowed before root.')
                      : this.name !== 'version' &&
                        this.xmlDeclExpects.includes('version') &&
                        this.fail('XML declaration must contain a version.'),
                    (v = this.xmldeclHandler) === null ||
                      v === void 0 ||
                      v.call(this, this.xmlDecl),
                    (this.name = ''),
                    (this.piTarget = this.text = ''),
                    (this.state = 13))
                  : this.fail('The character ? is disallowed anywhere in XML declarations.'),
                  (this.xmlDeclPossible = !1))
              }
              sOpenTag() {
                var v
                const x = this.captureNameChars()
                if (x === -1) return
                const _ = (this.tag = { name: this.name, attributes: Object.create(null) })
                switch (
                  ((this.name = ''),
                  this.xmlnsOpt && (this.topNS = _.ns = Object.create(null)),
                  (v = this.openTagStartHandler) === null || v === void 0 || v.call(this, _),
                  (this.sawRoot = !0),
                  !this.fragmentOpt &&
                    this.closedRoot &&
                    this.fail('documents may contain only one root.'),
                  x)
                ) {
                  case 62:
                    this.openTag()
                    break
                  case 47:
                    this.state = 35
                    break
                  default:
                    ;(l(x) || this.fail('disallowed character in tag name.'), (this.state = 36))
                }
              }
              sOpenTagSlash() {
                this.getCode() === 62
                  ? this.openSelfClosingTag()
                  : (this.fail('forward-slash in opening tag not followed by >.'),
                    (this.state = 36))
              }
              sAttrib() {
                const v = this.skipSpaces()
                v !== -1 &&
                  (u(v)
                    ? (this.unget(), (this.state = 37))
                    : v === 62
                      ? this.openTag()
                      : v === 47
                        ? (this.state = 35)
                        : this.fail('disallowed character in attribute name.'))
              }
              sAttribName() {
                const v = this.captureNameChars()
                v === 61
                  ? (this.state = 39)
                  : l(v)
                    ? (this.state = 38)
                    : v === 62
                      ? (this.fail('attribute without value.'),
                        this.pushAttrib(this.name, this.name),
                        (this.name = this.text = ''),
                        this.openTag())
                      : v !== -1 && this.fail('disallowed character in attribute name.')
              }
              sAttribNameSawWhite() {
                const v = this.skipSpaces()
                switch (v) {
                  case -1:
                    return
                  case 61:
                    this.state = 39
                    break
                  default:
                    ;(this.fail('attribute without value.'),
                      (this.text = ''),
                      (this.name = ''),
                      v === 62
                        ? this.openTag()
                        : u(v)
                          ? (this.unget(), (this.state = 37))
                          : (this.fail('disallowed character in attribute name.'),
                            (this.state = 36)))
                }
              }
              sAttribValue() {
                const v = this.getCodeNorm()
                I(v)
                  ? ((this.q = v), (this.state = 40))
                  : l(v) ||
                    (this.fail('unquoted attribute value.'), (this.state = 42), this.unget())
              }
              sAttribValueQuoted() {
                const { q: v, chunk: x } = this
                let { i: _ } = this
                for (;;)
                  switch (this.getCode()) {
                    case v:
                      return (
                        this.pushAttrib(this.name, this.text + x.slice(_, this.prevI)),
                        (this.name = this.text = ''),
                        (this.q = null),
                        void (this.state = 41)
                      )
                    case 38:
                      return (
                        (this.text += x.slice(_, this.prevI)),
                        (this.state = 14),
                        void (this.entityReturnState = 40)
                      )
                    case 10:
                    case -2:
                    case 9:
                      ;((this.text += x.slice(_, this.prevI) + ' '), (_ = this.i))
                      break
                    case 60:
                      return (
                        (this.text += x.slice(_, this.prevI)),
                        void this.fail('disallowed character.')
                      )
                    case -1:
                      return void (this.text += x.slice(_))
                  }
              }
              sAttribValueClosed() {
                const v = this.getCodeNorm()
                l(v)
                  ? (this.state = 36)
                  : v === 62
                    ? this.openTag()
                    : v === 47
                      ? (this.state = 35)
                      : u(v)
                        ? (this.fail('no whitespace between attributes.'),
                          this.unget(),
                          (this.state = 37))
                        : this.fail('disallowed character in attribute name.')
              }
              sAttribValueUnquoted() {
                const v = this.captureTo($)
                switch (v) {
                  case 38:
                    ;((this.state = 14), (this.entityReturnState = 42))
                    break
                  case 60:
                    this.fail('disallowed character.')
                    break
                  case -1:
                    break
                  default:
                    ;(this.text.includes(']]>') &&
                      this.fail('the string "]]>" is disallowed in char data.'),
                      this.pushAttrib(this.name, this.text),
                      (this.name = this.text = ''),
                      v === 62 ? this.openTag() : (this.state = 36))
                }
              }
              sCloseTag() {
                const v = this.captureNameChars()
                v === 62
                  ? this.closeTag()
                  : l(v)
                    ? (this.state = 44)
                    : v !== -1 && this.fail('disallowed character in closing tag.')
              }
              sCloseTagSawWhite() {
                switch (this.skipSpaces()) {
                  case 62:
                    this.closeTag()
                    break
                  case -1:
                    break
                  default:
                    this.fail('disallowed character in closing tag.')
                }
              }
              handleTextInRoot() {
                let { i: v, forbiddenState: x } = this
                const { chunk: _, textHandler: S } = this
                t: for (;;)
                  switch (this.getCode()) {
                    case 60:
                      if (((this.state = 15), S !== void 0)) {
                        const { text: A } = this,
                          j = _.slice(v, this.prevI)
                        A.length !== 0 ? (S(A + j), (this.text = '')) : j.length !== 0 && S(j)
                      }
                      x = 0
                      break t
                    case 38:
                      ;((this.state = 14),
                        (this.entityReturnState = 13),
                        S !== void 0 && (this.text += _.slice(v, this.prevI)),
                        (x = 0))
                      break t
                    case 93:
                      switch (x) {
                        case 0:
                          x = 1
                          break
                        case 1:
                          x = 2
                          break
                        case 2:
                          break
                        default:
                          throw new Error('impossible state')
                      }
                      break
                    case 62:
                      ;(x === 2 && this.fail('the string "]]>" is disallowed in char data.'),
                        (x = 0))
                      break
                    case -2:
                      ;(S !== void 0 &&
                        (this.text +=
                          _.slice(v, this.prevI) +
                          `
`),
                        (v = this.i),
                        (x = 0))
                      break
                    case -1:
                      S !== void 0 && (this.text += _.slice(v))
                      break t
                    default:
                      x = 0
                  }
                this.forbiddenState = x
              }
              handleTextOutsideRoot() {
                let { i: v } = this
                const { chunk: x, textHandler: _ } = this
                let S = !1
                t: for (;;) {
                  const A = this.getCode()
                  switch (A) {
                    case 60:
                      if (((this.state = 15), _ !== void 0)) {
                        const { text: j } = this,
                          L = x.slice(v, this.prevI)
                        j.length !== 0 ? (_(j + L), (this.text = '')) : L.length !== 0 && _(L)
                      }
                      break t
                    case 38:
                      ;((this.state = 14),
                        (this.entityReturnState = 13),
                        _ !== void 0 && (this.text += x.slice(v, this.prevI)),
                        (S = !0))
                      break t
                    case -2:
                      ;(_ !== void 0 &&
                        (this.text +=
                          x.slice(v, this.prevI) +
                          `
`),
                        (v = this.i))
                      break
                    case -1:
                      _ !== void 0 && (this.text += x.slice(v))
                      break t
                    default:
                      l(A) || (S = !0)
                  }
                }
                S &&
                  (this.sawRoot ||
                    this.reportedTextBeforeRoot ||
                    (this.fail('text data outside of root node.'),
                    (this.reportedTextBeforeRoot = !0)),
                  this.closedRoot &&
                    !this.reportedTextAfterRoot &&
                    (this.fail('text data outside of root node.'),
                    (this.reportedTextAfterRoot = !0)))
              }
              pushAttribNS(v, x) {
                var _
                const { prefix: S, local: A } = this.qname(v),
                  j = { name: v, prefix: S, local: A, value: x }
                if (
                  (this.attribList.push(j),
                  (_ = this.attributeHandler) === null || _ === void 0 || _.call(this, j),
                  S === 'xmlns')
                ) {
                  const L = x.trim()
                  ;(this.currentXMLVersion === '1.0' &&
                    L === '' &&
                    this.fail('invalid attempt to undefine prefix in XML 1.0'),
                    (this.topNS[A] = L),
                    F(this, A, L))
                } else if (v === 'xmlns') {
                  const L = x.trim()
                  ;((this.topNS[''] = L), F(this, '', L))
                }
              }
              pushAttribPlain(v, x) {
                var _
                const S = { name: v, value: x }
                ;(this.attribList.push(S),
                  (_ = this.attributeHandler) === null || _ === void 0 || _.call(this, S))
              }
              end() {
                var v, x
                this.sawRoot || this.fail('document must contain a root element.')
                const { tags: _ } = this
                for (; _.length > 0; ) {
                  const A = _.pop()
                  this.fail('unclosed tag: ' + A.name)
                }
                this.state !== 0 && this.state !== 13 && this.fail('unexpected end.')
                const { text: S } = this
                return (
                  S.length !== 0 &&
                    ((v = this.textHandler) === null || v === void 0 || v.call(this, S),
                    (this.text = '')),
                  (this._closed = !0),
                  (x = this.endHandler) === null || x === void 0 || x.call(this),
                  this._init(),
                  this
                )
              }
              resolve(v) {
                var x, _
                let S = this.topNS[v]
                if (S !== void 0) return S
                const { tags: A } = this
                for (let j = A.length - 1; j >= 0; j--)
                  if (((S = A[j].ns[v]), S !== void 0)) return S
                return (
                  (S = this.ns[v]),
                  S !== void 0
                    ? S
                    : (_ = (x = this.opt).resolvePrefix) === null || _ === void 0
                      ? void 0
                      : _.call(x, v)
                )
              }
              qname(v) {
                const x = v.indexOf(':')
                if (x === -1) return { prefix: '', local: v }
                const _ = v.slice(x + 1),
                  S = v.slice(0, x)
                return (
                  (S === '' || _ === '' || _.includes(':')) && this.fail(`malformed name: ${v}.`),
                  { prefix: S, local: _ }
                )
              }
              processAttribsNS() {
                var v
                const { attribList: x } = this,
                  _ = this.tag
                {
                  const { prefix: j, local: L } = this.qname(_.name)
                  ;((_.prefix = j), (_.local = L))
                  const H = (_.uri = (v = this.resolve(j)) !== null && v !== void 0 ? v : '')
                  j !== '' &&
                    (j === 'xmlns' && this.fail('tags may not have "xmlns" as prefix.'),
                    H === '' &&
                      (this.fail(`unbound namespace prefix: ${JSON.stringify(j)}.`), (_.uri = j)))
                }
                if (x.length === 0) return
                const { attributes: S } = _,
                  A = new Set()
                for (const j of x) {
                  const { name: L, prefix: H, local: U } = j
                  let K, z
                  ;(H === ''
                    ? ((K = L === 'xmlns' ? w : ''), (z = L))
                    : ((K = this.resolve(H)),
                      K === void 0 &&
                        (this.fail(`unbound namespace prefix: ${JSON.stringify(H)}.`), (K = H)),
                      (z = `{${K}}${U}`)),
                    A.has(z) && this.fail(`duplicate attribute: ${z}.`),
                    A.add(z),
                    (j.uri = K),
                    (S[L] = j))
                }
                this.attribList = []
              }
              processAttribsPlain() {
                const { attribList: v } = this,
                  x = this.tag.attributes
                for (const { name: _, value: S } of v)
                  (x[_] !== void 0 && this.fail(`duplicate attribute: ${_}.`), (x[_] = S))
                this.attribList = []
              }
              openTag() {
                var v
                this.processAttribs()
                const { tags: x } = this,
                  _ = this.tag
                ;((_.isSelfClosing = !1),
                  (v = this.openTagHandler) === null || v === void 0 || v.call(this, _),
                  x.push(_),
                  (this.state = 13),
                  (this.name = ''))
              }
              openSelfClosingTag() {
                var v, x, _
                this.processAttribs()
                const { tags: S } = this,
                  A = this.tag
                ;((A.isSelfClosing = !0),
                  (v = this.openTagHandler) === null || v === void 0 || v.call(this, A),
                  (x = this.closeTagHandler) === null || x === void 0 || x.call(this, A),
                  (this.tag = (_ = S[S.length - 1]) !== null && _ !== void 0 ? _ : null) === null &&
                    (this.closedRoot = !0),
                  (this.state = 13),
                  (this.name = ''))
              }
              closeTag() {
                const { tags: v, name: x } = this
                if (((this.state = 13), (this.name = ''), x === ''))
                  return (this.fail('weird empty close tag.'), void (this.text += '</>'))
                const _ = this.closeTagHandler
                let S = v.length
                for (; S-- > 0; ) {
                  const A = (this.tag = v.pop())
                  if (((this.topNS = A.ns), _?.(A), A.name === x)) break
                  this.fail('unexpected close tag.')
                }
                S === 0
                  ? (this.closedRoot = !0)
                  : S < 0 && (this.fail(`unmatched closing tag: ${x}.`), (this.text += `</${x}>`))
              }
              parseEntity(v) {
                if (v[0] !== '#') {
                  const _ = this.ENTITIES[v]
                  return _ !== void 0
                    ? _
                    : (this.fail(
                        this.isName(v)
                          ? 'undefined entity.'
                          : 'disallowed character in entity name.',
                      ),
                      `&${v};`)
                }
                let x = NaN
                return (
                  v[1] === 'x' && /^#x[0-9a-f]+$/i.test(v)
                    ? (x = parseInt(v.slice(2), 16))
                    : /^#[0-9]+$/.test(v) && (x = parseInt(v.slice(1), 10)),
                  this.isChar(x)
                    ? String.fromCodePoint(x)
                    : (this.fail('malformed character entity.'), `&${v};`)
                )
              }
            }
          },
          {
            'xmlchars/xml/1.0/ed5': 543,
            'xmlchars/xml/1.1/ed2': 544,
            'xmlchars/xmlns/1.0/ed3': 545,
          },
        ],
        497: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer
            function o(a, l) {
              ;((this._block = s.alloc(a)),
                (this._finalSize = l),
                (this._blockSize = a),
                (this._len = 0))
            }
            ;((o.prototype.update = function (a, l) {
              typeof a == 'string' && ((l = l || 'utf8'), (a = s.from(a, l)))
              for (
                var c = this._block, u = this._blockSize, f = a.length, d = this._len, h = 0;
                h < f;

              ) {
                for (var p = d % u, g = Math.min(f - h, u - p), m = 0; m < g; m++)
                  c[p + m] = a[h + m]
                ;((h += g), (d += g) % u == 0 && this._update(c))
              }
              return ((this._len += f), this)
            }),
              (o.prototype.digest = function (a) {
                var l = this._len % this._blockSize
                ;((this._block[l] = 128),
                  this._block.fill(0, l + 1),
                  l >= this._finalSize && (this._update(this._block), this._block.fill(0)))
                var c = 8 * this._len
                if (c <= 4294967295) this._block.writeUInt32BE(c, this._blockSize - 4)
                else {
                  var u = (4294967295 & c) >>> 0,
                    f = (c - u) / 4294967296
                  ;(this._block.writeUInt32BE(f, this._blockSize - 8),
                    this._block.writeUInt32BE(u, this._blockSize - 4))
                }
                this._update(this._block)
                var d = this._hash()
                return a ? d.toString(a) : d
              }),
              (o.prototype._update = function () {
                throw new Error('_update must be implemented by subclass')
              }),
              (r.exports = o))
          },
          { 'safe-buffer': 494 },
        ],
        498: [
          function (t, r, i) {
            var s = (r.exports = function (o) {
              o = o.toLowerCase()
              var a = s[o]
              if (!a) throw new Error(o + ' is not supported (we accept pull requests)')
              return new a()
            })
            ;((s.sha = t('./sha')),
              (s.sha1 = t('./sha1')),
              (s.sha224 = t('./sha224')),
              (s.sha256 = t('./sha256')),
              (s.sha384 = t('./sha384')),
              (s.sha512 = t('./sha512')))
          },
          {
            './sha': 499,
            './sha1': 500,
            './sha224': 501,
            './sha256': 502,
            './sha384': 503,
            './sha512': 504,
          },
        ],
        499: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('./hash'),
              a = t('safe-buffer').Buffer,
              l = [1518500249, 1859775393, -1894007588, -899497514],
              c = new Array(80)
            function u() {
              ;(this.init(), (this._w = c), o.call(this, 64, 56))
            }
            function f(h) {
              return (h << 30) | (h >>> 2)
            }
            function d(h, p, g, m) {
              return h === 0
                ? (p & g) | (~p & m)
                : h === 2
                  ? (p & g) | (p & m) | (g & m)
                  : p ^ g ^ m
            }
            ;(s(u, o),
              (u.prototype.init = function () {
                return (
                  (this._a = 1732584193),
                  (this._b = 4023233417),
                  (this._c = 2562383102),
                  (this._d = 271733878),
                  (this._e = 3285377520),
                  this
                )
              }),
              (u.prototype._update = function (h) {
                for (
                  var p,
                    g = this._w,
                    m = 0 | this._a,
                    y = 0 | this._b,
                    b = 0 | this._c,
                    w = 0 | this._d,
                    C = 0 | this._e,
                    T = 0;
                  T < 16;
                  ++T
                )
                  g[T] = h.readInt32BE(4 * T)
                for (; T < 80; ++T) g[T] = g[T - 3] ^ g[T - 8] ^ g[T - 14] ^ g[T - 16]
                for (var I = 0; I < 80; ++I) {
                  var B = ~~(I / 20),
                    E = 0 | ((((p = m) << 5) | (p >>> 27)) + d(B, y, b, w) + C + g[I] + l[B])
                  ;((C = w), (w = b), (b = f(y)), (y = m), (m = E))
                }
                ;((this._a = (m + this._a) | 0),
                  (this._b = (y + this._b) | 0),
                  (this._c = (b + this._c) | 0),
                  (this._d = (w + this._d) | 0),
                  (this._e = (C + this._e) | 0))
              }),
              (u.prototype._hash = function () {
                var h = a.allocUnsafe(20)
                return (
                  h.writeInt32BE(0 | this._a, 0),
                  h.writeInt32BE(0 | this._b, 4),
                  h.writeInt32BE(0 | this._c, 8),
                  h.writeInt32BE(0 | this._d, 12),
                  h.writeInt32BE(0 | this._e, 16),
                  h
                )
              }),
              (r.exports = u))
          },
          { './hash': 497, inherits: 440, 'safe-buffer': 494 },
        ],
        500: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('./hash'),
              a = t('safe-buffer').Buffer,
              l = [1518500249, 1859775393, -1894007588, -899497514],
              c = new Array(80)
            function u() {
              ;(this.init(), (this._w = c), o.call(this, 64, 56))
            }
            function f(p) {
              return (p << 5) | (p >>> 27)
            }
            function d(p) {
              return (p << 30) | (p >>> 2)
            }
            function h(p, g, m, y) {
              return p === 0
                ? (g & m) | (~g & y)
                : p === 2
                  ? (g & m) | (g & y) | (m & y)
                  : g ^ m ^ y
            }
            ;(s(u, o),
              (u.prototype.init = function () {
                return (
                  (this._a = 1732584193),
                  (this._b = 4023233417),
                  (this._c = 2562383102),
                  (this._d = 271733878),
                  (this._e = 3285377520),
                  this
                )
              }),
              (u.prototype._update = function (p) {
                for (
                  var g,
                    m = this._w,
                    y = 0 | this._a,
                    b = 0 | this._b,
                    w = 0 | this._c,
                    C = 0 | this._d,
                    T = 0 | this._e,
                    I = 0;
                  I < 16;
                  ++I
                )
                  m[I] = p.readInt32BE(4 * I)
                for (; I < 80; ++I)
                  m[I] = ((g = m[I - 3] ^ m[I - 8] ^ m[I - 14] ^ m[I - 16]) << 1) | (g >>> 31)
                for (var B = 0; B < 80; ++B) {
                  var E = ~~(B / 20),
                    O = (f(y) + h(E, b, w, C) + T + m[B] + l[E]) | 0
                  ;((T = C), (C = w), (w = d(b)), (b = y), (y = O))
                }
                ;((this._a = (y + this._a) | 0),
                  (this._b = (b + this._b) | 0),
                  (this._c = (w + this._c) | 0),
                  (this._d = (C + this._d) | 0),
                  (this._e = (T + this._e) | 0))
              }),
              (u.prototype._hash = function () {
                var p = a.allocUnsafe(20)
                return (
                  p.writeInt32BE(0 | this._a, 0),
                  p.writeInt32BE(0 | this._b, 4),
                  p.writeInt32BE(0 | this._c, 8),
                  p.writeInt32BE(0 | this._d, 12),
                  p.writeInt32BE(0 | this._e, 16),
                  p
                )
              }),
              (r.exports = u))
          },
          { './hash': 497, inherits: 440, 'safe-buffer': 494 },
        ],
        501: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('./sha256'),
              a = t('./hash'),
              l = t('safe-buffer').Buffer,
              c = new Array(64)
            function u() {
              ;(this.init(), (this._w = c), a.call(this, 64, 56))
            }
            ;(s(u, o),
              (u.prototype.init = function () {
                return (
                  (this._a = 3238371032),
                  (this._b = 914150663),
                  (this._c = 812702999),
                  (this._d = 4144912697),
                  (this._e = 4290775857),
                  (this._f = 1750603025),
                  (this._g = 1694076839),
                  (this._h = 3204075428),
                  this
                )
              }),
              (u.prototype._hash = function () {
                var f = l.allocUnsafe(28)
                return (
                  f.writeInt32BE(this._a, 0),
                  f.writeInt32BE(this._b, 4),
                  f.writeInt32BE(this._c, 8),
                  f.writeInt32BE(this._d, 12),
                  f.writeInt32BE(this._e, 16),
                  f.writeInt32BE(this._f, 20),
                  f.writeInt32BE(this._g, 24),
                  f
                )
              }),
              (r.exports = u))
          },
          { './hash': 497, './sha256': 502, inherits: 440, 'safe-buffer': 494 },
        ],
        502: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('./hash'),
              a = t('safe-buffer').Buffer,
              l = [
                1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,
                2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
                2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
                1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
                3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372,
                1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
                3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734,
                506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
                1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
                3329325298,
              ],
              c = new Array(64)
            function u() {
              ;(this.init(), (this._w = c), o.call(this, 64, 56))
            }
            function f(m, y, b) {
              return b ^ (m & (y ^ b))
            }
            function d(m, y, b) {
              return (m & y) | (b & (m | y))
            }
            function h(m) {
              return ((m >>> 2) | (m << 30)) ^ ((m >>> 13) | (m << 19)) ^ ((m >>> 22) | (m << 10))
            }
            function p(m) {
              return ((m >>> 6) | (m << 26)) ^ ((m >>> 11) | (m << 21)) ^ ((m >>> 25) | (m << 7))
            }
            function g(m) {
              return ((m >>> 7) | (m << 25)) ^ ((m >>> 18) | (m << 14)) ^ (m >>> 3)
            }
            ;(s(u, o),
              (u.prototype.init = function () {
                return (
                  (this._a = 1779033703),
                  (this._b = 3144134277),
                  (this._c = 1013904242),
                  (this._d = 2773480762),
                  (this._e = 1359893119),
                  (this._f = 2600822924),
                  (this._g = 528734635),
                  (this._h = 1541459225),
                  this
                )
              }),
              (u.prototype._update = function (m) {
                for (
                  var y,
                    b = this._w,
                    w = 0 | this._a,
                    C = 0 | this._b,
                    T = 0 | this._c,
                    I = 0 | this._d,
                    B = 0 | this._e,
                    E = 0 | this._f,
                    O = 0 | this._g,
                    P = 0 | this._h,
                    $ = 0;
                  $ < 16;
                  ++$
                )
                  b[$] = m.readInt32BE(4 * $)
                for (; $ < 64; ++$)
                  b[$] =
                    0 |
                    (((((y = b[$ - 2]) >>> 17) | (y << 15)) ^
                      ((y >>> 19) | (y << 13)) ^
                      (y >>> 10)) +
                      b[$ - 7] +
                      g(b[$ - 15]) +
                      b[$ - 16])
                for (var F = 0; F < 64; ++F) {
                  var M = (P + p(B) + f(B, E, O) + l[F] + b[F]) | 0,
                    R = (h(w) + d(w, C, T)) | 0
                  ;((P = O),
                    (O = E),
                    (E = B),
                    (B = (I + M) | 0),
                    (I = T),
                    (T = C),
                    (C = w),
                    (w = (M + R) | 0))
                }
                ;((this._a = (w + this._a) | 0),
                  (this._b = (C + this._b) | 0),
                  (this._c = (T + this._c) | 0),
                  (this._d = (I + this._d) | 0),
                  (this._e = (B + this._e) | 0),
                  (this._f = (E + this._f) | 0),
                  (this._g = (O + this._g) | 0),
                  (this._h = (P + this._h) | 0))
              }),
              (u.prototype._hash = function () {
                var m = a.allocUnsafe(32)
                return (
                  m.writeInt32BE(this._a, 0),
                  m.writeInt32BE(this._b, 4),
                  m.writeInt32BE(this._c, 8),
                  m.writeInt32BE(this._d, 12),
                  m.writeInt32BE(this._e, 16),
                  m.writeInt32BE(this._f, 20),
                  m.writeInt32BE(this._g, 24),
                  m.writeInt32BE(this._h, 28),
                  m
                )
              }),
              (r.exports = u))
          },
          { './hash': 497, inherits: 440, 'safe-buffer': 494 },
        ],
        503: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('./sha512'),
              a = t('./hash'),
              l = t('safe-buffer').Buffer,
              c = new Array(160)
            function u() {
              ;(this.init(), (this._w = c), a.call(this, 128, 112))
            }
            ;(s(u, o),
              (u.prototype.init = function () {
                return (
                  (this._ah = 3418070365),
                  (this._bh = 1654270250),
                  (this._ch = 2438529370),
                  (this._dh = 355462360),
                  (this._eh = 1731405415),
                  (this._fh = 2394180231),
                  (this._gh = 3675008525),
                  (this._hh = 1203062813),
                  (this._al = 3238371032),
                  (this._bl = 914150663),
                  (this._cl = 812702999),
                  (this._dl = 4144912697),
                  (this._el = 4290775857),
                  (this._fl = 1750603025),
                  (this._gl = 1694076839),
                  (this._hl = 3204075428),
                  this
                )
              }),
              (u.prototype._hash = function () {
                var f = l.allocUnsafe(48)
                function d(h, p, g) {
                  ;(f.writeInt32BE(h, g), f.writeInt32BE(p, g + 4))
                }
                return (
                  d(this._ah, this._al, 0),
                  d(this._bh, this._bl, 8),
                  d(this._ch, this._cl, 16),
                  d(this._dh, this._dl, 24),
                  d(this._eh, this._el, 32),
                  d(this._fh, this._fl, 40),
                  f
                )
              }),
              (r.exports = u))
          },
          { './hash': 497, './sha512': 504, inherits: 440, 'safe-buffer': 494 },
        ],
        504: [
          function (t, r, i) {
            var s = t('inherits'),
              o = t('./hash'),
              a = t('safe-buffer').Buffer,
              l = [
                1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573,
                2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579,
                2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278,
                1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113,
                2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774,
                944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
                1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882,
                3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956,
                3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895,
                168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485,
                1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350,
                1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
                3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804,
                1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752,
                506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571,
                3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
                1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424,
                442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
                3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606,
                3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270,
                289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971,
                1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158,
                1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
              ],
              c = new Array(160)
            function u() {
              ;(this.init(), (this._w = c), o.call(this, 128, 112))
            }
            function f(C, T, I) {
              return I ^ (C & (T ^ I))
            }
            function d(C, T, I) {
              return (C & T) | (I & (C | T))
            }
            function h(C, T) {
              return ((C >>> 28) | (T << 4)) ^ ((T >>> 2) | (C << 30)) ^ ((T >>> 7) | (C << 25))
            }
            function p(C, T) {
              return ((C >>> 14) | (T << 18)) ^ ((C >>> 18) | (T << 14)) ^ ((T >>> 9) | (C << 23))
            }
            function g(C, T) {
              return ((C >>> 1) | (T << 31)) ^ ((C >>> 8) | (T << 24)) ^ (C >>> 7)
            }
            function m(C, T) {
              return ((C >>> 1) | (T << 31)) ^ ((C >>> 8) | (T << 24)) ^ ((C >>> 7) | (T << 25))
            }
            function y(C, T) {
              return ((C >>> 19) | (T << 13)) ^ ((T >>> 29) | (C << 3)) ^ (C >>> 6)
            }
            function b(C, T) {
              return ((C >>> 19) | (T << 13)) ^ ((T >>> 29) | (C << 3)) ^ ((C >>> 6) | (T << 26))
            }
            function w(C, T) {
              return C >>> 0 < T >>> 0 ? 1 : 0
            }
            ;(s(u, o),
              (u.prototype.init = function () {
                return (
                  (this._ah = 1779033703),
                  (this._bh = 3144134277),
                  (this._ch = 1013904242),
                  (this._dh = 2773480762),
                  (this._eh = 1359893119),
                  (this._fh = 2600822924),
                  (this._gh = 528734635),
                  (this._hh = 1541459225),
                  (this._al = 4089235720),
                  (this._bl = 2227873595),
                  (this._cl = 4271175723),
                  (this._dl = 1595750129),
                  (this._el = 2917565137),
                  (this._fl = 725511199),
                  (this._gl = 4215389547),
                  (this._hl = 327033209),
                  this
                )
              }),
              (u.prototype._update = function (C) {
                for (
                  var T = this._w,
                    I = 0 | this._ah,
                    B = 0 | this._bh,
                    E = 0 | this._ch,
                    O = 0 | this._dh,
                    P = 0 | this._eh,
                    $ = 0 | this._fh,
                    F = 0 | this._gh,
                    M = 0 | this._hh,
                    R = 0 | this._al,
                    k = 0 | this._bl,
                    v = 0 | this._cl,
                    x = 0 | this._dl,
                    _ = 0 | this._el,
                    S = 0 | this._fl,
                    A = 0 | this._gl,
                    j = 0 | this._hl,
                    L = 0;
                  L < 32;
                  L += 2
                )
                  ((T[L] = C.readInt32BE(4 * L)), (T[L + 1] = C.readInt32BE(4 * L + 4)))
                for (; L < 160; L += 2) {
                  var H = T[L - 30],
                    U = T[L - 30 + 1],
                    K = g(H, U),
                    z = m(U, H),
                    q = y((H = T[L - 4]), (U = T[L - 4 + 1])),
                    D = b(U, H),
                    N = T[L - 14],
                    V = T[L - 14 + 1],
                    W = T[L - 32],
                    J = T[L - 32 + 1],
                    G = (z + V) | 0,
                    Z = (K + N + w(G, z)) | 0
                  ;((Z =
                    ((Z = (Z + q + w((G = (G + D) | 0), D)) | 0) + W + w((G = (G + J) | 0), J)) |
                    0),
                    (T[L] = Z),
                    (T[L + 1] = G))
                }
                for (var rt = 0; rt < 160; rt += 2) {
                  ;((Z = T[rt]), (G = T[rt + 1]))
                  var nt = d(I, B, E),
                    X = d(R, k, v),
                    Q = h(I, R),
                    tt = h(R, I),
                    st = p(P, _),
                    ot = p(_, P),
                    at = l[rt],
                    ht = l[rt + 1],
                    dt = f(P, $, F),
                    mt = f(_, S, A),
                    bt = (j + ot) | 0,
                    yt = (M + st + w(bt, j)) | 0
                  yt =
                    ((yt =
                      ((yt = (yt + dt + w((bt = (bt + mt) | 0), mt)) | 0) +
                        at +
                        w((bt = (bt + ht) | 0), ht)) |
                      0) +
                      Z +
                      w((bt = (bt + G) | 0), G)) |
                    0
                  var vt = (tt + X) | 0,
                    Nt = (Q + nt + w(vt, tt)) | 0
                  ;((M = F),
                    (j = A),
                    (F = $),
                    (A = S),
                    ($ = P),
                    (S = _),
                    (P = (O + yt + w((_ = (x + bt) | 0), x)) | 0),
                    (O = E),
                    (x = v),
                    (E = B),
                    (v = k),
                    (B = I),
                    (k = R),
                    (I = (yt + Nt + w((R = (bt + vt) | 0), bt)) | 0))
                }
                ;((this._al = (this._al + R) | 0),
                  (this._bl = (this._bl + k) | 0),
                  (this._cl = (this._cl + v) | 0),
                  (this._dl = (this._dl + x) | 0),
                  (this._el = (this._el + _) | 0),
                  (this._fl = (this._fl + S) | 0),
                  (this._gl = (this._gl + A) | 0),
                  (this._hl = (this._hl + j) | 0),
                  (this._ah = (this._ah + I + w(this._al, R)) | 0),
                  (this._bh = (this._bh + B + w(this._bl, k)) | 0),
                  (this._ch = (this._ch + E + w(this._cl, v)) | 0),
                  (this._dh = (this._dh + O + w(this._dl, x)) | 0),
                  (this._eh = (this._eh + P + w(this._el, _)) | 0),
                  (this._fh = (this._fh + $ + w(this._fl, S)) | 0),
                  (this._gh = (this._gh + F + w(this._gl, A)) | 0),
                  (this._hh = (this._hh + M + w(this._hl, j)) | 0))
              }),
              (u.prototype._hash = function () {
                var C = a.allocUnsafe(64)
                function T(I, B, E) {
                  ;(C.writeInt32BE(I, E), C.writeInt32BE(B, E + 4))
                }
                return (
                  T(this._ah, this._al, 0),
                  T(this._bh, this._bl, 8),
                  T(this._ch, this._cl, 16),
                  T(this._dh, this._dl, 24),
                  T(this._eh, this._el, 32),
                  T(this._fh, this._fl, 40),
                  T(this._gh, this._gl, 48),
                  T(this._hh, this._hl, 56),
                  C
                )
              }),
              (r.exports = u))
          },
          { './hash': 497, inherits: 440, 'safe-buffer': 494 },
        ],
        505: [
          function (t, r, i) {
            r.exports = o
            var s = t('events').EventEmitter
            function o() {
              s.call(this)
            }
            ;(t('inherits')(o, s),
              (o.Readable = t('readable-stream/readable.js')),
              (o.Writable = t('readable-stream/writable.js')),
              (o.Duplex = t('readable-stream/duplex.js')),
              (o.Transform = t('readable-stream/transform.js')),
              (o.PassThrough = t('readable-stream/passthrough.js')),
              (o.Stream = o),
              (o.prototype.pipe = function (a, l) {
                var c = this
                function u(y) {
                  a.writable && a.write(y) === !1 && c.pause && c.pause()
                }
                function f() {
                  c.readable && c.resume && c.resume()
                }
                ;(c.on('data', u),
                  a.on('drain', f),
                  a._isStdio || (l && l.end === !1) || (c.on('end', h), c.on('close', p)))
                var d = !1
                function h() {
                  d || ((d = !0), a.end())
                }
                function p() {
                  d || ((d = !0), typeof a.destroy == 'function' && a.destroy())
                }
                function g(y) {
                  if ((m(), s.listenerCount(this, 'error') === 0)) throw y
                }
                function m() {
                  ;(c.removeListener('data', u),
                    a.removeListener('drain', f),
                    c.removeListener('end', h),
                    c.removeListener('close', p),
                    c.removeListener('error', g),
                    a.removeListener('error', g),
                    c.removeListener('end', m),
                    c.removeListener('close', m),
                    a.removeListener('close', m))
                }
                return (
                  c.on('error', g),
                  a.on('error', g),
                  c.on('end', m),
                  c.on('close', m),
                  a.on('close', m),
                  a.emit('pipe', c),
                  a
                )
              }))
          },
          {
            events: 422,
            inherits: 440,
            'readable-stream/duplex.js': 507,
            'readable-stream/passthrough.js': 516,
            'readable-stream/readable.js': 517,
            'readable-stream/transform.js': 518,
            'readable-stream/writable.js': 519,
          },
        ],
        506: [
          function (t, r, i) {
            var s = {}.toString
            r.exports =
              Array.isArray ||
              function (o) {
                return s.call(o) == '[object Array]'
              }
          },
          {},
        ],
        507: [
          function (t, r, i) {
            r.exports = t('./lib/_stream_duplex.js')
          },
          { './lib/_stream_duplex.js': 508 },
        ],
        508: [
          function (t, r, i) {
            var s = t('process-nextick-args'),
              o =
                Object.keys ||
                function (m) {
                  var y = []
                  for (var b in m) y.push(b)
                  return y
                }
            r.exports = h
            var a = Object.create(t('core-util-is'))
            a.inherits = t('inherits')
            var l = t('./_stream_readable'),
              c = t('./_stream_writable')
            a.inherits(h, l)
            for (var u = o(c.prototype), f = 0; f < u.length; f++) {
              var d = u[f]
              h.prototype[d] || (h.prototype[d] = c.prototype[d])
            }
            function h(m) {
              if (!(this instanceof h)) return new h(m)
              ;(l.call(this, m),
                c.call(this, m),
                m && m.readable === !1 && (this.readable = !1),
                m && m.writable === !1 && (this.writable = !1),
                (this.allowHalfOpen = !0),
                m && m.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
                this.once('end', p))
            }
            function p() {
              this.allowHalfOpen || this._writableState.ended || s.nextTick(g, this)
            }
            function g(m) {
              m.end()
            }
            ;(Object.defineProperty(h.prototype, 'writableHighWaterMark', {
              enumerable: !1,
              get: function () {
                return this._writableState.highWaterMark
              },
            }),
              Object.defineProperty(h.prototype, 'destroyed', {
                get: function () {
                  return (
                    this._readableState !== void 0 &&
                    this._writableState !== void 0 &&
                    this._readableState.destroyed &&
                    this._writableState.destroyed
                  )
                },
                set: function (m) {
                  this._readableState !== void 0 &&
                    this._writableState !== void 0 &&
                    ((this._readableState.destroyed = m), (this._writableState.destroyed = m))
                },
              }),
              (h.prototype._destroy = function (m, y) {
                ;(this.push(null), this.end(), s.nextTick(y, m))
              }))
          },
          {
            './_stream_readable': 510,
            './_stream_writable': 512,
            'core-util-is': 383,
            inherits: 440,
            'process-nextick-args': 466,
          },
        ],
        509: [
          function (t, r, i) {
            r.exports = a
            var s = t('./_stream_transform'),
              o = Object.create(t('core-util-is'))
            function a(l) {
              if (!(this instanceof a)) return new a(l)
              s.call(this, l)
            }
            ;((o.inherits = t('inherits')),
              o.inherits(a, s),
              (a.prototype._transform = function (l, c, u) {
                u(null, l)
              }))
          },
          { './_stream_transform': 511, 'core-util-is': 383, inherits: 440 },
        ],
        510: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                var a = t('process-nextick-args')
                r.exports = I
                var l,
                  c = t('isarray')
                ;((I.ReadableState = T), t('events').EventEmitter)
                var u = function (j, L) {
                    return j.listeners(L).length
                  },
                  f = t('./internal/streams/stream'),
                  d = t('safe-buffer').Buffer,
                  h =
                    (o !== void 0
                      ? o
                      : typeof window < 'u'
                        ? window
                        : typeof self < 'u'
                          ? self
                          : {}
                    ).Uint8Array || function () {},
                  p = Object.create(t('core-util-is'))
                p.inherits = t('inherits')
                var g = t('util'),
                  m = void 0
                m = g && g.debuglog ? g.debuglog('stream') : function () {}
                var y,
                  b = t('./internal/streams/BufferList'),
                  w = t('./internal/streams/destroy')
                p.inherits(I, f)
                var C = ['error', 'close', 'destroy', 'pause', 'resume']
                function T(j, L) {
                  j = j || {}
                  var H = L instanceof (l = l || t('./_stream_duplex'))
                  ;((this.objectMode = !!j.objectMode),
                    H && (this.objectMode = this.objectMode || !!j.readableObjectMode))
                  var U = j.highWaterMark,
                    K = j.readableHighWaterMark,
                    z = this.objectMode ? 16 : 16384
                  ;((this.highWaterMark = U || U === 0 ? U : H && (K || K === 0) ? K : z),
                    (this.highWaterMark = Math.floor(this.highWaterMark)),
                    (this.buffer = new b()),
                    (this.length = 0),
                    (this.pipes = null),
                    (this.pipesCount = 0),
                    (this.flowing = null),
                    (this.ended = !1),
                    (this.endEmitted = !1),
                    (this.reading = !1),
                    (this.sync = !0),
                    (this.needReadable = !1),
                    (this.emittedReadable = !1),
                    (this.readableListening = !1),
                    (this.resumeScheduled = !1),
                    (this.destroyed = !1),
                    (this.defaultEncoding = j.defaultEncoding || 'utf8'),
                    (this.awaitDrain = 0),
                    (this.readingMore = !1),
                    (this.decoder = null),
                    (this.encoding = null),
                    j.encoding &&
                      (y || (y = t('string_decoder/').StringDecoder),
                      (this.decoder = new y(j.encoding)),
                      (this.encoding = j.encoding)))
                }
                function I(j) {
                  if (((l = l || t('./_stream_duplex')), !(this instanceof I))) return new I(j)
                  ;((this._readableState = new T(j, this)),
                    (this.readable = !0),
                    j &&
                      (typeof j.read == 'function' && (this._read = j.read),
                      typeof j.destroy == 'function' && (this._destroy = j.destroy)),
                    f.call(this))
                }
                function B(j, L, H, U, K) {
                  var z,
                    q = j._readableState
                  return (
                    L === null
                      ? ((q.reading = !1),
                        (function (D, N) {
                          if (!N.ended) {
                            if (N.decoder) {
                              var V = N.decoder.end()
                              V &&
                                V.length &&
                                (N.buffer.push(V), (N.length += N.objectMode ? 1 : V.length))
                            }
                            ;((N.ended = !0), P(D))
                          }
                        })(j, q))
                      : (K ||
                          (z = (function (D, N) {
                            var V
                            ;((W = N),
                              d.isBuffer(W) ||
                                W instanceof h ||
                                typeof N == 'string' ||
                                N === void 0 ||
                                D.objectMode ||
                                (V = new TypeError('Invalid non-string/buffer chunk')))
                            var W
                            return V
                          })(q, L)),
                        z
                          ? j.emit('error', z)
                          : q.objectMode || (L && L.length > 0)
                            ? (typeof L == 'string' ||
                                q.objectMode ||
                                Object.getPrototypeOf(L) === d.prototype ||
                                (L = (function (D) {
                                  return d.from(D)
                                })(L)),
                              U
                                ? q.endEmitted
                                  ? j.emit('error', new Error('stream.unshift() after end event'))
                                  : E(j, q, L, !0)
                                : q.ended
                                  ? j.emit('error', new Error('stream.push() after EOF'))
                                  : ((q.reading = !1),
                                    q.decoder && !H
                                      ? ((L = q.decoder.write(L)),
                                        q.objectMode || L.length !== 0 ? E(j, q, L, !1) : F(j, q))
                                      : E(j, q, L, !1)))
                            : U || (q.reading = !1)),
                    (function (D) {
                      return (
                        !D.ended && (D.needReadable || D.length < D.highWaterMark || D.length === 0)
                      )
                    })(q)
                  )
                }
                function E(j, L, H, U) {
                  ;(L.flowing && L.length === 0 && !L.sync
                    ? (j.emit('data', H), j.read(0))
                    : ((L.length += L.objectMode ? 1 : H.length),
                      U ? L.buffer.unshift(H) : L.buffer.push(H),
                      L.needReadable && P(j)),
                    F(j, L))
                }
                ;(Object.defineProperty(I.prototype, 'destroyed', {
                  get: function () {
                    return this._readableState !== void 0 && this._readableState.destroyed
                  },
                  set: function (j) {
                    this._readableState && (this._readableState.destroyed = j)
                  },
                }),
                  (I.prototype.destroy = w.destroy),
                  (I.prototype._undestroy = w.undestroy),
                  (I.prototype._destroy = function (j, L) {
                    ;(this.push(null), L(j))
                  }),
                  (I.prototype.push = function (j, L) {
                    var H,
                      U = this._readableState
                    return (
                      U.objectMode
                        ? (H = !0)
                        : typeof j == 'string' &&
                          ((L = L || U.defaultEncoding) !== U.encoding &&
                            ((j = d.from(j, L)), (L = '')),
                          (H = !0)),
                      B(this, j, L, !1, H)
                    )
                  }),
                  (I.prototype.unshift = function (j) {
                    return B(this, j, null, !0, !1)
                  }),
                  (I.prototype.isPaused = function () {
                    return this._readableState.flowing === !1
                  }),
                  (I.prototype.setEncoding = function (j) {
                    return (
                      y || (y = t('string_decoder/').StringDecoder),
                      (this._readableState.decoder = new y(j)),
                      (this._readableState.encoding = j),
                      this
                    )
                  }))
                function O(j, L) {
                  return j <= 0 || (L.length === 0 && L.ended)
                    ? 0
                    : L.objectMode
                      ? 1
                      : j != j
                        ? L.flowing && L.length
                          ? L.buffer.head.data.length
                          : L.length
                        : (j > L.highWaterMark &&
                            (L.highWaterMark = (function (H) {
                              return (
                                H >= 8388608
                                  ? (H = 8388608)
                                  : (H--,
                                    (H |= H >>> 1),
                                    (H |= H >>> 2),
                                    (H |= H >>> 4),
                                    (H |= H >>> 8),
                                    (H |= H >>> 16),
                                    H++),
                                H
                              )
                            })(j)),
                          j <= L.length ? j : L.ended ? L.length : ((L.needReadable = !0), 0))
                }
                function P(j) {
                  var L = j._readableState
                  ;((L.needReadable = !1),
                    L.emittedReadable ||
                      (m('emitReadable', L.flowing),
                      (L.emittedReadable = !0),
                      L.sync ? a.nextTick($, j) : $(j)))
                }
                function $(j) {
                  ;(m('emit readable'), j.emit('readable'), v(j))
                }
                function F(j, L) {
                  L.readingMore || ((L.readingMore = !0), a.nextTick(M, j, L))
                }
                function M(j, L) {
                  for (
                    var H = L.length;
                    !L.reading &&
                    !L.flowing &&
                    !L.ended &&
                    L.length < L.highWaterMark &&
                    (m('maybeReadMore read 0'), j.read(0), H !== L.length);

                  )
                    H = L.length
                  L.readingMore = !1
                }
                function R(j) {
                  ;(m('readable nexttick read 0'), j.read(0))
                }
                function k(j, L) {
                  ;(L.reading || (m('resume read 0'), j.read(0)),
                    (L.resumeScheduled = !1),
                    (L.awaitDrain = 0),
                    j.emit('resume'),
                    v(j),
                    L.flowing && !L.reading && j.read(0))
                }
                function v(j) {
                  var L = j._readableState
                  for (m('flow', L.flowing); L.flowing && j.read() !== null; );
                }
                function x(j, L) {
                  return L.length === 0
                    ? null
                    : (L.objectMode
                        ? (H = L.buffer.shift())
                        : !j || j >= L.length
                          ? ((H = L.decoder
                              ? L.buffer.join('')
                              : L.buffer.length === 1
                                ? L.buffer.head.data
                                : L.buffer.concat(L.length)),
                            L.buffer.clear())
                          : (H = (function (U, K, z) {
                              var q
                              return (
                                U < K.head.data.length
                                  ? ((q = K.head.data.slice(0, U)),
                                    (K.head.data = K.head.data.slice(U)))
                                  : (q =
                                      U === K.head.data.length
                                        ? K.shift()
                                        : z
                                          ? (function (D, N) {
                                              var V = N.head,
                                                W = 1,
                                                J = V.data
                                              for (D -= J.length; (V = V.next); ) {
                                                var G = V.data,
                                                  Z = D > G.length ? G.length : D
                                                if (
                                                  (Z === G.length ? (J += G) : (J += G.slice(0, D)),
                                                  (D -= Z) === 0)
                                                ) {
                                                  Z === G.length
                                                    ? (++W,
                                                      V.next
                                                        ? (N.head = V.next)
                                                        : (N.head = N.tail = null))
                                                    : ((N.head = V), (V.data = G.slice(Z)))
                                                  break
                                                }
                                                ++W
                                              }
                                              return ((N.length -= W), J)
                                            })(U, K)
                                          : (function (D, N) {
                                              var V = d.allocUnsafe(D),
                                                W = N.head,
                                                J = 1
                                              for (
                                                W.data.copy(V), D -= W.data.length;
                                                (W = W.next);

                                              ) {
                                                var G = W.data,
                                                  Z = D > G.length ? G.length : D
                                                if (
                                                  (G.copy(V, V.length - D, 0, Z), (D -= Z) === 0)
                                                ) {
                                                  Z === G.length
                                                    ? (++J,
                                                      W.next
                                                        ? (N.head = W.next)
                                                        : (N.head = N.tail = null))
                                                    : ((N.head = W), (W.data = G.slice(Z)))
                                                  break
                                                }
                                                ++J
                                              }
                                              return ((N.length -= J), V)
                                            })(U, K)),
                                q
                              )
                            })(j, L.buffer, L.decoder)),
                      H)
                  var H
                }
                function _(j) {
                  var L = j._readableState
                  if (L.length > 0) throw new Error('"endReadable()" called on non-empty stream')
                  L.endEmitted || ((L.ended = !0), a.nextTick(S, L, j))
                }
                function S(j, L) {
                  j.endEmitted ||
                    j.length !== 0 ||
                    ((j.endEmitted = !0), (L.readable = !1), L.emit('end'))
                }
                function A(j, L) {
                  for (var H = 0, U = j.length; H < U; H++) if (j[H] === L) return H
                  return -1
                }
                ;((I.prototype.read = function (j) {
                  ;(m('read', j), (j = parseInt(j, 10)))
                  var L = this._readableState,
                    H = j
                  if (
                    (j !== 0 && (L.emittedReadable = !1),
                    j === 0 && L.needReadable && (L.length >= L.highWaterMark || L.ended))
                  )
                    return (
                      m('read: emitReadable', L.length, L.ended),
                      L.length === 0 && L.ended ? _(this) : P(this),
                      null
                    )
                  if ((j = O(j, L)) === 0 && L.ended) return (L.length === 0 && _(this), null)
                  var U,
                    K = L.needReadable
                  return (
                    m('need readable', K),
                    (L.length === 0 || L.length - j < L.highWaterMark) &&
                      m('length less than watermark', (K = !0)),
                    L.ended || L.reading
                      ? m('reading or ended', (K = !1))
                      : K &&
                        (m('do read'),
                        (L.reading = !0),
                        (L.sync = !0),
                        L.length === 0 && (L.needReadable = !0),
                        this._read(L.highWaterMark),
                        (L.sync = !1),
                        L.reading || (j = O(H, L))),
                    (U = j > 0 ? x(j, L) : null) === null
                      ? ((L.needReadable = !0), (j = 0))
                      : (L.length -= j),
                    L.length === 0 &&
                      (L.ended || (L.needReadable = !0), H !== j && L.ended && _(this)),
                    U !== null && this.emit('data', U),
                    U
                  )
                }),
                  (I.prototype._read = function (j) {
                    this.emit('error', new Error('_read() is not implemented'))
                  }),
                  (I.prototype.pipe = function (j, L) {
                    var H = this,
                      U = this._readableState
                    switch (U.pipesCount) {
                      case 0:
                        U.pipes = j
                        break
                      case 1:
                        U.pipes = [U.pipes, j]
                        break
                      default:
                        U.pipes.push(j)
                    }
                    ;((U.pipesCount += 1), m('pipe count=%d opts=%j', U.pipesCount, L))
                    var K = (!L || L.end !== !1) && j !== s.stdout && j !== s.stderr ? q : rt
                    function z(nt, X) {
                      ;(m('onunpipe'),
                        nt === H &&
                          X &&
                          X.hasUnpiped === !1 &&
                          ((X.hasUnpiped = !0),
                          m('cleanup'),
                          j.removeListener('close', G),
                          j.removeListener('finish', Z),
                          j.removeListener('drain', D),
                          j.removeListener('error', J),
                          j.removeListener('unpipe', z),
                          H.removeListener('end', q),
                          H.removeListener('end', rt),
                          H.removeListener('data', W),
                          (N = !0),
                          !U.awaitDrain ||
                            (j._writableState && !j._writableState.needDrain) ||
                            D()))
                    }
                    function q() {
                      ;(m('onend'), j.end())
                    }
                    ;(U.endEmitted ? a.nextTick(K) : H.once('end', K), j.on('unpipe', z))
                    var D = (function (nt) {
                      return function () {
                        var X = nt._readableState
                        ;(m('pipeOnDrain', X.awaitDrain),
                          X.awaitDrain && X.awaitDrain--,
                          X.awaitDrain === 0 && u(nt, 'data') && ((X.flowing = !0), v(nt)))
                      }
                    })(H)
                    j.on('drain', D)
                    var N = !1,
                      V = !1
                    function W(nt) {
                      ;(m('ondata'),
                        (V = !1),
                        j.write(nt) !== !1 ||
                          V ||
                          (((U.pipesCount === 1 && U.pipes === j) ||
                            (U.pipesCount > 1 && A(U.pipes, j) !== -1)) &&
                            !N &&
                            (m('false write response, pause', U.awaitDrain),
                            U.awaitDrain++,
                            (V = !0)),
                          H.pause()))
                    }
                    function J(nt) {
                      ;(m('onerror', nt),
                        rt(),
                        j.removeListener('error', J),
                        u(j, 'error') === 0 && j.emit('error', nt))
                    }
                    function G() {
                      ;(j.removeListener('finish', Z), rt())
                    }
                    function Z() {
                      ;(m('onfinish'), j.removeListener('close', G), rt())
                    }
                    function rt() {
                      ;(m('unpipe'), H.unpipe(j))
                    }
                    return (
                      H.on('data', W),
                      (function (nt, X, Q) {
                        if (typeof nt.prependListener == 'function') return nt.prependListener(X, Q)
                        nt._events && nt._events[X]
                          ? c(nt._events[X])
                            ? nt._events[X].unshift(Q)
                            : (nt._events[X] = [Q, nt._events[X]])
                          : nt.on(X, Q)
                      })(j, 'error', J),
                      j.once('close', G),
                      j.once('finish', Z),
                      j.emit('pipe', H),
                      U.flowing || (m('pipe resume'), H.resume()),
                      j
                    )
                  }),
                  (I.prototype.unpipe = function (j) {
                    var L = this._readableState,
                      H = { hasUnpiped: !1 }
                    if (L.pipesCount === 0) return this
                    if (L.pipesCount === 1)
                      return (
                        (j && j !== L.pipes) ||
                          (j || (j = L.pipes),
                          (L.pipes = null),
                          (L.pipesCount = 0),
                          (L.flowing = !1),
                          j && j.emit('unpipe', this, H)),
                        this
                      )
                    if (!j) {
                      var U = L.pipes,
                        K = L.pipesCount
                      ;((L.pipes = null), (L.pipesCount = 0), (L.flowing = !1))
                      for (var z = 0; z < K; z++) U[z].emit('unpipe', this, { hasUnpiped: !1 })
                      return this
                    }
                    var q = A(L.pipes, j)
                    return (
                      q === -1 ||
                        (L.pipes.splice(q, 1),
                        (L.pipesCount -= 1),
                        L.pipesCount === 1 && (L.pipes = L.pipes[0]),
                        j.emit('unpipe', this, H)),
                      this
                    )
                  }),
                  (I.prototype.on = function (j, L) {
                    var H = f.prototype.on.call(this, j, L)
                    if (j === 'data') this._readableState.flowing !== !1 && this.resume()
                    else if (j === 'readable') {
                      var U = this._readableState
                      U.endEmitted ||
                        U.readableListening ||
                        ((U.readableListening = U.needReadable = !0),
                        (U.emittedReadable = !1),
                        U.reading ? U.length && P(this) : a.nextTick(R, this))
                    }
                    return H
                  }),
                  (I.prototype.addListener = I.prototype.on),
                  (I.prototype.resume = function () {
                    var j = this._readableState
                    return (
                      j.flowing ||
                        (m('resume'),
                        (j.flowing = !0),
                        (function (L, H) {
                          H.resumeScheduled || ((H.resumeScheduled = !0), a.nextTick(k, L, H))
                        })(this, j)),
                      this
                    )
                  }),
                  (I.prototype.pause = function () {
                    return (
                      m('call pause flowing=%j', this._readableState.flowing),
                      this._readableState.flowing !== !1 &&
                        (m('pause'), (this._readableState.flowing = !1), this.emit('pause')),
                      this
                    )
                  }),
                  (I.prototype.wrap = function (j) {
                    var L = this,
                      H = this._readableState,
                      U = !1
                    for (var K in (j.on('end', function () {
                      if ((m('wrapped end'), H.decoder && !H.ended)) {
                        var q = H.decoder.end()
                        q && q.length && L.push(q)
                      }
                      L.push(null)
                    }),
                    j.on('data', function (q) {
                      ;(m('wrapped data'),
                        H.decoder && (q = H.decoder.write(q)),
                        (H.objectMode && q == null) ||
                          ((H.objectMode || (q && q.length)) &&
                            (L.push(q) || ((U = !0), j.pause()))))
                    }),
                    j))
                      this[K] === void 0 &&
                        typeof j[K] == 'function' &&
                        (this[K] = (function (q) {
                          return function () {
                            return j[q].apply(j, arguments)
                          }
                        })(K))
                    for (var z = 0; z < C.length; z++) j.on(C[z], this.emit.bind(this, C[z]))
                    return (
                      (this._read = function (q) {
                        ;(m('wrapped _read', q), U && ((U = !1), j.resume()))
                      }),
                      this
                    )
                  }),
                  Object.defineProperty(I.prototype, 'readableHighWaterMark', {
                    enumerable: !1,
                    get: function () {
                      return this._readableState.highWaterMark
                    },
                  }),
                  (I._fromList = x))
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {
            './_stream_duplex': 508,
            './internal/streams/BufferList': 513,
            './internal/streams/destroy': 514,
            './internal/streams/stream': 515,
            _process: 467,
            'core-util-is': 383,
            events: 422,
            inherits: 440,
            isarray: 506,
            'process-nextick-args': 466,
            'safe-buffer': 520,
            'string_decoder/': 521,
            util: 188,
          },
        ],
        511: [
          function (t, r, i) {
            r.exports = l
            var s = t('./_stream_duplex'),
              o = Object.create(t('core-util-is'))
            function a(f, d) {
              var h = this._transformState
              h.transforming = !1
              var p = h.writecb
              if (!p) return this.emit('error', new Error('write callback called multiple times'))
              ;((h.writechunk = null), (h.writecb = null), d != null && this.push(d), p(f))
              var g = this._readableState
              ;((g.reading = !1),
                (g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark))
            }
            function l(f) {
              if (!(this instanceof l)) return new l(f)
              ;(s.call(this, f),
                (this._transformState = {
                  afterTransform: a.bind(this),
                  needTransform: !1,
                  transforming: !1,
                  writecb: null,
                  writechunk: null,
                  writeencoding: null,
                }),
                (this._readableState.needReadable = !0),
                (this._readableState.sync = !1),
                f &&
                  (typeof f.transform == 'function' && (this._transform = f.transform),
                  typeof f.flush == 'function' && (this._flush = f.flush)),
                this.on('prefinish', c))
            }
            function c() {
              var f = this
              typeof this._flush == 'function'
                ? this._flush(function (d, h) {
                    u(f, d, h)
                  })
                : u(this, null, null)
            }
            function u(f, d, h) {
              if (d) return f.emit('error', d)
              if ((h != null && f.push(h), f._writableState.length))
                throw new Error('Calling transform done when ws.length != 0')
              if (f._transformState.transforming)
                throw new Error('Calling transform done when still transforming')
              return f.push(null)
            }
            ;((o.inherits = t('inherits')),
              o.inherits(l, s),
              (l.prototype.push = function (f, d) {
                return (
                  (this._transformState.needTransform = !1),
                  s.prototype.push.call(this, f, d)
                )
              }),
              (l.prototype._transform = function (f, d, h) {
                throw new Error('_transform() is not implemented')
              }),
              (l.prototype._write = function (f, d, h) {
                var p = this._transformState
                if (((p.writecb = h), (p.writechunk = f), (p.writeencoding = d), !p.transforming)) {
                  var g = this._readableState
                  ;(p.needTransform || g.needReadable || g.length < g.highWaterMark) &&
                    this._read(g.highWaterMark)
                }
              }),
              (l.prototype._read = function (f) {
                var d = this._transformState
                d.writechunk !== null && d.writecb && !d.transforming
                  ? ((d.transforming = !0),
                    this._transform(d.writechunk, d.writeencoding, d.afterTransform))
                  : (d.needTransform = !0)
              }),
              (l.prototype._destroy = function (f, d) {
                var h = this
                s.prototype._destroy.call(this, f, function (p) {
                  ;(d(p), h.emit('close'))
                })
              }))
          },
          { './_stream_duplex': 508, 'core-util-is': 383, inherits: 440 },
        ],
        512: [
          function (t, r, i) {
            ;(function (s, o, a) {
              ;(function () {
                var l = t('process-nextick-args')
                function c(F) {
                  var M = this
                  ;((this.next = null),
                    (this.entry = null),
                    (this.finish = function () {
                      ;(function (R, k, v) {
                        var x = R.entry
                        for (R.entry = null; x; ) {
                          var _ = x.callback
                          ;(k.pendingcb--, _(v), (x = x.next))
                        }
                        k.corkedRequestsFree.next = R
                      })(M, F)
                    }))
                }
                r.exports = T
                var u,
                  f =
                    !s.browser && ['v0.10', 'v0.9.'].indexOf(s.version.slice(0, 5)) > -1
                      ? a
                      : l.nextTick
                T.WritableState = C
                var d = Object.create(t('core-util-is'))
                d.inherits = t('inherits')
                var h = { deprecate: t('util-deprecate') },
                  p = t('./internal/streams/stream'),
                  g = t('safe-buffer').Buffer,
                  m =
                    (o !== void 0
                      ? o
                      : typeof window < 'u'
                        ? window
                        : typeof self < 'u'
                          ? self
                          : {}
                    ).Uint8Array || function () {},
                  y,
                  b = t('./internal/streams/destroy')
                function w() {}
                function C(F, M) {
                  ;((u = u || t('./_stream_duplex')), (F = F || {}))
                  var R = M instanceof u
                  ;((this.objectMode = !!F.objectMode),
                    R && (this.objectMode = this.objectMode || !!F.writableObjectMode))
                  var k = F.highWaterMark,
                    v = F.writableHighWaterMark,
                    x = this.objectMode ? 16 : 16384
                  ;((this.highWaterMark = k || k === 0 ? k : R && (v || v === 0) ? v : x),
                    (this.highWaterMark = Math.floor(this.highWaterMark)),
                    (this.finalCalled = !1),
                    (this.needDrain = !1),
                    (this.ending = !1),
                    (this.ended = !1),
                    (this.finished = !1),
                    (this.destroyed = !1))
                  var _ = F.decodeStrings === !1
                  ;((this.decodeStrings = !_),
                    (this.defaultEncoding = F.defaultEncoding || 'utf8'),
                    (this.length = 0),
                    (this.writing = !1),
                    (this.corked = 0),
                    (this.sync = !0),
                    (this.bufferProcessing = !1),
                    (this.onwrite = function (S) {
                      ;(function (A, j) {
                        var L = A._writableState,
                          H = L.sync,
                          U = L.writecb
                        if (
                          ((function (z) {
                            ;((z.writing = !1),
                              (z.writecb = null),
                              (z.length -= z.writelen),
                              (z.writelen = 0))
                          })(L),
                          j)
                        )
                          (function (z, q, D, N, V) {
                            ;(--q.pendingcb,
                              D
                                ? (l.nextTick(V, N),
                                  l.nextTick($, z, q),
                                  (z._writableState.errorEmitted = !0),
                                  z.emit('error', N))
                                : (V(N),
                                  (z._writableState.errorEmitted = !0),
                                  z.emit('error', N),
                                  $(z, q)))
                          })(A, L, H, j, U)
                        else {
                          var K = O(L)
                          ;(K || L.corked || L.bufferProcessing || !L.bufferedRequest || E(A, L),
                            H ? f(B, A, L, K, U) : B(A, L, K, U))
                        }
                      })(M, S)
                    }),
                    (this.writecb = null),
                    (this.writelen = 0),
                    (this.bufferedRequest = null),
                    (this.lastBufferedRequest = null),
                    (this.pendingcb = 0),
                    (this.prefinished = !1),
                    (this.errorEmitted = !1),
                    (this.bufferedRequestCount = 0),
                    (this.corkedRequestsFree = new c(this)))
                }
                function T(F) {
                  if (((u = u || t('./_stream_duplex')), !(y.call(T, this) || this instanceof u)))
                    return new T(F)
                  ;((this._writableState = new C(F, this)),
                    (this.writable = !0),
                    F &&
                      (typeof F.write == 'function' && (this._write = F.write),
                      typeof F.writev == 'function' && (this._writev = F.writev),
                      typeof F.destroy == 'function' && (this._destroy = F.destroy),
                      typeof F.final == 'function' && (this._final = F.final)),
                    p.call(this))
                }
                function I(F, M, R, k, v, x, _) {
                  ;((M.writelen = k),
                    (M.writecb = _),
                    (M.writing = !0),
                    (M.sync = !0),
                    R ? F._writev(v, M.onwrite) : F._write(v, x, M.onwrite),
                    (M.sync = !1))
                }
                function B(F, M, R, k) {
                  ;(R ||
                    (function (v, x) {
                      x.length === 0 && x.needDrain && ((x.needDrain = !1), v.emit('drain'))
                    })(F, M),
                    M.pendingcb--,
                    k(),
                    $(F, M))
                }
                function E(F, M) {
                  M.bufferProcessing = !0
                  var R = M.bufferedRequest
                  if (F._writev && R && R.next) {
                    var k = M.bufferedRequestCount,
                      v = new Array(k),
                      x = M.corkedRequestsFree
                    x.entry = R
                    for (var _ = 0, S = !0; R; )
                      ((v[_] = R), R.isBuf || (S = !1), (R = R.next), (_ += 1))
                    ;((v.allBuffers = S),
                      I(F, M, !0, M.length, v, '', x.finish),
                      M.pendingcb++,
                      (M.lastBufferedRequest = null),
                      x.next
                        ? ((M.corkedRequestsFree = x.next), (x.next = null))
                        : (M.corkedRequestsFree = new c(M)),
                      (M.bufferedRequestCount = 0))
                  } else {
                    for (; R; ) {
                      var A = R.chunk,
                        j = R.encoding,
                        L = R.callback
                      if (
                        (I(F, M, !1, M.objectMode ? 1 : A.length, A, j, L),
                        (R = R.next),
                        M.bufferedRequestCount--,
                        M.writing)
                      )
                        break
                    }
                    R === null && (M.lastBufferedRequest = null)
                  }
                  ;((M.bufferedRequest = R), (M.bufferProcessing = !1))
                }
                function O(F) {
                  return (
                    F.ending &&
                    F.length === 0 &&
                    F.bufferedRequest === null &&
                    !F.finished &&
                    !F.writing
                  )
                }
                function P(F, M) {
                  F._final(function (R) {
                    ;(M.pendingcb--,
                      R && F.emit('error', R),
                      (M.prefinished = !0),
                      F.emit('prefinish'),
                      $(F, M))
                  })
                }
                function $(F, M) {
                  var R = O(M)
                  return (
                    R &&
                      ((function (k, v) {
                        v.prefinished ||
                          v.finalCalled ||
                          (typeof k._final == 'function'
                            ? (v.pendingcb++, (v.finalCalled = !0), l.nextTick(P, k, v))
                            : ((v.prefinished = !0), k.emit('prefinish')))
                      })(F, M),
                      M.pendingcb === 0 && ((M.finished = !0), F.emit('finish'))),
                    R
                  )
                }
                ;(d.inherits(T, p),
                  (C.prototype.getBuffer = function () {
                    for (var F = this.bufferedRequest, M = []; F; ) (M.push(F), (F = F.next))
                    return M
                  }),
                  (function () {
                    try {
                      Object.defineProperty(C.prototype, 'buffer', {
                        get: h.deprecate(
                          function () {
                            return this.getBuffer()
                          },
                          '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
                          'DEP0003',
                        ),
                      })
                    } catch {}
                  })(),
                  typeof Symbol == 'function' &&
                  Symbol.hasInstance &&
                  typeof Function.prototype[Symbol.hasInstance] == 'function'
                    ? ((y = Function.prototype[Symbol.hasInstance]),
                      Object.defineProperty(T, Symbol.hasInstance, {
                        value: function (F) {
                          return (
                            !!y.call(this, F) || (this === T && F && F._writableState instanceof C)
                          )
                        },
                      }))
                    : (y = function (F) {
                        return F instanceof this
                      }),
                  (T.prototype.pipe = function () {
                    this.emit('error', new Error('Cannot pipe, not readable'))
                  }),
                  (T.prototype.write = function (F, M, R) {
                    var k,
                      v = this._writableState,
                      x = !1,
                      _ = !v.objectMode && ((k = F), g.isBuffer(k) || k instanceof m)
                    return (
                      _ &&
                        !g.isBuffer(F) &&
                        (F = (function (S) {
                          return g.from(S)
                        })(F)),
                      typeof M == 'function' && ((R = M), (M = null)),
                      _ ? (M = 'buffer') : M || (M = v.defaultEncoding),
                      typeof R != 'function' && (R = w),
                      v.ended
                        ? (function (S, A) {
                            var j = new Error('write after end')
                            ;(S.emit('error', j), l.nextTick(A, j))
                          })(this, R)
                        : (_ ||
                            (function (S, A, j, L) {
                              var H = !0,
                                U = !1
                              return (
                                j === null
                                  ? (U = new TypeError('May not write null values to stream'))
                                  : typeof j == 'string' ||
                                    j === void 0 ||
                                    A.objectMode ||
                                    (U = new TypeError('Invalid non-string/buffer chunk')),
                                U && (S.emit('error', U), l.nextTick(L, U), (H = !1)),
                                H
                              )
                            })(this, v, F, R)) &&
                          (v.pendingcb++,
                          (x = (function (S, A, j, L, H, U) {
                            if (!j) {
                              var K = (function (N, V, W) {
                                return (
                                  N.objectMode ||
                                    N.decodeStrings === !1 ||
                                    typeof V != 'string' ||
                                    (V = g.from(V, W)),
                                  V
                                )
                              })(A, L, H)
                              L !== K && ((j = !0), (H = 'buffer'), (L = K))
                            }
                            var z = A.objectMode ? 1 : L.length
                            A.length += z
                            var q = A.length < A.highWaterMark
                            if ((q || (A.needDrain = !0), A.writing || A.corked)) {
                              var D = A.lastBufferedRequest
                              ;((A.lastBufferedRequest = {
                                chunk: L,
                                encoding: H,
                                isBuf: j,
                                callback: U,
                                next: null,
                              }),
                                D
                                  ? (D.next = A.lastBufferedRequest)
                                  : (A.bufferedRequest = A.lastBufferedRequest),
                                (A.bufferedRequestCount += 1))
                            } else I(S, A, !1, z, L, H, U)
                            return q
                          })(this, v, _, F, M, R))),
                      x
                    )
                  }),
                  (T.prototype.cork = function () {
                    this._writableState.corked++
                  }),
                  (T.prototype.uncork = function () {
                    var F = this._writableState
                    F.corked &&
                      (F.corked--,
                      F.writing ||
                        F.corked ||
                        F.bufferProcessing ||
                        !F.bufferedRequest ||
                        E(this, F))
                  }),
                  (T.prototype.setDefaultEncoding = function (F) {
                    if (
                      (typeof F == 'string' && (F = F.toLowerCase()),
                      !(
                        [
                          'hex',
                          'utf8',
                          'utf-8',
                          'ascii',
                          'binary',
                          'base64',
                          'ucs2',
                          'ucs-2',
                          'utf16le',
                          'utf-16le',
                          'raw',
                        ].indexOf((F + '').toLowerCase()) > -1
                      ))
                    )
                      throw new TypeError('Unknown encoding: ' + F)
                    return ((this._writableState.defaultEncoding = F), this)
                  }),
                  Object.defineProperty(T.prototype, 'writableHighWaterMark', {
                    enumerable: !1,
                    get: function () {
                      return this._writableState.highWaterMark
                    },
                  }),
                  (T.prototype._write = function (F, M, R) {
                    R(new Error('_write() is not implemented'))
                  }),
                  (T.prototype._writev = null),
                  (T.prototype.end = function (F, M, R) {
                    var k = this._writableState
                    ;(typeof F == 'function'
                      ? ((R = F), (F = null), (M = null))
                      : typeof M == 'function' && ((R = M), (M = null)),
                      F != null && this.write(F, M),
                      k.corked && ((k.corked = 1), this.uncork()),
                      k.ending ||
                        (function (v, x, _) {
                          ;((x.ending = !0),
                            $(v, x),
                            _ && (x.finished ? l.nextTick(_) : v.once('finish', _)),
                            (x.ended = !0),
                            (v.writable = !1))
                        })(this, k, R))
                  }),
                  Object.defineProperty(T.prototype, 'destroyed', {
                    get: function () {
                      return this._writableState !== void 0 && this._writableState.destroyed
                    },
                    set: function (F) {
                      this._writableState && (this._writableState.destroyed = F)
                    },
                  }),
                  (T.prototype.destroy = b.destroy),
                  (T.prototype._undestroy = b.undestroy),
                  (T.prototype._destroy = function (F, M) {
                    ;(this.end(), M(F))
                  }))
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
              t('timers').setImmediate,
            )
          },
          {
            './_stream_duplex': 508,
            './internal/streams/destroy': 514,
            './internal/streams/stream': 515,
            _process: 467,
            'core-util-is': 383,
            inherits: 440,
            'process-nextick-args': 466,
            'safe-buffer': 520,
            timers: 523,
            'util-deprecate': 524,
          },
        ],
        513: [
          function (t, r, i) {
            var s = t('safe-buffer').Buffer,
              o = t('util')
            ;((r.exports = (function () {
              function a() {
                ;((function (l, c) {
                  if (!(l instanceof c)) throw new TypeError('Cannot call a class as a function')
                })(this, a),
                  (this.head = null),
                  (this.tail = null),
                  (this.length = 0))
              }
              return (
                (a.prototype.push = function (l) {
                  var c = { data: l, next: null }
                  ;(this.length > 0 ? (this.tail.next = c) : (this.head = c),
                    (this.tail = c),
                    ++this.length)
                }),
                (a.prototype.unshift = function (l) {
                  var c = { data: l, next: this.head }
                  ;(this.length === 0 && (this.tail = c), (this.head = c), ++this.length)
                }),
                (a.prototype.shift = function () {
                  if (this.length !== 0) {
                    var l = this.head.data
                    return (
                      this.length === 1
                        ? (this.head = this.tail = null)
                        : (this.head = this.head.next),
                      --this.length,
                      l
                    )
                  }
                }),
                (a.prototype.clear = function () {
                  ;((this.head = this.tail = null), (this.length = 0))
                }),
                (a.prototype.join = function (l) {
                  if (this.length === 0) return ''
                  for (var c = this.head, u = '' + c.data; (c = c.next); ) u += l + c.data
                  return u
                }),
                (a.prototype.concat = function (l) {
                  if (this.length === 0) return s.alloc(0)
                  for (var c, u, f, d = s.allocUnsafe(l >>> 0), h = this.head, p = 0; h; )
                    ((c = h.data),
                      (u = d),
                      (f = p),
                      c.copy(u, f),
                      (p += h.data.length),
                      (h = h.next))
                  return d
                }),
                a
              )
            })()),
              o &&
                o.inspect &&
                o.inspect.custom &&
                (r.exports.prototype[o.inspect.custom] = function () {
                  var a = o.inspect({ length: this.length })
                  return this.constructor.name + ' ' + a
                }))
          },
          { 'safe-buffer': 520, util: 188 },
        ],
        514: [
          function (t, r, i) {
            var s = t('process-nextick-args')
            function o(a, l) {
              a.emit('error', l)
            }
            r.exports = {
              destroy: function (a, l) {
                var c = this,
                  u = this._readableState && this._readableState.destroyed,
                  f = this._writableState && this._writableState.destroyed
                return u || f
                  ? (l
                      ? l(a)
                      : a &&
                        (this._writableState
                          ? this._writableState.errorEmitted ||
                            ((this._writableState.errorEmitted = !0), s.nextTick(o, this, a))
                          : s.nextTick(o, this, a)),
                    this)
                  : (this._readableState && (this._readableState.destroyed = !0),
                    this._writableState && (this._writableState.destroyed = !0),
                    this._destroy(a || null, function (d) {
                      !l && d
                        ? c._writableState
                          ? c._writableState.errorEmitted ||
                            ((c._writableState.errorEmitted = !0), s.nextTick(o, c, d))
                          : s.nextTick(o, c, d)
                        : l && l(d)
                    }),
                    this)
              },
              undestroy: function () {
                ;(this._readableState &&
                  ((this._readableState.destroyed = !1),
                  (this._readableState.reading = !1),
                  (this._readableState.ended = !1),
                  (this._readableState.endEmitted = !1)),
                  this._writableState &&
                    ((this._writableState.destroyed = !1),
                    (this._writableState.ended = !1),
                    (this._writableState.ending = !1),
                    (this._writableState.finalCalled = !1),
                    (this._writableState.prefinished = !1),
                    (this._writableState.finished = !1),
                    (this._writableState.errorEmitted = !1)))
              },
            }
          },
          { 'process-nextick-args': 466 },
        ],
        515: [
          function (t, r, i) {
            arguments[4][490][0].apply(i, arguments)
          },
          { dup: 490, events: 422 },
        ],
        516: [
          function (t, r, i) {
            r.exports = t('./readable').PassThrough
          },
          { './readable': 517 },
        ],
        517: [
          function (t, r, i) {
            ;(((i = r.exports = t('./lib/_stream_readable.js')).Stream = i),
              (i.Readable = i),
              (i.Writable = t('./lib/_stream_writable.js')),
              (i.Duplex = t('./lib/_stream_duplex.js')),
              (i.Transform = t('./lib/_stream_transform.js')),
              (i.PassThrough = t('./lib/_stream_passthrough.js')))
          },
          {
            './lib/_stream_duplex.js': 508,
            './lib/_stream_passthrough.js': 509,
            './lib/_stream_readable.js': 510,
            './lib/_stream_transform.js': 511,
            './lib/_stream_writable.js': 512,
          },
        ],
        518: [
          function (t, r, i) {
            r.exports = t('./readable').Transform
          },
          { './readable': 517 },
        ],
        519: [
          function (t, r, i) {
            r.exports = t('./lib/_stream_writable.js')
          },
          { './lib/_stream_writable.js': 512 },
        ],
        520: [
          function (t, r, i) {
            arguments[4][217][0].apply(i, arguments)
          },
          { buffer: 220, dup: 217 },
        ],
        521: [
          function (t, r, i) {
            arguments[4][218][0].apply(i, arguments)
          },
          { dup: 218, 'safe-buffer': 520 },
        ],
        522: [
          function (t, r, i) {
            arguments[4][218][0].apply(i, arguments)
          },
          { dup: 218, 'safe-buffer': 494 },
        ],
        523: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                var a = t('process/browser.js').nextTick,
                  l = Function.prototype.apply,
                  c = Array.prototype.slice,
                  u = {},
                  f = 0
                function d(h, p) {
                  ;((this._id = h), (this._clearFn = p))
                }
                ;((i.setTimeout = function () {
                  return new d(l.call(setTimeout, window, arguments), clearTimeout)
                }),
                  (i.setInterval = function () {
                    return new d(l.call(setInterval, window, arguments), clearInterval)
                  }),
                  (i.clearTimeout = i.clearInterval =
                    function (h) {
                      h.close()
                    }),
                  (d.prototype.unref = d.prototype.ref = function () {}),
                  (d.prototype.close = function () {
                    this._clearFn.call(window, this._id)
                  }),
                  (i.enroll = function (h, p) {
                    ;(clearTimeout(h._idleTimeoutId), (h._idleTimeout = p))
                  }),
                  (i.unenroll = function (h) {
                    ;(clearTimeout(h._idleTimeoutId), (h._idleTimeout = -1))
                  }),
                  (i._unrefActive = i.active =
                    function (h) {
                      clearTimeout(h._idleTimeoutId)
                      var p = h._idleTimeout
                      p >= 0 &&
                        (h._idleTimeoutId = setTimeout(function () {
                          h._onTimeout && h._onTimeout()
                        }, p))
                    }),
                  (i.setImmediate =
                    typeof s == 'function'
                      ? s
                      : function (h) {
                          var p = f++,
                            g = !(arguments.length < 2) && c.call(arguments, 1)
                          return (
                            (u[p] = !0),
                            a(function () {
                              u[p] && (g ? h.apply(null, g) : h.call(null), i.clearImmediate(p))
                            }),
                            p
                          )
                        }),
                  (i.clearImmediate =
                    typeof o == 'function'
                      ? o
                      : function (h) {
                          delete u[h]
                        }))
              }).call(this)
            }).call(this, t('timers').setImmediate, t('timers').clearImmediate)
          },
          { 'process/browser.js': 467, timers: 523 },
        ],
        524: [
          function (t, r, i) {
            ;(function (s) {
              ;(function () {
                function o(a) {
                  try {
                    if (!s.localStorage) return !1
                  } catch {
                    return !1
                  }
                  var l = s.localStorage[a]
                  return l != null && String(l).toLowerCase() === 'true'
                }
                r.exports = function (a, l) {
                  if (o('noDeprecation')) return a
                  var c = !1
                  return function () {
                    if (!c) {
                      if (o('throwDeprecation')) throw new Error(l)
                      ;(o('traceDeprecation') ? console.trace(l) : console.warn(l), (c = !0))
                    }
                    return a.apply(this, arguments)
                  }
                }
              }).call(this)
            }).call(
              this,
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          {},
        ],
        525: [
          function (t, r, i) {
            typeof Object.create == 'function'
              ? (r.exports = function (s, o) {
                  ;((s.super_ = o),
                    (s.prototype = Object.create(o.prototype, {
                      constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 },
                    })))
                })
              : (r.exports = function (s, o) {
                  s.super_ = o
                  var a = function () {}
                  ;((a.prototype = o.prototype),
                    (s.prototype = new a()),
                    (s.prototype.constructor = s))
                })
          },
          {},
        ],
        526: [
          function (t, r, i) {
            r.exports = function (s) {
              return (
                s &&
                typeof s == 'object' &&
                typeof s.copy == 'function' &&
                typeof s.fill == 'function' &&
                typeof s.readUInt8 == 'function'
              )
            }
          },
          {},
        ],
        527: [
          function (t, r, i) {
            ;(function (s, o) {
              ;(function () {
                var a = /%[sdj%]/g
                ;((i.format = function (v) {
                  if (!C(v)) {
                    for (var x = [], _ = 0; _ < arguments.length; _++) x.push(u(arguments[_]))
                    return x.join(' ')
                  }
                  _ = 1
                  for (
                    var S = arguments,
                      A = S.length,
                      j = String(v).replace(a, function (H) {
                        if (H === '%%') return '%'
                        if (_ >= A) return H
                        switch (H) {
                          case '%s':
                            return String(S[_++])
                          case '%d':
                            return Number(S[_++])
                          case '%j':
                            try {
                              return JSON.stringify(S[_++])
                            } catch {
                              return '[Circular]'
                            }
                          default:
                            return H
                        }
                      }),
                      L = S[_];
                    _ < A;
                    L = S[++_]
                  )
                    b(L) || !B(L) ? (j += ' ' + L) : (j += ' ' + u(L))
                  return j
                }),
                  (i.deprecate = function (v, x) {
                    if (T(o.process))
                      return function () {
                        return i.deprecate(v, x).apply(this, arguments)
                      }
                    if (s.noDeprecation === !0) return v
                    var _ = !1
                    return function () {
                      if (!_) {
                        if (s.throwDeprecation) throw new Error(x)
                        ;(s.traceDeprecation ? console.trace(x) : console.error(x), (_ = !0))
                      }
                      return v.apply(this, arguments)
                    }
                  }))
                var l,
                  c = {}
                function u(v, x) {
                  var _ = { seen: [], stylize: d }
                  return (
                    arguments.length >= 3 && (_.depth = arguments[2]),
                    arguments.length >= 4 && (_.colors = arguments[3]),
                    y(x) ? (_.showHidden = x) : x && i._extend(_, x),
                    T(_.showHidden) && (_.showHidden = !1),
                    T(_.depth) && (_.depth = 2),
                    T(_.colors) && (_.colors = !1),
                    T(_.customInspect) && (_.customInspect = !0),
                    _.colors && (_.stylize = f),
                    h(_, v, _.depth)
                  )
                }
                function f(v, x) {
                  var _ = u.styles[x]
                  return _ ? '\x1B[' + u.colors[_][0] + 'm' + v + '\x1B[' + u.colors[_][1] + 'm' : v
                }
                function d(v, x) {
                  return v
                }
                function h(v, x, _) {
                  if (
                    v.customInspect &&
                    x &&
                    P(x.inspect) &&
                    x.inspect !== i.inspect &&
                    (!x.constructor || x.constructor.prototype !== x)
                  ) {
                    var S = x.inspect(_, v)
                    return (C(S) || (S = h(v, S, _)), S)
                  }
                  var A = (function (D, N) {
                    if (T(N)) return D.stylize('undefined', 'undefined')
                    if (C(N)) {
                      var V =
                        "'" +
                        JSON.stringify(N)
                          .replace(/^"|"$/g, '')
                          .replace(/'/g, "\\'")
                          .replace(/\\"/g, '"') +
                        "'"
                      return D.stylize(V, 'string')
                    }
                    if (w(N)) return D.stylize('' + N, 'number')
                    if (y(N)) return D.stylize('' + N, 'boolean')
                    if (b(N)) return D.stylize('null', 'null')
                  })(v, x)
                  if (A) return A
                  var j = Object.keys(x),
                    L = (function (D) {
                      var N = {}
                      return (
                        D.forEach(function (V, W) {
                          N[V] = !0
                        }),
                        N
                      )
                    })(j)
                  if (
                    (v.showHidden && (j = Object.getOwnPropertyNames(x)),
                    O(x) && (j.indexOf('message') >= 0 || j.indexOf('description') >= 0))
                  )
                    return p(x)
                  if (j.length === 0) {
                    if (P(x)) {
                      var H = x.name ? ': ' + x.name : ''
                      return v.stylize('[Function' + H + ']', 'special')
                    }
                    if (I(x)) return v.stylize(RegExp.prototype.toString.call(x), 'regexp')
                    if (E(x)) return v.stylize(Date.prototype.toString.call(x), 'date')
                    if (O(x)) return p(x)
                  }
                  var U,
                    K = '',
                    z = !1,
                    q = ['{', '}']
                  return (
                    m(x) && ((z = !0), (q = ['[', ']'])),
                    P(x) && (K = ' [Function' + (x.name ? ': ' + x.name : '') + ']'),
                    I(x) && (K = ' ' + RegExp.prototype.toString.call(x)),
                    E(x) && (K = ' ' + Date.prototype.toUTCString.call(x)),
                    O(x) && (K = ' ' + p(x)),
                    j.length !== 0 || (z && x.length != 0)
                      ? _ < 0
                        ? I(x)
                          ? v.stylize(RegExp.prototype.toString.call(x), 'regexp')
                          : v.stylize('[Object]', 'special')
                        : (v.seen.push(x),
                          (U = z
                            ? (function (D, N, V, W, J) {
                                for (var G = [], Z = 0, rt = N.length; Z < rt; ++Z)
                                  k(N, String(Z))
                                    ? G.push(g(D, N, V, W, String(Z), !0))
                                    : G.push('')
                                return (
                                  J.forEach(function (nt) {
                                    nt.match(/^\d+$/) || G.push(g(D, N, V, W, nt, !0))
                                  }),
                                  G
                                )
                              })(v, x, _, L, j)
                            : j.map(function (D) {
                                return g(v, x, _, L, D, z)
                              })),
                          v.seen.pop(),
                          (function (D, N, V) {
                            return D.reduce(function (W, J) {
                              return (
                                J.indexOf(`
`) >= 0,
                                W + J.replace(/\u001b\[\d\d?m/g, '').length + 1
                              )
                            }, 0) > 60
                              ? V[0] +
                                  (N === ''
                                    ? ''
                                    : N +
                                      `
 `) +
                                  ' ' +
                                  D.join(`,
  `) +
                                  ' ' +
                                  V[1]
                              : V[0] + N + ' ' + D.join(', ') + ' ' + V[1]
                          })(U, K, q))
                      : q[0] + K + q[1]
                  )
                }
                function p(v) {
                  return '[' + Error.prototype.toString.call(v) + ']'
                }
                function g(v, x, _, S, A, j) {
                  var L, H, U
                  if (
                    ((U = Object.getOwnPropertyDescriptor(x, A) || { value: x[A] }).get
                      ? (H = U.set
                          ? v.stylize('[Getter/Setter]', 'special')
                          : v.stylize('[Getter]', 'special'))
                      : U.set && (H = v.stylize('[Setter]', 'special')),
                    k(S, A) || (L = '[' + A + ']'),
                    H ||
                      (v.seen.indexOf(U.value) < 0
                        ? (H = b(_) ? h(v, U.value, null) : h(v, U.value, _ - 1)).indexOf(`
`) > -1 &&
                          (H = j
                            ? H.split(
                                `
`,
                              )
                                .map(function (K) {
                                  return '  ' + K
                                })
                                .join(
                                  `
`,
                                )
                                .substr(2)
                            : `
` +
                              H.split(
                                `
`,
                              ).map(function (K) {
                                return '   ' + K
                              }).join(`
`))
                        : (H = v.stylize('[Circular]', 'special'))),
                    T(L))
                  ) {
                    if (j && A.match(/^\d+$/)) return H
                    ;(L = JSON.stringify('' + A)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
                      ? ((L = L.substr(1, L.length - 2)), (L = v.stylize(L, 'name')))
                      : ((L = L.replace(/'/g, "\\'")
                          .replace(/\\"/g, '"')
                          .replace(/(^"|"$)/g, "'")),
                        (L = v.stylize(L, 'string')))
                  }
                  return L + ': ' + H
                }
                function m(v) {
                  return Array.isArray(v)
                }
                function y(v) {
                  return typeof v == 'boolean'
                }
                function b(v) {
                  return v === null
                }
                function w(v) {
                  return typeof v == 'number'
                }
                function C(v) {
                  return typeof v == 'string'
                }
                function T(v) {
                  return v === void 0
                }
                function I(v) {
                  return B(v) && $(v) === '[object RegExp]'
                }
                function B(v) {
                  return typeof v == 'object' && v !== null
                }
                function E(v) {
                  return B(v) && $(v) === '[object Date]'
                }
                function O(v) {
                  return B(v) && ($(v) === '[object Error]' || v instanceof Error)
                }
                function P(v) {
                  return typeof v == 'function'
                }
                function $(v) {
                  return Object.prototype.toString.call(v)
                }
                function F(v) {
                  return v < 10 ? '0' + v.toString(10) : v.toString(10)
                }
                ;((i.debuglog = function (v) {
                  if ((T(l) && (l = s.env.NODE_DEBUG || ''), (v = v.toUpperCase()), !c[v]))
                    if (new RegExp('\\b' + v + '\\b', 'i').test(l)) {
                      var x = s.pid
                      c[v] = function () {
                        var _ = i.format.apply(i, arguments)
                        console.error('%s %d: %s', v, x, _)
                      }
                    } else c[v] = function () {}
                  return c[v]
                }),
                  (i.inspect = u),
                  (u.colors = {
                    bold: [1, 22],
                    italic: [3, 23],
                    underline: [4, 24],
                    inverse: [7, 27],
                    white: [37, 39],
                    grey: [90, 39],
                    black: [30, 39],
                    blue: [34, 39],
                    cyan: [36, 39],
                    green: [32, 39],
                    magenta: [35, 39],
                    red: [31, 39],
                    yellow: [33, 39],
                  }),
                  (u.styles = {
                    special: 'cyan',
                    number: 'yellow',
                    boolean: 'yellow',
                    undefined: 'grey',
                    null: 'bold',
                    string: 'green',
                    date: 'magenta',
                    regexp: 'red',
                  }),
                  (i.isArray = m),
                  (i.isBoolean = y),
                  (i.isNull = b),
                  (i.isNullOrUndefined = function (v) {
                    return v == null
                  }),
                  (i.isNumber = w),
                  (i.isString = C),
                  (i.isSymbol = function (v) {
                    return typeof v == 'symbol'
                  }),
                  (i.isUndefined = T),
                  (i.isRegExp = I),
                  (i.isObject = B),
                  (i.isDate = E),
                  (i.isError = O),
                  (i.isFunction = P),
                  (i.isPrimitive = function (v) {
                    return (
                      v === null ||
                      typeof v == 'boolean' ||
                      typeof v == 'number' ||
                      typeof v == 'string' ||
                      typeof v == 'symbol' ||
                      v === void 0
                    )
                  }),
                  (i.isBuffer = t('./support/isBuffer')))
                var M = [
                  'Jan',
                  'Feb',
                  'Mar',
                  'Apr',
                  'May',
                  'Jun',
                  'Jul',
                  'Aug',
                  'Sep',
                  'Oct',
                  'Nov',
                  'Dec',
                ]
                function R() {
                  var v = new Date(),
                    x = [F(v.getHours()), F(v.getMinutes()), F(v.getSeconds())].join(':')
                  return [v.getDate(), M[v.getMonth()], x].join(' ')
                }
                function k(v, x) {
                  return Object.prototype.hasOwnProperty.call(v, x)
                }
                ;((i.log = function () {
                  console.log('%s - %s', R(), i.format.apply(i, arguments))
                }),
                  (i.inherits = t('inherits')),
                  (i._extend = function (v, x) {
                    if (!x || !B(x)) return v
                    for (var _ = Object.keys(x), S = _.length; S--; ) v[_[S]] = x[_[S]]
                    return v
                  }))
              }).call(this)
            }).call(
              this,
              t('_process'),
              typeof xe < 'u' ? xe : typeof self < 'u' ? self : typeof window < 'u' ? window : {},
            )
          },
          { './support/isBuffer': 526, _process: 467, inherits: 525 },
        ],
        528: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              Object.defineProperty(i, 'v1', {
                enumerable: !0,
                get: function () {
                  return s.default
                },
              }),
              Object.defineProperty(i, 'v3', {
                enumerable: !0,
                get: function () {
                  return o.default
                },
              }),
              Object.defineProperty(i, 'v4', {
                enumerable: !0,
                get: function () {
                  return a.default
                },
              }),
              Object.defineProperty(i, 'v5', {
                enumerable: !0,
                get: function () {
                  return l.default
                },
              }),
              Object.defineProperty(i, 'NIL', {
                enumerable: !0,
                get: function () {
                  return c.default
                },
              }),
              Object.defineProperty(i, 'version', {
                enumerable: !0,
                get: function () {
                  return u.default
                },
              }),
              Object.defineProperty(i, 'validate', {
                enumerable: !0,
                get: function () {
                  return f.default
                },
              }),
              Object.defineProperty(i, 'stringify', {
                enumerable: !0,
                get: function () {
                  return d.default
                },
              }),
              Object.defineProperty(i, 'parse', {
                enumerable: !0,
                get: function () {
                  return h.default
                },
              }))
            var s = p(t('./v1.js')),
              o = p(t('./v3.js')),
              a = p(t('./v4.js')),
              l = p(t('./v5.js')),
              c = p(t('./nil.js')),
              u = p(t('./version.js')),
              f = p(t('./validate.js')),
              d = p(t('./stringify.js')),
              h = p(t('./parse.js'))
            function p(g) {
              return g && g.__esModule ? g : { default: g }
            }
          },
          {
            './nil.js': 530,
            './parse.js': 531,
            './stringify.js': 535,
            './v1.js': 536,
            './v3.js': 537,
            './v4.js': 539,
            './v5.js': 540,
            './validate.js': 541,
            './version.js': 542,
          },
        ],
        529: [
          function (t, r, i) {
            function s(h) {
              return 14 + (((h + 64) >>> 9) << 4) + 1
            }
            function o(h, p) {
              const g = (65535 & h) + (65535 & p)
              return (((h >> 16) + (p >> 16) + (g >> 16)) << 16) | (65535 & g)
            }
            function a(h, p, g, m, y, b) {
              return o(((w = o(o(p, h), o(m, b))) << (C = y)) | (w >>> (32 - C)), g)
              var w, C
            }
            function l(h, p, g, m, y, b, w) {
              return a((p & g) | (~p & m), h, p, y, b, w)
            }
            function c(h, p, g, m, y, b, w) {
              return a((p & m) | (g & ~m), h, p, y, b, w)
            }
            function u(h, p, g, m, y, b, w) {
              return a(p ^ g ^ m, h, p, y, b, w)
            }
            function f(h, p, g, m, y, b, w) {
              return a(g ^ (p | ~m), h, p, y, b, w)
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var d = function (h) {
              if (typeof h == 'string') {
                const p = unescape(encodeURIComponent(h))
                h = new Uint8Array(p.length)
                for (let g = 0; g < p.length; ++g) h[g] = p.charCodeAt(g)
              }
              return (function (p) {
                const g = [],
                  m = 32 * p.length
                for (let y = 0; y < m; y += 8) {
                  const b = (p[y >> 5] >>> y % 32) & 255,
                    w = parseInt(
                      '0123456789abcdef'.charAt((b >>> 4) & 15) + '0123456789abcdef'.charAt(15 & b),
                      16,
                    )
                  g.push(w)
                }
                return g
              })(
                (function (p, g) {
                  ;((p[g >> 5] |= 128 << g % 32), (p[s(g) - 1] = g))
                  let m = 1732584193,
                    y = -271733879,
                    b = -1732584194,
                    w = 271733878
                  for (let C = 0; C < p.length; C += 16) {
                    const T = m,
                      I = y,
                      B = b,
                      E = w
                    ;((m = l(m, y, b, w, p[C], 7, -680876936)),
                      (w = l(w, m, y, b, p[C + 1], 12, -389564586)),
                      (b = l(b, w, m, y, p[C + 2], 17, 606105819)),
                      (y = l(y, b, w, m, p[C + 3], 22, -1044525330)),
                      (m = l(m, y, b, w, p[C + 4], 7, -176418897)),
                      (w = l(w, m, y, b, p[C + 5], 12, 1200080426)),
                      (b = l(b, w, m, y, p[C + 6], 17, -1473231341)),
                      (y = l(y, b, w, m, p[C + 7], 22, -45705983)),
                      (m = l(m, y, b, w, p[C + 8], 7, 1770035416)),
                      (w = l(w, m, y, b, p[C + 9], 12, -1958414417)),
                      (b = l(b, w, m, y, p[C + 10], 17, -42063)),
                      (y = l(y, b, w, m, p[C + 11], 22, -1990404162)),
                      (m = l(m, y, b, w, p[C + 12], 7, 1804603682)),
                      (w = l(w, m, y, b, p[C + 13], 12, -40341101)),
                      (b = l(b, w, m, y, p[C + 14], 17, -1502002290)),
                      (y = l(y, b, w, m, p[C + 15], 22, 1236535329)),
                      (m = c(m, y, b, w, p[C + 1], 5, -165796510)),
                      (w = c(w, m, y, b, p[C + 6], 9, -1069501632)),
                      (b = c(b, w, m, y, p[C + 11], 14, 643717713)),
                      (y = c(y, b, w, m, p[C], 20, -373897302)),
                      (m = c(m, y, b, w, p[C + 5], 5, -701558691)),
                      (w = c(w, m, y, b, p[C + 10], 9, 38016083)),
                      (b = c(b, w, m, y, p[C + 15], 14, -660478335)),
                      (y = c(y, b, w, m, p[C + 4], 20, -405537848)),
                      (m = c(m, y, b, w, p[C + 9], 5, 568446438)),
                      (w = c(w, m, y, b, p[C + 14], 9, -1019803690)),
                      (b = c(b, w, m, y, p[C + 3], 14, -187363961)),
                      (y = c(y, b, w, m, p[C + 8], 20, 1163531501)),
                      (m = c(m, y, b, w, p[C + 13], 5, -1444681467)),
                      (w = c(w, m, y, b, p[C + 2], 9, -51403784)),
                      (b = c(b, w, m, y, p[C + 7], 14, 1735328473)),
                      (y = c(y, b, w, m, p[C + 12], 20, -1926607734)),
                      (m = u(m, y, b, w, p[C + 5], 4, -378558)),
                      (w = u(w, m, y, b, p[C + 8], 11, -2022574463)),
                      (b = u(b, w, m, y, p[C + 11], 16, 1839030562)),
                      (y = u(y, b, w, m, p[C + 14], 23, -35309556)),
                      (m = u(m, y, b, w, p[C + 1], 4, -1530992060)),
                      (w = u(w, m, y, b, p[C + 4], 11, 1272893353)),
                      (b = u(b, w, m, y, p[C + 7], 16, -155497632)),
                      (y = u(y, b, w, m, p[C + 10], 23, -1094730640)),
                      (m = u(m, y, b, w, p[C + 13], 4, 681279174)),
                      (w = u(w, m, y, b, p[C], 11, -358537222)),
                      (b = u(b, w, m, y, p[C + 3], 16, -722521979)),
                      (y = u(y, b, w, m, p[C + 6], 23, 76029189)),
                      (m = u(m, y, b, w, p[C + 9], 4, -640364487)),
                      (w = u(w, m, y, b, p[C + 12], 11, -421815835)),
                      (b = u(b, w, m, y, p[C + 15], 16, 530742520)),
                      (y = u(y, b, w, m, p[C + 2], 23, -995338651)),
                      (m = f(m, y, b, w, p[C], 6, -198630844)),
                      (w = f(w, m, y, b, p[C + 7], 10, 1126891415)),
                      (b = f(b, w, m, y, p[C + 14], 15, -1416354905)),
                      (y = f(y, b, w, m, p[C + 5], 21, -57434055)),
                      (m = f(m, y, b, w, p[C + 12], 6, 1700485571)),
                      (w = f(w, m, y, b, p[C + 3], 10, -1894986606)),
                      (b = f(b, w, m, y, p[C + 10], 15, -1051523)),
                      (y = f(y, b, w, m, p[C + 1], 21, -2054922799)),
                      (m = f(m, y, b, w, p[C + 8], 6, 1873313359)),
                      (w = f(w, m, y, b, p[C + 15], 10, -30611744)),
                      (b = f(b, w, m, y, p[C + 6], 15, -1560198380)),
                      (y = f(y, b, w, m, p[C + 13], 21, 1309151649)),
                      (m = f(m, y, b, w, p[C + 4], 6, -145523070)),
                      (w = f(w, m, y, b, p[C + 11], 10, -1120210379)),
                      (b = f(b, w, m, y, p[C + 2], 15, 718787259)),
                      (y = f(y, b, w, m, p[C + 9], 21, -343485551)),
                      (m = o(m, T)),
                      (y = o(y, I)),
                      (b = o(b, B)),
                      (w = o(w, E)))
                  }
                  return [m, y, b, w]
                })(
                  (function (p) {
                    if (p.length === 0) return []
                    const g = 8 * p.length,
                      m = new Uint32Array(s(g))
                    for (let y = 0; y < g; y += 8) m[y >> 5] |= (255 & p[y / 8]) << y % 32
                    return m
                  })(h),
                  8 * h.length,
                ),
              )
            }
            i.default = d
          },
          {},
        ],
        530: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.default = void 0),
              (i.default = '00000000-0000-0000-0000-000000000000'))
          },
          {},
        ],
        531: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s,
              o = (s = t('./validate.js')) && s.__esModule ? s : { default: s },
              a = function (l) {
                if (!(0, o.default)(l)) throw TypeError('Invalid UUID')
                let c
                const u = new Uint8Array(16)
                return (
                  (u[0] = (c = parseInt(l.slice(0, 8), 16)) >>> 24),
                  (u[1] = (c >>> 16) & 255),
                  (u[2] = (c >>> 8) & 255),
                  (u[3] = 255 & c),
                  (u[4] = (c = parseInt(l.slice(9, 13), 16)) >>> 8),
                  (u[5] = 255 & c),
                  (u[6] = (c = parseInt(l.slice(14, 18), 16)) >>> 8),
                  (u[7] = 255 & c),
                  (u[8] = (c = parseInt(l.slice(19, 23), 16)) >>> 8),
                  (u[9] = 255 & c),
                  (u[10] = ((c = parseInt(l.slice(24, 36), 16)) / 1099511627776) & 255),
                  (u[11] = (c / 4294967296) & 255),
                  (u[12] = (c >>> 24) & 255),
                  (u[13] = (c >>> 16) & 255),
                  (u[14] = (c >>> 8) & 255),
                  (u[15] = 255 & c),
                  u
                )
              }
            i.default = a
          },
          { './validate.js': 541 },
        ],
        532: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.default = void 0),
              (i.default =
                /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i))
          },
          {},
        ],
        533: [
          function (t, r, i) {
            let s
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.default = function () {
                if (
                  !s &&
                  ((s =
                    (typeof crypto < 'u' &&
                      crypto.getRandomValues &&
                      crypto.getRandomValues.bind(crypto)) ||
                    (typeof msCrypto < 'u' &&
                      typeof msCrypto.getRandomValues == 'function' &&
                      msCrypto.getRandomValues.bind(msCrypto))),
                  !s)
                )
                  throw new Error(
                    'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported',
                  )
                return s(o)
              }))
            const o = new Uint8Array(16)
          },
          {},
        ],
        534: [
          function (t, r, i) {
            function s(l, c, u, f) {
              switch (l) {
                case 0:
                  return (c & u) ^ (~c & f)
                case 1:
                  return c ^ u ^ f
                case 2:
                  return (c & u) ^ (c & f) ^ (u & f)
                case 3:
                  return c ^ u ^ f
              }
            }
            function o(l, c) {
              return (l << c) | (l >>> (32 - c))
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var a = function (l) {
              const c = [1518500249, 1859775393, 2400959708, 3395469782],
                u = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
              if (typeof l == 'string') {
                const p = unescape(encodeURIComponent(l))
                l = []
                for (let g = 0; g < p.length; ++g) l.push(p.charCodeAt(g))
              } else Array.isArray(l) || (l = Array.prototype.slice.call(l))
              l.push(128)
              const f = l.length / 4 + 2,
                d = Math.ceil(f / 16),
                h = new Array(d)
              for (let p = 0; p < d; ++p) {
                const g = new Uint32Array(16)
                for (let m = 0; m < 16; ++m)
                  g[m] =
                    (l[64 * p + 4 * m] << 24) |
                    (l[64 * p + 4 * m + 1] << 16) |
                    (l[64 * p + 4 * m + 2] << 8) |
                    l[64 * p + 4 * m + 3]
                h[p] = g
              }
              ;((h[d - 1][14] = (8 * (l.length - 1)) / Math.pow(2, 32)),
                (h[d - 1][14] = Math.floor(h[d - 1][14])),
                (h[d - 1][15] = (8 * (l.length - 1)) & 4294967295))
              for (let p = 0; p < d; ++p) {
                const g = new Uint32Array(80)
                for (let T = 0; T < 16; ++T) g[T] = h[p][T]
                for (let T = 16; T < 80; ++T)
                  g[T] = o(g[T - 3] ^ g[T - 8] ^ g[T - 14] ^ g[T - 16], 1)
                let m = u[0],
                  y = u[1],
                  b = u[2],
                  w = u[3],
                  C = u[4]
                for (let T = 0; T < 80; ++T) {
                  const I = Math.floor(T / 20),
                    B = (o(m, 5) + s(I, y, b, w) + C + c[I] + g[T]) >>> 0
                  ;((C = w), (w = b), (b = o(y, 30) >>> 0), (y = m), (m = B))
                }
                ;((u[0] = (u[0] + m) >>> 0),
                  (u[1] = (u[1] + y) >>> 0),
                  (u[2] = (u[2] + b) >>> 0),
                  (u[3] = (u[3] + w) >>> 0),
                  (u[4] = (u[4] + C) >>> 0))
              }
              return [
                (u[0] >> 24) & 255,
                (u[0] >> 16) & 255,
                (u[0] >> 8) & 255,
                255 & u[0],
                (u[1] >> 24) & 255,
                (u[1] >> 16) & 255,
                (u[1] >> 8) & 255,
                255 & u[1],
                (u[2] >> 24) & 255,
                (u[2] >> 16) & 255,
                (u[2] >> 8) & 255,
                255 & u[2],
                (u[3] >> 24) & 255,
                (u[3] >> 16) & 255,
                (u[3] >> 8) & 255,
                255 & u[3],
                (u[4] >> 24) & 255,
                (u[4] >> 16) & 255,
                (u[4] >> 8) & 255,
                255 & u[4],
              ]
            }
            i.default = a
          },
          {},
        ],
        535: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s,
              o = (s = t('./validate.js')) && s.__esModule ? s : { default: s }
            const a = []
            for (let c = 0; c < 256; ++c) a.push((c + 256).toString(16).substr(1))
            var l = function (c) {
              let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
              const f = (
                a[c[u + 0]] +
                a[c[u + 1]] +
                a[c[u + 2]] +
                a[c[u + 3]] +
                '-' +
                a[c[u + 4]] +
                a[c[u + 5]] +
                '-' +
                a[c[u + 6]] +
                a[c[u + 7]] +
                '-' +
                a[c[u + 8]] +
                a[c[u + 9]] +
                '-' +
                a[c[u + 10]] +
                a[c[u + 11]] +
                a[c[u + 12]] +
                a[c[u + 13]] +
                a[c[u + 14]] +
                a[c[u + 15]]
              ).toLowerCase()
              if (!(0, o.default)(f)) throw TypeError('Stringified UUID is invalid')
              return f
            }
            i.default = l
          },
          { './validate.js': 541 },
        ],
        536: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s = a(t('./rng.js')),
              o = a(t('./stringify.js'))
            function a(h) {
              return h && h.__esModule ? h : { default: h }
            }
            let l,
              c,
              u = 0,
              f = 0
            var d = function (h, p, g) {
              let m = (p && g) || 0
              const y = p || new Array(16)
              let b = (h = h || {}).node || l,
                w = h.clockseq !== void 0 ? h.clockseq : c
              if (b == null || w == null) {
                const O = h.random || (h.rng || s.default)()
                ;(b == null && (b = l = [1 | O[0], O[1], O[2], O[3], O[4], O[5]]),
                  w == null && (w = c = 16383 & ((O[6] << 8) | O[7])))
              }
              let C = h.msecs !== void 0 ? h.msecs : Date.now(),
                T = h.nsecs !== void 0 ? h.nsecs : f + 1
              const I = C - u + (T - f) / 1e4
              if (
                (I < 0 && h.clockseq === void 0 && (w = (w + 1) & 16383),
                (I < 0 || C > u) && h.nsecs === void 0 && (T = 0),
                T >= 1e4)
              )
                throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
              ;((u = C), (f = T), (c = w), (C += 122192928e5))
              const B = (1e4 * (268435455 & C) + T) % 4294967296
              ;((y[m++] = (B >>> 24) & 255),
                (y[m++] = (B >>> 16) & 255),
                (y[m++] = (B >>> 8) & 255),
                (y[m++] = 255 & B))
              const E = ((C / 4294967296) * 1e4) & 268435455
              ;((y[m++] = (E >>> 8) & 255),
                (y[m++] = 255 & E),
                (y[m++] = ((E >>> 24) & 15) | 16),
                (y[m++] = (E >>> 16) & 255),
                (y[m++] = (w >>> 8) | 128),
                (y[m++] = 255 & w))
              for (let O = 0; O < 6; ++O) y[m + O] = b[O]
              return p || (0, o.default)(y)
            }
            i.default = d
          },
          { './rng.js': 533, './stringify.js': 535 },
        ],
        537: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s = a(t('./v35.js')),
              o = a(t('./md5.js'))
            function a(c) {
              return c && c.__esModule ? c : { default: c }
            }
            var l = (0, s.default)('v3', 48, o.default)
            i.default = l
          },
          { './md5.js': 529, './v35.js': 538 },
        ],
        538: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.default = function (u, f, d) {
                function h(p, g, m, y) {
                  if (
                    (typeof p == 'string' &&
                      (p = (function (w) {
                        w = unescape(encodeURIComponent(w))
                        const C = []
                        for (let T = 0; T < w.length; ++T) C.push(w.charCodeAt(T))
                        return C
                      })(p)),
                    typeof g == 'string' && (g = (0, o.default)(g)),
                    g.length !== 16)
                  )
                    throw TypeError(
                      'Namespace must be array-like (16 iterable integer values, 0-255)',
                    )
                  let b = new Uint8Array(16 + p.length)
                  if (
                    (b.set(g),
                    b.set(p, g.length),
                    (b = d(b)),
                    (b[6] = (15 & b[6]) | f),
                    (b[8] = (63 & b[8]) | 128),
                    m)
                  ) {
                    y = y || 0
                    for (let w = 0; w < 16; ++w) m[y + w] = b[w]
                    return m
                  }
                  return (0, s.default)(b)
                }
                try {
                  h.name = u
                } catch {}
                return ((h.DNS = l), (h.URL = c), h)
              }),
              (i.URL = i.DNS = void 0))
            var s = a(t('./stringify.js')),
              o = a(t('./parse.js'))
            function a(u) {
              return u && u.__esModule ? u : { default: u }
            }
            const l = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'
            i.DNS = l
            const c = '6ba7b811-9dad-11d1-80b4-00c04fd430c8'
            i.URL = c
          },
          { './parse.js': 531, './stringify.js': 535 },
        ],
        539: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s = a(t('./rng.js')),
              o = a(t('./stringify.js'))
            function a(c) {
              return c && c.__esModule ? c : { default: c }
            }
            var l = function (c, u, f) {
              const d = (c = c || {}).random || (c.rng || s.default)()
              if (((d[6] = (15 & d[6]) | 64), (d[8] = (63 & d[8]) | 128), u)) {
                f = f || 0
                for (let h = 0; h < 16; ++h) u[f + h] = d[h]
                return u
              }
              return (0, o.default)(d)
            }
            i.default = l
          },
          { './rng.js': 533, './stringify.js': 535 },
        ],
        540: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s = a(t('./v35.js')),
              o = a(t('./sha1.js'))
            function a(c) {
              return c && c.__esModule ? c : { default: c }
            }
            var l = (0, s.default)('v5', 80, o.default)
            i.default = l
          },
          { './sha1.js': 534, './v35.js': 538 },
        ],
        541: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s,
              o = (s = t('./regex.js')) && s.__esModule ? s : { default: s },
              a = function (l) {
                return typeof l == 'string' && o.default.test(l)
              }
            i.default = a
          },
          { './regex.js': 532 },
        ],
        542: [
          function (t, r, i) {
            ;(Object.defineProperty(i, '__esModule', { value: !0 }), (i.default = void 0))
            var s,
              o = (s = t('./validate.js')) && s.__esModule ? s : { default: s },
              a = function (l) {
                if (!(0, o.default)(l)) throw TypeError('Invalid UUID')
                return parseInt(l.substr(14, 1), 16)
              }
            i.default = a
          },
          { './validate.js': 541 },
        ],
        543: [
          function (t, r, i) {
            /**
             * Character classes and associated utilities for the 5th edition of XML 1.0.
             *
             * @author Louis-Dominique Dubeau
             * @license MIT
             * @copyright Louis-Dominique Dubeau
             */ ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.CHAR = `	
\r ---`),
              (i.S = ` 	\r
`),
              (i.NAME_START_CHAR = ':A-Z_a-z-----------'),
              (i.NAME_CHAR = '-' + i.NAME_START_CHAR + '.0-9--'),
              (i.CHAR_RE = new RegExp('^[' + i.CHAR + ']$', 'u')),
              (i.S_RE = new RegExp('^[' + i.S + ']+$', 'u')),
              (i.NAME_START_CHAR_RE = new RegExp('^[' + i.NAME_START_CHAR + ']$', 'u')),
              (i.NAME_CHAR_RE = new RegExp('^[' + i.NAME_CHAR + ']$', 'u')),
              (i.NAME_RE = new RegExp('^[' + i.NAME_START_CHAR + '][' + i.NAME_CHAR + ']*$', 'u')),
              (i.NMTOKEN_RE = new RegExp('^[' + i.NAME_CHAR + ']+$', 'u')))
            function s(o) {
              return (
                (o >= 65 && o <= 90) ||
                (o >= 97 && o <= 122) ||
                o === 58 ||
                o === 95 ||
                o === 8204 ||
                o === 8205 ||
                (o >= 192 && o <= 214) ||
                (o >= 216 && o <= 246) ||
                (o >= 248 && o <= 767) ||
                (o >= 880 && o <= 893) ||
                (o >= 895 && o <= 8191) ||
                (o >= 8304 && o <= 8591) ||
                (o >= 11264 && o <= 12271) ||
                (o >= 12289 && o <= 55295) ||
                (o >= 63744 && o <= 64975) ||
                (o >= 65008 && o <= 65533) ||
                (o >= 65536 && o <= 983039)
              )
            }
            ;((i.S_LIST = [32, 10, 13, 9]),
              (i.isChar = function (o) {
                return (
                  (o >= 32 && o <= 55295) ||
                  o === 10 ||
                  o === 13 ||
                  o === 9 ||
                  (o >= 57344 && o <= 65533) ||
                  (o >= 65536 && o <= 1114111)
                )
              }),
              (i.isS = function (o) {
                return o === 32 || o === 10 || o === 13 || o === 9
              }),
              (i.isNameStartChar = s),
              (i.isNameChar = function (o) {
                return (
                  s(o) ||
                  (o >= 48 && o <= 57) ||
                  o === 45 ||
                  o === 46 ||
                  o === 183 ||
                  (o >= 768 && o <= 879) ||
                  (o >= 8255 && o <= 8256)
                )
              }))
          },
          {},
        ],
        544: [
          function (t, r, i) {
            /**
             * Character classes and associated utilities for the 2nd edition of XML 1.1.
             *
             * @author Louis-Dominique Dubeau
             * @license MIT
             * @copyright Louis-Dominique Dubeau
             */ ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.CHAR = '---'),
              (i.RESTRICTED_CHAR = '-\b\v\f---'),
              (i.S = ` 	\r
`),
              (i.NAME_START_CHAR = ':A-Z_a-z-----------'),
              (i.NAME_CHAR = '-' + i.NAME_START_CHAR + '.0-9--'),
              (i.CHAR_RE = new RegExp('^[' + i.CHAR + ']$', 'u')),
              (i.RESTRICTED_CHAR_RE = new RegExp('^[' + i.RESTRICTED_CHAR + ']$', 'u')),
              (i.S_RE = new RegExp('^[' + i.S + ']+$', 'u')),
              (i.NAME_START_CHAR_RE = new RegExp('^[' + i.NAME_START_CHAR + ']$', 'u')),
              (i.NAME_CHAR_RE = new RegExp('^[' + i.NAME_CHAR + ']$', 'u')),
              (i.NAME_RE = new RegExp('^[' + i.NAME_START_CHAR + '][' + i.NAME_CHAR + ']*$', 'u')),
              (i.NMTOKEN_RE = new RegExp('^[' + i.NAME_CHAR + ']+$', 'u')))
            function s(o) {
              return (
                (o >= 65 && o <= 90) ||
                (o >= 97 && o <= 122) ||
                o === 58 ||
                o === 95 ||
                o === 8204 ||
                o === 8205 ||
                (o >= 192 && o <= 214) ||
                (o >= 216 && o <= 246) ||
                (o >= 248 && o <= 767) ||
                (o >= 880 && o <= 893) ||
                (o >= 895 && o <= 8191) ||
                (o >= 8304 && o <= 8591) ||
                (o >= 11264 && o <= 12271) ||
                (o >= 12289 && o <= 55295) ||
                (o >= 63744 && o <= 64975) ||
                (o >= 65008 && o <= 65533) ||
                (o >= 65536 && o <= 983039)
              )
            }
            ;((i.S_LIST = [32, 10, 13, 9]),
              (i.isChar = function (o) {
                return (
                  (o >= 1 && o <= 55295) ||
                  (o >= 57344 && o <= 65533) ||
                  (o >= 65536 && o <= 1114111)
                )
              }),
              (i.isRestrictedChar = function (o) {
                return (
                  (o >= 1 && o <= 8) ||
                  o === 11 ||
                  o === 12 ||
                  (o >= 14 && o <= 31) ||
                  (o >= 127 && o <= 132) ||
                  (o >= 134 && o <= 159)
                )
              }),
              (i.isCharAndNotRestricted = function (o) {
                return (
                  o === 9 ||
                  o === 10 ||
                  o === 13 ||
                  (o > 31 && o < 127) ||
                  o === 133 ||
                  (o > 159 && o <= 55295) ||
                  (o >= 57344 && o <= 65533) ||
                  (o >= 65536 && o <= 1114111)
                )
              }),
              (i.isS = function (o) {
                return o === 32 || o === 10 || o === 13 || o === 9
              }),
              (i.isNameStartChar = s),
              (i.isNameChar = function (o) {
                return (
                  s(o) ||
                  (o >= 48 && o <= 57) ||
                  o === 45 ||
                  o === 46 ||
                  o === 183 ||
                  (o >= 768 && o <= 879) ||
                  (o >= 8255 && o <= 8256)
                )
              }))
          },
          {},
        ],
        545: [
          function (t, r, i) {
            /**
             * Character class utilities for XML NS 1.0 edition 3.
             *
             * @author Louis-Dominique Dubeau
             * @license MIT
             * @copyright Louis-Dominique Dubeau
             */ function s(o) {
              return (
                (o >= 65 && o <= 90) ||
                o === 95 ||
                (o >= 97 && o <= 122) ||
                (o >= 192 && o <= 214) ||
                (o >= 216 && o <= 246) ||
                (o >= 248 && o <= 767) ||
                (o >= 880 && o <= 893) ||
                (o >= 895 && o <= 8191) ||
                (o >= 8204 && o <= 8205) ||
                (o >= 8304 && o <= 8591) ||
                (o >= 11264 && o <= 12271) ||
                (o >= 12289 && o <= 55295) ||
                (o >= 63744 && o <= 64975) ||
                (o >= 65008 && o <= 65533) ||
                (o >= 65536 && o <= 983039)
              )
            }
            ;(Object.defineProperty(i, '__esModule', { value: !0 }),
              (i.NC_NAME_START_CHAR = 'A-Z_a-z------------'),
              (i.NC_NAME_CHAR = '-' + i.NC_NAME_START_CHAR + '.0-9--'),
              (i.NC_NAME_START_CHAR_RE = new RegExp('^[' + i.NC_NAME_START_CHAR + ']$', 'u')),
              (i.NC_NAME_CHAR_RE = new RegExp('^[' + i.NC_NAME_CHAR + ']$', 'u')),
              (i.NC_NAME_RE = new RegExp(
                '^[' + i.NC_NAME_START_CHAR + '][' + i.NC_NAME_CHAR + ']*$',
                'u',
              )),
              (i.isNCNameStartChar = s),
              (i.isNCNameChar = function (o) {
                return (
                  s(o) ||
                  o === 45 ||
                  o === 46 ||
                  (o >= 48 && o <= 57) ||
                  o === 183 ||
                  (o >= 768 && o <= 879) ||
                  (o >= 8255 && o <= 8256)
                )
              }))
          },
          {},
        ],
      },
      {},
      [15],
    )(15)
  })
})(n4)
var UZ = n4.exports,
  r4 = { exports: {} },
  yj = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED',
  bj = yj,
  vj = bj
function i4() {}
function s4() {}
s4.resetWarningCache = i4
var wj = function () {
  function e(r, i, s, o, a, l) {
    if (l !== vj) {
      var c = new Error(
        'Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types',
      )
      throw ((c.name = 'Invariant Violation'), c)
    }
  }
  e.isRequired = e
  function n() {
    return e
  }
  var t = {
    array: e,
    bigint: e,
    bool: e,
    func: e,
    number: e,
    object: e,
    string: e,
    symbol: e,
    any: e,
    arrayOf: n,
    element: e,
    elementType: e,
    instanceOf: n,
    node: e,
    objectOf: n,
    oneOf: n,
    oneOfType: n,
    shape: n,
    exact: n,
    checkPropTypes: s4,
    resetWarningCache: i4,
  }
  return ((t.PropTypes = t), t)
}
r4.exports = wj()
var xj = r4.exports
const qZ = kr(xj),
  Sj = new Map([
    ['1km', 'application/vnd.1000minds.decision-model+xml'],
    ['3dml', 'text/vnd.in3d.3dml'],
    ['3ds', 'image/x-3ds'],
    ['3g2', 'video/3gpp2'],
    ['3gp', 'video/3gp'],
    ['3gpp', 'video/3gpp'],
    ['3mf', 'model/3mf'],
    ['7z', 'application/x-7z-compressed'],
    ['7zip', 'application/x-7z-compressed'],
    ['123', 'application/vnd.lotus-1-2-3'],
    ['aab', 'application/x-authorware-bin'],
    ['aac', 'audio/x-acc'],
    ['aam', 'application/x-authorware-map'],
    ['aas', 'application/x-authorware-seg'],
    ['abw', 'application/x-abiword'],
    ['ac', 'application/vnd.nokia.n-gage.ac+xml'],
    ['ac3', 'audio/ac3'],
    ['acc', 'application/vnd.americandynamics.acc'],
    ['ace', 'application/x-ace-compressed'],
    ['acu', 'application/vnd.acucobol'],
    ['acutc', 'application/vnd.acucorp'],
    ['adp', 'audio/adpcm'],
    ['aep', 'application/vnd.audiograph'],
    ['afm', 'application/x-font-type1'],
    ['afp', 'application/vnd.ibm.modcap'],
    ['ahead', 'application/vnd.ahead.space'],
    ['ai', 'application/pdf'],
    ['aif', 'audio/x-aiff'],
    ['aifc', 'audio/x-aiff'],
    ['aiff', 'audio/x-aiff'],
    ['air', 'application/vnd.adobe.air-application-installer-package+zip'],
    ['ait', 'application/vnd.dvb.ait'],
    ['ami', 'application/vnd.amiga.ami'],
    ['amr', 'audio/amr'],
    ['apk', 'application/vnd.android.package-archive'],
    ['apng', 'image/apng'],
    ['appcache', 'text/cache-manifest'],
    ['application', 'application/x-ms-application'],
    ['apr', 'application/vnd.lotus-approach'],
    ['arc', 'application/x-freearc'],
    ['arj', 'application/x-arj'],
    ['asc', 'application/pgp-signature'],
    ['asf', 'video/x-ms-asf'],
    ['asm', 'text/x-asm'],
    ['aso', 'application/vnd.accpac.simply.aso'],
    ['asx', 'video/x-ms-asf'],
    ['atc', 'application/vnd.acucorp'],
    ['atom', 'application/atom+xml'],
    ['atomcat', 'application/atomcat+xml'],
    ['atomdeleted', 'application/atomdeleted+xml'],
    ['atomsvc', 'application/atomsvc+xml'],
    ['atx', 'application/vnd.antix.game-component'],
    ['au', 'audio/x-au'],
    ['avi', 'video/x-msvideo'],
    ['avif', 'image/avif'],
    ['aw', 'application/applixware'],
    ['azf', 'application/vnd.airzip.filesecure.azf'],
    ['azs', 'application/vnd.airzip.filesecure.azs'],
    ['azv', 'image/vnd.airzip.accelerator.azv'],
    ['azw', 'application/vnd.amazon.ebook'],
    ['b16', 'image/vnd.pco.b16'],
    ['bat', 'application/x-msdownload'],
    ['bcpio', 'application/x-bcpio'],
    ['bdf', 'application/x-font-bdf'],
    ['bdm', 'application/vnd.syncml.dm+wbxml'],
    ['bdoc', 'application/x-bdoc'],
    ['bed', 'application/vnd.realvnc.bed'],
    ['bh2', 'application/vnd.fujitsu.oasysprs'],
    ['bin', 'application/octet-stream'],
    ['blb', 'application/x-blorb'],
    ['blorb', 'application/x-blorb'],
    ['bmi', 'application/vnd.bmi'],
    ['bmml', 'application/vnd.balsamiq.bmml+xml'],
    ['bmp', 'image/bmp'],
    ['book', 'application/vnd.framemaker'],
    ['box', 'application/vnd.previewsystems.box'],
    ['boz', 'application/x-bzip2'],
    ['bpk', 'application/octet-stream'],
    ['bpmn', 'application/octet-stream'],
    ['bsp', 'model/vnd.valve.source.compiled-map'],
    ['btif', 'image/prs.btif'],
    ['buffer', 'application/octet-stream'],
    ['bz', 'application/x-bzip'],
    ['bz2', 'application/x-bzip2'],
    ['c', 'text/x-c'],
    ['c4d', 'application/vnd.clonk.c4group'],
    ['c4f', 'application/vnd.clonk.c4group'],
    ['c4g', 'application/vnd.clonk.c4group'],
    ['c4p', 'application/vnd.clonk.c4group'],
    ['c4u', 'application/vnd.clonk.c4group'],
    ['c11amc', 'application/vnd.cluetrust.cartomobile-config'],
    ['c11amz', 'application/vnd.cluetrust.cartomobile-config-pkg'],
    ['cab', 'application/vnd.ms-cab-compressed'],
    ['caf', 'audio/x-caf'],
    ['cap', 'application/vnd.tcpdump.pcap'],
    ['car', 'application/vnd.curl.car'],
    ['cat', 'application/vnd.ms-pki.seccat'],
    ['cb7', 'application/x-cbr'],
    ['cba', 'application/x-cbr'],
    ['cbr', 'application/x-cbr'],
    ['cbt', 'application/x-cbr'],
    ['cbz', 'application/x-cbr'],
    ['cc', 'text/x-c'],
    ['cco', 'application/x-cocoa'],
    ['cct', 'application/x-director'],
    ['ccxml', 'application/ccxml+xml'],
    ['cdbcmsg', 'application/vnd.contact.cmsg'],
    ['cda', 'application/x-cdf'],
    ['cdf', 'application/x-netcdf'],
    ['cdfx', 'application/cdfx+xml'],
    ['cdkey', 'application/vnd.mediastation.cdkey'],
    ['cdmia', 'application/cdmi-capability'],
    ['cdmic', 'application/cdmi-container'],
    ['cdmid', 'application/cdmi-domain'],
    ['cdmio', 'application/cdmi-object'],
    ['cdmiq', 'application/cdmi-queue'],
    ['cdr', 'application/cdr'],
    ['cdx', 'chemical/x-cdx'],
    ['cdxml', 'application/vnd.chemdraw+xml'],
    ['cdy', 'application/vnd.cinderella'],
    ['cer', 'application/pkix-cert'],
    ['cfs', 'application/x-cfs-compressed'],
    ['cgm', 'image/cgm'],
    ['chat', 'application/x-chat'],
    ['chm', 'application/vnd.ms-htmlhelp'],
    ['chrt', 'application/vnd.kde.kchart'],
    ['cif', 'chemical/x-cif'],
    ['cii', 'application/vnd.anser-web-certificate-issue-initiation'],
    ['cil', 'application/vnd.ms-artgalry'],
    ['cjs', 'application/node'],
    ['cla', 'application/vnd.claymore'],
    ['class', 'application/octet-stream'],
    ['clkk', 'application/vnd.crick.clicker.keyboard'],
    ['clkp', 'application/vnd.crick.clicker.palette'],
    ['clkt', 'application/vnd.crick.clicker.template'],
    ['clkw', 'application/vnd.crick.clicker.wordbank'],
    ['clkx', 'application/vnd.crick.clicker'],
    ['clp', 'application/x-msclip'],
    ['cmc', 'application/vnd.cosmocaller'],
    ['cmdf', 'chemical/x-cmdf'],
    ['cml', 'chemical/x-cml'],
    ['cmp', 'application/vnd.yellowriver-custom-menu'],
    ['cmx', 'image/x-cmx'],
    ['cod', 'application/vnd.rim.cod'],
    ['coffee', 'text/coffeescript'],
    ['com', 'application/x-msdownload'],
    ['conf', 'text/plain'],
    ['cpio', 'application/x-cpio'],
    ['cpp', 'text/x-c'],
    ['cpt', 'application/mac-compactpro'],
    ['crd', 'application/x-mscardfile'],
    ['crl', 'application/pkix-crl'],
    ['crt', 'application/x-x509-ca-cert'],
    ['crx', 'application/x-chrome-extension'],
    ['cryptonote', 'application/vnd.rig.cryptonote'],
    ['csh', 'application/x-csh'],
    ['csl', 'application/vnd.citationstyles.style+xml'],
    ['csml', 'chemical/x-csml'],
    ['csp', 'application/vnd.commonspace'],
    ['csr', 'application/octet-stream'],
    ['css', 'text/css'],
    ['cst', 'application/x-director'],
    ['csv', 'text/csv'],
    ['cu', 'application/cu-seeme'],
    ['curl', 'text/vnd.curl'],
    ['cww', 'application/prs.cww'],
    ['cxt', 'application/x-director'],
    ['cxx', 'text/x-c'],
    ['dae', 'model/vnd.collada+xml'],
    ['daf', 'application/vnd.mobius.daf'],
    ['dart', 'application/vnd.dart'],
    ['dataless', 'application/vnd.fdsn.seed'],
    ['davmount', 'application/davmount+xml'],
    ['dbf', 'application/vnd.dbf'],
    ['dbk', 'application/docbook+xml'],
    ['dcr', 'application/x-director'],
    ['dcurl', 'text/vnd.curl.dcurl'],
    ['dd2', 'application/vnd.oma.dd2+xml'],
    ['ddd', 'application/vnd.fujixerox.ddd'],
    ['ddf', 'application/vnd.syncml.dmddf+xml'],
    ['dds', 'image/vnd.ms-dds'],
    ['deb', 'application/x-debian-package'],
    ['def', 'text/plain'],
    ['deploy', 'application/octet-stream'],
    ['der', 'application/x-x509-ca-cert'],
    ['dfac', 'application/vnd.dreamfactory'],
    ['dgc', 'application/x-dgc-compressed'],
    ['dic', 'text/x-c'],
    ['dir', 'application/x-director'],
    ['dis', 'application/vnd.mobius.dis'],
    ['disposition-notification', 'message/disposition-notification'],
    ['dist', 'application/octet-stream'],
    ['distz', 'application/octet-stream'],
    ['djv', 'image/vnd.djvu'],
    ['djvu', 'image/vnd.djvu'],
    ['dll', 'application/octet-stream'],
    ['dmg', 'application/x-apple-diskimage'],
    ['dmn', 'application/octet-stream'],
    ['dmp', 'application/vnd.tcpdump.pcap'],
    ['dms', 'application/octet-stream'],
    ['dna', 'application/vnd.dna'],
    ['doc', 'application/msword'],
    ['docm', 'application/vnd.ms-word.template.macroEnabled.12'],
    ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
    ['dot', 'application/msword'],
    ['dotm', 'application/vnd.ms-word.template.macroEnabled.12'],
    ['dotx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template'],
    ['dp', 'application/vnd.osgi.dp'],
    ['dpg', 'application/vnd.dpgraph'],
    ['dra', 'audio/vnd.dra'],
    ['drle', 'image/dicom-rle'],
    ['dsc', 'text/prs.lines.tag'],
    ['dssc', 'application/dssc+der'],
    ['dtb', 'application/x-dtbook+xml'],
    ['dtd', 'application/xml-dtd'],
    ['dts', 'audio/vnd.dts'],
    ['dtshd', 'audio/vnd.dts.hd'],
    ['dump', 'application/octet-stream'],
    ['dvb', 'video/vnd.dvb.file'],
    ['dvi', 'application/x-dvi'],
    ['dwd', 'application/atsc-dwd+xml'],
    ['dwf', 'model/vnd.dwf'],
    ['dwg', 'image/vnd.dwg'],
    ['dxf', 'image/vnd.dxf'],
    ['dxp', 'application/vnd.spotfire.dxp'],
    ['dxr', 'application/x-director'],
    ['ear', 'application/java-archive'],
    ['ecelp4800', 'audio/vnd.nuera.ecelp4800'],
    ['ecelp7470', 'audio/vnd.nuera.ecelp7470'],
    ['ecelp9600', 'audio/vnd.nuera.ecelp9600'],
    ['ecma', 'application/ecmascript'],
    ['edm', 'application/vnd.novadigm.edm'],
    ['edx', 'application/vnd.novadigm.edx'],
    ['efif', 'application/vnd.picsel'],
    ['ei6', 'application/vnd.pg.osasli'],
    ['elc', 'application/octet-stream'],
    ['emf', 'image/emf'],
    ['eml', 'message/rfc822'],
    ['emma', 'application/emma+xml'],
    ['emotionml', 'application/emotionml+xml'],
    ['emz', 'application/x-msmetafile'],
    ['eol', 'audio/vnd.digital-winds'],
    ['eot', 'application/vnd.ms-fontobject'],
    ['eps', 'application/postscript'],
    ['epub', 'application/epub+zip'],
    ['es', 'application/ecmascript'],
    ['es3', 'application/vnd.eszigno3+xml'],
    ['esa', 'application/vnd.osgi.subsystem'],
    ['esf', 'application/vnd.epson.esf'],
    ['et3', 'application/vnd.eszigno3+xml'],
    ['etx', 'text/x-setext'],
    ['eva', 'application/x-eva'],
    ['evy', 'application/x-envoy'],
    ['exe', 'application/octet-stream'],
    ['exi', 'application/exi'],
    ['exp', 'application/express'],
    ['exr', 'image/aces'],
    ['ext', 'application/vnd.novadigm.ext'],
    ['ez', 'application/andrew-inset'],
    ['ez2', 'application/vnd.ezpix-album'],
    ['ez3', 'application/vnd.ezpix-package'],
    ['f', 'text/x-fortran'],
    ['f4v', 'video/mp4'],
    ['f77', 'text/x-fortran'],
    ['f90', 'text/x-fortran'],
    ['fbs', 'image/vnd.fastbidsheet'],
    ['fcdt', 'application/vnd.adobe.formscentral.fcdt'],
    ['fcs', 'application/vnd.isac.fcs'],
    ['fdf', 'application/vnd.fdf'],
    ['fdt', 'application/fdt+xml'],
    ['fe_launch', 'application/vnd.denovo.fcselayout-link'],
    ['fg5', 'application/vnd.fujitsu.oasysgp'],
    ['fgd', 'application/x-director'],
    ['fh', 'image/x-freehand'],
    ['fh4', 'image/x-freehand'],
    ['fh5', 'image/x-freehand'],
    ['fh7', 'image/x-freehand'],
    ['fhc', 'image/x-freehand'],
    ['fig', 'application/x-xfig'],
    ['fits', 'image/fits'],
    ['flac', 'audio/x-flac'],
    ['fli', 'video/x-fli'],
    ['flo', 'application/vnd.micrografx.flo'],
    ['flv', 'video/x-flv'],
    ['flw', 'application/vnd.kde.kivio'],
    ['flx', 'text/vnd.fmi.flexstor'],
    ['fly', 'text/vnd.fly'],
    ['fm', 'application/vnd.framemaker'],
    ['fnc', 'application/vnd.frogans.fnc'],
    ['fo', 'application/vnd.software602.filler.form+xml'],
    ['for', 'text/x-fortran'],
    ['fpx', 'image/vnd.fpx'],
    ['frame', 'application/vnd.framemaker'],
    ['fsc', 'application/vnd.fsc.weblaunch'],
    ['fst', 'image/vnd.fst'],
    ['ftc', 'application/vnd.fluxtime.clip'],
    ['fti', 'application/vnd.anser-web-funds-transfer-initiation'],
    ['fvt', 'video/vnd.fvt'],
    ['fxp', 'application/vnd.adobe.fxp'],
    ['fxpl', 'application/vnd.adobe.fxp'],
    ['fzs', 'application/vnd.fuzzysheet'],
    ['g2w', 'application/vnd.geoplan'],
    ['g3', 'image/g3fax'],
    ['g3w', 'application/vnd.geospace'],
    ['gac', 'application/vnd.groove-account'],
    ['gam', 'application/x-tads'],
    ['gbr', 'application/rpki-ghostbusters'],
    ['gca', 'application/x-gca-compressed'],
    ['gdl', 'model/vnd.gdl'],
    ['gdoc', 'application/vnd.google-apps.document'],
    ['geo', 'application/vnd.dynageo'],
    ['geojson', 'application/geo+json'],
    ['gex', 'application/vnd.geometry-explorer'],
    ['ggb', 'application/vnd.geogebra.file'],
    ['ggt', 'application/vnd.geogebra.tool'],
    ['ghf', 'application/vnd.groove-help'],
    ['gif', 'image/gif'],
    ['gim', 'application/vnd.groove-identity-message'],
    ['glb', 'model/gltf-binary'],
    ['gltf', 'model/gltf+json'],
    ['gml', 'application/gml+xml'],
    ['gmx', 'application/vnd.gmx'],
    ['gnumeric', 'application/x-gnumeric'],
    ['gpg', 'application/gpg-keys'],
    ['gph', 'application/vnd.flographit'],
    ['gpx', 'application/gpx+xml'],
    ['gqf', 'application/vnd.grafeq'],
    ['gqs', 'application/vnd.grafeq'],
    ['gram', 'application/srgs'],
    ['gramps', 'application/x-gramps-xml'],
    ['gre', 'application/vnd.geometry-explorer'],
    ['grv', 'application/vnd.groove-injector'],
    ['grxml', 'application/srgs+xml'],
    ['gsf', 'application/x-font-ghostscript'],
    ['gsheet', 'application/vnd.google-apps.spreadsheet'],
    ['gslides', 'application/vnd.google-apps.presentation'],
    ['gtar', 'application/x-gtar'],
    ['gtm', 'application/vnd.groove-tool-message'],
    ['gtw', 'model/vnd.gtw'],
    ['gv', 'text/vnd.graphviz'],
    ['gxf', 'application/gxf'],
    ['gxt', 'application/vnd.geonext'],
    ['gz', 'application/gzip'],
    ['gzip', 'application/gzip'],
    ['h', 'text/x-c'],
    ['h261', 'video/h261'],
    ['h263', 'video/h263'],
    ['h264', 'video/h264'],
    ['hal', 'application/vnd.hal+xml'],
    ['hbci', 'application/vnd.hbci'],
    ['hbs', 'text/x-handlebars-template'],
    ['hdd', 'application/x-virtualbox-hdd'],
    ['hdf', 'application/x-hdf'],
    ['heic', 'image/heic'],
    ['heics', 'image/heic-sequence'],
    ['heif', 'image/heif'],
    ['heifs', 'image/heif-sequence'],
    ['hej2', 'image/hej2k'],
    ['held', 'application/atsc-held+xml'],
    ['hh', 'text/x-c'],
    ['hjson', 'application/hjson'],
    ['hlp', 'application/winhlp'],
    ['hpgl', 'application/vnd.hp-hpgl'],
    ['hpid', 'application/vnd.hp-hpid'],
    ['hps', 'application/vnd.hp-hps'],
    ['hqx', 'application/mac-binhex40'],
    ['hsj2', 'image/hsj2'],
    ['htc', 'text/x-component'],
    ['htke', 'application/vnd.kenameaapp'],
    ['htm', 'text/html'],
    ['html', 'text/html'],
    ['hvd', 'application/vnd.yamaha.hv-dic'],
    ['hvp', 'application/vnd.yamaha.hv-voice'],
    ['hvs', 'application/vnd.yamaha.hv-script'],
    ['i2g', 'application/vnd.intergeo'],
    ['icc', 'application/vnd.iccprofile'],
    ['ice', 'x-conference/x-cooltalk'],
    ['icm', 'application/vnd.iccprofile'],
    ['ico', 'image/x-icon'],
    ['ics', 'text/calendar'],
    ['ief', 'image/ief'],
    ['ifb', 'text/calendar'],
    ['ifm', 'application/vnd.shana.informed.formdata'],
    ['iges', 'model/iges'],
    ['igl', 'application/vnd.igloader'],
    ['igm', 'application/vnd.insors.igm'],
    ['igs', 'model/iges'],
    ['igx', 'application/vnd.micrografx.igx'],
    ['iif', 'application/vnd.shana.informed.interchange'],
    ['img', 'application/octet-stream'],
    ['imp', 'application/vnd.accpac.simply.imp'],
    ['ims', 'application/vnd.ms-ims'],
    ['in', 'text/plain'],
    ['ini', 'text/plain'],
    ['ink', 'application/inkml+xml'],
    ['inkml', 'application/inkml+xml'],
    ['install', 'application/x-install-instructions'],
    ['iota', 'application/vnd.astraea-software.iota'],
    ['ipfix', 'application/ipfix'],
    ['ipk', 'application/vnd.shana.informed.package'],
    ['irm', 'application/vnd.ibm.rights-management'],
    ['irp', 'application/vnd.irepository.package+xml'],
    ['iso', 'application/x-iso9660-image'],
    ['itp', 'application/vnd.shana.informed.formtemplate'],
    ['its', 'application/its+xml'],
    ['ivp', 'application/vnd.immervision-ivp'],
    ['ivu', 'application/vnd.immervision-ivu'],
    ['jad', 'text/vnd.sun.j2me.app-descriptor'],
    ['jade', 'text/jade'],
    ['jam', 'application/vnd.jam'],
    ['jar', 'application/java-archive'],
    ['jardiff', 'application/x-java-archive-diff'],
    ['java', 'text/x-java-source'],
    ['jhc', 'image/jphc'],
    ['jisp', 'application/vnd.jisp'],
    ['jls', 'image/jls'],
    ['jlt', 'application/vnd.hp-jlyt'],
    ['jng', 'image/x-jng'],
    ['jnlp', 'application/x-java-jnlp-file'],
    ['joda', 'application/vnd.joost.joda-archive'],
    ['jp2', 'image/jp2'],
    ['jpe', 'image/jpeg'],
    ['jpeg', 'image/jpeg'],
    ['jpf', 'image/jpx'],
    ['jpg', 'image/jpeg'],
    ['jpg2', 'image/jp2'],
    ['jpgm', 'video/jpm'],
    ['jpgv', 'video/jpeg'],
    ['jph', 'image/jph'],
    ['jpm', 'video/jpm'],
    ['jpx', 'image/jpx'],
    ['js', 'application/javascript'],
    ['json', 'application/json'],
    ['json5', 'application/json5'],
    ['jsonld', 'application/ld+json'],
    ['jsonl', 'application/jsonl'],
    ['jsonml', 'application/jsonml+json'],
    ['jsx', 'text/jsx'],
    ['jxr', 'image/jxr'],
    ['jxra', 'image/jxra'],
    ['jxrs', 'image/jxrs'],
    ['jxs', 'image/jxs'],
    ['jxsc', 'image/jxsc'],
    ['jxsi', 'image/jxsi'],
    ['jxss', 'image/jxss'],
    ['kar', 'audio/midi'],
    ['karbon', 'application/vnd.kde.karbon'],
    ['kdb', 'application/octet-stream'],
    ['kdbx', 'application/x-keepass2'],
    ['key', 'application/x-iwork-keynote-sffkey'],
    ['kfo', 'application/vnd.kde.kformula'],
    ['kia', 'application/vnd.kidspiration'],
    ['kml', 'application/vnd.google-earth.kml+xml'],
    ['kmz', 'application/vnd.google-earth.kmz'],
    ['kne', 'application/vnd.kinar'],
    ['knp', 'application/vnd.kinar'],
    ['kon', 'application/vnd.kde.kontour'],
    ['kpr', 'application/vnd.kde.kpresenter'],
    ['kpt', 'application/vnd.kde.kpresenter'],
    ['kpxx', 'application/vnd.ds-keypoint'],
    ['ksp', 'application/vnd.kde.kspread'],
    ['ktr', 'application/vnd.kahootz'],
    ['ktx', 'image/ktx'],
    ['ktx2', 'image/ktx2'],
    ['ktz', 'application/vnd.kahootz'],
    ['kwd', 'application/vnd.kde.kword'],
    ['kwt', 'application/vnd.kde.kword'],
    ['lasxml', 'application/vnd.las.las+xml'],
    ['latex', 'application/x-latex'],
    ['lbd', 'application/vnd.llamagraphics.life-balance.desktop'],
    ['lbe', 'application/vnd.llamagraphics.life-balance.exchange+xml'],
    ['les', 'application/vnd.hhe.lesson-player'],
    ['less', 'text/less'],
    ['lgr', 'application/lgr+xml'],
    ['lha', 'application/octet-stream'],
    ['link66', 'application/vnd.route66.link66+xml'],
    ['list', 'text/plain'],
    ['list3820', 'application/vnd.ibm.modcap'],
    ['listafp', 'application/vnd.ibm.modcap'],
    ['litcoffee', 'text/coffeescript'],
    ['lnk', 'application/x-ms-shortcut'],
    ['log', 'text/plain'],
    ['lostxml', 'application/lost+xml'],
    ['lrf', 'application/octet-stream'],
    ['lrm', 'application/vnd.ms-lrm'],
    ['ltf', 'application/vnd.frogans.ltf'],
    ['lua', 'text/x-lua'],
    ['luac', 'application/x-lua-bytecode'],
    ['lvp', 'audio/vnd.lucent.voice'],
    ['lwp', 'application/vnd.lotus-wordpro'],
    ['lzh', 'application/octet-stream'],
    ['m1v', 'video/mpeg'],
    ['m2a', 'audio/mpeg'],
    ['m2v', 'video/mpeg'],
    ['m3a', 'audio/mpeg'],
    ['m3u', 'text/plain'],
    ['m3u8', 'application/vnd.apple.mpegurl'],
    ['m4a', 'audio/x-m4a'],
    ['m4p', 'application/mp4'],
    ['m4s', 'video/iso.segment'],
    ['m4u', 'application/vnd.mpegurl'],
    ['m4v', 'video/x-m4v'],
    ['m13', 'application/x-msmediaview'],
    ['m14', 'application/x-msmediaview'],
    ['m21', 'application/mp21'],
    ['ma', 'application/mathematica'],
    ['mads', 'application/mads+xml'],
    ['maei', 'application/mmt-aei+xml'],
    ['mag', 'application/vnd.ecowin.chart'],
    ['maker', 'application/vnd.framemaker'],
    ['man', 'text/troff'],
    ['manifest', 'text/cache-manifest'],
    ['map', 'application/json'],
    ['mar', 'application/octet-stream'],
    ['markdown', 'text/markdown'],
    ['mathml', 'application/mathml+xml'],
    ['mb', 'application/mathematica'],
    ['mbk', 'application/vnd.mobius.mbk'],
    ['mbox', 'application/mbox'],
    ['mc1', 'application/vnd.medcalcdata'],
    ['mcd', 'application/vnd.mcd'],
    ['mcurl', 'text/vnd.curl.mcurl'],
    ['md', 'text/markdown'],
    ['mdb', 'application/x-msaccess'],
    ['mdi', 'image/vnd.ms-modi'],
    ['mdx', 'text/mdx'],
    ['me', 'text/troff'],
    ['mesh', 'model/mesh'],
    ['meta4', 'application/metalink4+xml'],
    ['metalink', 'application/metalink+xml'],
    ['mets', 'application/mets+xml'],
    ['mfm', 'application/vnd.mfmp'],
    ['mft', 'application/rpki-manifest'],
    ['mgp', 'application/vnd.osgeo.mapguide.package'],
    ['mgz', 'application/vnd.proteus.magazine'],
    ['mid', 'audio/midi'],
    ['midi', 'audio/midi'],
    ['mie', 'application/x-mie'],
    ['mif', 'application/vnd.mif'],
    ['mime', 'message/rfc822'],
    ['mj2', 'video/mj2'],
    ['mjp2', 'video/mj2'],
    ['mjs', 'application/javascript'],
    ['mk3d', 'video/x-matroska'],
    ['mka', 'audio/x-matroska'],
    ['mkd', 'text/x-markdown'],
    ['mks', 'video/x-matroska'],
    ['mkv', 'video/x-matroska'],
    ['mlp', 'application/vnd.dolby.mlp'],
    ['mmd', 'application/vnd.chipnuts.karaoke-mmd'],
    ['mmf', 'application/vnd.smaf'],
    ['mml', 'text/mathml'],
    ['mmr', 'image/vnd.fujixerox.edmics-mmr'],
    ['mng', 'video/x-mng'],
    ['mny', 'application/x-msmoney'],
    ['mobi', 'application/x-mobipocket-ebook'],
    ['mods', 'application/mods+xml'],
    ['mov', 'video/quicktime'],
    ['movie', 'video/x-sgi-movie'],
    ['mp2', 'audio/mpeg'],
    ['mp2a', 'audio/mpeg'],
    ['mp3', 'audio/mpeg'],
    ['mp4', 'video/mp4'],
    ['mp4a', 'audio/mp4'],
    ['mp4s', 'application/mp4'],
    ['mp4v', 'video/mp4'],
    ['mp21', 'application/mp21'],
    ['mpc', 'application/vnd.mophun.certificate'],
    ['mpd', 'application/dash+xml'],
    ['mpe', 'video/mpeg'],
    ['mpeg', 'video/mpeg'],
    ['mpg', 'video/mpeg'],
    ['mpg4', 'video/mp4'],
    ['mpga', 'audio/mpeg'],
    ['mpkg', 'application/vnd.apple.installer+xml'],
    ['mpm', 'application/vnd.blueice.multipass'],
    ['mpn', 'application/vnd.mophun.application'],
    ['mpp', 'application/vnd.ms-project'],
    ['mpt', 'application/vnd.ms-project'],
    ['mpy', 'application/vnd.ibm.minipay'],
    ['mqy', 'application/vnd.mobius.mqy'],
    ['mrc', 'application/marc'],
    ['mrcx', 'application/marcxml+xml'],
    ['ms', 'text/troff'],
    ['mscml', 'application/mediaservercontrol+xml'],
    ['mseed', 'application/vnd.fdsn.mseed'],
    ['mseq', 'application/vnd.mseq'],
    ['msf', 'application/vnd.epson.msf'],
    ['msg', 'application/vnd.ms-outlook'],
    ['msh', 'model/mesh'],
    ['msi', 'application/x-msdownload'],
    ['msl', 'application/vnd.mobius.msl'],
    ['msm', 'application/octet-stream'],
    ['msp', 'application/octet-stream'],
    ['msty', 'application/vnd.muvee.style'],
    ['mtl', 'model/mtl'],
    ['mts', 'model/vnd.mts'],
    ['mus', 'application/vnd.musician'],
    ['musd', 'application/mmt-usd+xml'],
    ['musicxml', 'application/vnd.recordare.musicxml+xml'],
    ['mvb', 'application/x-msmediaview'],
    ['mvt', 'application/vnd.mapbox-vector-tile'],
    ['mwf', 'application/vnd.mfer'],
    ['mxf', 'application/mxf'],
    ['mxl', 'application/vnd.recordare.musicxml'],
    ['mxmf', 'audio/mobile-xmf'],
    ['mxml', 'application/xv+xml'],
    ['mxs', 'application/vnd.triscape.mxs'],
    ['mxu', 'video/vnd.mpegurl'],
    ['n-gage', 'application/vnd.nokia.n-gage.symbian.install'],
    ['n3', 'text/n3'],
    ['nb', 'application/mathematica'],
    ['nbp', 'application/vnd.wolfram.player'],
    ['nc', 'application/x-netcdf'],
    ['ncx', 'application/x-dtbncx+xml'],
    ['nfo', 'text/x-nfo'],
    ['ngdat', 'application/vnd.nokia.n-gage.data'],
    ['nitf', 'application/vnd.nitf'],
    ['nlu', 'application/vnd.neurolanguage.nlu'],
    ['nml', 'application/vnd.enliven'],
    ['nnd', 'application/vnd.noblenet-directory'],
    ['nns', 'application/vnd.noblenet-sealer'],
    ['nnw', 'application/vnd.noblenet-web'],
    ['npx', 'image/vnd.net-fpx'],
    ['nq', 'application/n-quads'],
    ['nsc', 'application/x-conference'],
    ['nsf', 'application/vnd.lotus-notes'],
    ['nt', 'application/n-triples'],
    ['ntf', 'application/vnd.nitf'],
    ['numbers', 'application/x-iwork-numbers-sffnumbers'],
    ['nzb', 'application/x-nzb'],
    ['oa2', 'application/vnd.fujitsu.oasys2'],
    ['oa3', 'application/vnd.fujitsu.oasys3'],
    ['oas', 'application/vnd.fujitsu.oasys'],
    ['obd', 'application/x-msbinder'],
    ['obgx', 'application/vnd.openblox.game+xml'],
    ['obj', 'model/obj'],
    ['oda', 'application/oda'],
    ['odb', 'application/vnd.oasis.opendocument.database'],
    ['odc', 'application/vnd.oasis.opendocument.chart'],
    ['odf', 'application/vnd.oasis.opendocument.formula'],
    ['odft', 'application/vnd.oasis.opendocument.formula-template'],
    ['odg', 'application/vnd.oasis.opendocument.graphics'],
    ['odi', 'application/vnd.oasis.opendocument.image'],
    ['odm', 'application/vnd.oasis.opendocument.text-master'],
    ['odp', 'application/vnd.oasis.opendocument.presentation'],
    ['ods', 'application/vnd.oasis.opendocument.spreadsheet'],
    ['odt', 'application/vnd.oasis.opendocument.text'],
    ['oga', 'audio/ogg'],
    ['ogex', 'model/vnd.opengex'],
    ['ogg', 'audio/ogg'],
    ['ogv', 'video/ogg'],
    ['ogx', 'application/ogg'],
    ['omdoc', 'application/omdoc+xml'],
    ['onepkg', 'application/onenote'],
    ['onetmp', 'application/onenote'],
    ['onetoc', 'application/onenote'],
    ['onetoc2', 'application/onenote'],
    ['opf', 'application/oebps-package+xml'],
    ['opml', 'text/x-opml'],
    ['oprc', 'application/vnd.palm'],
    ['opus', 'audio/ogg'],
    ['org', 'text/x-org'],
    ['osf', 'application/vnd.yamaha.openscoreformat'],
    ['osfpvg', 'application/vnd.yamaha.openscoreformat.osfpvg+xml'],
    ['osm', 'application/vnd.openstreetmap.data+xml'],
    ['otc', 'application/vnd.oasis.opendocument.chart-template'],
    ['otf', 'font/otf'],
    ['otg', 'application/vnd.oasis.opendocument.graphics-template'],
    ['oth', 'application/vnd.oasis.opendocument.text-web'],
    ['oti', 'application/vnd.oasis.opendocument.image-template'],
    ['otp', 'application/vnd.oasis.opendocument.presentation-template'],
    ['ots', 'application/vnd.oasis.opendocument.spreadsheet-template'],
    ['ott', 'application/vnd.oasis.opendocument.text-template'],
    ['ova', 'application/x-virtualbox-ova'],
    ['ovf', 'application/x-virtualbox-ovf'],
    ['owl', 'application/rdf+xml'],
    ['oxps', 'application/oxps'],
    ['oxt', 'application/vnd.openofficeorg.extension'],
    ['p', 'text/x-pascal'],
    ['p7a', 'application/x-pkcs7-signature'],
    ['p7b', 'application/x-pkcs7-certificates'],
    ['p7c', 'application/pkcs7-mime'],
    ['p7m', 'application/pkcs7-mime'],
    ['p7r', 'application/x-pkcs7-certreqresp'],
    ['p7s', 'application/pkcs7-signature'],
    ['p8', 'application/pkcs8'],
    ['p10', 'application/x-pkcs10'],
    ['p12', 'application/x-pkcs12'],
    ['pac', 'application/x-ns-proxy-autoconfig'],
    ['pages', 'application/x-iwork-pages-sffpages'],
    ['pas', 'text/x-pascal'],
    ['paw', 'application/vnd.pawaafile'],
    ['pbd', 'application/vnd.powerbuilder6'],
    ['pbm', 'image/x-portable-bitmap'],
    ['pcap', 'application/vnd.tcpdump.pcap'],
    ['pcf', 'application/x-font-pcf'],
    ['pcl', 'application/vnd.hp-pcl'],
    ['pclxl', 'application/vnd.hp-pclxl'],
    ['pct', 'image/x-pict'],
    ['pcurl', 'application/vnd.curl.pcurl'],
    ['pcx', 'image/x-pcx'],
    ['pdb', 'application/x-pilot'],
    ['pde', 'text/x-processing'],
    ['pdf', 'application/pdf'],
    ['pem', 'application/x-x509-user-cert'],
    ['pfa', 'application/x-font-type1'],
    ['pfb', 'application/x-font-type1'],
    ['pfm', 'application/x-font-type1'],
    ['pfr', 'application/font-tdpfr'],
    ['pfx', 'application/x-pkcs12'],
    ['pgm', 'image/x-portable-graymap'],
    ['pgn', 'application/x-chess-pgn'],
    ['pgp', 'application/pgp'],
    ['php', 'application/x-httpd-php'],
    ['php3', 'application/x-httpd-php'],
    ['php4', 'application/x-httpd-php'],
    ['phps', 'application/x-httpd-php-source'],
    ['phtml', 'application/x-httpd-php'],
    ['pic', 'image/x-pict'],
    ['pkg', 'application/octet-stream'],
    ['pki', 'application/pkixcmp'],
    ['pkipath', 'application/pkix-pkipath'],
    ['pkpass', 'application/vnd.apple.pkpass'],
    ['pl', 'application/x-perl'],
    ['plb', 'application/vnd.3gpp.pic-bw-large'],
    ['plc', 'application/vnd.mobius.plc'],
    ['plf', 'application/vnd.pocketlearn'],
    ['pls', 'application/pls+xml'],
    ['pm', 'application/x-perl'],
    ['pml', 'application/vnd.ctc-posml'],
    ['png', 'image/png'],
    ['pnm', 'image/x-portable-anymap'],
    ['portpkg', 'application/vnd.macports.portpkg'],
    ['pot', 'application/vnd.ms-powerpoint'],
    ['potm', 'application/vnd.ms-powerpoint.presentation.macroEnabled.12'],
    ['potx', 'application/vnd.openxmlformats-officedocument.presentationml.template'],
    ['ppa', 'application/vnd.ms-powerpoint'],
    ['ppam', 'application/vnd.ms-powerpoint.addin.macroEnabled.12'],
    ['ppd', 'application/vnd.cups-ppd'],
    ['ppm', 'image/x-portable-pixmap'],
    ['pps', 'application/vnd.ms-powerpoint'],
    ['ppsm', 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12'],
    ['ppsx', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow'],
    ['ppt', 'application/powerpoint'],
    ['pptm', 'application/vnd.ms-powerpoint.presentation.macroEnabled.12'],
    ['pptx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'],
    ['pqa', 'application/vnd.palm'],
    ['prc', 'application/x-pilot'],
    ['pre', 'application/vnd.lotus-freelance'],
    ['prf', 'application/pics-rules'],
    ['provx', 'application/provenance+xml'],
    ['ps', 'application/postscript'],
    ['psb', 'application/vnd.3gpp.pic-bw-small'],
    ['psd', 'application/x-photoshop'],
    ['psf', 'application/x-font-linux-psf'],
    ['pskcxml', 'application/pskc+xml'],
    ['pti', 'image/prs.pti'],
    ['ptid', 'application/vnd.pvi.ptid1'],
    ['pub', 'application/x-mspublisher'],
    ['pvb', 'application/vnd.3gpp.pic-bw-var'],
    ['pwn', 'application/vnd.3m.post-it-notes'],
    ['pya', 'audio/vnd.ms-playready.media.pya'],
    ['pyv', 'video/vnd.ms-playready.media.pyv'],
    ['qam', 'application/vnd.epson.quickanime'],
    ['qbo', 'application/vnd.intu.qbo'],
    ['qfx', 'application/vnd.intu.qfx'],
    ['qps', 'application/vnd.publishare-delta-tree'],
    ['qt', 'video/quicktime'],
    ['qwd', 'application/vnd.quark.quarkxpress'],
    ['qwt', 'application/vnd.quark.quarkxpress'],
    ['qxb', 'application/vnd.quark.quarkxpress'],
    ['qxd', 'application/vnd.quark.quarkxpress'],
    ['qxl', 'application/vnd.quark.quarkxpress'],
    ['qxt', 'application/vnd.quark.quarkxpress'],
    ['ra', 'audio/x-realaudio'],
    ['ram', 'audio/x-pn-realaudio'],
    ['raml', 'application/raml+yaml'],
    ['rapd', 'application/route-apd+xml'],
    ['rar', 'application/x-rar'],
    ['ras', 'image/x-cmu-raster'],
    ['rcprofile', 'application/vnd.ipunplugged.rcprofile'],
    ['rdf', 'application/rdf+xml'],
    ['rdz', 'application/vnd.data-vision.rdz'],
    ['relo', 'application/p2p-overlay+xml'],
    ['rep', 'application/vnd.businessobjects'],
    ['res', 'application/x-dtbresource+xml'],
    ['rgb', 'image/x-rgb'],
    ['rif', 'application/reginfo+xml'],
    ['rip', 'audio/vnd.rip'],
    ['ris', 'application/x-research-info-systems'],
    ['rl', 'application/resource-lists+xml'],
    ['rlc', 'image/vnd.fujixerox.edmics-rlc'],
    ['rld', 'application/resource-lists-diff+xml'],
    ['rm', 'audio/x-pn-realaudio'],
    ['rmi', 'audio/midi'],
    ['rmp', 'audio/x-pn-realaudio-plugin'],
    ['rms', 'application/vnd.jcp.javame.midlet-rms'],
    ['rmvb', 'application/vnd.rn-realmedia-vbr'],
    ['rnc', 'application/relax-ng-compact-syntax'],
    ['rng', 'application/xml'],
    ['roa', 'application/rpki-roa'],
    ['roff', 'text/troff'],
    ['rp9', 'application/vnd.cloanto.rp9'],
    ['rpm', 'audio/x-pn-realaudio-plugin'],
    ['rpss', 'application/vnd.nokia.radio-presets'],
    ['rpst', 'application/vnd.nokia.radio-preset'],
    ['rq', 'application/sparql-query'],
    ['rs', 'application/rls-services+xml'],
    ['rsa', 'application/x-pkcs7'],
    ['rsat', 'application/atsc-rsat+xml'],
    ['rsd', 'application/rsd+xml'],
    ['rsheet', 'application/urc-ressheet+xml'],
    ['rss', 'application/rss+xml'],
    ['rtf', 'text/rtf'],
    ['rtx', 'text/richtext'],
    ['run', 'application/x-makeself'],
    ['rusd', 'application/route-usd+xml'],
    ['rv', 'video/vnd.rn-realvideo'],
    ['s', 'text/x-asm'],
    ['s3m', 'audio/s3m'],
    ['saf', 'application/vnd.yamaha.smaf-audio'],
    ['sass', 'text/x-sass'],
    ['sbml', 'application/sbml+xml'],
    ['sc', 'application/vnd.ibm.secure-container'],
    ['scd', 'application/x-msschedule'],
    ['scm', 'application/vnd.lotus-screencam'],
    ['scq', 'application/scvp-cv-request'],
    ['scs', 'application/scvp-cv-response'],
    ['scss', 'text/x-scss'],
    ['scurl', 'text/vnd.curl.scurl'],
    ['sda', 'application/vnd.stardivision.draw'],
    ['sdc', 'application/vnd.stardivision.calc'],
    ['sdd', 'application/vnd.stardivision.impress'],
    ['sdkd', 'application/vnd.solent.sdkm+xml'],
    ['sdkm', 'application/vnd.solent.sdkm+xml'],
    ['sdp', 'application/sdp'],
    ['sdw', 'application/vnd.stardivision.writer'],
    ['sea', 'application/octet-stream'],
    ['see', 'application/vnd.seemail'],
    ['seed', 'application/vnd.fdsn.seed'],
    ['sema', 'application/vnd.sema'],
    ['semd', 'application/vnd.semd'],
    ['semf', 'application/vnd.semf'],
    ['senmlx', 'application/senml+xml'],
    ['sensmlx', 'application/sensml+xml'],
    ['ser', 'application/java-serialized-object'],
    ['setpay', 'application/set-payment-initiation'],
    ['setreg', 'application/set-registration-initiation'],
    ['sfd-hdstx', 'application/vnd.hydrostatix.sof-data'],
    ['sfs', 'application/vnd.spotfire.sfs'],
    ['sfv', 'text/x-sfv'],
    ['sgi', 'image/sgi'],
    ['sgl', 'application/vnd.stardivision.writer-global'],
    ['sgm', 'text/sgml'],
    ['sgml', 'text/sgml'],
    ['sh', 'application/x-sh'],
    ['shar', 'application/x-shar'],
    ['shex', 'text/shex'],
    ['shf', 'application/shf+xml'],
    ['shtml', 'text/html'],
    ['sid', 'image/x-mrsid-image'],
    ['sieve', 'application/sieve'],
    ['sig', 'application/pgp-signature'],
    ['sil', 'audio/silk'],
    ['silo', 'model/mesh'],
    ['sis', 'application/vnd.symbian.install'],
    ['sisx', 'application/vnd.symbian.install'],
    ['sit', 'application/x-stuffit'],
    ['sitx', 'application/x-stuffitx'],
    ['siv', 'application/sieve'],
    ['skd', 'application/vnd.koan'],
    ['skm', 'application/vnd.koan'],
    ['skp', 'application/vnd.koan'],
    ['skt', 'application/vnd.koan'],
    ['sldm', 'application/vnd.ms-powerpoint.slide.macroenabled.12'],
    ['sldx', 'application/vnd.openxmlformats-officedocument.presentationml.slide'],
    ['slim', 'text/slim'],
    ['slm', 'text/slim'],
    ['sls', 'application/route-s-tsid+xml'],
    ['slt', 'application/vnd.epson.salt'],
    ['sm', 'application/vnd.stepmania.stepchart'],
    ['smf', 'application/vnd.stardivision.math'],
    ['smi', 'application/smil'],
    ['smil', 'application/smil'],
    ['smv', 'video/x-smv'],
    ['smzip', 'application/vnd.stepmania.package'],
    ['snd', 'audio/basic'],
    ['snf', 'application/x-font-snf'],
    ['so', 'application/octet-stream'],
    ['spc', 'application/x-pkcs7-certificates'],
    ['spdx', 'text/spdx'],
    ['spf', 'application/vnd.yamaha.smaf-phrase'],
    ['spl', 'application/x-futuresplash'],
    ['spot', 'text/vnd.in3d.spot'],
    ['spp', 'application/scvp-vp-response'],
    ['spq', 'application/scvp-vp-request'],
    ['spx', 'audio/ogg'],
    ['sql', 'application/x-sql'],
    ['src', 'application/x-wais-source'],
    ['srt', 'application/x-subrip'],
    ['sru', 'application/sru+xml'],
    ['srx', 'application/sparql-results+xml'],
    ['ssdl', 'application/ssdl+xml'],
    ['sse', 'application/vnd.kodak-descriptor'],
    ['ssf', 'application/vnd.epson.ssf'],
    ['ssml', 'application/ssml+xml'],
    ['sst', 'application/octet-stream'],
    ['st', 'application/vnd.sailingtracker.track'],
    ['stc', 'application/vnd.sun.xml.calc.template'],
    ['std', 'application/vnd.sun.xml.draw.template'],
    ['stf', 'application/vnd.wt.stf'],
    ['sti', 'application/vnd.sun.xml.impress.template'],
    ['stk', 'application/hyperstudio'],
    ['stl', 'model/stl'],
    ['stpx', 'model/step+xml'],
    ['stpxz', 'model/step-xml+zip'],
    ['stpz', 'model/step+zip'],
    ['str', 'application/vnd.pg.format'],
    ['stw', 'application/vnd.sun.xml.writer.template'],
    ['styl', 'text/stylus'],
    ['stylus', 'text/stylus'],
    ['sub', 'text/vnd.dvb.subtitle'],
    ['sus', 'application/vnd.sus-calendar'],
    ['susp', 'application/vnd.sus-calendar'],
    ['sv4cpio', 'application/x-sv4cpio'],
    ['sv4crc', 'application/x-sv4crc'],
    ['svc', 'application/vnd.dvb.service'],
    ['svd', 'application/vnd.svd'],
    ['svg', 'image/svg+xml'],
    ['svgz', 'image/svg+xml'],
    ['swa', 'application/x-director'],
    ['swf', 'application/x-shockwave-flash'],
    ['swi', 'application/vnd.aristanetworks.swi'],
    ['swidtag', 'application/swid+xml'],
    ['sxc', 'application/vnd.sun.xml.calc'],
    ['sxd', 'application/vnd.sun.xml.draw'],
    ['sxg', 'application/vnd.sun.xml.writer.global'],
    ['sxi', 'application/vnd.sun.xml.impress'],
    ['sxm', 'application/vnd.sun.xml.math'],
    ['sxw', 'application/vnd.sun.xml.writer'],
    ['t', 'text/troff'],
    ['t3', 'application/x-t3vm-image'],
    ['t38', 'image/t38'],
    ['taglet', 'application/vnd.mynfc'],
    ['tao', 'application/vnd.tao.intent-module-archive'],
    ['tap', 'image/vnd.tencent.tap'],
    ['tar', 'application/x-tar'],
    ['tcap', 'application/vnd.3gpp2.tcap'],
    ['tcl', 'application/x-tcl'],
    ['td', 'application/urc-targetdesc+xml'],
    ['teacher', 'application/vnd.smart.teacher'],
    ['tei', 'application/tei+xml'],
    ['teicorpus', 'application/tei+xml'],
    ['tex', 'application/x-tex'],
    ['texi', 'application/x-texinfo'],
    ['texinfo', 'application/x-texinfo'],
    ['text', 'text/plain'],
    ['tfi', 'application/thraud+xml'],
    ['tfm', 'application/x-tex-tfm'],
    ['tfx', 'image/tiff-fx'],
    ['tga', 'image/x-tga'],
    ['tgz', 'application/x-tar'],
    ['thmx', 'application/vnd.ms-officetheme'],
    ['tif', 'image/tiff'],
    ['tiff', 'image/tiff'],
    ['tk', 'application/x-tcl'],
    ['tmo', 'application/vnd.tmobile-livetv'],
    ['toml', 'application/toml'],
    ['torrent', 'application/x-bittorrent'],
    ['tpl', 'application/vnd.groove-tool-template'],
    ['tpt', 'application/vnd.trid.tpt'],
    ['tr', 'text/troff'],
    ['tra', 'application/vnd.trueapp'],
    ['trig', 'application/trig'],
    ['trm', 'application/x-msterminal'],
    ['ts', 'video/mp2t'],
    ['tsd', 'application/timestamped-data'],
    ['tsv', 'text/tab-separated-values'],
    ['ttc', 'font/collection'],
    ['ttf', 'font/ttf'],
    ['ttl', 'text/turtle'],
    ['ttml', 'application/ttml+xml'],
    ['twd', 'application/vnd.simtech-mindmapper'],
    ['twds', 'application/vnd.simtech-mindmapper'],
    ['txd', 'application/vnd.genomatix.tuxedo'],
    ['txf', 'application/vnd.mobius.txf'],
    ['txt', 'text/plain'],
    ['u8dsn', 'message/global-delivery-status'],
    ['u8hdr', 'message/global-headers'],
    ['u8mdn', 'message/global-disposition-notification'],
    ['u8msg', 'message/global'],
    ['u32', 'application/x-authorware-bin'],
    ['ubj', 'application/ubjson'],
    ['udeb', 'application/x-debian-package'],
    ['ufd', 'application/vnd.ufdl'],
    ['ufdl', 'application/vnd.ufdl'],
    ['ulx', 'application/x-glulx'],
    ['umj', 'application/vnd.umajin'],
    ['unityweb', 'application/vnd.unity'],
    ['uoml', 'application/vnd.uoml+xml'],
    ['uri', 'text/uri-list'],
    ['uris', 'text/uri-list'],
    ['urls', 'text/uri-list'],
    ['usdz', 'model/vnd.usdz+zip'],
    ['ustar', 'application/x-ustar'],
    ['utz', 'application/vnd.uiq.theme'],
    ['uu', 'text/x-uuencode'],
    ['uva', 'audio/vnd.dece.audio'],
    ['uvd', 'application/vnd.dece.data'],
    ['uvf', 'application/vnd.dece.data'],
    ['uvg', 'image/vnd.dece.graphic'],
    ['uvh', 'video/vnd.dece.hd'],
    ['uvi', 'image/vnd.dece.graphic'],
    ['uvm', 'video/vnd.dece.mobile'],
    ['uvp', 'video/vnd.dece.pd'],
    ['uvs', 'video/vnd.dece.sd'],
    ['uvt', 'application/vnd.dece.ttml+xml'],
    ['uvu', 'video/vnd.uvvu.mp4'],
    ['uvv', 'video/vnd.dece.video'],
    ['uvva', 'audio/vnd.dece.audio'],
    ['uvvd', 'application/vnd.dece.data'],
    ['uvvf', 'application/vnd.dece.data'],
    ['uvvg', 'image/vnd.dece.graphic'],
    ['uvvh', 'video/vnd.dece.hd'],
    ['uvvi', 'image/vnd.dece.graphic'],
    ['uvvm', 'video/vnd.dece.mobile'],
    ['uvvp', 'video/vnd.dece.pd'],
    ['uvvs', 'video/vnd.dece.sd'],
    ['uvvt', 'application/vnd.dece.ttml+xml'],
    ['uvvu', 'video/vnd.uvvu.mp4'],
    ['uvvv', 'video/vnd.dece.video'],
    ['uvvx', 'application/vnd.dece.unspecified'],
    ['uvvz', 'application/vnd.dece.zip'],
    ['uvx', 'application/vnd.dece.unspecified'],
    ['uvz', 'application/vnd.dece.zip'],
    ['vbox', 'application/x-virtualbox-vbox'],
    ['vbox-extpack', 'application/x-virtualbox-vbox-extpack'],
    ['vcard', 'text/vcard'],
    ['vcd', 'application/x-cdlink'],
    ['vcf', 'text/x-vcard'],
    ['vcg', 'application/vnd.groove-vcard'],
    ['vcs', 'text/x-vcalendar'],
    ['vcx', 'application/vnd.vcx'],
    ['vdi', 'application/x-virtualbox-vdi'],
    ['vds', 'model/vnd.sap.vds'],
    ['vhd', 'application/x-virtualbox-vhd'],
    ['vis', 'application/vnd.visionary'],
    ['viv', 'video/vnd.vivo'],
    ['vlc', 'application/videolan'],
    ['vmdk', 'application/x-virtualbox-vmdk'],
    ['vob', 'video/x-ms-vob'],
    ['vor', 'application/vnd.stardivision.writer'],
    ['vox', 'application/x-authorware-bin'],
    ['vrml', 'model/vrml'],
    ['vsd', 'application/vnd.visio'],
    ['vsf', 'application/vnd.vsf'],
    ['vss', 'application/vnd.visio'],
    ['vst', 'application/vnd.visio'],
    ['vsw', 'application/vnd.visio'],
    ['vtf', 'image/vnd.valve.source.texture'],
    ['vtt', 'text/vtt'],
    ['vtu', 'model/vnd.vtu'],
    ['vxml', 'application/voicexml+xml'],
    ['w3d', 'application/x-director'],
    ['wad', 'application/x-doom'],
    ['wadl', 'application/vnd.sun.wadl+xml'],
    ['war', 'application/java-archive'],
    ['wasm', 'application/wasm'],
    ['wav', 'audio/x-wav'],
    ['wax', 'audio/x-ms-wax'],
    ['wbmp', 'image/vnd.wap.wbmp'],
    ['wbs', 'application/vnd.criticaltools.wbs+xml'],
    ['wbxml', 'application/wbxml'],
    ['wcm', 'application/vnd.ms-works'],
    ['wdb', 'application/vnd.ms-works'],
    ['wdp', 'image/vnd.ms-photo'],
    ['weba', 'audio/webm'],
    ['webapp', 'application/x-web-app-manifest+json'],
    ['webm', 'video/webm'],
    ['webmanifest', 'application/manifest+json'],
    ['webp', 'image/webp'],
    ['wg', 'application/vnd.pmi.widget'],
    ['wgt', 'application/widget'],
    ['wks', 'application/vnd.ms-works'],
    ['wm', 'video/x-ms-wm'],
    ['wma', 'audio/x-ms-wma'],
    ['wmd', 'application/x-ms-wmd'],
    ['wmf', 'image/wmf'],
    ['wml', 'text/vnd.wap.wml'],
    ['wmlc', 'application/wmlc'],
    ['wmls', 'text/vnd.wap.wmlscript'],
    ['wmlsc', 'application/vnd.wap.wmlscriptc'],
    ['wmv', 'video/x-ms-wmv'],
    ['wmx', 'video/x-ms-wmx'],
    ['wmz', 'application/x-msmetafile'],
    ['woff', 'font/woff'],
    ['woff2', 'font/woff2'],
    ['word', 'application/msword'],
    ['wpd', 'application/vnd.wordperfect'],
    ['wpl', 'application/vnd.ms-wpl'],
    ['wps', 'application/vnd.ms-works'],
    ['wqd', 'application/vnd.wqd'],
    ['wri', 'application/x-mswrite'],
    ['wrl', 'model/vrml'],
    ['wsc', 'message/vnd.wfa.wsc'],
    ['wsdl', 'application/wsdl+xml'],
    ['wspolicy', 'application/wspolicy+xml'],
    ['wtb', 'application/vnd.webturbo'],
    ['wvx', 'video/x-ms-wvx'],
    ['x3d', 'model/x3d+xml'],
    ['x3db', 'model/x3d+fastinfoset'],
    ['x3dbz', 'model/x3d+binary'],
    ['x3dv', 'model/x3d-vrml'],
    ['x3dvz', 'model/x3d+vrml'],
    ['x3dz', 'model/x3d+xml'],
    ['x32', 'application/x-authorware-bin'],
    ['x_b', 'model/vnd.parasolid.transmit.binary'],
    ['x_t', 'model/vnd.parasolid.transmit.text'],
    ['xaml', 'application/xaml+xml'],
    ['xap', 'application/x-silverlight-app'],
    ['xar', 'application/vnd.xara'],
    ['xav', 'application/xcap-att+xml'],
    ['xbap', 'application/x-ms-xbap'],
    ['xbd', 'application/vnd.fujixerox.docuworks.binder'],
    ['xbm', 'image/x-xbitmap'],
    ['xca', 'application/xcap-caps+xml'],
    ['xcs', 'application/calendar+xml'],
    ['xdf', 'application/xcap-diff+xml'],
    ['xdm', 'application/vnd.syncml.dm+xml'],
    ['xdp', 'application/vnd.adobe.xdp+xml'],
    ['xdssc', 'application/dssc+xml'],
    ['xdw', 'application/vnd.fujixerox.docuworks'],
    ['xel', 'application/xcap-el+xml'],
    ['xenc', 'application/xenc+xml'],
    ['xer', 'application/patch-ops-error+xml'],
    ['xfdf', 'application/vnd.adobe.xfdf'],
    ['xfdl', 'application/vnd.xfdl'],
    ['xht', 'application/xhtml+xml'],
    ['xhtml', 'application/xhtml+xml'],
    ['xhvml', 'application/xv+xml'],
    ['xif', 'image/vnd.xiff'],
    ['xl', 'application/excel'],
    ['xla', 'application/vnd.ms-excel'],
    ['xlam', 'application/vnd.ms-excel.addin.macroEnabled.12'],
    ['xlc', 'application/vnd.ms-excel'],
    ['xlf', 'application/xliff+xml'],
    ['xlm', 'application/vnd.ms-excel'],
    ['xls', 'application/vnd.ms-excel'],
    ['xlsb', 'application/vnd.ms-excel.sheet.binary.macroEnabled.12'],
    ['xlsm', 'application/vnd.ms-excel.sheet.macroEnabled.12'],
    ['xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],
    ['xlt', 'application/vnd.ms-excel'],
    ['xltm', 'application/vnd.ms-excel.template.macroEnabled.12'],
    ['xltx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template'],
    ['xlw', 'application/vnd.ms-excel'],
    ['xm', 'audio/xm'],
    ['xml', 'application/xml'],
    ['xns', 'application/xcap-ns+xml'],
    ['xo', 'application/vnd.olpc-sugar'],
    ['xop', 'application/xop+xml'],
    ['xpi', 'application/x-xpinstall'],
    ['xpl', 'application/xproc+xml'],
    ['xpm', 'image/x-xpixmap'],
    ['xpr', 'application/vnd.is-xpr'],
    ['xps', 'application/vnd.ms-xpsdocument'],
    ['xpw', 'application/vnd.intercon.formnet'],
    ['xpx', 'application/vnd.intercon.formnet'],
    ['xsd', 'application/xml'],
    ['xsl', 'application/xml'],
    ['xslt', 'application/xslt+xml'],
    ['xsm', 'application/vnd.syncml+xml'],
    ['xspf', 'application/xspf+xml'],
    ['xul', 'application/vnd.mozilla.xul+xml'],
    ['xvm', 'application/xv+xml'],
    ['xvml', 'application/xv+xml'],
    ['xwd', 'image/x-xwindowdump'],
    ['xyz', 'chemical/x-xyz'],
    ['xz', 'application/x-xz'],
    ['yaml', 'text/yaml'],
    ['yang', 'application/yang'],
    ['yin', 'application/yin+xml'],
    ['yml', 'text/yaml'],
    ['ymp', 'text/x-suse-ymp'],
    ['z', 'application/x-compress'],
    ['z1', 'application/x-zmachine'],
    ['z2', 'application/x-zmachine'],
    ['z3', 'application/x-zmachine'],
    ['z4', 'application/x-zmachine'],
    ['z5', 'application/x-zmachine'],
    ['z6', 'application/x-zmachine'],
    ['z7', 'application/x-zmachine'],
    ['z8', 'application/x-zmachine'],
    ['zaz', 'application/vnd.zzazz.deck+xml'],
    ['zip', 'application/zip'],
    ['zir', 'application/vnd.zul'],
    ['zirz', 'application/vnd.zul'],
    ['zmm', 'application/vnd.handheld-entertainment+xml'],
    ['zsh', 'text/x-scriptzsh'],
  ])
function Do(e, n, t) {
  const r = _j(e),
    { webkitRelativePath: i } = e,
    s = typeof n == 'string' ? n : typeof i == 'string' && i.length > 0 ? i : `./${e.name}`
  return (typeof r.path != 'string' && bb(r, 'path', s), bb(r, 'relativePath', s), r)
}
function _j(e) {
  const { name: n } = e
  if (n && n.lastIndexOf('.') !== -1 && !e.type) {
    const r = n.split('.').pop().toLowerCase(),
      i = Sj.get(r)
    i &&
      Object.defineProperty(e, 'type', { value: i, writable: !1, configurable: !1, enumerable: !0 })
  }
  return e
}
function bb(e, n, t) {
  Object.defineProperty(e, n, { value: t, writable: !1, configurable: !1, enumerable: !0 })
}
const kj = ['.DS_Store', 'Thumbs.db']
function WZ(e) {
  return Vs(this, void 0, void 0, function* () {
    return gu(e) && Cj(e.dataTransfer)
      ? Aj(e.dataTransfer, e.type)
      : Mj(e)
        ? Ej(e)
        : Array.isArray(e) && e.every((n) => 'getFile' in n && typeof n.getFile == 'function')
          ? Tj(e)
          : []
  })
}
function Cj(e) {
  return gu(e)
}
function Mj(e) {
  return gu(e) && gu(e.target)
}
function gu(e) {
  return typeof e == 'object' && e !== null
}
function Ej(e) {
  return Ap(e.target.files).map((n) => Do(n))
}
function Tj(e) {
  return Vs(this, void 0, void 0, function* () {
    return (yield Promise.all(e.map((t) => t.getFile()))).map((t) => Do(t))
  })
}
function Aj(e, n) {
  return Vs(this, void 0, void 0, function* () {
    if (e.items) {
      const t = Ap(e.items).filter((i) => i.kind === 'file')
      if (n !== 'drop') return t
      const r = yield Promise.all(t.map(Rj))
      return vb(o4(r))
    }
    return vb(Ap(e.files).map((t) => Do(t)))
  })
}
function vb(e) {
  return e.filter((n) => kj.indexOf(n.name) === -1)
}
function Ap(e) {
  if (e === null) return []
  const n = []
  for (let t = 0; t < e.length; t++) {
    const r = e[t]
    n.push(r)
  }
  return n
}
function Rj(e) {
  if (typeof e.webkitGetAsEntry != 'function') return wb(e)
  const n = e.webkitGetAsEntry()
  return n && n.isDirectory ? a4(n) : wb(e, n)
}
function o4(e) {
  return e.reduce((n, t) => [...n, ...(Array.isArray(t) ? o4(t) : [t])], [])
}
function wb(e, n) {
  return Vs(this, void 0, void 0, function* () {
    var t
    if (globalThis.isSecureContext && typeof e.getAsFileSystemHandle == 'function') {
      const s = yield e.getAsFileSystemHandle()
      if (s === null) throw new Error(`${e} is not a File`)
      if (s !== void 0) {
        const o = yield s.getFile()
        return ((o.handle = s), Do(o))
      }
    }
    const r = e.getAsFile()
    if (!r) throw new Error(`${e} is not a File`)
    return Do(r, (t = n?.fullPath) !== null && t !== void 0 ? t : void 0)
  })
}
function Oj(e) {
  return Vs(this, void 0, void 0, function* () {
    return e.isDirectory ? a4(e) : Pj(e)
  })
}
function a4(e) {
  const n = e.createReader()
  return new Promise((t, r) => {
    const i = []
    function s() {
      n.readEntries(
        (o) =>
          Vs(this, void 0, void 0, function* () {
            if (o.length) {
              const a = Promise.all(o.map(Oj))
              ;(i.push(a), s())
            } else
              try {
                const a = yield Promise.all(i)
                t(a)
              } catch (a) {
                r(a)
              }
          }),
        (o) => {
          r(o)
        },
      )
    }
    s()
  })
}
function Pj(e) {
  return Vs(this, void 0, void 0, function* () {
    return new Promise((n, t) => {
      e.file(
        (r) => {
          const i = Do(r, e.fullPath)
          n(i)
        },
        (r) => {
          t(r)
        },
      )
    })
  })
}
var KZ = function (e, n) {
    if (e && n) {
      var t = Array.isArray(n) ? n : n.split(',')
      if (t.length === 0) return !0
      var r = e.name || '',
        i = (e.type || '').toLowerCase(),
        s = i.replace(/\/.*$/, '')
      return t.some(function (o) {
        var a = o.trim().toLowerCase()
        return a.charAt(0) === '.'
          ? r.toLowerCase().endsWith(a)
          : a.endsWith('/*')
            ? s === a.replace(/\/.*$/, '')
            : i === a
      })
    }
    return !0
  },
  l4 = { exports: {} }
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/ ;(function (e, n) {
  ;((t, r) => {
    e.exports = r()
  })(xe, function t() {
    var r = typeof self < 'u' ? self : typeof window < 'u' ? window : r !== void 0 ? r : {},
      i,
      s = !r.document && !!r.postMessage,
      o = r.IS_PAPA_WORKER || !1,
      a = {},
      l = 0,
      c = {}
    function u(E) {
      ;((this._handle = null),
        (this._finished = !1),
        (this._completed = !1),
        (this._halted = !1),
        (this._input = null),
        (this._baseIndex = 0),
        (this._partialLine = ''),
        (this._rowCount = 0),
        (this._start = 0),
        (this._nextChunk = null),
        (this.isFirstChunk = !0),
        (this._completeResults = { data: [], errors: [], meta: {} }),
        function (O) {
          var P = T(O)
          ;((P.chunkSize = parseInt(P.chunkSize)),
            O.step || O.chunk || (P.chunkSize = null),
            (this._handle = new g(P)),
            ((this._handle.streamer = this)._config = P))
        }.call(this, E),
        (this.parseChunk = function (O, P) {
          var $ = parseInt(this._config.skipFirstNLines) || 0
          if (this.isFirstChunk && 0 < $) {
            let M = this._config.newline
            ;(M || ((F = this._config.quoteChar || '"'), (M = this._handle.guessLineEndings(O, F))),
              (O = [...O.split(M).slice($)].join(M)))
          }
          ;(this.isFirstChunk &&
            B(this._config.beforeFirstChunk) &&
            (F = this._config.beforeFirstChunk(O)) !== void 0 &&
            (O = F),
            (this.isFirstChunk = !1),
            (this._halted = !1))
          var $ = this._partialLine + O,
            F = ((this._partialLine = ''), this._handle.parse($, this._baseIndex, !this._finished))
          if (!this._handle.paused() && !this._handle.aborted()) {
            if (
              ((O = F.meta.cursor),
              ($ =
                (this._finished ||
                  ((this._partialLine = $.substring(O - this._baseIndex)), (this._baseIndex = O)),
                F && F.data && (this._rowCount += F.data.length),
                this._finished ||
                  (this._config.preview && this._rowCount >= this._config.preview))),
              o)
            )
              r.postMessage({ results: F, workerId: c.WORKER_ID, finished: $ })
            else if (B(this._config.chunk) && !P) {
              if (
                (this._config.chunk(F, this._handle),
                this._handle.paused() || this._handle.aborted())
              )
                return void (this._halted = !0)
              this._completeResults = F = void 0
            }
            return (
              this._config.step ||
                this._config.chunk ||
                ((this._completeResults.data = this._completeResults.data.concat(F.data)),
                (this._completeResults.errors = this._completeResults.errors.concat(F.errors)),
                (this._completeResults.meta = F.meta)),
              this._completed ||
                !$ ||
                !B(this._config.complete) ||
                (F && F.meta.aborted) ||
                (this._config.complete(this._completeResults, this._input), (this._completed = !0)),
              $ || (F && F.meta.paused) || this._nextChunk(),
              F
            )
          }
          this._halted = !0
        }),
        (this._sendError = function (O) {
          B(this._config.error)
            ? this._config.error(O)
            : o &&
              this._config.error &&
              r.postMessage({ workerId: c.WORKER_ID, error: O, finished: !1 })
        }))
    }
    function f(E) {
      var O
      ;((E = E || {}).chunkSize || (E.chunkSize = c.RemoteChunkSize),
        u.call(this, E),
        (this._nextChunk = s
          ? function () {
              ;(this._readChunk(), this._chunkLoaded())
            }
          : function () {
              this._readChunk()
            }),
        (this.stream = function (P) {
          ;((this._input = P), this._nextChunk())
        }),
        (this._readChunk = function () {
          if (this._finished) this._chunkLoaded()
          else {
            if (
              ((O = new XMLHttpRequest()),
              this._config.withCredentials && (O.withCredentials = this._config.withCredentials),
              s ||
                ((O.onload = I(this._chunkLoaded, this)), (O.onerror = I(this._chunkError, this))),
              O.open(this._config.downloadRequestBody ? 'POST' : 'GET', this._input, !s),
              this._config.downloadRequestHeaders)
            ) {
              var P,
                $ = this._config.downloadRequestHeaders
              for (P in $) O.setRequestHeader(P, $[P])
            }
            var F
            this._config.chunkSize &&
              ((F = this._start + this._config.chunkSize - 1),
              O.setRequestHeader('Range', 'bytes=' + this._start + '-' + F))
            try {
              O.send(this._config.downloadRequestBody)
            } catch (M) {
              this._chunkError(M.message)
            }
            s && O.status === 0 && this._chunkError()
          }
        }),
        (this._chunkLoaded = function () {
          O.readyState === 4 &&
            (O.status < 200 || 400 <= O.status
              ? this._chunkError()
              : ((this._start += this._config.chunkSize || O.responseText.length),
                (this._finished =
                  !this._config.chunkSize ||
                  this._start >=
                    ((P) =>
                      (P = P.getResponseHeader('Content-Range')) !== null
                        ? parseInt(P.substring(P.lastIndexOf('/') + 1))
                        : -1)(O)),
                this.parseChunk(O.responseText)))
        }),
        (this._chunkError = function (P) {
          ;((P = O.statusText || P), this._sendError(new Error(P)))
        }))
    }
    function d(E) {
      ;((E = E || {}).chunkSize || (E.chunkSize = c.LocalChunkSize), u.call(this, E))
      var O,
        P,
        $ = typeof FileReader < 'u'
      ;((this.stream = function (F) {
        ;((this._input = F),
          (P = F.slice || F.webkitSlice || F.mozSlice),
          $
            ? (((O = new FileReader()).onload = I(this._chunkLoaded, this)),
              (O.onerror = I(this._chunkError, this)))
            : (O = new FileReaderSync()),
          this._nextChunk())
      }),
        (this._nextChunk = function () {
          this._finished ||
            (this._config.preview && !(this._rowCount < this._config.preview)) ||
            this._readChunk()
        }),
        (this._readChunk = function () {
          var F = this._input,
            M =
              (this._config.chunkSize &&
                ((M = Math.min(this._start + this._config.chunkSize, this._input.size)),
                (F = P.call(F, this._start, M))),
              O.readAsText(F, this._config.encoding))
          $ || this._chunkLoaded({ target: { result: M } })
        }),
        (this._chunkLoaded = function (F) {
          ;((this._start += this._config.chunkSize),
            (this._finished = !this._config.chunkSize || this._start >= this._input.size),
            this.parseChunk(F.target.result))
        }),
        (this._chunkError = function () {
          this._sendError(O.error)
        }))
    }
    function h(E) {
      var O
      ;(u.call(this, (E = E || {})),
        (this.stream = function (P) {
          return ((O = P), this._nextChunk())
        }),
        (this._nextChunk = function () {
          var P, $
          if (!this._finished)
            return (
              (P = this._config.chunkSize),
              (O = P ? (($ = O.substring(0, P)), O.substring(P)) : (($ = O), '')),
              (this._finished = !O),
              this.parseChunk($)
            )
        }))
    }
    function p(E) {
      u.call(this, (E = E || {}))
      var O = [],
        P = !0,
        $ = !1
      ;((this.pause = function () {
        ;(u.prototype.pause.apply(this, arguments), this._input.pause())
      }),
        (this.resume = function () {
          ;(u.prototype.resume.apply(this, arguments), this._input.resume())
        }),
        (this.stream = function (F) {
          ;((this._input = F),
            this._input.on('data', this._streamData),
            this._input.on('end', this._streamEnd),
            this._input.on('error', this._streamError))
        }),
        (this._checkIsFinished = function () {
          $ && O.length === 1 && (this._finished = !0)
        }),
        (this._nextChunk = function () {
          ;(this._checkIsFinished(), O.length ? this.parseChunk(O.shift()) : (P = !0))
        }),
        (this._streamData = I(function (F) {
          try {
            ;(O.push(typeof F == 'string' ? F : F.toString(this._config.encoding)),
              P && ((P = !1), this._checkIsFinished(), this.parseChunk(O.shift())))
          } catch (M) {
            this._streamError(M)
          }
        }, this)),
        (this._streamError = I(function (F) {
          ;(this._streamCleanUp(), this._sendError(F))
        }, this)),
        (this._streamEnd = I(function () {
          ;(this._streamCleanUp(), ($ = !0), this._streamData(''))
        }, this)),
        (this._streamCleanUp = I(function () {
          ;(this._input.removeListener('data', this._streamData),
            this._input.removeListener('end', this._streamEnd),
            this._input.removeListener('error', this._streamError))
        }, this)))
    }
    function g(E) {
      var O,
        P,
        $,
        F,
        M = Math.pow(2, 53),
        R = -M,
        k = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,
        v =
          /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,
        x = this,
        _ = 0,
        S = 0,
        A = !1,
        j = !1,
        L = [],
        H = { data: [], errors: [], meta: {} }
      function U(D) {
        return E.skipEmptyLines === 'greedy'
          ? D.join('').trim() === ''
          : D.length === 1 && D[0].length === 0
      }
      function K() {
        if (
          (H &&
            $ &&
            (q(
              'Delimiter',
              'UndetectableDelimiter',
              "Unable to auto-detect delimiting character; defaulted to '" +
                c.DefaultDelimiter +
                "'",
            ),
            ($ = !1)),
          E.skipEmptyLines &&
            (H.data = H.data.filter(function (W) {
              return !U(W)
            })),
          z())
        ) {
          let W = function (J, G) {
            ;(B(E.transformHeader) && (J = E.transformHeader(J, G)), L.push(J))
          }
          if (H)
            if (Array.isArray(H.data[0])) {
              for (var D = 0; z() && D < H.data.length; D++) H.data[D].forEach(W)
              H.data.splice(0, 1)
            } else H.data.forEach(W)
        }
        function N(W, J) {
          for (var G = E.header ? {} : [], Z = 0; Z < W.length; Z++) {
            var rt = Z,
              nt = W[Z],
              nt = ((X, Q) =>
                ((tt) => (
                  E.dynamicTypingFunction &&
                    E.dynamicTyping[tt] === void 0 &&
                    (E.dynamicTyping[tt] = E.dynamicTypingFunction(tt)),
                  (E.dynamicTyping[tt] || E.dynamicTyping) === !0
                ))(X)
                  ? Q === 'true' ||
                    Q === 'TRUE' ||
                    (Q !== 'false' &&
                      Q !== 'FALSE' &&
                      (((tt) => {
                        if (k.test(tt) && ((tt = parseFloat(tt)), R < tt && tt < M)) return 1
                      })(Q)
                        ? parseFloat(Q)
                        : v.test(Q)
                          ? new Date(Q)
                          : Q === ''
                            ? null
                            : Q))
                  : Q)(
                (rt = E.header ? (Z >= L.length ? '__parsed_extra' : L[Z]) : rt),
                (nt = E.transform ? E.transform(nt, rt) : nt),
              )
            rt === '__parsed_extra' ? ((G[rt] = G[rt] || []), G[rt].push(nt)) : (G[rt] = nt)
          }
          return (
            E.header &&
              (Z > L.length
                ? q(
                    'FieldMismatch',
                    'TooManyFields',
                    'Too many fields: expected ' + L.length + ' fields but parsed ' + Z,
                    S + J,
                  )
                : Z < L.length &&
                  q(
                    'FieldMismatch',
                    'TooFewFields',
                    'Too few fields: expected ' + L.length + ' fields but parsed ' + Z,
                    S + J,
                  )),
            G
          )
        }
        var V
        H &&
          (E.header || E.dynamicTyping || E.transform) &&
          ((V = 1),
          !H.data.length || Array.isArray(H.data[0])
            ? ((H.data = H.data.map(N)), (V = H.data.length))
            : (H.data = N(H.data, 0)),
          E.header && H.meta && (H.meta.fields = L),
          (S += V))
      }
      function z() {
        return E.header && L.length === 0
      }
      function q(D, N, V, W) {
        ;((D = { type: D, code: N, message: V }), W !== void 0 && (D.row = W), H.errors.push(D))
      }
      ;(B(E.step) &&
        ((F = E.step),
        (E.step = function (D) {
          ;((H = D),
            z()
              ? K()
              : (K(),
                H.data.length !== 0 &&
                  ((_ += D.data.length),
                  E.preview && _ > E.preview ? P.abort() : ((H.data = H.data[0]), F(H, x)))))
        })),
        (this.parse = function (D, N, V) {
          var W = E.quoteChar || '"',
            W =
              (E.newline || (E.newline = this.guessLineEndings(D, W)),
              ($ = !1),
              E.delimiter
                ? B(E.delimiter) &&
                  ((E.delimiter = E.delimiter(D)), (H.meta.delimiter = E.delimiter))
                : ((W = ((J, G, Z, rt, nt) => {
                    var X, Q, tt, st
                    nt = nt || [',', '	', '|', ';', c.RECORD_SEP, c.UNIT_SEP]
                    for (var ot = 0; ot < nt.length; ot++) {
                      for (
                        var at,
                          ht = nt[ot],
                          dt = 0,
                          mt = 0,
                          bt = 0,
                          yt =
                            ((tt = void 0),
                            new y({ comments: rt, delimiter: ht, newline: G, preview: 10 }).parse(
                              J,
                            )),
                          vt = 0;
                        vt < yt.data.length;
                        vt++
                      )
                        Z && U(yt.data[vt])
                          ? bt++
                          : ((at = yt.data[vt].length),
                            (mt += at),
                            tt === void 0
                              ? (tt = at)
                              : 0 < at && ((dt += Math.abs(at - tt)), (tt = at)))
                      ;(0 < yt.data.length && (mt /= yt.data.length - bt),
                        (Q === void 0 || dt <= Q) &&
                          (st === void 0 || st < mt) &&
                          1.99 < mt &&
                          ((Q = dt), (X = ht), (st = mt)))
                    }
                    return { successful: !!(E.delimiter = X), bestDelimiter: X }
                  })(D, E.newline, E.skipEmptyLines, E.comments, E.delimitersToGuess)).successful
                    ? (E.delimiter = W.bestDelimiter)
                    : (($ = !0), (E.delimiter = c.DefaultDelimiter)),
                  (H.meta.delimiter = E.delimiter)),
              T(E))
          return (
            E.preview && E.header && W.preview++,
            (O = D),
            (P = new y(W)),
            (H = P.parse(O, N, V)),
            K(),
            A ? { meta: { paused: !0 } } : H || { meta: { paused: !1 } }
          )
        }),
        (this.paused = function () {
          return A
        }),
        (this.pause = function () {
          ;((A = !0), P.abort(), (O = B(E.chunk) ? '' : O.substring(P.getCharIndex())))
        }),
        (this.resume = function () {
          x.streamer._halted ? ((A = !1), x.streamer.parseChunk(O, !0)) : setTimeout(x.resume, 3)
        }),
        (this.aborted = function () {
          return j
        }),
        (this.abort = function () {
          ;((j = !0), P.abort(), (H.meta.aborted = !0), B(E.complete) && E.complete(H), (O = ''))
        }),
        (this.guessLineEndings = function (J, W) {
          J = J.substring(0, 1048576)
          var W = new RegExp(m(W) + '([^]*?)' + m(W), 'gm'),
            V = (J = J.replace(W, '')).split('\r'),
            W = J.split(`
`),
            J = 1 < W.length && W[0].length < V[0].length
          if (V.length === 1 || J)
            return `
`
          for (var G = 0, Z = 0; Z < V.length; Z++)
            V[Z][0] ===
              `
` && G++
          return G >= V.length / 2
            ? `\r
`
            : '\r'
        }))
    }
    function m(E) {
      return E.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    }
    function y(E) {
      var O = (E = E || {}).delimiter,
        P = E.newline,
        $ = E.comments,
        F = E.step,
        M = E.preview,
        R = E.fastMode,
        k = null,
        v = !1,
        x = E.quoteChar == null ? '"' : E.quoteChar,
        _ = x
      if (
        (E.escapeChar !== void 0 && (_ = E.escapeChar),
        (typeof O != 'string' || -1 < c.BAD_DELIMITERS.indexOf(O)) && (O = ','),
        $ === O)
      )
        throw new Error('Comment character same as delimiter')
      ;($ === !0
        ? ($ = '#')
        : (typeof $ != 'string' || -1 < c.BAD_DELIMITERS.indexOf($)) && ($ = !1),
        P !==
          `
` &&
          P !== '\r' &&
          P !==
            `\r
` &&
          (P = `
`))
      var S = 0,
        A = !1
      ;((this.parse = function (j, L, H) {
        if (typeof j != 'string') throw new Error('Input must be a string')
        var U = j.length,
          K = O.length,
          z = P.length,
          q = $.length,
          D = B(F),
          N = [],
          V = [],
          W = [],
          J = (S = 0)
        if (!j) return dt()
        if (R || (R !== !1 && j.indexOf(x) === -1)) {
          for (var G = j.split(P), Z = 0; Z < G.length; Z++) {
            if (((W = G[Z]), (S += W.length), Z !== G.length - 1)) S += P.length
            else if (H) return dt()
            if (!$ || W.substring(0, q) !== $) {
              if (D) {
                if (((N = []), st(W.split(O)), mt(), A)) return dt()
              } else st(W.split(O))
              if (M && M <= Z) return ((N = N.slice(0, M)), dt(!0))
            }
          }
          return dt()
        }
        for (
          var rt = j.indexOf(O, S),
            nt = j.indexOf(P, S),
            X = new RegExp(m(_) + m(x), 'g'),
            Q = j.indexOf(x, S);
          ;

        )
          if (j[S] === x)
            for (Q = S, S++; ; ) {
              if ((Q = j.indexOf(x, Q + 1)) === -1)
                return (
                  H ||
                    V.push({
                      type: 'Quotes',
                      code: 'MissingQuotes',
                      message: 'Quoted field unterminated',
                      row: N.length,
                      index: S,
                    }),
                  at()
                )
              if (Q === U - 1) return at(j.substring(S, Q).replace(X, x))
              if (x === _ && j[Q + 1] === _) Q++
              else if (x === _ || Q === 0 || j[Q - 1] !== _) {
                rt !== -1 && rt < Q + 1 && (rt = j.indexOf(O, Q + 1))
                var tt = ot(
                  (nt = nt !== -1 && nt < Q + 1 ? j.indexOf(P, Q + 1) : nt) === -1
                    ? rt
                    : Math.min(rt, nt),
                )
                if (j.substr(Q + 1 + tt, K) === O) {
                  ;(W.push(j.substring(S, Q).replace(X, x)),
                    j[(S = Q + 1 + tt + K)] !== x && (Q = j.indexOf(x, S)),
                    (rt = j.indexOf(O, S)),
                    (nt = j.indexOf(P, S)))
                  break
                }
                if (((tt = ot(nt)), j.substring(Q + 1 + tt, Q + 1 + tt + z) === P)) {
                  if (
                    (W.push(j.substring(S, Q).replace(X, x)),
                    ht(Q + 1 + tt + z),
                    (rt = j.indexOf(O, S)),
                    (Q = j.indexOf(x, S)),
                    D && (mt(), A))
                  )
                    return dt()
                  if (M && N.length >= M) return dt(!0)
                  break
                }
                ;(V.push({
                  type: 'Quotes',
                  code: 'InvalidQuotes',
                  message: 'Trailing quote on quoted field is malformed',
                  row: N.length,
                  index: S,
                }),
                  Q++)
              }
            }
          else if ($ && W.length === 0 && j.substring(S, S + q) === $) {
            if (nt === -1) return dt()
            ;((S = nt + z), (nt = j.indexOf(P, S)), (rt = j.indexOf(O, S)))
          } else if (rt !== -1 && (rt < nt || nt === -1))
            (W.push(j.substring(S, rt)), (S = rt + K), (rt = j.indexOf(O, S)))
          else {
            if (nt === -1) break
            if ((W.push(j.substring(S, nt)), ht(nt + z), D && (mt(), A))) return dt()
            if (M && N.length >= M) return dt(!0)
          }
        return at()
        function st(bt) {
          ;(N.push(bt), (J = S))
        }
        function ot(bt) {
          var yt = 0
          return (yt =
            bt !== -1 && (bt = j.substring(Q + 1, bt)) && bt.trim() === '' ? bt.length : yt)
        }
        function at(bt) {
          return (
            H || (bt === void 0 && (bt = j.substring(S)), W.push(bt), (S = U), st(W), D && mt()),
            dt()
          )
        }
        function ht(bt) {
          ;((S = bt), st(W), (W = []), (nt = j.indexOf(P, S)))
        }
        function dt(bt) {
          if (E.header && !L && N.length && !v) {
            var yt = N[0],
              vt = Object.create(null),
              Nt = new Set(yt)
            let Dt = !1
            for (let Mt = 0; Mt < yt.length; Mt++) {
              let Ot = yt[Mt]
              if (vt[(Ot = B(E.transformHeader) ? E.transformHeader(Ot, Mt) : Ot)]) {
                let Ct,
                  xt = vt[Ot]
                for (; (Ct = Ot + '_' + xt), xt++, Nt.has(Ct); );
                ;(Nt.add(Ct),
                  (yt[Mt] = Ct),
                  vt[Ot]++,
                  (Dt = !0),
                  ((k = k === null ? {} : k)[Ct] = Ot))
              } else ((vt[Ot] = 1), (yt[Mt] = Ot))
              Nt.add(Ot)
            }
            ;(Dt && console.warn('Duplicate headers found and renamed.'), (v = !0))
          }
          return {
            data: N,
            errors: V,
            meta: {
              delimiter: O,
              linebreak: P,
              aborted: A,
              truncated: !!bt,
              cursor: J + (L || 0),
              renamedHeaders: k,
            },
          }
        }
        function mt() {
          ;(F(dt()), (N = []), (V = []))
        }
      }),
        (this.abort = function () {
          A = !0
        }),
        (this.getCharIndex = function () {
          return S
        }))
    }
    function b(E) {
      var O = E.data,
        P = a[O.workerId],
        $ = !1
      if (O.error) P.userError(O.error, O.file)
      else if (O.results && O.results.data) {
        var F = {
          abort: function () {
            ;(($ = !0), w(O.workerId, { data: [], errors: [], meta: { aborted: !0 } }))
          },
          pause: C,
          resume: C,
        }
        if (B(P.userStep)) {
          for (
            var M = 0;
            M < O.results.data.length &&
            (P.userStep(
              { data: O.results.data[M], errors: O.results.errors, meta: O.results.meta },
              F,
            ),
            !$);
            M++
          );
          delete O.results
        } else B(P.userChunk) && (P.userChunk(O.results, F, O.file), delete O.results)
      }
      O.finished && !$ && w(O.workerId, O.results)
    }
    function w(E, O) {
      var P = a[E]
      ;(B(P.userComplete) && P.userComplete(O), P.terminate(), delete a[E])
    }
    function C() {
      throw new Error('Not implemented.')
    }
    function T(E) {
      if (typeof E != 'object' || E === null) return E
      var O,
        P = Array.isArray(E) ? [] : {}
      for (O in E) P[O] = T(E[O])
      return P
    }
    function I(E, O) {
      return function () {
        E.apply(O, arguments)
      }
    }
    function B(E) {
      return typeof E == 'function'
    }
    return (
      (c.parse = function (E, O) {
        var P = (O = O || {}).dynamicTyping || !1
        if (
          (B(P) && ((O.dynamicTypingFunction = P), (P = {})),
          (O.dynamicTyping = P),
          (O.transform = !!B(O.transform) && O.transform),
          !O.worker || !c.WORKERS_SUPPORTED)
        )
          return (
            (P = null),
            c.NODE_STREAM_INPUT,
            typeof E == 'string'
              ? ((E = (($) => ($.charCodeAt(0) !== 65279 ? $ : $.slice(1)))(E)),
                (P = new (O.download ? f : h)(O)))
              : E.readable === !0 && B(E.read) && B(E.on)
                ? (P = new p(O))
                : ((r.File && E instanceof File) || E instanceof Object) && (P = new d(O)),
            P.stream(E)
          )
        ;(((P = (() => {
          var $
          return (
            !!c.WORKERS_SUPPORTED &&
            (($ = (() => {
              var F = r.URL || r.webkitURL || null,
                M = t.toString()
              return (
                c.BLOB_URL ||
                (c.BLOB_URL = F.createObjectURL(
                  new Blob(
                    [
                      "var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ",
                      '(',
                      M,
                      ')();',
                    ],
                    { type: 'text/javascript' },
                  ),
                ))
              )
            })()),
            (($ = new r.Worker($)).onmessage = b),
            ($.id = l++),
            (a[$.id] = $))
          )
        })()).userStep = O.step),
          (P.userChunk = O.chunk),
          (P.userComplete = O.complete),
          (P.userError = O.error),
          (O.step = B(O.step)),
          (O.chunk = B(O.chunk)),
          (O.complete = B(O.complete)),
          (O.error = B(O.error)),
          delete O.worker,
          P.postMessage({ input: E, config: O, workerId: P.id }))
      }),
      (c.unparse = function (E, O) {
        var P = !1,
          $ = !0,
          F = ',',
          M = `\r
`,
          R = '"',
          k = R + R,
          v = !1,
          x = null,
          _ = !1,
          S =
            ((() => {
              if (typeof O == 'object') {
                if (
                  (typeof O.delimiter != 'string' ||
                    c.BAD_DELIMITERS.filter(function (L) {
                      return O.delimiter.indexOf(L) !== -1
                    }).length ||
                    (F = O.delimiter),
                  (typeof O.quotes != 'boolean' &&
                    typeof O.quotes != 'function' &&
                    !Array.isArray(O.quotes)) ||
                    (P = O.quotes),
                  (typeof O.skipEmptyLines != 'boolean' && typeof O.skipEmptyLines != 'string') ||
                    (v = O.skipEmptyLines),
                  typeof O.newline == 'string' && (M = O.newline),
                  typeof O.quoteChar == 'string' && (R = O.quoteChar),
                  typeof O.header == 'boolean' && ($ = O.header),
                  Array.isArray(O.columns))
                ) {
                  if (O.columns.length === 0) throw new Error('Option columns is empty')
                  x = O.columns
                }
                ;(O.escapeChar !== void 0 && (k = O.escapeChar + R),
                  O.escapeFormulae instanceof RegExp
                    ? (_ = O.escapeFormulae)
                    : typeof O.escapeFormulae == 'boolean' &&
                      O.escapeFormulae &&
                      (_ = /^[=+\-@\t\r].*$/))
              }
            })(),
            new RegExp(m(R), 'g'))
        if ((typeof E == 'string' && (E = JSON.parse(E)), Array.isArray(E))) {
          if (!E.length || Array.isArray(E[0])) return A(null, E, v)
          if (typeof E[0] == 'object') return A(x || Object.keys(E[0]), E, v)
        } else if (typeof E == 'object')
          return (
            typeof E.data == 'string' && (E.data = JSON.parse(E.data)),
            Array.isArray(E.data) &&
              (E.fields || (E.fields = (E.meta && E.meta.fields) || x),
              E.fields ||
                (E.fields = Array.isArray(E.data[0])
                  ? E.fields
                  : typeof E.data[0] == 'object'
                    ? Object.keys(E.data[0])
                    : []),
              Array.isArray(E.data[0]) || typeof E.data[0] == 'object' || (E.data = [E.data])),
            A(E.fields || [], E.data || [], v)
          )
        throw new Error('Unable to serialize unrecognized input')
        function A(L, H, U) {
          var K = '',
            z =
              (typeof L == 'string' && (L = JSON.parse(L)),
              typeof H == 'string' && (H = JSON.parse(H)),
              Array.isArray(L) && 0 < L.length),
            q = !Array.isArray(H[0])
          if (z && $) {
            for (var D = 0; D < L.length; D++) (0 < D && (K += F), (K += j(L[D], D)))
            0 < H.length && (K += M)
          }
          for (var N = 0; N < H.length; N++) {
            var V = (z ? L : H[N]).length,
              W = !1,
              J = z ? Object.keys(H[N]).length === 0 : H[N].length === 0
            if (
              (U &&
                !z &&
                (W =
                  U === 'greedy'
                    ? H[N].join('').trim() === ''
                    : H[N].length === 1 && H[N][0].length === 0),
              U === 'greedy' && z)
            ) {
              for (var G = [], Z = 0; Z < V; Z++) {
                var rt = q ? L[Z] : Z
                G.push(H[N][rt])
              }
              W = G.join('').trim() === ''
            }
            if (!W) {
              for (var nt = 0; nt < V; nt++) {
                0 < nt && !J && (K += F)
                var X = z && q ? L[nt] : nt
                K += j(H[N][X], nt)
              }
              N < H.length - 1 && (!U || (0 < V && !J)) && (K += M)
            }
          }
          return K
        }
        function j(L, H) {
          var U, K
          return L == null
            ? ''
            : L.constructor === Date
              ? JSON.stringify(L).slice(1, 25)
              : ((K = !1),
                _ && typeof L == 'string' && _.test(L) && ((L = "'" + L), (K = !0)),
                (U = L.toString().replace(S, k)),
                (K =
                  K ||
                  P === !0 ||
                  (typeof P == 'function' && P(L, H)) ||
                  (Array.isArray(P) && P[H]) ||
                  ((z, q) => {
                    for (var D = 0; D < q.length; D++) if (-1 < z.indexOf(q[D])) return !0
                    return !1
                  })(U, c.BAD_DELIMITERS) ||
                  -1 < U.indexOf(F) ||
                  U.charAt(0) === ' ' ||
                  U.charAt(U.length - 1) === ' ')
                  ? R + U + R
                  : U)
        }
      }),
      (c.RECORD_SEP = ''),
      (c.UNIT_SEP = ''),
      (c.BYTE_ORDER_MARK = '\uFEFF'),
      (c.BAD_DELIMITERS = [
        '\r',
        `
`,
        '"',
        c.BYTE_ORDER_MARK,
      ]),
      (c.WORKERS_SUPPORTED = !s && !!r.Worker),
      (c.NODE_STREAM_INPUT = 1),
      (c.LocalChunkSize = 10485760),
      (c.RemoteChunkSize = 5242880),
      (c.DefaultDelimiter = ','),
      (c.Parser = y),
      (c.ParserHandle = g),
      (c.NetworkStreamer = f),
      (c.FileStreamer = d),
      (c.StringStreamer = h),
      (c.ReadableStreamStreamer = p),
      r.jQuery &&
        ((i = r.jQuery).fn.parse = function (E) {
          var O = E.config || {},
            P = []
          return (
            this.each(function (M) {
              if (
                !(
                  i(this).prop('tagName').toUpperCase() === 'INPUT' &&
                  i(this).attr('type').toLowerCase() === 'file' &&
                  r.FileReader
                ) ||
                !this.files ||
                this.files.length === 0
              )
                return !0
              for (var R = 0; R < this.files.length; R++)
                P.push({ file: this.files[R], inputElem: this, instanceConfig: i.extend({}, O) })
            }),
            $(),
            this
          )
          function $() {
            if (P.length === 0) B(E.complete) && E.complete()
            else {
              var M,
                R,
                k,
                v,
                x = P[0]
              if (B(E.before)) {
                var _ = E.before(x.file, x.inputElem)
                if (typeof _ == 'object') {
                  if (_.action === 'abort')
                    return (
                      (M = 'AbortError'),
                      (R = x.file),
                      (k = x.inputElem),
                      (v = _.reason),
                      void (B(E.error) && E.error({ name: M }, R, k, v))
                    )
                  if (_.action === 'skip') return void F()
                  typeof _.config == 'object' &&
                    (x.instanceConfig = i.extend(x.instanceConfig, _.config))
                } else if (_ === 'skip') return void F()
              }
              var S = x.instanceConfig.complete
              ;((x.instanceConfig.complete = function (A) {
                ;(B(S) && S(A, x.file, x.inputElem), F())
              }),
                c.parse(x.file, x.instanceConfig))
            }
          }
          function F() {
            ;(P.splice(0, 1), $())
          }
        }),
      o &&
        (r.onmessage = function (E) {
          ;((E = E.data),
            c.WORKER_ID === void 0 && E && (c.WORKER_ID = E.workerId),
            typeof E.input == 'string'
              ? r.postMessage({
                  workerId: c.WORKER_ID,
                  results: c.parse(E.input, E.config),
                  finished: !0,
                })
              : ((r.File && E.input instanceof File) || E.input instanceof Object) &&
                (E = c.parse(E.input, E.config)) &&
                r.postMessage({ workerId: c.WORKER_ID, results: E, finished: !0 }))
        }),
      ((f.prototype = Object.create(u.prototype)).constructor = f),
      ((d.prototype = Object.create(u.prototype)).constructor = d),
      ((h.prototype = Object.create(h.prototype)).constructor = h),
      ((p.prototype = Object.create(u.prototype)).constructor = p),
      c
    )
  })
})(l4)
var Nj = l4.exports
const GZ = kr(Nj)
var mn = []
for (var Wd = 0; Wd < 256; ++Wd) mn.push((Wd + 256).toString(16).slice(1))
function Ij(e, n = 0) {
  return (
    mn[e[n + 0]] +
    mn[e[n + 1]] +
    mn[e[n + 2]] +
    mn[e[n + 3]] +
    '-' +
    mn[e[n + 4]] +
    mn[e[n + 5]] +
    '-' +
    mn[e[n + 6]] +
    mn[e[n + 7]] +
    '-' +
    mn[e[n + 8]] +
    mn[e[n + 9]] +
    '-' +
    mn[e[n + 10]] +
    mn[e[n + 11]] +
    mn[e[n + 12]] +
    mn[e[n + 13]] +
    mn[e[n + 14]] +
    mn[e[n + 15]]
  ).toLowerCase()
}
var fc,
  Dj = new Uint8Array(16)
function jj() {
  if (
    !fc &&
    ((fc = typeof crypto < 'u' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)),
    !fc)
  )
    throw new Error(
      'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported',
    )
  return fc(Dj)
}
var Lj = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto)
const xb = { randomUUID: Lj }
function XZ(e, n, t) {
  if (xb.randomUUID && !e) return xb.randomUUID()
  e = e || {}
  var r = e.random || (e.rng || jj)()
  return ((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), Ij(r))
}
var jf = {},
  c4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return t === '__proto__'
  }
  e.isUnsafeProperty = n
})(c4)
var R0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    switch (typeof t) {
      case 'number':
      case 'symbol':
        return !1
      case 'string':
        return t.includes('.') || t.includes('[') || t.includes(']')
    }
  }
  e.isDeepKey = n
})(R0)
var Lf = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return typeof t == 'string' || typeof t == 'symbol'
      ? t
      : Object.is(t?.valueOf?.(), -0)
        ? '-0'
        : String(t)
  }
  e.toKey = n
})(Lf)
var Ff = {},
  u4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    if (t == null) return ''
    if (typeof t == 'string') return t
    if (Array.isArray(t)) return t.map(n).join(',')
    const r = String(t)
    return r === '0' && Object.is(Number(t), -0) ? '-0' : r
  }
  e.toString = n
})(u4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = u4,
    t = Lf
  function r(i) {
    if (Array.isArray(i)) return i.map(t.toKey)
    if (typeof i == 'symbol') return [i]
    i = n.toString(i)
    const s = [],
      o = i.length
    if (o === 0) return s
    let a = 0,
      l = '',
      c = '',
      u = !1
    for (i.charCodeAt(0) === 46 && (s.push(''), a++); a < o; ) {
      const f = i[a]
      ;(c
        ? f === '\\' && a + 1 < o
          ? (a++, (l += i[a]))
          : f === c
            ? (c = '')
            : (l += f)
        : u
          ? f === '"' || f === "'"
            ? (c = f)
            : f === ']'
              ? ((u = !1), s.push(l), (l = ''))
              : (l += f)
          : f === '['
            ? ((u = !0), l && (s.push(l), (l = '')))
            : f === '.'
              ? l && (s.push(l), (l = ''))
              : (l += f),
        a++)
    }
    return (l && s.push(l), s)
  }
  e.toPath = r
})(Ff)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = c4,
    t = R0,
    r = Lf,
    i = Ff
  function s(a, l, c) {
    if (a == null) return c
    switch (typeof l) {
      case 'string': {
        if (n.isUnsafeProperty(l)) return c
        const u = a[l]
        return u === void 0 ? (t.isDeepKey(l) ? s(a, i.toPath(l), c) : c) : u
      }
      case 'number':
      case 'symbol': {
        typeof l == 'number' && (l = r.toKey(l))
        const u = a[l]
        return u === void 0 ? c : u
      }
      default: {
        if (Array.isArray(l)) return o(a, l, c)
        if ((Object.is(l?.valueOf(), -0) ? (l = '-0') : (l = String(l)), n.isUnsafeProperty(l)))
          return c
        const u = a[l]
        return u === void 0 ? c : u
      }
    }
  }
  function o(a, l, c) {
    if (l.length === 0) return c
    let u = a
    for (let f = 0; f < l.length; f++) {
      if (u == null || n.isUnsafeProperty(l[f])) return c
      u = u[l[f]]
    }
    return u === void 0 ? c : u
  }
  e.get = s
})(jf)
var Fj = jf.get
const YZ = kr(Fj)
var f4 = {},
  d4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t, r) {
    const i = new Map()
    for (let s = 0; s < t.length; s++) {
      const o = t[s],
        a = r(o)
      i.has(a) || i.set(a, o)
    }
    return Array.from(i.values())
  }
  e.uniqBy = n
})(d4)
var O0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return t
  }
  e.identity = n
})(O0)
var h4 = {},
  Bf = {},
  p4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return Number.isSafeInteger(t) && t >= 0
  }
  e.isLength = n
})(p4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = p4
  function t(r) {
    return r != null && typeof r != 'function' && n.isLength(r.length)
  }
  e.isArrayLike = t
})(Bf)
var m4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return typeof t == 'object' && t !== null
  }
  e.isObjectLike = n
})(m4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = Bf,
    t = m4
  function r(i) {
    return t.isObjectLike(i) && n.isArrayLike(i)
  }
  e.isArrayLikeObject = r
})(h4)
var g4 = {},
  y4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = jf
  function t(r) {
    return function (i) {
      return n.get(i, r)
    }
  }
  e.property = t
})(y4)
var b4 = {},
  Kd = {},
  Gd = {},
  P0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return t !== null && (typeof t == 'object' || typeof t == 'function')
  }
  e.isObject = n
})(P0)
var N0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return t == null || (typeof t != 'object' && typeof t != 'function')
  }
  e.isPrimitive = n
})(N0)
var I0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t, r) {
    return t === r || (Number.isNaN(t) && Number.isNaN(r))
  }
  e.eq = n
})(I0)
var Sb
function Bj() {
  return (
    Sb ||
      ((Sb = 1),
      (function (e) {
        Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
        const n = D0(),
          t = P0,
          r = N0,
          i = I0
        function s(f, d, h) {
          return typeof h != 'function'
            ? n.isMatch(f, d)
            : o(
                f,
                d,
                function p(g, m, y, b, w, C) {
                  const T = h(g, m, y, b, w, C)
                  return T !== void 0 ? !!T : o(g, m, p, C)
                },
                new Map(),
              )
        }
        function o(f, d, h, p) {
          if (d === f) return !0
          switch (typeof d) {
            case 'object':
              return a(f, d, h, p)
            case 'function':
              return Object.keys(d).length > 0 ? o(f, { ...d }, h, p) : i.eq(f, d)
            default:
              return t.isObject(f) ? (typeof d == 'string' ? d === '' : !0) : i.eq(f, d)
          }
        }
        function a(f, d, h, p) {
          if (d == null) return !0
          if (Array.isArray(d)) return c(f, d, h, p)
          if (d instanceof Map) return l(f, d, h, p)
          if (d instanceof Set) return u(f, d, h, p)
          const g = Object.keys(d)
          if (f == null) return g.length === 0
          if (g.length === 0) return !0
          if (p && p.has(d)) return p.get(d) === f
          p && p.set(d, f)
          try {
            for (let m = 0; m < g.length; m++) {
              const y = g[m]
              if (
                (!r.isPrimitive(f) && !(y in f)) ||
                (d[y] === void 0 && f[y] !== void 0) ||
                (d[y] === null && f[y] !== null) ||
                !h(f[y], d[y], y, f, d, p)
              )
                return !1
            }
            return !0
          } finally {
            p && p.delete(d)
          }
        }
        function l(f, d, h, p) {
          if (d.size === 0) return !0
          if (!(f instanceof Map)) return !1
          for (const [g, m] of d.entries()) {
            const y = f.get(g)
            if (h(y, m, g, f, d, p) === !1) return !1
          }
          return !0
        }
        function c(f, d, h, p) {
          if (d.length === 0) return !0
          if (!Array.isArray(f)) return !1
          const g = new Set()
          for (let m = 0; m < d.length; m++) {
            const y = d[m]
            let b = !1
            for (let w = 0; w < f.length; w++) {
              if (g.has(w)) continue
              const C = f[w]
              let T = !1
              if ((h(C, y, m, f, d, p) && (T = !0), T)) {
                ;(g.add(w), (b = !0))
                break
              }
            }
            if (!b) return !1
          }
          return !0
        }
        function u(f, d, h, p) {
          return d.size === 0 ? !0 : f instanceof Set ? c([...f], [...d], h, p) : !1
        }
        ;((e.isMatchWith = s), (e.isSetMatch = u))
      })(Gd)),
    Gd
  )
}
var _b
function D0() {
  return (
    _b ||
      ((_b = 1),
      (function (e) {
        Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
        const n = Bj()
        function t(r, i) {
          return n.isMatchWith(r, i, () => {})
        }
        e.isMatch = t
      })(Kd)),
    Kd
  )
}
var v4 = {},
  j0 = {},
  w4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return Object.getOwnPropertySymbols(t).filter((r) =>
      Object.prototype.propertyIsEnumerable.call(t, r),
    )
  }
  e.getSymbols = n
})(w4)
var L0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return t == null
      ? t === void 0
        ? '[object Undefined]'
        : '[object Null]'
      : Object.prototype.toString.call(t)
  }
  e.getTag = n
})(L0)
var F0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = '[object RegExp]',
    t = '[object String]',
    r = '[object Number]',
    i = '[object Boolean]',
    s = '[object Arguments]',
    o = '[object Symbol]',
    a = '[object Date]',
    l = '[object Map]',
    c = '[object Set]',
    u = '[object Array]',
    f = '[object Function]',
    d = '[object ArrayBuffer]',
    h = '[object Object]',
    p = '[object Error]',
    g = '[object DataView]',
    m = '[object Uint8Array]',
    y = '[object Uint8ClampedArray]',
    b = '[object Uint16Array]',
    w = '[object Uint32Array]',
    C = '[object BigUint64Array]',
    T = '[object Int8Array]',
    I = '[object Int16Array]',
    B = '[object Int32Array]',
    E = '[object BigInt64Array]',
    O = '[object Float32Array]',
    P = '[object Float64Array]'
  ;((e.argumentsTag = s),
    (e.arrayBufferTag = d),
    (e.arrayTag = u),
    (e.bigInt64ArrayTag = E),
    (e.bigUint64ArrayTag = C),
    (e.booleanTag = i),
    (e.dataViewTag = g),
    (e.dateTag = a),
    (e.errorTag = p),
    (e.float32ArrayTag = O),
    (e.float64ArrayTag = P),
    (e.functionTag = f),
    (e.int16ArrayTag = I),
    (e.int32ArrayTag = B),
    (e.int8ArrayTag = T),
    (e.mapTag = l),
    (e.numberTag = r),
    (e.objectTag = h),
    (e.regexpTag = n),
    (e.setTag = c),
    (e.stringTag = t),
    (e.symbolTag = o),
    (e.uint16ArrayTag = b),
    (e.uint32ArrayTag = w),
    (e.uint8ArrayTag = m),
    (e.uint8ClampedArrayTag = y))
})(F0)
var x4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView)
  }
  e.isTypedArray = n
})(x4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = w4,
    t = L0,
    r = F0,
    i = N0,
    s = x4
  function o(u, f) {
    return a(u, void 0, u, new Map(), f)
  }
  function a(u, f, d, h = new Map(), p = void 0) {
    const g = p?.(u, f, d, h)
    if (g !== void 0) return g
    if (i.isPrimitive(u)) return u
    if (h.has(u)) return h.get(u)
    if (Array.isArray(u)) {
      const m = new Array(u.length)
      h.set(u, m)
      for (let y = 0; y < u.length; y++) m[y] = a(u[y], y, d, h, p)
      return (
        Object.hasOwn(u, 'index') && (m.index = u.index),
        Object.hasOwn(u, 'input') && (m.input = u.input),
        m
      )
    }
    if (u instanceof Date) return new Date(u.getTime())
    if (u instanceof RegExp) {
      const m = new RegExp(u.source, u.flags)
      return ((m.lastIndex = u.lastIndex), m)
    }
    if (u instanceof Map) {
      const m = new Map()
      h.set(u, m)
      for (const [y, b] of u) m.set(y, a(b, y, d, h, p))
      return m
    }
    if (u instanceof Set) {
      const m = new Set()
      h.set(u, m)
      for (const y of u) m.add(a(y, void 0, d, h, p))
      return m
    }
    if (typeof Buffer < 'u' && Buffer.isBuffer(u)) return u.subarray()
    if (s.isTypedArray(u)) {
      const m = new (Object.getPrototypeOf(u).constructor)(u.length)
      h.set(u, m)
      for (let y = 0; y < u.length; y++) m[y] = a(u[y], y, d, h, p)
      return m
    }
    if (
      u instanceof ArrayBuffer ||
      (typeof SharedArrayBuffer < 'u' && u instanceof SharedArrayBuffer)
    )
      return u.slice(0)
    if (u instanceof DataView) {
      const m = new DataView(u.buffer.slice(0), u.byteOffset, u.byteLength)
      return (h.set(u, m), l(m, u, d, h, p), m)
    }
    if (typeof File < 'u' && u instanceof File) {
      const m = new File([u], u.name, { type: u.type })
      return (h.set(u, m), l(m, u, d, h, p), m)
    }
    if (typeof Blob < 'u' && u instanceof Blob) {
      const m = new Blob([u], { type: u.type })
      return (h.set(u, m), l(m, u, d, h, p), m)
    }
    if (u instanceof Error) {
      const m = new u.constructor()
      return (
        h.set(u, m),
        (m.message = u.message),
        (m.name = u.name),
        (m.stack = u.stack),
        (m.cause = u.cause),
        l(m, u, d, h, p),
        m
      )
    }
    if (u instanceof Boolean) {
      const m = new Boolean(u.valueOf())
      return (h.set(u, m), l(m, u, d, h, p), m)
    }
    if (u instanceof Number) {
      const m = new Number(u.valueOf())
      return (h.set(u, m), l(m, u, d, h, p), m)
    }
    if (u instanceof String) {
      const m = new String(u.valueOf())
      return (h.set(u, m), l(m, u, d, h, p), m)
    }
    if (typeof u == 'object' && c(u)) {
      const m = Object.create(Object.getPrototypeOf(u))
      return (h.set(u, m), l(m, u, d, h, p), m)
    }
    return u
  }
  function l(u, f, d = u, h, p) {
    const g = [...Object.keys(f), ...n.getSymbols(f)]
    for (let m = 0; m < g.length; m++) {
      const y = g[m],
        b = Object.getOwnPropertyDescriptor(u, y)
      ;(b == null || b.writable) && (u[y] = a(f[y], y, d, h, p))
    }
  }
  function c(u) {
    switch (t.getTag(u)) {
      case r.argumentsTag:
      case r.arrayTag:
      case r.arrayBufferTag:
      case r.dataViewTag:
      case r.booleanTag:
      case r.dateTag:
      case r.float32ArrayTag:
      case r.float64ArrayTag:
      case r.int8ArrayTag:
      case r.int16ArrayTag:
      case r.int32ArrayTag:
      case r.mapTag:
      case r.numberTag:
      case r.objectTag:
      case r.regexpTag:
      case r.setTag:
      case r.stringTag:
      case r.symbolTag:
      case r.uint8ArrayTag:
      case r.uint8ClampedArrayTag:
      case r.uint16ArrayTag:
      case r.uint32ArrayTag:
        return !0
      default:
        return !1
    }
  }
  ;((e.cloneDeepWith = o), (e.cloneDeepWithImpl = a), (e.copyProperties = l))
})(j0)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = j0
  function t(r) {
    return n.cloneDeepWithImpl(r, void 0, r, new Map(), void 0)
  }
  e.cloneDeep = t
})(v4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = D0(),
    t = v4
  function r(i) {
    return ((i = t.cloneDeep(i)), (s) => n.isMatch(s, i))
  }
  e.matches = r
})(b4)
var S4 = {},
  _4 = {},
  k4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = j0,
    t = F0
  function r(i, s) {
    return n.cloneDeepWith(i, (o, a, l, c) => {
      const u = s?.(o, a, l, c)
      if (u !== void 0) return u
      if (typeof i == 'object')
        switch (Object.prototype.toString.call(i)) {
          case t.numberTag:
          case t.stringTag:
          case t.booleanTag: {
            const f = new i.constructor(i?.valueOf())
            return (n.copyProperties(f, i), f)
          }
          case t.argumentsTag: {
            const f = {}
            return (
              n.copyProperties(f, i),
              (f.length = i.length),
              (f[Symbol.iterator] = i[Symbol.iterator]),
              f
            )
          }
          default:
            return
        }
    })
  }
  e.cloneDeepWith = r
})(k4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = k4
  function t(r) {
    return n.cloneDeepWith(r)
  }
  e.cloneDeep = t
})(_4)
var C4 = {},
  B0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = /^(?:0|[1-9]\d*)$/
  function t(r, i = Number.MAX_SAFE_INTEGER) {
    switch (typeof r) {
      case 'number':
        return Number.isInteger(r) && r >= 0 && r < i
      case 'symbol':
        return !1
      case 'string':
        return n.test(r)
    }
  }
  e.isIndex = t
})(B0)
var M4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = L0
  function t(r) {
    return r !== null && typeof r == 'object' && n.getTag(r) === '[object Arguments]'
  }
  e.isArguments = t
})(M4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = R0,
    t = B0,
    r = M4,
    i = Ff
  function s(o, a) {
    let l
    if (
      (Array.isArray(a)
        ? (l = a)
        : typeof a == 'string' && n.isDeepKey(a) && o?.[a] == null
          ? (l = i.toPath(a))
          : (l = [a]),
      l.length === 0)
    )
      return !1
    let c = o
    for (let u = 0; u < l.length; u++) {
      const f = l[u]
      if (
        (c == null || !Object.hasOwn(c, f)) &&
        !((Array.isArray(c) || r.isArguments(c)) && t.isIndex(f) && f < c.length)
      )
        return !1
      c = c[f]
    }
    return !0
  }
  e.has = s
})(C4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = D0(),
    t = Lf,
    r = _4,
    i = jf,
    s = C4
  function o(a, l) {
    switch (typeof a) {
      case 'object': {
        Object.is(a?.valueOf(), -0) && (a = '-0')
        break
      }
      case 'number': {
        a = t.toKey(a)
        break
      }
    }
    return (
      (l = r.cloneDeep(l)),
      function (c) {
        const u = i.get(c, a)
        return u === void 0 ? s.has(c, a) : l === void 0 ? u === void 0 : n.isMatch(u, l)
      }
    )
  }
  e.matchesProperty = o
})(S4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = O0,
    t = y4,
    r = b4,
    i = S4
  function s(o) {
    if (o == null) return n.identity
    switch (typeof o) {
      case 'function':
        return o
      case 'object':
        return Array.isArray(o) && o.length === 2 ? i.matchesProperty(o[0], o[1]) : r.matches(o)
      case 'string':
      case 'symbol':
      case 'number':
        return t.property(o)
    }
  }
  e.iteratee = s
})(g4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = d4,
    t = O0,
    r = h4,
    i = g4
  function s(o, a = t.identity) {
    return r.isArrayLikeObject(o) ? n.uniqBy(Array.from(o), i.iteratee(a)) : []
  }
  e.uniqBy = s
})(f4)
var zj = f4.uniqBy
const ZZ = kr(zj)
function $j(e, n = `expected a function, instead received ${typeof e}`) {
  if (typeof e != 'function') throw new TypeError(n)
}
function Vj(e, n = `expected an object, instead received ${typeof e}`) {
  if (typeof e != 'object') throw new TypeError(n)
}
function Hj(e, n = 'expected all items to be functions, instead received the following types: ') {
  if (!e.every((t) => typeof t == 'function')) {
    const t = e
      .map((r) => (typeof r == 'function' ? `function ${r.name || 'unnamed'}()` : typeof r))
      .join(', ')
    throw new TypeError(`${n}[${t}]`)
  }
}
var kb = (e) => (Array.isArray(e) ? e : [e])
function Uj(e) {
  const n = Array.isArray(e[0]) ? e[0] : e
  return (
    Hj(
      n,
      'createSelector expects all input-selectors to be functions, but received the following types: ',
    ),
    n
  )
}
function qj(e, n) {
  const t = [],
    { length: r } = e
  for (let i = 0; i < r; i++) t.push(e[i].apply(null, n))
  return t
}
var Wj = class {
    constructor(e) {
      this.value = e
    }
    deref() {
      return this.value
    }
  },
  Kj = typeof WeakRef < 'u' ? WeakRef : Wj,
  Gj = 0,
  Cb = 1
function dc() {
  return { s: Gj, v: void 0, o: null, p: null }
}
function E4(e, n = {}) {
  let t = dc()
  const { resultEqualityCheck: r } = n
  let i,
    s = 0
  function o() {
    let a = t
    const { length: l } = arguments
    for (let f = 0, d = l; f < d; f++) {
      const h = arguments[f]
      if (typeof h == 'function' || (typeof h == 'object' && h !== null)) {
        let p = a.o
        p === null && (a.o = p = new WeakMap())
        const g = p.get(h)
        g === void 0 ? ((a = dc()), p.set(h, a)) : (a = g)
      } else {
        let p = a.p
        p === null && (a.p = p = new Map())
        const g = p.get(h)
        g === void 0 ? ((a = dc()), p.set(h, a)) : (a = g)
      }
    }
    const c = a
    let u
    if (a.s === Cb) u = a.v
    else if (((u = e.apply(null, arguments)), s++, r)) {
      const f = i?.deref?.() ?? i
      ;(f != null && r(f, u) && ((u = f), s !== 0 && s--),
        (i = (typeof u == 'object' && u !== null) || typeof u == 'function' ? new Kj(u) : u))
    }
    return ((c.s = Cb), (c.v = u), u)
  }
  return (
    (o.clearCache = () => {
      ;((t = dc()), o.resetResultsCount())
    }),
    (o.resultsCount = () => s),
    (o.resetResultsCount = () => {
      s = 0
    }),
    o
  )
}
function Xj(e, ...n) {
  const t = typeof e == 'function' ? { memoize: e, memoizeOptions: n } : e,
    r = (...i) => {
      let s = 0,
        o = 0,
        a,
        l = {},
        c = i.pop()
      ;(typeof c == 'object' && ((l = c), (c = i.pop())),
        $j(
          c,
          `createSelector expects an output function after the inputs, but received: [${typeof c}]`,
        ))
      const u = { ...t, ...l },
        { memoize: f, memoizeOptions: d = [], argsMemoize: h = E4, argsMemoizeOptions: p = [] } = u,
        g = kb(d),
        m = kb(p),
        y = Uj(i),
        b = f(
          function () {
            return (s++, c.apply(null, arguments))
          },
          ...g,
        ),
        w = h(
          function () {
            o++
            const T = qj(y, arguments)
            return ((a = b.apply(null, T)), a)
          },
          ...m,
        )
      return Object.assign(w, {
        resultFunc: c,
        memoizedResultFunc: b,
        dependencies: y,
        dependencyRecomputations: () => o,
        resetDependencyRecomputations: () => {
          o = 0
        },
        lastResult: () => a,
        recomputations: () => s,
        resetRecomputations: () => {
          s = 0
        },
        memoize: f,
        argsMemoize: h,
      })
    }
  return (Object.assign(r, { withTypes: () => r }), r)
}
var Yj = Xj(E4),
  Zj = Object.assign(
    (e, n = Yj) => {
      Vj(
        e,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`,
      )
      const t = Object.keys(e),
        r = t.map((s) => e[s])
      return n(r, (...s) => s.reduce((o, a, l) => ((o[t[l]] = a), o), {}))
    },
    { withTypes: () => Zj },
  ),
  T4 = {},
  A4 = {},
  R4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(r) {
    return typeof r == 'symbol' ? 1 : r === null ? 2 : r === void 0 ? 3 : r !== r ? 4 : 0
  }
  const t = (r, i, s) => {
    if (r !== i) {
      const o = n(r),
        a = n(i)
      if (o === a && o === 0) {
        if (r < i) return s === 'desc' ? 1 : -1
        if (r > i) return s === 'desc' ? -1 : 1
      }
      return s === 'desc' ? a - o : o - a
    }
    return 0
  }
  e.compareValues = t
})(R4)
var O4 = {},
  z0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return typeof t == 'symbol' || t instanceof Symbol
  }
  e.isSymbol = n
})(z0)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = z0,
    t = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    r = /^\w*$/
  function i(s, o) {
    return Array.isArray(s)
      ? !1
      : typeof s == 'number' || typeof s == 'boolean' || s == null || n.isSymbol(s)
        ? !0
        : (typeof s == 'string' && (r.test(s) || !t.test(s))) || (o != null && Object.hasOwn(o, s))
  }
  e.isKey = i
})(O4)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = R4,
    t = O4,
    r = Ff
  function i(s, o, a, l) {
    if (s == null) return []
    ;((a = l ? void 0 : a),
      Array.isArray(s) || (s = Object.values(s)),
      Array.isArray(o) || (o = o == null ? [null] : [o]),
      o.length === 0 && (o = [null]),
      Array.isArray(a) || (a = a == null ? [] : [a]),
      (a = a.map((h) => String(h))))
    const c = (h, p) => {
        let g = h
        for (let m = 0; m < p.length && g != null; ++m) g = g[p[m]]
        return g
      },
      u = (h, p) =>
        p == null || h == null
          ? p
          : typeof h == 'object' && 'key' in h
            ? Object.hasOwn(p, h.key)
              ? p[h.key]
              : c(p, h.path)
            : typeof h == 'function'
              ? h(p)
              : Array.isArray(h)
                ? c(p, h)
                : typeof p == 'object'
                  ? p[h]
                  : p,
      f = o.map(
        (h) => (
          Array.isArray(h) && h.length === 1 && (h = h[0]),
          h == null || typeof h == 'function' || Array.isArray(h) || t.isKey(h)
            ? h
            : { key: h, path: r.toPath(h) }
        ),
      )
    return s
      .map((h) => ({ original: h, criteria: f.map((p) => u(p, h)) }))
      .slice()
      .sort((h, p) => {
        for (let g = 0; g < f.length; g++) {
          const m = n.compareValues(h.criteria[g], p.criteria[g], a[g])
          if (m !== 0) return m
        }
        return 0
      })
      .map((h) => h.original)
  }
  e.orderBy = i
})(A4)
var P4 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t, r = 1) {
    const i = [],
      s = Math.floor(r),
      o = (a, l) => {
        for (let c = 0; c < a.length; c++) {
          const u = a[c]
          Array.isArray(u) && l < s ? o(u, l + 1) : i.push(u)
        }
      }
    return (o(t, 0), i)
  }
  e.flatten = n
})(P4)
var $0 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = B0,
    t = Bf,
    r = P0,
    i = I0
  function s(o, a, l) {
    return r.isObject(l) &&
      ((typeof a == 'number' && t.isArrayLike(l) && n.isIndex(a) && a < l.length) ||
        (typeof a == 'string' && a in l))
      ? i.eq(l[a], o)
      : !1
  }
  e.isIterateeCall = s
})($0)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = A4,
    t = P4,
    r = $0
  function i(s, ...o) {
    const a = o.length
    return (
      a > 1 && r.isIterateeCall(s, o[0], o[1])
        ? (o = [])
        : a > 2 && r.isIterateeCall(o[0], o[1], o[2]) && (o = [o[0]]),
      n.orderBy(s, t.flatten(o), ['asc'])
    )
  }
  e.sortBy = i
})(T4)
var Jj = T4.sortBy
const JZ = kr(Jj)
function gn(e) {
  return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
}
var Qj = (typeof Symbol == 'function' && Symbol.observable) || '@@observable',
  Mb = Qj,
  Xd = () => Math.random().toString(36).substring(7).split('').join('.'),
  tL = {
    INIT: `@@redux/INIT${Xd()}`,
    REPLACE: `@@redux/REPLACE${Xd()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${Xd()}`,
  },
  yu = tL
function V0(e) {
  if (typeof e != 'object' || e === null) return !1
  let n = e
  for (; Object.getPrototypeOf(n) !== null; ) n = Object.getPrototypeOf(n)
  return Object.getPrototypeOf(e) === n || Object.getPrototypeOf(e) === null
}
function N4(e, n, t) {
  if (typeof e != 'function') throw new Error(gn(2))
  if (
    (typeof n == 'function' && typeof t == 'function') ||
    (typeof t == 'function' && typeof arguments[3] == 'function')
  )
    throw new Error(gn(0))
  if ((typeof n == 'function' && typeof t > 'u' && ((t = n), (n = void 0)), typeof t < 'u')) {
    if (typeof t != 'function') throw new Error(gn(1))
    return t(N4)(e, n)
  }
  let r = e,
    i = n,
    s = new Map(),
    o = s,
    a = 0,
    l = !1
  function c() {
    o === s &&
      ((o = new Map()),
      s.forEach((m, y) => {
        o.set(y, m)
      }))
  }
  function u() {
    if (l) throw new Error(gn(3))
    return i
  }
  function f(m) {
    if (typeof m != 'function') throw new Error(gn(4))
    if (l) throw new Error(gn(5))
    let y = !0
    c()
    const b = a++
    return (
      o.set(b, m),
      function () {
        if (y) {
          if (l) throw new Error(gn(6))
          ;((y = !1), c(), o.delete(b), (s = null))
        }
      }
    )
  }
  function d(m) {
    if (!V0(m)) throw new Error(gn(7))
    if (typeof m.type > 'u') throw new Error(gn(8))
    if (typeof m.type != 'string') throw new Error(gn(17))
    if (l) throw new Error(gn(9))
    try {
      ;((l = !0), (i = r(i, m)))
    } finally {
      l = !1
    }
    return (
      (s = o).forEach((b) => {
        b()
      }),
      m
    )
  }
  function h(m) {
    if (typeof m != 'function') throw new Error(gn(10))
    ;((r = m), d({ type: yu.REPLACE }))
  }
  function p() {
    const m = f
    return {
      subscribe(y) {
        if (typeof y != 'object' || y === null) throw new Error(gn(11))
        function b() {
          const C = y
          C.next && C.next(u())
        }
        return (b(), { unsubscribe: m(b) })
      },
      [Mb]() {
        return this
      },
    }
  }
  return (
    d({ type: yu.INIT }),
    { dispatch: d, subscribe: f, getState: u, replaceReducer: h, [Mb]: p }
  )
}
function eL(e) {
  Object.keys(e).forEach((n) => {
    const t = e[n]
    if (typeof t(void 0, { type: yu.INIT }) > 'u') throw new Error(gn(12))
    if (typeof t(void 0, { type: yu.PROBE_UNKNOWN_ACTION() }) > 'u') throw new Error(gn(13))
  })
}
function nL(e) {
  const n = Object.keys(e),
    t = {}
  for (let s = 0; s < n.length; s++) {
    const o = n[s]
    typeof e[o] == 'function' && (t[o] = e[o])
  }
  const r = Object.keys(t)
  let i
  try {
    eL(t)
  } catch (s) {
    i = s
  }
  return function (o = {}, a) {
    if (i) throw i
    let l = !1
    const c = {}
    for (let u = 0; u < r.length; u++) {
      const f = r[u],
        d = t[f],
        h = o[f],
        p = d(h, a)
      if (typeof p > 'u') throw (a && a.type, new Error(gn(14)))
      ;((c[f] = p), (l = l || p !== h))
    }
    return ((l = l || r.length !== Object.keys(o).length), l ? c : o)
  }
}
function bu(...e) {
  return e.length === 0
    ? (n) => n
    : e.length === 1
      ? e[0]
      : e.reduce(
          (n, t) =>
            (...r) =>
              n(t(...r)),
        )
}
function rL(...e) {
  return (n) => (t, r) => {
    const i = n(t, r)
    let s = () => {
      throw new Error(gn(15))
    }
    const o = { getState: i.getState, dispatch: (l, ...c) => s(l, ...c) },
      a = e.map((l) => l(o))
    return ((s = bu(...a)(i.dispatch)), { ...i, dispatch: s })
  }
}
function I4(e) {
  return V0(e) && 'type' in e && typeof e.type == 'string'
}
var D4 = Symbol.for('immer-nothing'),
  Eb = Symbol.for('immer-draftable'),
  Kn = Symbol.for('immer-state')
function mr(e, ...n) {
  throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)
}
var jo = Object.getPrototypeOf
function Ns(e) {
  return !!e && !!e[Kn]
}
function si(e) {
  return e ? j4(e) || Array.isArray(e) || !!e[Eb] || !!e.constructor?.[Eb] || Nl(e) || $f(e) : !1
}
var iL = Object.prototype.constructor.toString()
function j4(e) {
  if (!e || typeof e != 'object') return !1
  const n = jo(e)
  if (n === null) return !0
  const t = Object.hasOwnProperty.call(n, 'constructor') && n.constructor
  return t === Object ? !0 : typeof t == 'function' && Function.toString.call(t) === iL
}
function vu(e, n) {
  zf(e) === 0
    ? Reflect.ownKeys(e).forEach((t) => {
        n(t, e[t], e)
      })
    : e.forEach((t, r) => n(r, t, e))
}
function zf(e) {
  const n = e[Kn]
  return n ? n.type_ : Array.isArray(e) ? 1 : Nl(e) ? 2 : $f(e) ? 3 : 0
}
function Rp(e, n) {
  return zf(e) === 2 ? e.has(n) : Object.prototype.hasOwnProperty.call(e, n)
}
function L4(e, n, t) {
  const r = zf(e)
  r === 2 ? e.set(n, t) : r === 3 ? e.add(t) : (e[n] = t)
}
function sL(e, n) {
  return e === n ? e !== 0 || 1 / e === 1 / n : e !== e && n !== n
}
function Nl(e) {
  return e instanceof Map
}
function $f(e) {
  return e instanceof Set
}
function rs(e) {
  return e.copy_ || e.base_
}
function Op(e, n) {
  if (Nl(e)) return new Map(e)
  if ($f(e)) return new Set(e)
  if (Array.isArray(e)) return Array.prototype.slice.call(e)
  const t = j4(e)
  if (n === !0 || (n === 'class_only' && !t)) {
    const r = Object.getOwnPropertyDescriptors(e)
    delete r[Kn]
    let i = Reflect.ownKeys(r)
    for (let s = 0; s < i.length; s++) {
      const o = i[s],
        a = r[o]
      ;(a.writable === !1 && ((a.writable = !0), (a.configurable = !0)),
        (a.get || a.set) &&
          (r[o] = { configurable: !0, writable: !0, enumerable: a.enumerable, value: e[o] }))
    }
    return Object.create(jo(e), r)
  } else {
    const r = jo(e)
    if (r !== null && t) return { ...e }
    const i = Object.create(r)
    return Object.assign(i, e)
  }
}
function H0(e, n = !1) {
  return (
    Vf(e) ||
      Ns(e) ||
      !si(e) ||
      (zf(e) > 1 &&
        Object.defineProperties(e, {
          set: { value: hc },
          add: { value: hc },
          clear: { value: hc },
          delete: { value: hc },
        }),
      Object.freeze(e),
      n && Object.values(e).forEach((t) => H0(t, !0))),
    e
  )
}
function hc() {
  mr(2)
}
function Vf(e) {
  return Object.isFrozen(e)
}
var oL = {}
function Is(e) {
  const n = oL[e]
  return (n || mr(0, e), n)
}
var al
function F4() {
  return al
}
function aL(e, n) {
  return { drafts_: [], parent_: e, immer_: n, canAutoFreeze_: !0, unfinalizedDrafts_: 0 }
}
function Tb(e, n) {
  n && (Is('Patches'), (e.patches_ = []), (e.inversePatches_ = []), (e.patchListener_ = n))
}
function Pp(e) {
  ;(Np(e), e.drafts_.forEach(lL), (e.drafts_ = null))
}
function Np(e) {
  e === al && (al = e.parent_)
}
function Ab(e) {
  return (al = aL(al, e))
}
function lL(e) {
  const n = e[Kn]
  n.type_ === 0 || n.type_ === 1 ? n.revoke_() : (n.revoked_ = !0)
}
function Rb(e, n) {
  n.unfinalizedDrafts_ = n.drafts_.length
  const t = n.drafts_[0]
  return (
    e !== void 0 && e !== t
      ? (t[Kn].modified_ && (Pp(n), mr(4)),
        si(e) && ((e = wu(n, e)), n.parent_ || xu(n, e)),
        n.patches_ &&
          Is('Patches').generateReplacementPatches_(t[Kn].base_, e, n.patches_, n.inversePatches_))
      : (e = wu(n, t, [])),
    Pp(n),
    n.patches_ && n.patchListener_(n.patches_, n.inversePatches_),
    e !== D4 ? e : void 0
  )
}
function wu(e, n, t) {
  if (Vf(n)) return n
  const r = n[Kn]
  if (!r) return (vu(n, (i, s) => Ob(e, r, n, i, s, t)), n)
  if (r.scope_ !== e) return n
  if (!r.modified_) return (xu(e, r.base_, !0), r.base_)
  if (!r.finalized_) {
    ;((r.finalized_ = !0), r.scope_.unfinalizedDrafts_--)
    const i = r.copy_
    let s = i,
      o = !1
    ;(r.type_ === 3 && ((s = new Set(i)), i.clear(), (o = !0)),
      vu(s, (a, l) => Ob(e, r, i, a, l, t, o)),
      xu(e, i, !1),
      t && e.patches_ && Is('Patches').generatePatches_(r, t, e.patches_, e.inversePatches_))
  }
  return r.copy_
}
function Ob(e, n, t, r, i, s, o) {
  if (Ns(i)) {
    const a = s && n && n.type_ !== 3 && !Rp(n.assigned_, r) ? s.concat(r) : void 0,
      l = wu(e, i, a)
    if ((L4(t, r, l), Ns(l))) e.canAutoFreeze_ = !1
    else return
  } else o && t.add(i)
  if (si(i) && !Vf(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return
    ;(wu(e, i),
      (!n || !n.scope_.parent_) &&
        typeof r != 'symbol' &&
        (Nl(t) ? t.has(r) : Object.prototype.propertyIsEnumerable.call(t, r)) &&
        xu(e, i))
  }
}
function xu(e, n, t = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && H0(n, t)
}
function cL(e, n) {
  const t = Array.isArray(e),
    r = {
      type_: t ? 1 : 0,
      scope_: n ? n.scope_ : F4(),
      modified_: !1,
      finalized_: !1,
      assigned_: {},
      parent_: n,
      base_: e,
      draft_: null,
      copy_: null,
      revoke_: null,
      isManual_: !1,
    }
  let i = r,
    s = U0
  t && ((i = [r]), (s = ll))
  const { revoke: o, proxy: a } = Proxy.revocable(i, s)
  return ((r.draft_ = a), (r.revoke_ = o), a)
}
var U0 = {
    get(e, n) {
      if (n === Kn) return e
      const t = rs(e)
      if (!Rp(t, n)) return uL(e, t, n)
      const r = t[n]
      return e.finalized_ || !si(r)
        ? r
        : r === Yd(e.base_, n)
          ? (Zd(e), (e.copy_[n] = Dp(r, e)))
          : r
    },
    has(e, n) {
      return n in rs(e)
    },
    ownKeys(e) {
      return Reflect.ownKeys(rs(e))
    },
    set(e, n, t) {
      const r = B4(rs(e), n)
      if (r?.set) return (r.set.call(e.draft_, t), !0)
      if (!e.modified_) {
        const i = Yd(rs(e), n),
          s = i?.[Kn]
        if (s && s.base_ === t) return ((e.copy_[n] = t), (e.assigned_[n] = !1), !0)
        if (sL(t, i) && (t !== void 0 || Rp(e.base_, n))) return !0
        ;(Zd(e), Ip(e))
      }
      return (
        (e.copy_[n] === t && (t !== void 0 || n in e.copy_)) ||
          (Number.isNaN(t) && Number.isNaN(e.copy_[n])) ||
          ((e.copy_[n] = t), (e.assigned_[n] = !0)),
        !0
      )
    },
    deleteProperty(e, n) {
      return (
        Yd(e.base_, n) !== void 0 || n in e.base_
          ? ((e.assigned_[n] = !1), Zd(e), Ip(e))
          : delete e.assigned_[n],
        e.copy_ && delete e.copy_[n],
        !0
      )
    },
    getOwnPropertyDescriptor(e, n) {
      const t = rs(e),
        r = Reflect.getOwnPropertyDescriptor(t, n)
      return (
        r && {
          writable: !0,
          configurable: e.type_ !== 1 || n !== 'length',
          enumerable: r.enumerable,
          value: t[n],
        }
      )
    },
    defineProperty() {
      mr(11)
    },
    getPrototypeOf(e) {
      return jo(e.base_)
    },
    setPrototypeOf() {
      mr(12)
    },
  },
  ll = {}
vu(U0, (e, n) => {
  ll[e] = function () {
    return ((arguments[0] = arguments[0][0]), n.apply(this, arguments))
  }
})
ll.deleteProperty = function (e, n) {
  return ll.set.call(this, e, n, void 0)
}
ll.set = function (e, n, t) {
  return U0.set.call(this, e[0], n, t, e[0])
}
function Yd(e, n) {
  const t = e[Kn]
  return (t ? rs(t) : e)[n]
}
function uL(e, n, t) {
  const r = B4(n, t)
  return r ? ('value' in r ? r.value : r.get?.call(e.draft_)) : void 0
}
function B4(e, n) {
  if (!(n in e)) return
  let t = jo(e)
  for (; t; ) {
    const r = Object.getOwnPropertyDescriptor(t, n)
    if (r) return r
    t = jo(t)
  }
}
function Ip(e) {
  e.modified_ || ((e.modified_ = !0), e.parent_ && Ip(e.parent_))
}
function Zd(e) {
  e.copy_ || (e.copy_ = Op(e.base_, e.scope_.immer_.useStrictShallowCopy_))
}
var fL = class {
  constructor(e) {
    ;((this.autoFreeze_ = !0),
      (this.useStrictShallowCopy_ = !1),
      (this.produce = (n, t, r) => {
        if (typeof n == 'function' && typeof t != 'function') {
          const s = t
          t = n
          const o = this
          return function (l = s, ...c) {
            return o.produce(l, (u) => t.call(this, u, ...c))
          }
        }
        ;(typeof t != 'function' && mr(6), r !== void 0 && typeof r != 'function' && mr(7))
        let i
        if (si(n)) {
          const s = Ab(this),
            o = Dp(n, void 0)
          let a = !0
          try {
            ;((i = t(o)), (a = !1))
          } finally {
            a ? Pp(s) : Np(s)
          }
          return (Tb(s, r), Rb(i, s))
        } else if (!n || typeof n != 'object') {
          if (
            ((i = t(n)),
            i === void 0 && (i = n),
            i === D4 && (i = void 0),
            this.autoFreeze_ && H0(i, !0),
            r)
          ) {
            const s = [],
              o = []
            ;(Is('Patches').generateReplacementPatches_(n, i, s, o), r(s, o))
          }
          return i
        } else mr(1, n)
      }),
      (this.produceWithPatches = (n, t) => {
        if (typeof n == 'function')
          return (o, ...a) => this.produceWithPatches(o, (l) => n(l, ...a))
        let r, i
        return [
          this.produce(n, t, (o, a) => {
            ;((r = o), (i = a))
          }),
          r,
          i,
        ]
      }),
      typeof e?.autoFreeze == 'boolean' && this.setAutoFreeze(e.autoFreeze),
      typeof e?.useStrictShallowCopy == 'boolean' &&
        this.setUseStrictShallowCopy(e.useStrictShallowCopy))
  }
  createDraft(e) {
    ;(si(e) || mr(8), Ns(e) && (e = dL(e)))
    const n = Ab(this),
      t = Dp(e, void 0)
    return ((t[Kn].isManual_ = !0), Np(n), t)
  }
  finishDraft(e, n) {
    const t = e && e[Kn]
    ;(!t || !t.isManual_) && mr(9)
    const { scope_: r } = t
    return (Tb(r, n), Rb(void 0, r))
  }
  setAutoFreeze(e) {
    this.autoFreeze_ = e
  }
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e
  }
  applyPatches(e, n) {
    let t
    for (t = n.length - 1; t >= 0; t--) {
      const i = n[t]
      if (i.path.length === 0 && i.op === 'replace') {
        e = i.value
        break
      }
    }
    t > -1 && (n = n.slice(t + 1))
    const r = Is('Patches').applyPatches_
    return Ns(e) ? r(e, n) : this.produce(e, (i) => r(i, n))
  }
}
function Dp(e, n) {
  const t = Nl(e) ? Is('MapSet').proxyMap_(e, n) : $f(e) ? Is('MapSet').proxySet_(e, n) : cL(e, n)
  return ((n ? n.scope_ : F4()).drafts_.push(t), t)
}
function dL(e) {
  return (Ns(e) || mr(10, e), z4(e))
}
function z4(e) {
  if (!si(e) || Vf(e)) return e
  const n = e[Kn]
  let t
  if (n) {
    if (!n.modified_) return n.base_
    ;((n.finalized_ = !0), (t = Op(e, n.scope_.immer_.useStrictShallowCopy_)))
  } else t = Op(e, !0)
  return (
    vu(t, (r, i) => {
      L4(t, r, z4(i))
    }),
    n && (n.finalized_ = !1),
    t
  )
}
var hL = new fL(),
  $4 = hL.produce
function QZ(e) {
  return e
}
function V4(e) {
  return ({ dispatch: t, getState: r }) =>
    (i) =>
    (s) =>
      typeof s == 'function' ? s(t, r, e) : i(s)
}
var pL = V4(),
  mL = V4,
  gL =
    typeof window < 'u' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == 'object' ? bu : bu.apply(null, arguments)
        }
function Lo(e, n) {
  function t(...r) {
    if (n) {
      let i = n(...r)
      if (!i) throw new Error(Un(0))
      return {
        type: e,
        payload: i.payload,
        ...('meta' in i && { meta: i.meta }),
        ...('error' in i && { error: i.error }),
      }
    }
    return { type: e, payload: r[0] }
  }
  return ((t.toString = () => `${e}`), (t.type = e), (t.match = (r) => I4(r) && r.type === e), t)
}
var H4 = class va extends Array {
  constructor(...n) {
    ;(super(...n), Object.setPrototypeOf(this, va.prototype))
  }
  static get [Symbol.species]() {
    return va
  }
  concat(...n) {
    return super.concat.apply(this, n)
  }
  prepend(...n) {
    return n.length === 1 && Array.isArray(n[0])
      ? new va(...n[0].concat(this))
      : new va(...n.concat(this))
  }
}
function Pb(e) {
  return si(e) ? $4(e, () => {}) : e
}
function pc(e, n, t) {
  return e.has(n) ? e.get(n) : e.set(n, t(n)).get(n)
}
function yL(e) {
  return typeof e == 'boolean'
}
var bL = () =>
    function (n) {
      const {
        thunk: t = !0,
        immutableCheck: r = !0,
        serializableCheck: i = !0,
        actionCreatorCheck: s = !0,
      } = n ?? {}
      let o = new H4()
      return (t && (yL(t) ? o.push(pL) : o.push(mL(t.extraArgument))), o)
    },
  U4 = 'RTK_autoBatch',
  tJ = () => (e) => ({ payload: e, meta: { [U4]: !0 } }),
  Nb = (e) => (n) => {
    setTimeout(n, e)
  },
  vL =
    (e = { type: 'raf' }) =>
    (n) =>
    (...t) => {
      const r = n(...t)
      let i = !0,
        s = !1,
        o = !1
      const a = new Set(),
        l =
          e.type === 'tick'
            ? queueMicrotask
            : e.type === 'raf'
              ? typeof window < 'u' && window.requestAnimationFrame
                ? window.requestAnimationFrame
                : Nb(10)
              : e.type === 'callback'
                ? e.queueNotification
                : Nb(e.timeout),
        c = () => {
          ;((o = !1), s && ((s = !1), a.forEach((u) => u())))
        }
      return Object.assign({}, r, {
        subscribe(u) {
          const f = () => i && u(),
            d = r.subscribe(f)
          return (
            a.add(u),
            () => {
              ;(d(), a.delete(u))
            }
          )
        },
        dispatch(u) {
          try {
            return ((i = !u?.meta?.[U4]), (s = !i), s && (o || ((o = !0), l(c))), r.dispatch(u))
          } finally {
            i = !0
          }
        },
      })
    },
  wL = (e) =>
    function (t) {
      const { autoBatch: r = !0 } = t ?? {}
      let i = new H4(e)
      return (r && i.push(vL(typeof r == 'object' ? r : void 0)), i)
    }
function eJ(e) {
  const n = bL(),
    {
      reducer: t = void 0,
      middleware: r,
      devTools: i = !0,
      preloadedState: s = void 0,
      enhancers: o = void 0,
    } = e || {}
  let a
  if (typeof t == 'function') a = t
  else if (V0(t)) a = nL(t)
  else throw new Error(Un(1))
  let l
  typeof r == 'function' ? (l = r(n)) : (l = n())
  let c = bu
  i && (c = gL({ trace: !1, ...(typeof i == 'object' && i) }))
  const u = rL(...l),
    f = wL(u)
  let d = typeof o == 'function' ? o(f) : f()
  const h = c(...d)
  return N4(a, s, h)
}
function q4(e) {
  const n = {},
    t = []
  let r
  const i = {
    addCase(s, o) {
      const a = typeof s == 'string' ? s : s.type
      if (!a) throw new Error(Un(28))
      if (a in n) throw new Error(Un(29))
      return ((n[a] = o), i)
    },
    addAsyncThunk(s, o) {
      return (
        o.pending && (n[s.pending.type] = o.pending),
        o.rejected && (n[s.rejected.type] = o.rejected),
        o.fulfilled && (n[s.fulfilled.type] = o.fulfilled),
        o.settled && t.push({ matcher: s.settled, reducer: o.settled }),
        i
      )
    },
    addMatcher(s, o) {
      return (t.push({ matcher: s, reducer: o }), i)
    },
    addDefaultCase(s) {
      return ((r = s), i)
    },
  }
  return (e(i), [n, t, r])
}
function xL(e) {
  return typeof e == 'function'
}
function SL(e, n) {
  let [t, r, i] = q4(n),
    s
  if (xL(e)) s = () => Pb(e())
  else {
    const a = Pb(e)
    s = () => a
  }
  function o(a = s(), l) {
    let c = [t[l.type], ...r.filter(({ matcher: u }) => u(l)).map(({ reducer: u }) => u)]
    return (
      c.filter((u) => !!u).length === 0 && (c = [i]),
      c.reduce((u, f) => {
        if (f)
          if (Ns(u)) {
            const h = f(u, l)
            return h === void 0 ? u : h
          } else {
            if (si(u)) return $4(u, (d) => f(d, l))
            {
              const d = f(u, l)
              if (d === void 0) {
                if (u === null) return u
                throw Error('A case reducer on a non-draftable value must not return undefined')
              }
              return d
            }
          }
        return u
      }, a)
    )
  }
  return ((o.getInitialState = s), o)
}
var _L = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW',
  kL = (e = 21) => {
    let n = '',
      t = e
    for (; t--; ) n += _L[(Math.random() * 64) | 0]
    return n
  },
  CL = Symbol.for('rtk-slice-createasyncthunk')
function ML(e, n) {
  return `${e}/${n}`
}
function EL({ creators: e } = {}) {
  const n = e?.asyncThunk?.[CL]
  return function (r) {
    const { name: i, reducerPath: s = i } = r
    if (!i) throw new Error(Un(11))
    const o = (typeof r.reducers == 'function' ? r.reducers(AL()) : r.reducers) || {},
      a = Object.keys(o),
      l = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: [],
      },
      c = {
        addCase(w, C) {
          const T = typeof w == 'string' ? w : w.type
          if (!T) throw new Error(Un(12))
          if (T in l.sliceCaseReducersByType) throw new Error(Un(13))
          return ((l.sliceCaseReducersByType[T] = C), c)
        },
        addMatcher(w, C) {
          return (l.sliceMatchers.push({ matcher: w, reducer: C }), c)
        },
        exposeAction(w, C) {
          return ((l.actionCreators[w] = C), c)
        },
        exposeCaseReducer(w, C) {
          return ((l.sliceCaseReducersByName[w] = C), c)
        },
      }
    a.forEach((w) => {
      const C = o[w],
        T = { reducerName: w, type: ML(i, w), createNotation: typeof r.reducers == 'function' }
      OL(C) ? NL(T, C, c, n) : RL(T, C, c)
    })
    function u() {
      const [w = {}, C = [], T = void 0] =
          typeof r.extraReducers == 'function' ? q4(r.extraReducers) : [r.extraReducers],
        I = { ...w, ...l.sliceCaseReducersByType }
      return SL(r.initialState, (B) => {
        for (let E in I) B.addCase(E, I[E])
        for (let E of l.sliceMatchers) B.addMatcher(E.matcher, E.reducer)
        for (let E of C) B.addMatcher(E.matcher, E.reducer)
        T && B.addDefaultCase(T)
      })
    }
    const f = (w) => w,
      d = new Map(),
      h = new WeakMap()
    let p
    function g(w, C) {
      return (p || (p = u()), p(w, C))
    }
    function m() {
      return (p || (p = u()), p.getInitialState())
    }
    function y(w, C = !1) {
      function T(B) {
        let E = B[w]
        return (typeof E > 'u' && C && (E = pc(h, T, m)), E)
      }
      function I(B = f) {
        const E = pc(d, C, () => new WeakMap())
        return pc(E, B, () => {
          const O = {}
          for (const [P, $] of Object.entries(r.selectors ?? {}))
            O[P] = TL($, B, () => pc(h, B, m), C)
          return O
        })
      }
      return {
        reducerPath: w,
        getSelectors: I,
        get selectors() {
          return I(T)
        },
        selectSlice: T,
      }
    }
    const b = {
      name: i,
      reducer: g,
      actions: l.actionCreators,
      caseReducers: l.sliceCaseReducersByName,
      getInitialState: m,
      ...y(s),
      injectInto(w, { reducerPath: C, ...T } = {}) {
        const I = C ?? s
        return (w.inject({ reducerPath: I, reducer: g }, T), { ...b, ...y(I, !0) })
      },
    }
    return b
  }
}
function TL(e, n, t, r) {
  function i(s, ...o) {
    let a = n(s)
    return (typeof a > 'u' && r && (a = t()), e(a, ...o))
  }
  return ((i.unwrapped = e), i)
}
var nJ = EL()
function AL() {
  function e(n, t) {
    return { _reducerDefinitionType: 'asyncThunk', payloadCreator: n, ...t }
  }
  return (
    (e.withTypes = () => e),
    {
      reducer(n) {
        return Object.assign(
          {
            [n.name](...t) {
              return n(...t)
            },
          }[n.name],
          { _reducerDefinitionType: 'reducer' },
        )
      },
      preparedReducer(n, t) {
        return { _reducerDefinitionType: 'reducerWithPrepare', prepare: n, reducer: t }
      },
      asyncThunk: e,
    }
  )
}
function RL({ type: e, reducerName: n, createNotation: t }, r, i) {
  let s, o
  if ('reducer' in r) {
    if (t && !PL(r)) throw new Error(Un(17))
    ;((s = r.reducer), (o = r.prepare))
  } else s = r
  i.addCase(e, s)
    .exposeCaseReducer(n, s)
    .exposeAction(n, o ? Lo(e, o) : Lo(e))
}
function OL(e) {
  return e._reducerDefinitionType === 'asyncThunk'
}
function PL(e) {
  return e._reducerDefinitionType === 'reducerWithPrepare'
}
function NL({ type: e, reducerName: n }, t, r, i) {
  if (!i) throw new Error(Un(18))
  const { payloadCreator: s, fulfilled: o, pending: a, rejected: l, settled: c, options: u } = t,
    f = i(e, s, u)
  ;(r.exposeAction(n, f),
    o && r.addCase(f.fulfilled, o),
    a && r.addCase(f.pending, a),
    l && r.addCase(f.rejected, l),
    c && r.addMatcher(f.settled, c),
    r.exposeCaseReducer(n, {
      fulfilled: o || mc,
      pending: a || mc,
      rejected: l || mc,
      settled: c || mc,
    }))
}
function mc() {}
var IL = 'task',
  W4 = 'listener',
  K4 = 'completed',
  q0 = 'cancelled',
  DL = `task-${q0}`,
  jL = `task-${K4}`,
  jp = `${W4}-${q0}`,
  LL = `${W4}-${K4}`,
  Hf = class {
    constructor(e) {
      ;((this.code = e), (this.message = `${IL} ${q0} (reason: ${e})`))
    }
    name = 'TaskAbortError'
    message
  },
  W0 = (e, n) => {
    if (typeof e != 'function') throw new TypeError(Un(32))
  },
  Su = () => {},
  G4 = (e, n = Su) => (e.catch(n), e),
  X4 = (e, n) => (
    e.addEventListener('abort', n, { once: !0 }),
    () => e.removeEventListener('abort', n)
  ),
  ws = (e, n) => {
    const t = e.signal
    t.aborted ||
      ('reason' in t ||
        Object.defineProperty(t, 'reason', {
          enumerable: !0,
          value: n,
          configurable: !0,
          writable: !0,
        }),
      e.abort(n))
  },
  xs = (e) => {
    if (e.aborted) {
      const { reason: n } = e
      throw new Hf(n)
    }
  }
function Y4(e, n) {
  let t = Su
  return new Promise((r, i) => {
    const s = () => i(new Hf(e.reason))
    if (e.aborted) {
      s()
      return
    }
    ;((t = X4(e, s)), n.finally(() => t()).then(r, i))
  }).finally(() => {
    t = Su
  })
}
var FL = async (e, n) => {
    try {
      return (await Promise.resolve(), { status: 'ok', value: await e() })
    } catch (t) {
      return { status: t instanceof Hf ? 'cancelled' : 'rejected', error: t }
    } finally {
      n?.()
    }
  },
  _u = (e) => (n) => G4(Y4(e, n).then((t) => (xs(e), t))),
  Z4 = (e) => {
    const n = _u(e)
    return (t) => n(new Promise((r) => setTimeout(r, t)))
  },
  { assign: _o } = Object,
  Ib = {},
  Uf = 'listenerMiddleware',
  BL = (e, n) => {
    const t = (r) => X4(e, () => ws(r, e.reason))
    return (r, i) => {
      W0(r)
      const s = new AbortController()
      t(s)
      const o = FL(
        async () => {
          ;(xs(e), xs(s.signal))
          const a = await r({ pause: _u(s.signal), delay: Z4(s.signal), signal: s.signal })
          return (xs(s.signal), a)
        },
        () => ws(s, jL),
      )
      return (
        i?.autoJoin && n.push(o.catch(Su)),
        {
          result: _u(e)(o),
          cancel() {
            ws(s, DL)
          },
        }
      )
    }
  },
  zL = (e, n) => {
    const t = async (r, i) => {
      xs(n)
      let s = () => {}
      const a = [
        new Promise((l, c) => {
          let u = e({
            predicate: r,
            effect: (f, d) => {
              ;(d.unsubscribe(), l([f, d.getState(), d.getOriginalState()]))
            },
          })
          s = () => {
            ;(u(), c())
          }
        }),
      ]
      i != null && a.push(new Promise((l) => setTimeout(l, i, null)))
      try {
        const l = await Y4(n, Promise.race(a))
        return (xs(n), l)
      } finally {
        s()
      }
    }
    return (r, i) => G4(t(r, i))
  },
  J4 = (e) => {
    let { type: n, actionCreator: t, matcher: r, predicate: i, effect: s } = e
    if (n) i = Lo(n).match
    else if (t) ((n = t.type), (i = t.match))
    else if (r) i = r
    else if (!i) throw new Error(Un(21))
    return (W0(s), { predicate: i, type: n, effect: s })
  },
  Q4 = _o(
    (e) => {
      const { type: n, predicate: t, effect: r } = J4(e)
      return {
        id: kL(),
        effect: r,
        type: n,
        predicate: t,
        pending: new Set(),
        unsubscribe: () => {
          throw new Error(Un(22))
        },
      }
    },
    { withTypes: () => Q4 },
  ),
  Db = (e, n) => {
    const { type: t, effect: r, predicate: i } = J4(n)
    return Array.from(e.values()).find(
      (s) => (typeof t == 'string' ? s.type === t : s.predicate === i) && s.effect === r,
    )
  },
  Lp = (e) => {
    e.pending.forEach((n) => {
      ws(n, jp)
    })
  },
  $L = (e, n) => () => {
    for (const t of n.keys()) Lp(t)
    e.clear()
  },
  jb = (e, n, t) => {
    try {
      e(n, t)
    } catch (r) {
      setTimeout(() => {
        throw r
      }, 0)
    }
  },
  t6 = _o(Lo(`${Uf}/add`), { withTypes: () => t6 }),
  VL = Lo(`${Uf}/removeAll`),
  e6 = _o(Lo(`${Uf}/remove`), { withTypes: () => e6 }),
  HL = (...e) => {
    console.error(`${Uf}/error`, ...e)
  },
  rJ = (e = {}) => {
    const n = new Map(),
      t = new Map(),
      r = (h) => {
        const p = t.get(h) ?? 0
        t.set(h, p + 1)
      },
      i = (h) => {
        const p = t.get(h) ?? 1
        p === 1 ? t.delete(h) : t.set(h, p - 1)
      },
      { extra: s, onError: o = HL } = e
    W0(o)
    const a = (h) => (
        (h.unsubscribe = () => n.delete(h.id)),
        n.set(h.id, h),
        (p) => {
          ;(h.unsubscribe(), p?.cancelActive && Lp(h))
        }
      ),
      l = (h) => {
        const p = Db(n, h) ?? Q4(h)
        return a(p)
      }
    _o(l, { withTypes: () => l })
    const c = (h) => {
      const p = Db(n, h)
      return (p && (p.unsubscribe(), h.cancelActive && Lp(p)), !!p)
    }
    _o(c, { withTypes: () => c })
    const u = async (h, p, g, m) => {
        const y = new AbortController(),
          b = zL(l, y.signal),
          w = []
        try {
          ;(h.pending.add(y),
            r(h),
            await Promise.resolve(
              h.effect(
                p,
                _o({}, g, {
                  getOriginalState: m,
                  condition: (C, T) => b(C, T).then(Boolean),
                  take: b,
                  delay: Z4(y.signal),
                  pause: _u(y.signal),
                  extra: s,
                  signal: y.signal,
                  fork: BL(y.signal, w),
                  unsubscribe: h.unsubscribe,
                  subscribe: () => {
                    n.set(h.id, h)
                  },
                  cancelActiveListeners: () => {
                    h.pending.forEach((C, T, I) => {
                      C !== y && (ws(C, jp), I.delete(C))
                    })
                  },
                  cancel: () => {
                    ;(ws(y, jp), h.pending.delete(y))
                  },
                  throwIfCancelled: () => {
                    xs(y.signal)
                  },
                }),
              ),
            ))
        } catch (C) {
          C instanceof Hf || jb(o, C, { raisedBy: 'effect' })
        } finally {
          ;(await Promise.all(w), ws(y, LL), i(h), h.pending.delete(y))
        }
      },
      f = $L(n, t)
    return {
      middleware: (h) => (p) => (g) => {
        if (!I4(g)) return p(g)
        if (t6.match(g)) return l(g.payload)
        if (VL.match(g)) {
          f()
          return
        }
        if (e6.match(g)) return c(g.payload)
        let m = h.getState()
        const y = () => {
          if (m === Ib) throw new Error(Un(23))
          return m
        }
        let b
        try {
          if (((b = p(g)), n.size > 0)) {
            const w = h.getState(),
              C = Array.from(n.values())
            for (const T of C) {
              let I = !1
              try {
                I = T.predicate(g, w, m)
              } catch (B) {
                ;((I = !1), jb(o, B, { raisedBy: 'predicate' }))
              }
              I && u(T, g, h, y)
            }
          }
        } finally {
          m = Ib
        }
        return b
      },
      startListening: l,
      stopListening: c,
      clearListeners: f,
    }
  }
function Un(e) {
  return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
}
function iJ() {}
function sJ(e) {
  return e != null
}
var n6 = {},
  r6 = {},
  i6 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = z0
  function t(r) {
    return n.isSymbol(r) ? NaN : Number(r)
  }
  e.toNumber = t
})(i6)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = i6
  function t(r) {
    return r
      ? ((r = n.toNumber(r)),
        r === 1 / 0 || r === -1 / 0 ? (r < 0 ? -1 : 1) * Number.MAX_VALUE : r === r ? r : 0)
      : r === 0
        ? r
        : 0
  }
  e.toFinite = t
})(r6)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = $0,
    t = r6
  function r(i, s, o) {
    ;(o && typeof o != 'number' && n.isIterateeCall(i, s, o) && (s = o = void 0),
      (i = t.toFinite(i)),
      s === void 0 ? ((s = i), (i = 0)) : (s = t.toFinite(s)),
      (o = o === void 0 ? (i < s ? 1 : -1) : t.toFinite(o)))
    const a = Math.max(Math.ceil((s - i) / (o || 1)), 0),
      l = new Array(a)
    for (let c = 0; c < a; c++) ((l[c] = i), (i += o))
    return l
  }
  e.range = r
})(n6)
var UL = n6.range
const oJ = kr(UL)
class aJ extends Map {
  constructor(n, t = KL) {
    if (
      (super(),
      Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: t } }),
      n != null)
    )
      for (const [r, i] of n) this.set(r, i)
  }
  get(n) {
    return super.get(Lb(this, n))
  }
  has(n) {
    return super.has(Lb(this, n))
  }
  set(n, t) {
    return super.set(qL(this, n), t)
  }
  delete(n) {
    return super.delete(WL(this, n))
  }
}
function Lb({ _intern: e, _key: n }, t) {
  const r = n(t)
  return e.has(r) ? e.get(r) : t
}
function qL({ _intern: e, _key: n }, t) {
  const r = n(t)
  return e.has(r) ? e.get(r) : (e.set(r, t), t)
}
function WL({ _intern: e, _key: n }, t) {
  const r = n(t)
  return (e.has(r) && ((t = e.get(r)), e.delete(r)), t)
}
function KL(e) {
  return e !== null && typeof e == 'object' ? e.valueOf() : e
}
const lJ = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      scaleBand: K_,
      scaleDiverging: G_,
      scaleDivergingLog: X_,
      scaleDivergingPow: Y_,
      scaleDivergingSqrt: Z_,
      scaleDivergingSymlog: J_,
      scaleIdentity: Q_,
      scaleImplicit: tk,
      scaleLinear: ek,
      scaleLog: nk,
      scaleOrdinal: rk,
      scalePoint: ik,
      scalePow: sk,
      scaleQuantile: ok,
      scaleQuantize: ak,
      scaleRadial: lk,
      scaleSequential: ck,
      scaleSequentialLog: uk,
      scaleSequentialPow: fk,
      scaleSequentialQuantile: dk,
      scaleSequentialSqrt: hk,
      scaleSequentialSymlog: pk,
      scaleSqrt: mk,
      scaleSymlog: gk,
      scaleThreshold: yk,
      scaleTime: bk,
      scaleUtc: vk,
      tickFormat: wk,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
)
var ea = 1e9,
  GL = {
    precision: 20,
    rounding: 4,
    toExpNeg: -7,
    toExpPos: 21,
    LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286',
  },
  G0,
  Be = !0,
  ur = '[DecimalError] ',
  Ss = ur + 'Invalid argument: ',
  K0 = ur + 'Exponent out of range: ',
  na = Math.floor,
  is = Math.pow,
  XL = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
  $n,
  an = 1e7,
  je = 7,
  s6 = 9007199254740991,
  ku = na(s6 / je),
  Bt = {}
Bt.absoluteValue = Bt.abs = function () {
  var e = new this.constructor(this)
  return (e.s && (e.s = 1), e)
}
Bt.comparedTo = Bt.cmp = function (e) {
  var n,
    t,
    r,
    i,
    s = this
  if (((e = new s.constructor(e)), s.s !== e.s)) return s.s || -e.s
  if (s.e !== e.e) return (s.e > e.e) ^ (s.s < 0) ? 1 : -1
  for (r = s.d.length, i = e.d.length, n = 0, t = r < i ? r : i; n < t; ++n)
    if (s.d[n] !== e.d[n]) return (s.d[n] > e.d[n]) ^ (s.s < 0) ? 1 : -1
  return r === i ? 0 : (r > i) ^ (s.s < 0) ? 1 : -1
}
Bt.decimalPlaces = Bt.dp = function () {
  var e = this,
    n = e.d.length - 1,
    t = (n - e.e) * je
  if (((n = e.d[n]), n)) for (; n % 10 == 0; n /= 10) t--
  return t < 0 ? 0 : t
}
Bt.dividedBy = Bt.div = function (e) {
  return Jr(this, new this.constructor(e))
}
Bt.dividedToIntegerBy = Bt.idiv = function (e) {
  var n = this,
    t = n.constructor
  return Pe(Jr(n, new t(e), 0, 1), t.precision)
}
Bt.equals = Bt.eq = function (e) {
  return !this.cmp(e)
}
Bt.exponent = function () {
  return Qe(this)
}
Bt.greaterThan = Bt.gt = function (e) {
  return this.cmp(e) > 0
}
Bt.greaterThanOrEqualTo = Bt.gte = function (e) {
  return this.cmp(e) >= 0
}
Bt.isInteger = Bt.isint = function () {
  return this.e > this.d.length - 2
}
Bt.isNegative = Bt.isneg = function () {
  return this.s < 0
}
Bt.isPositive = Bt.ispos = function () {
  return this.s > 0
}
Bt.isZero = function () {
  return this.s === 0
}
Bt.lessThan = Bt.lt = function (e) {
  return this.cmp(e) < 0
}
Bt.lessThanOrEqualTo = Bt.lte = function (e) {
  return this.cmp(e) < 1
}
Bt.logarithm = Bt.log = function (e) {
  var n,
    t = this,
    r = t.constructor,
    i = r.precision,
    s = i + 5
  if (e === void 0) e = new r(10)
  else if (((e = new r(e)), e.s < 1 || e.eq($n))) throw Error(ur + 'NaN')
  if (t.s < 1) throw Error(ur + (t.s ? 'NaN' : '-Infinity'))
  return t.eq($n) ? new r(0) : ((Be = !1), (n = Jr(cl(t, s), cl(e, s), s)), (Be = !0), Pe(n, i))
}
Bt.minus = Bt.sub = function (e) {
  var n = this
  return ((e = new n.constructor(e)), n.s == e.s ? l6(n, e) : o6(n, ((e.s = -e.s), e)))
}
Bt.modulo = Bt.mod = function (e) {
  var n,
    t = this,
    r = t.constructor,
    i = r.precision
  if (((e = new r(e)), !e.s)) throw Error(ur + 'NaN')
  return t.s ? ((Be = !1), (n = Jr(t, e, 0, 1).times(e)), (Be = !0), t.minus(n)) : Pe(new r(t), i)
}
Bt.naturalExponential = Bt.exp = function () {
  return a6(this)
}
Bt.naturalLogarithm = Bt.ln = function () {
  return cl(this)
}
Bt.negated = Bt.neg = function () {
  var e = new this.constructor(this)
  return ((e.s = -e.s || 0), e)
}
Bt.plus = Bt.add = function (e) {
  var n = this
  return ((e = new n.constructor(e)), n.s == e.s ? o6(n, e) : l6(n, ((e.s = -e.s), e)))
}
Bt.precision = Bt.sd = function (e) {
  var n,
    t,
    r,
    i = this
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(Ss + e)
  if (((n = Qe(i) + 1), (r = i.d.length - 1), (t = r * je + 1), (r = i.d[r]), r)) {
    for (; r % 10 == 0; r /= 10) t--
    for (r = i.d[0]; r >= 10; r /= 10) t++
  }
  return e && n > t ? n : t
}
Bt.squareRoot = Bt.sqrt = function () {
  var e,
    n,
    t,
    r,
    i,
    s,
    o,
    a = this,
    l = a.constructor
  if (a.s < 1) {
    if (!a.s) return new l(0)
    throw Error(ur + 'NaN')
  }
  for (
    e = Qe(a),
      Be = !1,
      i = Math.sqrt(+a),
      i == 0 || i == 1 / 0
        ? ((n = Rr(a.d)),
          (n.length + e) % 2 == 0 && (n += '0'),
          (i = Math.sqrt(n)),
          (e = na((e + 1) / 2) - (e < 0 || e % 2)),
          i == 1 / 0
            ? (n = '5e' + e)
            : ((n = i.toExponential()), (n = n.slice(0, n.indexOf('e') + 1) + e)),
          (r = new l(n)))
        : (r = new l(i.toString())),
      t = l.precision,
      i = o = t + 3;
    ;

  )
    if (
      ((s = r),
      (r = s.plus(Jr(a, s, o + 2)).times(0.5)),
      Rr(s.d).slice(0, o) === (n = Rr(r.d)).slice(0, o))
    ) {
      if (((n = n.slice(o - 3, o + 1)), i == o && n == '4999')) {
        if ((Pe(s, t + 1, 0), s.times(s).eq(a))) {
          r = s
          break
        }
      } else if (n != '9999') break
      o += 4
    }
  return ((Be = !0), Pe(r, t))
}
Bt.times = Bt.mul = function (e) {
  var n,
    t,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u = this,
    f = u.constructor,
    d = u.d,
    h = (e = new f(e)).d
  if (!u.s || !e.s) return new f(0)
  for (
    e.s *= u.s,
      t = u.e + e.e,
      l = d.length,
      c = h.length,
      l < c && ((s = d), (d = h), (h = s), (o = l), (l = c), (c = o)),
      s = [],
      o = l + c,
      r = o;
    r--;

  )
    s.push(0)
  for (r = c; --r >= 0; ) {
    for (n = 0, i = l + r; i > r; )
      ((a = s[i] + h[r] * d[i - r - 1] + n), (s[i--] = a % an | 0), (n = (a / an) | 0))
    s[i] = (s[i] + n) % an | 0
  }
  for (; !s[--o]; ) s.pop()
  return (n ? ++t : s.shift(), (e.d = s), (e.e = t), Be ? Pe(e, f.precision) : e)
}
Bt.toDecimalPlaces = Bt.todp = function (e, n) {
  var t = this,
    r = t.constructor
  return (
    (t = new r(t)),
    e === void 0
      ? t
      : (jr(e, 0, ea), n === void 0 ? (n = r.rounding) : jr(n, 0, 8), Pe(t, e + Qe(t) + 1, n))
  )
}
Bt.toExponential = function (e, n) {
  var t,
    r = this,
    i = r.constructor
  return (
    e === void 0
      ? (t = Ds(r, !0))
      : (jr(e, 0, ea),
        n === void 0 ? (n = i.rounding) : jr(n, 0, 8),
        (r = Pe(new i(r), e + 1, n)),
        (t = Ds(r, !0, e + 1))),
    t
  )
}
Bt.toFixed = function (e, n) {
  var t,
    r,
    i = this,
    s = i.constructor
  return e === void 0
    ? Ds(i)
    : (jr(e, 0, ea),
      n === void 0 ? (n = s.rounding) : jr(n, 0, 8),
      (r = Pe(new s(i), e + Qe(i) + 1, n)),
      (t = Ds(r.abs(), !1, e + Qe(r) + 1)),
      i.isneg() && !i.isZero() ? '-' + t : t)
}
Bt.toInteger = Bt.toint = function () {
  var e = this,
    n = e.constructor
  return Pe(new n(e), Qe(e) + 1, n.rounding)
}
Bt.toNumber = function () {
  return +this
}
Bt.toPower = Bt.pow = function (e) {
  var n,
    t,
    r,
    i,
    s,
    o,
    a = this,
    l = a.constructor,
    c = 12,
    u = +(e = new l(e))
  if (!e.s) return new l($n)
  if (((a = new l(a)), !a.s)) {
    if (e.s < 1) throw Error(ur + 'Infinity')
    return a
  }
  if (a.eq($n)) return a
  if (((r = l.precision), e.eq($n))) return Pe(a, r)
  if (((n = e.e), (t = e.d.length - 1), (o = n >= t), (s = a.s), o)) {
    if ((t = u < 0 ? -u : u) <= s6) {
      for (
        i = new l($n), n = Math.ceil(r / je + 4), Be = !1;
        t % 2 && ((i = i.times(a)), Bb(i.d, n)), (t = na(t / 2)), t !== 0;

      )
        ((a = a.times(a)), Bb(a.d, n))
      return ((Be = !0), e.s < 0 ? new l($n).div(i) : Pe(i, r))
    }
  } else if (s < 0) throw Error(ur + 'NaN')
  return (
    (s = s < 0 && e.d[Math.max(n, t)] & 1 ? -1 : 1),
    (a.s = 1),
    (Be = !1),
    (i = e.times(cl(a, r + c))),
    (Be = !0),
    (i = a6(i)),
    (i.s = s),
    i
  )
}
Bt.toPrecision = function (e, n) {
  var t,
    r,
    i = this,
    s = i.constructor
  return (
    e === void 0
      ? ((t = Qe(i)), (r = Ds(i, t <= s.toExpNeg || t >= s.toExpPos)))
      : (jr(e, 1, ea),
        n === void 0 ? (n = s.rounding) : jr(n, 0, 8),
        (i = Pe(new s(i), e, n)),
        (t = Qe(i)),
        (r = Ds(i, e <= t || t <= s.toExpNeg, e))),
    r
  )
}
Bt.toSignificantDigits = Bt.tosd = function (e, n) {
  var t = this,
    r = t.constructor
  return (
    e === void 0
      ? ((e = r.precision), (n = r.rounding))
      : (jr(e, 1, ea), n === void 0 ? (n = r.rounding) : jr(n, 0, 8)),
    Pe(new r(t), e, n)
  )
}
Bt.toString =
  Bt.valueOf =
  Bt.val =
  Bt.toJSON =
  Bt[Symbol.for('nodejs.util.inspect.custom')] =
    function () {
      var e = this,
        n = Qe(e),
        t = e.constructor
      return Ds(e, n <= t.toExpNeg || n >= t.toExpPos)
    }
function o6(e, n) {
  var t,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u = e.constructor,
    f = u.precision
  if (!e.s || !n.s) return (n.s || (n = new u(e)), Be ? Pe(n, f) : n)
  if (((l = e.d), (c = n.d), (o = e.e), (i = n.e), (l = l.slice()), (s = o - i), s)) {
    for (
      s < 0 ? ((r = l), (s = -s), (a = c.length)) : ((r = c), (i = o), (a = l.length)),
        o = Math.ceil(f / je),
        a = o > a ? o + 1 : a + 1,
        s > a && ((s = a), (r.length = 1)),
        r.reverse();
      s--;

    )
      r.push(0)
    r.reverse()
  }
  for (a = l.length, s = c.length, a - s < 0 && ((s = a), (r = c), (c = l), (l = r)), t = 0; s; )
    ((t = ((l[--s] = l[s] + c[s] + t) / an) | 0), (l[s] %= an))
  for (t && (l.unshift(t), ++i), a = l.length; l[--a] == 0; ) l.pop()
  return ((n.d = l), (n.e = i), Be ? Pe(n, f) : n)
}
function jr(e, n, t) {
  if (e !== ~~e || e < n || e > t) throw Error(Ss + e)
}
function Rr(e) {
  var n,
    t,
    r,
    i = e.length - 1,
    s = '',
    o = e[0]
  if (i > 0) {
    for (s += o, n = 1; n < i; n++)
      ((r = e[n] + ''), (t = je - r.length), t && (s += bi(t)), (s += r))
    ;((o = e[n]), (r = o + ''), (t = je - r.length), t && (s += bi(t)))
  } else if (o === 0) return '0'
  for (; o % 10 === 0; ) o /= 10
  return s + o
}
var Jr = (function () {
  function e(r, i) {
    var s,
      o = 0,
      a = r.length
    for (r = r.slice(); a--; ) ((s = r[a] * i + o), (r[a] = s % an | 0), (o = (s / an) | 0))
    return (o && r.unshift(o), r)
  }
  function n(r, i, s, o) {
    var a, l
    if (s != o) l = s > o ? 1 : -1
    else
      for (a = l = 0; a < s; a++)
        if (r[a] != i[a]) {
          l = r[a] > i[a] ? 1 : -1
          break
        }
    return l
  }
  function t(r, i, s) {
    for (var o = 0; s--; ) ((r[s] -= o), (o = r[s] < i[s] ? 1 : 0), (r[s] = o * an + r[s] - i[s]))
    for (; !r[0] && r.length > 1; ) r.shift()
  }
  return function (r, i, s, o) {
    var a,
      l,
      c,
      u,
      f,
      d,
      h,
      p,
      g,
      m,
      y,
      b,
      w,
      C,
      T,
      I,
      B,
      E,
      O = r.constructor,
      P = r.s == i.s ? 1 : -1,
      $ = r.d,
      F = i.d
    if (!r.s) return new O(r)
    if (!i.s) throw Error(ur + 'Division by zero')
    for (
      l = r.e - i.e, B = F.length, T = $.length, h = new O(P), p = h.d = [], c = 0;
      F[c] == ($[c] || 0);

    )
      ++c
    if (
      (F[c] > ($[c] || 0) && --l,
      s == null ? (b = s = O.precision) : o ? (b = s + (Qe(r) - Qe(i)) + 1) : (b = s),
      b < 0)
    )
      return new O(0)
    if (((b = (b / je + 2) | 0), (c = 0), B == 1))
      for (u = 0, F = F[0], b++; (c < T || u) && b--; c++)
        ((w = u * an + ($[c] || 0)), (p[c] = (w / F) | 0), (u = w % F | 0))
    else {
      for (
        u = (an / (F[0] + 1)) | 0,
          u > 1 && ((F = e(F, u)), ($ = e($, u)), (B = F.length), (T = $.length)),
          C = B,
          g = $.slice(0, B),
          m = g.length;
        m < B;

      )
        g[m++] = 0
      ;((E = F.slice()), E.unshift(0), (I = F[0]), F[1] >= an / 2 && ++I)
      do
        ((u = 0),
          (a = n(F, g, B, m)),
          a < 0
            ? ((y = g[0]),
              B != m && (y = y * an + (g[1] || 0)),
              (u = (y / I) | 0),
              u > 1
                ? (u >= an && (u = an - 1),
                  (f = e(F, u)),
                  (d = f.length),
                  (m = g.length),
                  (a = n(f, g, d, m)),
                  a == 1 && (u--, t(f, B < d ? E : F, d)))
                : (u == 0 && (a = u = 1), (f = F.slice())),
              (d = f.length),
              d < m && f.unshift(0),
              t(g, f, m),
              a == -1 &&
                ((m = g.length), (a = n(F, g, B, m)), a < 1 && (u++, t(g, B < m ? E : F, m))),
              (m = g.length))
            : a === 0 && (u++, (g = [0])),
          (p[c++] = u),
          a && g[0] ? (g[m++] = $[C] || 0) : ((g = [$[C]]), (m = 1)))
      while ((C++ < T || g[0] !== void 0) && b--)
    }
    return (p[0] || p.shift(), (h.e = l), Pe(h, o ? s + Qe(h) + 1 : s))
  }
})()
function a6(e, n) {
  var t,
    r,
    i,
    s,
    o,
    a,
    l = 0,
    c = 0,
    u = e.constructor,
    f = u.precision
  if (Qe(e) > 16) throw Error(K0 + Qe(e))
  if (!e.s) return new u($n)
  for (Be = !1, a = f, o = new u(0.03125); e.abs().gte(0.1); ) ((e = e.times(o)), (c += 5))
  for (
    r = ((Math.log(is(2, c)) / Math.LN10) * 2 + 5) | 0,
      a += r,
      t = i = s = new u($n),
      u.precision = a;
    ;

  ) {
    if (
      ((i = Pe(i.times(e), a)),
      (t = t.times(++l)),
      (o = s.plus(Jr(i, t, a))),
      Rr(o.d).slice(0, a) === Rr(s.d).slice(0, a))
    ) {
      for (; c--; ) s = Pe(s.times(s), a)
      return ((u.precision = f), n == null ? ((Be = !0), Pe(s, f)) : s)
    }
    s = o
  }
}
function Qe(e) {
  for (var n = e.e * je, t = e.d[0]; t >= 10; t /= 10) n++
  return n
}
function Jd(e, n, t) {
  if (n > e.LN10.sd())
    throw ((Be = !0), t && (e.precision = t), Error(ur + 'LN10 precision limit exceeded'))
  return Pe(new e(e.LN10), n)
}
function bi(e) {
  for (var n = ''; e--; ) n += '0'
  return n
}
function cl(e, n) {
  var t,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    f = 1,
    d = 10,
    h = e,
    p = h.d,
    g = h.constructor,
    m = g.precision
  if (h.s < 1) throw Error(ur + (h.s ? 'NaN' : '-Infinity'))
  if (h.eq($n)) return new g(0)
  if ((n == null ? ((Be = !1), (c = m)) : (c = n), h.eq(10)))
    return (n == null && (Be = !0), Jd(g, c))
  if (
    ((c += d), (g.precision = c), (t = Rr(p)), (r = t.charAt(0)), (s = Qe(h)), Math.abs(s) < 15e14)
  ) {
    for (; (r < 7 && r != 1) || (r == 1 && t.charAt(1) > 3); )
      ((h = h.times(e)), (t = Rr(h.d)), (r = t.charAt(0)), f++)
    ;((s = Qe(h)), r > 1 ? ((h = new g('0.' + t)), s++) : (h = new g(r + '.' + t.slice(1))))
  } else
    return (
      (l = Jd(g, c + 2, m).times(s + '')),
      (h = cl(new g(r + '.' + t.slice(1)), c - d).plus(l)),
      (g.precision = m),
      n == null ? ((Be = !0), Pe(h, m)) : h
    )
  for (a = o = h = Jr(h.minus($n), h.plus($n), c), u = Pe(h.times(h), c), i = 3; ; ) {
    if (
      ((o = Pe(o.times(u), c)),
      (l = a.plus(Jr(o, new g(i), c))),
      Rr(l.d).slice(0, c) === Rr(a.d).slice(0, c))
    )
      return (
        (a = a.times(2)),
        s !== 0 && (a = a.plus(Jd(g, c + 2, m).times(s + ''))),
        (a = Jr(a, new g(f), c)),
        (g.precision = m),
        n == null ? ((Be = !0), Pe(a, m)) : a
      )
    ;((a = l), (i += 2))
  }
}
function Fb(e, n) {
  var t, r, i
  for (
    (t = n.indexOf('.')) > -1 && (n = n.replace('.', '')),
      (r = n.search(/e/i)) > 0
        ? (t < 0 && (t = r), (t += +n.slice(r + 1)), (n = n.substring(0, r)))
        : t < 0 && (t = n.length),
      r = 0;
    n.charCodeAt(r) === 48;

  )
    ++r
  for (i = n.length; n.charCodeAt(i - 1) === 48; ) --i
  if (((n = n.slice(r, i)), n)) {
    if (
      ((i -= r),
      (t = t - r - 1),
      (e.e = na(t / je)),
      (e.d = []),
      (r = (t + 1) % je),
      t < 0 && (r += je),
      r < i)
    ) {
      for (r && e.d.push(+n.slice(0, r)), i -= je; r < i; ) e.d.push(+n.slice(r, (r += je)))
      ;((n = n.slice(r)), (r = je - n.length))
    } else r -= i
    for (; r--; ) n += '0'
    if ((e.d.push(+n), Be && (e.e > ku || e.e < -ku))) throw Error(K0 + t)
  } else ((e.s = 0), (e.e = 0), (e.d = [0]))
  return e
}
function Pe(e, n, t) {
  var r,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    f = e.d
  for (o = 1, s = f[0]; s >= 10; s /= 10) o++
  if (((r = n - o), r < 0)) ((r += je), (i = n), (c = f[(u = 0)]))
  else {
    if (((u = Math.ceil((r + 1) / je)), (s = f.length), u >= s)) return e
    for (c = s = f[u], o = 1; s >= 10; s /= 10) o++
    ;((r %= je), (i = r - je + o))
  }
  if (
    (t !== void 0 &&
      ((s = is(10, o - i - 1)),
      (a = (c / s) % 10 | 0),
      (l = n < 0 || f[u + 1] !== void 0 || c % s),
      (l =
        t < 4
          ? (a || l) && (t == 0 || t == (e.s < 0 ? 3 : 2))
          : a > 5 ||
            (a == 5 &&
              (t == 4 ||
                l ||
                (t == 6 && (r > 0 ? (i > 0 ? c / is(10, o - i) : 0) : f[u - 1]) % 10 & 1) ||
                t == (e.s < 0 ? 8 : 7))))),
    n < 1 || !f[0])
  )
    return (
      l
        ? ((s = Qe(e)),
          (f.length = 1),
          (n = n - s - 1),
          (f[0] = is(10, (je - (n % je)) % je)),
          (e.e = na(-n / je) || 0))
        : ((f.length = 1), (f[0] = e.e = e.s = 0)),
      e
    )
  if (
    (r == 0
      ? ((f.length = u), (s = 1), u--)
      : ((f.length = u + 1),
        (s = is(10, je - r)),
        (f[u] = i > 0 ? ((c / is(10, o - i)) % is(10, i) | 0) * s : 0)),
    l)
  )
    for (;;)
      if (u == 0) {
        ;(f[0] += s) == an && ((f[0] = 1), ++e.e)
        break
      } else {
        if (((f[u] += s), f[u] != an)) break
        ;((f[u--] = 0), (s = 1))
      }
  for (r = f.length; f[--r] === 0; ) f.pop()
  if (Be && (e.e > ku || e.e < -ku)) throw Error(K0 + Qe(e))
  return e
}
function l6(e, n) {
  var t,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    f,
    d = e.constructor,
    h = d.precision
  if (!e.s || !n.s) return (n.s ? (n.s = -n.s) : (n = new d(e)), Be ? Pe(n, h) : n)
  if (((l = e.d), (f = n.d), (r = n.e), (c = e.e), (l = l.slice()), (o = c - r), o)) {
    for (
      u = o < 0,
        u ? ((t = l), (o = -o), (a = f.length)) : ((t = f), (r = c), (a = l.length)),
        i = Math.max(Math.ceil(h / je), a) + 2,
        o > i && ((o = i), (t.length = 1)),
        t.reverse(),
        i = o;
      i--;

    )
      t.push(0)
    t.reverse()
  } else {
    for (i = l.length, a = f.length, u = i < a, u && (a = i), i = 0; i < a; i++)
      if (l[i] != f[i]) {
        u = l[i] < f[i]
        break
      }
    o = 0
  }
  for (u && ((t = l), (l = f), (f = t), (n.s = -n.s)), a = l.length, i = f.length - a; i > 0; --i)
    l[a++] = 0
  for (i = f.length; i > o; ) {
    if (l[--i] < f[i]) {
      for (s = i; s && l[--s] === 0; ) l[s] = an - 1
      ;(--l[s], (l[i] += an))
    }
    l[i] -= f[i]
  }
  for (; l[--a] === 0; ) l.pop()
  for (; l[0] === 0; l.shift()) --r
  return l[0] ? ((n.d = l), (n.e = r), Be ? Pe(n, h) : n) : new d(0)
}
function Ds(e, n, t) {
  var r,
    i = Qe(e),
    s = Rr(e.d),
    o = s.length
  return (
    n
      ? (t && (r = t - o) > 0
          ? (s = s.charAt(0) + '.' + s.slice(1) + bi(r))
          : o > 1 && (s = s.charAt(0) + '.' + s.slice(1)),
        (s = s + (i < 0 ? 'e' : 'e+') + i))
      : i < 0
        ? ((s = '0.' + bi(-i - 1) + s), t && (r = t - o) > 0 && (s += bi(r)))
        : i >= o
          ? ((s += bi(i + 1 - o)), t && (r = t - i - 1) > 0 && (s = s + '.' + bi(r)))
          : ((r = i + 1) < o && (s = s.slice(0, r) + '.' + s.slice(r)),
            t && (r = t - o) > 0 && (i + 1 === o && (s += '.'), (s += bi(r)))),
    e.s < 0 ? '-' + s : s
  )
}
function Bb(e, n) {
  if (e.length > n) return ((e.length = n), !0)
}
function c6(e) {
  var n, t, r
  function i(s) {
    var o = this
    if (!(o instanceof i)) return new i(s)
    if (((o.constructor = i), s instanceof i)) {
      ;((o.s = s.s), (o.e = s.e), (o.d = (s = s.d) ? s.slice() : s))
      return
    }
    if (typeof s == 'number') {
      if (s * 0 !== 0) throw Error(Ss + s)
      if (s > 0) o.s = 1
      else if (s < 0) ((s = -s), (o.s = -1))
      else {
        ;((o.s = 0), (o.e = 0), (o.d = [0]))
        return
      }
      if (s === ~~s && s < 1e7) {
        ;((o.e = 0), (o.d = [s]))
        return
      }
      return Fb(o, s.toString())
    } else if (typeof s != 'string') throw Error(Ss + s)
    if ((s.charCodeAt(0) === 45 ? ((s = s.slice(1)), (o.s = -1)) : (o.s = 1), XL.test(s))) Fb(o, s)
    else throw Error(Ss + s)
  }
  if (
    ((i.prototype = Bt),
    (i.ROUND_UP = 0),
    (i.ROUND_DOWN = 1),
    (i.ROUND_CEIL = 2),
    (i.ROUND_FLOOR = 3),
    (i.ROUND_HALF_UP = 4),
    (i.ROUND_HALF_DOWN = 5),
    (i.ROUND_HALF_EVEN = 6),
    (i.ROUND_HALF_CEIL = 7),
    (i.ROUND_HALF_FLOOR = 8),
    (i.clone = c6),
    (i.config = i.set = YL),
    e === void 0 && (e = {}),
    e)
  )
    for (r = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'], n = 0; n < r.length; )
      e.hasOwnProperty((t = r[n++])) || (e[t] = this[t])
  return (i.config(e), i)
}
function YL(e) {
  if (!e || typeof e != 'object') throw Error(ur + 'Object expected')
  var n,
    t,
    r,
    i = ['precision', 1, ea, 'rounding', 0, 8, 'toExpNeg', -1 / 0, 0, 'toExpPos', 0, 1 / 0]
  for (n = 0; n < i.length; n += 3)
    if ((r = e[(t = i[n])]) !== void 0)
      if (na(r) === r && r >= i[n + 1] && r <= i[n + 2]) this[t] = r
      else throw Error(Ss + t + ': ' + r)
  if ((r = e[(t = 'LN10')]) !== void 0)
    if (r == Math.LN10) this[t] = new this(r)
    else throw Error(Ss + t + ': ' + r)
  return this
}
var G0 = c6(GL)
$n = new G0(1)
const cJ = G0
var u6 = { exports: {} }
;(function (e) {
  var n = Object.prototype.hasOwnProperty,
    t = '~'
  function r() {}
  Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (t = !1))
  function i(l, c, u) {
    ;((this.fn = l), (this.context = c), (this.once = u || !1))
  }
  function s(l, c, u, f, d) {
    if (typeof u != 'function') throw new TypeError('The listener must be a function')
    var h = new i(u, f || l, d),
      p = t ? t + c : c
    return (
      l._events[p]
        ? l._events[p].fn
          ? (l._events[p] = [l._events[p], h])
          : l._events[p].push(h)
        : ((l._events[p] = h), l._eventsCount++),
      l
    )
  }
  function o(l, c) {
    --l._eventsCount === 0 ? (l._events = new r()) : delete l._events[c]
  }
  function a() {
    ;((this._events = new r()), (this._eventsCount = 0))
  }
  ;((a.prototype.eventNames = function () {
    var c = [],
      u,
      f
    if (this._eventsCount === 0) return c
    for (f in (u = this._events)) n.call(u, f) && c.push(t ? f.slice(1) : f)
    return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
  }),
    (a.prototype.listeners = function (c) {
      var u = t ? t + c : c,
        f = this._events[u]
      if (!f) return []
      if (f.fn) return [f.fn]
      for (var d = 0, h = f.length, p = new Array(h); d < h; d++) p[d] = f[d].fn
      return p
    }),
    (a.prototype.listenerCount = function (c) {
      var u = t ? t + c : c,
        f = this._events[u]
      return f ? (f.fn ? 1 : f.length) : 0
    }),
    (a.prototype.emit = function (c, u, f, d, h, p) {
      var g = t ? t + c : c
      if (!this._events[g]) return !1
      var m = this._events[g],
        y = arguments.length,
        b,
        w
      if (m.fn) {
        switch ((m.once && this.removeListener(c, m.fn, void 0, !0), y)) {
          case 1:
            return (m.fn.call(m.context), !0)
          case 2:
            return (m.fn.call(m.context, u), !0)
          case 3:
            return (m.fn.call(m.context, u, f), !0)
          case 4:
            return (m.fn.call(m.context, u, f, d), !0)
          case 5:
            return (m.fn.call(m.context, u, f, d, h), !0)
          case 6:
            return (m.fn.call(m.context, u, f, d, h, p), !0)
        }
        for (w = 1, b = new Array(y - 1); w < y; w++) b[w - 1] = arguments[w]
        m.fn.apply(m.context, b)
      } else {
        var C = m.length,
          T
        for (w = 0; w < C; w++)
          switch ((m[w].once && this.removeListener(c, m[w].fn, void 0, !0), y)) {
            case 1:
              m[w].fn.call(m[w].context)
              break
            case 2:
              m[w].fn.call(m[w].context, u)
              break
            case 3:
              m[w].fn.call(m[w].context, u, f)
              break
            case 4:
              m[w].fn.call(m[w].context, u, f, d)
              break
            default:
              if (!b) for (T = 1, b = new Array(y - 1); T < y; T++) b[T - 1] = arguments[T]
              m[w].fn.apply(m[w].context, b)
          }
      }
      return !0
    }),
    (a.prototype.on = function (c, u, f) {
      return s(this, c, u, f, !1)
    }),
    (a.prototype.once = function (c, u, f) {
      return s(this, c, u, f, !0)
    }),
    (a.prototype.removeListener = function (c, u, f, d) {
      var h = t ? t + c : c
      if (!this._events[h]) return this
      if (!u) return (o(this, h), this)
      var p = this._events[h]
      if (p.fn) p.fn === u && (!d || p.once) && (!f || p.context === f) && o(this, h)
      else {
        for (var g = 0, m = [], y = p.length; g < y; g++)
          (p[g].fn !== u || (d && !p[g].once) || (f && p[g].context !== f)) && m.push(p[g])
        m.length ? (this._events[h] = m.length === 1 ? m[0] : m) : o(this, h)
      }
      return this
    }),
    (a.prototype.removeAllListeners = function (c) {
      var u
      return (
        c
          ? ((u = t ? t + c : c), this._events[u] && o(this, u))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      )
    }),
    (a.prototype.off = a.prototype.removeListener),
    (a.prototype.addListener = a.prototype.on),
    (a.prefixed = t),
    (a.EventEmitter = a),
    (e.exports = a))
})(u6)
var ZL = u6.exports
const uJ = kr(ZL)
var f6 = {},
  d6 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return t[t.length - 1]
  }
  e.last = n
})(d6)
var h6 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    return Array.isArray(t) ? t : Array.from(t)
  }
  e.toArray = n
})(h6)
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  const n = d6,
    t = h6,
    r = Bf
  function i(s) {
    if (r.isArrayLike(s)) return n.last(t.toArray(s))
  }
  e.last = i
})(f6)
var JL = f6.last
const fJ = kr(JL)
var p6 = {}
;(function (e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' })
  function n(t) {
    if (typeof t != 'object' || t == null) return !1
    if (Object.getPrototypeOf(t) === null) return !0
    if (Object.prototype.toString.call(t) !== '[object Object]') {
      const i = t[Symbol.toStringTag]
      return i == null || !Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)?.writable
        ? !1
        : t.toString() === `[object ${i}]`
    }
    let r = t
    for (; Object.getPrototypeOf(r) !== null; ) r = Object.getPrototypeOf(r)
    return Object.getPrototypeOf(t) === r
  }
  e.isPlainObject = n
})(p6)
var QL = p6.isPlainObject
const dJ = kr(QL)
var tF = {}
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Il = Y
function eF(e, n) {
  return (e === n && (e !== 0 || 1 / e === 1 / n)) || (e !== e && n !== n)
}
var nF = typeof Object.is == 'function' ? Object.is : eF,
  rF = Il.useSyncExternalStore,
  iF = Il.useRef,
  sF = Il.useEffect,
  oF = Il.useMemo,
  aF = Il.useDebugValue
tF.useSyncExternalStoreWithSelector = function (e, n, t, r, i) {
  var s = iF(null)
  if (s.current === null) {
    var o = { hasValue: !1, value: null }
    s.current = o
  } else o = s.current
  s = oF(
    function () {
      function l(h) {
        if (!c) {
          if (((c = !0), (u = h), (h = r(h)), i !== void 0 && o.hasValue)) {
            var p = o.value
            if (i(p, h)) return (f = p)
          }
          return (f = h)
        }
        if (((p = f), nF(u, h))) return p
        var g = r(h)
        return i !== void 0 && i(p, g) ? ((u = h), p) : ((u = h), (f = g))
      }
      var c = !1,
        u,
        f,
        d = t === void 0 ? null : t
      return [
        function () {
          return l(n())
        },
        d === null
          ? void 0
          : function () {
              return l(d())
            },
      ]
    },
    [n, t, r, i],
  )
  var a = rF(e, s[0], s[1])
  return (
    sF(
      function () {
        ;((o.hasValue = !0), (o.value = a))
      },
      [a],
    ),
    aF(a),
    a
  )
}
function hJ(e, n, t, r) {
  var i = this,
    s = Y.useRef(null),
    o = Y.useRef(0),
    a = Y.useRef(0),
    l = Y.useRef(null),
    c = Y.useRef([]),
    u = Y.useRef(),
    f = Y.useRef(),
    d = Y.useRef(e),
    h = Y.useRef(!0)
  d.current = e
  var p = typeof window < 'u',
    g = !n && n !== 0 && p
  if (typeof e != 'function') throw new TypeError('Expected a function')
  n = +n || 0
  var m = !!(t = t || {}).leading,
    y = !('trailing' in t) || !!t.trailing,
    b = 'maxWait' in t,
    w = 'debounceOnServer' in t && !!t.debounceOnServer,
    C = b ? Math.max(+t.maxWait || 0, n) : null
  Y.useEffect(function () {
    return (
      (h.current = !0),
      function () {
        h.current = !1
      }
    )
  }, [])
  var T = Y.useMemo(
    function () {
      var I = function (M) {
          var R = c.current,
            k = u.current
          return (
            (c.current = u.current = null),
            (o.current = M),
            (a.current = a.current || M),
            (f.current = d.current.apply(k, R))
          )
        },
        B = function (M, R) {
          ;(g && cancelAnimationFrame(l.current),
            (l.current = g ? requestAnimationFrame(M) : setTimeout(M, R)))
        },
        E = function (M) {
          if (!h.current) return !1
          var R = M - s.current
          return !s.current || R >= n || R < 0 || (b && M - o.current >= C)
        },
        O = function (M) {
          return (
            (l.current = null),
            y && c.current ? I(M) : ((c.current = u.current = null), f.current)
          )
        },
        P = function M() {
          var R = Date.now()
          if ((m && a.current === o.current && $(), E(R))) return O(R)
          if (h.current) {
            var k = n - (R - s.current),
              v = b ? Math.min(k, C - (R - o.current)) : k
            B(M, v)
          }
        },
        $ = function () {},
        F = function () {
          if (p || w) {
            var M = Date.now(),
              R = E(M)
            if (((c.current = [].slice.call(arguments)), (u.current = i), (s.current = M), R)) {
              if (!l.current && h.current)
                return ((o.current = s.current), B(P, n), m ? I(s.current) : f.current)
              if (b) return (B(P, n), I(s.current))
            }
            return (l.current || B(P, n), f.current)
          }
        }
      return (
        (F.cancel = function () {
          var M = l.current
          ;(M && (g ? cancelAnimationFrame(l.current) : clearTimeout(l.current)),
            (o.current = 0),
            (c.current = s.current = u.current = l.current = null))
        }),
        (F.isPending = function () {
          return !!l.current
        }),
        (F.flush = function () {
          return l.current ? O(Date.now()) : f.current
        }),
        F
      )
    },
    [m, b, n, C, y, g, p, w, r],
  )
  return T
}
function Sn(e) {
  if (typeof e == 'string' || typeof e == 'number') return '' + e
  let n = ''
  if (Array.isArray(e))
    for (let t = 0, r; t < e.length; t++) (r = Sn(e[t])) !== '' && (n += (n && ' ') + r)
  else for (let t in e) e[t] && (n += (n && ' ') + t)
  return n
}
const lF = {},
  zb = (e) => {
    let n
    const t = new Set(),
      r = (u, f) => {
        const d = typeof u == 'function' ? u(n) : u
        if (!Object.is(d, n)) {
          const h = n
          ;((n = (f ?? (typeof d != 'object' || d === null)) ? d : Object.assign({}, n, d)),
            t.forEach((p) => p(n, h)))
        }
      },
      i = () => n,
      l = {
        setState: r,
        getState: i,
        getInitialState: () => c,
        subscribe: (u) => (t.add(u), () => t.delete(u)),
        destroy: () => {
          ;((lF ? 'production' : void 0) !== 'production' &&
            console.warn(
              '[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.',
            ),
            t.clear())
        },
      },
      c = (n = e(r, i, l))
    return l
  },
  m6 = (e) => (e ? zb(e) : zb),
  { useDebugValue: cF } = ut,
  { useSyncExternalStoreWithSelector: uF } = iw,
  fF = (e) => e
function g6(e, n = fF, t) {
  const r = uF(e.subscribe, e.getState, e.getServerState || e.getInitialState, n, t)
  return (cF(r), r)
}
const $b = (e, n) => {
    const t = m6(e),
      r = (i, s = n) => g6(t, i, s)
    return (Object.assign(r, t), r)
  },
  dF = (e, n) => (e ? $b(e, n) : $b)
function dn(e, n) {
  if (Object.is(e, n)) return !0
  if (typeof e != 'object' || e === null || typeof n != 'object' || n === null) return !1
  if (e instanceof Map && n instanceof Map) {
    if (e.size !== n.size) return !1
    for (const [r, i] of e) if (!Object.is(i, n.get(r))) return !1
    return !0
  }
  if (e instanceof Set && n instanceof Set) {
    if (e.size !== n.size) return !1
    for (const r of e) if (!n.has(r)) return !1
    return !0
  }
  const t = Object.keys(e)
  if (t.length !== Object.keys(n).length) return !1
  for (const r of t)
    if (!Object.prototype.hasOwnProperty.call(n, r) || !Object.is(e[r], n[r])) return !1
  return !0
}
const qf = Y.createContext(null),
  hF = qf.Provider,
  oi = {
    error001: () =>
      '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',
    error002: () =>
      "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
    error004: () =>
      'The React Flow parent container needs a width and a height to render the graph.',
    error005: () => 'Only child nodes can use a parent extent.',
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: (e) => `The old edge with id=${e} does not exist.`,
    error009: (e) => `Marker type "${e}" doesn't exist.`,
    error008: (e, n) =>
      `Couldn't create edge for ${e ? 'target' : 'source'} handle id: "${e ? n.targetHandle : n.sourceHandle}", edge id: ${n.id}.`,
    error010: () =>
      'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',
    error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
    error012: (e) =>
      `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  },
  y6 = oi.error001()
function Ne(e, n) {
  const t = Y.useContext(qf)
  if (t === null) throw new Error(y6)
  return g6(t, e, n)
}
const sn = () => {
    const e = Y.useContext(qf)
    if (e === null) throw new Error(y6)
    return Y.useMemo(
      () => ({
        getState: e.getState,
        setState: e.setState,
        subscribe: e.subscribe,
        destroy: e.destroy,
      }),
      [e],
    )
  },
  pF = (e) => (e.userSelectionActive ? 'none' : 'all')
function X0({ position: e, children: n, className: t, style: r, ...i }) {
  const s = Ne(pF),
    o = `${e}`.split('-')
  return ut.createElement(
    'div',
    { className: Sn(['react-flow__panel', t, ...o]), style: { ...r, pointerEvents: s }, ...i },
    n,
  )
}
function mF({ proOptions: e, position: n = 'bottom-right' }) {
  return e?.hideAttribution
    ? null
    : ut.createElement(
        X0,
        {
          position: n,
          className: 'react-flow__attribution',
          'data-message':
            'Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro',
        },
        ut.createElement(
          'a',
          {
            href: 'https://reactflow.dev',
            target: '_blank',
            rel: 'noopener noreferrer',
            'aria-label': 'React Flow attribution',
          },
          'React Flow',
        ),
      )
}
const gF = ({
  x: e,
  y: n,
  label: t,
  labelStyle: r = {},
  labelShowBg: i = !0,
  labelBgStyle: s = {},
  labelBgPadding: o = [2, 4],
  labelBgBorderRadius: a = 2,
  children: l,
  className: c,
  ...u
}) => {
  const f = Y.useRef(null),
    [d, h] = Y.useState({ x: 0, y: 0, width: 0, height: 0 }),
    p = Sn(['react-flow__edge-textwrapper', c])
  return (
    Y.useEffect(() => {
      if (f.current) {
        const g = f.current.getBBox()
        h({ x: g.x, y: g.y, width: g.width, height: g.height })
      }
    }, [t]),
    typeof t > 'u' || !t
      ? null
      : ut.createElement(
          'g',
          {
            transform: `translate(${e - d.width / 2} ${n - d.height / 2})`,
            className: p,
            visibility: d.width ? 'visible' : 'hidden',
            ...u,
          },
          i &&
            ut.createElement('rect', {
              width: d.width + 2 * o[0],
              x: -o[0],
              y: -o[1],
              height: d.height + 2 * o[1],
              className: 'react-flow__edge-textbg',
              style: s,
              rx: a,
              ry: a,
            }),
          ut.createElement(
            'text',
            { className: 'react-flow__edge-text', y: d.height / 2, dy: '0.3em', ref: f, style: r },
            t,
          ),
          l,
        )
  )
}
var yF = Y.memo(gF)
const Y0 = (e) => ({ width: e.offsetWidth, height: e.offsetHeight }),
  Fo = (e, n = 0, t = 1) => Math.min(Math.max(e, n), t),
  Z0 = (e = { x: 0, y: 0 }, n) => ({ x: Fo(e.x, n[0][0], n[1][0]), y: Fo(e.y, n[0][1], n[1][1]) }),
  Vb = (e, n, t) =>
    e < n ? Fo(Math.abs(e - n), 1, 50) / 50 : e > t ? -Fo(Math.abs(e - t), 1, 50) / 50 : 0,
  b6 = (e, n) => {
    const t = Vb(e.x, 35, n.width - 35) * 20,
      r = Vb(e.y, 35, n.height - 35) * 20
    return [t, r]
  },
  v6 = (e) => e.getRootNode?.() || window?.document,
  w6 = (e, n) => ({
    x: Math.min(e.x, n.x),
    y: Math.min(e.y, n.y),
    x2: Math.max(e.x2, n.x2),
    y2: Math.max(e.y2, n.y2),
  }),
  ul = ({ x: e, y: n, width: t, height: r }) => ({ x: e, y: n, x2: e + t, y2: n + r }),
  x6 = ({ x: e, y: n, x2: t, y2: r }) => ({ x: e, y: n, width: t - e, height: r - n }),
  Hb = (e) => ({
    ...(e.positionAbsolute || { x: 0, y: 0 }),
    width: e.width || 0,
    height: e.height || 0,
  }),
  bF = (e, n) => x6(w6(ul(e), ul(n))),
  Fp = (e, n) => {
    const t = Math.max(0, Math.min(e.x + e.width, n.x + n.width) - Math.max(e.x, n.x)),
      r = Math.max(0, Math.min(e.y + e.height, n.y + n.height) - Math.max(e.y, n.y))
    return Math.ceil(t * r)
  },
  vF = (e) => or(e.width) && or(e.height) && or(e.x) && or(e.y),
  or = (e) => !isNaN(e) && isFinite(e),
  We = Symbol.for('internals'),
  S6 = ['Enter', ' ', 'Escape'],
  wF = (e, n) => {},
  xF = (e) => 'nativeEvent' in e
function Bp(e) {
  const t = (xF(e) ? e.nativeEvent : e).composedPath?.()?.[0] || e.target
  return (
    ['INPUT', 'SELECT', 'TEXTAREA'].includes(t?.nodeName) ||
    t?.hasAttribute('contenteditable') ||
    !!t?.closest('.nokey')
  )
}
const _6 = (e) => 'clientX' in e,
  ji = (e, n) => {
    const t = _6(e),
      r = t ? e.clientX : e.touches?.[0].clientX,
      i = t ? e.clientY : e.touches?.[0].clientY
    return { x: r - (n?.left ?? 0), y: i - (n?.top ?? 0) }
  },
  Cu = () => typeof navigator < 'u' && navigator?.userAgent?.indexOf('Mac') >= 0,
  Dl = ({
    id: e,
    path: n,
    labelX: t,
    labelY: r,
    label: i,
    labelStyle: s,
    labelShowBg: o,
    labelBgStyle: a,
    labelBgPadding: l,
    labelBgBorderRadius: c,
    style: u,
    markerEnd: f,
    markerStart: d,
    interactionWidth: h = 20,
  }) =>
    ut.createElement(
      ut.Fragment,
      null,
      ut.createElement('path', {
        id: e,
        style: u,
        d: n,
        fill: 'none',
        className: 'react-flow__edge-path',
        markerEnd: f,
        markerStart: d,
      }),
      h &&
        ut.createElement('path', {
          d: n,
          fill: 'none',
          strokeOpacity: 0,
          strokeWidth: h,
          className: 'react-flow__edge-interaction',
        }),
      i && or(t) && or(r)
        ? ut.createElement(yF, {
            x: t,
            y: r,
            label: i,
            labelStyle: s,
            labelShowBg: o,
            labelBgStyle: a,
            labelBgPadding: l,
            labelBgBorderRadius: c,
          })
        : null,
    )
Dl.displayName = 'BaseEdge'
function ua(e, n, t) {
  return t === void 0
    ? t
    : (r) => {
        const i = n().edges.find((s) => s.id === e)
        i && t(r, { ...i })
      }
}
function k6({ sourceX: e, sourceY: n, targetX: t, targetY: r }) {
  const i = Math.abs(t - e) / 2,
    s = t < e ? t + i : t - i,
    o = Math.abs(r - n) / 2,
    a = r < n ? r + o : r - o
  return [s, a, i, o]
}
function C6({
  sourceX: e,
  sourceY: n,
  targetX: t,
  targetY: r,
  sourceControlX: i,
  sourceControlY: s,
  targetControlX: o,
  targetControlY: a,
}) {
  const l = e * 0.125 + i * 0.375 + o * 0.375 + t * 0.125,
    c = n * 0.125 + s * 0.375 + a * 0.375 + r * 0.125,
    u = Math.abs(l - e),
    f = Math.abs(c - n)
  return [l, c, u, f]
}
var js
;(function (e) {
  ;((e.Strict = 'strict'), (e.Loose = 'loose'))
})(js || (js = {}))
var ds
;(function (e) {
  ;((e.Free = 'free'), (e.Vertical = 'vertical'), (e.Horizontal = 'horizontal'))
})(ds || (ds = {}))
var fl
;(function (e) {
  ;((e.Partial = 'partial'), (e.Full = 'full'))
})(fl || (fl = {}))
var ki
;(function (e) {
  ;((e.Bezier = 'default'),
    (e.Straight = 'straight'),
    (e.Step = 'step'),
    (e.SmoothStep = 'smoothstep'),
    (e.SimpleBezier = 'simplebezier'))
})(ki || (ki = {}))
var Mu
;(function (e) {
  ;((e.Arrow = 'arrow'), (e.ArrowClosed = 'arrowclosed'))
})(Mu || (Mu = {}))
var Yt
;(function (e) {
  ;((e.Left = 'left'), (e.Top = 'top'), (e.Right = 'right'), (e.Bottom = 'bottom'))
})(Yt || (Yt = {}))
function Ub({ pos: e, x1: n, y1: t, x2: r, y2: i }) {
  return e === Yt.Left || e === Yt.Right ? [0.5 * (n + r), t] : [n, 0.5 * (t + i)]
}
function M6({
  sourceX: e,
  sourceY: n,
  sourcePosition: t = Yt.Bottom,
  targetX: r,
  targetY: i,
  targetPosition: s = Yt.Top,
}) {
  const [o, a] = Ub({ pos: t, x1: e, y1: n, x2: r, y2: i }),
    [l, c] = Ub({ pos: s, x1: r, y1: i, x2: e, y2: n }),
    [u, f, d, h] = C6({
      sourceX: e,
      sourceY: n,
      targetX: r,
      targetY: i,
      sourceControlX: o,
      sourceControlY: a,
      targetControlX: l,
      targetControlY: c,
    })
  return [`M${e},${n} C${o},${a} ${l},${c} ${r},${i}`, u, f, d, h]
}
const J0 = Y.memo(
  ({
    sourceX: e,
    sourceY: n,
    targetX: t,
    targetY: r,
    sourcePosition: i = Yt.Bottom,
    targetPosition: s = Yt.Top,
    label: o,
    labelStyle: a,
    labelShowBg: l,
    labelBgStyle: c,
    labelBgPadding: u,
    labelBgBorderRadius: f,
    style: d,
    markerEnd: h,
    markerStart: p,
    interactionWidth: g,
  }) => {
    const [m, y, b] = M6({
      sourceX: e,
      sourceY: n,
      sourcePosition: i,
      targetX: t,
      targetY: r,
      targetPosition: s,
    })
    return ut.createElement(Dl, {
      path: m,
      labelX: y,
      labelY: b,
      label: o,
      labelStyle: a,
      labelShowBg: l,
      labelBgStyle: c,
      labelBgPadding: u,
      labelBgBorderRadius: f,
      style: d,
      markerEnd: h,
      markerStart: p,
      interactionWidth: g,
    })
  },
)
J0.displayName = 'SimpleBezierEdge'
const qb = {
    [Yt.Left]: { x: -1, y: 0 },
    [Yt.Right]: { x: 1, y: 0 },
    [Yt.Top]: { x: 0, y: -1 },
    [Yt.Bottom]: { x: 0, y: 1 },
  },
  SF = ({ source: e, sourcePosition: n = Yt.Bottom, target: t }) =>
    n === Yt.Left || n === Yt.Right
      ? e.x < t.x
        ? { x: 1, y: 0 }
        : { x: -1, y: 0 }
      : e.y < t.y
        ? { x: 0, y: 1 }
        : { x: 0, y: -1 },
  Wb = (e, n) => Math.sqrt(Math.pow(n.x - e.x, 2) + Math.pow(n.y - e.y, 2))
function _F({
  source: e,
  sourcePosition: n = Yt.Bottom,
  target: t,
  targetPosition: r = Yt.Top,
  center: i,
  offset: s,
}) {
  const o = qb[n],
    a = qb[r],
    l = { x: e.x + o.x * s, y: e.y + o.y * s },
    c = { x: t.x + a.x * s, y: t.y + a.y * s },
    u = SF({ source: l, sourcePosition: n, target: c }),
    f = u.x !== 0 ? 'x' : 'y',
    d = u[f]
  let h = [],
    p,
    g
  const m = { x: 0, y: 0 },
    y = { x: 0, y: 0 },
    [b, w, C, T] = k6({ sourceX: e.x, sourceY: e.y, targetX: t.x, targetY: t.y })
  if (o[f] * a[f] === -1) {
    ;((p = i.x ?? b), (g = i.y ?? w))
    const B = [
        { x: p, y: l.y },
        { x: p, y: c.y },
      ],
      E = [
        { x: l.x, y: g },
        { x: c.x, y: g },
      ]
    o[f] === d ? (h = f === 'x' ? B : E) : (h = f === 'x' ? E : B)
  } else {
    const B = [{ x: l.x, y: c.y }],
      E = [{ x: c.x, y: l.y }]
    if ((f === 'x' ? (h = o.x === d ? E : B) : (h = o.y === d ? B : E), n === r)) {
      const M = Math.abs(e[f] - t[f])
      if (M <= s) {
        const R = Math.min(s - 1, s - M)
        o[f] === d ? (m[f] = (l[f] > e[f] ? -1 : 1) * R) : (y[f] = (c[f] > t[f] ? -1 : 1) * R)
      }
    }
    if (n !== r) {
      const M = f === 'x' ? 'y' : 'x',
        R = o[f] === a[M],
        k = l[M] > c[M],
        v = l[M] < c[M]
      ;((o[f] === 1 && ((!R && k) || (R && v))) || (o[f] !== 1 && ((!R && v) || (R && k)))) &&
        (h = f === 'x' ? B : E)
    }
    const O = { x: l.x + m.x, y: l.y + m.y },
      P = { x: c.x + y.x, y: c.y + y.y },
      $ = Math.max(Math.abs(O.x - h[0].x), Math.abs(P.x - h[0].x)),
      F = Math.max(Math.abs(O.y - h[0].y), Math.abs(P.y - h[0].y))
    $ >= F ? ((p = (O.x + P.x) / 2), (g = h[0].y)) : ((p = h[0].x), (g = (O.y + P.y) / 2))
  }
  return [[e, { x: l.x + m.x, y: l.y + m.y }, ...h, { x: c.x + y.x, y: c.y + y.y }, t], p, g, C, T]
}
function kF(e, n, t, r) {
  const i = Math.min(Wb(e, n) / 2, Wb(n, t) / 2, r),
    { x: s, y: o } = n
  if ((e.x === s && s === t.x) || (e.y === o && o === t.y)) return `L${s} ${o}`
  if (e.y === o) {
    const c = e.x < t.x ? -1 : 1,
      u = e.y < t.y ? 1 : -1
    return `L ${s + i * c},${o}Q ${s},${o} ${s},${o + i * u}`
  }
  const a = e.x < t.x ? 1 : -1,
    l = e.y < t.y ? -1 : 1
  return `L ${s},${o + i * l}Q ${s},${o} ${s + i * a},${o}`
}
function zp({
  sourceX: e,
  sourceY: n,
  sourcePosition: t = Yt.Bottom,
  targetX: r,
  targetY: i,
  targetPosition: s = Yt.Top,
  borderRadius: o = 5,
  centerX: a,
  centerY: l,
  offset: c = 20,
}) {
  const [u, f, d, h, p] = _F({
    source: { x: e, y: n },
    sourcePosition: t,
    target: { x: r, y: i },
    targetPosition: s,
    center: { x: a, y: l },
    offset: c,
  })
  return [
    u.reduce((m, y, b) => {
      let w = ''
      return (
        b > 0 && b < u.length - 1
          ? (w = kF(u[b - 1], y, u[b + 1], o))
          : (w = `${b === 0 ? 'M' : 'L'}${y.x} ${y.y}`),
        (m += w),
        m
      )
    }, ''),
    f,
    d,
    h,
    p,
  ]
}
const Wf = Y.memo(
  ({
    sourceX: e,
    sourceY: n,
    targetX: t,
    targetY: r,
    label: i,
    labelStyle: s,
    labelShowBg: o,
    labelBgStyle: a,
    labelBgPadding: l,
    labelBgBorderRadius: c,
    style: u,
    sourcePosition: f = Yt.Bottom,
    targetPosition: d = Yt.Top,
    markerEnd: h,
    markerStart: p,
    pathOptions: g,
    interactionWidth: m,
  }) => {
    const [y, b, w] = zp({
      sourceX: e,
      sourceY: n,
      sourcePosition: f,
      targetX: t,
      targetY: r,
      targetPosition: d,
      borderRadius: g?.borderRadius,
      offset: g?.offset,
    })
    return ut.createElement(Dl, {
      path: y,
      labelX: b,
      labelY: w,
      label: i,
      labelStyle: s,
      labelShowBg: o,
      labelBgStyle: a,
      labelBgPadding: l,
      labelBgBorderRadius: c,
      style: u,
      markerEnd: h,
      markerStart: p,
      interactionWidth: m,
    })
  },
)
Wf.displayName = 'SmoothStepEdge'
const Q0 = Y.memo((e) =>
  ut.createElement(Wf, {
    ...e,
    pathOptions: Y.useMemo(
      () => ({ borderRadius: 0, offset: e.pathOptions?.offset }),
      [e.pathOptions?.offset],
    ),
  }),
)
Q0.displayName = 'StepEdge'
function CF({ sourceX: e, sourceY: n, targetX: t, targetY: r }) {
  const [i, s, o, a] = k6({ sourceX: e, sourceY: n, targetX: t, targetY: r })
  return [`M ${e},${n}L ${t},${r}`, i, s, o, a]
}
const tg = Y.memo(
  ({
    sourceX: e,
    sourceY: n,
    targetX: t,
    targetY: r,
    label: i,
    labelStyle: s,
    labelShowBg: o,
    labelBgStyle: a,
    labelBgPadding: l,
    labelBgBorderRadius: c,
    style: u,
    markerEnd: f,
    markerStart: d,
    interactionWidth: h,
  }) => {
    const [p, g, m] = CF({ sourceX: e, sourceY: n, targetX: t, targetY: r })
    return ut.createElement(Dl, {
      path: p,
      labelX: g,
      labelY: m,
      label: i,
      labelStyle: s,
      labelShowBg: o,
      labelBgStyle: a,
      labelBgPadding: l,
      labelBgBorderRadius: c,
      style: u,
      markerEnd: f,
      markerStart: d,
      interactionWidth: h,
    })
  },
)
tg.displayName = 'StraightEdge'
function gc(e, n) {
  return e >= 0 ? 0.5 * e : n * 25 * Math.sqrt(-e)
}
function Kb({ pos: e, x1: n, y1: t, x2: r, y2: i, c: s }) {
  switch (e) {
    case Yt.Left:
      return [n - gc(n - r, s), t]
    case Yt.Right:
      return [n + gc(r - n, s), t]
    case Yt.Top:
      return [n, t - gc(t - i, s)]
    case Yt.Bottom:
      return [n, t + gc(i - t, s)]
  }
}
function E6({
  sourceX: e,
  sourceY: n,
  sourcePosition: t = Yt.Bottom,
  targetX: r,
  targetY: i,
  targetPosition: s = Yt.Top,
  curvature: o = 0.25,
}) {
  const [a, l] = Kb({ pos: t, x1: e, y1: n, x2: r, y2: i, c: o }),
    [c, u] = Kb({ pos: s, x1: r, y1: i, x2: e, y2: n, c: o }),
    [f, d, h, p] = C6({
      sourceX: e,
      sourceY: n,
      targetX: r,
      targetY: i,
      sourceControlX: a,
      sourceControlY: l,
      targetControlX: c,
      targetControlY: u,
    })
  return [`M${e},${n} C${a},${l} ${c},${u} ${r},${i}`, f, d, h, p]
}
const Eu = Y.memo(
  ({
    sourceX: e,
    sourceY: n,
    targetX: t,
    targetY: r,
    sourcePosition: i = Yt.Bottom,
    targetPosition: s = Yt.Top,
    label: o,
    labelStyle: a,
    labelShowBg: l,
    labelBgStyle: c,
    labelBgPadding: u,
    labelBgBorderRadius: f,
    style: d,
    markerEnd: h,
    markerStart: p,
    pathOptions: g,
    interactionWidth: m,
  }) => {
    const [y, b, w] = E6({
      sourceX: e,
      sourceY: n,
      sourcePosition: i,
      targetX: t,
      targetY: r,
      targetPosition: s,
      curvature: g?.curvature,
    })
    return ut.createElement(Dl, {
      path: y,
      labelX: b,
      labelY: w,
      label: o,
      labelStyle: a,
      labelShowBg: l,
      labelBgStyle: c,
      labelBgPadding: u,
      labelBgBorderRadius: f,
      style: d,
      markerEnd: h,
      markerStart: p,
      interactionWidth: m,
    })
  },
)
Eu.displayName = 'BezierEdge'
const eg = Y.createContext(null),
  MF = eg.Provider
eg.Consumer
const EF = () => Y.useContext(eg),
  TF = (e) => 'id' in e && 'source' in e && 'target' in e,
  AF = ({ source: e, sourceHandle: n, target: t, targetHandle: r }) =>
    `reactflow__edge-${e}${n || ''}-${t}${r || ''}`,
  $p = (e, n) =>
    typeof e > 'u'
      ? ''
      : typeof e == 'string'
        ? e
        : `${n ? `${n}__` : ''}${Object.keys(e)
            .sort()
            .map((r) => `${r}=${e[r]}`)
            .join('&')}`,
  RF = (e, n) =>
    n.some(
      (t) =>
        t.source === e.source &&
        t.target === e.target &&
        (t.sourceHandle === e.sourceHandle || (!t.sourceHandle && !e.sourceHandle)) &&
        (t.targetHandle === e.targetHandle || (!t.targetHandle && !e.targetHandle)),
    ),
  OF = (e, n) => {
    if (!e.source || !e.target) return n
    let t
    return (TF(e) ? (t = { ...e }) : (t = { ...e, id: AF(e) }), RF(t, n) ? n : n.concat(t))
  },
  Vp = ({ x: e, y: n }, [t, r, i], s, [o, a]) => {
    const l = { x: (e - t) / i, y: (n - r) / i }
    return s ? { x: o * Math.round(l.x / o), y: a * Math.round(l.y / a) } : l
  },
  T6 = ({ x: e, y: n }, [t, r, i]) => ({ x: e * i + t, y: n * i + r }),
  _s = (e, n = [0, 0]) => {
    if (!e) return { x: 0, y: 0, positionAbsolute: { x: 0, y: 0 } }
    const t = (e.width ?? 0) * n[0],
      r = (e.height ?? 0) * n[1],
      i = { x: e.position.x - t, y: e.position.y - r }
    return {
      ...i,
      positionAbsolute: e.positionAbsolute
        ? { x: e.positionAbsolute.x - t, y: e.positionAbsolute.y - r }
        : i,
    }
  },
  Kf = (e, n = [0, 0]) => {
    if (e.length === 0) return { x: 0, y: 0, width: 0, height: 0 }
    const t = e.reduce(
      (r, i) => {
        const { x: s, y: o } = _s(i, n).positionAbsolute
        return w6(r, ul({ x: s, y: o, width: i.width || 0, height: i.height || 0 }))
      },
      { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 },
    )
    return x6(t)
  },
  A6 = (e, n, [t, r, i] = [0, 0, 1], s = !1, o = !1, a = [0, 0]) => {
    const l = { x: (n.x - t) / i, y: (n.y - r) / i, width: n.width / i, height: n.height / i },
      c = []
    return (
      e.forEach((u) => {
        const { width: f, height: d, selectable: h = !0, hidden: p = !1 } = u
        if ((o && !h) || p) return !1
        const { positionAbsolute: g } = _s(u, a),
          m = { x: g.x, y: g.y, width: f || 0, height: d || 0 },
          y = Fp(l, m),
          b = typeof f > 'u' || typeof d > 'u' || f === null || d === null,
          w = s && y > 0,
          C = (f || 0) * (d || 0)
        ;(b || w || y >= C || u.dragging) && c.push(u)
      }),
      c
    )
  },
  R6 = (e, n) => {
    const t = e.map((r) => r.id)
    return n.filter((r) => t.includes(r.source) || t.includes(r.target))
  },
  O6 = (e, n, t, r, i, s = 0.1) => {
    const o = n / (e.width * (1 + s)),
      a = t / (e.height * (1 + s)),
      l = Math.min(o, a),
      c = Fo(l, r, i),
      u = e.x + e.width / 2,
      f = e.y + e.height / 2,
      d = n / 2 - u * c,
      h = t / 2 - f * c
    return { x: d, y: h, zoom: c }
  },
  ss = (e, n = 0) => e.transition().duration(n)
function Gb(e, n, t, r) {
  return (n[t] || []).reduce(
    (i, s) => (
      `${e.id}-${s.id}-${t}` !== r &&
        i.push({
          id: s.id || null,
          type: t,
          nodeId: e.id,
          x: (e.positionAbsolute?.x ?? 0) + s.x + s.width / 2,
          y: (e.positionAbsolute?.y ?? 0) + s.y + s.height / 2,
        }),
      i
    ),
    [],
  )
}
function PF(e, n, t, r, i, s) {
  const { x: o, y: a } = ji(e),
    c = n.elementsFromPoint(o, a).find((p) => p.classList.contains('react-flow__handle'))
  if (c) {
    const p = c.getAttribute('data-nodeid')
    if (p) {
      const g = ng(void 0, c),
        m = c.getAttribute('data-handleid'),
        y = s({ nodeId: p, id: m, type: g })
      if (y) {
        const b = i.find((w) => w.nodeId === p && w.type === g && w.id === m)
        return {
          handle: { id: m, type: g, nodeId: p, x: b?.x || t.x, y: b?.y || t.y },
          validHandleResult: y,
        }
      }
    }
  }
  let u = [],
    f = 1 / 0
  if (
    (i.forEach((p) => {
      const g = Math.sqrt((p.x - t.x) ** 2 + (p.y - t.y) ** 2)
      if (g <= r) {
        const m = s(p)
        g <= f &&
          (g < f
            ? (u = [{ handle: p, validHandleResult: m }])
            : g === f && u.push({ handle: p, validHandleResult: m }),
          (f = g))
      }
    }),
    !u.length)
  )
    return { handle: null, validHandleResult: P6() }
  if (u.length === 1) return u[0]
  const d = u.some(({ validHandleResult: p }) => p.isValid),
    h = u.some(({ handle: p }) => p.type === 'target')
  return (
    u.find(({ handle: p, validHandleResult: g }) =>
      h ? p.type === 'target' : d ? g.isValid : !0,
    ) || u[0]
  )
}
const NF = { source: null, target: null, sourceHandle: null, targetHandle: null },
  P6 = () => ({ handleDomNode: null, isValid: !1, connection: NF, endHandle: null })
function N6(e, n, t, r, i, s, o) {
  const a = i === 'target',
    l = o.querySelector(`.react-flow__handle[data-id="${e?.nodeId}-${e?.id}-${e?.type}"]`),
    c = { ...P6(), handleDomNode: l }
  if (l) {
    const u = ng(void 0, l),
      f = l.getAttribute('data-nodeid'),
      d = l.getAttribute('data-handleid'),
      h = l.classList.contains('connectable'),
      p = l.classList.contains('connectableend'),
      g = { source: a ? f : t, sourceHandle: a ? d : r, target: a ? t : f, targetHandle: a ? r : d }
    ;((c.connection = g),
      h &&
        p &&
        (n === js.Strict ? (a && u === 'source') || (!a && u === 'target') : f !== t || d !== r) &&
        ((c.endHandle = { nodeId: f, handleId: d, type: u }), (c.isValid = s(g))))
  }
  return c
}
function IF({ nodes: e, nodeId: n, handleId: t, handleType: r }) {
  return e.reduce((i, s) => {
    if (s[We]) {
      const { handleBounds: o } = s[We]
      let a = [],
        l = []
      ;(o &&
        ((a = Gb(s, o, 'source', `${n}-${t}-${r}`)), (l = Gb(s, o, 'target', `${n}-${t}-${r}`))),
        i.push(...a, ...l))
    }
    return i
  }, [])
}
function ng(e, n) {
  return (
    e ||
    (n?.classList.contains('target') ? 'target' : n?.classList.contains('source') ? 'source' : null)
  )
}
function Qd(e) {
  e?.classList.remove(
    'valid',
    'connecting',
    'react-flow__handle-valid',
    'react-flow__handle-connecting',
  )
}
function DF(e, n) {
  let t = null
  return (n ? (t = 'valid') : e && !n && (t = 'invalid'), t)
}
function I6({
  event: e,
  handleId: n,
  nodeId: t,
  onConnect: r,
  isTarget: i,
  getState: s,
  setState: o,
  isValidConnection: a,
  edgeUpdaterType: l,
  onReconnectEnd: c,
}) {
  const u = v6(e.target),
    {
      connectionMode: f,
      domNode: d,
      autoPanOnConnect: h,
      connectionRadius: p,
      onConnectStart: g,
      panBy: m,
      getNodes: y,
      cancelConnection: b,
    } = s()
  let w = 0,
    C
  const { x: T, y: I } = ji(e),
    B = u?.elementFromPoint(T, I),
    E = ng(l, B),
    O = d?.getBoundingClientRect()
  if (!O || !E) return
  let P,
    $ = ji(e, O),
    F = !1,
    M = null,
    R = !1,
    k = null
  const v = IF({ nodes: y(), nodeId: t, handleId: n, handleType: E }),
    x = () => {
      if (!h) return
      const [A, j] = b6($, O)
      ;(m({ x: A, y: j }), (w = requestAnimationFrame(x)))
    }
  ;(o({
    connectionPosition: $,
    connectionStatus: null,
    connectionNodeId: t,
    connectionHandleId: n,
    connectionHandleType: E,
    connectionStartHandle: { nodeId: t, handleId: n, type: E },
    connectionEndHandle: null,
  }),
    g?.(e, { nodeId: t, handleId: n, handleType: E }))
  function _(A) {
    const { transform: j } = s()
    $ = ji(A, O)
    const { handle: L, validHandleResult: H } = PF(A, u, Vp($, j, !1, [1, 1]), p, v, (U) =>
      N6(U, f, t, n, i ? 'target' : 'source', a, u),
    )
    if (
      ((C = L),
      F || (x(), (F = !0)),
      (k = H.handleDomNode),
      (M = H.connection),
      (R = H.isValid),
      o({
        connectionPosition: C && R ? T6({ x: C.x, y: C.y }, j) : $,
        connectionStatus: DF(!!C, R),
        connectionEndHandle: H.endHandle,
      }),
      !C && !R && !k)
    )
      return Qd(P)
    M.source !== M.target &&
      k &&
      (Qd(P),
      (P = k),
      k.classList.add('connecting', 'react-flow__handle-connecting'),
      k.classList.toggle('valid', R),
      k.classList.toggle('react-flow__handle-valid', R))
  }
  function S(A) {
    ;((C || k) && M && R && r?.(M),
      s().onConnectEnd?.(A),
      l && c?.(A),
      Qd(P),
      b(),
      cancelAnimationFrame(w),
      (F = !1),
      (R = !1),
      (M = null),
      (k = null),
      u.removeEventListener('mousemove', _),
      u.removeEventListener('mouseup', S),
      u.removeEventListener('touchmove', _),
      u.removeEventListener('touchend', S))
  }
  ;(u.addEventListener('mousemove', _),
    u.addEventListener('mouseup', S),
    u.addEventListener('touchmove', _),
    u.addEventListener('touchend', S))
}
const Xb = () => !0,
  jF = (e) => ({
    connectionStartHandle: e.connectionStartHandle,
    connectOnClick: e.connectOnClick,
    noPanClassName: e.noPanClassName,
  }),
  LF = (e, n, t) => (r) => {
    const { connectionStartHandle: i, connectionEndHandle: s, connectionClickStartHandle: o } = r
    return {
      connecting:
        (i?.nodeId === e && i?.handleId === n && i?.type === t) ||
        (s?.nodeId === e && s?.handleId === n && s?.type === t),
      clickConnecting: o?.nodeId === e && o?.handleId === n && o?.type === t,
    }
  },
  D6 = Y.forwardRef(
    (
      {
        type: e = 'source',
        position: n = Yt.Top,
        isValidConnection: t,
        isConnectable: r = !0,
        isConnectableStart: i = !0,
        isConnectableEnd: s = !0,
        id: o,
        onConnect: a,
        children: l,
        className: c,
        onMouseDown: u,
        onTouchStart: f,
        ...d
      },
      h,
    ) => {
      const p = o || null,
        g = e === 'target',
        m = sn(),
        y = EF(),
        { connectOnClick: b, noPanClassName: w } = Ne(jF, dn),
        { connecting: C, clickConnecting: T } = Ne(LF(y, p, e), dn)
      y || m.getState().onError?.('010', oi.error010())
      const I = (O) => {
          const { defaultEdgeOptions: P, onConnect: $, hasDefaultEdges: F } = m.getState(),
            M = { ...P, ...O }
          if (F) {
            const { edges: R, setEdges: k } = m.getState()
            k(OF(M, R))
          }
          ;($?.(M), a?.(M))
        },
        B = (O) => {
          if (!y) return
          const P = _6(O)
          ;(i &&
            ((P && O.button === 0) || !P) &&
            I6({
              event: O,
              handleId: p,
              nodeId: y,
              onConnect: I,
              isTarget: g,
              getState: m.getState,
              setState: m.setState,
              isValidConnection: t || m.getState().isValidConnection || Xb,
            }),
            P ? u?.(O) : f?.(O))
        },
        E = (O) => {
          const {
            onClickConnectStart: P,
            onClickConnectEnd: $,
            connectionClickStartHandle: F,
            connectionMode: M,
            isValidConnection: R,
          } = m.getState()
          if (!y || (!F && !i)) return
          if (!F) {
            ;(P?.(O, { nodeId: y, handleId: p, handleType: e }),
              m.setState({ connectionClickStartHandle: { nodeId: y, type: e, handleId: p } }))
            return
          }
          const k = v6(O.target),
            v = t || R || Xb,
            { connection: x, isValid: _ } = N6(
              { nodeId: y, id: p, type: e },
              M,
              F.nodeId,
              F.handleId || null,
              F.type,
              v,
              k,
            )
          ;(_ && I(x), $?.(O), m.setState({ connectionClickStartHandle: null }))
        }
      return ut.createElement(
        'div',
        {
          'data-handleid': p,
          'data-nodeid': y,
          'data-handlepos': n,
          'data-id': `${y}-${p}-${e}`,
          className: Sn([
            'react-flow__handle',
            `react-flow__handle-${n}`,
            'nodrag',
            w,
            c,
            {
              source: !g,
              target: g,
              connectable: r,
              connectablestart: i,
              connectableend: s,
              connecting: T,
              connectionindicator: r && ((i && !C) || (s && C)),
            },
          ]),
          onMouseDown: B,
          onTouchStart: B,
          onClick: b ? E : void 0,
          ref: h,
          ...d,
        },
        l,
      )
    },
  )
D6.displayName = 'Handle'
var Tu = Y.memo(D6)
const j6 = ({
  data: e,
  isConnectable: n,
  targetPosition: t = Yt.Top,
  sourcePosition: r = Yt.Bottom,
}) =>
  ut.createElement(
    ut.Fragment,
    null,
    ut.createElement(Tu, { type: 'target', position: t, isConnectable: n }),
    e?.label,
    ut.createElement(Tu, { type: 'source', position: r, isConnectable: n }),
  )
j6.displayName = 'DefaultNode'
var Hp = Y.memo(j6)
const L6 = ({ data: e, isConnectable: n, sourcePosition: t = Yt.Bottom }) =>
  ut.createElement(
    ut.Fragment,
    null,
    e?.label,
    ut.createElement(Tu, { type: 'source', position: t, isConnectable: n }),
  )
L6.displayName = 'InputNode'
var F6 = Y.memo(L6)
const B6 = ({ data: e, isConnectable: n, targetPosition: t = Yt.Top }) =>
  ut.createElement(
    ut.Fragment,
    null,
    ut.createElement(Tu, { type: 'target', position: t, isConnectable: n }),
    e?.label,
  )
B6.displayName = 'OutputNode'
var z6 = Y.memo(B6)
const rg = () => null
rg.displayName = 'GroupNode'
const FF = (e) => ({
    selectedNodes: e.getNodes().filter((n) => n.selected),
    selectedEdges: e.edges.filter((n) => n.selected).map((n) => ({ ...n })),
  }),
  yc = (e) => e.id
function BF(e, n) {
  return (
    dn(e.selectedNodes.map(yc), n.selectedNodes.map(yc)) &&
    dn(e.selectedEdges.map(yc), n.selectedEdges.map(yc))
  )
}
const $6 = Y.memo(({ onSelectionChange: e }) => {
  const n = sn(),
    { selectedNodes: t, selectedEdges: r } = Ne(FF, BF)
  return (
    Y.useEffect(() => {
      const i = { nodes: t, edges: r }
      ;(e?.(i), n.getState().onSelectionChange.forEach((s) => s(i)))
    }, [t, r, e]),
    null
  )
})
$6.displayName = 'SelectionListener'
const zF = (e) => !!e.onSelectionChange
function $F({ onSelectionChange: e }) {
  const n = Ne(zF)
  return e || n ? ut.createElement($6, { onSelectionChange: e }) : null
}
const VF = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
})
function Zs(e, n) {
  Y.useEffect(() => {
    typeof e < 'u' && n(e)
  }, [e])
}
function we(e, n, t) {
  Y.useEffect(() => {
    typeof n < 'u' && t({ [e]: n })
  }, [n])
}
const HF = ({
    nodes: e,
    edges: n,
    defaultNodes: t,
    defaultEdges: r,
    onConnect: i,
    onConnectStart: s,
    onConnectEnd: o,
    onClickConnectStart: a,
    onClickConnectEnd: l,
    nodesDraggable: c,
    nodesConnectable: u,
    nodesFocusable: f,
    edgesFocusable: d,
    edgesUpdatable: h,
    elevateNodesOnSelect: p,
    minZoom: g,
    maxZoom: m,
    nodeExtent: y,
    onNodesChange: b,
    onEdgesChange: w,
    elementsSelectable: C,
    connectionMode: T,
    snapGrid: I,
    snapToGrid: B,
    translateExtent: E,
    connectOnClick: O,
    defaultEdgeOptions: P,
    fitView: $,
    fitViewOptions: F,
    onNodesDelete: M,
    onEdgesDelete: R,
    onNodeDrag: k,
    onNodeDragStart: v,
    onNodeDragStop: x,
    onSelectionDrag: _,
    onSelectionDragStart: S,
    onSelectionDragStop: A,
    noPanClassName: j,
    nodeOrigin: L,
    rfId: H,
    autoPanOnConnect: U,
    autoPanOnNodeDrag: K,
    onError: z,
    connectionRadius: q,
    isValidConnection: D,
    nodeDragThreshold: N,
  }) => {
    const {
        setNodes: V,
        setEdges: W,
        setDefaultNodesAndEdges: J,
        setMinZoom: G,
        setMaxZoom: Z,
        setTranslateExtent: rt,
        setNodeExtent: nt,
        reset: X,
      } = Ne(VF, dn),
      Q = sn()
    return (
      Y.useEffect(() => {
        const tt = r?.map((st) => ({ ...st, ...P }))
        return (
          J(t, tt),
          () => {
            X()
          }
        )
      }, []),
      we('defaultEdgeOptions', P, Q.setState),
      we('connectionMode', T, Q.setState),
      we('onConnect', i, Q.setState),
      we('onConnectStart', s, Q.setState),
      we('onConnectEnd', o, Q.setState),
      we('onClickConnectStart', a, Q.setState),
      we('onClickConnectEnd', l, Q.setState),
      we('nodesDraggable', c, Q.setState),
      we('nodesConnectable', u, Q.setState),
      we('nodesFocusable', f, Q.setState),
      we('edgesFocusable', d, Q.setState),
      we('edgesUpdatable', h, Q.setState),
      we('elementsSelectable', C, Q.setState),
      we('elevateNodesOnSelect', p, Q.setState),
      we('snapToGrid', B, Q.setState),
      we('snapGrid', I, Q.setState),
      we('onNodesChange', b, Q.setState),
      we('onEdgesChange', w, Q.setState),
      we('connectOnClick', O, Q.setState),
      we('fitViewOnInit', $, Q.setState),
      we('fitViewOnInitOptions', F, Q.setState),
      we('onNodesDelete', M, Q.setState),
      we('onEdgesDelete', R, Q.setState),
      we('onNodeDrag', k, Q.setState),
      we('onNodeDragStart', v, Q.setState),
      we('onNodeDragStop', x, Q.setState),
      we('onSelectionDrag', _, Q.setState),
      we('onSelectionDragStart', S, Q.setState),
      we('onSelectionDragStop', A, Q.setState),
      we('noPanClassName', j, Q.setState),
      we('nodeOrigin', L, Q.setState),
      we('rfId', H, Q.setState),
      we('autoPanOnConnect', U, Q.setState),
      we('autoPanOnNodeDrag', K, Q.setState),
      we('onError', z, Q.setState),
      we('connectionRadius', q, Q.setState),
      we('isValidConnection', D, Q.setState),
      we('nodeDragThreshold', N, Q.setState),
      Zs(e, V),
      Zs(n, W),
      Zs(g, G),
      Zs(m, Z),
      Zs(E, rt),
      Zs(y, nt),
      null
    )
  },
  Yb = { display: 'none' },
  UF = {
    position: 'absolute',
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: 'hidden',
    clip: 'rect(0px, 0px, 0px, 0px)',
    clipPath: 'inset(100%)',
  },
  V6 = 'react-flow__node-desc',
  H6 = 'react-flow__edge-desc',
  qF = 'react-flow__aria-live',
  WF = (e) => e.ariaLiveMessage
function KF({ rfId: e }) {
  const n = Ne(WF)
  return ut.createElement(
    'div',
    { id: `${qF}-${e}`, 'aria-live': 'assertive', 'aria-atomic': 'true', style: UF },
    n,
  )
}
function GF({ rfId: e, disableKeyboardA11y: n }) {
  return ut.createElement(
    ut.Fragment,
    null,
    ut.createElement(
      'div',
      { id: `${V6}-${e}`, style: Yb },
      'Press enter or space to select a node.',
      !n && 'You can then use the arrow keys to move the node around.',
      ' Press delete to remove it and escape to cancel.',
      ' ',
    ),
    ut.createElement(
      'div',
      { id: `${H6}-${e}`, style: Yb },
      'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',
    ),
    !n && ut.createElement(KF, { rfId: e }),
  )
}
var dl = (e = null, n = { actInsideInputWithModifier: !0 }) => {
  const [t, r] = Y.useState(!1),
    i = Y.useRef(!1),
    s = Y.useRef(new Set([])),
    [o, a] = Y.useMemo(() => {
      if (e !== null) {
        const c = (Array.isArray(e) ? e : [e])
            .filter((f) => typeof f == 'string')
            .map((f) => f.split('+')),
          u = c.reduce((f, d) => f.concat(...d), [])
        return [c, u]
      }
      return [[], []]
    }, [e])
  return (
    Y.useEffect(() => {
      const l = typeof document < 'u' ? document : null,
        c = n?.target || l
      if (e !== null) {
        const u = (h) => {
            if (
              ((i.current = h.ctrlKey || h.metaKey || h.shiftKey),
              (!i.current || (i.current && !n.actInsideInputWithModifier)) && Bp(h))
            )
              return !1
            const g = Jb(h.code, a)
            ;(s.current.add(h[g]), Zb(o, s.current, !1) && (h.preventDefault(), r(!0)))
          },
          f = (h) => {
            if ((!i.current || (i.current && !n.actInsideInputWithModifier)) && Bp(h)) return !1
            const g = Jb(h.code, a)
            ;(Zb(o, s.current, !0) ? (r(!1), s.current.clear()) : s.current.delete(h[g]),
              h.key === 'Meta' && s.current.clear(),
              (i.current = !1))
          },
          d = () => {
            ;(s.current.clear(), r(!1))
          }
        return (
          c?.addEventListener('keydown', u),
          c?.addEventListener('keyup', f),
          window.addEventListener('blur', d),
          () => {
            ;(c?.removeEventListener('keydown', u),
              c?.removeEventListener('keyup', f),
              window.removeEventListener('blur', d))
          }
        )
      }
    }, [e, r]),
    t
  )
}
function Zb(e, n, t) {
  return e.filter((r) => t || r.length === n.size).some((r) => r.every((i) => n.has(i)))
}
function Jb(e, n) {
  return n.includes(e) ? 'code' : 'key'
}
function U6(e, n, t, r) {
  const i = e.parentNode || e.parentId
  if (!i) return t
  const s = n.get(i),
    o = _s(s, r)
  return U6(
    s,
    n,
    {
      x: (t.x ?? 0) + o.x,
      y: (t.y ?? 0) + o.y,
      z: (s[We]?.z ?? 0) > (t.z ?? 0) ? (s[We]?.z ?? 0) : (t.z ?? 0),
    },
    r,
  )
}
function q6(e, n, t) {
  e.forEach((r) => {
    const i = r.parentNode || r.parentId
    if (i && !e.has(i)) throw new Error(`Parent node ${i} not found`)
    if (i || t?.[r.id]) {
      const { x: s, y: o, z: a } = U6(r, e, { ...r.position, z: r[We]?.z ?? 0 }, n)
      ;((r.positionAbsolute = { x: s, y: o }), (r[We].z = a), t?.[r.id] && (r[We].isParent = !0))
    }
  })
}
function th(e, n, t, r) {
  const i = new Map(),
    s = {},
    o = r ? 1e3 : 0
  return (
    e.forEach((a) => {
      const l = (or(a.zIndex) ? a.zIndex : 0) + (a.selected ? o : 0),
        c = n.get(a.id),
        u = { ...a, positionAbsolute: { x: a.position.x, y: a.position.y } },
        f = a.parentNode || a.parentId
      f && (s[f] = !0)
      const d = c?.type && c?.type !== a.type
      ;(Object.defineProperty(u, We, {
        enumerable: !1,
        value: { handleBounds: d ? void 0 : c?.[We]?.handleBounds, z: l },
      }),
        i.set(a.id, u))
    }),
    q6(i, t, s),
    i
  )
}
function W6(e, n = {}) {
  const {
      getNodes: t,
      width: r,
      height: i,
      minZoom: s,
      maxZoom: o,
      d3Zoom: a,
      d3Selection: l,
      fitViewOnInitDone: c,
      fitViewOnInit: u,
      nodeOrigin: f,
    } = e(),
    d = n.initial && !c && u
  if (a && l && (d || !n.initial)) {
    const p = t().filter((m) => {
        const y = n.includeHiddenNodes ? m.width && m.height : !m.hidden
        return n.nodes?.length ? y && n.nodes.some((b) => b.id === m.id) : y
      }),
      g = p.every((m) => m.width && m.height)
    if (p.length > 0 && g) {
      const m = Kf(p, f),
        { x: y, y: b, zoom: w } = O6(m, r, i, n.minZoom ?? s, n.maxZoom ?? o, n.padding ?? 0.1),
        C = ys.translate(y, b).scale(w)
      return (
        typeof n.duration == 'number' && n.duration > 0
          ? a.transform(ss(l, n.duration), C)
          : a.transform(l, C),
        !0
      )
    }
  }
  return !1
}
function XF(e, n) {
  return (
    e.forEach((t) => {
      const r = n.get(t.id)
      r && n.set(r.id, { ...r, [We]: r[We], selected: t.selected })
    }),
    new Map(n)
  )
}
function YF(e, n) {
  return n.map((t) => {
    const r = e.find((i) => i.id === t.id)
    return (r && (t.selected = r.selected), t)
  })
}
function bc({ changedNodes: e, changedEdges: n, get: t, set: r }) {
  const {
    nodeInternals: i,
    edges: s,
    onNodesChange: o,
    onEdgesChange: a,
    hasDefaultNodes: l,
    hasDefaultEdges: c,
  } = t()
  ;(e?.length && (l && r({ nodeInternals: XF(e, i) }), o?.(e)),
    n?.length && (c && r({ edges: YF(n, s) }), a?.(n)))
}
const Js = () => {},
  ZF = {
    zoomIn: Js,
    zoomOut: Js,
    zoomTo: Js,
    getZoom: () => 1,
    setViewport: Js,
    getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
    fitView: () => !1,
    setCenter: Js,
    fitBounds: Js,
    project: (e) => e,
    screenToFlowPosition: (e) => e,
    flowToScreenPosition: (e) => e,
    viewportInitialized: !1,
  },
  JF = (e) => ({ d3Zoom: e.d3Zoom, d3Selection: e.d3Selection }),
  QF = () => {
    const e = sn(),
      { d3Zoom: n, d3Selection: t } = Ne(JF, dn)
    return Y.useMemo(
      () =>
        t && n
          ? {
              zoomIn: (i) => n.scaleBy(ss(t, i?.duration), 1.2),
              zoomOut: (i) => n.scaleBy(ss(t, i?.duration), 1 / 1.2),
              zoomTo: (i, s) => n.scaleTo(ss(t, s?.duration), i),
              getZoom: () => e.getState().transform[2],
              setViewport: (i, s) => {
                const [o, a, l] = e.getState().transform,
                  c = ys.translate(i.x ?? o, i.y ?? a).scale(i.zoom ?? l)
                n.transform(ss(t, s?.duration), c)
              },
              getViewport: () => {
                const [i, s, o] = e.getState().transform
                return { x: i, y: s, zoom: o }
              },
              fitView: (i) => W6(e.getState, i),
              setCenter: (i, s, o) => {
                const { width: a, height: l, maxZoom: c } = e.getState(),
                  u = typeof o?.zoom < 'u' ? o.zoom : c,
                  f = a / 2 - i * u,
                  d = l / 2 - s * u,
                  h = ys.translate(f, d).scale(u)
                n.transform(ss(t, o?.duration), h)
              },
              fitBounds: (i, s) => {
                const { width: o, height: a, minZoom: l, maxZoom: c } = e.getState(),
                  { x: u, y: f, zoom: d } = O6(i, o, a, l, c, s?.padding ?? 0.1),
                  h = ys.translate(u, f).scale(d)
                n.transform(ss(t, s?.duration), h)
              },
              project: (i) => {
                const { transform: s, snapToGrid: o, snapGrid: a } = e.getState()
                return (
                  console.warn(
                    '[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position',
                  ),
                  Vp(i, s, o, a)
                )
              },
              screenToFlowPosition: (i) => {
                const { transform: s, snapToGrid: o, snapGrid: a, domNode: l } = e.getState()
                if (!l) return i
                const { x: c, y: u } = l.getBoundingClientRect(),
                  f = { x: i.x - c, y: i.y - u }
                return Vp(f, s, o, a)
              },
              flowToScreenPosition: (i) => {
                const { transform: s, domNode: o } = e.getState()
                if (!o) return i
                const { x: a, y: l } = o.getBoundingClientRect(),
                  c = T6(i, s)
                return { x: c.x + a, y: c.y + l }
              },
              viewportInitialized: !0,
            }
          : ZF,
      [n, t],
    )
  }
function ig() {
  const e = QF(),
    n = sn(),
    t = Y.useCallback(
      () =>
        n
          .getState()
          .getNodes()
          .map((g) => ({ ...g })),
      [],
    ),
    r = Y.useCallback((g) => n.getState().nodeInternals.get(g), []),
    i = Y.useCallback(() => {
      const { edges: g = [] } = n.getState()
      return g.map((m) => ({ ...m }))
    }, []),
    s = Y.useCallback((g) => {
      const { edges: m = [] } = n.getState()
      return m.find((y) => y.id === g)
    }, []),
    o = Y.useCallback((g) => {
      const { getNodes: m, setNodes: y, hasDefaultNodes: b, onNodesChange: w } = n.getState(),
        C = m(),
        T = typeof g == 'function' ? g(C) : g
      if (b) y(T)
      else if (w) {
        const I =
          T.length === 0
            ? C.map((B) => ({ type: 'remove', id: B.id }))
            : T.map((B) => ({ item: B, type: 'reset' }))
        w(I)
      }
    }, []),
    a = Y.useCallback((g) => {
      const { edges: m = [], setEdges: y, hasDefaultEdges: b, onEdgesChange: w } = n.getState(),
        C = typeof g == 'function' ? g(m) : g
      if (b) y(C)
      else if (w) {
        const T =
          C.length === 0
            ? m.map((I) => ({ type: 'remove', id: I.id }))
            : C.map((I) => ({ item: I, type: 'reset' }))
        w(T)
      }
    }, []),
    l = Y.useCallback((g) => {
      const m = Array.isArray(g) ? g : [g],
        { getNodes: y, setNodes: b, hasDefaultNodes: w, onNodesChange: C } = n.getState()
      if (w) {
        const I = [...y(), ...m]
        b(I)
      } else if (C) {
        const T = m.map((I) => ({ item: I, type: 'add' }))
        C(T)
      }
    }, []),
    c = Y.useCallback((g) => {
      const m = Array.isArray(g) ? g : [g],
        { edges: y = [], setEdges: b, hasDefaultEdges: w, onEdgesChange: C } = n.getState()
      if (w) b([...y, ...m])
      else if (C) {
        const T = m.map((I) => ({ item: I, type: 'add' }))
        C(T)
      }
    }, []),
    u = Y.useCallback(() => {
      const { getNodes: g, edges: m = [], transform: y } = n.getState(),
        [b, w, C] = y
      return {
        nodes: g().map((T) => ({ ...T })),
        edges: m.map((T) => ({ ...T })),
        viewport: { x: b, y: w, zoom: C },
      }
    }, []),
    f = Y.useCallback(({ nodes: g, edges: m }) => {
      const {
          nodeInternals: y,
          getNodes: b,
          edges: w,
          hasDefaultNodes: C,
          hasDefaultEdges: T,
          onNodesDelete: I,
          onEdgesDelete: B,
          onNodesChange: E,
          onEdgesChange: O,
        } = n.getState(),
        P = (g || []).map((k) => k.id),
        $ = (m || []).map((k) => k.id),
        F = b().reduce((k, v) => {
          const x = v.parentNode || v.parentId,
            _ = !P.includes(v.id) && x && k.find((A) => A.id === x)
          return (
            (typeof v.deletable == 'boolean' ? v.deletable : !0) &&
              (P.includes(v.id) || _) &&
              k.push(v),
            k
          )
        }, []),
        M = w.filter((k) => (typeof k.deletable == 'boolean' ? k.deletable : !0)),
        R = M.filter((k) => $.includes(k.id))
      if (F || R) {
        const k = R6(F, M),
          v = [...R, ...k],
          x = v.reduce((_, S) => (_.includes(S.id) || _.push(S.id), _), [])
        if (
          ((T || C) &&
            (T && n.setState({ edges: w.filter((_) => !x.includes(_.id)) }),
            C &&
              (F.forEach((_) => {
                y.delete(_.id)
              }),
              n.setState({ nodeInternals: new Map(y) }))),
          x.length > 0 && (B?.(v), O && O(x.map((_) => ({ id: _, type: 'remove' })))),
          F.length > 0 && (I?.(F), E))
        ) {
          const _ = F.map((S) => ({ id: S.id, type: 'remove' }))
          E(_)
        }
      }
    }, []),
    d = Y.useCallback((g) => {
      const m = vF(g),
        y = m ? null : n.getState().nodeInternals.get(g.id)
      return !m && !y ? [null, null, m] : [m ? g : Hb(y), y, m]
    }, []),
    h = Y.useCallback((g, m = !0, y) => {
      const [b, w, C] = d(g)
      return b
        ? (y || n.getState().getNodes()).filter((T) => {
            if (!C && (T.id === w.id || !T.positionAbsolute)) return !1
            const I = Hb(T),
              B = Fp(I, b)
            return (m && B > 0) || B >= b.width * b.height
          })
        : []
    }, []),
    p = Y.useCallback((g, m, y = !0) => {
      const [b] = d(g)
      if (!b) return !1
      const w = Fp(b, m)
      return (y && w > 0) || w >= b.width * b.height
    }, [])
  return Y.useMemo(
    () => ({
      ...e,
      getNodes: t,
      getNode: r,
      getEdges: i,
      getEdge: s,
      setNodes: o,
      setEdges: a,
      addNodes: l,
      addEdges: c,
      toObject: u,
      deleteElements: f,
      getIntersectingNodes: h,
      isNodeIntersecting: p,
    }),
    [e, t, r, i, s, o, a, l, c, u, f, h, p],
  )
}
const tB = { actInsideInputWithModifier: !1 }
var eB = ({ deleteKeyCode: e, multiSelectionKeyCode: n }) => {
  const t = sn(),
    { deleteElements: r } = ig(),
    i = dl(e, tB),
    s = dl(n)
  ;(Y.useEffect(() => {
    if (i) {
      const { edges: o, getNodes: a } = t.getState(),
        l = a().filter((u) => u.selected),
        c = o.filter((u) => u.selected)
      ;(r({ nodes: l, edges: c }), t.setState({ nodesSelectionActive: !1 }))
    }
  }, [i]),
    Y.useEffect(() => {
      t.setState({ multiSelectionActive: s })
    }, [s]))
}
function nB(e) {
  const n = sn()
  Y.useEffect(() => {
    let t
    const r = () => {
      if (!e.current) return
      const i = Y0(e.current)
      ;((i.height === 0 || i.width === 0) && n.getState().onError?.('004', oi.error004()),
        n.setState({ width: i.width || 500, height: i.height || 500 }))
    }
    return (
      r(),
      window.addEventListener('resize', r),
      e.current && ((t = new ResizeObserver(() => r())), t.observe(e.current)),
      () => {
        ;(window.removeEventListener('resize', r), t && e.current && t.unobserve(e.current))
      }
    )
  }, [])
}
const sg = { position: 'absolute', width: '100%', height: '100%', top: 0, left: 0 },
  rB = (e, n) => e.x !== n.x || e.y !== n.y || e.zoom !== n.k,
  vc = (e) => ({ x: e.x, y: e.y, zoom: e.k }),
  Qs = (e, n) => e.target.closest(`.${n}`),
  Qb = (e, n) => n === 2 && Array.isArray(e) && e.includes(2),
  tv = (e) => {
    const n = e.ctrlKey && Cu() ? 10 : 1
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 0.002) * n
  },
  iB = (e) => ({
    d3Zoom: e.d3Zoom,
    d3Selection: e.d3Selection,
    d3ZoomHandler: e.d3ZoomHandler,
    userSelectionActive: e.userSelectionActive,
  }),
  sB = ({
    onMove: e,
    onMoveStart: n,
    onMoveEnd: t,
    onPaneContextMenu: r,
    zoomOnScroll: i = !0,
    zoomOnPinch: s = !0,
    panOnScroll: o = !1,
    panOnScrollSpeed: a = 0.5,
    panOnScrollMode: l = ds.Free,
    zoomOnDoubleClick: c = !0,
    elementsSelectable: u,
    panOnDrag: f = !0,
    defaultViewport: d,
    translateExtent: h,
    minZoom: p,
    maxZoom: g,
    zoomActivationKeyCode: m,
    preventScrolling: y = !0,
    children: b,
    noWheelClassName: w,
    noPanClassName: C,
  }) => {
    const T = Y.useRef(),
      I = sn(),
      B = Y.useRef(!1),
      E = Y.useRef(!1),
      O = Y.useRef(null),
      P = Y.useRef({ x: 0, y: 0, zoom: 0 }),
      { d3Zoom: $, d3Selection: F, d3ZoomHandler: M, userSelectionActive: R } = Ne(iB, dn),
      k = dl(m),
      v = Y.useRef(0),
      x = Y.useRef(!1),
      _ = Y.useRef()
    return (
      nB(O),
      Y.useEffect(() => {
        if (O.current) {
          const S = O.current.getBoundingClientRect(),
            A = L2().scaleExtent([p, g]).translateExtent(h),
            j = _m(O.current).call(A),
            L = ys.translate(d.x, d.y).scale(Fo(d.zoom, p, g)),
            H = [
              [0, 0],
              [S.width, S.height],
            ],
            U = A.constrain()(L, H, h)
          ;(A.transform(j, U),
            A.wheelDelta(tv),
            I.setState({
              d3Zoom: A,
              d3Selection: j,
              d3ZoomHandler: j.on('wheel.zoom'),
              transform: [U.x, U.y, U.k],
              domNode: O.current.closest('.react-flow'),
            }))
        }
      }, []),
      Y.useEffect(() => {
        F &&
          $ &&
          (o && !k && !R
            ? F.on(
                'wheel.zoom',
                (S) => {
                  if (Qs(S, w)) return !1
                  ;(S.preventDefault(), S.stopImmediatePropagation())
                  const A = F.property('__zoom').k || 1
                  if (S.ctrlKey && s) {
                    const D = F2(S),
                      N = tv(S),
                      V = A * Math.pow(2, N)
                    $.scaleTo(F, V, D, S)
                    return
                  }
                  const j = S.deltaMode === 1 ? 20 : 1
                  let L = l === ds.Vertical ? 0 : S.deltaX * j,
                    H = l === ds.Horizontal ? 0 : S.deltaY * j
                  ;(!Cu() && S.shiftKey && l !== ds.Vertical && ((L = S.deltaY * j), (H = 0)),
                    $.translateBy(F, -(L / A) * a, -(H / A) * a, { internal: !0 }))
                  const U = vc(F.property('__zoom')),
                    {
                      onViewportChangeStart: K,
                      onViewportChange: z,
                      onViewportChangeEnd: q,
                    } = I.getState()
                  ;(clearTimeout(_.current),
                    x.current || ((x.current = !0), n?.(S, U), K?.(U)),
                    x.current &&
                      (e?.(S, U),
                      z?.(U),
                      (_.current = setTimeout(() => {
                        ;(t?.(S, U), q?.(U), (x.current = !1))
                      }, 150))))
                },
                { passive: !1 },
              )
            : typeof M < 'u' &&
              F.on(
                'wheel.zoom',
                function (S, A) {
                  if ((!y && S.type === 'wheel' && !S.ctrlKey) || Qs(S, w)) return null
                  ;(S.preventDefault(), M.call(this, S, A))
                },
                { passive: !1 },
              ))
      }, [R, o, l, F, $, M, k, s, y, w, n, e, t]),
      Y.useEffect(() => {
        $ &&
          $.on('start', (S) => {
            if (!S.sourceEvent || S.sourceEvent.internal) return null
            v.current = S.sourceEvent?.button
            const { onViewportChangeStart: A } = I.getState(),
              j = vc(S.transform)
            ;((B.current = !0),
              (P.current = j),
              S.sourceEvent?.type === 'mousedown' && I.setState({ paneDragging: !0 }),
              A?.(j),
              n?.(S.sourceEvent, j))
          })
      }, [$, n]),
      Y.useEffect(() => {
        $ &&
          (R && !B.current
            ? $.on('zoom', null)
            : R ||
              $.on('zoom', (S) => {
                const { onViewportChange: A } = I.getState()
                if (
                  (I.setState({ transform: [S.transform.x, S.transform.y, S.transform.k] }),
                  (E.current = !!(r && Qb(f, v.current ?? 0))),
                  (e || A) && !S.sourceEvent?.internal)
                ) {
                  const j = vc(S.transform)
                  ;(A?.(j), e?.(S.sourceEvent, j))
                }
              }))
      }, [R, $, e, f, r]),
      Y.useEffect(() => {
        $ &&
          $.on('end', (S) => {
            if (!S.sourceEvent || S.sourceEvent.internal) return null
            const { onViewportChangeEnd: A } = I.getState()
            if (
              ((B.current = !1),
              I.setState({ paneDragging: !1 }),
              r && Qb(f, v.current ?? 0) && !E.current && r(S.sourceEvent),
              (E.current = !1),
              (t || A) && rB(P.current, S.transform))
            ) {
              const j = vc(S.transform)
              ;((P.current = j),
                clearTimeout(T.current),
                (T.current = setTimeout(
                  () => {
                    ;(A?.(j), t?.(S.sourceEvent, j))
                  },
                  o ? 150 : 0,
                )))
            }
          })
      }, [$, o, f, t, r]),
      Y.useEffect(() => {
        $ &&
          $.filter((S) => {
            const A = k || i,
              j = s && S.ctrlKey
            if (
              (f === !0 || (Array.isArray(f) && f.includes(1))) &&
              S.button === 1 &&
              S.type === 'mousedown' &&
              (Qs(S, 'react-flow__node') || Qs(S, 'react-flow__edge'))
            )
              return !0
            if (
              (!f && !A && !o && !c && !s) ||
              R ||
              (!c && S.type === 'dblclick') ||
              (Qs(S, w) && S.type === 'wheel') ||
              (Qs(S, C) && (S.type !== 'wheel' || (o && S.type === 'wheel' && !k))) ||
              (!s && S.ctrlKey && S.type === 'wheel') ||
              (!A && !o && !j && S.type === 'wheel') ||
              (!f && (S.type === 'mousedown' || S.type === 'touchstart')) ||
              (Array.isArray(f) && !f.includes(S.button) && S.type === 'mousedown')
            )
              return !1
            const L = (Array.isArray(f) && f.includes(S.button)) || !S.button || S.button <= 1
            return (!S.ctrlKey || S.type === 'wheel') && L
          })
      }, [R, $, i, s, o, c, f, u, k]),
      ut.createElement('div', { className: 'react-flow__renderer', ref: O, style: sg }, b)
    )
  },
  oB = (e) => ({
    userSelectionActive: e.userSelectionActive,
    userSelectionRect: e.userSelectionRect,
  })
function aB() {
  const { userSelectionActive: e, userSelectionRect: n } = Ne(oB, dn)
  return e && n
    ? ut.createElement('div', {
        className: 'react-flow__selection react-flow__container',
        style: { width: n.width, height: n.height, transform: `translate(${n.x}px, ${n.y}px)` },
      })
    : null
}
function ev(e, n) {
  const t = n.parentNode || n.parentId,
    r = e.find((i) => i.id === t)
  if (r) {
    const i = n.position.x + n.width - r.width,
      s = n.position.y + n.height - r.height
    if (i > 0 || s > 0 || n.position.x < 0 || n.position.y < 0) {
      if (
        ((r.style = { ...r.style }),
        (r.style.width = r.style.width ?? r.width),
        (r.style.height = r.style.height ?? r.height),
        i > 0 && (r.style.width += i),
        s > 0 && (r.style.height += s),
        n.position.x < 0)
      ) {
        const o = Math.abs(n.position.x)
        ;((r.position.x = r.position.x - o), (r.style.width += o), (n.position.x = 0))
      }
      if (n.position.y < 0) {
        const o = Math.abs(n.position.y)
        ;((r.position.y = r.position.y - o), (r.style.height += o), (n.position.y = 0))
      }
      ;((r.width = r.style.width), (r.height = r.style.height))
    }
  }
}
function K6(e, n) {
  if (e.some((r) => r.type === 'reset'))
    return e.filter((r) => r.type === 'reset').map((r) => r.item)
  const t = e.filter((r) => r.type === 'add').map((r) => r.item)
  return n.reduce((r, i) => {
    const s = e.filter((a) => a.id === i.id)
    if (s.length === 0) return (r.push(i), r)
    const o = { ...i }
    for (const a of s)
      if (a)
        switch (a.type) {
          case 'select': {
            o.selected = a.selected
            break
          }
          case 'position': {
            ;(typeof a.position < 'u' && (o.position = a.position),
              typeof a.positionAbsolute < 'u' && (o.positionAbsolute = a.positionAbsolute),
              typeof a.dragging < 'u' && (o.dragging = a.dragging),
              o.expandParent && ev(r, o))
            break
          }
          case 'dimensions': {
            ;(typeof a.dimensions < 'u' &&
              ((o.width = a.dimensions.width), (o.height = a.dimensions.height)),
              typeof a.updateStyle < 'u' && (o.style = { ...(o.style || {}), ...a.dimensions }),
              typeof a.resizing == 'boolean' && (o.resizing = a.resizing),
              o.expandParent && ev(r, o))
            break
          }
          case 'remove':
            return r
        }
    return (r.push(o), r)
  }, t)
}
function G6(e, n) {
  return K6(e, n)
}
function lB(e, n) {
  return K6(e, n)
}
const vi = (e, n) => ({ id: e, type: 'select', selected: n })
function ho(e, n) {
  return e.reduce((t, r) => {
    const i = n.includes(r.id)
    return (
      !r.selected && i
        ? ((r.selected = !0), t.push(vi(r.id, !0)))
        : r.selected && !i && ((r.selected = !1), t.push(vi(r.id, !1))),
      t
    )
  }, [])
}
const eh = (e, n) => (t) => {
    t.target === n.current && e?.(t)
  },
  cB = (e) => ({
    userSelectionActive: e.userSelectionActive,
    elementsSelectable: e.elementsSelectable,
    dragging: e.paneDragging,
  }),
  X6 = Y.memo(
    ({
      isSelecting: e,
      selectionMode: n = fl.Full,
      panOnDrag: t,
      onSelectionStart: r,
      onSelectionEnd: i,
      onPaneClick: s,
      onPaneContextMenu: o,
      onPaneScroll: a,
      onPaneMouseEnter: l,
      onPaneMouseMove: c,
      onPaneMouseLeave: u,
      children: f,
    }) => {
      const d = Y.useRef(null),
        h = sn(),
        p = Y.useRef(0),
        g = Y.useRef(0),
        m = Y.useRef(),
        { userSelectionActive: y, elementsSelectable: b, dragging: w } = Ne(cB, dn),
        C = () => {
          ;(h.setState({ userSelectionActive: !1, userSelectionRect: null }),
            (p.current = 0),
            (g.current = 0))
        },
        T = (M) => {
          ;(s?.(M), h.getState().resetSelectedElements(), h.setState({ nodesSelectionActive: !1 }))
        },
        I = (M) => {
          if (Array.isArray(t) && t?.includes(2)) {
            M.preventDefault()
            return
          }
          o?.(M)
        },
        B = a ? (M) => a(M) : void 0,
        E = (M) => {
          const { resetSelectedElements: R, domNode: k } = h.getState()
          if (
            ((m.current = k?.getBoundingClientRect()),
            !b || !e || M.button !== 0 || M.target !== d.current || !m.current)
          )
            return
          const { x: v, y: x } = ji(M, m.current)
          ;(R(),
            h.setState({
              userSelectionRect: { width: 0, height: 0, startX: v, startY: x, x: v, y: x },
            }),
            r?.(M))
        },
        O = (M) => {
          const {
            userSelectionRect: R,
            nodeInternals: k,
            edges: v,
            transform: x,
            onNodesChange: _,
            onEdgesChange: S,
            nodeOrigin: A,
            getNodes: j,
          } = h.getState()
          if (!e || !m.current || !R) return
          h.setState({ userSelectionActive: !0, nodesSelectionActive: !1 })
          const L = ji(M, m.current),
            H = R.startX ?? 0,
            U = R.startY ?? 0,
            K = {
              ...R,
              x: L.x < H ? L.x : H,
              y: L.y < U ? L.y : U,
              width: Math.abs(L.x - H),
              height: Math.abs(L.y - U),
            },
            z = j(),
            q = A6(k, K, x, n === fl.Partial, !0, A),
            D = R6(q, v).map((V) => V.id),
            N = q.map((V) => V.id)
          if (p.current !== N.length) {
            p.current = N.length
            const V = ho(z, N)
            V.length && _?.(V)
          }
          if (g.current !== D.length) {
            g.current = D.length
            const V = ho(v, D)
            V.length && S?.(V)
          }
          h.setState({ userSelectionRect: K })
        },
        P = (M) => {
          if (M.button !== 0) return
          const { userSelectionRect: R } = h.getState()
          ;(!y && R && M.target === d.current && T?.(M),
            h.setState({ nodesSelectionActive: p.current > 0 }),
            C(),
            i?.(M))
        },
        $ = (M) => {
          ;(y && (h.setState({ nodesSelectionActive: p.current > 0 }), i?.(M)), C())
        },
        F = b && (e || y)
      return ut.createElement(
        'div',
        {
          className: Sn(['react-flow__pane', { dragging: w, selection: e }]),
          onClick: F ? void 0 : eh(T, d),
          onContextMenu: eh(I, d),
          onWheel: eh(B, d),
          onMouseEnter: F ? void 0 : l,
          onMouseDown: F ? E : void 0,
          onMouseMove: F ? O : c,
          onMouseUp: F ? P : void 0,
          onMouseLeave: F ? $ : u,
          ref: d,
          style: sg,
        },
        f,
        ut.createElement(aB, null),
      )
    },
  )
X6.displayName = 'Pane'
function Y6(e, n) {
  const t = e.parentNode || e.parentId
  if (!t) return !1
  const r = n.get(t)
  return r ? (r.selected ? !0 : Y6(r, n)) : !1
}
function nv(e, n, t) {
  let r = e
  do {
    if (r?.matches(n)) return !0
    if (r === t.current) return !1
    r = r.parentElement
  } while (r)
  return !1
}
function uB(e, n, t, r) {
  return Array.from(e.values())
    .filter(
      (i) =>
        (i.selected || i.id === r) &&
        (!i.parentNode || i.parentId || !Y6(i, e)) &&
        (i.draggable || (n && typeof i.draggable > 'u')),
    )
    .map((i) => ({
      id: i.id,
      position: i.position || { x: 0, y: 0 },
      positionAbsolute: i.positionAbsolute || { x: 0, y: 0 },
      distance: { x: t.x - (i.positionAbsolute?.x ?? 0), y: t.y - (i.positionAbsolute?.y ?? 0) },
      delta: { x: 0, y: 0 },
      extent: i.extent,
      parentNode: i.parentNode || i.parentId,
      parentId: i.parentNode || i.parentId,
      width: i.width,
      height: i.height,
      expandParent: i.expandParent,
    }))
}
function fB(e, n) {
  return !n || n === 'parent' ? n : [n[0], [n[1][0] - (e.width || 0), n[1][1] - (e.height || 0)]]
}
function Z6(e, n, t, r, i = [0, 0], s) {
  const o = fB(e, e.extent || r)
  let a = o
  const l = e.parentNode || e.parentId
  if (e.extent === 'parent' && !e.expandParent)
    if (l && e.width && e.height) {
      const f = t.get(l),
        { x: d, y: h } = _s(f, i).positionAbsolute
      a =
        f && or(d) && or(h) && or(f.width) && or(f.height)
          ? [
              [d + e.width * i[0], h + e.height * i[1]],
              [d + f.width - e.width + e.width * i[0], h + f.height - e.height + e.height * i[1]],
            ]
          : a
    } else (s?.('005', oi.error005()), (a = o))
  else if (e.extent && l && e.extent !== 'parent') {
    const f = t.get(l),
      { x: d, y: h } = _s(f, i).positionAbsolute
    a = [
      [e.extent[0][0] + d, e.extent[0][1] + h],
      [e.extent[1][0] + d, e.extent[1][1] + h],
    ]
  }
  let c = { x: 0, y: 0 }
  if (l) {
    const f = t.get(l)
    c = _s(f, i).positionAbsolute
  }
  const u = a && a !== 'parent' ? Z0(n, a) : n
  return { position: { x: u.x - c.x, y: u.y - c.y }, positionAbsolute: u }
}
function nh({ nodeId: e, dragItems: n, nodeInternals: t }) {
  const r = n.map((i) => ({
    ...t.get(i.id),
    position: i.position,
    positionAbsolute: i.positionAbsolute,
  }))
  return [e ? r.find((i) => i.id === e) : r[0], r]
}
const rv = (e, n, t, r) => {
  const i = n.querySelectorAll(e)
  if (!i || !i.length) return null
  const s = Array.from(i),
    o = n.getBoundingClientRect(),
    a = { x: o.width * r[0], y: o.height * r[1] }
  return s.map((l) => {
    const c = l.getBoundingClientRect()
    return {
      id: l.getAttribute('data-handleid'),
      position: l.getAttribute('data-handlepos'),
      x: (c.left - o.left - a.x) / t,
      y: (c.top - o.top - a.y) / t,
      ...Y0(l),
    }
  })
}
function fa(e, n, t) {
  return t === void 0
    ? t
    : (r) => {
        const i = n().nodeInternals.get(e)
        i && t(r, { ...i })
      }
}
function Up({ id: e, store: n, unselect: t = !1, nodeRef: r }) {
  const {
      addSelectedNodes: i,
      unselectNodesAndEdges: s,
      multiSelectionActive: o,
      nodeInternals: a,
      onError: l,
    } = n.getState(),
    c = a.get(e)
  if (!c) {
    l?.('012', oi.error012(e))
    return
  }
  ;(n.setState({ nodesSelectionActive: !1 }),
    c.selected
      ? (t || (c.selected && o)) &&
        (s({ nodes: [c], edges: [] }), requestAnimationFrame(() => r?.current?.blur()))
      : i([e]))
}
function dB() {
  const e = sn()
  return Y.useCallback(({ sourceEvent: t }) => {
    const { transform: r, snapGrid: i, snapToGrid: s } = e.getState(),
      o = t.touches ? t.touches[0].clientX : t.clientX,
      a = t.touches ? t.touches[0].clientY : t.clientY,
      l = { x: (o - r[0]) / r[2], y: (a - r[1]) / r[2] }
    return {
      xSnapped: s ? i[0] * Math.round(l.x / i[0]) : l.x,
      ySnapped: s ? i[1] * Math.round(l.y / i[1]) : l.y,
      ...l,
    }
  }, [])
}
function rh(e) {
  return (n, t, r) => e?.(n, r)
}
function J6({
  nodeRef: e,
  disabled: n = !1,
  noDragClassName: t,
  handleSelector: r,
  nodeId: i,
  isSelectable: s,
  selectNodesOnDrag: o,
}) {
  const a = sn(),
    [l, c] = Y.useState(!1),
    u = Y.useRef([]),
    f = Y.useRef({ x: null, y: null }),
    d = Y.useRef(0),
    h = Y.useRef(null),
    p = Y.useRef({ x: 0, y: 0 }),
    g = Y.useRef(null),
    m = Y.useRef(!1),
    y = Y.useRef(!1),
    b = Y.useRef(!1),
    w = dB()
  return (
    Y.useEffect(() => {
      if (e?.current) {
        const C = _m(e.current),
          T = ({ x: E, y: O }) => {
            const {
              nodeInternals: P,
              onNodeDrag: $,
              onSelectionDrag: F,
              updateNodePositions: M,
              nodeExtent: R,
              snapGrid: k,
              snapToGrid: v,
              nodeOrigin: x,
              onError: _,
            } = a.getState()
            f.current = { x: E, y: O }
            let S = !1,
              A = { x: 0, y: 0, x2: 0, y2: 0 }
            if (u.current.length > 1 && R) {
              const L = Kf(u.current, x)
              A = ul(L)
            }
            if (
              ((u.current = u.current.map((L) => {
                const H = { x: E - L.distance.x, y: O - L.distance.y }
                v && ((H.x = k[0] * Math.round(H.x / k[0])), (H.y = k[1] * Math.round(H.y / k[1])))
                const U = [
                  [R[0][0], R[0][1]],
                  [R[1][0], R[1][1]],
                ]
                u.current.length > 1 &&
                  R &&
                  !L.extent &&
                  ((U[0][0] = L.positionAbsolute.x - A.x + R[0][0]),
                  (U[1][0] = L.positionAbsolute.x + (L.width ?? 0) - A.x2 + R[1][0]),
                  (U[0][1] = L.positionAbsolute.y - A.y + R[0][1]),
                  (U[1][1] = L.positionAbsolute.y + (L.height ?? 0) - A.y2 + R[1][1]))
                const K = Z6(L, H, P, U, x, _)
                return (
                  (S = S || L.position.x !== K.position.x || L.position.y !== K.position.y),
                  (L.position = K.position),
                  (L.positionAbsolute = K.positionAbsolute),
                  L
                )
              })),
              !S)
            )
              return
            ;(M(u.current, !0, !0), c(!0))
            const j = i ? $ : rh(F)
            if (j && g.current) {
              const [L, H] = nh({ nodeId: i, dragItems: u.current, nodeInternals: P })
              j(g.current, L, H)
            }
          },
          I = () => {
            if (!h.current) return
            const [E, O] = b6(p.current, h.current)
            if (E !== 0 || O !== 0) {
              const { transform: P, panBy: $ } = a.getState()
              ;((f.current.x = (f.current.x ?? 0) - E / P[2]),
                (f.current.y = (f.current.y ?? 0) - O / P[2]),
                $({ x: E, y: O }) && T(f.current))
            }
            d.current = requestAnimationFrame(I)
          },
          B = (E) => {
            const {
              nodeInternals: O,
              multiSelectionActive: P,
              nodesDraggable: $,
              unselectNodesAndEdges: F,
              onNodeDragStart: M,
              onSelectionDragStart: R,
            } = a.getState()
            y.current = !0
            const k = i ? M : rh(R)
            ;((!o || !s) && !P && i && (O.get(i)?.selected || F()),
              i && s && o && Up({ id: i, store: a, nodeRef: e }))
            const v = w(E)
            if (((f.current = v), (u.current = uB(O, $, v, i)), k && u.current)) {
              const [x, _] = nh({ nodeId: i, dragItems: u.current, nodeInternals: O })
              k(E.sourceEvent, x, _)
            }
          }
        if (n) C.on('.drag', null)
        else {
          const E = xk()
            .on('start', (O) => {
              const { domNode: P, nodeDragThreshold: $ } = a.getState()
              ;($ === 0 && B(O), (b.current = !1))
              const F = w(O)
              ;((f.current = F),
                (h.current = P?.getBoundingClientRect() || null),
                (p.current = ji(O.sourceEvent, h.current)))
            })
            .on('drag', (O) => {
              const P = w(O),
                { autoPanOnNodeDrag: $, nodeDragThreshold: F } = a.getState()
              if (
                (O.sourceEvent.type === 'touchmove' &&
                  O.sourceEvent.touches.length > 1 &&
                  (b.current = !0),
                !b.current)
              ) {
                if ((!m.current && y.current && $ && ((m.current = !0), I()), !y.current)) {
                  const M = P.xSnapped - (f?.current?.x ?? 0),
                    R = P.ySnapped - (f?.current?.y ?? 0)
                  Math.sqrt(M * M + R * R) > F && B(O)
                }
                ;(f.current.x !== P.xSnapped || f.current.y !== P.ySnapped) &&
                  u.current &&
                  y.current &&
                  ((g.current = O.sourceEvent), (p.current = ji(O.sourceEvent, h.current)), T(P))
              }
            })
            .on('end', (O) => {
              if (
                !(!y.current || b.current) &&
                (c(!1),
                (m.current = !1),
                (y.current = !1),
                cancelAnimationFrame(d.current),
                u.current)
              ) {
                const {
                    updateNodePositions: P,
                    nodeInternals: $,
                    onNodeDragStop: F,
                    onSelectionDragStop: M,
                  } = a.getState(),
                  R = i ? F : rh(M)
                if ((P(u.current, !1, !1), R)) {
                  const [k, v] = nh({ nodeId: i, dragItems: u.current, nodeInternals: $ })
                  R(O.sourceEvent, k, v)
                }
              }
            })
            .filter((O) => {
              const P = O.target
              return !O.button && (!t || !nv(P, `.${t}`, e)) && (!r || nv(P, r, e))
            })
          return (
            C.call(E),
            () => {
              C.on('.drag', null)
            }
          )
        }
      }
    }, [e, n, t, r, s, a, i, o, w]),
    l
  )
}
function Q6() {
  const e = sn()
  return Y.useCallback((t) => {
    const {
        nodeInternals: r,
        nodeExtent: i,
        updateNodePositions: s,
        getNodes: o,
        snapToGrid: a,
        snapGrid: l,
        onError: c,
        nodesDraggable: u,
      } = e.getState(),
      f = o().filter((b) => b.selected && (b.draggable || (u && typeof b.draggable > 'u'))),
      d = a ? l[0] : 5,
      h = a ? l[1] : 5,
      p = t.isShiftPressed ? 4 : 1,
      g = t.x * d * p,
      m = t.y * h * p,
      y = f.map((b) => {
        if (b.positionAbsolute) {
          const w = { x: b.positionAbsolute.x + g, y: b.positionAbsolute.y + m }
          a && ((w.x = l[0] * Math.round(w.x / l[0])), (w.y = l[1] * Math.round(w.y / l[1])))
          const { positionAbsolute: C, position: T } = Z6(b, w, r, i, void 0, c)
          ;((b.position = T), (b.positionAbsolute = C))
        }
        return b
      })
    s(y, !0, !1)
  }, [])
}
const ko = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 },
}
var da = (e) => {
  const n = ({
    id: t,
    type: r,
    data: i,
    xPos: s,
    yPos: o,
    xPosOrigin: a,
    yPosOrigin: l,
    selected: c,
    onClick: u,
    onMouseEnter: f,
    onMouseMove: d,
    onMouseLeave: h,
    onContextMenu: p,
    onDoubleClick: g,
    style: m,
    className: y,
    isDraggable: b,
    isSelectable: w,
    isConnectable: C,
    isFocusable: T,
    selectNodesOnDrag: I,
    sourcePosition: B,
    targetPosition: E,
    hidden: O,
    resizeObserver: P,
    dragHandle: $,
    zIndex: F,
    isParent: M,
    noDragClassName: R,
    noPanClassName: k,
    initialized: v,
    disableKeyboardA11y: x,
    ariaLabel: _,
    rfId: S,
    hasHandleBounds: A,
  }) => {
    const j = sn(),
      L = Y.useRef(null),
      H = Y.useRef(null),
      U = Y.useRef(B),
      K = Y.useRef(E),
      z = Y.useRef(r),
      q = w || b || u || f || d || h,
      D = Q6(),
      N = fa(t, j.getState, f),
      V = fa(t, j.getState, d),
      W = fa(t, j.getState, h),
      J = fa(t, j.getState, p),
      G = fa(t, j.getState, g),
      Z = (X) => {
        const { nodeDragThreshold: Q } = j.getState()
        if ((w && (!I || !b || Q > 0) && Up({ id: t, store: j, nodeRef: L }), u)) {
          const tt = j.getState().nodeInternals.get(t)
          tt && u(X, { ...tt })
        }
      },
      rt = (X) => {
        if (!Bp(X) && !x)
          if (S6.includes(X.key) && w) {
            const Q = X.key === 'Escape'
            Up({ id: t, store: j, unselect: Q, nodeRef: L })
          } else
            b &&
              c &&
              Object.prototype.hasOwnProperty.call(ko, X.key) &&
              (j.setState({
                ariaLiveMessage: `Moved selected node ${X.key.replace('Arrow', '').toLowerCase()}. New position, x: ${~~s}, y: ${~~o}`,
              }),
              D({ x: ko[X.key].x, y: ko[X.key].y, isShiftPressed: X.shiftKey }))
      }
    ;(Y.useEffect(
      () => () => {
        H.current && (P?.unobserve(H.current), (H.current = null))
      },
      [],
    ),
      Y.useEffect(() => {
        if (L.current && !O) {
          const X = L.current
          ;(!v || !A || H.current !== X) &&
            (H.current && P?.unobserve(H.current), P?.observe(X), (H.current = X))
        }
      }, [O, v, A]),
      Y.useEffect(() => {
        const X = z.current !== r,
          Q = U.current !== B,
          tt = K.current !== E
        L.current &&
          (X || Q || tt) &&
          (X && (z.current = r),
          Q && (U.current = B),
          tt && (K.current = E),
          j.getState().updateNodeDimensions([{ id: t, nodeElement: L.current, forceUpdate: !0 }]))
      }, [t, r, B, E]))
    const nt = J6({
      nodeRef: L,
      disabled: O || !b,
      noDragClassName: R,
      handleSelector: $,
      nodeId: t,
      isSelectable: w,
      selectNodesOnDrag: I,
    })
    return O
      ? null
      : ut.createElement(
          'div',
          {
            className: Sn([
              'react-flow__node',
              `react-flow__node-${r}`,
              { [k]: b },
              y,
              { selected: c, selectable: w, parent: M, dragging: nt },
            ]),
            ref: L,
            style: {
              zIndex: F,
              transform: `translate(${a}px,${l}px)`,
              pointerEvents: q ? 'all' : 'none',
              visibility: v ? 'visible' : 'hidden',
              ...m,
            },
            'data-id': t,
            'data-testid': `rf__node-${t}`,
            onMouseEnter: N,
            onMouseMove: V,
            onMouseLeave: W,
            onContextMenu: J,
            onClick: Z,
            onDoubleClick: G,
            onKeyDown: T ? rt : void 0,
            tabIndex: T ? 0 : void 0,
            role: T ? 'button' : void 0,
            'aria-describedby': x ? void 0 : `${V6}-${S}`,
            'aria-label': _,
          },
          ut.createElement(
            MF,
            { value: t },
            ut.createElement(e, {
              id: t,
              data: i,
              type: r,
              xPos: s,
              yPos: o,
              selected: c,
              isConnectable: C,
              sourcePosition: B,
              targetPosition: E,
              dragging: nt,
              dragHandle: $,
              zIndex: F,
            }),
          ),
        )
  }
  return ((n.displayName = 'NodeWrapper'), Y.memo(n))
}
const hB = (e) => {
  const n = e.getNodes().filter((t) => t.selected)
  return {
    ...Kf(n, e.nodeOrigin),
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`,
    userSelectionActive: e.userSelectionActive,
  }
}
function pB({ onSelectionContextMenu: e, noPanClassName: n, disableKeyboardA11y: t }) {
  const r = sn(),
    { width: i, height: s, x: o, y: a, transformString: l, userSelectionActive: c } = Ne(hB, dn),
    u = Q6(),
    f = Y.useRef(null)
  if (
    (Y.useEffect(() => {
      t || f.current?.focus({ preventScroll: !0 })
    }, [t]),
    J6({ nodeRef: f }),
    c || !i || !s)
  )
    return null
  const d = e
      ? (p) => {
          const g = r
            .getState()
            .getNodes()
            .filter((m) => m.selected)
          e(p, g)
        }
      : void 0,
    h = (p) => {
      Object.prototype.hasOwnProperty.call(ko, p.key) &&
        u({ x: ko[p.key].x, y: ko[p.key].y, isShiftPressed: p.shiftKey })
    }
  return ut.createElement(
    'div',
    {
      className: Sn(['react-flow__nodesselection', 'react-flow__container', n]),
      style: { transform: l },
    },
    ut.createElement('div', {
      ref: f,
      className: 'react-flow__nodesselection-rect',
      onContextMenu: d,
      tabIndex: t ? void 0 : -1,
      onKeyDown: t ? void 0 : h,
      style: { width: i, height: s, top: a, left: o },
    }),
  )
}
var mB = Y.memo(pB)
const gB = (e) => e.nodesSelectionActive,
  t5 = ({
    children: e,
    onPaneClick: n,
    onPaneMouseEnter: t,
    onPaneMouseMove: r,
    onPaneMouseLeave: i,
    onPaneContextMenu: s,
    onPaneScroll: o,
    deleteKeyCode: a,
    onMove: l,
    onMoveStart: c,
    onMoveEnd: u,
    selectionKeyCode: f,
    selectionOnDrag: d,
    selectionMode: h,
    onSelectionStart: p,
    onSelectionEnd: g,
    multiSelectionKeyCode: m,
    panActivationKeyCode: y,
    zoomActivationKeyCode: b,
    elementsSelectable: w,
    zoomOnScroll: C,
    zoomOnPinch: T,
    panOnScroll: I,
    panOnScrollSpeed: B,
    panOnScrollMode: E,
    zoomOnDoubleClick: O,
    panOnDrag: P,
    defaultViewport: $,
    translateExtent: F,
    minZoom: M,
    maxZoom: R,
    preventScrolling: k,
    onSelectionContextMenu: v,
    noWheelClassName: x,
    noPanClassName: _,
    disableKeyboardA11y: S,
  }) => {
    const A = Ne(gB),
      j = dl(f),
      L = dl(y),
      H = L || P,
      U = L || I,
      K = j || (d && H !== !0)
    return (
      eB({ deleteKeyCode: a, multiSelectionKeyCode: m }),
      ut.createElement(
        sB,
        {
          onMove: l,
          onMoveStart: c,
          onMoveEnd: u,
          onPaneContextMenu: s,
          elementsSelectable: w,
          zoomOnScroll: C,
          zoomOnPinch: T,
          panOnScroll: U,
          panOnScrollSpeed: B,
          panOnScrollMode: E,
          zoomOnDoubleClick: O,
          panOnDrag: !j && H,
          defaultViewport: $,
          translateExtent: F,
          minZoom: M,
          maxZoom: R,
          zoomActivationKeyCode: b,
          preventScrolling: k,
          noWheelClassName: x,
          noPanClassName: _,
        },
        ut.createElement(
          X6,
          {
            onSelectionStart: p,
            onSelectionEnd: g,
            onPaneClick: n,
            onPaneMouseEnter: t,
            onPaneMouseMove: r,
            onPaneMouseLeave: i,
            onPaneContextMenu: s,
            onPaneScroll: o,
            panOnDrag: H,
            isSelecting: !!K,
            selectionMode: h,
          },
          e,
          A &&
            ut.createElement(mB, {
              onSelectionContextMenu: v,
              noPanClassName: _,
              disableKeyboardA11y: S,
            }),
        ),
      )
    )
  }
t5.displayName = 'FlowRenderer'
var yB = Y.memo(t5)
function bB(e) {
  return Ne(
    Y.useCallback(
      (t) =>
        e
          ? A6(t.nodeInternals, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0)
          : t.getNodes(),
      [e],
    ),
  )
}
function vB(e) {
  const n = {
      input: da(e.input || F6),
      default: da(e.default || Hp),
      output: da(e.output || z6),
      group: da(e.group || rg),
    },
    t = {},
    r = Object.keys(e)
      .filter((i) => !['input', 'default', 'output', 'group'].includes(i))
      .reduce((i, s) => ((i[s] = da(e[s] || Hp)), i), t)
  return { ...n, ...r }
}
const wB = ({ x: e, y: n, width: t, height: r, origin: i }) =>
    !t || !r
      ? { x: e, y: n }
      : i[0] < 0 || i[1] < 0 || i[0] > 1 || i[1] > 1
        ? { x: e, y: n }
        : { x: e - t * i[0], y: n - r * i[1] },
  xB = (e) => ({
    nodesDraggable: e.nodesDraggable,
    nodesConnectable: e.nodesConnectable,
    nodesFocusable: e.nodesFocusable,
    elementsSelectable: e.elementsSelectable,
    updateNodeDimensions: e.updateNodeDimensions,
    onError: e.onError,
  }),
  e5 = (e) => {
    const {
        nodesDraggable: n,
        nodesConnectable: t,
        nodesFocusable: r,
        elementsSelectable: i,
        updateNodeDimensions: s,
        onError: o,
      } = Ne(xB, dn),
      a = bB(e.onlyRenderVisibleElements),
      l = Y.useRef(),
      c = Y.useMemo(() => {
        if (typeof ResizeObserver > 'u') return null
        const u = new ResizeObserver((f) => {
          const d = f.map((h) => ({
            id: h.target.getAttribute('data-id'),
            nodeElement: h.target,
            forceUpdate: !0,
          }))
          s(d)
        })
        return ((l.current = u), u)
      }, [])
    return (
      Y.useEffect(
        () => () => {
          l?.current?.disconnect()
        },
        [],
      ),
      ut.createElement(
        'div',
        { className: 'react-flow__nodes', style: sg },
        a.map((u) => {
          let f = u.type || 'default'
          e.nodeTypes[f] || (o?.('003', oi.error003(f)), (f = 'default'))
          const d = e.nodeTypes[f] || e.nodeTypes.default,
            h = !!(u.draggable || (n && typeof u.draggable > 'u')),
            p = !!(u.selectable || (i && typeof u.selectable > 'u')),
            g = !!(u.connectable || (t && typeof u.connectable > 'u')),
            m = !!(u.focusable || (r && typeof u.focusable > 'u')),
            y = e.nodeExtent ? Z0(u.positionAbsolute, e.nodeExtent) : u.positionAbsolute,
            b = y?.x ?? 0,
            w = y?.y ?? 0,
            C = wB({ x: b, y: w, width: u.width ?? 0, height: u.height ?? 0, origin: e.nodeOrigin })
          return ut.createElement(d, {
            key: u.id,
            id: u.id,
            className: u.className,
            style: u.style,
            type: f,
            data: u.data,
            sourcePosition: u.sourcePosition || Yt.Bottom,
            targetPosition: u.targetPosition || Yt.Top,
            hidden: u.hidden,
            xPos: b,
            yPos: w,
            xPosOrigin: C.x,
            yPosOrigin: C.y,
            selectNodesOnDrag: e.selectNodesOnDrag,
            onClick: e.onNodeClick,
            onMouseEnter: e.onNodeMouseEnter,
            onMouseMove: e.onNodeMouseMove,
            onMouseLeave: e.onNodeMouseLeave,
            onContextMenu: e.onNodeContextMenu,
            onDoubleClick: e.onNodeDoubleClick,
            selected: !!u.selected,
            isDraggable: h,
            isSelectable: p,
            isConnectable: g,
            isFocusable: m,
            resizeObserver: c,
            dragHandle: u.dragHandle,
            zIndex: u[We]?.z ?? 0,
            isParent: !!u[We]?.isParent,
            noDragClassName: e.noDragClassName,
            noPanClassName: e.noPanClassName,
            initialized: !!u.width && !!u.height,
            rfId: e.rfId,
            disableKeyboardA11y: e.disableKeyboardA11y,
            ariaLabel: u.ariaLabel,
            hasHandleBounds: !!u[We]?.handleBounds,
          })
        }),
      )
    )
  }
e5.displayName = 'NodeRenderer'
var SB = Y.memo(e5)
const _B = (e, n, t) => (t === Yt.Left ? e - n : t === Yt.Right ? e + n : e),
  kB = (e, n, t) => (t === Yt.Top ? e - n : t === Yt.Bottom ? e + n : e),
  iv = 'react-flow__edgeupdater',
  sv = ({
    position: e,
    centerX: n,
    centerY: t,
    radius: r = 10,
    onMouseDown: i,
    onMouseEnter: s,
    onMouseOut: o,
    type: a,
  }) =>
    ut.createElement('circle', {
      onMouseDown: i,
      onMouseEnter: s,
      onMouseOut: o,
      className: Sn([iv, `${iv}-${a}`]),
      cx: _B(n, r, e),
      cy: kB(t, r, e),
      r,
      stroke: 'transparent',
      fill: 'transparent',
    }),
  CB = () => !0
var to = (e) => {
  const n = ({
    id: t,
    className: r,
    type: i,
    data: s,
    onClick: o,
    onEdgeDoubleClick: a,
    selected: l,
    animated: c,
    label: u,
    labelStyle: f,
    labelShowBg: d,
    labelBgStyle: h,
    labelBgPadding: p,
    labelBgBorderRadius: g,
    style: m,
    source: y,
    target: b,
    sourceX: w,
    sourceY: C,
    targetX: T,
    targetY: I,
    sourcePosition: B,
    targetPosition: E,
    elementsSelectable: O,
    hidden: P,
    sourceHandleId: $,
    targetHandleId: F,
    onContextMenu: M,
    onMouseEnter: R,
    onMouseMove: k,
    onMouseLeave: v,
    reconnectRadius: x,
    onReconnect: _,
    onReconnectStart: S,
    onReconnectEnd: A,
    markerEnd: j,
    markerStart: L,
    rfId: H,
    ariaLabel: U,
    isFocusable: K,
    isReconnectable: z,
    pathOptions: q,
    interactionWidth: D,
    disableKeyboardA11y: N,
  }) => {
    const V = Y.useRef(null),
      [W, J] = Y.useState(!1),
      [G, Z] = Y.useState(!1),
      rt = sn(),
      nt = Y.useMemo(() => `url('#${$p(L, H)}')`, [L, H]),
      X = Y.useMemo(() => `url('#${$p(j, H)}')`, [j, H])
    if (P) return null
    const Q = (Mt) => {
        const {
            edges: Ot,
            addSelectedEdges: Ct,
            unselectNodesAndEdges: xt,
            multiSelectionActive: Rt,
          } = rt.getState(),
          It = Ot.find((Pt) => Pt.id === t)
        It &&
          (O &&
            (rt.setState({ nodesSelectionActive: !1 }),
            It.selected && Rt ? (xt({ nodes: [], edges: [It] }), V.current?.blur()) : Ct([t])),
          o && o(Mt, It))
      },
      tt = ua(t, rt.getState, a),
      st = ua(t, rt.getState, M),
      ot = ua(t, rt.getState, R),
      at = ua(t, rt.getState, k),
      ht = ua(t, rt.getState, v),
      dt = (Mt, Ot) => {
        if (Mt.button !== 0) return
        const { edges: Ct, isValidConnection: xt } = rt.getState(),
          Rt = Ot ? b : y,
          It = (Ot ? F : $) || null,
          Pt = Ot ? 'target' : 'source',
          ae = xt || CB,
          Se = Ot,
          zt = Ct.find((Lt) => Lt.id === t)
        ;(Z(!0), S?.(Mt, zt, Pt))
        const be = (Lt) => {
          ;(Z(!1), A?.(Lt, zt, Pt))
        }
        I6({
          event: Mt,
          handleId: It,
          nodeId: Rt,
          onConnect: (Lt) => _?.(zt, Lt),
          isTarget: Se,
          getState: rt.getState,
          setState: rt.setState,
          isValidConnection: ae,
          edgeUpdaterType: Pt,
          onReconnectEnd: be,
        })
      },
      mt = (Mt) => dt(Mt, !0),
      bt = (Mt) => dt(Mt, !1),
      yt = () => J(!0),
      vt = () => J(!1),
      Nt = !O && !o,
      Dt = (Mt) => {
        if (!N && S6.includes(Mt.key) && O) {
          const { unselectNodesAndEdges: Ot, addSelectedEdges: Ct, edges: xt } = rt.getState()
          Mt.key === 'Escape'
            ? (V.current?.blur(), Ot({ edges: [xt.find((It) => It.id === t)] }))
            : Ct([t])
        }
      }
    return ut.createElement(
      'g',
      {
        className: Sn([
          'react-flow__edge',
          `react-flow__edge-${i}`,
          r,
          { selected: l, animated: c, inactive: Nt, updating: W },
        ]),
        onClick: Q,
        onDoubleClick: tt,
        onContextMenu: st,
        onMouseEnter: ot,
        onMouseMove: at,
        onMouseLeave: ht,
        onKeyDown: K ? Dt : void 0,
        tabIndex: K ? 0 : void 0,
        role: K ? 'button' : 'img',
        'data-testid': `rf__edge-${t}`,
        'aria-label': U === null ? void 0 : U || `Edge from ${y} to ${b}`,
        'aria-describedby': K ? `${H6}-${H}` : void 0,
        ref: V,
      },
      !G &&
        ut.createElement(e, {
          id: t,
          source: y,
          target: b,
          selected: l,
          animated: c,
          label: u,
          labelStyle: f,
          labelShowBg: d,
          labelBgStyle: h,
          labelBgPadding: p,
          labelBgBorderRadius: g,
          data: s,
          style: m,
          sourceX: w,
          sourceY: C,
          targetX: T,
          targetY: I,
          sourcePosition: B,
          targetPosition: E,
          sourceHandleId: $,
          targetHandleId: F,
          markerStart: nt,
          markerEnd: X,
          pathOptions: q,
          interactionWidth: D,
        }),
      z &&
        ut.createElement(
          ut.Fragment,
          null,
          (z === 'source' || z === !0) &&
            ut.createElement(sv, {
              position: B,
              centerX: w,
              centerY: C,
              radius: x,
              onMouseDown: mt,
              onMouseEnter: yt,
              onMouseOut: vt,
              type: 'source',
            }),
          (z === 'target' || z === !0) &&
            ut.createElement(sv, {
              position: E,
              centerX: T,
              centerY: I,
              radius: x,
              onMouseDown: bt,
              onMouseEnter: yt,
              onMouseOut: vt,
              type: 'target',
            }),
        ),
    )
  }
  return ((n.displayName = 'EdgeWrapper'), Y.memo(n))
}
function MB(e) {
  const n = {
      default: to(e.default || Eu),
      straight: to(e.bezier || tg),
      step: to(e.step || Q0),
      smoothstep: to(e.step || Wf),
      simplebezier: to(e.simplebezier || J0),
    },
    t = {},
    r = Object.keys(e)
      .filter((i) => !['default', 'bezier'].includes(i))
      .reduce((i, s) => ((i[s] = to(e[s] || Eu)), i), t)
  return { ...n, ...r }
}
function ov(e, n, t = null) {
  const r = (t?.x || 0) + n.x,
    i = (t?.y || 0) + n.y,
    s = t?.width || n.width,
    o = t?.height || n.height
  switch (e) {
    case Yt.Top:
      return { x: r + s / 2, y: i }
    case Yt.Right:
      return { x: r + s, y: i + o / 2 }
    case Yt.Bottom:
      return { x: r + s / 2, y: i + o }
    case Yt.Left:
      return { x: r, y: i + o / 2 }
  }
}
function av(e, n) {
  return e ? (e.length === 1 || !n ? e[0] : (n && e.find((t) => t.id === n)) || null) : null
}
const EB = (e, n, t, r, i, s) => {
  const o = ov(t, e, n),
    a = ov(s, r, i)
  return { sourceX: o.x, sourceY: o.y, targetX: a.x, targetY: a.y }
}
function TB({
  sourcePos: e,
  targetPos: n,
  sourceWidth: t,
  sourceHeight: r,
  targetWidth: i,
  targetHeight: s,
  width: o,
  height: a,
  transform: l,
}) {
  const c = {
    x: Math.min(e.x, n.x),
    y: Math.min(e.y, n.y),
    x2: Math.max(e.x + t, n.x + i),
    y2: Math.max(e.y + r, n.y + s),
  }
  ;(c.x === c.x2 && (c.x2 += 1), c.y === c.y2 && (c.y2 += 1))
  const u = ul({ x: (0 - l[0]) / l[2], y: (0 - l[1]) / l[2], width: o / l[2], height: a / l[2] }),
    f = Math.max(0, Math.min(u.x2, c.x2) - Math.max(u.x, c.x)),
    d = Math.max(0, Math.min(u.y2, c.y2) - Math.max(u.y, c.y))
  return Math.ceil(f * d) > 0
}
function lv(e) {
  const n = e?.[We]?.handleBounds || null,
    t =
      n &&
      e?.width &&
      e?.height &&
      typeof e?.positionAbsolute?.x < 'u' &&
      typeof e?.positionAbsolute?.y < 'u'
  return [
    {
      x: e?.positionAbsolute?.x || 0,
      y: e?.positionAbsolute?.y || 0,
      width: e?.width || 0,
      height: e?.height || 0,
    },
    n,
    !!t,
  ]
}
const AB = [{ level: 0, isMaxLevel: !0, edges: [] }]
function RB(e, n, t = !1) {
  let r = -1
  const i = e.reduce((o, a) => {
      const l = or(a.zIndex)
      let c = l ? a.zIndex : 0
      if (t) {
        const u = n.get(a.target),
          f = n.get(a.source),
          d = a.selected || u?.selected || f?.selected,
          h = Math.max(f?.[We]?.z || 0, u?.[We]?.z || 0, 1e3)
        c = (l ? a.zIndex : 0) + (d ? h : 0)
      }
      return (o[c] ? o[c].push(a) : (o[c] = [a]), (r = c > r ? c : r), o)
    }, {}),
    s = Object.entries(i).map(([o, a]) => {
      const l = +o
      return { edges: a, level: l, isMaxLevel: l === r }
    })
  return s.length === 0 ? AB : s
}
function OB(e, n, t) {
  const r = Ne(
    Y.useCallback(
      (i) =>
        e
          ? i.edges.filter((s) => {
              const o = n.get(s.source),
                a = n.get(s.target)
              return (
                o?.width &&
                o?.height &&
                a?.width &&
                a?.height &&
                TB({
                  sourcePos: o.positionAbsolute || { x: 0, y: 0 },
                  targetPos: a.positionAbsolute || { x: 0, y: 0 },
                  sourceWidth: o.width,
                  sourceHeight: o.height,
                  targetWidth: a.width,
                  targetHeight: a.height,
                  width: i.width,
                  height: i.height,
                  transform: i.transform,
                })
              )
            })
          : i.edges,
      [e, n],
    ),
  )
  return RB(r, n, t)
}
const PB = ({ color: e = 'none', strokeWidth: n = 1 }) =>
    ut.createElement('polyline', {
      style: { stroke: e, strokeWidth: n },
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      fill: 'none',
      points: '-5,-4 0,0 -5,4',
    }),
  NB = ({ color: e = 'none', strokeWidth: n = 1 }) =>
    ut.createElement('polyline', {
      style: { stroke: e, fill: e, strokeWidth: n },
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      points: '-5,-4 0,0 -5,4 -5,-4',
    }),
  cv = { [Mu.Arrow]: PB, [Mu.ArrowClosed]: NB }
function IB(e) {
  const n = sn()
  return Y.useMemo(
    () =>
      Object.prototype.hasOwnProperty.call(cv, e)
        ? cv[e]
        : (n.getState().onError?.('009', oi.error009(e)), null),
    [e],
  )
}
const DB = ({
    id: e,
    type: n,
    color: t,
    width: r = 12.5,
    height: i = 12.5,
    markerUnits: s = 'strokeWidth',
    strokeWidth: o,
    orient: a = 'auto-start-reverse',
  }) => {
    const l = IB(n)
    return l
      ? ut.createElement(
          'marker',
          {
            className: 'react-flow__arrowhead',
            id: e,
            markerWidth: `${r}`,
            markerHeight: `${i}`,
            viewBox: '-10 -10 20 20',
            markerUnits: s,
            orient: a,
            refX: '0',
            refY: '0',
          },
          ut.createElement(l, { color: t, strokeWidth: o }),
        )
      : null
  },
  jB =
    ({ defaultColor: e, rfId: n }) =>
    (t) => {
      const r = []
      return t.edges
        .reduce(
          (i, s) => (
            [s.markerStart, s.markerEnd].forEach((o) => {
              if (o && typeof o == 'object') {
                const a = $p(o, n)
                r.includes(a) || (i.push({ id: a, color: o.color || e, ...o }), r.push(a))
              }
            }),
            i
          ),
          [],
        )
        .sort((i, s) => i.id.localeCompare(s.id))
    },
  n5 = ({ defaultColor: e, rfId: n }) => {
    const t = Ne(
      Y.useCallback(jB({ defaultColor: e, rfId: n }), [e, n]),
      (r, i) => !(r.length !== i.length || r.some((s, o) => s.id !== i[o].id)),
    )
    return ut.createElement(
      'defs',
      null,
      t.map((r) =>
        ut.createElement(DB, {
          id: r.id,
          key: r.id,
          type: r.type,
          color: r.color,
          width: r.width,
          height: r.height,
          markerUnits: r.markerUnits,
          strokeWidth: r.strokeWidth,
          orient: r.orient,
        }),
      ),
    )
  }
n5.displayName = 'MarkerDefinitions'
var LB = Y.memo(n5)
const FB = (e) => ({
    nodesConnectable: e.nodesConnectable,
    edgesFocusable: e.edgesFocusable,
    edgesUpdatable: e.edgesUpdatable,
    elementsSelectable: e.elementsSelectable,
    width: e.width,
    height: e.height,
    connectionMode: e.connectionMode,
    nodeInternals: e.nodeInternals,
    onError: e.onError,
  }),
  r5 = ({
    defaultMarkerColor: e,
    onlyRenderVisibleElements: n,
    elevateEdgesOnSelect: t,
    rfId: r,
    edgeTypes: i,
    noPanClassName: s,
    onEdgeContextMenu: o,
    onEdgeMouseEnter: a,
    onEdgeMouseMove: l,
    onEdgeMouseLeave: c,
    onEdgeClick: u,
    onEdgeDoubleClick: f,
    onReconnect: d,
    onReconnectStart: h,
    onReconnectEnd: p,
    reconnectRadius: g,
    children: m,
    disableKeyboardA11y: y,
  }) => {
    const {
        edgesFocusable: b,
        edgesUpdatable: w,
        elementsSelectable: C,
        width: T,
        height: I,
        connectionMode: B,
        nodeInternals: E,
        onError: O,
      } = Ne(FB, dn),
      P = OB(n, E, t)
    return T
      ? ut.createElement(
          ut.Fragment,
          null,
          P.map(({ level: $, edges: F, isMaxLevel: M }) =>
            ut.createElement(
              'svg',
              {
                key: $,
                style: { zIndex: $ },
                width: T,
                height: I,
                className: 'react-flow__edges react-flow__container',
              },
              M && ut.createElement(LB, { defaultColor: e, rfId: r }),
              ut.createElement(
                'g',
                null,
                F.map((R) => {
                  const [k, v, x] = lv(E.get(R.source)),
                    [_, S, A] = lv(E.get(R.target))
                  if (!x || !A) return null
                  let j = R.type || 'default'
                  i[j] || (O?.('011', oi.error011(j)), (j = 'default'))
                  const L = i[j] || i.default,
                    H = B === js.Strict ? S.target : (S.target ?? []).concat(S.source ?? []),
                    U = av(v.source, R.sourceHandle),
                    K = av(H, R.targetHandle),
                    z = U?.position || Yt.Bottom,
                    q = K?.position || Yt.Top,
                    D = !!(R.focusable || (b && typeof R.focusable > 'u')),
                    N = R.reconnectable || R.updatable,
                    V = typeof d < 'u' && (N || (w && typeof N > 'u'))
                  if (!U || !K) return (O?.('008', oi.error008(U, R)), null)
                  const { sourceX: W, sourceY: J, targetX: G, targetY: Z } = EB(k, U, z, _, K, q)
                  return ut.createElement(L, {
                    key: R.id,
                    id: R.id,
                    className: Sn([R.className, s]),
                    type: j,
                    data: R.data,
                    selected: !!R.selected,
                    animated: !!R.animated,
                    hidden: !!R.hidden,
                    label: R.label,
                    labelStyle: R.labelStyle,
                    labelShowBg: R.labelShowBg,
                    labelBgStyle: R.labelBgStyle,
                    labelBgPadding: R.labelBgPadding,
                    labelBgBorderRadius: R.labelBgBorderRadius,
                    style: R.style,
                    source: R.source,
                    target: R.target,
                    sourceHandleId: R.sourceHandle,
                    targetHandleId: R.targetHandle,
                    markerEnd: R.markerEnd,
                    markerStart: R.markerStart,
                    sourceX: W,
                    sourceY: J,
                    targetX: G,
                    targetY: Z,
                    sourcePosition: z,
                    targetPosition: q,
                    elementsSelectable: C,
                    onContextMenu: o,
                    onMouseEnter: a,
                    onMouseMove: l,
                    onMouseLeave: c,
                    onClick: u,
                    onEdgeDoubleClick: f,
                    onReconnect: d,
                    onReconnectStart: h,
                    onReconnectEnd: p,
                    reconnectRadius: g,
                    rfId: r,
                    ariaLabel: R.ariaLabel,
                    isFocusable: D,
                    isReconnectable: V,
                    pathOptions: 'pathOptions' in R ? R.pathOptions : void 0,
                    interactionWidth: R.interactionWidth,
                    disableKeyboardA11y: y,
                  })
                }),
              ),
            ),
          ),
          m,
        )
      : null
  }
r5.displayName = 'EdgeRenderer'
var BB = Y.memo(r5)
const zB = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`
function $B({ children: e }) {
  const n = Ne(zB)
  return ut.createElement(
    'div',
    { className: 'react-flow__viewport react-flow__container', style: { transform: n } },
    e,
  )
}
function VB(e) {
  const n = ig(),
    t = Y.useRef(!1)
  Y.useEffect(() => {
    !t.current && n.viewportInitialized && e && (setTimeout(() => e(n), 1), (t.current = !0))
  }, [e, n.viewportInitialized])
}
const HB = { [Yt.Left]: Yt.Right, [Yt.Right]: Yt.Left, [Yt.Top]: Yt.Bottom, [Yt.Bottom]: Yt.Top },
  i5 = ({
    nodeId: e,
    handleType: n,
    style: t,
    type: r = ki.Bezier,
    CustomComponent: i,
    connectionStatus: s,
  }) => {
    const {
        fromNode: o,
        handleId: a,
        toX: l,
        toY: c,
        connectionMode: u,
      } = Ne(
        Y.useCallback(
          (I) => ({
            fromNode: I.nodeInternals.get(e),
            handleId: I.connectionHandleId,
            toX: (I.connectionPosition.x - I.transform[0]) / I.transform[2],
            toY: (I.connectionPosition.y - I.transform[1]) / I.transform[2],
            connectionMode: I.connectionMode,
          }),
          [e],
        ),
        dn,
      ),
      f = o?.[We]?.handleBounds
    let d = f?.[n]
    if ((u === js.Loose && (d = d || f?.[n === 'source' ? 'target' : 'source']), !o || !d))
      return null
    const h = a ? d.find((I) => I.id === a) : d[0],
      p = h ? h.x + h.width / 2 : (o.width ?? 0) / 2,
      g = h ? h.y + h.height / 2 : (o.height ?? 0),
      m = (o.positionAbsolute?.x ?? 0) + p,
      y = (o.positionAbsolute?.y ?? 0) + g,
      b = h?.position,
      w = b ? HB[b] : null
    if (!b || !w) return null
    if (i)
      return ut.createElement(i, {
        connectionLineType: r,
        connectionLineStyle: t,
        fromNode: o,
        fromHandle: h,
        fromX: m,
        fromY: y,
        toX: l,
        toY: c,
        fromPosition: b,
        toPosition: w,
        connectionStatus: s,
      })
    let C = ''
    const T = {
      sourceX: m,
      sourceY: y,
      sourcePosition: b,
      targetX: l,
      targetY: c,
      targetPosition: w,
    }
    return (
      r === ki.Bezier
        ? ([C] = E6(T))
        : r === ki.Step
          ? ([C] = zp({ ...T, borderRadius: 0 }))
          : r === ki.SmoothStep
            ? ([C] = zp(T))
            : r === ki.SimpleBezier
              ? ([C] = M6(T))
              : (C = `M${m},${y} ${l},${c}`),
      ut.createElement('path', {
        d: C,
        fill: 'none',
        className: 'react-flow__connection-path',
        style: t,
      })
    )
  }
i5.displayName = 'ConnectionLine'
const UB = (e) => ({
  nodeId: e.connectionNodeId,
  handleType: e.connectionHandleType,
  nodesConnectable: e.nodesConnectable,
  connectionStatus: e.connectionStatus,
  width: e.width,
  height: e.height,
})
function qB({ containerStyle: e, style: n, type: t, component: r }) {
  const {
    nodeId: i,
    handleType: s,
    nodesConnectable: o,
    width: a,
    height: l,
    connectionStatus: c,
  } = Ne(UB, dn)
  return !(i && s && a && o)
    ? null
    : ut.createElement(
        'svg',
        {
          style: e,
          width: a,
          height: l,
          className: 'react-flow__edges react-flow__connectionline react-flow__container',
        },
        ut.createElement(
          'g',
          { className: Sn(['react-flow__connection', c]) },
          ut.createElement(i5, {
            nodeId: i,
            handleType: s,
            style: n,
            type: t,
            CustomComponent: r,
            connectionStatus: c,
          }),
        ),
      )
}
function uv(e, n) {
  return (Y.useRef(null), sn(), Y.useMemo(() => n(e), [e]))
}
const s5 = ({
  nodeTypes: e,
  edgeTypes: n,
  onMove: t,
  onMoveStart: r,
  onMoveEnd: i,
  onInit: s,
  onNodeClick: o,
  onEdgeClick: a,
  onNodeDoubleClick: l,
  onEdgeDoubleClick: c,
  onNodeMouseEnter: u,
  onNodeMouseMove: f,
  onNodeMouseLeave: d,
  onNodeContextMenu: h,
  onSelectionContextMenu: p,
  onSelectionStart: g,
  onSelectionEnd: m,
  connectionLineType: y,
  connectionLineStyle: b,
  connectionLineComponent: w,
  connectionLineContainerStyle: C,
  selectionKeyCode: T,
  selectionOnDrag: I,
  selectionMode: B,
  multiSelectionKeyCode: E,
  panActivationKeyCode: O,
  zoomActivationKeyCode: P,
  deleteKeyCode: $,
  onlyRenderVisibleElements: F,
  elementsSelectable: M,
  selectNodesOnDrag: R,
  defaultViewport: k,
  translateExtent: v,
  minZoom: x,
  maxZoom: _,
  preventScrolling: S,
  defaultMarkerColor: A,
  zoomOnScroll: j,
  zoomOnPinch: L,
  panOnScroll: H,
  panOnScrollSpeed: U,
  panOnScrollMode: K,
  zoomOnDoubleClick: z,
  panOnDrag: q,
  onPaneClick: D,
  onPaneMouseEnter: N,
  onPaneMouseMove: V,
  onPaneMouseLeave: W,
  onPaneScroll: J,
  onPaneContextMenu: G,
  onEdgeContextMenu: Z,
  onEdgeMouseEnter: rt,
  onEdgeMouseMove: nt,
  onEdgeMouseLeave: X,
  onReconnect: Q,
  onReconnectStart: tt,
  onReconnectEnd: st,
  reconnectRadius: ot,
  noDragClassName: at,
  noWheelClassName: ht,
  noPanClassName: dt,
  elevateEdgesOnSelect: mt,
  disableKeyboardA11y: bt,
  nodeOrigin: yt,
  nodeExtent: vt,
  rfId: Nt,
}) => {
  const Dt = uv(e, vB),
    Mt = uv(n, MB)
  return (
    VB(s),
    ut.createElement(
      yB,
      {
        onPaneClick: D,
        onPaneMouseEnter: N,
        onPaneMouseMove: V,
        onPaneMouseLeave: W,
        onPaneContextMenu: G,
        onPaneScroll: J,
        deleteKeyCode: $,
        selectionKeyCode: T,
        selectionOnDrag: I,
        selectionMode: B,
        onSelectionStart: g,
        onSelectionEnd: m,
        multiSelectionKeyCode: E,
        panActivationKeyCode: O,
        zoomActivationKeyCode: P,
        elementsSelectable: M,
        onMove: t,
        onMoveStart: r,
        onMoveEnd: i,
        zoomOnScroll: j,
        zoomOnPinch: L,
        zoomOnDoubleClick: z,
        panOnScroll: H,
        panOnScrollSpeed: U,
        panOnScrollMode: K,
        panOnDrag: q,
        defaultViewport: k,
        translateExtent: v,
        minZoom: x,
        maxZoom: _,
        onSelectionContextMenu: p,
        preventScrolling: S,
        noDragClassName: at,
        noWheelClassName: ht,
        noPanClassName: dt,
        disableKeyboardA11y: bt,
      },
      ut.createElement(
        $B,
        null,
        ut.createElement(
          BB,
          {
            edgeTypes: Mt,
            onEdgeClick: a,
            onEdgeDoubleClick: c,
            onlyRenderVisibleElements: F,
            onEdgeContextMenu: Z,
            onEdgeMouseEnter: rt,
            onEdgeMouseMove: nt,
            onEdgeMouseLeave: X,
            onReconnect: Q,
            onReconnectStart: tt,
            onReconnectEnd: st,
            reconnectRadius: ot,
            defaultMarkerColor: A,
            noPanClassName: dt,
            elevateEdgesOnSelect: !!mt,
            disableKeyboardA11y: bt,
            rfId: Nt,
          },
          ut.createElement(qB, { style: b, type: y, component: w, containerStyle: C }),
        ),
        ut.createElement('div', { className: 'react-flow__edgelabel-renderer' }),
        ut.createElement(SB, {
          nodeTypes: Dt,
          onNodeClick: o,
          onNodeDoubleClick: l,
          onNodeMouseEnter: u,
          onNodeMouseMove: f,
          onNodeMouseLeave: d,
          onNodeContextMenu: h,
          selectNodesOnDrag: R,
          onlyRenderVisibleElements: F,
          noPanClassName: dt,
          noDragClassName: at,
          disableKeyboardA11y: bt,
          nodeOrigin: yt,
          nodeExtent: vt,
          rfId: Nt,
        }),
      ),
    )
  )
}
s5.displayName = 'GraphView'
var WB = Y.memo(s5)
const qp = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
  ],
  hi = {
    rfId: '1',
    width: 0,
    height: 0,
    transform: [0, 0, 1],
    nodeInternals: new Map(),
    edges: [],
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: !1,
    hasDefaultEdges: !1,
    d3Zoom: null,
    d3Selection: null,
    d3ZoomHandler: void 0,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: qp,
    nodeExtent: qp,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionNodeId: null,
    connectionHandleId: null,
    connectionHandleType: 'source',
    connectionPosition: { x: 0, y: 0 },
    connectionStatus: null,
    connectionMode: js.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: 'nopan',
    nodeOrigin: [0, 0],
    nodeDragThreshold: 0,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesUpdatable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    fitViewOnInit: !1,
    fitViewOnInitDone: !1,
    fitViewOnInitOptions: void 0,
    onSelectionChange: [],
    multiSelectionActive: !1,
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: '',
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    connectionRadius: 20,
    onError: wF,
    isValidConnection: void 0,
  },
  KB = () =>
    dF(
      (e, n) => ({
        ...hi,
        setNodes: (t) => {
          const { nodeInternals: r, nodeOrigin: i, elevateNodesOnSelect: s } = n()
          e({ nodeInternals: th(t, r, i, s) })
        },
        getNodes: () => Array.from(n().nodeInternals.values()),
        setEdges: (t) => {
          const { defaultEdgeOptions: r = {} } = n()
          e({ edges: t.map((i) => ({ ...r, ...i })) })
        },
        setDefaultNodesAndEdges: (t, r) => {
          const i = typeof t < 'u',
            s = typeof r < 'u',
            o = i ? th(t, new Map(), n().nodeOrigin, n().elevateNodesOnSelect) : new Map()
          e({ nodeInternals: o, edges: s ? r : [], hasDefaultNodes: i, hasDefaultEdges: s })
        },
        updateNodeDimensions: (t) => {
          const {
              onNodesChange: r,
              nodeInternals: i,
              fitViewOnInit: s,
              fitViewOnInitDone: o,
              fitViewOnInitOptions: a,
              domNode: l,
              nodeOrigin: c,
            } = n(),
            u = l?.querySelector('.react-flow__viewport')
          if (!u) return
          const f = window.getComputedStyle(u),
            { m22: d } = new window.DOMMatrixReadOnly(f.transform),
            h = t.reduce((g, m) => {
              const y = i.get(m.id)
              if (y?.hidden) i.set(y.id, { ...y, [We]: { ...y[We], handleBounds: void 0 } })
              else if (y) {
                const b = Y0(m.nodeElement)
                !!(
                  b.width &&
                  b.height &&
                  (y.width !== b.width || y.height !== b.height || m.forceUpdate)
                ) &&
                  (i.set(y.id, {
                    ...y,
                    [We]: {
                      ...y[We],
                      handleBounds: {
                        source: rv('.source', m.nodeElement, d, c),
                        target: rv('.target', m.nodeElement, d, c),
                      },
                    },
                    ...b,
                  }),
                  g.push({ id: y.id, type: 'dimensions', dimensions: b }))
              }
              return g
            }, [])
          q6(i, c)
          const p = o || (s && !o && W6(n, { initial: !0, ...a }))
          ;(e({ nodeInternals: new Map(i), fitViewOnInitDone: p }), h?.length > 0 && r?.(h))
        },
        updateNodePositions: (t, r = !0, i = !1) => {
          const { triggerNodeChanges: s } = n(),
            o = t.map((a) => {
              const l = { id: a.id, type: 'position', dragging: i }
              return (
                r && ((l.positionAbsolute = a.positionAbsolute), (l.position = a.position)),
                l
              )
            })
          s(o)
        },
        triggerNodeChanges: (t) => {
          const {
            onNodesChange: r,
            nodeInternals: i,
            hasDefaultNodes: s,
            nodeOrigin: o,
            getNodes: a,
            elevateNodesOnSelect: l,
          } = n()
          if (t?.length) {
            if (s) {
              const c = G6(t, a()),
                u = th(c, i, o, l)
              e({ nodeInternals: u })
            }
            r?.(t)
          }
        },
        addSelectedNodes: (t) => {
          const { multiSelectionActive: r, edges: i, getNodes: s } = n()
          let o,
            a = null
          ;(r ? (o = t.map((l) => vi(l, !0))) : ((o = ho(s(), t)), (a = ho(i, []))),
            bc({ changedNodes: o, changedEdges: a, get: n, set: e }))
        },
        addSelectedEdges: (t) => {
          const { multiSelectionActive: r, edges: i, getNodes: s } = n()
          let o,
            a = null
          ;(r ? (o = t.map((l) => vi(l, !0))) : ((o = ho(i, t)), (a = ho(s(), []))),
            bc({ changedNodes: a, changedEdges: o, get: n, set: e }))
        },
        unselectNodesAndEdges: ({ nodes: t, edges: r } = {}) => {
          const { edges: i, getNodes: s } = n(),
            o = t || s(),
            a = r || i,
            l = o.map((u) => ((u.selected = !1), vi(u.id, !1))),
            c = a.map((u) => vi(u.id, !1))
          bc({ changedNodes: l, changedEdges: c, get: n, set: e })
        },
        setMinZoom: (t) => {
          const { d3Zoom: r, maxZoom: i } = n()
          ;(r?.scaleExtent([t, i]), e({ minZoom: t }))
        },
        setMaxZoom: (t) => {
          const { d3Zoom: r, minZoom: i } = n()
          ;(r?.scaleExtent([i, t]), e({ maxZoom: t }))
        },
        setTranslateExtent: (t) => {
          ;(n().d3Zoom?.translateExtent(t), e({ translateExtent: t }))
        },
        resetSelectedElements: () => {
          const { edges: t, getNodes: r } = n(),
            s = r()
              .filter((a) => a.selected)
              .map((a) => vi(a.id, !1)),
            o = t.filter((a) => a.selected).map((a) => vi(a.id, !1))
          bc({ changedNodes: s, changedEdges: o, get: n, set: e })
        },
        setNodeExtent: (t) => {
          const { nodeInternals: r } = n()
          ;(r.forEach((i) => {
            i.positionAbsolute = Z0(i.position, t)
          }),
            e({ nodeExtent: t, nodeInternals: new Map(r) }))
        },
        panBy: (t) => {
          const {
            transform: r,
            width: i,
            height: s,
            d3Zoom: o,
            d3Selection: a,
            translateExtent: l,
          } = n()
          if (!o || !a || (!t.x && !t.y)) return !1
          const c = ys.translate(r[0] + t.x, r[1] + t.y).scale(r[2]),
            u = [
              [0, 0],
              [i, s],
            ],
            f = o?.constrain()(c, u, l)
          return (o.transform(a, f), r[0] !== f.x || r[1] !== f.y || r[2] !== f.k)
        },
        cancelConnection: () =>
          e({
            connectionNodeId: hi.connectionNodeId,
            connectionHandleId: hi.connectionHandleId,
            connectionHandleType: hi.connectionHandleType,
            connectionStatus: hi.connectionStatus,
            connectionStartHandle: hi.connectionStartHandle,
            connectionEndHandle: hi.connectionEndHandle,
          }),
        reset: () => e({ ...hi }),
      }),
      Object.is,
    ),
  o5 = ({ children: e }) => {
    const n = Y.useRef(null)
    return (n.current || (n.current = KB()), ut.createElement(hF, { value: n.current }, e))
  }
o5.displayName = 'ReactFlowProvider'
const a5 = ({ children: e }) =>
  Y.useContext(qf) ? ut.createElement(ut.Fragment, null, e) : ut.createElement(o5, null, e)
a5.displayName = 'ReactFlowWrapper'
const GB = { input: F6, default: Hp, output: z6, group: rg },
  XB = { default: Eu, straight: tg, step: Q0, smoothstep: Wf, simplebezier: J0 },
  YB = [0, 0],
  ZB = [15, 15],
  JB = { x: 0, y: 0, zoom: 1 },
  QB = { width: '100%', height: '100%', overflow: 'hidden', position: 'relative', zIndex: 0 },
  tz = Y.forwardRef(
    (
      {
        nodes: e,
        edges: n,
        defaultNodes: t,
        defaultEdges: r,
        className: i,
        nodeTypes: s = GB,
        edgeTypes: o = XB,
        onNodeClick: a,
        onEdgeClick: l,
        onInit: c,
        onMove: u,
        onMoveStart: f,
        onMoveEnd: d,
        onConnect: h,
        onConnectStart: p,
        onConnectEnd: g,
        onClickConnectStart: m,
        onClickConnectEnd: y,
        onNodeMouseEnter: b,
        onNodeMouseMove: w,
        onNodeMouseLeave: C,
        onNodeContextMenu: T,
        onNodeDoubleClick: I,
        onNodeDragStart: B,
        onNodeDrag: E,
        onNodeDragStop: O,
        onNodesDelete: P,
        onEdgesDelete: $,
        onSelectionChange: F,
        onSelectionDragStart: M,
        onSelectionDrag: R,
        onSelectionDragStop: k,
        onSelectionContextMenu: v,
        onSelectionStart: x,
        onSelectionEnd: _,
        connectionMode: S = js.Strict,
        connectionLineType: A = ki.Bezier,
        connectionLineStyle: j,
        connectionLineComponent: L,
        connectionLineContainerStyle: H,
        deleteKeyCode: U = 'Backspace',
        selectionKeyCode: K = 'Shift',
        selectionOnDrag: z = !1,
        selectionMode: q = fl.Full,
        panActivationKeyCode: D = 'Space',
        multiSelectionKeyCode: N = Cu() ? 'Meta' : 'Control',
        zoomActivationKeyCode: V = Cu() ? 'Meta' : 'Control',
        snapToGrid: W = !1,
        snapGrid: J = ZB,
        onlyRenderVisibleElements: G = !1,
        selectNodesOnDrag: Z = !0,
        nodesDraggable: rt,
        nodesConnectable: nt,
        nodesFocusable: X,
        nodeOrigin: Q = YB,
        edgesFocusable: tt,
        edgesUpdatable: st,
        elementsSelectable: ot,
        defaultViewport: at = JB,
        minZoom: ht = 0.5,
        maxZoom: dt = 2,
        translateExtent: mt = qp,
        preventScrolling: bt = !0,
        nodeExtent: yt,
        defaultMarkerColor: vt = '#b1b1b7',
        zoomOnScroll: Nt = !0,
        zoomOnPinch: Dt = !0,
        panOnScroll: Mt = !1,
        panOnScrollSpeed: Ot = 0.5,
        panOnScrollMode: Ct = ds.Free,
        zoomOnDoubleClick: xt = !0,
        panOnDrag: Rt = !0,
        onPaneClick: It,
        onPaneMouseEnter: Pt,
        onPaneMouseMove: ae,
        onPaneMouseLeave: Se,
        onPaneScroll: zt,
        onPaneContextMenu: be,
        children: Ut,
        onEdgeContextMenu: Lt,
        onEdgeDoubleClick: le,
        onEdgeMouseEnter: ce,
        onEdgeMouseMove: Ft,
        onEdgeMouseLeave: Qt,
        onEdgeUpdate: fe,
        onEdgeUpdateStart: qt,
        onEdgeUpdateEnd: Jt,
        onReconnect: me,
        onReconnectStart: Wt,
        onReconnectEnd: it,
        reconnectRadius: ct = 10,
        edgeUpdaterRadius: pt = 10,
        onNodesChange: _t,
        onEdgesChange: Vt,
        noDragClassName: Tt = 'nodrag',
        noWheelClassName: te = 'nowheel',
        noPanClassName: Gt = 'nopan',
        fitView: Ht = !1,
        fitViewOptions: ie,
        connectOnClick: ee = !0,
        attributionPosition: de,
        proOptions: Le,
        defaultEdgeOptions: Te,
        elevateNodesOnSelect: Ge = !0,
        elevateEdgesOnSelect: Xe = !1,
        disableKeyboardA11y: pn = !1,
        autoPanOnConnect: et = !0,
        autoPanOnNodeDrag: ft = !0,
        connectionRadius: gt = 20,
        isValidConnection: wt,
        onError: $t,
        style: Et,
        id: At,
        nodeDragThreshold: ve,
        ...ue
      },
      he,
    ) => {
      const Kt = At || '1'
      return ut.createElement(
        'div',
        {
          ...ue,
          style: { ...Et, ...QB },
          ref: he,
          className: Sn(['react-flow', i]),
          'data-testid': 'rf__wrapper',
          id: At,
        },
        ut.createElement(
          a5,
          null,
          ut.createElement(WB, {
            onInit: c,
            onMove: u,
            onMoveStart: f,
            onMoveEnd: d,
            onNodeClick: a,
            onEdgeClick: l,
            onNodeMouseEnter: b,
            onNodeMouseMove: w,
            onNodeMouseLeave: C,
            onNodeContextMenu: T,
            onNodeDoubleClick: I,
            nodeTypes: s,
            edgeTypes: o,
            connectionLineType: A,
            connectionLineStyle: j,
            connectionLineComponent: L,
            connectionLineContainerStyle: H,
            selectionKeyCode: K,
            selectionOnDrag: z,
            selectionMode: q,
            deleteKeyCode: U,
            multiSelectionKeyCode: N,
            panActivationKeyCode: D,
            zoomActivationKeyCode: V,
            onlyRenderVisibleElements: G,
            selectNodesOnDrag: Z,
            defaultViewport: at,
            translateExtent: mt,
            minZoom: ht,
            maxZoom: dt,
            preventScrolling: bt,
            zoomOnScroll: Nt,
            zoomOnPinch: Dt,
            zoomOnDoubleClick: xt,
            panOnScroll: Mt,
            panOnScrollSpeed: Ot,
            panOnScrollMode: Ct,
            panOnDrag: Rt,
            onPaneClick: It,
            onPaneMouseEnter: Pt,
            onPaneMouseMove: ae,
            onPaneMouseLeave: Se,
            onPaneScroll: zt,
            onPaneContextMenu: be,
            onSelectionContextMenu: v,
            onSelectionStart: x,
            onSelectionEnd: _,
            onEdgeContextMenu: Lt,
            onEdgeDoubleClick: le,
            onEdgeMouseEnter: ce,
            onEdgeMouseMove: Ft,
            onEdgeMouseLeave: Qt,
            onReconnect: me ?? fe,
            onReconnectStart: Wt ?? qt,
            onReconnectEnd: it ?? Jt,
            reconnectRadius: ct ?? pt,
            defaultMarkerColor: vt,
            noDragClassName: Tt,
            noWheelClassName: te,
            noPanClassName: Gt,
            elevateEdgesOnSelect: Xe,
            rfId: Kt,
            disableKeyboardA11y: pn,
            nodeOrigin: Q,
            nodeExtent: yt,
          }),
          ut.createElement(HF, {
            nodes: e,
            edges: n,
            defaultNodes: t,
            defaultEdges: r,
            onConnect: h,
            onConnectStart: p,
            onConnectEnd: g,
            onClickConnectStart: m,
            onClickConnectEnd: y,
            nodesDraggable: rt,
            nodesConnectable: nt,
            nodesFocusable: X,
            edgesFocusable: tt,
            edgesUpdatable: st,
            elementsSelectable: ot,
            elevateNodesOnSelect: Ge,
            minZoom: ht,
            maxZoom: dt,
            nodeExtent: yt,
            onNodesChange: _t,
            onEdgesChange: Vt,
            snapToGrid: W,
            snapGrid: J,
            connectionMode: S,
            translateExtent: mt,
            connectOnClick: ee,
            defaultEdgeOptions: Te,
            fitView: Ht,
            fitViewOptions: ie,
            onNodesDelete: P,
            onEdgesDelete: $,
            onNodeDragStart: B,
            onNodeDrag: E,
            onNodeDragStop: O,
            onSelectionDrag: R,
            onSelectionDragStart: M,
            onSelectionDragStop: k,
            noPanClassName: Gt,
            nodeOrigin: Q,
            rfId: Kt,
            autoPanOnConnect: et,
            autoPanOnNodeDrag: ft,
            onError: $t,
            connectionRadius: gt,
            isValidConnection: wt,
            nodeDragThreshold: ve,
          }),
          ut.createElement($F, { onSelectionChange: F }),
          Ut,
          ut.createElement(mF, { proOptions: Le, position: de }),
          ut.createElement(GF, { rfId: Kt, disableKeyboardA11y: pn }),
        ),
      )
    },
  )
tz.displayName = 'ReactFlow'
const ez = (e) => e.domNode?.querySelector('.react-flow__edgelabel-renderer')
function pJ({ children: e }) {
  const n = Ne(ez)
  return n ? Ei.createPortal(e, n) : null
}
function l5(e) {
  return (n) => {
    const [t, r] = Y.useState(n),
      i = Y.useCallback((s) => r((o) => e(s, o)), [])
    return [t, r, i]
  }
}
const mJ = l5(G6),
  gJ = l5(lB),
  c5 = ({
    id: e,
    x: n,
    y: t,
    width: r,
    height: i,
    style: s,
    color: o,
    strokeColor: a,
    strokeWidth: l,
    className: c,
    borderRadius: u,
    shapeRendering: f,
    onClick: d,
    selected: h,
  }) => {
    const { background: p, backgroundColor: g } = s || {},
      m = o || p || g
    return ut.createElement('rect', {
      className: Sn(['react-flow__minimap-node', { selected: h }, c]),
      x: n,
      y: t,
      rx: u,
      ry: u,
      width: r,
      height: i,
      fill: m,
      stroke: a,
      strokeWidth: l,
      shapeRendering: f,
      onClick: d ? (y) => d(y, e) : void 0,
    })
  }
c5.displayName = 'MiniMapNode'
var nz = Y.memo(c5)
const rz = (e) => e.nodeOrigin,
  iz = (e) => e.getNodes().filter((n) => !n.hidden && n.width && n.height),
  ih = (e) => (e instanceof Function ? e : () => e)
function sz({
  nodeStrokeColor: e = 'transparent',
  nodeColor: n = '#e2e2e2',
  nodeClassName: t = '',
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: i = 2,
  nodeComponent: s = nz,
  onClick: o,
}) {
  const a = Ne(iz, dn),
    l = Ne(rz),
    c = ih(n),
    u = ih(e),
    f = ih(t),
    d = typeof window > 'u' || window.chrome ? 'crispEdges' : 'geometricPrecision'
  return ut.createElement(
    ut.Fragment,
    null,
    a.map((h) => {
      const { x: p, y: g } = _s(h, l).positionAbsolute
      return ut.createElement(s, {
        key: h.id,
        x: p,
        y: g,
        width: h.width,
        height: h.height,
        style: h.style,
        selected: h.selected,
        className: f(h),
        color: c(h),
        borderRadius: r,
        strokeColor: u(h),
        strokeWidth: i,
        shapeRendering: d,
        onClick: o,
        id: h.id,
      })
    }),
  )
}
var oz = Y.memo(sz)
const az = 200,
  lz = 150,
  cz = (e) => {
    const n = e.getNodes(),
      t = {
        x: -e.transform[0] / e.transform[2],
        y: -e.transform[1] / e.transform[2],
        width: e.width / e.transform[2],
        height: e.height / e.transform[2],
      }
    return { viewBB: t, boundingRect: n.length > 0 ? bF(Kf(n, e.nodeOrigin), t) : t, rfId: e.rfId }
  },
  uz = 'react-flow__minimap-desc'
function u5({
  style: e,
  className: n,
  nodeStrokeColor: t = 'transparent',
  nodeColor: r = '#e2e2e2',
  nodeClassName: i = '',
  nodeBorderRadius: s = 5,
  nodeStrokeWidth: o = 2,
  nodeComponent: a,
  maskColor: l = 'rgb(240, 240, 240, 0.6)',
  maskStrokeColor: c = 'none',
  maskStrokeWidth: u = 1,
  position: f = 'bottom-right',
  onClick: d,
  onNodeClick: h,
  pannable: p = !1,
  zoomable: g = !1,
  ariaLabel: m = 'React Flow mini map',
  inversePan: y = !1,
  zoomStep: b = 10,
  offsetScale: w = 5,
}) {
  const C = sn(),
    T = Y.useRef(null),
    { boundingRect: I, viewBB: B, rfId: E } = Ne(cz, dn),
    O = e?.width ?? az,
    P = e?.height ?? lz,
    $ = I.width / O,
    F = I.height / P,
    M = Math.max($, F),
    R = M * O,
    k = M * P,
    v = w * M,
    x = I.x - (R - I.width) / 2 - v,
    _ = I.y - (k - I.height) / 2 - v,
    S = R + v * 2,
    A = k + v * 2,
    j = `${uz}-${E}`,
    L = Y.useRef(0)
  ;((L.current = M),
    Y.useEffect(() => {
      if (T.current) {
        const K = _m(T.current),
          z = (N) => {
            const { transform: V, d3Selection: W, d3Zoom: J } = C.getState()
            if (N.sourceEvent.type !== 'wheel' || !W || !J) return
            const G =
                -N.sourceEvent.deltaY *
                (N.sourceEvent.deltaMode === 1 ? 0.05 : N.sourceEvent.deltaMode ? 1 : 0.002) *
                b,
              Z = V[2] * Math.pow(2, G)
            J.scaleTo(W, Z)
          },
          q = (N) => {
            const {
              transform: V,
              d3Selection: W,
              d3Zoom: J,
              translateExtent: G,
              width: Z,
              height: rt,
            } = C.getState()
            if (N.sourceEvent.type !== 'mousemove' || !W || !J) return
            const nt = L.current * Math.max(1, V[2]) * (y ? -1 : 1),
              X = {
                x: V[0] - N.sourceEvent.movementX * nt,
                y: V[1] - N.sourceEvent.movementY * nt,
              },
              Q = [
                [0, 0],
                [Z, rt],
              ],
              tt = ys.translate(X.x, X.y).scale(V[2]),
              st = J.constrain()(tt, Q, G)
            J.transform(W, st)
          },
          D = L2()
            .on('zoom', p ? q : null)
            .on('zoom.wheel', g ? z : null)
        return (
          K.call(D),
          () => {
            K.on('zoom', null)
          }
        )
      }
    }, [p, g, y, b]))
  const H = d
      ? (K) => {
          const z = F2(K)
          d(K, { x: z[0], y: z[1] })
        }
      : void 0,
    U = h
      ? (K, z) => {
          const q = C.getState().nodeInternals.get(z)
          h(K, q)
        }
      : void 0
  return ut.createElement(
    X0,
    {
      position: f,
      style: e,
      className: Sn(['react-flow__minimap', n]),
      'data-testid': 'rf__minimap',
    },
    ut.createElement(
      'svg',
      {
        width: O,
        height: P,
        viewBox: `${x} ${_} ${S} ${A}`,
        role: 'img',
        'aria-labelledby': j,
        ref: T,
        onClick: H,
      },
      m && ut.createElement('title', { id: j }, m),
      ut.createElement(oz, {
        onClick: U,
        nodeColor: r,
        nodeStrokeColor: t,
        nodeBorderRadius: s,
        nodeClassName: i,
        nodeStrokeWidth: o,
        nodeComponent: a,
      }),
      ut.createElement('path', {
        className: 'react-flow__minimap-mask',
        d: `M${x - v},${_ - v}h${S + v * 2}v${A + v * 2}h${-S - v * 2}z
        M${B.x},${B.y}h${B.width}v${B.height}h${-B.width}z`,
        fill: l,
        fillRule: 'evenodd',
        stroke: c,
        strokeWidth: u,
        pointerEvents: 'none',
      }),
    ),
  )
}
u5.displayName = 'MiniMap'
var yJ = Y.memo(u5)
function fz() {
  return ut.createElement(
    'svg',
    { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 32 32' },
    ut.createElement('path', {
      d: 'M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z',
    }),
  )
}
function dz() {
  return ut.createElement(
    'svg',
    { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 32 5' },
    ut.createElement('path', { d: 'M0 0h32v4.2H0z' }),
  )
}
function hz() {
  return ut.createElement(
    'svg',
    { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 32 30' },
    ut.createElement('path', {
      d: 'M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z',
    }),
  )
}
function pz() {
  return ut.createElement(
    'svg',
    { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 25 32' },
    ut.createElement('path', {
      d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z',
    }),
  )
}
function mz() {
  return ut.createElement(
    'svg',
    { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 25 32' },
    ut.createElement('path', {
      d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z',
    }),
  )
}
const wa = ({ children: e, className: n, ...t }) =>
  ut.createElement(
    'button',
    { type: 'button', className: Sn(['react-flow__controls-button', n]), ...t },
    e,
  )
wa.displayName = 'ControlButton'
const gz = (e) => ({
    isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
    minZoomReached: e.transform[2] <= e.minZoom,
    maxZoomReached: e.transform[2] >= e.maxZoom,
  }),
  f5 = ({
    style: e,
    showZoom: n = !0,
    showFitView: t = !0,
    showInteractive: r = !0,
    fitViewOptions: i,
    onZoomIn: s,
    onZoomOut: o,
    onFitView: a,
    onInteractiveChange: l,
    className: c,
    children: u,
    position: f = 'bottom-left',
  }) => {
    const d = sn(),
      [h, p] = Y.useState(!1),
      { isInteractive: g, minZoomReached: m, maxZoomReached: y } = Ne(gz, dn),
      { zoomIn: b, zoomOut: w, fitView: C } = ig()
    if (
      (Y.useEffect(() => {
        p(!0)
      }, []),
      !h)
    )
      return null
    const T = () => {
        ;(b(), s?.())
      },
      I = () => {
        ;(w(), o?.())
      },
      B = () => {
        ;(C(i), a?.())
      },
      E = () => {
        ;(d.setState({ nodesDraggable: !g, nodesConnectable: !g, elementsSelectable: !g }), l?.(!g))
      }
    return ut.createElement(
      X0,
      {
        className: Sn(['react-flow__controls', c]),
        position: f,
        style: e,
        'data-testid': 'rf__controls',
      },
      n &&
        ut.createElement(
          ut.Fragment,
          null,
          ut.createElement(
            wa,
            {
              onClick: T,
              className: 'react-flow__controls-zoomin',
              title: 'zoom in',
              'aria-label': 'zoom in',
              disabled: y,
            },
            ut.createElement(fz, null),
          ),
          ut.createElement(
            wa,
            {
              onClick: I,
              className: 'react-flow__controls-zoomout',
              title: 'zoom out',
              'aria-label': 'zoom out',
              disabled: m,
            },
            ut.createElement(dz, null),
          ),
        ),
      t &&
        ut.createElement(
          wa,
          {
            className: 'react-flow__controls-fitview',
            onClick: B,
            title: 'fit view',
            'aria-label': 'fit view',
          },
          ut.createElement(hz, null),
        ),
      r &&
        ut.createElement(
          wa,
          {
            className: 'react-flow__controls-interactive',
            onClick: E,
            title: 'toggle interactivity',
            'aria-label': 'toggle interactivity',
          },
          g ? ut.createElement(mz, null) : ut.createElement(pz, null),
        ),
      u,
    )
  }
f5.displayName = 'Controls'
var bJ = Y.memo(f5),
  vr
;(function (e) {
  ;((e.Lines = 'lines'), (e.Dots = 'dots'), (e.Cross = 'cross'))
})(vr || (vr = {}))
function yz({ color: e, dimensions: n, lineWidth: t }) {
  return ut.createElement('path', {
    stroke: e,
    strokeWidth: t,
    d: `M${n[0] / 2} 0 V${n[1]} M0 ${n[1] / 2} H${n[0]}`,
  })
}
function bz({ color: e, radius: n }) {
  return ut.createElement('circle', { cx: n, cy: n, r: n, fill: e })
}
const vz = { [vr.Dots]: '#91919a', [vr.Lines]: '#eee', [vr.Cross]: '#e2e2e2' },
  wz = { [vr.Dots]: 1, [vr.Lines]: 1, [vr.Cross]: 6 },
  xz = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` })
function d5({
  id: e,
  variant: n = vr.Dots,
  gap: t = 20,
  size: r,
  lineWidth: i = 1,
  offset: s = 2,
  color: o,
  style: a,
  className: l,
}) {
  const c = Y.useRef(null),
    { transform: u, patternId: f } = Ne(xz, dn),
    d = o || vz[n],
    h = r || wz[n],
    p = n === vr.Dots,
    g = n === vr.Cross,
    m = Array.isArray(t) ? t : [t, t],
    y = [m[0] * u[2] || 1, m[1] * u[2] || 1],
    b = h * u[2],
    w = g ? [b, b] : y,
    C = p ? [b / s, b / s] : [w[0] / s, w[1] / s]
  return ut.createElement(
    'svg',
    {
      className: Sn(['react-flow__background', l]),
      style: { ...a, position: 'absolute', width: '100%', height: '100%', top: 0, left: 0 },
      ref: c,
      'data-testid': 'rf__background',
    },
    ut.createElement(
      'pattern',
      {
        id: f + e,
        x: u[0] % y[0],
        y: u[1] % y[1],
        width: y[0],
        height: y[1],
        patternUnits: 'userSpaceOnUse',
        patternTransform: `translate(-${C[0]},-${C[1]})`,
      },
      p
        ? ut.createElement(bz, { color: d, radius: b / s })
        : ut.createElement(yz, { dimensions: w, color: d, lineWidth: i }),
    ),
    ut.createElement('rect', {
      x: '0',
      y: '0',
      width: '100%',
      height: '100%',
      fill: `url(#${f + e})`,
    }),
  )
}
d5.displayName = 'Background'
var vJ = Y.memo(d5)
function yn(e) {
  this.content = e
}
yn.prototype = {
  constructor: yn,
  find: function (e) {
    for (var n = 0; n < this.content.length; n += 2) if (this.content[n] === e) return n
    return -1
  },
  get: function (e) {
    var n = this.find(e)
    return n == -1 ? void 0 : this.content[n + 1]
  },
  update: function (e, n, t) {
    var r = t && t != e ? this.remove(t) : this,
      i = r.find(e),
      s = r.content.slice()
    return (i == -1 ? s.push(t || e, n) : ((s[i + 1] = n), t && (s[i] = t)), new yn(s))
  },
  remove: function (e) {
    var n = this.find(e)
    if (n == -1) return this
    var t = this.content.slice()
    return (t.splice(n, 2), new yn(t))
  },
  addToStart: function (e, n) {
    return new yn([e, n].concat(this.remove(e).content))
  },
  addToEnd: function (e, n) {
    var t = this.remove(e).content.slice()
    return (t.push(e, n), new yn(t))
  },
  addBefore: function (e, n, t) {
    var r = this.remove(n),
      i = r.content.slice(),
      s = r.find(e)
    return (i.splice(s == -1 ? i.length : s, 0, n, t), new yn(i))
  },
  forEach: function (e) {
    for (var n = 0; n < this.content.length; n += 2) e(this.content[n], this.content[n + 1])
  },
  prepend: function (e) {
    return ((e = yn.from(e)), e.size ? new yn(e.content.concat(this.subtract(e).content)) : this)
  },
  append: function (e) {
    return ((e = yn.from(e)), e.size ? new yn(this.subtract(e).content.concat(e.content)) : this)
  },
  subtract: function (e) {
    var n = this
    e = yn.from(e)
    for (var t = 0; t < e.content.length; t += 2) n = n.remove(e.content[t])
    return n
  },
  toObject: function () {
    var e = {}
    return (
      this.forEach(function (n, t) {
        e[n] = t
      }),
      e
    )
  },
  get size() {
    return this.content.length >> 1
  },
}
yn.from = function (e) {
  if (e instanceof yn) return e
  var n = []
  if (e) for (var t in e) n.push(t, e[t])
  return new yn(n)
}
function h5(e, n, t) {
  for (let r = 0; ; r++) {
    if (r == e.childCount || r == n.childCount) return e.childCount == n.childCount ? null : t
    let i = e.child(r),
      s = n.child(r)
    if (i == s) {
      t += i.nodeSize
      continue
    }
    if (!i.sameMarkup(s)) return t
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++) t++
      return t
    }
    if (i.content.size || s.content.size) {
      let o = h5(i.content, s.content, t + 1)
      if (o != null) return o
    }
    t += i.nodeSize
  }
}
function p5(e, n, t, r) {
  for (let i = e.childCount, s = n.childCount; ; ) {
    if (i == 0 || s == 0) return i == s ? null : { a: t, b: r }
    let o = e.child(--i),
      a = n.child(--s),
      l = o.nodeSize
    if (o == a) {
      ;((t -= l), (r -= l))
      continue
    }
    if (!o.sameMarkup(a)) return { a: t, b: r }
    if (o.isText && o.text != a.text) {
      let c = 0,
        u = Math.min(o.text.length, a.text.length)
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        (c++, t--, r--)
      return { a: t, b: r }
    }
    if (o.content.size || a.content.size) {
      let c = p5(o.content, a.content, t - 1, r - 1)
      if (c) return c
    }
    ;((t -= l), (r -= l))
  }
}
class St {
  constructor(n, t) {
    if (((this.content = n), (this.size = t || 0), t == null))
      for (let r = 0; r < n.length; r++) this.size += n[r].nodeSize
  }
  nodesBetween(n, t, r, i = 0, s) {
    for (let o = 0, a = 0; a < t; o++) {
      let l = this.content[o],
        c = a + l.nodeSize
      if (c > n && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1
        l.nodesBetween(Math.max(0, n - u), Math.min(l.content.size, t - u), r, i + u)
      }
      a = c
    }
  }
  descendants(n) {
    this.nodesBetween(0, this.size, n)
  }
  textBetween(n, t, r, i) {
    let s = '',
      o = !0
    return (
      this.nodesBetween(
        n,
        t,
        (a, l) => {
          let c = a.isText
            ? a.text.slice(Math.max(n, l) - l, t - l)
            : a.isLeaf
              ? i
                ? typeof i == 'function'
                  ? i(a)
                  : i
                : a.type.spec.leafText
                  ? a.type.spec.leafText(a)
                  : ''
              : ''
          ;(a.isBlock && ((a.isLeaf && c) || a.isTextblock) && r && (o ? (o = !1) : (s += r)),
            (s += c))
        },
        0,
      ),
      s
    )
  }
  append(n) {
    if (!n.size) return this
    if (!this.size) return n
    let t = this.lastChild,
      r = n.firstChild,
      i = this.content.slice(),
      s = 0
    for (
      t.isText && t.sameMarkup(r) && ((i[i.length - 1] = t.withText(t.text + r.text)), (s = 1));
      s < n.content.length;
      s++
    )
      i.push(n.content[s])
    return new St(i, this.size + n.size)
  }
  cut(n, t = this.size) {
    if (n == 0 && t == this.size) return this
    let r = [],
      i = 0
    if (t > n)
      for (let s = 0, o = 0; o < t; s++) {
        let a = this.content[s],
          l = o + a.nodeSize
        ;(l > n &&
          ((o < n || l > t) &&
            (a.isText
              ? (a = a.cut(Math.max(0, n - o), Math.min(a.text.length, t - o)))
              : (a = a.cut(Math.max(0, n - o - 1), Math.min(a.content.size, t - o - 1)))),
          r.push(a),
          (i += a.nodeSize)),
          (o = l))
      }
    return new St(r, i)
  }
  cutByIndex(n, t) {
    return n == t
      ? St.empty
      : n == 0 && t == this.content.length
        ? this
        : new St(this.content.slice(n, t))
  }
  replaceChild(n, t) {
    let r = this.content[n]
    if (r == t) return this
    let i = this.content.slice(),
      s = this.size + t.nodeSize - r.nodeSize
    return ((i[n] = t), new St(i, s))
  }
  addToStart(n) {
    return new St([n].concat(this.content), this.size + n.nodeSize)
  }
  addToEnd(n) {
    return new St(this.content.concat(n), this.size + n.nodeSize)
  }
  eq(n) {
    if (this.content.length != n.content.length) return !1
    for (let t = 0; t < this.content.length; t++) if (!this.content[t].eq(n.content[t])) return !1
    return !0
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null
  }
  get childCount() {
    return this.content.length
  }
  child(n) {
    let t = this.content[n]
    if (!t) throw new RangeError('Index ' + n + ' out of range for ' + this)
    return t
  }
  maybeChild(n) {
    return this.content[n] || null
  }
  forEach(n) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t]
      ;(n(i, r, t), (r += i.nodeSize))
    }
  }
  findDiffStart(n, t = 0) {
    return h5(this, n, t)
  }
  findDiffEnd(n, t = this.size, r = n.size) {
    return p5(this, n, t, r)
  }
  findIndex(n) {
    if (n == 0) return wc(0, n)
    if (n == this.size) return wc(this.content.length, n)
    if (n > this.size || n < 0) throw new RangeError(`Position ${n} outside of fragment (${this})`)
    for (let t = 0, r = 0; ; t++) {
      let i = this.child(t),
        s = r + i.nodeSize
      if (s >= n) return s == n ? wc(t + 1, s) : wc(t, r)
      r = s
    }
  }
  toString() {
    return '<' + this.toStringInner() + '>'
  }
  toStringInner() {
    return this.content.join(', ')
  }
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null
  }
  static fromJSON(n, t) {
    if (!t) return St.empty
    if (!Array.isArray(t)) throw new RangeError('Invalid input for Fragment.fromJSON')
    return new St(t.map(n.nodeFromJSON))
  }
  static fromArray(n) {
    if (!n.length) return St.empty
    let t,
      r = 0
    for (let i = 0; i < n.length; i++) {
      let s = n[i]
      ;((r += s.nodeSize),
        i && s.isText && n[i - 1].sameMarkup(s)
          ? (t || (t = n.slice(0, i)),
            (t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)))
          : t && t.push(s))
    }
    return new St(t || n, r)
  }
  static from(n) {
    if (!n) return St.empty
    if (n instanceof St) return n
    if (Array.isArray(n)) return this.fromArray(n)
    if (n.attrs) return new St([n], n.nodeSize)
    throw new RangeError(
      'Can not convert ' +
        n +
        ' to a Fragment' +
        (n.nodesBetween ? ' (looks like multiple versions of prosemirror-model were loaded)' : ''),
    )
  }
}
St.empty = new St([], 0)
const sh = { index: 0, offset: 0 }
function wc(e, n) {
  return ((sh.index = e), (sh.offset = n), sh)
}
function Au(e, n) {
  if (e === n) return !0
  if (!(e && typeof e == 'object') || !(n && typeof n == 'object')) return !1
  let t = Array.isArray(e)
  if (Array.isArray(n) != t) return !1
  if (t) {
    if (e.length != n.length) return !1
    for (let r = 0; r < e.length; r++) if (!Au(e[r], n[r])) return !1
  } else {
    for (let r in e) if (!(r in n) || !Au(e[r], n[r])) return !1
    for (let r in n) if (!(r in e)) return !1
  }
  return !0
}
let Oe = class Wp {
  constructor(n, t) {
    ;((this.type = n), (this.attrs = t))
  }
  addToSet(n) {
    let t,
      r = !1
    for (let i = 0; i < n.length; i++) {
      let s = n[i]
      if (this.eq(s)) return n
      if (this.type.excludes(s.type)) t || (t = n.slice(0, i))
      else {
        if (s.type.excludes(this.type)) return n
        ;(!r && s.type.rank > this.type.rank && (t || (t = n.slice(0, i)), t.push(this), (r = !0)),
          t && t.push(s))
      }
    }
    return (t || (t = n.slice()), r || t.push(this), t)
  }
  removeFromSet(n) {
    for (let t = 0; t < n.length; t++)
      if (this.eq(n[t])) return n.slice(0, t).concat(n.slice(t + 1))
    return n
  }
  isInSet(n) {
    for (let t = 0; t < n.length; t++) if (this.eq(n[t])) return !0
    return !1
  }
  eq(n) {
    return this == n || (this.type == n.type && Au(this.attrs, n.attrs))
  }
  toJSON() {
    let n = { type: this.type.name }
    for (let t in this.attrs) {
      n.attrs = this.attrs
      break
    }
    return n
  }
  static fromJSON(n, t) {
    if (!t) throw new RangeError('Invalid input for Mark.fromJSON')
    let r = n.marks[t.type]
    if (!r) throw new RangeError(`There is no mark type ${t.type} in this schema`)
    let i = r.create(t.attrs)
    return (r.checkAttrs(i.attrs), i)
  }
  static sameSet(n, t) {
    if (n == t) return !0
    if (n.length != t.length) return !1
    for (let r = 0; r < n.length; r++) if (!n[r].eq(t[r])) return !1
    return !0
  }
  static setFrom(n) {
    if (!n || (Array.isArray(n) && n.length == 0)) return Wp.none
    if (n instanceof Wp) return [n]
    let t = n.slice()
    return (t.sort((r, i) => r.type.rank - i.type.rank), t)
  }
}
Oe.none = []
class Ru extends Error {}
class jt {
  constructor(n, t, r) {
    ;((this.content = n), (this.openStart = t), (this.openEnd = r))
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd
  }
  insertAt(n, t) {
    let r = g5(this.content, n + this.openStart, t)
    return r && new jt(r, this.openStart, this.openEnd)
  }
  removeBetween(n, t) {
    return new jt(
      m5(this.content, n + this.openStart, t + this.openStart),
      this.openStart,
      this.openEnd,
    )
  }
  eq(n) {
    return this.content.eq(n.content) && this.openStart == n.openStart && this.openEnd == n.openEnd
  }
  toString() {
    return this.content + '(' + this.openStart + ',' + this.openEnd + ')'
  }
  toJSON() {
    if (!this.content.size) return null
    let n = { content: this.content.toJSON() }
    return (
      this.openStart > 0 && (n.openStart = this.openStart),
      this.openEnd > 0 && (n.openEnd = this.openEnd),
      n
    )
  }
  static fromJSON(n, t) {
    if (!t) return jt.empty
    let r = t.openStart || 0,
      i = t.openEnd || 0
    if (typeof r != 'number' || typeof i != 'number')
      throw new RangeError('Invalid input for Slice.fromJSON')
    return new jt(St.fromJSON(n, t.content), r, i)
  }
  static maxOpen(n, t = !0) {
    let r = 0,
      i = 0
    for (let s = n.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      r++
    for (let s = n.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild) i++
    return new jt(n, r, i)
  }
}
jt.empty = new jt(St.empty, 0, 0)
function m5(e, n, t) {
  let { index: r, offset: i } = e.findIndex(n),
    s = e.maybeChild(r),
    { index: o, offset: a } = e.findIndex(t)
  if (i == n || s.isText) {
    if (a != t && !e.child(o).isText) throw new RangeError('Removing non-flat range')
    return e.cut(0, n).append(e.cut(t))
  }
  if (r != o) throw new RangeError('Removing non-flat range')
  return e.replaceChild(r, s.copy(m5(s.content, n - i - 1, t - i - 1)))
}
function g5(e, n, t, r) {
  let { index: i, offset: s } = e.findIndex(n),
    o = e.maybeChild(i)
  if (s == n || o.isText)
    return r && !r.canReplace(i, i, t) ? null : e.cut(0, n).append(t).append(e.cut(n))
  let a = g5(o.content, n - s - 1, t, o)
  return a && e.replaceChild(i, o.copy(a))
}
function Sz(e, n, t) {
  if (t.openStart > e.depth) throw new Ru('Inserted content deeper than insertion position')
  if (e.depth - t.openStart != n.depth - t.openEnd) throw new Ru('Inconsistent open depths')
  return y5(e, n, t, 0)
}
function y5(e, n, t, r) {
  let i = e.index(r),
    s = e.node(r)
  if (i == n.index(r) && r < e.depth - t.openStart) {
    let o = y5(e, n, t, r + 1)
    return s.copy(s.content.replaceChild(i, o))
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && e.depth == r && n.depth == r) {
      let o = e.parent,
        a = o.content
      return Cs(o, a.cut(0, e.parentOffset).append(t.content).append(a.cut(n.parentOffset)))
    } else {
      let { start: o, end: a } = _z(t, e)
      return Cs(s, v5(e, o, a, n, r))
    }
  else return Cs(s, Ou(e, n, r))
}
function b5(e, n) {
  if (!n.type.compatibleContent(e.type))
    throw new Ru('Cannot join ' + n.type.name + ' onto ' + e.type.name)
}
function Kp(e, n, t) {
  let r = e.node(t)
  return (b5(r, n.node(t)), r)
}
function ks(e, n) {
  let t = n.length - 1
  t >= 0 && e.isText && e.sameMarkup(n[t]) ? (n[t] = e.withText(n[t].text + e.text)) : n.push(e)
}
function Fa(e, n, t, r) {
  let i = (n || e).node(t),
    s = 0,
    o = n ? n.index(t) : i.childCount
  e && ((s = e.index(t)), e.depth > t ? s++ : e.textOffset && (ks(e.nodeAfter, r), s++))
  for (let a = s; a < o; a++) ks(i.child(a), r)
  n && n.depth == t && n.textOffset && ks(n.nodeBefore, r)
}
function Cs(e, n) {
  return (e.type.checkContent(n), e.copy(n))
}
function v5(e, n, t, r, i) {
  let s = e.depth > i && Kp(e, n, i + 1),
    o = r.depth > i && Kp(t, r, i + 1),
    a = []
  return (
    Fa(null, e, i, a),
    s && o && n.index(i) == t.index(i)
      ? (b5(s, o), ks(Cs(s, v5(e, n, t, r, i + 1)), a))
      : (s && ks(Cs(s, Ou(e, n, i + 1)), a), Fa(n, t, i, a), o && ks(Cs(o, Ou(t, r, i + 1)), a)),
    Fa(r, null, i, a),
    new St(a)
  )
}
function Ou(e, n, t) {
  let r = []
  if ((Fa(null, e, t, r), e.depth > t)) {
    let i = Kp(e, n, t + 1)
    ks(Cs(i, Ou(e, n, t + 1)), r)
  }
  return (Fa(n, null, t, r), new St(r))
}
function _z(e, n) {
  let t = n.depth - e.openStart,
    i = n.node(t).copy(e.content)
  for (let s = t - 1; s >= 0; s--) i = n.node(s).copy(St.from(i))
  return {
    start: i.resolveNoCache(e.openStart + t),
    end: i.resolveNoCache(i.content.size - e.openEnd - t),
  }
}
class hl {
  constructor(n, t, r) {
    ;((this.pos = n), (this.path = t), (this.parentOffset = r), (this.depth = t.length / 3 - 1))
  }
  resolveDepth(n) {
    return n == null ? this.depth : n < 0 ? this.depth + n : n
  }
  get parent() {
    return this.node(this.depth)
  }
  get doc() {
    return this.node(0)
  }
  node(n) {
    return this.path[this.resolveDepth(n) * 3]
  }
  index(n) {
    return this.path[this.resolveDepth(n) * 3 + 1]
  }
  indexAfter(n) {
    return (
      (n = this.resolveDepth(n)),
      this.index(n) + (n == this.depth && !this.textOffset ? 0 : 1)
    )
  }
  start(n) {
    return ((n = this.resolveDepth(n)), n == 0 ? 0 : this.path[n * 3 - 1] + 1)
  }
  end(n) {
    return ((n = this.resolveDepth(n)), this.start(n) + this.node(n).content.size)
  }
  before(n) {
    if (((n = this.resolveDepth(n)), !n))
      throw new RangeError('There is no position before the top-level node')
    return n == this.depth + 1 ? this.pos : this.path[n * 3 - 1]
  }
  after(n) {
    if (((n = this.resolveDepth(n)), !n))
      throw new RangeError('There is no position after the top-level node')
    return n == this.depth + 1 ? this.pos : this.path[n * 3 - 1] + this.path[n * 3].nodeSize
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1]
  }
  get nodeAfter() {
    let n = this.parent,
      t = this.index(this.depth)
    if (t == n.childCount) return null
    let r = this.pos - this.path[this.path.length - 1],
      i = n.child(t)
    return r ? n.child(t).cut(r) : i
  }
  get nodeBefore() {
    let n = this.index(this.depth),
      t = this.pos - this.path[this.path.length - 1]
    return t ? this.parent.child(n).cut(0, t) : n == 0 ? null : this.parent.child(n - 1)
  }
  posAtIndex(n, t) {
    t = this.resolveDepth(t)
    let r = this.path[t * 3],
      i = t == 0 ? 0 : this.path[t * 3 - 1] + 1
    for (let s = 0; s < n; s++) i += r.child(s).nodeSize
    return i
  }
  marks() {
    let n = this.parent,
      t = this.index()
    if (n.content.size == 0) return Oe.none
    if (this.textOffset) return n.child(t).marks
    let r = n.maybeChild(t - 1),
      i = n.maybeChild(t)
    if (!r) {
      let a = r
      ;((r = i), (i = a))
    }
    let s = r.marks
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 &&
        (!i || !s[o].isInSet(i.marks)) &&
        (s = s[o--].removeFromSet(s))
    return s
  }
  marksAcross(n) {
    let t = this.parent.maybeChild(this.index())
    if (!t || !t.isInline) return null
    let r = t.marks,
      i = n.parent.maybeChild(n.index())
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 &&
        (!i || !r[s].isInSet(i.marks)) &&
        (r = r[s--].removeFromSet(r))
    return r
  }
  sharedDepth(n) {
    for (let t = this.depth; t > 0; t--) if (this.start(t) <= n && this.end(t) >= n) return t
    return 0
  }
  blockRange(n = this, t) {
    if (n.pos < this.pos) return n.blockRange(this)
    for (let r = this.depth - (this.parent.inlineContent || this.pos == n.pos ? 1 : 0); r >= 0; r--)
      if (n.pos <= this.end(r) && (!t || t(this.node(r)))) return new Pu(this, n, r)
    return null
  }
  sameParent(n) {
    return this.pos - this.parentOffset == n.pos - n.parentOffset
  }
  max(n) {
    return n.pos > this.pos ? n : this
  }
  min(n) {
    return n.pos < this.pos ? n : this
  }
  toString() {
    let n = ''
    for (let t = 1; t <= this.depth; t++)
      n += (n ? '/' : '') + this.node(t).type.name + '_' + this.index(t - 1)
    return n + ':' + this.parentOffset
  }
  static resolve(n, t) {
    if (!(t >= 0 && t <= n.content.size)) throw new RangeError('Position ' + t + ' out of range')
    let r = [],
      i = 0,
      s = t
    for (let o = n; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s),
        c = s - l
      if ((r.push(o, a, i + l), !c || ((o = o.child(a)), o.isText))) break
      ;((s = c - 1), (i += l + 1))
    }
    return new hl(t, r, s)
  }
  static resolveCached(n, t) {
    let r = fv.get(n)
    if (r)
      for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s]
        if (o.pos == t) return o
      }
    else fv.set(n, (r = new kz()))
    let i = (r.elts[r.i] = hl.resolve(n, t))
    return ((r.i = (r.i + 1) % Cz), i)
  }
}
class kz {
  constructor() {
    ;((this.elts = []), (this.i = 0))
  }
}
const Cz = 12,
  fv = new WeakMap()
class Pu {
  constructor(n, t, r) {
    ;((this.$from = n), (this.$to = t), (this.depth = r))
  }
  get start() {
    return this.$from.before(this.depth + 1)
  }
  get end() {
    return this.$to.after(this.depth + 1)
  }
  get parent() {
    return this.$from.node(this.depth)
  }
  get startIndex() {
    return this.$from.index(this.depth)
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth)
  }
}
const Mz = Object.create(null)
let Li = class Gp {
  constructor(n, t, r, i = Oe.none) {
    ;((this.type = n), (this.attrs = t), (this.marks = i), (this.content = r || St.empty))
  }
  get children() {
    return this.content.content
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size
  }
  get childCount() {
    return this.content.childCount
  }
  child(n) {
    return this.content.child(n)
  }
  maybeChild(n) {
    return this.content.maybeChild(n)
  }
  forEach(n) {
    this.content.forEach(n)
  }
  nodesBetween(n, t, r, i = 0) {
    this.content.nodesBetween(n, t, r, i, this)
  }
  descendants(n) {
    this.nodesBetween(0, this.content.size, n)
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText
      ? this.type.spec.leafText(this)
      : this.textBetween(0, this.content.size, '')
  }
  textBetween(n, t, r, i) {
    return this.content.textBetween(n, t, r, i)
  }
  get firstChild() {
    return this.content.firstChild
  }
  get lastChild() {
    return this.content.lastChild
  }
  eq(n) {
    return this == n || (this.sameMarkup(n) && this.content.eq(n.content))
  }
  sameMarkup(n) {
    return this.hasMarkup(n.type, n.attrs, n.marks)
  }
  hasMarkup(n, t, r) {
    return (
      this.type == n &&
      Au(this.attrs, t || n.defaultAttrs || Mz) &&
      Oe.sameSet(this.marks, r || Oe.none)
    )
  }
  copy(n = null) {
    return n == this.content ? this : new Gp(this.type, this.attrs, n, this.marks)
  }
  mark(n) {
    return n == this.marks ? this : new Gp(this.type, this.attrs, this.content, n)
  }
  cut(n, t = this.content.size) {
    return n == 0 && t == this.content.size ? this : this.copy(this.content.cut(n, t))
  }
  slice(n, t = this.content.size, r = !1) {
    if (n == t) return jt.empty
    let i = this.resolve(n),
      s = this.resolve(t),
      o = r ? 0 : i.sharedDepth(t),
      a = i.start(o),
      c = i.node(o).content.cut(i.pos - a, s.pos - a)
    return new jt(c, i.depth - o, s.depth - o)
  }
  replace(n, t, r) {
    return Sz(this.resolve(n), this.resolve(t), r)
  }
  nodeAt(n) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(n)
      if (((t = t.maybeChild(r)), !t)) return null
      if (i == n || t.isText) return t
      n -= i + 1
    }
  }
  childAfter(n) {
    let { index: t, offset: r } = this.content.findIndex(n)
    return { node: this.content.maybeChild(t), index: t, offset: r }
  }
  childBefore(n) {
    if (n == 0) return { node: null, index: 0, offset: 0 }
    let { index: t, offset: r } = this.content.findIndex(n)
    if (r < n) return { node: this.content.child(t), index: t, offset: r }
    let i = this.content.child(t - 1)
    return { node: i, index: t - 1, offset: r - i.nodeSize }
  }
  resolve(n) {
    return hl.resolveCached(this, n)
  }
  resolveNoCache(n) {
    return hl.resolve(this, n)
  }
  rangeHasMark(n, t, r) {
    let i = !1
    return (t > n && this.nodesBetween(n, t, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i)
  }
  get isBlock() {
    return this.type.isBlock
  }
  get isTextblock() {
    return this.type.isTextblock
  }
  get inlineContent() {
    return this.type.inlineContent
  }
  get isInline() {
    return this.type.isInline
  }
  get isText() {
    return this.type.isText
  }
  get isLeaf() {
    return this.type.isLeaf
  }
  get isAtom() {
    return this.type.isAtom
  }
  toString() {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)
    let n = this.type.name
    return (this.content.size && (n += '(' + this.content.toStringInner() + ')'), w5(this.marks, n))
  }
  contentMatchAt(n) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, n)
    if (!t) throw new Error('Called contentMatchAt on a node with invalid content')
    return t
  }
  canReplace(n, t, r = St.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(n).matchFragment(r, i, s),
      a = o && o.matchFragment(this.content, t)
    if (!a || !a.validEnd) return !1
    for (let l = i; l < s; l++) if (!this.type.allowsMarks(r.child(l).marks)) return !1
    return !0
  }
  canReplaceWith(n, t, r, i) {
    if (i && !this.type.allowsMarks(i)) return !1
    let s = this.contentMatchAt(n).matchType(r),
      o = s && s.matchFragment(this.content, t)
    return o ? o.validEnd : !1
  }
  canAppend(n) {
    return n.content.size
      ? this.canReplace(this.childCount, this.childCount, n.content)
      : this.type.compatibleContent(n.type)
  }
  check() {
    ;(this.type.checkContent(this.content), this.type.checkAttrs(this.attrs))
    let n = Oe.none
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t]
      ;(r.type.checkAttrs(r.attrs), (n = r.addToSet(n)))
    }
    if (!Oe.sameSet(n, this.marks))
      throw new RangeError(
        `Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`,
      )
    this.content.forEach((t) => t.check())
  }
  toJSON() {
    let n = { type: this.type.name }
    for (let t in this.attrs) {
      n.attrs = this.attrs
      break
    }
    return (
      this.content.size && (n.content = this.content.toJSON()),
      this.marks.length && (n.marks = this.marks.map((t) => t.toJSON())),
      n
    )
  }
  static fromJSON(n, t) {
    if (!t) throw new RangeError('Invalid input for Node.fromJSON')
    let r
    if (t.marks) {
      if (!Array.isArray(t.marks)) throw new RangeError('Invalid mark data for Node.fromJSON')
      r = t.marks.map(n.markFromJSON)
    }
    if (t.type == 'text') {
      if (typeof t.text != 'string') throw new RangeError('Invalid text node in JSON')
      return n.text(t.text, r)
    }
    let i = St.fromJSON(n, t.content),
      s = n.nodeType(t.type).create(t.attrs, i, r)
    return (s.type.checkAttrs(s.attrs), s)
  }
}
Li.prototype.text = void 0
class Nu extends Li {
  constructor(n, t, r, i) {
    if ((super(n, t, null, i), !r)) throw new RangeError('Empty text nodes are not allowed')
    this.text = r
  }
  toString() {
    return this.type.spec.toDebugString
      ? this.type.spec.toDebugString(this)
      : w5(this.marks, JSON.stringify(this.text))
  }
  get textContent() {
    return this.text
  }
  textBetween(n, t) {
    return this.text.slice(n, t)
  }
  get nodeSize() {
    return this.text.length
  }
  mark(n) {
    return n == this.marks ? this : new Nu(this.type, this.attrs, this.text, n)
  }
  withText(n) {
    return n == this.text ? this : new Nu(this.type, this.attrs, n, this.marks)
  }
  cut(n = 0, t = this.text.length) {
    return n == 0 && t == this.text.length ? this : this.withText(this.text.slice(n, t))
  }
  eq(n) {
    return this.sameMarkup(n) && this.text == n.text
  }
  toJSON() {
    let n = super.toJSON()
    return ((n.text = this.text), n)
  }
}
function w5(e, n) {
  for (let t = e.length - 1; t >= 0; t--) n = e[t].type.name + '(' + n + ')'
  return n
}
class Ls {
  constructor(n) {
    ;((this.validEnd = n), (this.next = []), (this.wrapCache = []))
  }
  static parse(n, t) {
    let r = new Ez(n, t)
    if (r.next == null) return Ls.empty
    let i = x5(r)
    r.next && r.err('Unexpected trailing text')
    let s = Iz(Nz(i))
    return (Dz(s, r), s)
  }
  matchType(n) {
    for (let t = 0; t < this.next.length; t++) if (this.next[t].type == n) return this.next[t].next
    return null
  }
  matchFragment(n, t = 0, r = n.childCount) {
    let i = this
    for (let s = t; i && s < r; s++) i = i.matchType(n.child(s).type)
    return i
  }
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline
  }
  get defaultType() {
    for (let n = 0; n < this.next.length; n++) {
      let { type: t } = this.next[n]
      if (!(t.isText || t.hasRequiredAttrs())) return t
    }
    return null
  }
  compatible(n) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < n.next.length; r++) if (this.next[t].type == n.next[r].type) return !0
    return !1
  }
  fillBefore(n, t = !1, r = 0) {
    let i = [this]
    function s(o, a) {
      let l = o.matchFragment(n, r)
      if (l && (!t || l.validEnd)) return St.from(a.map((c) => c.createAndFill()))
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: f } = o.next[c]
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(f) == -1) {
          i.push(f)
          let d = s(f, a.concat(u))
          if (d) return d
        }
      }
      return null
    }
    return s(this, [])
  }
  findWrapping(n) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == n) return this.wrapCache[r + 1]
    let t = this.computeWrapping(n)
    return (this.wrapCache.push(n, t), t)
  }
  computeWrapping(n) {
    let t = Object.create(null),
      r = [{ match: this, type: null, via: null }]
    for (; r.length; ) {
      let i = r.shift(),
        s = i.match
      if (s.matchType(n)) {
        let o = []
        for (let a = i; a.type; a = a.via) o.push(a.type)
        return o.reverse()
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o]
        !a.isLeaf &&
          !a.hasRequiredAttrs() &&
          !(a.name in t) &&
          (!i.type || l.validEnd) &&
          (r.push({ match: a.contentMatch, type: a, via: i }), (t[a.name] = !0))
      }
    }
    return null
  }
  get edgeCount() {
    return this.next.length
  }
  edge(n) {
    if (n >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)
    return this.next[n]
  }
  toString() {
    let n = []
    function t(r) {
      n.push(r)
      for (let i = 0; i < r.next.length; i++) n.indexOf(r.next[i].next) == -1 && t(r.next[i].next)
    }
    return (
      t(this),
      n.map((r, i) => {
        let s = i + (r.validEnd ? '*' : ' ') + ' '
        for (let o = 0; o < r.next.length; o++)
          s += (o ? ', ' : '') + r.next[o].type.name + '->' + n.indexOf(r.next[o].next)
        return s
      }).join(`
`)
    )
  }
}
Ls.empty = new Ls(!0)
class Ez {
  constructor(n, t) {
    ;((this.string = n),
      (this.nodeTypes = t),
      (this.inline = null),
      (this.pos = 0),
      (this.tokens = n.split(/\s*(?=\b|\W|$)/)),
      this.tokens[this.tokens.length - 1] == '' && this.tokens.pop(),
      this.tokens[0] == '' && this.tokens.shift())
  }
  get next() {
    return this.tokens[this.pos]
  }
  eat(n) {
    return this.next == n && (this.pos++ || !0)
  }
  err(n) {
    throw new SyntaxError(n + " (in content expression '" + this.string + "')")
  }
}
function x5(e) {
  let n = []
  do n.push(Tz(e))
  while (e.eat('|'))
  return n.length == 1 ? n[0] : { type: 'choice', exprs: n }
}
function Tz(e) {
  let n = []
  do n.push(Az(e))
  while (e.next && e.next != ')' && e.next != '|')
  return n.length == 1 ? n[0] : { type: 'seq', exprs: n }
}
function Az(e) {
  let n = Pz(e)
  for (;;)
    if (e.eat('+')) n = { type: 'plus', expr: n }
    else if (e.eat('*')) n = { type: 'star', expr: n }
    else if (e.eat('?')) n = { type: 'opt', expr: n }
    else if (e.eat('{')) n = Rz(e, n)
    else break
  return n
}
function dv(e) {
  ;/\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'")
  let n = Number(e.next)
  return (e.pos++, n)
}
function Rz(e, n) {
  let t = dv(e),
    r = t
  return (
    e.eat(',') && (e.next != '}' ? (r = dv(e)) : (r = -1)),
    e.eat('}') || e.err('Unclosed braced range'),
    { type: 'range', min: t, max: r, expr: n }
  )
}
function Oz(e, n) {
  let t = e.nodeTypes,
    r = t[n]
  if (r) return [r]
  let i = []
  for (let s in t) {
    let o = t[s]
    o.isInGroup(n) && i.push(o)
  }
  return (i.length == 0 && e.err("No node type or group '" + n + "' found"), i)
}
function Pz(e) {
  if (e.eat('(')) {
    let n = x5(e)
    return (e.eat(')') || e.err('Missing closing paren'), n)
  } else if (/\W/.test(e.next)) e.err("Unexpected token '" + e.next + "'")
  else {
    let n = Oz(e, e.next).map(
      (t) => (
        e.inline == null
          ? (e.inline = t.isInline)
          : e.inline != t.isInline && e.err('Mixing inline and block content'),
        { type: 'name', value: t }
      ),
    )
    return (e.pos++, n.length == 1 ? n[0] : { type: 'choice', exprs: n })
  }
}
function Nz(e) {
  let n = [[]]
  return (i(s(e, 0), t()), n)
  function t() {
    return n.push([]) - 1
  }
  function r(o, a, l) {
    let c = { term: l, to: a }
    return (n[o].push(c), c)
  }
  function i(o, a) {
    o.forEach((l) => (l.to = a))
  }
  function s(o, a) {
    if (o.type == 'choice') return o.exprs.reduce((l, c) => l.concat(s(c, a)), [])
    if (o.type == 'seq')
      for (let l = 0; ; l++) {
        let c = s(o.exprs[l], a)
        if (l == o.exprs.length - 1) return c
        i(c, (a = t()))
      }
    else if (o.type == 'star') {
      let l = t()
      return (r(a, l), i(s(o.expr, l), l), [r(l)])
    } else if (o.type == 'plus') {
      let l = t()
      return (i(s(o.expr, a), l), i(s(o.expr, l), l), [r(l)])
    } else {
      if (o.type == 'opt') return [r(a)].concat(s(o.expr, a))
      if (o.type == 'range') {
        let l = a
        for (let c = 0; c < o.min; c++) {
          let u = t()
          ;(i(s(o.expr, l), u), (l = u))
        }
        if (o.max == -1) i(s(o.expr, l), l)
        else
          for (let c = o.min; c < o.max; c++) {
            let u = t()
            ;(r(l, u), i(s(o.expr, l), u), (l = u))
          }
        return [r(l)]
      } else {
        if (o.type == 'name') return [r(a, void 0, o.value)]
        throw new Error('Unknown expr type')
      }
    }
  }
}
function S5(e, n) {
  return n - e
}
function hv(e, n) {
  let t = []
  return (r(n), t.sort(S5))
  function r(i) {
    let s = e[i]
    if (s.length == 1 && !s[0].term) return r(s[0].to)
    t.push(i)
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o]
      !a && t.indexOf(l) == -1 && r(l)
    }
  }
}
function Iz(e) {
  let n = Object.create(null)
  return t(hv(e, 0))
  function t(r) {
    let i = []
    r.forEach((o) => {
      e[o].forEach(({ term: a, to: l }) => {
        if (!a) return
        let c
        for (let u = 0; u < i.length; u++) i[u][0] == a && (c = i[u][1])
        hv(e, l).forEach((u) => {
          ;(c || i.push([a, (c = [])]), c.indexOf(u) == -1 && c.push(u))
        })
      })
    })
    let s = (n[r.join(',')] = new Ls(r.indexOf(e.length - 1) > -1))
    for (let o = 0; o < i.length; o++) {
      let a = i[o][1].sort(S5)
      s.next.push({ type: i[o][0], next: n[a.join(',')] || t(a) })
    }
    return s
  }
}
function Dz(e, n) {
  for (let t = 0, r = [e]; t < r.length; t++) {
    let i = r[t],
      s = !i.validEnd,
      o = []
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: c } = i.next[a]
      ;(o.push(l.name),
        s && !(l.isText || l.hasRequiredAttrs()) && (s = !1),
        r.indexOf(c) == -1 && r.push(c))
    }
    s &&
      n.err(
        'Only non-generatable nodes (' +
          o.join(', ') +
          ') in a required position (see https://prosemirror.net/docs/guide/#generatable)',
      )
  }
}
function _5(e) {
  let n = Object.create(null)
  for (let t in e) {
    let r = e[t]
    if (!r.hasDefault) return null
    n[t] = r.default
  }
  return n
}
function k5(e, n) {
  let t = Object.create(null)
  for (let r in e) {
    let i = n && n[r]
    if (i === void 0) {
      let s = e[r]
      if (s.hasDefault) i = s.default
      else throw new RangeError('No value supplied for attribute ' + r)
    }
    t[r] = i
  }
  return t
}
function C5(e, n, t, r) {
  for (let i in n)
    if (!(i in e)) throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`)
  for (let i in e) {
    let s = e[i]
    s.validate && s.validate(n[i])
  }
}
function M5(e, n) {
  let t = Object.create(null)
  if (n) for (let r in n) t[r] = new Lz(e, r, n[r])
  return t
}
let pv = class E5 {
  constructor(n, t, r) {
    ;((this.name = n),
      (this.schema = t),
      (this.spec = r),
      (this.markSet = null),
      (this.groups = r.group ? r.group.split(' ') : []),
      (this.attrs = M5(n, r.attrs)),
      (this.defaultAttrs = _5(this.attrs)),
      (this.contentMatch = null),
      (this.inlineContent = null),
      (this.isBlock = !(r.inline || n == 'text')),
      (this.isText = n == 'text'))
  }
  get isInline() {
    return !this.isBlock
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent
  }
  get isLeaf() {
    return this.contentMatch == Ls.empty
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom
  }
  isInGroup(n) {
    return this.groups.indexOf(n) > -1
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? 'pre' : 'normal')
  }
  hasRequiredAttrs() {
    for (let n in this.attrs) if (this.attrs[n].isRequired) return !0
    return !1
  }
  compatibleContent(n) {
    return this == n || this.contentMatch.compatible(n.contentMatch)
  }
  computeAttrs(n) {
    return !n && this.defaultAttrs ? this.defaultAttrs : k5(this.attrs, n)
  }
  create(n = null, t, r) {
    if (this.isText) throw new Error("NodeType.create can't construct text nodes")
    return new Li(this, this.computeAttrs(n), St.from(t), Oe.setFrom(r))
  }
  createChecked(n = null, t, r) {
    return (
      (t = St.from(t)),
      this.checkContent(t),
      new Li(this, this.computeAttrs(n), t, Oe.setFrom(r))
    )
  }
  createAndFill(n = null, t, r) {
    if (((n = this.computeAttrs(n)), (t = St.from(t)), t.size)) {
      let o = this.contentMatch.fillBefore(t)
      if (!o) return null
      t = o.append(t)
    }
    let i = this.contentMatch.matchFragment(t),
      s = i && i.fillBefore(St.empty, !0)
    return s ? new Li(this, n, t.append(s), Oe.setFrom(r)) : null
  }
  validContent(n) {
    let t = this.contentMatch.matchFragment(n)
    if (!t || !t.validEnd) return !1
    for (let r = 0; r < n.childCount; r++) if (!this.allowsMarks(n.child(r).marks)) return !1
    return !0
  }
  checkContent(n) {
    if (!this.validContent(n))
      throw new RangeError(`Invalid content for node ${this.name}: ${n.toString().slice(0, 50)}`)
  }
  checkAttrs(n) {
    C5(this.attrs, n, 'node', this.name)
  }
  allowsMarkType(n) {
    return this.markSet == null || this.markSet.indexOf(n) > -1
  }
  allowsMarks(n) {
    if (this.markSet == null) return !0
    for (let t = 0; t < n.length; t++) if (!this.allowsMarkType(n[t].type)) return !1
    return !0
  }
  allowedMarks(n) {
    if (this.markSet == null) return n
    let t
    for (let r = 0; r < n.length; r++)
      this.allowsMarkType(n[r].type) ? t && t.push(n[r]) : t || (t = n.slice(0, r))
    return t ? (t.length ? t : Oe.none) : n
  }
  static compile(n, t) {
    let r = Object.create(null)
    n.forEach((s, o) => (r[s] = new E5(s, t, o)))
    let i = t.spec.topNode || 'doc'
    if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')")
    if (!r.text) throw new RangeError("Every schema needs a 'text' type")
    for (let s in r.text.attrs)
      throw new RangeError('The text node type should not have attributes')
    return r
  }
}
function jz(e, n, t) {
  let r = t.split('|')
  return (i) => {
    let s = i === null ? 'null' : typeof i
    if (r.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${n} on type ${e}, got ${s}`)
  }
}
class Lz {
  constructor(n, t, r) {
    ;((this.hasDefault = Object.prototype.hasOwnProperty.call(r, 'default')),
      (this.default = r.default),
      (this.validate = typeof r.validate == 'string' ? jz(n, t, r.validate) : r.validate))
  }
  get isRequired() {
    return !this.hasDefault
  }
}
class Gf {
  constructor(n, t, r, i) {
    ;((this.name = n),
      (this.rank = t),
      (this.schema = r),
      (this.spec = i),
      (this.attrs = M5(n, i.attrs)),
      (this.excluded = null))
    let s = _5(this.attrs)
    this.instance = s ? new Oe(this, s) : null
  }
  create(n = null) {
    return !n && this.instance ? this.instance : new Oe(this, k5(this.attrs, n))
  }
  static compile(n, t) {
    let r = Object.create(null),
      i = 0
    return (n.forEach((s, o) => (r[s] = new Gf(s, i++, t, o))), r)
  }
  removeFromSet(n) {
    for (var t = 0; t < n.length; t++)
      n[t].type == this && ((n = n.slice(0, t).concat(n.slice(t + 1))), t--)
    return n
  }
  isInSet(n) {
    for (let t = 0; t < n.length; t++) if (n[t].type == this) return n[t]
  }
  checkAttrs(n) {
    C5(this.attrs, n, 'mark', this.name)
  }
  excludes(n) {
    return this.excluded.indexOf(n) > -1
  }
}
class T5 {
  constructor(n) {
    ;((this.linebreakReplacement = null), (this.cached = Object.create(null)))
    let t = (this.spec = {})
    for (let i in n) t[i] = n[i]
    ;((t.nodes = yn.from(n.nodes)),
      (t.marks = yn.from(n.marks || {})),
      (this.nodes = pv.compile(this.spec.nodes, this)),
      (this.marks = Gf.compile(this.spec.marks, this)))
    let r = Object.create(null)
    for (let i in this.nodes) {
      if (i in this.marks) throw new RangeError(i + ' can not be both a node and a mark')
      let s = this.nodes[i],
        o = s.spec.content || '',
        a = s.spec.marks
      if (
        ((s.contentMatch = r[o] || (r[o] = Ls.parse(o, this.nodes))),
        (s.inlineContent = s.contentMatch.inlineContent),
        s.spec.linebreakReplacement)
      ) {
        if (this.linebreakReplacement) throw new RangeError('Multiple linebreak nodes defined')
        if (!s.isInline || !s.isLeaf)
          throw new RangeError('Linebreak replacement nodes must be inline leaf nodes')
        this.linebreakReplacement = s
      }
      s.markSet =
        a == '_' ? null : a ? mv(this, a.split(' ')) : a == '' || !s.inlineContent ? [] : null
    }
    for (let i in this.marks) {
      let s = this.marks[i],
        o = s.spec.excludes
      s.excluded = o == null ? [s] : o == '' ? [] : mv(this, o.split(' '))
    }
    ;((this.nodeFromJSON = (i) => Li.fromJSON(this, i)),
      (this.markFromJSON = (i) => Oe.fromJSON(this, i)),
      (this.topNodeType = this.nodes[this.spec.topNode || 'doc']),
      (this.cached.wrappings = Object.create(null)))
  }
  node(n, t = null, r, i) {
    if (typeof n == 'string') n = this.nodeType(n)
    else if (n instanceof pv) {
      if (n.schema != this)
        throw new RangeError('Node type from different schema used (' + n.name + ')')
    } else throw new RangeError('Invalid node type: ' + n)
    return n.createChecked(t, r, i)
  }
  text(n, t) {
    let r = this.nodes.text
    return new Nu(r, r.defaultAttrs, n, Oe.setFrom(t))
  }
  mark(n, t) {
    return (typeof n == 'string' && (n = this.marks[n]), n.create(t))
  }
  nodeType(n) {
    let t = this.nodes[n]
    if (!t) throw new RangeError('Unknown node type: ' + n)
    return t
  }
}
function mv(e, n) {
  let t = []
  for (let r = 0; r < n.length; r++) {
    let i = n[r],
      s = e.marks[i],
      o = s
    if (s) t.push(s)
    else
      for (let a in e.marks) {
        let l = e.marks[a]
        ;(i == '_' || (l.spec.group && l.spec.group.split(' ').indexOf(i) > -1)) && t.push((o = l))
      }
    if (!o) throw new SyntaxError("Unknown mark type: '" + n[r] + "'")
  }
  return t
}
function Fz(e) {
  return e.tag != null
}
function Bz(e) {
  return e.style != null
}
class Fi {
  constructor(n, t) {
    ;((this.schema = n), (this.rules = t), (this.tags = []), (this.styles = []))
    let r = (this.matchedStyles = [])
    ;(t.forEach((i) => {
      if (Fz(i)) this.tags.push(i)
      else if (Bz(i)) {
        let s = /[^=]*/.exec(i.style)[0]
        ;(r.indexOf(s) < 0 && r.push(s), this.styles.push(i))
      }
    }),
      (this.normalizeLists = !this.tags.some((i) => {
        if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1
        let s = n.nodes[i.node]
        return s.contentMatch.matchType(s)
      })))
  }
  parse(n, t = {}) {
    let r = new yv(this, t, !1)
    return (r.addAll(n, Oe.none, t.from, t.to), r.finish())
  }
  parseSlice(n, t = {}) {
    let r = new yv(this, t, !0)
    return (r.addAll(n, Oe.none, t.from, t.to), jt.maxOpen(r.finish()))
  }
  matchTag(n, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i]
      if (
        Vz(n, s.tag) &&
        (s.namespace === void 0 || n.namespaceURI == s.namespace) &&
        (!s.context || t.matchesContext(s.context))
      ) {
        if (s.getAttrs) {
          let o = s.getAttrs(n)
          if (o === !1) continue
          s.attrs = o || void 0
        }
        return s
      }
    }
  }
  matchStyle(n, t, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s],
        a = o.style
      if (
        !(
          a.indexOf(n) != 0 ||
          (o.context && !r.matchesContext(o.context)) ||
          (a.length > n.length && (a.charCodeAt(n.length) != 61 || a.slice(n.length + 1) != t))
        )
      ) {
        if (o.getAttrs) {
          let l = o.getAttrs(t)
          if (l === !1) continue
          o.attrs = l || void 0
        }
        return o
      }
    }
  }
  static schemaRules(n) {
    let t = []
    function r(i) {
      let s = i.priority == null ? 50 : i.priority,
        o = 0
      for (; o < t.length; o++) {
        let a = t[o]
        if ((a.priority == null ? 50 : a.priority) < s) break
      }
      t.splice(o, 0, i)
    }
    for (let i in n.marks) {
      let s = n.marks[i].spec.parseDOM
      s &&
        s.forEach((o) => {
          ;(r((o = bv(o))), o.mark || o.ignore || o.clearMark || (o.mark = i))
        })
    }
    for (let i in n.nodes) {
      let s = n.nodes[i].spec.parseDOM
      s &&
        s.forEach((o) => {
          ;(r((o = bv(o))), o.node || o.ignore || o.mark || (o.node = i))
        })
    }
    return t
  }
  static fromSchema(n) {
    return n.cached.domParser || (n.cached.domParser = new Fi(n, Fi.schemaRules(n)))
  }
}
const A5 = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0,
  },
  zz = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 },
  R5 = { ol: !0, ul: !0 },
  pl = 1,
  Xp = 2,
  Ba = 4
function gv(e, n, t) {
  return n != null
    ? (n ? pl : 0) | (n === 'full' ? Xp : 0)
    : e && e.whitespace == 'pre'
      ? pl | Xp
      : t & ~Ba
}
class xc {
  constructor(n, t, r, i, s, o) {
    ;((this.type = n),
      (this.attrs = t),
      (this.marks = r),
      (this.solid = i),
      (this.options = o),
      (this.content = []),
      (this.activeMarks = Oe.none),
      (this.match = s || (o & Ba ? null : n.contentMatch)))
  }
  findWrapping(n) {
    if (!this.match) {
      if (!this.type) return []
      let t = this.type.contentMatch.fillBefore(St.from(n))
      if (t) this.match = this.type.contentMatch.matchFragment(t)
      else {
        let r = this.type.contentMatch,
          i
        return (i = r.findWrapping(n.type)) ? ((this.match = r), i) : null
      }
    }
    return this.match.findWrapping(n.type)
  }
  finish(n) {
    if (!(this.options & pl)) {
      let r = this.content[this.content.length - 1],
        i
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r
        r.text.length == i[0].length
          ? this.content.pop()
          : (this.content[this.content.length - 1] = s.withText(
              s.text.slice(0, s.text.length - i[0].length),
            ))
      }
    }
    let t = St.from(this.content)
    return (
      !n && this.match && (t = t.append(this.match.fillBefore(St.empty, !0))),
      this.type ? this.type.create(this.attrs, t, this.marks) : t
    )
  }
  inlineContext(n) {
    return this.type
      ? this.type.inlineContent
      : this.content.length
        ? this.content[0].isInline
        : n.parentNode && !A5.hasOwnProperty(n.parentNode.nodeName.toLowerCase())
  }
}
class yv {
  constructor(n, t, r) {
    ;((this.parser = n),
      (this.options = t),
      (this.isOpen = r),
      (this.open = 0),
      (this.localPreserveWS = !1))
    let i = t.topNode,
      s,
      o = gv(null, t.preserveWhitespace, 0) | (r ? Ba : 0)
    ;(i
      ? (s = new xc(i.type, i.attrs, Oe.none, !0, t.topMatch || i.type.contentMatch, o))
      : r
        ? (s = new xc(null, null, Oe.none, !0, null, o))
        : (s = new xc(n.schema.topNodeType, null, Oe.none, !0, null, o)),
      (this.nodes = [s]),
      (this.find = t.findPositions),
      (this.needsBlock = !1))
  }
  get top() {
    return this.nodes[this.open]
  }
  addDOM(n, t) {
    n.nodeType == 3 ? this.addTextNode(n, t) : n.nodeType == 1 && this.addElement(n, t)
  }
  addTextNode(n, t) {
    let r = n.nodeValue,
      i = this.top,
      s = i.options & Xp ? 'full' : this.localPreserveWS || (i.options & pl) > 0
    if (s === 'full' || i.inlineContext(n) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s)
        s !== 'full'
          ? (r = r.replace(/\r?\n|\r/g, ' '))
          : (r = r.replace(
              /\r\n?/g,
              `
`,
            ))
      else if (
        ((r = r.replace(/[ \t\r\n\u000c]+/g, ' ')),
        /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1)
      ) {
        let o = i.content[i.content.length - 1],
          a = n.previousSibling
        ;(!o || (a && a.nodeName == 'BR') || (o.isText && /[ \t\r\n\u000c]$/.test(o.text))) &&
          (r = r.slice(1))
      }
      ;(r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(n))
    } else this.findInside(n)
  }
  addElement(n, t, r) {
    let i = this.localPreserveWS,
      s = this.top
    ;(n.tagName == 'PRE' || /pre/.test(n.style && n.style.whiteSpace)) &&
      (this.localPreserveWS = !0)
    let o = n.nodeName.toLowerCase(),
      a
    R5.hasOwnProperty(o) && this.parser.normalizeLists && $z(n)
    let l =
      (this.options.ruleFromNode && this.options.ruleFromNode(n)) ||
      (a = this.parser.matchTag(n, this, r))
    t: if (l ? l.ignore : zz.hasOwnProperty(o)) (this.findInside(n), this.ignoreFallback(n, t))
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent
        ? (this.open = Math.max(0, this.open - 1))
        : l && l.skip.nodeType && (n = l.skip)
      let c,
        u = this.needsBlock
      if (A5.hasOwnProperty(o))
        (s.content.length && s.content[0].isInline && this.open && (this.open--, (s = this.top)),
          (c = !0),
          s.type || (this.needsBlock = !0))
      else if (!n.firstChild) {
        this.leafFallback(n, t)
        break t
      }
      let f = l && l.skip ? t : this.readStyles(n, t)
      ;(f && this.addAll(n, f), c && this.sync(s), (this.needsBlock = u))
    } else {
      let c = this.readStyles(n, t)
      c && this.addElementByRule(n, l, c, l.consuming === !1 ? a : void 0)
    }
    this.localPreserveWS = i
  }
  leafFallback(n, t) {
    n.nodeName == 'BR' &&
      this.top.type &&
      this.top.type.inlineContent &&
      this.addTextNode(
        n.ownerDocument.createTextNode(`
`),
        t,
      )
  }
  ignoreFallback(n, t) {
    n.nodeName == 'BR' &&
      (!this.top.type || !this.top.type.inlineContent) &&
      this.findPlace(this.parser.schema.text('-'), t, !0)
  }
  readStyles(n, t) {
    let r = n.style
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i],
          o = r.getPropertyValue(s)
        if (o)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(s, o, this, a)
            if (!l) break
            if (l.ignore) return null
            if (
              (l.clearMark
                ? (t = t.filter((c) => !l.clearMark(c)))
                : (t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs))),
              l.consuming === !1)
            )
              a = l
            else break
          }
      }
    return t
  }
  addElementByRule(n, t, r, i) {
    let s, o
    if (t.node)
      if (((o = this.parser.schema.nodes[t.node]), o.isLeaf))
        this.insertNode(o.create(t.attrs), r, n.nodeName == 'BR') || this.leafFallback(n, r)
      else {
        let l = this.enter(o, t.attrs || null, r, t.preserveWhitespace)
        l && ((s = !0), (r = l))
      }
    else {
      let l = this.parser.schema.marks[t.mark]
      r = r.concat(l.create(t.attrs))
    }
    let a = this.top
    if (o && o.isLeaf) this.findInside(n)
    else if (i) this.addElement(n, r, i)
    else if (t.getContent)
      (this.findInside(n),
        t.getContent(n, this.parser.schema).forEach((l) => this.insertNode(l, r, !1)))
    else {
      let l = n
      ;(typeof t.contentElement == 'string'
        ? (l = n.querySelector(t.contentElement))
        : typeof t.contentElement == 'function'
          ? (l = t.contentElement(n))
          : t.contentElement && (l = t.contentElement),
        this.findAround(n, l, !0),
        this.addAll(l, r),
        this.findAround(n, l, !1))
    }
    s && this.sync(a) && this.open--
  }
  addAll(n, t, r, i) {
    let s = r || 0
    for (
      let o = r ? n.childNodes[r] : n.firstChild, a = i == null ? null : n.childNodes[i];
      o != a;
      o = o.nextSibling, ++s
    )
      (this.findAtPoint(n, s), this.addDOM(o, t))
    this.findAtPoint(n, s)
  }
  findPlace(n, t, r) {
    let i, s
    for (let o = this.open, a = 0; o >= 0; o--) {
      let l = this.nodes[o],
        c = l.findWrapping(n)
      if (c && (!i || i.length > c.length + a) && ((i = c), (s = l), !c.length)) break
      if (l.solid) {
        if (r) break
        a += 2
      }
    }
    if (!i) return null
    this.sync(s)
    for (let o = 0; o < i.length; o++) t = this.enterInner(i[o], null, t, !1)
    return t
  }
  insertNode(n, t, r) {
    if (n.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext()
      s && (t = this.enterInner(s, null, t))
    }
    let i = this.findPlace(n, t, r)
    if (i) {
      this.closeExtra()
      let s = this.top
      s.match && (s.match = s.match.matchType(n.type))
      let o = Oe.none
      for (let a of i.concat(n.marks))
        (s.type ? s.type.allowsMarkType(a.type) : vv(a.type, n.type)) && (o = a.addToSet(o))
      return (s.content.push(n.mark(o)), !0)
    }
    return !1
  }
  enter(n, t, r, i) {
    let s = this.findPlace(n.create(t), r, !1)
    return (s && (s = this.enterInner(n, t, r, !0, i)), s)
  }
  enterInner(n, t, r, i = !1, s) {
    this.closeExtra()
    let o = this.top
    o.match = o.match && o.match.matchType(n)
    let a = gv(n, s, o.options)
    o.options & Ba && o.content.length == 0 && (a |= Ba)
    let l = Oe.none
    return (
      (r = r.filter((c) =>
        (o.type ? o.type.allowsMarkType(c.type) : vv(c.type, n)) ? ((l = c.addToSet(l)), !1) : !0,
      )),
      this.nodes.push(new xc(n, t, l, i, null, a)),
      this.open++,
      r
    )
  }
  closeExtra(n = !1) {
    let t = this.nodes.length - 1
    if (t > this.open) {
      for (; t > this.open; t--) this.nodes[t - 1].content.push(this.nodes[t].finish(n))
      this.nodes.length = this.open + 1
    }
  }
  finish() {
    return (
      (this.open = 0),
      this.closeExtra(this.isOpen),
      this.nodes[0].finish(!!(this.isOpen || this.options.topOpen))
    )
  }
  sync(n) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == n) return ((this.open = t), !0)
      this.localPreserveWS && (this.nodes[t].options |= pl)
    }
    return !1
  }
  get currentPos() {
    this.closeExtra()
    let n = 0
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content
      for (let i = r.length - 1; i >= 0; i--) n += r[i].nodeSize
      t && n++
    }
    return n
  }
  findAtPoint(n, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == n && this.find[r].offset == t && (this.find[r].pos = this.currentPos)
  }
  findInside(n) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null &&
          n.nodeType == 1 &&
          n.contains(this.find[t].node) &&
          (this.find[t].pos = this.currentPos)
  }
  findAround(n, t, r) {
    if (n != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null &&
          n.nodeType == 1 &&
          n.contains(this.find[i].node) &&
          t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) &&
          (this.find[i].pos = this.currentPos)
  }
  findInText(n) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == n &&
          (this.find[t].pos = this.currentPos - (n.nodeValue.length - this.find[t].offset))
  }
  matchesContext(n) {
    if (n.indexOf('|') > -1) return n.split(/\s*\|\s*/).some(this.matchesContext, this)
    let t = n.split('/'),
      r = this.options.context,
      i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
      s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1),
      o = (a, l) => {
        for (; a >= 0; a--) {
          let c = t[a]
          if (c == '') {
            if (a == t.length - 1 || a == 0) continue
            for (; l >= s; l--) if (o(a - 1, l)) return !0
            return !1
          } else {
            let u =
              l > 0 || (l == 0 && i) ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null
            if (!u || (u.name != c && !u.isInGroup(c))) return !1
            l--
          }
        }
        return !0
      }
    return o(t.length - 1, this.open)
  }
  textblockFromContext() {
    let n = this.options.context
    if (n)
      for (let t = n.depth; t >= 0; t--) {
        let r = n.node(t).contentMatchAt(n.indexAfter(t)).defaultType
        if (r && r.isTextblock && r.defaultAttrs) return r
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t]
      if (r.isTextblock && r.defaultAttrs) return r
    }
  }
}
function $z(e) {
  for (let n = e.firstChild, t = null; n; n = n.nextSibling) {
    let r = n.nodeType == 1 ? n.nodeName.toLowerCase() : null
    r && R5.hasOwnProperty(r) && t
      ? (t.appendChild(n), (n = t))
      : r == 'li'
        ? (t = n)
        : r && (t = null)
  }
}
function Vz(e, n) {
  return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(
    e,
    n,
  )
}
function bv(e) {
  let n = {}
  for (let t in e) n[t] = e[t]
  return n
}
function vv(e, n) {
  let t = n.schema.nodes
  for (let r in t) {
    let i = t[r]
    if (!i.allowsMarkType(e)) continue
    let s = [],
      o = (a) => {
        s.push(a)
        for (let l = 0; l < a.edgeCount; l++) {
          let { type: c, next: u } = a.edge(l)
          if (c == n || (s.indexOf(u) < 0 && o(u))) return !0
        }
      }
    if (o(i.contentMatch)) return !0
  }
}
class Hs {
  constructor(n, t) {
    ;((this.nodes = n), (this.marks = t))
  }
  serializeFragment(n, t = {}, r) {
    r || (r = oh(t).createDocumentFragment())
    let i = r,
      s = []
    return (
      n.forEach((o) => {
        if (s.length || o.marks.length) {
          let a = 0,
            l = 0
          for (; a < s.length && l < o.marks.length; ) {
            let c = o.marks[l]
            if (!this.marks[c.type.name]) {
              l++
              continue
            }
            if (!c.eq(s[a][0]) || c.type.spec.spanning === !1) break
            ;(a++, l++)
          }
          for (; a < s.length; ) i = s.pop()[1]
          for (; l < o.marks.length; ) {
            let c = o.marks[l++],
              u = this.serializeMark(c, o.isInline, t)
            u && (s.push([c, i]), i.appendChild(u.dom), (i = u.contentDOM || u.dom))
          }
        }
        i.appendChild(this.serializeNodeInner(o, t))
      }),
      r
    )
  }
  serializeNodeInner(n, t) {
    let { dom: r, contentDOM: i } = zc(oh(t), this.nodes[n.type.name](n), null, n.attrs)
    if (i) {
      if (n.isLeaf) throw new RangeError('Content hole not allowed in a leaf node spec')
      this.serializeFragment(n.content, t, i)
    }
    return r
  }
  serializeNode(n, t = {}) {
    let r = this.serializeNodeInner(n, t)
    for (let i = n.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(n.marks[i], n.isInline, t)
      s && ((s.contentDOM || s.dom).appendChild(r), (r = s.dom))
    }
    return r
  }
  serializeMark(n, t, r = {}) {
    let i = this.marks[n.type.name]
    return i && zc(oh(r), i(n, t), null, n.attrs)
  }
  static renderSpec(n, t, r = null, i) {
    return zc(n, t, r, i)
  }
  static fromSchema(n) {
    return (
      n.cached.domSerializer ||
      (n.cached.domSerializer = new Hs(this.nodesFromSchema(n), this.marksFromSchema(n)))
    )
  }
  static nodesFromSchema(n) {
    let t = wv(n.nodes)
    return (t.text || (t.text = (r) => r.text), t)
  }
  static marksFromSchema(n) {
    return wv(n.marks)
  }
}
function wv(e) {
  let n = {}
  for (let t in e) {
    let r = e[t].spec.toDOM
    r && (n[t] = r)
  }
  return n
}
function oh(e) {
  return e.document || window.document
}
const xv = new WeakMap()
function Hz(e) {
  let n = xv.get(e)
  return (n === void 0 && xv.set(e, (n = Uz(e))), n)
}
function Uz(e) {
  let n = null
  function t(r) {
    if (r && typeof r == 'object')
      if (Array.isArray(r))
        if (typeof r[0] == 'string') (n || (n = []), n.push(r))
        else for (let i = 0; i < r.length; i++) t(r[i])
      else for (let i in r) t(r[i])
  }
  return (t(e), n)
}
function zc(e, n, t, r) {
  if (typeof n == 'string') return { dom: e.createTextNode(n) }
  if (n.nodeType != null) return { dom: n }
  if (n.dom && n.dom.nodeType != null) return n
  let i = n[0],
    s
  if (typeof i != 'string') throw new RangeError('Invalid array passed to renderSpec')
  if (r && (s = Hz(r)) && s.indexOf(n) > -1)
    throw new RangeError(
      'Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.',
    )
  let o = i.indexOf(' ')
  o > 0 && ((t = i.slice(0, o)), (i = i.slice(o + 1)))
  let a,
    l = t ? e.createElementNS(t, i) : e.createElement(i),
    c = n[1],
    u = 1
  if (c && typeof c == 'object' && c.nodeType == null && !Array.isArray(c)) {
    u = 2
    for (let f in c)
      if (c[f] != null) {
        let d = f.indexOf(' ')
        d > 0
          ? l.setAttributeNS(f.slice(0, d), f.slice(d + 1), c[f])
          : f == 'style' && l.style
            ? (l.style.cssText = c[f])
            : l.setAttribute(f, c[f])
      }
  }
  for (let f = u; f < n.length; f++) {
    let d = n[f]
    if (d === 0) {
      if (f < n.length - 1 || f > u)
        throw new RangeError('Content hole must be the only child of its parent node')
      return { dom: l, contentDOM: l }
    } else {
      let { dom: h, contentDOM: p } = zc(e, d, t, r)
      if ((l.appendChild(h), p)) {
        if (a) throw new RangeError('Multiple content holes')
        a = p
      }
    }
  }
  return { dom: l, contentDOM: a }
}
const O5 = 65535,
  P5 = Math.pow(2, 16)
function qz(e, n) {
  return e + n * P5
}
function Sv(e) {
  return e & O5
}
function Wz(e) {
  return (e - (e & O5)) / P5
}
const N5 = 1,
  I5 = 2,
  $c = 4,
  D5 = 8
class Yp {
  constructor(n, t, r) {
    ;((this.pos = n), (this.delInfo = t), (this.recover = r))
  }
  get deleted() {
    return (this.delInfo & D5) > 0
  }
  get deletedBefore() {
    return (this.delInfo & (N5 | $c)) > 0
  }
  get deletedAfter() {
    return (this.delInfo & (I5 | $c)) > 0
  }
  get deletedAcross() {
    return (this.delInfo & $c) > 0
  }
}
class Vn {
  constructor(n, t = !1) {
    if (((this.ranges = n), (this.inverted = t), !n.length && Vn.empty)) return Vn.empty
  }
  recover(n) {
    let t = 0,
      r = Sv(n)
    if (!this.inverted)
      for (let i = 0; i < r; i++) t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]
    return this.ranges[r * 3] + t + Wz(n)
  }
  mapResult(n, t = 1) {
    return this._map(n, t, !1)
  }
  map(n, t = 1) {
    return this._map(n, t, !0)
  }
  _map(n, t, r) {
    let i = 0,
      s = this.inverted ? 2 : 1,
      o = this.inverted ? 1 : 2
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0)
      if (l > n) break
      let c = this.ranges[a + s],
        u = this.ranges[a + o],
        f = l + c
      if (n <= f) {
        let d = c ? (n == l ? -1 : n == f ? 1 : t) : t,
          h = l + i + (d < 0 ? 0 : u)
        if (r) return h
        let p = n == (t < 0 ? l : f) ? null : qz(a / 3, n - l),
          g = n == l ? I5 : n == f ? N5 : $c
        return ((t < 0 ? n != l : n != f) && (g |= D5), new Yp(h, g, p))
      }
      i += u - c
    }
    return r ? n + i : new Yp(n + i, 0, null)
  }
  touches(n, t) {
    let r = 0,
      i = Sv(t),
      s = this.inverted ? 2 : 1,
      o = this.inverted ? 1 : 2
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0)
      if (l > n) break
      let c = this.ranges[a + s],
        u = l + c
      if (n <= u && a == i * 3) return !0
      r += this.ranges[a + o] - c
    }
    return !1
  }
  forEach(n) {
    let t = this.inverted ? 2 : 1,
      r = this.inverted ? 1 : 2
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i],
        a = o - (this.inverted ? s : 0),
        l = o + (this.inverted ? 0 : s),
        c = this.ranges[i + t],
        u = this.ranges[i + r]
      ;(n(a, a + c, l, l + u), (s += u - c))
    }
  }
  invert() {
    return new Vn(this.ranges, !this.inverted)
  }
  toString() {
    return (this.inverted ? '-' : '') + JSON.stringify(this.ranges)
  }
  static offset(n) {
    return n == 0 ? Vn.empty : new Vn(n < 0 ? [0, -n, 0] : [0, 0, n])
  }
}
Vn.empty = new Vn([])
class ml {
  constructor(n, t, r = 0, i = n ? n.length : 0) {
    ;((this.mirror = t),
      (this.from = r),
      (this.to = i),
      (this._maps = n || []),
      (this.ownData = !(n || t)))
  }
  get maps() {
    return this._maps
  }
  slice(n = 0, t = this.maps.length) {
    return new ml(this._maps, this.mirror, n, t)
  }
  appendMap(n, t) {
    ;(this.ownData ||
      ((this._maps = this._maps.slice()),
      (this.mirror = this.mirror && this.mirror.slice()),
      (this.ownData = !0)),
      (this.to = this._maps.push(n)),
      t != null && this.setMirror(this._maps.length - 1, t))
  }
  appendMapping(n) {
    for (let t = 0, r = this._maps.length; t < n._maps.length; t++) {
      let i = n.getMirror(t)
      this.appendMap(n._maps[t], i != null && i < t ? r + i : void 0)
    }
  }
  getMirror(n) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == n) return this.mirror[t + (t % 2 ? -1 : 1)]
    }
  }
  setMirror(n, t) {
    ;(this.mirror || (this.mirror = []), this.mirror.push(n, t))
  }
  appendMappingInverted(n) {
    for (let t = n.maps.length - 1, r = this._maps.length + n._maps.length; t >= 0; t--) {
      let i = n.getMirror(t)
      this.appendMap(n._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0)
    }
  }
  invert() {
    let n = new ml()
    return (n.appendMappingInverted(this), n)
  }
  map(n, t = 1) {
    if (this.mirror) return this._map(n, t, !0)
    for (let r = this.from; r < this.to; r++) n = this._maps[r].map(n, t)
    return n
  }
  mapResult(n, t = 1) {
    return this._map(n, t, !1)
  }
  _map(n, t, r) {
    let i = 0
    for (let s = this.from; s < this.to; s++) {
      let o = this._maps[s],
        a = o.mapResult(n, t)
      if (a.recover != null) {
        let l = this.getMirror(s)
        if (l != null && l > s && l < this.to) {
          ;((s = l), (n = this._maps[l].recover(a.recover)))
          continue
        }
      }
      ;((i |= a.delInfo), (n = a.pos))
    }
    return r ? n : new Yp(n, i, null)
  }
}
const ah = Object.create(null)
class Tn {
  getMap() {
    return Vn.empty
  }
  merge(n) {
    return null
  }
  static fromJSON(n, t) {
    if (!t || !t.stepType) throw new RangeError('Invalid input for Step.fromJSON')
    let r = ah[t.stepType]
    if (!r) throw new RangeError(`No step type ${t.stepType} defined`)
    return r.fromJSON(n, t)
  }
  static jsonID(n, t) {
    if (n in ah) throw new RangeError('Duplicate use of step JSON ID ' + n)
    return ((ah[n] = t), (t.prototype.jsonID = n), t)
  }
}
class Je {
  constructor(n, t) {
    ;((this.doc = n), (this.failed = t))
  }
  static ok(n) {
    return new Je(n, null)
  }
  static fail(n) {
    return new Je(null, n)
  }
  static fromReplace(n, t, r, i) {
    try {
      return Je.ok(n.replace(t, r, i))
    } catch (s) {
      if (s instanceof Ru) return Je.fail(s.message)
      throw s
    }
  }
}
function og(e, n, t) {
  let r = []
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i)
    ;(s.content.size && (s = s.copy(og(s.content, n, s))),
      s.isInline && (s = n(s, t, i)),
      r.push(s))
  }
  return St.fromArray(r)
}
class Ri extends Tn {
  constructor(n, t, r) {
    ;(super(), (this.from = n), (this.to = t), (this.mark = r))
  }
  apply(n) {
    let t = n.slice(this.from, this.to),
      r = n.resolve(this.from),
      i = r.node(r.sharedDepth(this.to)),
      s = new jt(
        og(
          t.content,
          (o, a) =>
            !o.isAtom || !a.type.allowsMarkType(this.mark.type)
              ? o
              : o.mark(this.mark.addToSet(o.marks)),
          i,
        ),
        t.openStart,
        t.openEnd,
      )
    return Je.fromReplace(n, this.from, this.to, s)
  }
  invert() {
    return new yr(this.from, this.to, this.mark)
  }
  map(n) {
    let t = n.mapResult(this.from, 1),
      r = n.mapResult(this.to, -1)
    return (t.deleted && r.deleted) || t.pos >= r.pos ? null : new Ri(t.pos, r.pos, this.mark)
  }
  merge(n) {
    return n instanceof Ri && n.mark.eq(this.mark) && this.from <= n.to && this.to >= n.from
      ? new Ri(Math.min(this.from, n.from), Math.max(this.to, n.to), this.mark)
      : null
  }
  toJSON() {
    return { stepType: 'addMark', mark: this.mark.toJSON(), from: this.from, to: this.to }
  }
  static fromJSON(n, t) {
    if (typeof t.from != 'number' || typeof t.to != 'number')
      throw new RangeError('Invalid input for AddMarkStep.fromJSON')
    return new Ri(t.from, t.to, n.markFromJSON(t.mark))
  }
}
Tn.jsonID('addMark', Ri)
class yr extends Tn {
  constructor(n, t, r) {
    ;(super(), (this.from = n), (this.to = t), (this.mark = r))
  }
  apply(n) {
    let t = n.slice(this.from, this.to),
      r = new jt(
        og(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), n),
        t.openStart,
        t.openEnd,
      )
    return Je.fromReplace(n, this.from, this.to, r)
  }
  invert() {
    return new Ri(this.from, this.to, this.mark)
  }
  map(n) {
    let t = n.mapResult(this.from, 1),
      r = n.mapResult(this.to, -1)
    return (t.deleted && r.deleted) || t.pos >= r.pos ? null : new yr(t.pos, r.pos, this.mark)
  }
  merge(n) {
    return n instanceof yr && n.mark.eq(this.mark) && this.from <= n.to && this.to >= n.from
      ? new yr(Math.min(this.from, n.from), Math.max(this.to, n.to), this.mark)
      : null
  }
  toJSON() {
    return { stepType: 'removeMark', mark: this.mark.toJSON(), from: this.from, to: this.to }
  }
  static fromJSON(n, t) {
    if (typeof t.from != 'number' || typeof t.to != 'number')
      throw new RangeError('Invalid input for RemoveMarkStep.fromJSON')
    return new yr(t.from, t.to, n.markFromJSON(t.mark))
  }
}
Tn.jsonID('removeMark', yr)
class Oi extends Tn {
  constructor(n, t) {
    ;(super(), (this.pos = n), (this.mark = t))
  }
  apply(n) {
    let t = n.nodeAt(this.pos)
    if (!t) return Je.fail("No node at mark step's position")
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks))
    return Je.fromReplace(n, this.pos, this.pos + 1, new jt(St.from(r), 0, t.isLeaf ? 0 : 1))
  }
  invert(n) {
    let t = n.nodeAt(this.pos)
    if (t) {
      let r = this.mark.addToSet(t.marks)
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r)) return new Oi(this.pos, t.marks[i])
        return new Oi(this.pos, this.mark)
      }
    }
    return new Fs(this.pos, this.mark)
  }
  map(n) {
    let t = n.mapResult(this.pos, 1)
    return t.deletedAfter ? null : new Oi(t.pos, this.mark)
  }
  toJSON() {
    return { stepType: 'addNodeMark', pos: this.pos, mark: this.mark.toJSON() }
  }
  static fromJSON(n, t) {
    if (typeof t.pos != 'number') throw new RangeError('Invalid input for AddNodeMarkStep.fromJSON')
    return new Oi(t.pos, n.markFromJSON(t.mark))
  }
}
Tn.jsonID('addNodeMark', Oi)
class Fs extends Tn {
  constructor(n, t) {
    ;(super(), (this.pos = n), (this.mark = t))
  }
  apply(n) {
    let t = n.nodeAt(this.pos)
    if (!t) return Je.fail("No node at mark step's position")
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks))
    return Je.fromReplace(n, this.pos, this.pos + 1, new jt(St.from(r), 0, t.isLeaf ? 0 : 1))
  }
  invert(n) {
    let t = n.nodeAt(this.pos)
    return !t || !this.mark.isInSet(t.marks) ? this : new Oi(this.pos, this.mark)
  }
  map(n) {
    let t = n.mapResult(this.pos, 1)
    return t.deletedAfter ? null : new Fs(t.pos, this.mark)
  }
  toJSON() {
    return { stepType: 'removeNodeMark', pos: this.pos, mark: this.mark.toJSON() }
  }
  static fromJSON(n, t) {
    if (typeof t.pos != 'number')
      throw new RangeError('Invalid input for RemoveNodeMarkStep.fromJSON')
    return new Fs(t.pos, n.markFromJSON(t.mark))
  }
}
Tn.jsonID('removeNodeMark', Fs)
class cn extends Tn {
  constructor(n, t, r, i = !1) {
    ;(super(), (this.from = n), (this.to = t), (this.slice = r), (this.structure = i))
  }
  apply(n) {
    return this.structure && Zp(n, this.from, this.to)
      ? Je.fail('Structure replace would overwrite content')
      : Je.fromReplace(n, this.from, this.to, this.slice)
  }
  getMap() {
    return new Vn([this.from, this.to - this.from, this.slice.size])
  }
  invert(n) {
    return new cn(this.from, this.from + this.slice.size, n.slice(this.from, this.to))
  }
  map(n) {
    let t = n.mapResult(this.from, 1),
      r = n.mapResult(this.to, -1)
    return t.deletedAcross && r.deletedAcross
      ? null
      : new cn(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure)
  }
  merge(n) {
    if (!(n instanceof cn) || n.structure || this.structure) return null
    if (this.from + this.slice.size == n.from && !this.slice.openEnd && !n.slice.openStart) {
      let t =
        this.slice.size + n.slice.size == 0
          ? jt.empty
          : new jt(
              this.slice.content.append(n.slice.content),
              this.slice.openStart,
              n.slice.openEnd,
            )
      return new cn(this.from, this.to + (n.to - n.from), t, this.structure)
    } else if (n.to == this.from && !this.slice.openStart && !n.slice.openEnd) {
      let t =
        this.slice.size + n.slice.size == 0
          ? jt.empty
          : new jt(
              n.slice.content.append(this.slice.content),
              n.slice.openStart,
              this.slice.openEnd,
            )
      return new cn(n.from, this.to, t, this.structure)
    } else return null
  }
  toJSON() {
    let n = { stepType: 'replace', from: this.from, to: this.to }
    return (
      this.slice.size && (n.slice = this.slice.toJSON()),
      this.structure && (n.structure = !0),
      n
    )
  }
  static fromJSON(n, t) {
    if (typeof t.from != 'number' || typeof t.to != 'number')
      throw new RangeError('Invalid input for ReplaceStep.fromJSON')
    return new cn(t.from, t.to, jt.fromJSON(n, t.slice), !!t.structure)
  }
}
Tn.jsonID('replace', cn)
class un extends Tn {
  constructor(n, t, r, i, s, o, a = !1) {
    ;(super(),
      (this.from = n),
      (this.to = t),
      (this.gapFrom = r),
      (this.gapTo = i),
      (this.slice = s),
      (this.insert = o),
      (this.structure = a))
  }
  apply(n) {
    if (this.structure && (Zp(n, this.from, this.gapFrom) || Zp(n, this.gapTo, this.to)))
      return Je.fail('Structure gap-replace would overwrite content')
    let t = n.slice(this.gapFrom, this.gapTo)
    if (t.openStart || t.openEnd) return Je.fail('Gap is not a flat range')
    let r = this.slice.insertAt(this.insert, t.content)
    return r ? Je.fromReplace(n, this.from, this.to, r) : Je.fail('Content does not fit in gap')
  }
  getMap() {
    return new Vn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert,
    ])
  }
  invert(n) {
    let t = this.gapTo - this.gapFrom
    return new un(
      this.from,
      this.from + this.slice.size + t,
      this.from + this.insert,
      this.from + this.insert + t,
      n.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
      this.gapFrom - this.from,
      this.structure,
    )
  }
  map(n) {
    let t = n.mapResult(this.from, 1),
      r = n.mapResult(this.to, -1),
      i = this.from == this.gapFrom ? t.pos : n.map(this.gapFrom, -1),
      s = this.to == this.gapTo ? r.pos : n.map(this.gapTo, 1)
    return (t.deletedAcross && r.deletedAcross) || i < t.pos || s > r.pos
      ? null
      : new un(t.pos, r.pos, i, s, this.slice, this.insert, this.structure)
  }
  toJSON() {
    let n = {
      stepType: 'replaceAround',
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert,
    }
    return (
      this.slice.size && (n.slice = this.slice.toJSON()),
      this.structure && (n.structure = !0),
      n
    )
  }
  static fromJSON(n, t) {
    if (
      typeof t.from != 'number' ||
      typeof t.to != 'number' ||
      typeof t.gapFrom != 'number' ||
      typeof t.gapTo != 'number' ||
      typeof t.insert != 'number'
    )
      throw new RangeError('Invalid input for ReplaceAroundStep.fromJSON')
    return new un(
      t.from,
      t.to,
      t.gapFrom,
      t.gapTo,
      jt.fromJSON(n, t.slice),
      t.insert,
      !!t.structure,
    )
  }
}
Tn.jsonID('replaceAround', un)
function Zp(e, n, t) {
  let r = e.resolve(n),
    i = t - n,
    s = r.depth
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; ) (s--, i--)
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s))
    for (; i > 0; ) {
      if (!o || o.isLeaf) return !0
      ;((o = o.firstChild), i--)
    }
  }
  return !1
}
function Kz(e, n, t, r) {
  let i = [],
    s = [],
    o,
    a
  ;(e.doc.nodesBetween(n, t, (l, c, u) => {
    if (!l.isInline) return
    let f = l.marks
    if (!r.isInSet(f) && u.type.allowsMarkType(r.type)) {
      let d = Math.max(c, n),
        h = Math.min(c + l.nodeSize, t),
        p = r.addToSet(f)
      for (let g = 0; g < f.length; g++)
        f[g].isInSet(p) ||
          (o && o.to == d && o.mark.eq(f[g]) ? (o.to = h) : i.push((o = new yr(d, h, f[g]))))
      a && a.to == d ? (a.to = h) : s.push((a = new Ri(d, h, r)))
    }
  }),
    i.forEach((l) => e.step(l)),
    s.forEach((l) => e.step(l)))
}
function Gz(e, n, t, r) {
  let i = [],
    s = 0
  ;(e.doc.nodesBetween(n, t, (o, a) => {
    if (!o.isInline) return
    s++
    let l = null
    if (r instanceof Gf) {
      let c = o.marks,
        u
      for (; (u = r.isInSet(c)); ) ((l || (l = [])).push(u), (c = u.removeFromSet(c)))
    } else r ? r.isInSet(o.marks) && (l = [r]) : (l = o.marks)
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, t)
      for (let u = 0; u < l.length; u++) {
        let f = l[u],
          d
        for (let h = 0; h < i.length; h++) {
          let p = i[h]
          p.step == s - 1 && f.eq(i[h].style) && (d = p)
        }
        d ? ((d.to = c), (d.step = s)) : i.push({ style: f, from: Math.max(a, n), to: c, step: s })
      }
    }
  }),
    i.forEach((o) => e.step(new yr(o.from, o.to, o.style))))
}
function ag(e, n, t, r = t.contentMatch, i = !0) {
  let s = e.doc.nodeAt(n),
    o = [],
    a = n + 1
  for (let l = 0; l < s.childCount; l++) {
    let c = s.child(l),
      u = a + c.nodeSize,
      f = r.matchType(c.type)
    if (!f) o.push(new cn(a, u, jt.empty))
    else {
      r = f
      for (let d = 0; d < c.marks.length; d++)
        t.allowsMarkType(c.marks[d].type) || e.step(new yr(a, u, c.marks[d]))
      if (i && c.isText && t.whitespace != 'pre') {
        let d,
          h = /\r?\n|\r/g,
          p
        for (; (d = h.exec(c.text)); )
          (p || (p = new jt(St.from(t.schema.text(' ', t.allowedMarks(c.marks))), 0, 0)),
            o.push(new cn(a + d.index, a + d.index + d[0].length, p)))
      }
    }
    a = u
  }
  if (!r.validEnd) {
    let l = r.fillBefore(St.empty, !0)
    e.replace(a, a, new jt(l, 0, 0))
  }
  for (let l = o.length - 1; l >= 0; l--) e.step(o[l])
}
function Xz(e, n, t) {
  return (n == 0 || e.canReplace(n, e.childCount)) && (t == e.childCount || e.canReplace(0, t))
}
function ra(e) {
  let t = e.parent.content.cutByIndex(e.startIndex, e.endIndex)
  for (let r = e.depth; ; --r) {
    let i = e.$from.node(r),
      s = e.$from.index(r),
      o = e.$to.indexAfter(r)
    if (r < e.depth && i.canReplace(s, o, t)) return r
    if (r == 0 || i.type.spec.isolating || !Xz(i, s, o)) break
  }
  return null
}
function Yz(e, n, t) {
  let { $from: r, $to: i, depth: s } = n,
    o = r.before(s + 1),
    a = i.after(s + 1),
    l = o,
    c = a,
    u = St.empty,
    f = 0
  for (let p = s, g = !1; p > t; p--)
    g || r.index(p) > 0 ? ((g = !0), (u = St.from(r.node(p).copy(u))), f++) : l--
  let d = St.empty,
    h = 0
  for (let p = s, g = !1; p > t; p--)
    g || i.after(p + 1) < i.end(p) ? ((g = !0), (d = St.from(i.node(p).copy(d))), h++) : c++
  e.step(new un(l, c, o, a, new jt(u.append(d), f, h), u.size - f, !0))
}
function lg(e, n, t = null, r = e) {
  let i = Zz(e, n),
    s = i && Jz(r, n)
  return s ? i.map(_v).concat({ type: n, attrs: t }).concat(s.map(_v)) : null
}
function _v(e) {
  return { type: e, attrs: null }
}
function Zz(e, n) {
  let { parent: t, startIndex: r, endIndex: i } = e,
    s = t.contentMatchAt(r).findWrapping(n)
  if (!s) return null
  let o = s.length ? s[0] : n
  return t.canReplaceWith(r, i, o) ? s : null
}
function Jz(e, n) {
  let { parent: t, startIndex: r, endIndex: i } = e,
    s = t.child(r),
    o = n.contentMatch.findWrapping(s.type)
  if (!o) return null
  let l = (o.length ? o[o.length - 1] : n).contentMatch
  for (let c = r; l && c < i; c++) l = l.matchType(t.child(c).type)
  return !l || !l.validEnd ? null : o
}
function Qz(e, n, t) {
  let r = St.empty
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let a = t[o].type.contentMatch.matchFragment(r)
      if (!a || !a.validEnd)
        throw new RangeError(
          'Wrapper type given to Transform.wrap does not form valid content of its parent wrapper',
        )
    }
    r = St.from(t[o].type.create(t[o].attrs, r))
  }
  let i = n.start,
    s = n.end
  e.step(new un(i, s, i, s, new jt(r, 0, 0), t.length, !0))
}
function t$(e, n, t, r, i) {
  if (!r.isTextblock) throw new RangeError('Type given to setBlockType should be a textblock')
  let s = e.steps.length
  e.doc.nodesBetween(n, t, (o, a) => {
    let l = typeof i == 'function' ? i(o) : i
    if (o.isTextblock && !o.hasMarkup(r, l) && e$(e.doc, e.mapping.slice(s).map(a), r)) {
      let c = null
      if (r.schema.linebreakReplacement) {
        let h = r.whitespace == 'pre',
          p = !!r.contentMatch.matchType(r.schema.linebreakReplacement)
        h && !p ? (c = !1) : !h && p && (c = !0)
      }
      ;(c === !1 && L5(e, o, a, s), ag(e, e.mapping.slice(s).map(a, 1), r, void 0, c === null))
      let u = e.mapping.slice(s),
        f = u.map(a, 1),
        d = u.map(a + o.nodeSize, 1)
      return (
        e.step(
          new un(f, d, f + 1, d - 1, new jt(St.from(r.create(l, null, o.marks)), 0, 0), 1, !0),
        ),
        c === !0 && j5(e, o, a, s),
        !1
      )
    }
  })
}
function j5(e, n, t, r) {
  n.forEach((i, s) => {
    if (i.isText) {
      let o,
        a = /\r?\n|\r/g
      for (; (o = a.exec(i.text)); ) {
        let l = e.mapping.slice(r).map(t + 1 + s + o.index)
        e.replaceWith(l, l + 1, n.type.schema.linebreakReplacement.create())
      }
    }
  })
}
function L5(e, n, t, r) {
  n.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = e.mapping.slice(r).map(t + 1 + s)
      e.replaceWith(
        o,
        o + 1,
        n.type.schema.text(`
`),
      )
    }
  })
}
function e$(e, n, t) {
  let r = e.resolve(n),
    i = r.index()
  return r.parent.canReplaceWith(i, i + 1, t)
}
function n$(e, n, t, r, i) {
  let s = e.doc.nodeAt(n)
  if (!s) throw new RangeError('No node at given position')
  t || (t = s.type)
  let o = t.create(r, null, i || s.marks)
  if (s.isLeaf) return e.replaceWith(n, n + s.nodeSize, o)
  if (!t.validContent(s.content)) throw new RangeError('Invalid content for node type ' + t.name)
  e.step(new un(n, n + s.nodeSize, n + 1, n + s.nodeSize - 1, new jt(St.from(o), 0, 0), 1, !0))
}
function Qr(e, n, t = 1, r) {
  let i = e.resolve(n),
    s = i.depth - t,
    o = (r && r[r.length - 1]) || i.parent
  if (
    s < 0 ||
    i.parent.type.spec.isolating ||
    !i.parent.canReplace(i.index(), i.parent.childCount) ||
    !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))
  )
    return !1
  for (let c = i.depth - 1, u = t - 2; c > s; c--, u--) {
    let f = i.node(c),
      d = i.index(c)
    if (f.type.spec.isolating) return !1
    let h = f.content.cutByIndex(d, f.childCount),
      p = r && r[u + 1]
    p && (h = h.replaceChild(0, p.type.create(p.attrs)))
    let g = (r && r[u]) || f
    if (!f.canReplace(d + 1, f.childCount) || !g.type.validContent(h)) return !1
  }
  let a = i.indexAfter(s),
    l = r && r[0]
  return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type)
}
function r$(e, n, t = 1, r) {
  let i = e.doc.resolve(n),
    s = St.empty,
    o = St.empty
  for (let a = i.depth, l = i.depth - t, c = t - 1; a > l; a--, c--) {
    s = St.from(i.node(a).copy(s))
    let u = r && r[c]
    o = St.from(u ? u.type.create(u.attrs, o) : i.node(a).copy(o))
  }
  e.step(new cn(n, n, new jt(s.append(o), t, t), !0))
}
function Yi(e, n) {
  let t = e.resolve(n),
    r = t.index()
  return F5(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1)
}
function i$(e, n) {
  n.content.size || e.type.compatibleContent(n.type)
  let t = e.contentMatchAt(e.childCount),
    { linebreakReplacement: r } = e.type.schema
  for (let i = 0; i < n.childCount; i++) {
    let s = n.child(i),
      o = s.type == r ? e.type.schema.nodes.text : s.type
    if (((t = t.matchType(o)), !t || !e.type.allowsMarks(s.marks))) return !1
  }
  return t.validEnd
}
function F5(e, n) {
  return !!(e && n && !e.isLeaf && i$(e, n))
}
function Xf(e, n, t = -1) {
  let r = e.resolve(n)
  for (let i = r.depth; ; i--) {
    let s,
      o,
      a = r.index(i)
    if (
      (i == r.depth
        ? ((s = r.nodeBefore), (o = r.nodeAfter))
        : t > 0
          ? ((s = r.node(i + 1)), a++, (o = r.node(i).maybeChild(a)))
          : ((s = r.node(i).maybeChild(a - 1)), (o = r.node(i + 1))),
      s && !s.isTextblock && F5(s, o) && r.node(i).canReplace(a, a + 1))
    )
      return n
    if (i == 0) break
    n = t < 0 ? r.before(i) : r.after(i)
  }
}
function s$(e, n, t) {
  let r = null,
    { linebreakReplacement: i } = e.doc.type.schema,
    s = e.doc.resolve(n - t),
    o = s.node().type
  if (i && o.inlineContent) {
    let u = o.whitespace == 'pre',
      f = !!o.contentMatch.matchType(i)
    u && !f ? (r = !1) : !u && f && (r = !0)
  }
  let a = e.steps.length
  if (r === !1) {
    let u = e.doc.resolve(n + t)
    L5(e, u.node(), u.before(), a)
  }
  o.inlineContent && ag(e, n + t - 1, o, s.node().contentMatchAt(s.index()), r == null)
  let l = e.mapping.slice(a),
    c = l.map(n - t)
  if ((e.step(new cn(c, l.map(n + t, -1), jt.empty, !0)), r === !0)) {
    let u = e.doc.resolve(c)
    j5(e, u.node(), u.before(), e.steps.length)
  }
  return e
}
function o$(e, n, t) {
  let r = e.resolve(n)
  if (r.parent.canReplaceWith(r.index(), r.index(), t)) return n
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i)
      if (r.node(i).canReplaceWith(s, s, t)) return r.before(i + 1)
      if (s > 0) return null
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i)
      if (r.node(i).canReplaceWith(s, s, t)) return r.after(i + 1)
      if (s < r.node(i).childCount) return null
    }
  return null
}
function B5(e, n, t) {
  let r = e.resolve(n)
  if (!t.content.size) return n
  let i = t.content
  for (let s = 0; s < t.openStart; s++) i = i.firstChild.content
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1,
        l = r.index(o) + (a > 0 ? 1 : 0),
        c = r.node(o),
        u = !1
      if (s == 1) u = c.canReplace(l, l, i)
      else {
        let f = c.contentMatchAt(l).findWrapping(i.firstChild.type)
        u = f && c.canReplaceWith(l, l, f[0])
      }
      if (u) return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1)
    }
  return null
}
function Yf(e, n, t = n, r = jt.empty) {
  if (n == t && !r.size) return null
  let i = e.resolve(n),
    s = e.resolve(t)
  return z5(i, s, r) ? new cn(n, t, r) : new a$(i, s, r).fit()
}
function z5(e, n, t) {
  return (
    !t.openStart &&
    !t.openEnd &&
    e.start() == n.start() &&
    e.parent.canReplace(e.index(), n.index(), t.content)
  )
}
class a$ {
  constructor(n, t, r) {
    ;((this.$from = n),
      (this.$to = t),
      (this.unplaced = r),
      (this.frontier = []),
      (this.placed = St.empty))
    for (let i = 0; i <= n.depth; i++) {
      let s = n.node(i)
      this.frontier.push({ type: s.type, match: s.contentMatchAt(n.indexAfter(i)) })
    }
    for (let i = n.depth; i > 0; i--) this.placed = St.from(n.node(i).copy(this.placed))
  }
  get depth() {
    return this.frontier.length - 1
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable()
      c ? this.placeNodes(c) : this.openMore() || this.dropNode()
    }
    let n = this.mustMoveInline(),
      t = this.placed.size - this.depth - this.$from.depth,
      r = this.$from,
      i = this.close(n < 0 ? this.$to : r.doc.resolve(n))
    if (!i) return null
    let s = this.placed,
      o = r.depth,
      a = i.depth
    for (; o && a && s.childCount == 1; ) ((s = s.firstChild.content), o--, a--)
    let l = new jt(s, o, a)
    return n > -1
      ? new un(r.pos, n, this.$to.pos, this.$to.end(), l, t)
      : l.size || r.pos != this.$to.pos
        ? new cn(r.pos, i.pos, l)
        : null
  }
  findFittable() {
    let n = this.unplaced.openStart
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < n; r++) {
      let s = t.firstChild
      if ((t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r)) {
        n = r
        break
      }
      t = s.content
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? n : this.unplaced.openStart; r >= 0; r--) {
        let i,
          s = null
        r
          ? ((s = lh(this.unplaced.content, r - 1).firstChild), (i = s.content))
          : (i = this.unplaced.content)
        let o = i.firstChild
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a],
            u,
            f = null
          if (
            t == 1 &&
            (o
              ? c.matchType(o.type) || (f = c.fillBefore(St.from(o), !1))
              : s && l.compatibleContent(s.type))
          )
            return { sliceDepth: r, frontierDepth: a, parent: s, inject: f }
          if (t == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, wrap: u }
          if (s && c.matchType(s.type)) break
        }
      }
  }
  openMore() {
    let { content: n, openStart: t, openEnd: r } = this.unplaced,
      i = lh(n, t)
    return !i.childCount || i.firstChild.isLeaf
      ? !1
      : ((this.unplaced = new jt(n, t + 1, Math.max(r, i.size + t >= n.size - r ? t + 1 : 0))), !0)
  }
  dropNode() {
    let { content: n, openStart: t, openEnd: r } = this.unplaced,
      i = lh(n, t)
    if (i.childCount <= 1 && t > 0) {
      let s = n.size - t <= t + i.size
      this.unplaced = new jt(xa(n, t - 1, 1), t - 1, s ? t - 1 : r)
    } else this.unplaced = new jt(xa(n, t, 1), t, r)
  }
  placeNodes({ sliceDepth: n, frontierDepth: t, parent: r, inject: i, wrap: s }) {
    for (; this.depth > t; ) this.closeFrontierNode()
    if (s) for (let g = 0; g < s.length; g++) this.openFrontierNode(s[g])
    let o = this.unplaced,
      a = r ? r.content : o.content,
      l = o.openStart - n,
      c = 0,
      u = [],
      { match: f, type: d } = this.frontier[t]
    if (i) {
      for (let g = 0; g < i.childCount; g++) u.push(i.child(g))
      f = f.matchFragment(i)
    }
    let h = a.size + n - (o.content.size - o.openEnd)
    for (; c < a.childCount; ) {
      let g = a.child(c),
        m = f.matchType(g.type)
      if (!m) break
      ;(c++,
        (c > 1 || l == 0 || g.content.size) &&
          ((f = m),
          u.push($5(g.mark(d.allowedMarks(g.marks)), c == 1 ? l : 0, c == a.childCount ? h : -1))))
    }
    let p = c == a.childCount
    ;(p || (h = -1),
      (this.placed = Sa(this.placed, t, St.from(u))),
      (this.frontier[t].match = f),
      p &&
        h < 0 &&
        r &&
        r.type == this.frontier[this.depth].type &&
        this.frontier.length > 1 &&
        this.closeFrontierNode())
    for (let g = 0, m = a; g < h; g++) {
      let y = m.lastChild
      ;(this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }),
        (m = y.content))
    }
    this.unplaced = p
      ? n == 0
        ? jt.empty
        : new jt(xa(o.content, n - 1, 1), n - 1, h < 0 ? o.openEnd : n - 1)
      : new jt(xa(o.content, n, c), o.openStart, o.openEnd)
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock) return -1
    let n = this.frontier[this.depth],
      t
    if (
      !n.type.isTextblock ||
      !ch(this.$to, this.$to.depth, n.type, n.match, !1) ||
      (this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
    )
      return -1
    let { depth: r } = this.$to,
      i = this.$to.after(r)
    for (; r > 1 && i == this.$to.end(--r); ) ++i
    return i
  }
  findCloseLevel(n) {
    t: for (let t = Math.min(this.depth, n.depth); t >= 0; t--) {
      let { match: r, type: i } = this.frontier[t],
        s = t < n.depth && n.end(t + 1) == n.pos + (n.depth - (t + 1)),
        o = ch(n, t, i, r, s)
      if (o) {
        for (let a = t - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a],
            u = ch(n, a, c, l, !0)
          if (!u || u.childCount) continue t
        }
        return { depth: t, fit: o, move: s ? n.doc.resolve(n.after(t + 1)) : n }
      }
    }
  }
  close(n) {
    let t = this.findCloseLevel(n)
    if (!t) return null
    for (; this.depth > t.depth; ) this.closeFrontierNode()
    ;(t.fit.childCount && (this.placed = Sa(this.placed, t.depth, t.fit)), (n = t.move))
    for (let r = t.depth + 1; r <= n.depth; r++) {
      let i = n.node(r),
        s = i.type.contentMatch.fillBefore(i.content, !0, n.index(r))
      this.openFrontierNode(i.type, i.attrs, s)
    }
    return n
  }
  openFrontierNode(n, t = null, r) {
    let i = this.frontier[this.depth]
    ;((i.match = i.match.matchType(n)),
      (this.placed = Sa(this.placed, this.depth, St.from(n.create(t, r)))),
      this.frontier.push({ type: n, match: n.contentMatch }))
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(St.empty, !0)
    t.childCount && (this.placed = Sa(this.placed, this.frontier.length, t))
  }
}
function xa(e, n, t) {
  return n == 0
    ? e.cutByIndex(t, e.childCount)
    : e.replaceChild(0, e.firstChild.copy(xa(e.firstChild.content, n - 1, t)))
}
function Sa(e, n, t) {
  return n == 0
    ? e.append(t)
    : e.replaceChild(e.childCount - 1, e.lastChild.copy(Sa(e.lastChild.content, n - 1, t)))
}
function lh(e, n) {
  for (let t = 0; t < n; t++) e = e.firstChild.content
  return e
}
function $5(e, n, t) {
  if (n <= 0) return e
  let r = e.content
  return (
    n > 1 && (r = r.replaceChild(0, $5(r.firstChild, n - 1, r.childCount == 1 ? t - 1 : 0))),
    n > 0 &&
      ((r = e.type.contentMatch.fillBefore(r).append(r)),
      t <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(St.empty, !0)))),
    e.copy(r)
  )
}
function ch(e, n, t, r, i) {
  let s = e.node(n),
    o = i ? e.indexAfter(n) : e.index(n)
  if (o == s.childCount && !t.compatibleContent(s.type)) return null
  let a = r.fillBefore(s.content, !0, o)
  return a && !l$(t, s.content, o) ? a : null
}
function l$(e, n, t) {
  for (let r = t; r < n.childCount; r++) if (!e.allowsMarks(n.child(r).marks)) return !0
  return !1
}
function c$(e) {
  return e.spec.defining || e.spec.definingForContent
}
function u$(e, n, t, r) {
  if (!r.size) return e.deleteRange(n, t)
  let i = e.doc.resolve(n),
    s = e.doc.resolve(t)
  if (z5(i, s, r)) return e.step(new cn(n, t, r))
  let o = H5(i, e.doc.resolve(t))
  o[o.length - 1] == 0 && o.pop()
  let a = -(i.depth + 1)
  o.unshift(a)
  for (let d = i.depth, h = i.pos - 1; d > 0; d--, h--) {
    let p = i.node(d).type.spec
    if (p.defining || p.definingAsContext || p.isolating) break
    o.indexOf(d) > -1 ? (a = d) : i.before(d) == h && o.splice(1, 0, -d)
  }
  let l = o.indexOf(a),
    c = [],
    u = r.openStart
  for (let d = r.content, h = 0; ; h++) {
    let p = d.firstChild
    if ((c.push(p), h == r.openStart)) break
    d = p.content
  }
  for (let d = u - 1; d >= 0; d--) {
    let h = c[d],
      p = c$(h.type)
    if (p && !h.sameMarkup(i.node(Math.abs(a) - 1))) u = d
    else if (p || !h.type.isTextblock) break
  }
  for (let d = r.openStart; d >= 0; d--) {
    let h = (d + u + 1) % (r.openStart + 1),
      p = c[h]
    if (p)
      for (let g = 0; g < o.length; g++) {
        let m = o[(g + l) % o.length],
          y = !0
        m < 0 && ((y = !1), (m = -m))
        let b = i.node(m - 1),
          w = i.index(m - 1)
        if (b.canReplaceWith(w, w, p.type, p.marks))
          return e.replace(
            i.before(m),
            y ? s.after(m) : t,
            new jt(V5(r.content, 0, r.openStart, h), h, r.openEnd),
          )
      }
  }
  let f = e.steps.length
  for (let d = o.length - 1; d >= 0 && (e.replace(n, t, r), !(e.steps.length > f)); d--) {
    let h = o[d]
    h < 0 || ((n = i.before(h)), (t = s.after(h)))
  }
}
function V5(e, n, t, r, i) {
  if (n < t) {
    let s = e.firstChild
    e = e.replaceChild(0, s.copy(V5(s.content, n + 1, t, r, s)))
  }
  if (n > r) {
    let s = i.contentMatchAt(0),
      o = s.fillBefore(e).append(e)
    e = o.append(s.matchFragment(o).fillBefore(St.empty, !0))
  }
  return e
}
function f$(e, n, t, r) {
  if (!r.isInline && n == t && e.doc.resolve(n).parent.content.size) {
    let i = o$(e.doc, n, r.type)
    i != null && (n = t = i)
  }
  e.replaceRange(n, t, new jt(St.from(r), 0, 0))
}
function d$(e, n, t) {
  let r = e.doc.resolve(n),
    i = e.doc.resolve(t),
    s = H5(r, i)
  for (let o = 0; o < s.length; o++) {
    let a = s[o],
      l = o == s.length - 1
    if ((l && a == 0) || r.node(a).type.contentMatch.validEnd) return e.delete(r.start(a), i.end(a))
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return e.delete(r.before(a), i.after(a))
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (
      n - r.start(o) == r.depth - o &&
      t > r.end(o) &&
      i.end(o) - t != i.depth - o &&
      r.start(o - 1) == i.start(o - 1) &&
      r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1))
    )
      return e.delete(r.before(o), t)
  e.delete(n, t)
}
function H5(e, n) {
  let t = [],
    r = Math.min(e.depth, n.depth)
  for (let i = r; i >= 0; i--) {
    let s = e.start(i)
    if (
      s < e.pos - (e.depth - i) ||
      n.end(i) > n.pos + (n.depth - i) ||
      e.node(i).type.spec.isolating ||
      n.node(i).type.spec.isolating
    )
      break
    ;(s == n.start(i) ||
      (i == e.depth &&
        i == n.depth &&
        e.parent.inlineContent &&
        n.parent.inlineContent &&
        i &&
        n.start(i - 1) == s - 1)) &&
      t.push(i)
  }
  return t
}
class Co extends Tn {
  constructor(n, t, r) {
    ;(super(), (this.pos = n), (this.attr = t), (this.value = r))
  }
  apply(n) {
    let t = n.nodeAt(this.pos)
    if (!t) return Je.fail("No node at attribute step's position")
    let r = Object.create(null)
    for (let s in t.attrs) r[s] = t.attrs[s]
    r[this.attr] = this.value
    let i = t.type.create(r, null, t.marks)
    return Je.fromReplace(n, this.pos, this.pos + 1, new jt(St.from(i), 0, t.isLeaf ? 0 : 1))
  }
  getMap() {
    return Vn.empty
  }
  invert(n) {
    return new Co(this.pos, this.attr, n.nodeAt(this.pos).attrs[this.attr])
  }
  map(n) {
    let t = n.mapResult(this.pos, 1)
    return t.deletedAfter ? null : new Co(t.pos, this.attr, this.value)
  }
  toJSON() {
    return { stepType: 'attr', pos: this.pos, attr: this.attr, value: this.value }
  }
  static fromJSON(n, t) {
    if (typeof t.pos != 'number' || typeof t.attr != 'string')
      throw new RangeError('Invalid input for AttrStep.fromJSON')
    return new Co(t.pos, t.attr, t.value)
  }
}
Tn.jsonID('attr', Co)
class gl extends Tn {
  constructor(n, t) {
    ;(super(), (this.attr = n), (this.value = t))
  }
  apply(n) {
    let t = Object.create(null)
    for (let i in n.attrs) t[i] = n.attrs[i]
    t[this.attr] = this.value
    let r = n.type.create(t, n.content, n.marks)
    return Je.ok(r)
  }
  getMap() {
    return Vn.empty
  }
  invert(n) {
    return new gl(this.attr, n.attrs[this.attr])
  }
  map(n) {
    return this
  }
  toJSON() {
    return { stepType: 'docAttr', attr: this.attr, value: this.value }
  }
  static fromJSON(n, t) {
    if (typeof t.attr != 'string') throw new RangeError('Invalid input for DocAttrStep.fromJSON')
    return new gl(t.attr, t.value)
  }
}
Tn.jsonID('docAttr', gl)
let Bo = class extends Error {}
Bo = function e(n) {
  let t = Error.call(this, n)
  return ((t.__proto__ = e.prototype), t)
}
Bo.prototype = Object.create(Error.prototype)
Bo.prototype.constructor = Bo
Bo.prototype.name = 'TransformError'
class U5 {
  constructor(n) {
    ;((this.doc = n), (this.steps = []), (this.docs = []), (this.mapping = new ml()))
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc
  }
  step(n) {
    let t = this.maybeStep(n)
    if (t.failed) throw new Bo(t.failed)
    return this
  }
  maybeStep(n) {
    let t = n.apply(this.doc)
    return (t.failed || this.addStep(n, t.doc), t)
  }
  get docChanged() {
    return this.steps.length > 0
  }
  addStep(n, t) {
    ;(this.docs.push(this.doc),
      this.steps.push(n),
      this.mapping.appendMap(n.getMap()),
      (this.doc = t))
  }
  replace(n, t = n, r = jt.empty) {
    let i = Yf(this.doc, n, t, r)
    return (i && this.step(i), this)
  }
  replaceWith(n, t, r) {
    return this.replace(n, t, new jt(St.from(r), 0, 0))
  }
  delete(n, t) {
    return this.replace(n, t, jt.empty)
  }
  insert(n, t) {
    return this.replaceWith(n, n, t)
  }
  replaceRange(n, t, r) {
    return (u$(this, n, t, r), this)
  }
  replaceRangeWith(n, t, r) {
    return (f$(this, n, t, r), this)
  }
  deleteRange(n, t) {
    return (d$(this, n, t), this)
  }
  lift(n, t) {
    return (Yz(this, n, t), this)
  }
  join(n, t = 1) {
    return (s$(this, n, t), this)
  }
  wrap(n, t) {
    return (Qz(this, n, t), this)
  }
  setBlockType(n, t = n, r, i = null) {
    return (t$(this, n, t, r, i), this)
  }
  setNodeMarkup(n, t, r = null, i) {
    return (n$(this, n, t, r, i), this)
  }
  setNodeAttribute(n, t, r) {
    return (this.step(new Co(n, t, r)), this)
  }
  setDocAttribute(n, t) {
    return (this.step(new gl(n, t)), this)
  }
  addNodeMark(n, t) {
    return (this.step(new Oi(n, t)), this)
  }
  removeNodeMark(n, t) {
    let r = this.doc.nodeAt(n)
    if (!r) throw new RangeError('No node at position ' + n)
    if (t instanceof Oe) t.isInSet(r.marks) && this.step(new Fs(n, t))
    else {
      let i = r.marks,
        s,
        o = []
      for (; (s = t.isInSet(i)); ) (o.push(new Fs(n, s)), (i = s.removeFromSet(i)))
      for (let a = o.length - 1; a >= 0; a--) this.step(o[a])
    }
    return this
  }
  split(n, t = 1, r) {
    return (r$(this, n, t, r), this)
  }
  addMark(n, t, r) {
    return (Kz(this, n, t, r), this)
  }
  removeMark(n, t, r) {
    return (Gz(this, n, t, r), this)
  }
  clearIncompatible(n, t, r) {
    return (ag(this, n, t, r), this)
  }
}
const uh = Object.create(null)
class ye {
  constructor(n, t, r) {
    ;((this.$anchor = n), (this.$head = t), (this.ranges = r || [new h$(n.min(t), n.max(t))]))
  }
  get anchor() {
    return this.$anchor.pos
  }
  get head() {
    return this.$head.pos
  }
  get from() {
    return this.$from.pos
  }
  get to() {
    return this.$to.pos
  }
  get $from() {
    return this.ranges[0].$from
  }
  get $to() {
    return this.ranges[0].$to
  }
  get empty() {
    let n = this.ranges
    for (let t = 0; t < n.length; t++) if (n[t].$from.pos != n[t].$to.pos) return !1
    return !0
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, !0)
  }
  replace(n, t = jt.empty) {
    let r = t.content.lastChild,
      i = null
    for (let a = 0; a < t.openEnd; a++) ((i = r), (r = r.lastChild))
    let s = n.steps.length,
      o = this.ranges
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: c } = o[a],
        u = n.mapping.slice(s)
      ;(n.replaceRange(u.map(l.pos), u.map(c.pos), a ? jt.empty : t),
        a == 0 && Mv(n, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1))
    }
  }
  replaceWith(n, t) {
    let r = n.steps.length,
      i = this.ranges
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: a } = i[s],
        l = n.mapping.slice(r),
        c = l.map(o.pos),
        u = l.map(a.pos)
      s ? n.deleteRange(c, u) : (n.replaceRangeWith(c, u, t), Mv(n, r, t.isInline ? -1 : 1))
    }
  }
  static findFrom(n, t, r = !1) {
    let i = n.parent.inlineContent ? new oe(n) : ro(n.node(0), n.parent, n.pos, n.index(), t, r)
    if (i) return i
    for (let s = n.depth - 1; s >= 0; s--) {
      let o =
        t < 0
          ? ro(n.node(0), n.node(s), n.before(s + 1), n.index(s), t, r)
          : ro(n.node(0), n.node(s), n.after(s + 1), n.index(s) + 1, t, r)
      if (o) return o
    }
    return null
  }
  static near(n, t = 1) {
    return this.findFrom(n, t) || this.findFrom(n, -t) || new qn(n.node(0))
  }
  static atStart(n) {
    return ro(n, n, 0, 0, 1) || new qn(n)
  }
  static atEnd(n) {
    return ro(n, n, n.content.size, n.childCount, -1) || new qn(n)
  }
  static fromJSON(n, t) {
    if (!t || !t.type) throw new RangeError('Invalid input for Selection.fromJSON')
    let r = uh[t.type]
    if (!r) throw new RangeError(`No selection type ${t.type} defined`)
    return r.fromJSON(n, t)
  }
  static jsonID(n, t) {
    if (n in uh) throw new RangeError('Duplicate use of selection JSON ID ' + n)
    return ((uh[n] = t), (t.prototype.jsonID = n), t)
  }
  getBookmark() {
    return oe.between(this.$anchor, this.$head).getBookmark()
  }
}
ye.prototype.visible = !0
class h$ {
  constructor(n, t) {
    ;((this.$from = n), (this.$to = t))
  }
}
let kv = !1
function Cv(e) {
  !kv &&
    !e.parent.inlineContent &&
    ((kv = !0),
    console.warn(
      'TextSelection endpoint not pointing into a node with inline content (' +
        e.parent.type.name +
        ')',
    ))
}
class oe extends ye {
  constructor(n, t = n) {
    ;(Cv(n), Cv(t), super(n, t))
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null
  }
  map(n, t) {
    let r = n.resolve(t.map(this.head))
    if (!r.parent.inlineContent) return ye.near(r)
    let i = n.resolve(t.map(this.anchor))
    return new oe(i.parent.inlineContent ? i : r, r)
  }
  replace(n, t = jt.empty) {
    if ((super.replace(n, t), t == jt.empty)) {
      let r = this.$from.marksAcross(this.$to)
      r && n.ensureMarks(r)
    }
  }
  eq(n) {
    return n instanceof oe && n.anchor == this.anchor && n.head == this.head
  }
  getBookmark() {
    return new Zf(this.anchor, this.head)
  }
  toJSON() {
    return { type: 'text', anchor: this.anchor, head: this.head }
  }
  static fromJSON(n, t) {
    if (typeof t.anchor != 'number' || typeof t.head != 'number')
      throw new RangeError('Invalid input for TextSelection.fromJSON')
    return new oe(n.resolve(t.anchor), n.resolve(t.head))
  }
  static create(n, t, r = t) {
    let i = n.resolve(t)
    return new this(i, r == t ? i : n.resolve(r))
  }
  static between(n, t, r) {
    let i = n.pos - t.pos
    if (((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent)) {
      let s = ye.findFrom(t, r, !0) || ye.findFrom(t, -r, !0)
      if (s) t = s.$head
      else return ye.near(t, r)
    }
    return (
      n.parent.inlineContent ||
        (i == 0
          ? (n = t)
          : ((n = (ye.findFrom(n, -r, !0) || ye.findFrom(n, r, !0)).$anchor),
            n.pos < t.pos != i < 0 && (n = t))),
      new oe(n, t)
    )
  }
}
ye.jsonID('text', oe)
class Zf {
  constructor(n, t) {
    ;((this.anchor = n), (this.head = t))
  }
  map(n) {
    return new Zf(n.map(this.anchor), n.map(this.head))
  }
  resolve(n) {
    return oe.between(n.resolve(this.anchor), n.resolve(this.head))
  }
}
class Zt extends ye {
  constructor(n) {
    let t = n.nodeAfter,
      r = n.node(0).resolve(n.pos + t.nodeSize)
    ;(super(n, r), (this.node = t))
  }
  map(n, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor),
      s = n.resolve(i)
    return r ? ye.near(s) : new Zt(s)
  }
  content() {
    return new jt(St.from(this.node), 0, 0)
  }
  eq(n) {
    return n instanceof Zt && n.anchor == this.anchor
  }
  toJSON() {
    return { type: 'node', anchor: this.anchor }
  }
  getBookmark() {
    return new cg(this.anchor)
  }
  static fromJSON(n, t) {
    if (typeof t.anchor != 'number')
      throw new RangeError('Invalid input for NodeSelection.fromJSON')
    return new Zt(n.resolve(t.anchor))
  }
  static create(n, t) {
    return new Zt(n.resolve(t))
  }
  static isSelectable(n) {
    return !n.isText && n.type.spec.selectable !== !1
  }
}
Zt.prototype.visible = !1
ye.jsonID('node', Zt)
class cg {
  constructor(n) {
    this.anchor = n
  }
  map(n) {
    let { deleted: t, pos: r } = n.mapResult(this.anchor)
    return t ? new Zf(r, r) : new cg(r)
  }
  resolve(n) {
    let t = n.resolve(this.anchor),
      r = t.nodeAfter
    return r && Zt.isSelectable(r) ? new Zt(t) : ye.near(t)
  }
}
class qn extends ye {
  constructor(n) {
    super(n.resolve(0), n.resolve(n.content.size))
  }
  replace(n, t = jt.empty) {
    if (t == jt.empty) {
      n.delete(0, n.doc.content.size)
      let r = ye.atStart(n.doc)
      r.eq(n.selection) || n.setSelection(r)
    } else super.replace(n, t)
  }
  toJSON() {
    return { type: 'all' }
  }
  static fromJSON(n) {
    return new qn(n)
  }
  map(n) {
    return new qn(n)
  }
  eq(n) {
    return n instanceof qn
  }
  getBookmark() {
    return p$
  }
}
ye.jsonID('all', qn)
const p$ = {
  map() {
    return this
  },
  resolve(e) {
    return new qn(e)
  },
}
function ro(e, n, t, r, i, s = !1) {
  if (n.inlineContent) return oe.create(e, t)
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < n.childCount : o >= 0; o += i) {
    let a = n.child(o)
    if (a.isAtom) {
      if (!s && Zt.isSelectable(a)) return Zt.create(e, t - (i < 0 ? a.nodeSize : 0))
    } else {
      let l = ro(e, a, t + i, i < 0 ? a.childCount : 0, i, s)
      if (l) return l
    }
    t += a.nodeSize * i
  }
  return null
}
function Mv(e, n, t) {
  let r = e.steps.length - 1
  if (r < n) return
  let i = e.steps[r]
  if (!(i instanceof cn || i instanceof un)) return
  let s = e.mapping.maps[r],
    o
  ;(s.forEach((a, l, c, u) => {
    o == null && (o = u)
  }),
    e.setSelection(ye.near(e.doc.resolve(o), t)))
}
const Ev = 1,
  Sc = 2,
  Tv = 4
class m$ extends U5 {
  constructor(n) {
    ;(super(n.doc),
      (this.curSelectionFor = 0),
      (this.updated = 0),
      (this.meta = Object.create(null)),
      (this.time = Date.now()),
      (this.curSelection = n.selection),
      (this.storedMarks = n.storedMarks))
  }
  get selection() {
    return (
      this.curSelectionFor < this.steps.length &&
        ((this.curSelection = this.curSelection.map(
          this.doc,
          this.mapping.slice(this.curSelectionFor),
        )),
        (this.curSelectionFor = this.steps.length)),
      this.curSelection
    )
  }
  setSelection(n) {
    if (n.$from.doc != this.doc)
      throw new RangeError('Selection passed to setSelection must point at the current document')
    return (
      (this.curSelection = n),
      (this.curSelectionFor = this.steps.length),
      (this.updated = (this.updated | Ev) & ~Sc),
      (this.storedMarks = null),
      this
    )
  }
  get selectionSet() {
    return (this.updated & Ev) > 0
  }
  setStoredMarks(n) {
    return ((this.storedMarks = n), (this.updated |= Sc), this)
  }
  ensureMarks(n) {
    return (
      Oe.sameSet(this.storedMarks || this.selection.$from.marks(), n) || this.setStoredMarks(n),
      this
    )
  }
  addStoredMark(n) {
    return this.ensureMarks(n.addToSet(this.storedMarks || this.selection.$head.marks()))
  }
  removeStoredMark(n) {
    return this.ensureMarks(n.removeFromSet(this.storedMarks || this.selection.$head.marks()))
  }
  get storedMarksSet() {
    return (this.updated & Sc) > 0
  }
  addStep(n, t) {
    ;(super.addStep(n, t), (this.updated = this.updated & ~Sc), (this.storedMarks = null))
  }
  setTime(n) {
    return ((this.time = n), this)
  }
  replaceSelection(n) {
    return (this.selection.replace(this, n), this)
  }
  replaceSelectionWith(n, t = !0) {
    let r = this.selection
    return (
      t &&
        (n = n.mark(
          this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Oe.none),
        )),
      r.replaceWith(this, n),
      this
    )
  }
  deleteSelection() {
    return (this.selection.replace(this), this)
  }
  insertText(n, t, r) {
    let i = this.doc.type.schema
    if (t == null) return n ? this.replaceSelectionWith(i.text(n), !0) : this.deleteSelection()
    {
      if ((r == null && (r = t), (r = r ?? t), !n)) return this.deleteRange(t, r)
      let s = this.storedMarks
      if (!s) {
        let o = this.doc.resolve(t)
        s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r))
      }
      return (
        this.replaceRangeWith(t, r, i.text(n, s)),
        this.selection.empty || this.setSelection(ye.near(this.selection.$to)),
        this
      )
    }
  }
  setMeta(n, t) {
    return ((this.meta[typeof n == 'string' ? n : n.key] = t), this)
  }
  getMeta(n) {
    return this.meta[typeof n == 'string' ? n : n.key]
  }
  get isGeneric() {
    for (let n in this.meta) return !1
    return !0
  }
  scrollIntoView() {
    return ((this.updated |= Tv), this)
  }
  get scrolledIntoView() {
    return (this.updated & Tv) > 0
  }
}
function Av(e, n) {
  return !n || !e ? e : e.bind(n)
}
class _a {
  constructor(n, t, r) {
    ;((this.name = n), (this.init = Av(t.init, r)), (this.apply = Av(t.apply, r)))
  }
}
const g$ = [
  new _a('doc', {
    init(e) {
      return e.doc || e.schema.topNodeType.createAndFill()
    },
    apply(e) {
      return e.doc
    },
  }),
  new _a('selection', {
    init(e, n) {
      return e.selection || ye.atStart(n.doc)
    },
    apply(e) {
      return e.selection
    },
  }),
  new _a('storedMarks', {
    init(e) {
      return e.storedMarks || null
    },
    apply(e, n, t, r) {
      return r.selection.$cursor ? e.storedMarks : null
    },
  }),
  new _a('scrollToSelection', {
    init() {
      return 0
    },
    apply(e, n) {
      return e.scrolledIntoView ? n + 1 : n
    },
  }),
]
class fh {
  constructor(n, t) {
    ;((this.schema = n),
      (this.plugins = []),
      (this.pluginsByKey = Object.create(null)),
      (this.fields = g$.slice()),
      t &&
        t.forEach((r) => {
          if (this.pluginsByKey[r.key])
            throw new RangeError('Adding different instances of a keyed plugin (' + r.key + ')')
          ;(this.plugins.push(r),
            (this.pluginsByKey[r.key] = r),
            r.spec.state && this.fields.push(new _a(r.key, r.spec.state, r)))
        }))
  }
}
class po {
  constructor(n) {
    this.config = n
  }
  get schema() {
    return this.config.schema
  }
  get plugins() {
    return this.config.plugins
  }
  apply(n) {
    return this.applyTransaction(n).state
  }
  filterTransaction(n, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r]
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, n, this)) return !1
      }
    return !0
  }
  applyTransaction(n) {
    if (!this.filterTransaction(n)) return { state: this, transactions: [] }
    let t = [n],
      r = this.applyInner(n),
      i = null
    for (;;) {
      let s = !1
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o]
        if (a.spec.appendTransaction) {
          let l = i ? i[o].n : 0,
            c = i ? i[o].state : this,
            u = l < t.length && a.spec.appendTransaction.call(a, l ? t.slice(l) : t, c, r)
          if (u && r.filterTransaction(u, o)) {
            if ((u.setMeta('appendedTransaction', n), !i)) {
              i = []
              for (let f = 0; f < this.config.plugins.length; f++)
                i.push(f < o ? { state: r, n: t.length } : { state: this, n: 0 })
            }
            ;(t.push(u), (r = r.applyInner(u)), (s = !0))
          }
          i && (i[o] = { state: r, n: t.length })
        }
      }
      if (!s) return { state: r, transactions: t }
    }
  }
  applyInner(n) {
    if (!n.before.eq(this.doc)) throw new RangeError('Applying a mismatched transaction')
    let t = new po(this.config),
      r = this.config.fields
    for (let i = 0; i < r.length; i++) {
      let s = r[i]
      t[s.name] = s.apply(n, this[s.name], this, t)
    }
    return t
  }
  get tr() {
    return new m$(this)
  }
  static create(n) {
    let t = new fh(n.doc ? n.doc.type.schema : n.schema, n.plugins),
      r = new po(t)
    for (let i = 0; i < t.fields.length; i++) r[t.fields[i].name] = t.fields[i].init(n, r)
    return r
  }
  reconfigure(n) {
    let t = new fh(this.schema, n.plugins),
      r = t.fields,
      i = new po(t)
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(n, i)
    }
    return i
  }
  toJSON(n) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }
    if (
      (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())),
      n && typeof n == 'object')
    )
      for (let r in n) {
        if (r == 'doc' || r == 'selection')
          throw new RangeError('The JSON fields `doc` and `selection` are reserved')
        let i = n[r],
          s = i.spec.state
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]))
      }
    return t
  }
  static fromJSON(n, t, r) {
    if (!t) throw new RangeError('Invalid input for EditorState.fromJSON')
    if (!n.schema) throw new RangeError("Required config field 'schema' missing")
    let i = new fh(n.schema, n.plugins),
      s = new po(i)
    return (
      i.fields.forEach((o) => {
        if (o.name == 'doc') s.doc = Li.fromJSON(n.schema, t.doc)
        else if (o.name == 'selection') s.selection = ye.fromJSON(s.doc, t.selection)
        else if (o.name == 'storedMarks')
          t.storedMarks && (s.storedMarks = t.storedMarks.map(n.schema.markFromJSON))
        else {
          if (r)
            for (let a in r) {
              let l = r[a],
                c = l.spec.state
              if (
                l.key == o.name &&
                c &&
                c.fromJSON &&
                Object.prototype.hasOwnProperty.call(t, a)
              ) {
                s[o.name] = c.fromJSON.call(l, n, t[a], s)
                return
              }
            }
          s[o.name] = o.init(n, s)
        }
      }),
      s
    )
  }
}
function q5(e, n, t) {
  for (let r in e) {
    let i = e[r]
    ;(i instanceof Function ? (i = i.bind(n)) : r == 'handleDOMEvents' && (i = q5(i, n, {})),
      (t[r] = i))
  }
  return t
}
class Ke {
  constructor(n) {
    ;((this.spec = n),
      (this.props = {}),
      n.props && q5(n.props, this, this.props),
      (this.key = n.key ? n.key.key : W5('plugin')))
  }
  getState(n) {
    return n[this.key]
  }
}
const dh = Object.create(null)
function W5(e) {
  return e in dh ? e + '$' + ++dh[e] : ((dh[e] = 0), e + '$')
}
class hn {
  constructor(n = 'key') {
    this.key = W5(n)
  }
  get(n) {
    return n.config.pluginsByKey[this.key]
  }
  getState(n) {
    return n[this.key]
  }
}
const ug = (e, n) =>
  e.selection.empty ? !1 : (n && n(e.tr.deleteSelection().scrollIntoView()), !0)
function K5(e, n) {
  let { $cursor: t } = e.selection
  return !t || (n ? !n.endOfTextblock('backward', e) : t.parentOffset > 0) ? null : t
}
const G5 = (e, n, t) => {
    let r = K5(e, t)
    if (!r) return !1
    let i = fg(r)
    if (!i) {
      let o = r.blockRange(),
        a = o && ra(o)
      return a == null ? !1 : (n && n(e.tr.lift(o, a).scrollIntoView()), !0)
    }
    let s = i.nodeBefore
    if (rS(e, i, n, -1)) return !0
    if (r.parent.content.size == 0 && (zo(s, 'end') || Zt.isSelectable(s)))
      for (let o = r.depth; ; o--) {
        let a = Yf(e.doc, r.before(o), r.after(o), jt.empty)
        if (a && a.slice.size < a.to - a.from) {
          if (n) {
            let l = e.tr.step(a)
            ;(l.setSelection(
              zo(s, 'end')
                ? ye.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1)
                : Zt.create(l.doc, i.pos - s.nodeSize),
            ),
              n(l.scrollIntoView()))
          }
          return !0
        }
        if (o == 1 || r.node(o - 1).childCount > 1) break
      }
    return s.isAtom && i.depth == r.depth - 1
      ? (n && n(e.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0)
      : !1
  },
  y$ = (e, n, t) => {
    let r = K5(e, t)
    if (!r) return !1
    let i = fg(r)
    return i ? X5(e, i, n) : !1
  },
  b$ = (e, n, t) => {
    let r = Z5(e, t)
    if (!r) return !1
    let i = dg(r)
    return i ? X5(e, i, n) : !1
  }
function X5(e, n, t) {
  let r = n.nodeBefore,
    i = r,
    s = n.pos - 1
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating) return !1
    let u = i.lastChild
    if (!u) return !1
    i = u
  }
  let o = n.nodeAfter,
    a = o,
    l = n.pos + 1
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating) return !1
    let u = a.firstChild
    if (!u) return !1
    a = u
  }
  let c = Yf(e.doc, s, l, jt.empty)
  if (!c || c.from != s || (c instanceof cn && c.slice.size >= l - s)) return !1
  if (t) {
    let u = e.tr.step(c)
    ;(u.setSelection(oe.create(u.doc, s)), t(u.scrollIntoView()))
  }
  return !0
}
function zo(e, n, t = !1) {
  for (let r = e; r; r = n == 'start' ? r.firstChild : r.lastChild) {
    if (r.isTextblock) return !0
    if (t && r.childCount != 1) return !1
  }
  return !1
}
const Y5 = (e, n, t) => {
  let { $head: r, empty: i } = e.selection,
    s = r
  if (!i) return !1
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock('backward', e) : r.parentOffset > 0) return !1
    s = fg(r)
  }
  let o = s && s.nodeBefore
  return !o || !Zt.isSelectable(o)
    ? !1
    : (n && n(e.tr.setSelection(Zt.create(e.doc, s.pos - o.nodeSize)).scrollIntoView()), !0)
}
function fg(e) {
  if (!e.parent.type.spec.isolating)
    for (let n = e.depth - 1; n >= 0; n--) {
      if (e.index(n) > 0) return e.doc.resolve(e.before(n + 1))
      if (e.node(n).type.spec.isolating) break
    }
  return null
}
function Z5(e, n) {
  let { $cursor: t } = e.selection
  return !t || (n ? !n.endOfTextblock('forward', e) : t.parentOffset < t.parent.content.size)
    ? null
    : t
}
const J5 = (e, n, t) => {
    let r = Z5(e, t)
    if (!r) return !1
    let i = dg(r)
    if (!i) return !1
    let s = i.nodeAfter
    if (rS(e, i, n, 1)) return !0
    if (r.parent.content.size == 0 && (zo(s, 'start') || Zt.isSelectable(s))) {
      let o = Yf(e.doc, r.before(), r.after(), jt.empty)
      if (o && o.slice.size < o.to - o.from) {
        if (n) {
          let a = e.tr.step(o)
          ;(a.setSelection(
            zo(s, 'start')
              ? ye.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1)
              : Zt.create(a.doc, a.mapping.map(i.pos)),
          ),
            n(a.scrollIntoView()))
        }
        return !0
      }
    }
    return s.isAtom && i.depth == r.depth - 1
      ? (n && n(e.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0)
      : !1
  },
  Q5 = (e, n, t) => {
    let { $head: r, empty: i } = e.selection,
      s = r
    if (!i) return !1
    if (r.parent.isTextblock) {
      if (t ? !t.endOfTextblock('forward', e) : r.parentOffset < r.parent.content.size) return !1
      s = dg(r)
    }
    let o = s && s.nodeAfter
    return !o || !Zt.isSelectable(o)
      ? !1
      : (n && n(e.tr.setSelection(Zt.create(e.doc, s.pos)).scrollIntoView()), !0)
  }
function dg(e) {
  if (!e.parent.type.spec.isolating)
    for (let n = e.depth - 1; n >= 0; n--) {
      let t = e.node(n)
      if (e.index(n) + 1 < t.childCount) return e.doc.resolve(e.after(n + 1))
      if (t.type.spec.isolating) break
    }
  return null
}
const v$ = (e, n) => {
    let t = e.selection,
      r = t instanceof Zt,
      i
    if (r) {
      if (t.node.isTextblock || !Yi(e.doc, t.from)) return !1
      i = t.from
    } else if (((i = Xf(e.doc, t.from, -1)), i == null)) return !1
    if (n) {
      let s = e.tr.join(i)
      ;(r && s.setSelection(Zt.create(s.doc, i - e.doc.resolve(i).nodeBefore.nodeSize)),
        n(s.scrollIntoView()))
    }
    return !0
  },
  w$ = (e, n) => {
    let t = e.selection,
      r
    if (t instanceof Zt) {
      if (t.node.isTextblock || !Yi(e.doc, t.to)) return !1
      r = t.to
    } else if (((r = Xf(e.doc, t.to, 1)), r == null)) return !1
    return (n && n(e.tr.join(r).scrollIntoView()), !0)
  },
  x$ = (e, n) => {
    let { $from: t, $to: r } = e.selection,
      i = t.blockRange(r),
      s = i && ra(i)
    return s == null ? !1 : (n && n(e.tr.lift(i, s).scrollIntoView()), !0)
  },
  tS = (e, n) => {
    let { $head: t, $anchor: r } = e.selection
    return !t.parent.type.spec.code || !t.sameParent(r)
      ? !1
      : (n &&
          n(
            e.tr
              .insertText(
                `
`,
              )
              .scrollIntoView(),
          ),
        !0)
  }
function hg(e) {
  for (let n = 0; n < e.edgeCount; n++) {
    let { type: t } = e.edge(n)
    if (t.isTextblock && !t.hasRequiredAttrs()) return t
  }
  return null
}
const S$ = (e, n) => {
    let { $head: t, $anchor: r } = e.selection
    if (!t.parent.type.spec.code || !t.sameParent(r)) return !1
    let i = t.node(-1),
      s = t.indexAfter(-1),
      o = hg(i.contentMatchAt(s))
    if (!o || !i.canReplaceWith(s, s, o)) return !1
    if (n) {
      let a = t.after(),
        l = e.tr.replaceWith(a, a, o.createAndFill())
      ;(l.setSelection(ye.near(l.doc.resolve(a), 1)), n(l.scrollIntoView()))
    }
    return !0
  },
  eS = (e, n) => {
    let t = e.selection,
      { $from: r, $to: i } = t
    if (t instanceof qn || r.parent.inlineContent || i.parent.inlineContent) return !1
    let s = hg(i.parent.contentMatchAt(i.indexAfter()))
    if (!s || !s.isTextblock) return !1
    if (n) {
      let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos,
        a = e.tr.insert(o, s.createAndFill())
      ;(a.setSelection(oe.create(a.doc, o + 1)), n(a.scrollIntoView()))
    }
    return !0
  },
  nS = (e, n) => {
    let { $cursor: t } = e.selection
    if (!t || t.parent.content.size) return !1
    if (t.depth > 1 && t.after() != t.end(-1)) {
      let s = t.before()
      if (Qr(e.doc, s)) return (n && n(e.tr.split(s).scrollIntoView()), !0)
    }
    let r = t.blockRange(),
      i = r && ra(r)
    return i == null ? !1 : (n && n(e.tr.lift(r, i).scrollIntoView()), !0)
  }
function _$(e) {
  return (n, t) => {
    let { $from: r, $to: i } = n.selection
    if (n.selection instanceof Zt && n.selection.node.isBlock)
      return !r.parentOffset || !Qr(n.doc, r.pos)
        ? !1
        : (t && t(n.tr.split(r.pos).scrollIntoView()), !0)
    if (!r.depth) return !1
    let s = [],
      o,
      a,
      l = !1,
      c = !1
    for (let h = r.depth; ; h--)
      if (r.node(h).isBlock) {
        ;((l = r.end(h) == r.pos + (r.depth - h)),
          (c = r.start(h) == r.pos - (r.depth - h)),
          (a = hg(r.node(h - 1).contentMatchAt(r.indexAfter(h - 1)))),
          s.unshift(l && a ? { type: a } : null),
          (o = h))
        break
      } else {
        if (h == 1) return !1
        s.unshift(null)
      }
    let u = n.tr
    ;(n.selection instanceof oe || n.selection instanceof qn) && u.deleteSelection()
    let f = u.mapping.map(r.pos),
      d = Qr(u.doc, f, s.length, s)
    if ((d || ((s[0] = a ? { type: a } : null), (d = Qr(u.doc, f, s.length, s))), !d)) return !1
    if ((u.split(f, s.length, s), !l && c && r.node(o).type != a)) {
      let h = u.mapping.map(r.before(o)),
        p = u.doc.resolve(h)
      a &&
        r.node(o - 1).canReplaceWith(p.index(), p.index() + 1, a) &&
        u.setNodeMarkup(u.mapping.map(r.before(o)), a)
    }
    return (t && t(u.scrollIntoView()), !0)
  }
}
const k$ = _$(),
  C$ = (e, n) => {
    let { $from: t, to: r } = e.selection,
      i,
      s = t.sharedDepth(r)
    return s == 0 ? !1 : ((i = t.before(s)), n && n(e.tr.setSelection(Zt.create(e.doc, i))), !0)
  }
function M$(e, n, t) {
  let r = n.nodeBefore,
    i = n.nodeAfter,
    s = n.index()
  return !r || !i || !r.type.compatibleContent(i.type)
    ? !1
    : !r.content.size && n.parent.canReplace(s - 1, s)
      ? (t && t(e.tr.delete(n.pos - r.nodeSize, n.pos).scrollIntoView()), !0)
      : !n.parent.canReplace(s, s + 1) || !(i.isTextblock || Yi(e.doc, n.pos))
        ? !1
        : (t && t(e.tr.join(n.pos).scrollIntoView()), !0)
}
function rS(e, n, t, r) {
  let i = n.nodeBefore,
    s = n.nodeAfter,
    o,
    a,
    l = i.type.spec.isolating || s.type.spec.isolating
  if (!l && M$(e, n, t)) return !0
  let c = !l && n.parent.canReplace(n.index(), n.index() + 1)
  if (
    c &&
    (o = (a = i.contentMatchAt(i.childCount)).findWrapping(s.type)) &&
    a.matchType(o[0] || s.type).validEnd
  ) {
    if (t) {
      let h = n.pos + s.nodeSize,
        p = St.empty
      for (let y = o.length - 1; y >= 0; y--) p = St.from(o[y].create(null, p))
      p = St.from(i.copy(p))
      let g = e.tr.step(new un(n.pos - 1, h, n.pos, h, new jt(p, 1, 0), o.length, !0)),
        m = g.doc.resolve(h + 2 * o.length)
      ;(m.nodeAfter && m.nodeAfter.type == i.type && Yi(g.doc, m.pos) && g.join(m.pos),
        t(g.scrollIntoView()))
    }
    return !0
  }
  let u = s.type.spec.isolating || (r > 0 && l) ? null : ye.findFrom(n, 1),
    f = u && u.$from.blockRange(u.$to),
    d = f && ra(f)
  if (d != null && d >= n.depth) return (t && t(e.tr.lift(f, d).scrollIntoView()), !0)
  if (c && zo(s, 'start', !0) && zo(i, 'end')) {
    let h = i,
      p = []
    for (; p.push(h), !h.isTextblock; ) h = h.lastChild
    let g = s,
      m = 1
    for (; !g.isTextblock; g = g.firstChild) m++
    if (h.canReplace(h.childCount, h.childCount, g.content)) {
      if (t) {
        let y = St.empty
        for (let w = p.length - 1; w >= 0; w--) y = St.from(p[w].copy(y))
        let b = e.tr.step(
          new un(
            n.pos - p.length,
            n.pos + s.nodeSize,
            n.pos + m,
            n.pos + s.nodeSize - m,
            new jt(y, p.length, 0),
            0,
            !0,
          ),
        )
        t(b.scrollIntoView())
      }
      return !0
    }
  }
  return !1
}
function iS(e) {
  return function (n, t) {
    let r = n.selection,
      i = e < 0 ? r.$from : r.$to,
      s = i.depth
    for (; i.node(s).isInline; ) {
      if (!s) return !1
      s--
    }
    return i.node(s).isTextblock
      ? (t && t(n.tr.setSelection(oe.create(n.doc, e < 0 ? i.start(s) : i.end(s)))), !0)
      : !1
  }
}
const E$ = iS(-1),
  T$ = iS(1)
function A$(e, n = null) {
  return function (t, r) {
    let { $from: i, $to: s } = t.selection,
      o = i.blockRange(s),
      a = o && lg(o, e, n)
    return a ? (r && r(t.tr.wrap(o, a).scrollIntoView()), !0) : !1
  }
}
function Rv(e, n = null) {
  return function (t, r) {
    let i = !1
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let {
        $from: { pos: o },
        $to: { pos: a },
      } = t.selection.ranges[s]
      t.doc.nodesBetween(o, a, (l, c) => {
        if (i) return !1
        if (!(!l.isTextblock || l.hasMarkup(e, n)))
          if (l.type == e) i = !0
          else {
            let u = t.doc.resolve(c),
              f = u.index()
            i = u.parent.canReplaceWith(f, f + 1, e)
          }
      })
    }
    if (!i) return !1
    if (r) {
      let s = t.tr
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let {
          $from: { pos: a },
          $to: { pos: l },
        } = t.selection.ranges[o]
        s.setBlockType(a, l, e, n)
      }
      r(s.scrollIntoView())
    }
    return !0
  }
}
function pg(...e) {
  return function (n, t, r) {
    for (let i = 0; i < e.length; i++) if (e[i](n, t, r)) return !0
    return !1
  }
}
pg(ug, G5, Y5)
pg(ug, J5, Q5)
pg(tS, eS, nS, k$)
typeof navigator < 'u'
  ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
  : typeof os < 'u' && os.platform && os.platform() == 'darwin'
function R$(e, n = null) {
  return function (t, r) {
    let { $from: i, $to: s } = t.selection,
      o = i.blockRange(s)
    if (!o) return !1
    let a = r ? t.tr : null
    return O$(a, o, e, n) ? (r && r(a.scrollIntoView()), !0) : !1
  }
}
function O$(e, n, t, r = null) {
  let i = !1,
    s = n,
    o = n.$from.doc
  if (n.depth >= 2 && n.$from.node(n.depth - 1).type.compatibleContent(t) && n.startIndex == 0) {
    if (n.$from.index(n.depth - 1) == 0) return !1
    let l = o.resolve(n.start - 2)
    ;((s = new Pu(l, l, n.depth)),
      n.endIndex < n.parent.childCount &&
        (n = new Pu(n.$from, o.resolve(n.$to.end(n.depth)), n.depth)),
      (i = !0))
  }
  let a = lg(s, t, r, n)
  return a ? (e && P$(e, n, a, i, t), !0) : !1
}
function P$(e, n, t, r, i) {
  let s = St.empty
  for (let u = t.length - 1; u >= 0; u--) s = St.from(t[u].type.create(t[u].attrs, s))
  e.step(new un(n.start - (r ? 2 : 0), n.end, n.start, n.end, new jt(s, 0, 0), t.length, !0))
  let o = 0
  for (let u = 0; u < t.length; u++) t[u].type == i && (o = u + 1)
  let a = t.length - o,
    l = n.start + t.length - (r ? 2 : 0),
    c = n.parent
  for (let u = n.startIndex, f = n.endIndex, d = !0; u < f; u++, d = !1)
    (!d && Qr(e.doc, l, a) && (e.split(l, a), (l += 2 * a)), (l += c.child(u).nodeSize))
  return e
}
function N$(e) {
  return function (n, t) {
    let { $from: r, $to: i } = n.selection,
      s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == e)
    return s ? (t ? (r.node(s.depth - 1).type == e ? I$(n, t, e, s) : D$(n, t, s)) : !0) : !1
  }
}
function I$(e, n, t, r) {
  let i = e.tr,
    s = r.end,
    o = r.$to.end(r.depth)
  s < o &&
    (i.step(new un(s - 1, o, s, o, new jt(St.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)),
    (r = new Pu(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth)))
  const a = ra(r)
  if (a == null) return !1
  i.lift(r, a)
  let l = i.doc.resolve(i.mapping.map(s, -1) - 1)
  return (
    Yi(i.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && i.join(l.pos),
    n(i.scrollIntoView()),
    !0
  )
}
function D$(e, n, t) {
  let r = e.tr,
    i = t.parent
  for (let h = t.end, p = t.endIndex - 1, g = t.startIndex; p > g; p--)
    ((h -= i.child(p).nodeSize), r.delete(h - 1, h + 1))
  let s = r.doc.resolve(t.start),
    o = s.nodeAfter
  if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize) return !1
  let a = t.startIndex == 0,
    l = t.endIndex == i.childCount,
    c = s.node(-1),
    u = s.index(-1)
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, o.content.append(l ? St.empty : St.from(i)))) return !1
  let f = s.pos,
    d = f + o.nodeSize
  return (
    r.step(
      new un(
        f - (a ? 1 : 0),
        d + (l ? 1 : 0),
        f + 1,
        d - 1,
        new jt(
          (a ? St.empty : St.from(i.copy(St.empty))).append(
            l ? St.empty : St.from(i.copy(St.empty)),
          ),
          a ? 0 : 1,
          l ? 0 : 1,
        ),
        a ? 0 : 1,
      ),
    ),
    n(r.scrollIntoView()),
    !0
  )
}
function j$(e) {
  return function (n, t) {
    let { $from: r, $to: i } = n.selection,
      s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == e)
    if (!s) return !1
    let o = s.startIndex
    if (o == 0) return !1
    let a = s.parent,
      l = a.child(o - 1)
    if (l.type != e) return !1
    if (t) {
      let c = l.lastChild && l.lastChild.type == a.type,
        u = St.from(c ? e.create() : null),
        f = new jt(St.from(e.create(null, St.from(a.type.create(null, u)))), c ? 3 : 1, 0),
        d = s.start,
        h = s.end
      t(n.tr.step(new un(d - (c ? 3 : 1), h, d, h, f, 1, !0)).scrollIntoView())
    }
    return !0
  }
}
const wn = function (e) {
    for (var n = 0; ; n++) if (((e = e.previousSibling), !e)) return n
  },
  $o = function (e) {
    let n = e.assignedSlot || e.parentNode
    return n && n.nodeType == 11 ? n.host : n
  }
let Jp = null
const Gr = function (e, n, t) {
    let r = Jp || (Jp = document.createRange())
    return (r.setEnd(e, t ?? e.nodeValue.length), r.setStart(e, n || 0), r)
  },
  L$ = function () {
    Jp = null
  },
  Bs = function (e, n, t, r) {
    return t && (Ov(e, n, t, r, -1) || Ov(e, n, t, r, 1))
  },
  F$ = /^(img|br|input|textarea|hr)$/i
function Ov(e, n, t, r, i) {
  for (var s; ; ) {
    if (e == t && n == r) return !0
    if (n == (i < 0 ? 0 : ir(e))) {
      let o = e.parentNode
      if (!o || o.nodeType != 1 || jl(e) || F$.test(e.nodeName) || e.contentEditable == 'false')
        return !1
      ;((n = wn(e) + (i < 0 ? 0 : 1)), (e = o))
    } else if (e.nodeType == 1) {
      let o = e.childNodes[n + (i < 0 ? -1 : 0)]
      if (o.nodeType == 1 && o.contentEditable == 'false')
        if (!((s = o.pmViewDesc) === null || s === void 0) && s.ignoreForSelection) n += i
        else return !1
      else ((e = o), (n = i < 0 ? ir(e) : 0))
    } else return !1
  }
}
function ir(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function B$(e, n) {
  for (;;) {
    if (e.nodeType == 3 && n) return e
    if (e.nodeType == 1 && n > 0) {
      if (e.contentEditable == 'false') return null
      ;((e = e.childNodes[n - 1]), (n = ir(e)))
    } else if (e.parentNode && !jl(e)) ((n = wn(e)), (e = e.parentNode))
    else return null
  }
}
function z$(e, n) {
  for (;;) {
    if (e.nodeType == 3 && n < e.nodeValue.length) return e
    if (e.nodeType == 1 && n < e.childNodes.length) {
      if (e.contentEditable == 'false') return null
      ;((e = e.childNodes[n]), (n = 0))
    } else if (e.parentNode && !jl(e)) ((n = wn(e) + 1), (e = e.parentNode))
    else return null
  }
}
function $$(e, n, t) {
  for (let r = n == 0, i = n == ir(e); r || i; ) {
    if (e == t) return !0
    let s = wn(e)
    if (((e = e.parentNode), !e)) return !1
    ;((r = r && s == 0), (i = i && s == ir(e)))
  }
}
function jl(e) {
  let n
  for (let t = e; t && !(n = t.pmViewDesc); t = t.parentNode);
  return n && n.node && n.node.isBlock && (n.dom == e || n.contentDOM == e)
}
const Jf = function (e) {
  return e.focusNode && Bs(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
}
function as(e, n) {
  let t = document.createEvent('Event')
  return (t.initEvent('keydown', !0, !0), (t.keyCode = e), (t.key = t.code = n), t)
}
function V$(e) {
  let n = e.activeElement
  for (; n && n.shadowRoot; ) n = n.shadowRoot.activeElement
  return n
}
function H$(e, n, t) {
  if (e.caretPositionFromPoint)
    try {
      let r = e.caretPositionFromPoint(n, t)
      if (r) return { node: r.offsetNode, offset: Math.min(ir(r.offsetNode), r.offset) }
    } catch {}
  if (e.caretRangeFromPoint) {
    let r = e.caretRangeFromPoint(n, t)
    if (r) return { node: r.startContainer, offset: Math.min(ir(r.startContainer), r.startOffset) }
  }
}
const Lr = typeof navigator < 'u' ? navigator : null,
  Pv = typeof document < 'u' ? document : null,
  Zi = (Lr && Lr.userAgent) || '',
  Qp = /Edge\/(\d+)/.exec(Zi),
  sS = /MSIE \d/.exec(Zi),
  tm = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Zi),
  Fn = !!(sS || tm || Qp),
  Bi = sS ? document.documentMode : tm ? +tm[1] : Qp ? +Qp[1] : 0,
  lr = !Fn && /gecko\/(\d+)/i.test(Zi)
lr && +(/Firefox\/(\d+)/.exec(Zi) || [0, 0])[1]
const em = !Fn && /Chrome\/(\d+)/.exec(Zi),
  En = !!em,
  oS = em ? +em[1] : 0,
  Pn = !Fn && !!Lr && /Apple Computer/.test(Lr.vendor),
  Vo = Pn && (/Mobile\/\w+/.test(Zi) || (!!Lr && Lr.maxTouchPoints > 2)),
  rr = Vo || (Lr ? /Mac/.test(Lr.platform) : !1),
  U$ = Lr ? /Win/.test(Lr.platform) : !1,
  Yr = /Android \d/.test(Zi),
  Ll = !!Pv && 'webkitFontSmoothing' in Pv.documentElement.style,
  q$ = Ll ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0
function W$(e) {
  let n = e.defaultView && e.defaultView.visualViewport
  return n
    ? { left: 0, right: n.width, top: 0, bottom: n.height }
    : {
        left: 0,
        right: e.documentElement.clientWidth,
        top: 0,
        bottom: e.documentElement.clientHeight,
      }
}
function Hr(e, n) {
  return typeof e == 'number' ? e : e[n]
}
function K$(e) {
  let n = e.getBoundingClientRect(),
    t = n.width / e.offsetWidth || 1,
    r = n.height / e.offsetHeight || 1
  return {
    left: n.left,
    right: n.left + e.clientWidth * t,
    top: n.top,
    bottom: n.top + e.clientHeight * r,
  }
}
function Nv(e, n, t) {
  let r = e.someProp('scrollThreshold') || 0,
    i = e.someProp('scrollMargin') || 5,
    s = e.dom.ownerDocument
  for (let o = t || e.dom; o; ) {
    if (o.nodeType != 1) {
      o = $o(o)
      continue
    }
    let a = o,
      l = a == s.body,
      c = l ? W$(s) : K$(a),
      u = 0,
      f = 0
    if (
      (n.top < c.top + Hr(r, 'top')
        ? (f = -(c.top - n.top + Hr(i, 'top')))
        : n.bottom > c.bottom - Hr(r, 'bottom') &&
          (f =
            n.bottom - n.top > c.bottom - c.top
              ? n.top + Hr(i, 'top') - c.top
              : n.bottom - c.bottom + Hr(i, 'bottom')),
      n.left < c.left + Hr(r, 'left')
        ? (u = -(c.left - n.left + Hr(i, 'left')))
        : n.right > c.right - Hr(r, 'right') && (u = n.right - c.right + Hr(i, 'right')),
      u || f)
    )
      if (l) s.defaultView.scrollBy(u, f)
      else {
        let h = a.scrollLeft,
          p = a.scrollTop
        ;(f && (a.scrollTop += f), u && (a.scrollLeft += u))
        let g = a.scrollLeft - h,
          m = a.scrollTop - p
        n = { left: n.left - g, top: n.top - m, right: n.right - g, bottom: n.bottom - m }
      }
    let d = l ? 'fixed' : getComputedStyle(o).position
    if (/^(fixed|sticky)$/.test(d)) break
    o = d == 'absolute' ? o.offsetParent : $o(o)
  }
}
function G$(e) {
  let n = e.dom.getBoundingClientRect(),
    t = Math.max(0, n.top),
    r,
    i
  for (let s = (n.left + n.right) / 2, o = t + 1; o < Math.min(innerHeight, n.bottom); o += 5) {
    let a = e.root.elementFromPoint(s, o)
    if (!a || a == e.dom || !e.dom.contains(a)) continue
    let l = a.getBoundingClientRect()
    if (l.top >= t - 20) {
      ;((r = a), (i = l.top))
      break
    }
  }
  return { refDOM: r, refTop: i, stack: aS(e.dom) }
}
function aS(e) {
  let n = [],
    t = e.ownerDocument
  for (
    let r = e;
    r && (n.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != t);
    r = $o(r)
  );
  return n
}
function X$({ refDOM: e, refTop: n, stack: t }) {
  let r = e ? e.getBoundingClientRect().top : 0
  lS(t, r == 0 ? 0 : r - n)
}
function lS(e, n) {
  for (let t = 0; t < e.length; t++) {
    let { dom: r, top: i, left: s } = e[t]
    ;(r.scrollTop != i + n && (r.scrollTop = i + n), r.scrollLeft != s && (r.scrollLeft = s))
  }
}
let eo = null
function Y$(e) {
  if (e.setActive) return e.setActive()
  if (eo) return e.focus(eo)
  let n = aS(e)
  ;(e.focus(
    eo == null
      ? {
          get preventScroll() {
            return ((eo = { preventScroll: !0 }), !0)
          },
        }
      : void 0,
  ),
    eo || ((eo = !1), lS(n, 0)))
}
function cS(e, n) {
  let t,
    r = 2e8,
    i,
    s = 0,
    o = n.top,
    a = n.top,
    l,
    c
  for (let u = e.firstChild, f = 0; u; u = u.nextSibling, f++) {
    let d
    if (u.nodeType == 1) d = u.getClientRects()
    else if (u.nodeType == 3) d = Gr(u).getClientRects()
    else continue
    for (let h = 0; h < d.length; h++) {
      let p = d[h]
      if (p.top <= o && p.bottom >= a) {
        ;((o = Math.max(p.bottom, o)), (a = Math.min(p.top, a)))
        let g = p.left > n.left ? p.left - n.left : p.right < n.left ? n.left - p.right : 0
        if (g < r) {
          ;((t = u),
            (r = g),
            (i =
              g && t.nodeType == 3 ? { left: p.right < n.left ? p.right : p.left, top: n.top } : n),
            u.nodeType == 1 && g && (s = f + (n.left >= (p.left + p.right) / 2 ? 1 : 0)))
          continue
        }
      } else
        p.top > n.top &&
          !l &&
          p.left <= n.left &&
          p.right >= n.left &&
          ((l = u), (c = { left: Math.max(p.left, Math.min(p.right, n.left)), top: p.top }))
      !t &&
        ((n.left >= p.right && n.top >= p.top) || (n.left >= p.left && n.top >= p.bottom)) &&
        (s = f + 1)
    }
  }
  return (
    !t && l && ((t = l), (i = c), (r = 0)),
    t && t.nodeType == 3
      ? Z$(t, i)
      : !t || (r && t.nodeType == 1)
        ? { node: e, offset: s }
        : cS(t, i)
  )
}
function Z$(e, n) {
  let t = e.nodeValue.length,
    r = document.createRange()
  for (let i = 0; i < t; i++) {
    ;(r.setEnd(e, i + 1), r.setStart(e, i))
    let s = gi(r, 1)
    if (s.top != s.bottom && mg(n, s))
      return { node: e, offset: i + (n.left >= (s.left + s.right) / 2 ? 1 : 0) }
  }
  return { node: e, offset: 0 }
}
function mg(e, n) {
  return (
    e.left >= n.left - 1 && e.left <= n.right + 1 && e.top >= n.top - 1 && e.top <= n.bottom + 1
  )
}
function J$(e, n) {
  let t = e.parentNode
  return t && /^li$/i.test(t.nodeName) && n.left < e.getBoundingClientRect().left ? t : e
}
function Q$(e, n, t) {
  let { node: r, offset: i } = cS(n, t),
    s = -1
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect()
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1
  }
  return e.docView.posFromDOM(r, i, s)
}
function tV(e, n, t, r) {
  let i = -1
  for (let s = n, o = !1; s != e.dom; ) {
    let a = e.docView.nearestDesc(s, !0),
      l
    if (!a) return null
    if (
      a.dom.nodeType == 1 &&
      ((a.node.isBlock && a.parent) || !a.contentDOM) &&
      ((l = a.dom.getBoundingClientRect()).width || l.height) &&
      (a.node.isBlock &&
        a.parent &&
        !/^T(R|BODY|HEAD|FOOT)$/.test(a.dom.nodeName) &&
        ((!o && l.left > r.left) || l.top > r.top
          ? (i = a.posBefore)
          : ((!o && l.right < r.left) || l.bottom < r.top) && (i = a.posAfter),
        (o = !0)),
      !a.contentDOM && i < 0 && !a.node.isText)
    )
      return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2)
        ? a.posBefore
        : a.posAfter
    s = a.dom.parentNode
  }
  return i > -1 ? i : e.docView.posFromDOM(n, t, -1)
}
function uS(e, n, t) {
  let r = e.childNodes.length
  if (r && t.top < t.bottom)
    for (
      let i = Math.max(
          0,
          Math.min(r - 1, Math.floor((r * (n.top - t.top)) / (t.bottom - t.top)) - 2),
        ),
        s = i;
      ;

    ) {
      let o = e.childNodes[s]
      if (o.nodeType == 1) {
        let a = o.getClientRects()
        for (let l = 0; l < a.length; l++) {
          let c = a[l]
          if (mg(n, c)) return uS(o, n, c)
        }
      }
      if ((s = (s + 1) % r) == i) break
    }
  return e
}
function eV(e, n) {
  let t = e.dom.ownerDocument,
    r,
    i = 0,
    s = H$(t, n.left, n.top)
  s && ({ node: r, offset: i } = s)
  let o = (e.root.elementFromPoint ? e.root : t).elementFromPoint(n.left, n.top),
    a
  if (!o || !e.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = e.dom.getBoundingClientRect()
    if (!mg(n, c) || ((o = uS(e.dom, n, c)), !o)) return null
  }
  if (Pn) for (let c = o; r && c; c = $o(c)) c.draggable && (r = void 0)
  if (((o = J$(o, n)), r)) {
    if (
      lr &&
      r.nodeType == 1 &&
      ((i = Math.min(i, r.childNodes.length)), i < r.childNodes.length)
    ) {
      let u = r.childNodes[i],
        f
      u.nodeName == 'IMG' &&
        (f = u.getBoundingClientRect()).right <= n.left &&
        f.bottom > n.top &&
        i++
    }
    let c
    ;(Ll &&
      i &&
      r.nodeType == 1 &&
      (c = r.childNodes[i - 1]).nodeType == 1 &&
      c.contentEditable == 'false' &&
      c.getBoundingClientRect().top >= n.top &&
      i--,
      r == e.dom &&
      i == r.childNodes.length - 1 &&
      r.lastChild.nodeType == 1 &&
      n.top > r.lastChild.getBoundingClientRect().bottom
        ? (a = e.state.doc.content.size)
        : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != 'BR') &&
          (a = tV(e, r, i, n)))
  }
  a == null && (a = Q$(e, o, n))
  let l = e.docView.nearestDesc(o, !0)
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 }
}
function Iv(e) {
  return e.top < e.bottom || e.left < e.right
}
function gi(e, n) {
  let t = e.getClientRects()
  if (t.length) {
    let r = t[n < 0 ? 0 : t.length - 1]
    if (Iv(r)) return r
  }
  return Array.prototype.find.call(t, Iv) || e.getBoundingClientRect()
}
const nV = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
function fS(e, n, t) {
  let { node: r, offset: i, atom: s } = e.docView.domFromPos(n, t < 0 ? -1 : 1),
    o = Ll || lr
  if (r.nodeType == 3)
    if (o && (nV.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let l = gi(Gr(r, i, i), t)
      if (lr && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = gi(Gr(r, i - 1, i - 1), -1)
        if (c.top == l.top) {
          let u = gi(Gr(r, i, i + 1), -1)
          if (u.top != l.top) return ha(u, u.left < c.left)
        }
      }
      return l
    } else {
      let l = i,
        c = i,
        u = t < 0 ? 1 : -1
      return (
        t < 0 && !i
          ? (c++, (u = -1))
          : t >= 0 && i == r.nodeValue.length
            ? (l--, (u = 1))
            : t < 0
              ? l--
              : c++,
        ha(gi(Gr(r, l, c), u), u < 0)
      )
    }
  if (!e.state.doc.resolve(n - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == ir(r))) {
      let l = r.childNodes[i - 1]
      if (l.nodeType == 1) return hh(l.getBoundingClientRect(), !1)
    }
    if (s == null && i < ir(r)) {
      let l = r.childNodes[i]
      if (l.nodeType == 1) return hh(l.getBoundingClientRect(), !0)
    }
    return hh(r.getBoundingClientRect(), t >= 0)
  }
  if (s == null && i && (t < 0 || i == ir(r))) {
    let l = r.childNodes[i - 1],
      c =
        l.nodeType == 3
          ? Gr(l, ir(l) - (o ? 0 : 1))
          : l.nodeType == 1 && (l.nodeName != 'BR' || !l.nextSibling)
            ? l
            : null
    if (c) return ha(gi(c, 1), !1)
  }
  if (s == null && i < ir(r)) {
    let l = r.childNodes[i]
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; ) l = l.nextSibling
    let c = l ? (l.nodeType == 3 ? Gr(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null) : null
    if (c) return ha(gi(c, -1), !0)
  }
  return ha(gi(r.nodeType == 3 ? Gr(r) : r, -t), t >= 0)
}
function ha(e, n) {
  if (e.width == 0) return e
  let t = n ? e.left : e.right
  return { top: e.top, bottom: e.bottom, left: t, right: t }
}
function hh(e, n) {
  if (e.height == 0) return e
  let t = n ? e.top : e.bottom
  return { top: t, bottom: t, left: e.left, right: e.right }
}
function dS(e, n, t) {
  let r = e.state,
    i = e.root.activeElement
  ;(r != n && e.updateState(n), i != e.dom && e.focus())
  try {
    return t()
  } finally {
    ;(r != n && e.updateState(r), i != e.dom && i && i.focus())
  }
}
function rV(e, n, t) {
  let r = n.selection,
    i = t == 'up' ? r.$from : r.$to
  return dS(e, n, () => {
    let { node: s } = e.docView.domFromPos(i.pos, t == 'up' ? -1 : 1)
    for (;;) {
      let a = e.docView.nearestDesc(s, !0)
      if (!a) break
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom
        break
      }
      s = a.dom.parentNode
    }
    let o = fS(e, i.pos, 1)
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l
      if (a.nodeType == 1) l = a.getClientRects()
      else if (a.nodeType == 3) l = Gr(a, 0, a.nodeValue.length).getClientRects()
      else continue
      for (let c = 0; c < l.length; c++) {
        let u = l[c]
        if (
          u.bottom > u.top + 1 &&
          (t == 'up'
            ? o.top - u.top > (u.bottom - o.top) * 2
            : u.bottom - o.bottom > (o.bottom - u.top) * 2)
        )
          return !1
      }
    }
    return !0
  })
}
const iV = /[\u0590-\u08ac]/
function sV(e, n, t) {
  let { $head: r } = n.selection
  if (!r.parent.isTextblock) return !1
  let i = r.parentOffset,
    s = !i,
    o = i == r.parent.content.size,
    a = e.domSelection()
  return a
    ? !iV.test(r.parent.textContent) || !a.modify
      ? t == 'left' || t == 'backward'
        ? s
        : o
      : dS(e, n, () => {
          let {
              focusNode: l,
              focusOffset: c,
              anchorNode: u,
              anchorOffset: f,
            } = e.domSelectionRange(),
            d = a.caretBidiLevel
          a.modify('move', t, 'character')
          let h = r.depth ? e.docView.domAfterPos(r.before()) : e.dom,
            { focusNode: p, focusOffset: g } = e.domSelectionRange(),
            m = (p && !h.contains(p.nodeType == 1 ? p : p.parentNode)) || (l == p && c == g)
          try {
            ;(a.collapse(u, f), l && (l != u || c != f) && a.extend && a.extend(l, c))
          } catch {}
          return (d != null && (a.caretBidiLevel = d), m)
        })
    : r.pos == r.start() || r.pos == r.end()
}
let Dv = null,
  jv = null,
  Lv = !1
function oV(e, n, t) {
  return Dv == n && jv == t
    ? Lv
    : ((Dv = n), (jv = t), (Lv = t == 'up' || t == 'down' ? rV(e, n, t) : sV(e, n, t)))
}
const cr = 0,
  Fv = 1,
  hs = 2,
  Fr = 3
class Fl {
  constructor(n, t, r, i) {
    ;((this.parent = n),
      (this.children = t),
      (this.dom = r),
      (this.contentDOM = i),
      (this.dirty = cr),
      (r.pmViewDesc = this))
  }
  matchesWidget(n) {
    return !1
  }
  matchesMark(n) {
    return !1
  }
  matchesNode(n, t, r) {
    return !1
  }
  matchesHack(n) {
    return !1
  }
  parseRule() {
    return null
  }
  stopEvent(n) {
    return !1
  }
  get size() {
    let n = 0
    for (let t = 0; t < this.children.length; t++) n += this.children[t].size
    return n
  }
  get border() {
    return 0
  }
  destroy() {
    ;((this.parent = void 0), this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0))
    for (let n = 0; n < this.children.length; n++) this.children[n].destroy()
  }
  posBeforeChild(n) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t]
      if (i == n) return r
      r += i.size
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this)
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
  }
  get posAfter() {
    return this.posBefore + this.size
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border
  }
  localPosFromDOM(n, t, r) {
    if (this.contentDOM && this.contentDOM.contains(n.nodeType == 1 ? n : n.parentNode))
      if (r < 0) {
        let s, o
        if (n == this.contentDOM) s = n.childNodes[t - 1]
        else {
          for (; n.parentNode != this.contentDOM; ) n = n.parentNode
          s = n.previousSibling
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); ) s = s.previousSibling
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart
      } else {
        let s, o
        if (n == this.contentDOM) s = n.childNodes[t]
        else {
          for (; n.parentNode != this.contentDOM; ) n = n.parentNode
          s = n.nextSibling
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); ) s = s.nextSibling
        return s ? this.posBeforeChild(o) : this.posAtEnd
      }
    let i
    if (n == this.dom && this.contentDOM) i = t > wn(this.contentDOM)
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = n.compareDocumentPosition(this.contentDOM) & 2
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = n; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1
            break
          }
          if (s.previousSibling) break
        }
      if (i == null && t == n.childNodes.length)
        for (let s = n; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0
            break
          }
          if (s.nextSibling) break
        }
    }
    return (i ?? r > 0) ? this.posAtEnd : this.posAtStart
  }
  nearestDesc(n, t = !1) {
    for (let r = !0, i = n; i; i = i.parentNode) {
      let s = this.getDesc(i),
        o
      if (s && (!t || s.node))
        if (
          r &&
          (o = s.nodeDOM) &&
          !(o.nodeType == 1 ? o.contains(n.nodeType == 1 ? n : n.parentNode) : o == n)
        )
          r = !1
        else return s
    }
  }
  getDesc(n) {
    let t = n.pmViewDesc
    for (let r = t; r; r = r.parent) if (r == this) return t
  }
  posFromDOM(n, t, r) {
    for (let i = n; i; i = i.parentNode) {
      let s = this.getDesc(i)
      if (s) return s.localPosFromDOM(n, t, r)
    }
    return -1
  }
  descAt(n) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t],
        s = r + i.size
      if (r == n && s != r) {
        for (; !i.border && i.children.length; )
          for (let o = 0; o < i.children.length; o++) {
            let a = i.children[o]
            if (a.size) {
              i = a
              break
            }
          }
        return i
      }
      if (n < s) return i.descAt(n - r - i.border)
      r = s
    }
  }
  domFromPos(n, t) {
    if (!this.contentDOM) return { node: this.dom, offset: 0, atom: n + 1 }
    let r = 0,
      i = 0
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r],
        a = s + o.size
      if (a > n || o instanceof pS) {
        i = n - s
        break
      }
      s = a
    }
    if (i) return this.children[r].domFromPos(i - this.children[r].border, t)
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof hS && s.side >= 0; r--);
    if (t <= 0) {
      let s,
        o = !0
      for (
        ;
        (s = r ? this.children[r - 1] : null), !(!s || s.dom.parentNode == this.contentDOM);
        r--, o = !1
      );
      return s && t && o && !s.border && !s.domAtom
        ? s.domFromPos(s.size, t)
        : { node: this.contentDOM, offset: s ? wn(s.dom) + 1 : 0 }
    } else {
      let s,
        o = !0
      for (
        ;
        (s = r < this.children.length ? this.children[r] : null),
          !(!s || s.dom.parentNode == this.contentDOM);
        r++, o = !1
      );
      return s && o && !s.border && !s.domAtom
        ? s.domFromPos(0, t)
        : { node: this.contentDOM, offset: s ? wn(s.dom) : this.contentDOM.childNodes.length }
    }
  }
  parseRange(n, t, r = 0) {
    if (this.children.length == 0)
      return {
        node: this.contentDOM,
        from: n,
        to: t,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length,
      }
    let i = -1,
      s = -1
    for (let o = r, a = 0; ; a++) {
      let l = this.children[a],
        c = o + l.size
      if (i == -1 && n <= c) {
        let u = o + l.border
        if (
          n >= u &&
          t <= c - l.border &&
          l.node &&
          l.contentDOM &&
          this.contentDOM.contains(l.contentDOM)
        )
          return l.parseRange(n, t, u)
        n = o
        for (let f = a; f > 0; f--) {
          let d = this.children[f - 1]
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(1)) {
            i = wn(d.dom) + 1
            break
          }
          n -= d.size
        }
        i == -1 && (i = 0)
      }
      if (i > -1 && (c > t || a == this.children.length - 1)) {
        t = c
        for (let u = a + 1; u < this.children.length; u++) {
          let f = this.children[u]
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) {
            s = wn(f.dom)
            break
          }
          t += f.size
        }
        s == -1 && (s = this.contentDOM.childNodes.length)
        break
      }
      o = c
    }
    return { node: this.contentDOM, from: n, to: t, fromOffset: i, toOffset: s }
  }
  emptyChildAt(n) {
    if (this.border || !this.contentDOM || !this.children.length) return !1
    let t = this.children[n < 0 ? 0 : this.children.length - 1]
    return t.size == 0 || t.emptyChildAt(n)
  }
  domAfterPos(n) {
    let { node: t, offset: r } = this.domFromPos(n, 0)
    if (t.nodeType != 1 || r == t.childNodes.length) throw new RangeError('No node after pos ' + n)
    return t.childNodes[r]
  }
  setSelection(n, t, r, i = !1) {
    let s = Math.min(n, t),
      o = Math.max(n, t)
    for (let h = 0, p = 0; h < this.children.length; h++) {
      let g = this.children[h],
        m = p + g.size
      if (s > p && o < m) return g.setSelection(n - p - g.border, t - p - g.border, r, i)
      p = m
    }
    let a = this.domFromPos(n, n ? -1 : 1),
      l = t == n ? a : this.domFromPos(t, t ? -1 : 1),
      c = r.root.getSelection(),
      u = r.domSelectionRange(),
      f = !1
    if ((lr || Pn) && n == t) {
      let { node: h, offset: p } = a
      if (h.nodeType == 3) {
        if (
          ((f = !!(
            p &&
            h.nodeValue[p - 1] ==
              `
`
          )),
          f && p == h.nodeValue.length)
        )
          for (let g = h, m; g; g = g.parentNode) {
            if ((m = g.nextSibling)) {
              m.nodeName == 'BR' && (a = l = { node: m.parentNode, offset: wn(m) + 1 })
              break
            }
            let y = g.pmViewDesc
            if (y && y.node && y.node.isBlock) break
          }
      } else {
        let g = h.childNodes[p - 1]
        f = g && (g.nodeName == 'BR' || g.contentEditable == 'false')
      }
    }
    if (lr && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let h = u.focusNode.childNodes[u.focusOffset]
      h && h.contentEditable == 'false' && (i = !0)
    }
    if (
      !(i || (f && Pn)) &&
      Bs(a.node, a.offset, u.anchorNode, u.anchorOffset) &&
      Bs(l.node, l.offset, u.focusNode, u.focusOffset)
    )
      return
    let d = !1
    if ((c.extend || n == t) && !(f && lr)) {
      c.collapse(a.node, a.offset)
      try {
        ;(n != t && c.extend(l.node, l.offset), (d = !0))
      } catch {}
    }
    if (!d) {
      if (n > t) {
        let p = a
        ;((a = l), (l = p))
      }
      let h = document.createRange()
      ;(h.setEnd(l.node, l.offset),
        h.setStart(a.node, a.offset),
        c.removeAllRanges(),
        c.addRange(h))
    }
  }
  ignoreMutation(n) {
    return !this.contentDOM && n.type != 'selection'
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
  }
  markDirty(n, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i],
        o = r + s.size
      if (r == o ? n <= o && t >= r : n < o && t > r) {
        let a = r + s.border,
          l = o - s.border
        if (n >= a && t <= l) {
          ;((this.dirty = n == r || t == o ? hs : Fv),
            n == a && t == l && (s.contentLost || s.dom.parentNode != this.contentDOM)
              ? (s.dirty = Fr)
              : s.markDirty(n - a, t - a))
          return
        } else
          s.dirty =
            s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length
              ? hs
              : Fr
      }
      r = o
    }
    this.dirty = hs
  }
  markParentsDirty() {
    let n = 1
    for (let t = this.parent; t; t = t.parent, n++) {
      let r = n == 1 ? hs : Fv
      t.dirty < r && (t.dirty = r)
    }
  }
  get domAtom() {
    return !1
  }
  get ignoreForCoords() {
    return !1
  }
  get ignoreForSelection() {
    return !1
  }
  isText(n) {
    return !1
  }
}
class hS extends Fl {
  constructor(n, t, r, i) {
    let s,
      o = t.type.toDOM
    if (
      (typeof o == 'function' &&
        (o = o(r, () => {
          if (!s) return i
          if (s.parent) return s.parent.posBeforeChild(s)
        })),
      !t.type.spec.raw)
    ) {
      if (o.nodeType != 1) {
        let a = document.createElement('span')
        ;(a.appendChild(o), (o = a))
      }
      ;((o.contentEditable = 'false'), o.classList.add('ProseMirror-widget'))
    }
    ;(super(n, [], o, null), (this.widget = t), (this.widget = t), (s = this))
  }
  matchesWidget(n) {
    return this.dirty == cr && n.type.eq(this.widget.type)
  }
  parseRule() {
    return { ignore: !0 }
  }
  stopEvent(n) {
    let t = this.widget.spec.stopEvent
    return t ? t(n) : !1
  }
  ignoreMutation(n) {
    return n.type != 'selection' || this.widget.spec.ignoreSelection
  }
  destroy() {
    ;(this.widget.type.destroy(this.dom), super.destroy())
  }
  get domAtom() {
    return !0
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide
  }
  get side() {
    return this.widget.type.side
  }
}
class aV extends Fl {
  constructor(n, t, r, i) {
    ;(super(n, [], t, null), (this.textDOM = r), (this.text = i))
  }
  get size() {
    return this.text.length
  }
  localPosFromDOM(n, t) {
    return n != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t
  }
  domFromPos(n) {
    return { node: this.textDOM, offset: n }
  }
  ignoreMutation(n) {
    return n.type === 'characterData' && n.target.nodeValue == n.oldValue
  }
}
class zs extends Fl {
  constructor(n, t, r, i, s) {
    ;(super(n, [], r, i), (this.mark = t), (this.spec = s))
  }
  static create(n, t, r, i) {
    let s = i.nodeViews[t.type.name],
      o = s && s(t, i, r)
    return (
      (!o || !o.dom) && (o = Hs.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)),
      new zs(n, t, o.dom, o.contentDOM || o.dom, o)
    )
  }
  parseRule() {
    return this.dirty & Fr || this.mark.type.spec.reparseInView
      ? null
      : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM }
  }
  matchesMark(n) {
    return this.dirty != Fr && this.mark.eq(n)
  }
  markDirty(n, t) {
    if ((super.markDirty(n, t), this.dirty != cr)) {
      let r = this.parent
      for (; !r.node; ) r = r.parent
      ;(r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = cr))
    }
  }
  slice(n, t, r) {
    let i = zs.create(this.parent, this.mark, !0, r),
      s = this.children,
      o = this.size
    ;(t < o && (s = rm(s, t, o, r)), n > 0 && (s = rm(s, 0, n, r)))
    for (let a = 0; a < s.length; a++) s[a].parent = i
    return ((i.children = s), i)
  }
  ignoreMutation(n) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(n) : super.ignoreMutation(n)
  }
  destroy() {
    ;(this.spec.destroy && this.spec.destroy(), super.destroy())
  }
}
class zi extends Fl {
  constructor(n, t, r, i, s, o, a, l, c) {
    ;(super(n, [], s, o),
      (this.node = t),
      (this.outerDeco = r),
      (this.innerDeco = i),
      (this.nodeDOM = a))
  }
  static create(n, t, r, i, s, o) {
    let a = s.nodeViews[t.type.name],
      l,
      c =
        a &&
        a(
          t,
          s,
          () => {
            if (!l) return o
            if (l.parent) return l.parent.posBeforeChild(l)
          },
          r,
          i,
        ),
      u = c && c.dom,
      f = c && c.contentDOM
    if (t.isText) {
      if (!u) u = document.createTextNode(t.text)
      else if (u.nodeType != 3) throw new RangeError('Text must be rendered as a DOM text node')
    } else
      u ||
        ({ dom: u, contentDOM: f } = Hs.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs))
    !f &&
      !t.isText &&
      u.nodeName != 'BR' &&
      (u.hasAttribute('contenteditable') || (u.contentEditable = 'false'),
      t.type.spec.draggable && (u.draggable = !0))
    let d = u
    return (
      (u = yS(u, r, t)),
      c
        ? (l = new lV(n, t, r, i, u, f || null, d, c, s, o + 1))
        : t.isText
          ? new Qf(n, t, r, i, u, d, s)
          : new zi(n, t, r, i, u, f || null, d, s, o + 1)
    )
  }
  parseRule() {
    if (this.node.type.spec.reparseInView) return null
    let n = { node: this.node.type.name, attrs: this.node.attrs }
    if ((this.node.type.whitespace == 'pre' && (n.preserveWhitespace = 'full'), !this.contentDOM))
      n.getContent = () => this.node.content
    else if (!this.contentLost) n.contentElement = this.contentDOM
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t]
        if (this.dom.contains(r.dom.parentNode)) {
          n.contentElement = r.dom.parentNode
          break
        }
      }
      n.contentElement || (n.getContent = () => St.empty)
    }
    return n
  }
  matchesNode(n, t, r) {
    return this.dirty == cr && n.eq(this.node) && Iu(t, this.outerDeco) && r.eq(this.innerDeco)
  }
  get size() {
    return this.node.nodeSize
  }
  get border() {
    return this.node.isLeaf ? 0 : 1
  }
  updateChildren(n, t) {
    let r = this.node.inlineContent,
      i = t,
      s = n.composing ? this.localCompositionInfo(n, t) : null,
      o = s && s.pos > -1 ? s : null,
      a = s && s.pos < 0,
      l = new uV(this, o && o.node, n)
    ;(hV(
      this.node,
      this.innerDeco,
      (c, u, f) => {
        ;(c.spec.marks
          ? l.syncToMarks(c.spec.marks, r, n)
          : c.type.side >= 0 &&
            !f &&
            l.syncToMarks(u == this.node.childCount ? Oe.none : this.node.child(u).marks, r, n),
          l.placeWidget(c, n, i))
      },
      (c, u, f, d) => {
        l.syncToMarks(c.marks, r, n)
        let h
        ;(l.findNodeMatch(c, u, f, d) ||
          (a &&
            n.state.selection.from > i &&
            n.state.selection.to < i + c.nodeSize &&
            (h = l.findIndexWithChild(s.node)) > -1 &&
            l.updateNodeAt(c, u, f, h, n)) ||
          l.updateNextNode(c, u, f, n, d, i) ||
          l.addNode(c, u, f, n, i),
          (i += c.nodeSize))
      },
    ),
      l.syncToMarks([], r, n),
      this.node.isTextblock && l.addTextblockHacks(),
      l.destroyRest(),
      (l.changed || this.dirty == hs) &&
        (o && this.protectLocalComposition(n, o),
        mS(this.contentDOM, this.children, n),
        Vo && pV(this.dom)))
  }
  localCompositionInfo(n, t) {
    let { from: r, to: i } = n.state.selection
    if (!(n.state.selection instanceof oe) || r < t || i > t + this.node.content.size) return null
    let s = n.input.compositionNode
    if (!s || !this.dom.contains(s.parentNode)) return null
    if (this.node.inlineContent) {
      let o = s.nodeValue,
        a = mV(this.node.content, o, r - t, i - t)
      return a < 0 ? null : { node: s, pos: a, text: o }
    } else return { node: s, pos: -1, text: '' }
  }
  protectLocalComposition(n, { node: t, pos: r, text: i }) {
    if (this.getDesc(t)) return
    let s = t
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; ) s.parentNode.removeChild(s.previousSibling)
      for (; s.nextSibling; ) s.parentNode.removeChild(s.nextSibling)
      s.pmViewDesc && (s.pmViewDesc = void 0)
    }
    let o = new aV(this, s, t, i)
    ;(n.input.compositionNodes.push(o), (this.children = rm(this.children, r, r + i.length, n, o)))
  }
  update(n, t, r, i) {
    return this.dirty == Fr || !n.sameMarkup(this.node) ? !1 : (this.updateInner(n, t, r, i), !0)
  }
  updateInner(n, t, r, i) {
    ;(this.updateOuterDeco(t),
      (this.node = n),
      (this.innerDeco = r),
      this.contentDOM && this.updateChildren(i, this.posAtStart),
      (this.dirty = cr))
  }
  updateOuterDeco(n) {
    if (Iu(n, this.outerDeco)) return
    let t = this.nodeDOM.nodeType != 1,
      r = this.dom
    ;((this.dom = gS(
      this.dom,
      this.nodeDOM,
      nm(this.outerDeco, this.node, t),
      nm(n, this.node, t),
    )),
      this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
      (this.outerDeco = n))
  }
  selectNode() {
    this.nodeDOM.nodeType == 1 &&
      (this.nodeDOM.classList.add('ProseMirror-selectednode'),
      (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0))
  }
  deselectNode() {
    this.nodeDOM.nodeType == 1 &&
      (this.nodeDOM.classList.remove('ProseMirror-selectednode'),
      (this.contentDOM || !this.node.type.spec.draggable) &&
        this.nodeDOM.removeAttribute('draggable'))
  }
  get domAtom() {
    return this.node.isAtom
  }
}
function Bv(e, n, t, r, i) {
  yS(r, n, e)
  let s = new zi(void 0, e, n, t, r, r, r, i, 0)
  return (s.contentDOM && s.updateChildren(i, 0), s)
}
class Qf extends zi {
  constructor(n, t, r, i, s, o, a) {
    super(n, t, r, i, s, null, o, a, 0)
  }
  parseRule() {
    let n = this.nodeDOM.parentNode
    for (; n && n != this.dom && !n.pmIsDeco; ) n = n.parentNode
    return { skip: n || !0 }
  }
  update(n, t, r, i) {
    return this.dirty == Fr || (this.dirty != cr && !this.inParent()) || !n.sameMarkup(this.node)
      ? !1
      : (this.updateOuterDeco(t),
        (this.dirty != cr || n.text != this.node.text) &&
          n.text != this.nodeDOM.nodeValue &&
          ((this.nodeDOM.nodeValue = n.text),
          i.trackWrites == this.nodeDOM && (i.trackWrites = null)),
        (this.node = n),
        (this.dirty = cr),
        !0)
  }
  inParent() {
    let n = this.parent.contentDOM
    for (let t = this.nodeDOM; t; t = t.parentNode) if (t == n) return !0
    return !1
  }
  domFromPos(n) {
    return { node: this.nodeDOM, offset: n }
  }
  localPosFromDOM(n, t, r) {
    return n == this.nodeDOM
      ? this.posAtStart + Math.min(t, this.node.text.length)
      : super.localPosFromDOM(n, t, r)
  }
  ignoreMutation(n) {
    return n.type != 'characterData' && n.type != 'selection'
  }
  slice(n, t, r) {
    let i = this.node.cut(n, t),
      s = document.createTextNode(i.text)
    return new Qf(this.parent, i, this.outerDeco, this.innerDeco, s, s, r)
  }
  markDirty(n, t) {
    ;(super.markDirty(n, t),
      this.dom != this.nodeDOM &&
        (n == 0 || t == this.nodeDOM.nodeValue.length) &&
        (this.dirty = Fr))
  }
  get domAtom() {
    return !1
  }
  isText(n) {
    return this.node.text == n
  }
}
class pS extends Fl {
  parseRule() {
    return { ignore: !0 }
  }
  matchesHack(n) {
    return this.dirty == cr && this.dom.nodeName == n
  }
  get domAtom() {
    return !0
  }
  get ignoreForCoords() {
    return this.dom.nodeName == 'IMG'
  }
}
class lV extends zi {
  constructor(n, t, r, i, s, o, a, l, c, u) {
    ;(super(n, t, r, i, s, o, a, c, u), (this.spec = l))
  }
  update(n, t, r, i) {
    if (this.dirty == Fr) return !1
    if (this.spec.update && (this.node.type == n.type || this.spec.multiType)) {
      let s = this.spec.update(n, t, r)
      return (s && this.updateInner(n, t, r, i), s)
    } else return !this.contentDOM && !n.isLeaf ? !1 : super.update(n, t, r, i)
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
  }
  setSelection(n, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(n, t, r.root) : super.setSelection(n, t, r, i)
  }
  destroy() {
    ;(this.spec.destroy && this.spec.destroy(), super.destroy())
  }
  stopEvent(n) {
    return this.spec.stopEvent ? this.spec.stopEvent(n) : !1
  }
  ignoreMutation(n) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(n) : super.ignoreMutation(n)
  }
}
function mS(e, n, t) {
  let r = e.firstChild,
    i = !1
  for (let s = 0; s < n.length; s++) {
    let o = n[s],
      a = o.dom
    if (a.parentNode == e) {
      for (; a != r; ) ((r = zv(r)), (i = !0))
      r = r.nextSibling
    } else ((i = !0), e.insertBefore(a, r))
    if (o instanceof zs) {
      let l = r ? r.previousSibling : e.lastChild
      ;(mS(o.contentDOM, o.children, t), (r = l ? l.nextSibling : e.firstChild))
    }
  }
  for (; r; ) ((r = zv(r)), (i = !0))
  i && t.trackWrites == e && (t.trackWrites = null)
}
const za = function (e) {
  e && (this.nodeName = e)
}
za.prototype = Object.create(null)
const ps = [new za()]
function nm(e, n, t) {
  if (e.length == 0) return ps
  let r = t ? ps[0] : new za(),
    i = [r]
  for (let s = 0; s < e.length; s++) {
    let o = e[s].type.attrs
    if (o) {
      o.nodeName && i.push((r = new za(o.nodeName)))
      for (let a in o) {
        let l = o[a]
        l != null &&
          (t && i.length == 1 && i.push((r = new za(n.isInline ? 'span' : 'div'))),
          a == 'class'
            ? (r.class = (r.class ? r.class + ' ' : '') + l)
            : a == 'style'
              ? (r.style = (r.style ? r.style + ';' : '') + l)
              : a != 'nodeName' && (r[a] = l))
      }
    }
  }
  return i
}
function gS(e, n, t, r) {
  if (t == ps && r == ps) return n
  let i = n
  for (let s = 0; s < r.length; s++) {
    let o = r[s],
      a = t[s]
    if (s) {
      let l
      ;((a &&
        a.nodeName == o.nodeName &&
        i != e &&
        (l = i.parentNode) &&
        l.nodeName.toLowerCase() == o.nodeName) ||
        ((l = document.createElement(o.nodeName)),
        (l.pmIsDeco = !0),
        l.appendChild(i),
        (a = ps[0])),
        (i = l))
    }
    cV(i, a || ps[0], o)
  }
  return i
}
function cV(e, n, t) {
  for (let r in n)
    r != 'class' && r != 'style' && r != 'nodeName' && !(r in t) && e.removeAttribute(r)
  for (let r in t)
    r != 'class' && r != 'style' && r != 'nodeName' && t[r] != n[r] && e.setAttribute(r, t[r])
  if (n.class != t.class) {
    let r = n.class ? n.class.split(' ').filter(Boolean) : [],
      i = t.class ? t.class.split(' ').filter(Boolean) : []
    for (let s = 0; s < r.length; s++) i.indexOf(r[s]) == -1 && e.classList.remove(r[s])
    for (let s = 0; s < i.length; s++) r.indexOf(i[s]) == -1 && e.classList.add(i[s])
    e.classList.length == 0 && e.removeAttribute('class')
  }
  if (n.style != t.style) {
    if (n.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
        i
      for (; (i = r.exec(n.style)); ) e.style.removeProperty(i[1])
    }
    t.style && (e.style.cssText += t.style)
  }
}
function yS(e, n, t) {
  return gS(e, e, ps, nm(n, t, e.nodeType != 1))
}
function Iu(e, n) {
  if (e.length != n.length) return !1
  for (let t = 0; t < e.length; t++) if (!e[t].type.eq(n[t].type)) return !1
  return !0
}
function zv(e) {
  let n = e.nextSibling
  return (e.parentNode.removeChild(e), n)
}
class uV {
  constructor(n, t, r) {
    ;((this.lock = t),
      (this.view = r),
      (this.index = 0),
      (this.stack = []),
      (this.changed = !1),
      (this.top = n),
      (this.preMatch = fV(n.node.content, n)))
  }
  destroyBetween(n, t) {
    if (n != t) {
      for (let r = n; r < t; r++) this.top.children[r].destroy()
      ;(this.top.children.splice(n, t - n), (this.changed = !0))
    }
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length)
  }
  syncToMarks(n, t, r) {
    let i = 0,
      s = this.stack.length >> 1,
      o = Math.min(s, n.length)
    for (
      ;
      i < o &&
      (i == s - 1 ? this.top : this.stack[(i + 1) << 1]).matchesMark(n[i]) &&
      n[i].type.spec.spanning !== !1;

    )
      i++
    for (; i < s; )
      (this.destroyRest(),
        (this.top.dirty = cr),
        (this.index = this.stack.pop()),
        (this.top = this.stack.pop()),
        s--)
    for (; s < n.length; ) {
      this.stack.push(this.top, this.index + 1)
      let a = -1
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l]
        if (c.matchesMark(n[s]) && !this.isLocked(c.dom)) {
          a = l
          break
        }
      }
      if (a > -1)
        (a > this.index && ((this.changed = !0), this.destroyBetween(this.index, a)),
          (this.top = this.top.children[this.index]))
      else {
        let l = zs.create(this.top, n[s], t, r)
        ;(this.top.children.splice(this.index, 0, l), (this.top = l), (this.changed = !0))
      }
      ;((this.index = 0), s++)
    }
  }
  findNodeMatch(n, t, r, i) {
    let s = -1,
      o
    if (
      i >= this.preMatch.index &&
      (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top &&
      o.matchesNode(n, t, r)
    )
      s = this.top.children.indexOf(o, this.index)
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a]
        if (c.matchesNode(n, t, r) && !this.preMatch.matched.has(c)) {
          s = a
          break
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0)
  }
  updateNodeAt(n, t, r, i, s) {
    let o = this.top.children[i]
    return (
      o.dirty == Fr && o.dom == o.contentDOM && (o.dirty = hs),
      o.update(n, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1
    )
  }
  findIndexWithChild(n) {
    for (;;) {
      let t = n.parentNode
      if (!t) return -1
      if (t == this.top.contentDOM) {
        let r = n.pmViewDesc
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r) return i
        }
        return -1
      }
      n = t
    }
  }
  updateNextNode(n, t, r, i, s, o) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a]
      if (l instanceof zi) {
        let c = this.preMatch.matched.get(l)
        if (c != null && c != s) return !1
        let u = l.dom,
          f,
          d =
            this.isLocked(u) &&
            !(
              n.isText &&
              l.node &&
              l.node.isText &&
              l.nodeDOM.nodeValue == n.text &&
              l.dirty != Fr &&
              Iu(t, l.outerDeco)
            )
        if (!d && l.update(n, t, r, i))
          return (
            this.destroyBetween(this.index, a),
            l.dom != u && (this.changed = !0),
            this.index++,
            !0
          )
        if (!d && (f = this.recreateWrapper(l, n, t, r, i, o)))
          return (
            this.destroyBetween(this.index, a),
            (this.top.children[this.index] = f),
            f.contentDOM && ((f.dirty = hs), f.updateChildren(i, o + 1), (f.dirty = cr)),
            (this.changed = !0),
            this.index++,
            !0
          )
        break
      }
    }
    return !1
  }
  recreateWrapper(n, t, r, i, s, o) {
    if (
      n.dirty ||
      t.isAtom ||
      !n.children.length ||
      !n.node.content.eq(t.content) ||
      !Iu(r, n.outerDeco) ||
      !i.eq(n.innerDeco)
    )
      return null
    let a = zi.create(this.top, t, r, i, s, o)
    if (a.contentDOM) {
      ;((a.children = n.children), (n.children = []))
      for (let l of a.children) l.parent = a
    }
    return (n.destroy(), a)
  }
  addNode(n, t, r, i, s) {
    let o = zi.create(this.top, n, t, r, i, s)
    ;(o.contentDOM && o.updateChildren(i, s + 1),
      this.top.children.splice(this.index++, 0, o),
      (this.changed = !0))
  }
  placeWidget(n, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null
    if (i && i.matchesWidget(n) && (n == i.widget || !i.widget.type.toDOM.parentNode)) this.index++
    else {
      let s = new hS(this.top, n, t, r)
      ;(this.top.children.splice(this.index++, 0, s), (this.changed = !0))
    }
  }
  addTextblockHacks() {
    let n = this.top.children[this.index - 1],
      t = this.top
    for (; n instanceof zs; ) ((t = n), (n = t.children[t.children.length - 1]))
    ;(!n ||
      !(n instanceof Qf) ||
      /\n$/.test(n.node.text) ||
      (this.view.requiresGeckoHackNode && /\s$/.test(n.node.text))) &&
      ((Pn || En) && n && n.dom.contentEditable == 'false' && this.addHackNode('IMG', t),
      this.addHackNode('BR', this.top))
  }
  addHackNode(n, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(n))
      this.index++
    else {
      let r = document.createElement(n)
      ;(n == 'IMG' && ((r.className = 'ProseMirror-separator'), (r.alt = '')),
        n == 'BR' && (r.className = 'ProseMirror-trailingBreak'))
      let i = new pS(this.top, [], r, null)
      ;(t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i),
        (this.changed = !0))
    }
  }
  isLocked(n) {
    return this.lock && (n == this.lock || (n.nodeType == 1 && n.contains(this.lock.parentNode)))
  }
}
function fV(e, n) {
  let t = n,
    r = t.children.length,
    i = e.childCount,
    s = new Map(),
    o = []
  t: for (; i > 0; ) {
    let a
    for (;;)
      if (r) {
        let c = t.children[r - 1]
        if (c instanceof zs) ((t = c), (r = c.children.length))
        else {
          ;((a = c), r--)
          break
        }
      } else {
        if (t == n) break t
        ;((r = t.parent.children.indexOf(t)), (t = t.parent))
      }
    let l = a.node
    if (l) {
      if (l != e.child(i - 1)) break
      ;(--i, s.set(a, i), o.push(a))
    }
  }
  return { index: i, matched: s, matches: o.reverse() }
}
function dV(e, n) {
  return e.type.side - n.type.side
}
function hV(e, n, t, r) {
  let i = n.locals(e),
    s = 0
  if (i.length == 0) {
    for (let c = 0; c < e.childCount; c++) {
      let u = e.child(c)
      ;(r(u, i, n.forChild(s, u), c), (s += u.nodeSize))
    }
    return
  }
  let o = 0,
    a = [],
    l = null
  for (let c = 0; ; ) {
    let u, f
    for (; o < i.length && i[o].to == s; ) {
      let m = i[o++]
      m.widget && (u ? (f || (f = [u])).push(m) : (u = m))
    }
    if (u)
      if (f) {
        f.sort(dV)
        for (let m = 0; m < f.length; m++) t(f[m], c, !!l)
      } else t(u, c, !!l)
    let d, h
    if (l) ((h = -1), (d = l), (l = null))
    else if (c < e.childCount) ((h = c), (d = e.child(c++)))
    else break
    for (let m = 0; m < a.length; m++) a[m].to <= s && a.splice(m--, 1)
    for (; o < i.length && i[o].from <= s && i[o].to > s; ) a.push(i[o++])
    let p = s + d.nodeSize
    if (d.isText) {
      let m = p
      o < i.length && i[o].from < m && (m = i[o].from)
      for (let y = 0; y < a.length; y++) a[y].to < m && (m = a[y].to)
      m < p && ((l = d.cut(m - s)), (d = d.cut(0, m - s)), (p = m), (h = -1))
    } else for (; o < i.length && i[o].to < p; ) o++
    let g = d.isInline && !d.isLeaf ? a.filter((m) => !m.inline) : a.slice()
    ;(r(d, g, n.forChild(s, d), h), (s = p))
  }
}
function pV(e) {
  if (e.nodeName == 'UL' || e.nodeName == 'OL') {
    let n = e.style.cssText
    ;((e.style.cssText = n + '; list-style: square !important'),
      window.getComputedStyle(e).listStyle,
      (e.style.cssText = n))
  }
}
function mV(e, n, t, r) {
  for (let i = 0, s = 0; i < e.childCount && s <= r; ) {
    let o = e.child(i++),
      a = s
    if (((s += o.nodeSize), !o.isText)) continue
    let l = o.text
    for (; i < e.childCount; ) {
      let c = e.child(i++)
      if (((s += c.nodeSize), !c.isText)) break
      l += c.text
    }
    if (s >= t) {
      if (s >= r && l.slice(r - n.length - a, r - a) == n) return r - n.length
      let c = a < r ? l.lastIndexOf(n, r - a - 1) : -1
      if (c >= 0 && c + n.length + a >= t) return a + c
      if (t == r && l.length >= r + n.length - a && l.slice(r - a, r - a + n.length) == n) return r
    }
  }
  return -1
}
function rm(e, n, t, r, i) {
  let s = []
  for (let o = 0, a = 0; o < e.length; o++) {
    let l = e[o],
      c = a,
      u = (a += l.size)
    c >= t || u <= n
      ? s.push(l)
      : (c < n && s.push(l.slice(0, n - c, r)),
        i && (s.push(i), (i = void 0)),
        u > t && s.push(l.slice(t - c, l.size, r)))
  }
  return s
}
function gg(e, n = null) {
  let t = e.domSelectionRange(),
    r = e.state.doc
  if (!t.focusNode) return null
  let i = e.docView.nearestDesc(t.focusNode),
    s = i && i.size == 0,
    o = e.docView.posFromDOM(t.focusNode, t.focusOffset, 1)
  if (o < 0) return null
  let a = r.resolve(o),
    l,
    c
  if (Jf(t)) {
    for (l = o; i && !i.node; ) i = i.parent
    let f = i.node
    if (
      i &&
      f.isAtom &&
      Zt.isSelectable(f) &&
      i.parent &&
      !(f.isInline && $$(t.focusNode, t.focusOffset, i.dom))
    ) {
      let d = i.posBefore
      c = new Zt(o == d ? a : r.resolve(d))
    }
  } else {
    if (t instanceof e.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let f = o,
        d = o
      for (let h = 0; h < t.rangeCount; h++) {
        let p = t.getRangeAt(h)
        ;((f = Math.min(f, e.docView.posFromDOM(p.startContainer, p.startOffset, 1))),
          (d = Math.max(d, e.docView.posFromDOM(p.endContainer, p.endOffset, -1))))
      }
      if (f < 0) return null
      ;(([l, o] = d == e.state.selection.anchor ? [d, f] : [f, d]), (a = r.resolve(o)))
    } else l = e.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1)
    if (l < 0) return null
  }
  let u = r.resolve(l)
  if (!c) {
    let f = n == 'pointer' || (e.state.selection.head < a.pos && !s) ? 1 : -1
    c = yg(e, u, a, f)
  }
  return c
}
function bS(e) {
  return e.editable
    ? e.hasFocus()
    : wS(e) && document.activeElement && document.activeElement.contains(e.dom)
}
function ti(e, n = !1) {
  let t = e.state.selection
  if ((vS(e, t), !!bS(e))) {
    if (!n && e.input.mouseDown && e.input.mouseDown.allowDefault && En) {
      let r = e.domSelectionRange(),
        i = e.domObserver.currentSelection
      if (
        r.anchorNode &&
        i.anchorNode &&
        Bs(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)
      ) {
        ;((e.input.mouseDown.delayedSelectionSync = !0), e.domObserver.setCurSelection())
        return
      }
    }
    if ((e.domObserver.disconnectSelection(), e.cursorWrapper)) yV(e)
    else {
      let { anchor: r, head: i } = t,
        s,
        o
      ;($v &&
        !(t instanceof oe) &&
        (t.$from.parent.inlineContent || (s = Vv(e, t.from)),
        !t.empty && !t.$from.parent.inlineContent && (o = Vv(e, t.to))),
        e.docView.setSelection(r, i, e, n),
        $v && (s && Hv(s), o && Hv(o)),
        t.visible
          ? e.dom.classList.remove('ProseMirror-hideselection')
          : (e.dom.classList.add('ProseMirror-hideselection'),
            'onselectionchange' in document && gV(e)))
    }
    ;(e.domObserver.setCurSelection(), e.domObserver.connectSelection())
  }
}
const $v = Pn || (En && oS < 63)
function Vv(e, n) {
  let { node: t, offset: r } = e.docView.domFromPos(n, 0),
    i = r < t.childNodes.length ? t.childNodes[r] : null,
    s = r ? t.childNodes[r - 1] : null
  if (Pn && i && i.contentEditable == 'false') return ph(i)
  if ((!i || i.contentEditable == 'false') && (!s || s.contentEditable == 'false')) {
    if (i) return ph(i)
    if (s) return ph(s)
  }
}
function ph(e) {
  return (
    (e.contentEditable = 'true'),
    Pn && e.draggable && ((e.draggable = !1), (e.wasDraggable = !0)),
    e
  )
}
function Hv(e) {
  ;((e.contentEditable = 'false'), e.wasDraggable && ((e.draggable = !0), (e.wasDraggable = null)))
}
function gV(e) {
  let n = e.dom.ownerDocument
  n.removeEventListener('selectionchange', e.input.hideSelectionGuard)
  let t = e.domSelectionRange(),
    r = t.anchorNode,
    i = t.anchorOffset
  n.addEventListener(
    'selectionchange',
    (e.input.hideSelectionGuard = () => {
      ;(t.anchorNode != r || t.anchorOffset != i) &&
        (n.removeEventListener('selectionchange', e.input.hideSelectionGuard),
        setTimeout(() => {
          ;(!bS(e) || e.state.selection.visible) &&
            e.dom.classList.remove('ProseMirror-hideselection')
        }, 20))
    }),
  )
}
function yV(e) {
  let n = e.domSelection()
  if (!n) return
  let t = e.cursorWrapper.dom,
    r = t.nodeName == 'IMG'
  ;(r ? n.collapse(t.parentNode, wn(t) + 1) : n.collapse(t, 0),
    !r && !e.state.selection.visible && Fn && Bi <= 11 && ((t.disabled = !0), (t.disabled = !1)))
}
function vS(e, n) {
  if (n instanceof Zt) {
    let t = e.docView.descAt(n.from)
    t != e.lastSelectedViewDesc && (Uv(e), t && t.selectNode(), (e.lastSelectedViewDesc = t))
  } else Uv(e)
}
function Uv(e) {
  e.lastSelectedViewDesc &&
    (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(),
    (e.lastSelectedViewDesc = void 0))
}
function yg(e, n, t, r) {
  return e.someProp('createSelectionBetween', (i) => i(e, n, t)) || oe.between(n, t, r)
}
function qv(e) {
  return e.editable && !e.hasFocus() ? !1 : wS(e)
}
function wS(e) {
  let n = e.domSelectionRange()
  if (!n.anchorNode) return !1
  try {
    return (
      e.dom.contains(n.anchorNode.nodeType == 3 ? n.anchorNode.parentNode : n.anchorNode) &&
      (e.editable ||
        e.dom.contains(n.focusNode.nodeType == 3 ? n.focusNode.parentNode : n.focusNode))
    )
  } catch {
    return !1
  }
}
function bV(e) {
  let n = e.docView.domFromPos(e.state.selection.anchor, 0),
    t = e.domSelectionRange()
  return Bs(n.node, n.offset, t.anchorNode, t.anchorOffset)
}
function im(e, n) {
  let { $anchor: t, $head: r } = e.selection,
    i = n > 0 ? t.max(r) : t.min(r),
    s = i.parent.inlineContent
      ? i.depth
        ? e.doc.resolve(n > 0 ? i.after() : i.before())
        : null
      : i
  return s && ye.findFrom(s, n)
}
function wi(e, n) {
  return (e.dispatch(e.state.tr.setSelection(n).scrollIntoView()), !0)
}
function Wv(e, n, t) {
  let r = e.state.selection
  if (r instanceof oe)
    if (t.indexOf('s') > -1) {
      let { $head: i } = r,
        s = i.textOffset ? null : n < 0 ? i.nodeBefore : i.nodeAfter
      if (!s || s.isText || !s.isLeaf) return !1
      let o = e.state.doc.resolve(i.pos + s.nodeSize * (n < 0 ? -1 : 1))
      return wi(e, new oe(r.$anchor, o))
    } else if (r.empty) {
      if (e.endOfTextblock(n > 0 ? 'forward' : 'backward')) {
        let i = im(e.state, n)
        return i && i instanceof Zt ? wi(e, i) : !1
      } else if (!(rr && t.indexOf('m') > -1)) {
        let i = r.$head,
          s = i.textOffset ? null : n < 0 ? i.nodeBefore : i.nodeAfter,
          o
        if (!s || s.isText) return !1
        let a = n < 0 ? i.pos - s.nodeSize : i.pos
        return s.isAtom || ((o = e.docView.descAt(a)) && !o.contentDOM)
          ? Zt.isSelectable(s)
            ? wi(e, new Zt(n < 0 ? e.state.doc.resolve(i.pos - s.nodeSize) : i))
            : Ll
              ? wi(e, new oe(e.state.doc.resolve(n < 0 ? a : a + s.nodeSize)))
              : !1
          : !1
      }
    } else return !1
  else {
    if (r instanceof Zt && r.node.isInline) return wi(e, new oe(n > 0 ? r.$to : r.$from))
    {
      let i = im(e.state, n)
      return i ? wi(e, i) : !1
    }
  }
}
function Du(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function $a(e, n) {
  let t = e.pmViewDesc
  return t && t.size == 0 && (n < 0 || e.nextSibling || e.nodeName != 'BR')
}
function no(e, n) {
  return n < 0 ? vV(e) : wV(e)
}
function vV(e) {
  let n = e.domSelectionRange(),
    t = n.focusNode,
    r = n.focusOffset
  if (!t) return
  let i,
    s,
    o = !1
  for (lr && t.nodeType == 1 && r < Du(t) && $a(t.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1) break
      {
        let a = t.childNodes[r - 1]
        if ($a(a, -1)) ((i = t), (s = --r))
        else if (a.nodeType == 3) ((t = a), (r = t.nodeValue.length))
        else break
      }
    } else {
      if (xS(t)) break
      {
        let a = t.previousSibling
        for (; a && $a(a, -1); ) ((i = t.parentNode), (s = wn(a)), (a = a.previousSibling))
        if (a) ((t = a), (r = Du(t)))
        else {
          if (((t = t.parentNode), t == e.dom)) break
          r = 0
        }
      }
    }
  o ? sm(e, t, r) : i && sm(e, i, s)
}
function wV(e) {
  let n = e.domSelectionRange(),
    t = n.focusNode,
    r = n.focusOffset
  if (!t) return
  let i = Du(t),
    s,
    o
  for (;;)
    if (r < i) {
      if (t.nodeType != 1) break
      let a = t.childNodes[r]
      if ($a(a, 1)) ((s = t), (o = ++r))
      else break
    } else {
      if (xS(t)) break
      {
        let a = t.nextSibling
        for (; a && $a(a, 1); ) ((s = a.parentNode), (o = wn(a) + 1), (a = a.nextSibling))
        if (a) ((t = a), (r = 0), (i = Du(t)))
        else {
          if (((t = t.parentNode), t == e.dom)) break
          r = i = 0
        }
      }
    }
  s && sm(e, s, o)
}
function xS(e) {
  let n = e.pmViewDesc
  return n && n.node && n.node.isBlock
}
function xV(e, n) {
  for (; e && n == e.childNodes.length && !jl(e); ) ((n = wn(e) + 1), (e = e.parentNode))
  for (; e && n < e.childNodes.length; ) {
    let t = e.childNodes[n]
    if (t.nodeType == 3) return t
    if (t.nodeType == 1 && t.contentEditable == 'false') break
    ;((e = t), (n = 0))
  }
}
function SV(e, n) {
  for (; e && !n && !jl(e); ) ((n = wn(e)), (e = e.parentNode))
  for (; e && n; ) {
    let t = e.childNodes[n - 1]
    if (t.nodeType == 3) return t
    if (t.nodeType == 1 && t.contentEditable == 'false') break
    ;((e = t), (n = e.childNodes.length))
  }
}
function sm(e, n, t) {
  if (n.nodeType != 3) {
    let s, o
    ;(o = xV(n, t)) ? ((n = o), (t = 0)) : (s = SV(n, t)) && ((n = s), (t = s.nodeValue.length))
  }
  let r = e.domSelection()
  if (!r) return
  if (Jf(r)) {
    let s = document.createRange()
    ;(s.setEnd(n, t), s.setStart(n, t), r.removeAllRanges(), r.addRange(s))
  } else r.extend && r.extend(n, t)
  e.domObserver.setCurSelection()
  let { state: i } = e
  setTimeout(() => {
    e.state == i && ti(e)
  }, 50)
}
function Kv(e, n) {
  let t = e.state.doc.resolve(n)
  if (!(En || U$) && t.parent.inlineContent) {
    let i = e.coordsAtPos(n)
    if (n > t.start()) {
      let s = e.coordsAtPos(n - 1),
        o = (s.top + s.bottom) / 2
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? 'ltr' : 'rtl'
    }
    if (n < t.end()) {
      let s = e.coordsAtPos(n + 1),
        o = (s.top + s.bottom) / 2
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? 'ltr' : 'rtl'
    }
  }
  return getComputedStyle(e.dom).direction == 'rtl' ? 'rtl' : 'ltr'
}
function Gv(e, n, t) {
  let r = e.state.selection
  if ((r instanceof oe && !r.empty) || t.indexOf('s') > -1 || (rr && t.indexOf('m') > -1)) return !1
  let { $from: i, $to: s } = r
  if (!i.parent.inlineContent || e.endOfTextblock(n < 0 ? 'up' : 'down')) {
    let o = im(e.state, n)
    if (o && o instanceof Zt) return wi(e, o)
  }
  if (!i.parent.inlineContent) {
    let o = n < 0 ? i : s,
      a = r instanceof qn ? ye.near(o, n) : ye.findFrom(o, n)
    return a ? wi(e, a) : !1
  }
  return !1
}
function Xv(e, n) {
  if (!(e.state.selection instanceof oe)) return !0
  let { $head: t, $anchor: r, empty: i } = e.state.selection
  if (!t.sameParent(r)) return !0
  if (!i) return !1
  if (e.endOfTextblock(n > 0 ? 'forward' : 'backward')) return !0
  let s = !t.textOffset && (n < 0 ? t.nodeBefore : t.nodeAfter)
  if (s && !s.isText) {
    let o = e.state.tr
    return (
      n < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize),
      e.dispatch(o),
      !0
    )
  }
  return !1
}
function Yv(e, n, t) {
  ;(e.domObserver.stop(), (n.contentEditable = t), e.domObserver.start())
}
function _V(e) {
  if (!Pn || e.state.selection.$head.parentOffset > 0) return !1
  let { focusNode: n, focusOffset: t } = e.domSelectionRange()
  if (n && n.nodeType == 1 && t == 0 && n.firstChild && n.firstChild.contentEditable == 'false') {
    let r = n.firstChild
    ;(Yv(e, r, 'true'), setTimeout(() => Yv(e, r, 'false'), 20))
  }
  return !1
}
function kV(e) {
  let n = ''
  return (
    e.ctrlKey && (n += 'c'),
    e.metaKey && (n += 'm'),
    e.altKey && (n += 'a'),
    e.shiftKey && (n += 's'),
    n
  )
}
function CV(e, n) {
  let t = n.keyCode,
    r = kV(n)
  if (t == 8 || (rr && t == 72 && r == 'c')) return Xv(e, -1) || no(e, -1)
  if ((t == 46 && !n.shiftKey) || (rr && t == 68 && r == 'c')) return Xv(e, 1) || no(e, 1)
  if (t == 13 || t == 27) return !0
  if (t == 37 || (rr && t == 66 && r == 'c')) {
    let i = t == 37 ? (Kv(e, e.state.selection.from) == 'ltr' ? -1 : 1) : -1
    return Wv(e, i, r) || no(e, i)
  } else if (t == 39 || (rr && t == 70 && r == 'c')) {
    let i = t == 39 ? (Kv(e, e.state.selection.from) == 'ltr' ? 1 : -1) : 1
    return Wv(e, i, r) || no(e, i)
  } else {
    if (t == 38 || (rr && t == 80 && r == 'c')) return Gv(e, -1, r) || no(e, -1)
    if (t == 40 || (rr && t == 78 && r == 'c')) return _V(e) || Gv(e, 1, r) || no(e, 1)
    if (r == (rr ? 'm' : 'c') && (t == 66 || t == 73 || t == 89 || t == 90)) return !0
  }
  return !1
}
function bg(e, n) {
  e.someProp('transformCopied', (h) => {
    n = h(n, e)
  })
  let t = [],
    { content: r, openStart: i, openEnd: s } = n
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    ;(i--, s--)
    let h = r.firstChild
    ;(t.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), (r = h.content))
  }
  let o = e.someProp('clipboardSerializer') || Hs.fromSchema(e.state.schema),
    a = ES(),
    l = a.createElement('div')
  l.appendChild(o.serializeFragment(r, { document: a }))
  let c = l.firstChild,
    u,
    f = 0
  for (; c && c.nodeType == 1 && (u = MS[c.nodeName.toLowerCase()]); ) {
    for (let h = u.length - 1; h >= 0; h--) {
      let p = a.createElement(u[h])
      for (; l.firstChild; ) p.appendChild(l.firstChild)
      ;(l.appendChild(p), f++)
    }
    c = l.firstChild
  }
  c &&
    c.nodeType == 1 &&
    c.setAttribute('data-pm-slice', `${i} ${s}${f ? ` -${f}` : ''} ${JSON.stringify(t)}`)
  let d =
    e.someProp('clipboardTextSerializer', (h) => h(n, e)) ||
    n.content.textBetween(
      0,
      n.content.size,
      `

`,
    )
  return { dom: l, text: d, slice: n }
}
function SS(e, n, t, r, i) {
  let s = i.parent.type.spec.code,
    o,
    a
  if (!t && !n) return null
  let l = !!n && (r || s || !t)
  if (l) {
    if (
      (e.someProp('transformPastedText', (d) => {
        n = d(n, s || r, e)
      }),
      s)
    )
      return (
        (a = new jt(
          St.from(
            e.state.schema.text(
              n.replace(
                /\r\n?/g,
                `
`,
              ),
            ),
          ),
          0,
          0,
        )),
        e.someProp('transformPasted', (d) => {
          a = d(a, e, !0)
        }),
        a
      )
    let f = e.someProp('clipboardTextParser', (d) => d(n, i, r, e))
    if (f) a = f
    else {
      let d = i.marks(),
        { schema: h } = e.state,
        p = Hs.fromSchema(h)
      ;((o = document.createElement('div')),
        n.split(/(?:\r\n?|\n)+/).forEach((g) => {
          let m = o.appendChild(document.createElement('p'))
          g && m.appendChild(p.serializeNode(h.text(g, d)))
        }))
    }
  } else
    (e.someProp('transformPastedHTML', (f) => {
      t = f(t, e)
    }),
      (o = AV(t)),
      Ll && RV(o))
  let c = o && o.querySelector('[data-pm-slice]'),
    u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute('data-pm-slice') || '')
  if (u && u[3])
    for (let f = +u[3]; f > 0; f--) {
      let d = o.firstChild
      for (; d && d.nodeType != 1; ) d = d.nextSibling
      if (!d) break
      o = d
    }
  if (
    (a ||
      (a = (
        e.someProp('clipboardParser') ||
        e.someProp('domParser') ||
        Fi.fromSchema(e.state.schema)
      ).parseSlice(o, {
        preserveWhitespace: !!(l || u),
        context: i,
        ruleFromNode(d) {
          return d.nodeName == 'BR' &&
            !d.nextSibling &&
            d.parentNode &&
            !MV.test(d.parentNode.nodeName)
            ? { ignore: !0 }
            : null
        },
      })),
    u)
  )
    a = OV(Zv(a, +u[1], +u[2]), u[4])
  else if (((a = jt.maxOpen(EV(a.content, i), !0)), a.openStart || a.openEnd)) {
    let f = 0,
      d = 0
    for (
      let h = a.content.firstChild;
      f < a.openStart && !h.type.spec.isolating;
      f++, h = h.firstChild
    );
    for (
      let h = a.content.lastChild;
      d < a.openEnd && !h.type.spec.isolating;
      d++, h = h.lastChild
    );
    a = Zv(a, f, d)
  }
  return (
    e.someProp('transformPasted', (f) => {
      a = f(a, e, l)
    }),
    a
  )
}
const MV =
  /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i
function EV(e, n) {
  if (e.childCount < 2) return e
  for (let t = n.depth; t >= 0; t--) {
    let i = n.node(t).contentMatchAt(n.index(t)),
      s,
      o = []
    if (
      (e.forEach((a) => {
        if (!o) return
        let l = i.findWrapping(a.type),
          c
        if (!l) return (o = null)
        if ((c = o.length && s.length && kS(l, s, a, o[o.length - 1], 0))) o[o.length - 1] = c
        else {
          o.length && (o[o.length - 1] = CS(o[o.length - 1], s.length))
          let u = _S(a, l)
          ;(o.push(u), (i = i.matchType(u.type)), (s = l))
        }
      }),
      o)
    )
      return St.from(o)
  }
  return e
}
function _S(e, n, t = 0) {
  for (let r = n.length - 1; r >= t; r--) e = n[r].create(null, St.from(e))
  return e
}
function kS(e, n, t, r, i) {
  if (i < e.length && i < n.length && e[i] == n[i]) {
    let s = kS(e, n, t, r.lastChild, i + 1)
    if (s) return r.copy(r.content.replaceChild(r.childCount - 1, s))
    if (r.contentMatchAt(r.childCount).matchType(i == e.length - 1 ? t.type : e[i + 1]))
      return r.copy(r.content.append(St.from(_S(t, e, i + 1))))
  }
}
function CS(e, n) {
  if (n == 0) return e
  let t = e.content.replaceChild(e.childCount - 1, CS(e.lastChild, n - 1)),
    r = e.contentMatchAt(e.childCount).fillBefore(St.empty, !0)
  return e.copy(t.append(r))
}
function om(e, n, t, r, i, s) {
  let o = n < 0 ? e.firstChild : e.lastChild,
    a = o.content
  return (
    e.childCount > 1 && (s = 0),
    i < r - 1 && (a = om(a, n, t, r, i + 1, s)),
    i >= t &&
      (a =
        n < 0
          ? o
              .contentMatchAt(0)
              .fillBefore(a, s <= i)
              .append(a)
          : a.append(o.contentMatchAt(o.childCount).fillBefore(St.empty, !0))),
    e.replaceChild(n < 0 ? 0 : e.childCount - 1, o.copy(a))
  )
}
function Zv(e, n, t) {
  return (
    n < e.openStart && (e = new jt(om(e.content, -1, n, e.openStart, 0, e.openEnd), n, e.openEnd)),
    t < e.openEnd && (e = new jt(om(e.content, 1, t, e.openEnd, 0, 0), e.openStart, t)),
    e
  )
}
const MS = {
  thead: ['table'],
  tbody: ['table'],
  tfoot: ['table'],
  caption: ['table'],
  colgroup: ['table'],
  col: ['table', 'colgroup'],
  tr: ['table', 'tbody'],
  td: ['table', 'tbody', 'tr'],
  th: ['table', 'tbody', 'tr'],
}
let Jv = null
function ES() {
  return Jv || (Jv = document.implementation.createHTMLDocument('title'))
}
let mh = null
function TV(e) {
  let n = window.trustedTypes
  return n
    ? (mh ||
        (mh = n.defaultPolicy || n.createPolicy('ProseMirrorClipboard', { createHTML: (t) => t })),
      mh.createHTML(e))
    : e
}
function AV(e) {
  let n = /^(\s*<meta [^>]*>)*/.exec(e)
  n && (e = e.slice(n[0].length))
  let t = ES().createElement('div'),
    r = /<([a-z][^>\s]+)/i.exec(e),
    i
  if (
    ((i = r && MS[r[1].toLowerCase()]) &&
      (e =
        i.map((s) => '<' + s + '>').join('') +
        e +
        i
          .map((s) => '</' + s + '>')
          .reverse()
          .join('')),
    (t.innerHTML = TV(e)),
    i)
  )
    for (let s = 0; s < i.length; s++) t = t.querySelector(i[s]) || t
  return t
}
function RV(e) {
  let n = e.querySelectorAll(En ? 'span:not([class]):not([style])' : 'span.Apple-converted-space')
  for (let t = 0; t < n.length; t++) {
    let r = n[t]
    r.childNodes.length == 1 &&
      r.textContent == '' &&
      r.parentNode &&
      r.parentNode.replaceChild(e.ownerDocument.createTextNode(' '), r)
  }
}
function OV(e, n) {
  if (!e.size) return e
  let t = e.content.firstChild.type.schema,
    r
  try {
    r = JSON.parse(n)
  } catch {
    return e
  }
  let { content: i, openStart: s, openEnd: o } = e
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = t.nodes[r[a]]
    if (!l || l.hasRequiredAttrs()) break
    ;((i = St.from(l.create(r[a + 1], i))), s++, o++)
  }
  return new jt(i, s, o)
}
const Nn = {},
  In = {},
  PV = { touchstart: !0, touchmove: !0 }
class NV {
  constructor() {
    ;((this.shiftKey = !1),
      (this.mouseDown = null),
      (this.lastKeyCode = null),
      (this.lastKeyCodeTime = 0),
      (this.lastClick = { time: 0, x: 0, y: 0, type: '', button: 0 }),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastIOSEnter = 0),
      (this.lastIOSEnterFallbackTimeout = -1),
      (this.lastFocus = 0),
      (this.lastTouch = 0),
      (this.lastChromeDelete = 0),
      (this.composing = !1),
      (this.compositionNode = null),
      (this.composingTimeout = -1),
      (this.compositionNodes = []),
      (this.compositionEndedAt = -2e8),
      (this.compositionID = 1),
      (this.compositionPendingChanges = 0),
      (this.domChangeCount = 0),
      (this.eventHandlers = Object.create(null)),
      (this.hideSelectionGuard = null))
  }
}
function IV(e) {
  for (let n in Nn) {
    let t = Nn[n]
    e.dom.addEventListener(
      n,
      (e.input.eventHandlers[n] = (r) => {
        jV(e, r) && !vg(e, r) && (e.editable || !(r.type in In)) && t(e, r)
      }),
      PV[n] ? { passive: !0 } : void 0,
    )
  }
  ;(Pn && e.dom.addEventListener('input', () => null), am(e))
}
function Pi(e, n) {
  ;((e.input.lastSelectionOrigin = n), (e.input.lastSelectionTime = Date.now()))
}
function DV(e) {
  e.domObserver.stop()
  for (let n in e.input.eventHandlers) e.dom.removeEventListener(n, e.input.eventHandlers[n])
  ;(clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout))
}
function am(e) {
  e.someProp('handleDOMEvents', (n) => {
    for (let t in n)
      e.input.eventHandlers[t] ||
        e.dom.addEventListener(t, (e.input.eventHandlers[t] = (r) => vg(e, r)))
  })
}
function vg(e, n) {
  return e.someProp('handleDOMEvents', (t) => {
    let r = t[n.type]
    return r ? r(e, n) || n.defaultPrevented : !1
  })
}
function jV(e, n) {
  if (!n.bubbles) return !0
  if (n.defaultPrevented) return !1
  for (let t = n.target; t != e.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || (t.pmViewDesc && t.pmViewDesc.stopEvent(n))) return !1
  return !0
}
function LV(e, n) {
  !vg(e, n) && Nn[n.type] && (e.editable || !(n.type in In)) && Nn[n.type](e, n)
}
In.keydown = (e, n) => {
  let t = n
  if (
    ((e.input.shiftKey = t.keyCode == 16 || t.shiftKey),
    !AS(e, t) &&
      ((e.input.lastKeyCode = t.keyCode),
      (e.input.lastKeyCodeTime = Date.now()),
      !(Yr && En && t.keyCode == 13)))
  )
    if (
      (t.keyCode != 229 && e.domObserver.forceFlush(),
      Vo && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey)
    ) {
      let r = Date.now()
      ;((e.input.lastIOSEnter = r),
        (e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          e.input.lastIOSEnter == r &&
            (e.someProp('handleKeyDown', (i) => i(e, as(13, 'Enter'))), (e.input.lastIOSEnter = 0))
        }, 200)))
    } else
      e.someProp('handleKeyDown', (r) => r(e, t)) || CV(e, t) ? t.preventDefault() : Pi(e, 'key')
}
In.keyup = (e, n) => {
  n.keyCode == 16 && (e.input.shiftKey = !1)
}
In.keypress = (e, n) => {
  let t = n
  if (AS(e, t) || !t.charCode || (t.ctrlKey && !t.altKey) || (rr && t.metaKey)) return
  if (e.someProp('handleKeyPress', (i) => i(e, t))) {
    t.preventDefault()
    return
  }
  let r = e.state.selection
  if (!(r instanceof oe) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode),
      s = () => e.state.tr.insertText(i).scrollIntoView()
    ;(!/[\r\n]/.test(i) &&
      !e.someProp('handleTextInput', (o) => o(e, r.$from.pos, r.$to.pos, i, s)) &&
      e.dispatch(s()),
      t.preventDefault())
  }
}
function td(e) {
  return { left: e.clientX, top: e.clientY }
}
function FV(e, n) {
  let t = n.x - e.clientX,
    r = n.y - e.clientY
  return t * t + r * r < 100
}
function wg(e, n, t, r, i) {
  if (r == -1) return !1
  let s = e.state.doc.resolve(r)
  for (let o = s.depth + 1; o > 0; o--)
    if (
      e.someProp(n, (a) =>
        o > s.depth
          ? a(e, t, s.nodeAfter, s.before(o), i, !0)
          : a(e, t, s.node(o), s.before(o), i, !1),
      )
    )
      return !0
  return !1
}
function Mo(e, n, t) {
  if ((e.focused || e.focus(), e.state.selection.eq(n))) return
  let r = e.state.tr.setSelection(n)
  ;(r.setMeta('pointer', !0), e.dispatch(r))
}
function BV(e, n) {
  if (n == -1) return !1
  let t = e.state.doc.resolve(n),
    r = t.nodeAfter
  return r && r.isAtom && Zt.isSelectable(r) ? (Mo(e, new Zt(t)), !0) : !1
}
function zV(e, n) {
  if (n == -1) return !1
  let t = e.state.selection,
    r,
    i
  t instanceof Zt && (r = t.node)
  let s = e.state.doc.resolve(n)
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o)
    if (Zt.isSelectable(a)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos
        ? (i = s.before(t.$from.depth))
        : (i = s.before(o))
      break
    }
  }
  return i != null ? (Mo(e, Zt.create(e.state.doc, i)), !0) : !1
}
function $V(e, n, t, r, i) {
  return (
    wg(e, 'handleClickOn', n, t, r) ||
    e.someProp('handleClick', (s) => s(e, n, r)) ||
    (i ? zV(e, t) : BV(e, t))
  )
}
function VV(e, n, t, r) {
  return wg(e, 'handleDoubleClickOn', n, t, r) || e.someProp('handleDoubleClick', (i) => i(e, n, r))
}
function HV(e, n, t, r) {
  return (
    wg(e, 'handleTripleClickOn', n, t, r) ||
    e.someProp('handleTripleClick', (i) => i(e, n, r)) ||
    UV(e, t, r)
  )
}
function UV(e, n, t) {
  if (t.button != 0) return !1
  let r = e.state.doc
  if (n == -1) return r.inlineContent ? (Mo(e, oe.create(r, 0, r.content.size)), !0) : !1
  let i = r.resolve(n)
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s),
      a = i.before(s)
    if (o.inlineContent) Mo(e, oe.create(r, a + 1, a + 1 + o.content.size))
    else if (Zt.isSelectable(o)) Mo(e, Zt.create(r, a))
    else continue
    return !0
  }
}
function xg(e) {
  return ju(e)
}
const TS = rr ? 'metaKey' : 'ctrlKey'
Nn.mousedown = (e, n) => {
  let t = n
  e.input.shiftKey = t.shiftKey
  let r = xg(e),
    i = Date.now(),
    s = 'singleClick'
  ;(i - e.input.lastClick.time < 500 &&
    FV(t, e.input.lastClick) &&
    !t[TS] &&
    e.input.lastClick.button == t.button &&
    (e.input.lastClick.type == 'singleClick'
      ? (s = 'doubleClick')
      : e.input.lastClick.type == 'doubleClick' && (s = 'tripleClick')),
    (e.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button }))
  let o = e.posAtCoords(td(t))
  o &&
    (s == 'singleClick'
      ? (e.input.mouseDown && e.input.mouseDown.done(), (e.input.mouseDown = new qV(e, o, t, !!r)))
      : (s == 'doubleClick' ? VV : HV)(e, o.pos, o.inside, t)
        ? t.preventDefault()
        : Pi(e, 'pointer'))
}
class qV {
  constructor(n, t, r, i) {
    ;((this.view = n),
      (this.pos = t),
      (this.event = r),
      (this.flushed = i),
      (this.delayedSelectionSync = !1),
      (this.mightDrag = null),
      (this.startDoc = n.state.doc),
      (this.selectNode = !!r[TS]),
      (this.allowDefault = r.shiftKey))
    let s, o
    if (t.inside > -1) ((s = n.state.doc.nodeAt(t.inside)), (o = t.inside))
    else {
      let u = n.state.doc.resolve(t.pos)
      ;((s = u.parent), (o = u.depth ? u.before() : 0))
    }
    const a = i ? null : r.target,
      l = a ? n.docView.nearestDesc(a, !0) : null
    this.target = l && l.nodeDOM.nodeType == 1 ? l.nodeDOM : null
    let { selection: c } = n.state
    ;(((r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1) ||
      (c instanceof Zt && c.from <= o && c.to > o)) &&
      (this.mightDrag = {
        node: s,
        pos: o,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && lr && !this.target.hasAttribute('contentEditable')),
      }),
      this.target &&
        this.mightDrag &&
        (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable &&
          setTimeout(() => {
            this.view.input.mouseDown == this &&
              this.target.setAttribute('contentEditable', 'false')
          }, 20),
        this.view.domObserver.start()),
      n.root.addEventListener('mouseup', (this.up = this.up.bind(this))),
      n.root.addEventListener('mousemove', (this.move = this.move.bind(this))),
      Pi(n, 'pointer'))
  }
  done() {
    ;(this.view.root.removeEventListener('mouseup', this.up),
      this.view.root.removeEventListener('mousemove', this.move),
      this.mightDrag &&
        this.target &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute('draggable'),
        this.mightDrag.setUneditable && this.target.removeAttribute('contentEditable'),
        this.view.domObserver.start()),
      this.delayedSelectionSync && setTimeout(() => ti(this.view)),
      (this.view.input.mouseDown = null))
  }
  up(n) {
    if ((this.done(), !this.view.dom.contains(n.target))) return
    let t = this.pos
    ;(this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(td(n))),
      this.updateAllowDefault(n),
      this.allowDefault || !t
        ? Pi(this.view, 'pointer')
        : $V(this.view, t.pos, t.inside, n, this.selectNode)
          ? n.preventDefault()
          : n.button == 0 &&
              (this.flushed ||
                (Pn && this.mightDrag && !this.mightDrag.node.isAtom) ||
                (En &&
                  !this.view.state.selection.visible &&
                  Math.min(
                    Math.abs(t.pos - this.view.state.selection.from),
                    Math.abs(t.pos - this.view.state.selection.to),
                  ) <= 2))
            ? (Mo(this.view, ye.near(this.view.state.doc.resolve(t.pos))), n.preventDefault())
            : Pi(this.view, 'pointer'))
  }
  move(n) {
    ;(this.updateAllowDefault(n), Pi(this.view, 'pointer'), n.buttons == 0 && this.done())
  }
  updateAllowDefault(n) {
    !this.allowDefault &&
      (Math.abs(this.event.x - n.clientX) > 4 || Math.abs(this.event.y - n.clientY) > 4) &&
      (this.allowDefault = !0)
  }
}
Nn.touchstart = (e) => {
  ;((e.input.lastTouch = Date.now()), xg(e), Pi(e, 'pointer'))
}
Nn.touchmove = (e) => {
  ;((e.input.lastTouch = Date.now()), Pi(e, 'pointer'))
}
Nn.contextmenu = (e) => xg(e)
function AS(e, n) {
  return e.composing
    ? !0
    : Pn && Math.abs(n.timeStamp - e.input.compositionEndedAt) < 500
      ? ((e.input.compositionEndedAt = -2e8), !0)
      : !1
}
const WV = Yr ? 5e3 : -1
In.compositionstart = In.compositionupdate = (e) => {
  if (!e.composing) {
    e.domObserver.flush()
    let { state: n } = e,
      t = n.selection.$to
    if (
      n.selection instanceof oe &&
      (n.storedMarks ||
        (!t.textOffset &&
          t.parentOffset &&
          t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
    )
      ((e.markCursor = e.state.storedMarks || t.marks()), ju(e, !0), (e.markCursor = null))
    else if (
      (ju(e, !n.selection.empty),
      lr && n.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length)
    ) {
      let r = e.domSelectionRange()
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1]
        if (!o) break
        if (o.nodeType == 3) {
          let a = e.domSelection()
          a && a.collapse(o, o.nodeValue.length)
          break
        } else ((i = o), (s = -1))
      }
    }
    e.input.composing = !0
  }
  RS(e, WV)
}
In.compositionend = (e, n) => {
  e.composing &&
    ((e.input.composing = !1),
    (e.input.compositionEndedAt = n.timeStamp),
    (e.input.compositionPendingChanges = e.domObserver.pendingRecords().length
      ? e.input.compositionID
      : 0),
    (e.input.compositionNode = null),
    e.input.compositionPendingChanges && Promise.resolve().then(() => e.domObserver.flush()),
    e.input.compositionID++,
    RS(e, 20))
}
function RS(e, n) {
  ;(clearTimeout(e.input.composingTimeout),
    n > -1 && (e.input.composingTimeout = setTimeout(() => ju(e), n)))
}
function OS(e) {
  for (
    e.composing && ((e.input.composing = !1), (e.input.compositionEndedAt = GV()));
    e.input.compositionNodes.length > 0;

  )
    e.input.compositionNodes.pop().markParentsDirty()
}
function KV(e) {
  let n = e.domSelectionRange()
  if (!n.focusNode) return null
  let t = B$(n.focusNode, n.focusOffset),
    r = z$(n.focusNode, n.focusOffset)
  if (t && r && t != r) {
    let i = r.pmViewDesc,
      s = e.domObserver.lastChangedTextNode
    if (t == s || r == s) return s
    if (!i || !i.isText(r.nodeValue)) return r
    if (e.input.compositionNode == r) {
      let o = t.pmViewDesc
      if (!(!o || !o.isText(t.nodeValue))) return r
    }
  }
  return t || r
}
function GV() {
  let e = document.createEvent('Event')
  return (e.initEvent('event', !0, !0), e.timeStamp)
}
function ju(e, n = !1) {
  if (!(Yr && e.domObserver.flushingSoon >= 0)) {
    if ((e.domObserver.forceFlush(), OS(e), n || (e.docView && e.docView.dirty))) {
      let t = gg(e),
        r = e.state.selection
      return (
        t && !t.eq(r)
          ? e.dispatch(e.state.tr.setSelection(t))
          : (e.markCursor || n) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent
            ? e.dispatch(e.state.tr.deleteSelection())
            : e.updateState(e.state),
        !0
      )
    }
    return !1
  }
}
function XV(e, n) {
  if (!e.dom.parentNode) return
  let t = e.dom.parentNode.appendChild(document.createElement('div'))
  ;(t.appendChild(n), (t.style.cssText = 'position: fixed; left: -10000px; top: 10px'))
  let r = getSelection(),
    i = document.createRange()
  ;(i.selectNodeContents(n),
    e.dom.blur(),
    r.removeAllRanges(),
    r.addRange(i),
    setTimeout(() => {
      ;(t.parentNode && t.parentNode.removeChild(t), e.focus())
    }, 50))
}
const yl = (Fn && Bi < 15) || (Vo && q$ < 604)
Nn.copy = In.cut = (e, n) => {
  let t = n,
    r = e.state.selection,
    i = t.type == 'cut'
  if (r.empty) return
  let s = yl ? null : t.clipboardData,
    o = r.content(),
    { dom: a, text: l } = bg(e, o)
  ;(s
    ? (t.preventDefault(),
      s.clearData(),
      s.setData('text/html', a.innerHTML),
      s.setData('text/plain', l))
    : XV(e, a),
    i && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta('uiEvent', 'cut')))
}
function YV(e) {
  return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1
    ? e.content.firstChild
    : null
}
function ZV(e, n) {
  if (!e.dom.parentNode) return
  let t = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code,
    r = e.dom.parentNode.appendChild(document.createElement(t ? 'textarea' : 'div'))
  ;(t || (r.contentEditable = 'true'),
    (r.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    r.focus())
  let i = e.input.shiftKey && e.input.lastKeyCode != 45
  setTimeout(() => {
    ;(e.focus(),
      r.parentNode && r.parentNode.removeChild(r),
      t ? bl(e, r.value, null, i, n) : bl(e, r.textContent, r.innerHTML, i, n))
  }, 50)
}
function bl(e, n, t, r, i) {
  let s = SS(e, n, t, r, e.state.selection.$from)
  if (e.someProp('handlePaste', (l) => l(e, i, s || jt.empty))) return !0
  if (!s) return !1
  let o = YV(s),
    a = o ? e.state.tr.replaceSelectionWith(o, r) : e.state.tr.replaceSelection(s)
  return (e.dispatch(a.scrollIntoView().setMeta('paste', !0).setMeta('uiEvent', 'paste')), !0)
}
function PS(e) {
  let n = e.getData('text/plain') || e.getData('Text')
  if (n) return n
  let t = e.getData('text/uri-list')
  return t ? t.replace(/\r?\n/g, ' ') : ''
}
In.paste = (e, n) => {
  let t = n
  if (e.composing && !Yr) return
  let r = yl ? null : t.clipboardData,
    i = e.input.shiftKey && e.input.lastKeyCode != 45
  r && bl(e, PS(r), r.getData('text/html'), i, t) ? t.preventDefault() : ZV(e, t)
}
class NS {
  constructor(n, t, r) {
    ;((this.slice = n), (this.move = t), (this.node = r))
  }
}
const JV = rr ? 'altKey' : 'ctrlKey'
function IS(e, n) {
  let t = e.someProp('dragCopies', (r) => !r(n))
  return t ?? !n[JV]
}
Nn.dragstart = (e, n) => {
  let t = n,
    r = e.input.mouseDown
  if ((r && r.done(), !t.dataTransfer)) return
  let i = e.state.selection,
    s = i.empty ? null : e.posAtCoords(td(t)),
    o
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof Zt ? i.to - 1 : i.to))) {
    if (r && r.mightDrag) o = Zt.create(e.state.doc, r.mightDrag.pos)
    else if (t.target && t.target.nodeType == 1) {
      let f = e.docView.nearestDesc(t.target, !0)
      f && f.node.type.spec.draggable && f != e.docView && (o = Zt.create(e.state.doc, f.posBefore))
    }
  }
  let a = (o || e.state.selection).content(),
    { dom: l, text: c, slice: u } = bg(e, a)
  ;((!t.dataTransfer.files.length || !En || oS > 120) && t.dataTransfer.clearData(),
    t.dataTransfer.setData(yl ? 'Text' : 'text/html', l.innerHTML),
    (t.dataTransfer.effectAllowed = 'copyMove'),
    yl || t.dataTransfer.setData('text/plain', c),
    (e.dragging = new NS(u, IS(e, t), o)))
}
Nn.dragend = (e) => {
  let n = e.dragging
  window.setTimeout(() => {
    e.dragging == n && (e.dragging = null)
  }, 50)
}
In.dragover = In.dragenter = (e, n) => n.preventDefault()
In.drop = (e, n) => {
  let t = n,
    r = e.dragging
  if (((e.dragging = null), !t.dataTransfer)) return
  let i = e.posAtCoords(td(t))
  if (!i) return
  let s = e.state.doc.resolve(i.pos),
    o = r && r.slice
  o
    ? e.someProp('transformPasted', (p) => {
        o = p(o, e, !1)
      })
    : (o = SS(e, PS(t.dataTransfer), yl ? null : t.dataTransfer.getData('text/html'), !1, s))
  let a = !!(r && IS(e, t))
  if (e.someProp('handleDrop', (p) => p(e, t, o || jt.empty, a))) {
    t.preventDefault()
    return
  }
  if (!o) return
  t.preventDefault()
  let l = o ? B5(e.state.doc, s.pos, o) : s.pos
  l == null && (l = s.pos)
  let c = e.state.tr
  if (a) {
    let { node: p } = r
    p ? p.replace(c) : c.deleteSelection()
  }
  let u = c.mapping.map(l),
    f = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1,
    d = c.doc
  if ((f ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(d)))
    return
  let h = c.doc.resolve(u)
  if (
    f &&
    Zt.isSelectable(o.content.firstChild) &&
    h.nodeAfter &&
    h.nodeAfter.sameMarkup(o.content.firstChild)
  )
    c.setSelection(new Zt(h))
  else {
    let p = c.mapping.map(l)
    ;(c.mapping.maps[c.mapping.maps.length - 1].forEach((g, m, y, b) => (p = b)),
      c.setSelection(yg(e, h, c.doc.resolve(p))))
  }
  ;(e.focus(), e.dispatch(c.setMeta('uiEvent', 'drop')))
}
Nn.focus = (e) => {
  ;((e.input.lastFocus = Date.now()),
    e.focused ||
      (e.domObserver.stop(),
      e.dom.classList.add('ProseMirror-focused'),
      e.domObserver.start(),
      (e.focused = !0),
      setTimeout(() => {
        e.docView &&
          e.hasFocus() &&
          !e.domObserver.currentSelection.eq(e.domSelectionRange()) &&
          ti(e)
      }, 20)))
}
Nn.blur = (e, n) => {
  let t = n
  e.focused &&
    (e.domObserver.stop(),
    e.dom.classList.remove('ProseMirror-focused'),
    e.domObserver.start(),
    t.relatedTarget && e.dom.contains(t.relatedTarget) && e.domObserver.currentSelection.clear(),
    (e.focused = !1))
}
Nn.beforeinput = (e, n) => {
  if (En && Yr && n.inputType == 'deleteContentBackward') {
    e.domObserver.flushSoon()
    let { domChangeCount: r } = e.input
    setTimeout(() => {
      if (
        e.input.domChangeCount != r ||
        (e.dom.blur(), e.focus(), e.someProp('handleKeyDown', (s) => s(e, as(8, 'Backspace'))))
      )
        return
      let { $cursor: i } = e.state.selection
      i && i.pos > 0 && e.dispatch(e.state.tr.delete(i.pos - 1, i.pos).scrollIntoView())
    }, 50)
  }
}
for (let e in In) Nn[e] = In[e]
function vl(e, n) {
  if (e == n) return !0
  for (let t in e) if (e[t] !== n[t]) return !1
  for (let t in n) if (!(t in e)) return !1
  return !0
}
class Lu {
  constructor(n, t) {
    ;((this.toDOM = n), (this.spec = t || Ms), (this.side = this.spec.side || 0))
  }
  map(n, t, r, i) {
    let { pos: s, deleted: o } = n.mapResult(t.from + i, this.side < 0 ? -1 : 1)
    return o ? null : new On(s - r, s - r, this)
  }
  valid() {
    return !0
  }
  eq(n) {
    return (
      this == n ||
      (n instanceof Lu &&
        ((this.spec.key && this.spec.key == n.spec.key) ||
          (this.toDOM == n.toDOM && vl(this.spec, n.spec))))
    )
  }
  destroy(n) {
    this.spec.destroy && this.spec.destroy(n)
  }
}
class $i {
  constructor(n, t) {
    ;((this.attrs = n), (this.spec = t || Ms))
  }
  map(n, t, r, i) {
    let s = n.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r,
      o = n.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r
    return s >= o ? null : new On(s, o, this)
  }
  valid(n, t) {
    return t.from < t.to
  }
  eq(n) {
    return this == n || (n instanceof $i && vl(this.attrs, n.attrs) && vl(this.spec, n.spec))
  }
  static is(n) {
    return n.type instanceof $i
  }
  destroy() {}
}
class Sg {
  constructor(n, t) {
    ;((this.attrs = n), (this.spec = t || Ms))
  }
  map(n, t, r, i) {
    let s = n.mapResult(t.from + i, 1)
    if (s.deleted) return null
    let o = n.mapResult(t.to + i, -1)
    return o.deleted || o.pos <= s.pos ? null : new On(s.pos - r, o.pos - r, this)
  }
  valid(n, t) {
    let { index: r, offset: i } = n.content.findIndex(t.from),
      s
    return i == t.from && !(s = n.child(r)).isText && i + s.nodeSize == t.to
  }
  eq(n) {
    return this == n || (n instanceof Sg && vl(this.attrs, n.attrs) && vl(this.spec, n.spec))
  }
  destroy() {}
}
class On {
  constructor(n, t, r) {
    ;((this.from = n), (this.to = t), (this.type = r))
  }
  copy(n, t) {
    return new On(n, t, this.type)
  }
  eq(n, t = 0) {
    return this.type.eq(n.type) && this.from + t == n.from && this.to + t == n.to
  }
  map(n, t, r) {
    return this.type.map(n, this, t, r)
  }
  static widget(n, t, r) {
    return new On(n, n, new Lu(t, r))
  }
  static inline(n, t, r, i) {
    return new On(n, t, new $i(r, i))
  }
  static node(n, t, r, i) {
    return new On(n, t, new Sg(r, i))
  }
  get spec() {
    return this.type.spec
  }
  get inline() {
    return this.type instanceof $i
  }
  get widget() {
    return this.type instanceof Lu
  }
}
const io = [],
  Ms = {}
class $e {
  constructor(n, t) {
    ;((this.local = n.length ? n : io), (this.children = t.length ? t : io))
  }
  static create(n, t) {
    return t.length ? Fu(t, n, 0, Ms) : kn
  }
  find(n, t, r) {
    let i = []
    return (this.findInner(n ?? 0, t ?? 1e9, i, 0, r), i)
  }
  findInner(n, t, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o]
      a.from <= t && a.to >= n && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i))
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > n) {
        let a = this.children[o] + 1
        this.children[o + 2].findInner(n - a, t - a, r, i + a, s)
      }
  }
  map(n, t, r) {
    return this == kn || n.maps.length == 0 ? this : this.mapInner(n, t, 0, 0, r || Ms)
  }
  mapInner(n, t, r, i, s) {
    let o
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(n, r, i)
      l && l.type.valid(t, l)
        ? (o || (o = [])).push(l)
        : s.onRemove && s.onRemove(this.local[a].spec)
    }
    return this.children.length
      ? QV(this.children, o || [], n, t, r, i, s)
      : o
        ? new $e(o.sort(Es), io)
        : kn
  }
  add(n, t) {
    return t.length ? (this == kn ? $e.create(n, t) : this.addInner(n, t, 0)) : this
  }
  addInner(n, t, r) {
    let i,
      s = 0
    n.forEach((a, l) => {
      let c = l + r,
        u
      if ((u = jS(t, a, c))) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < l; ) s += 3
        ;(i[s] == l
          ? (i[s + 2] = i[s + 2].addInner(a, u, c + 1))
          : i.splice(s, 0, l, l + a.nodeSize, Fu(u, a, c + 1, Ms)),
          (s += 3))
      }
    })
    let o = DS(s ? LS(t) : t, -r)
    for (let a = 0; a < o.length; a++) o[a].type.valid(n, o[a]) || o.splice(a--, 1)
    return new $e(o.length ? this.local.concat(o).sort(Es) : this.local, i || this.children)
  }
  remove(n) {
    return n.length == 0 || this == kn ? this : this.removeInner(n, 0)
  }
  removeInner(n, t) {
    let r = this.children,
      i = this.local
    for (let s = 0; s < r.length; s += 3) {
      let o,
        a = r[s] + t,
        l = r[s + 1] + t
      for (let u = 0, f; u < n.length; u++)
        (f = n[u]) && f.from > a && f.to < l && ((n[u] = null), (o || (o = [])).push(f))
      if (!o) continue
      r == this.children && (r = this.children.slice())
      let c = r[s + 2].removeInner(o, a + 1)
      c != kn ? (r[s + 2] = c) : (r.splice(s, 3), (s -= 3))
    }
    if (i.length) {
      for (let s = 0, o; s < n.length; s++)
        if ((o = n[s]))
          for (let a = 0; a < i.length; a++)
            i[a].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1))
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new $e(i, r) : kn
  }
  forChild(n, t) {
    if (this == kn) return this
    if (t.isLeaf) return $e.empty
    let r, i
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= n) {
        this.children[a] == n && (r = this.children[a + 2])
        break
      }
    let s = n + 1,
      o = s + t.content.size
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a]
      if (l.from < o && l.to > s && l.type instanceof $i) {
        let c = Math.max(s, l.from) - s,
          u = Math.min(o, l.to) - s
        c < u && (i || (i = [])).push(l.copy(c, u))
      }
    }
    if (i) {
      let a = new $e(i.sort(Es), io)
      return r ? new Ci([a, r]) : a
    }
    return r || kn
  }
  eq(n) {
    if (this == n) return !0
    if (
      !(n instanceof $e) ||
      this.local.length != n.local.length ||
      this.children.length != n.children.length
    )
      return !1
    for (let t = 0; t < this.local.length; t++) if (!this.local[t].eq(n.local[t])) return !1
    for (let t = 0; t < this.children.length; t += 3)
      if (
        this.children[t] != n.children[t] ||
        this.children[t + 1] != n.children[t + 1] ||
        !this.children[t + 2].eq(n.children[t + 2])
      )
        return !1
    return !0
  }
  locals(n) {
    return _g(this.localsInner(n))
  }
  localsInner(n) {
    if (this == kn) return io
    if (n.inlineContent || !this.local.some($i.is)) return this.local
    let t = []
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof $i || t.push(this.local[r])
    return t
  }
  forEachSet(n) {
    n(this)
  }
}
$e.empty = new $e([], [])
$e.removeOverlap = _g
const kn = $e.empty
class Ci {
  constructor(n) {
    this.members = n
  }
  map(n, t) {
    const r = this.members.map((i) => i.map(n, t, Ms))
    return Ci.from(r)
  }
  forChild(n, t) {
    if (t.isLeaf) return $e.empty
    let r = []
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(n, t)
      s != kn && (s instanceof Ci ? (r = r.concat(s.members)) : r.push(s))
    }
    return Ci.from(r)
  }
  eq(n) {
    if (!(n instanceof Ci) || n.members.length != this.members.length) return !1
    for (let t = 0; t < this.members.length; t++) if (!this.members[t].eq(n.members[t])) return !1
    return !0
  }
  locals(n) {
    let t,
      r = !0
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(n)
      if (s.length)
        if (!t) t = s
        else {
          r && ((t = t.slice()), (r = !1))
          for (let o = 0; o < s.length; o++) t.push(s[o])
        }
    }
    return t ? _g(r ? t : t.sort(Es)) : io
  }
  static from(n) {
    switch (n.length) {
      case 0:
        return kn
      case 1:
        return n[0]
      default:
        return new Ci(
          n.every((t) => t instanceof $e)
            ? n
            : n.reduce((t, r) => t.concat(r instanceof $e ? r : r.members), []),
        )
    }
  }
  forEachSet(n) {
    for (let t = 0; t < this.members.length; t++) this.members[t].forEachSet(n)
  }
}
function QV(e, n, t, r, i, s, o) {
  let a = e.slice()
  for (let c = 0, u = s; c < t.maps.length; c++) {
    let f = 0
    ;(t.maps[c].forEach((d, h, p, g) => {
      let m = g - p - (h - d)
      for (let y = 0; y < a.length; y += 3) {
        let b = a[y + 1]
        if (b < 0 || d > b + u - f) continue
        let w = a[y] + u - f
        h >= w ? (a[y + 1] = d <= w ? -2 : -1) : d >= u && m && ((a[y] += m), (a[y + 1] += m))
      }
      f += m
    }),
      (u = t.maps[c].map(u, -1)))
  }
  let l = !1
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        ;((l = !0), (a[c + 1] = -1))
        continue
      }
      let u = t.map(e[c] + s),
        f = u - i
      if (f < 0 || f >= r.content.size) {
        l = !0
        continue
      }
      let d = t.map(e[c + 1] + s, -1),
        h = d - i,
        { index: p, offset: g } = r.content.findIndex(f),
        m = r.maybeChild(p)
      if (m && g == f && g + m.nodeSize == h) {
        let y = a[c + 2].mapInner(t, m, u + 1, e[c] + s + 1, o)
        y != kn ? ((a[c] = f), (a[c + 1] = h), (a[c + 2] = y)) : ((a[c + 1] = -2), (l = !0))
      } else l = !0
    }
  if (l) {
    let c = tH(a, e, n, t, i, s, o),
      u = Fu(c, r, 0, o)
    n = u.local
    for (let f = 0; f < a.length; f += 3) a[f + 1] < 0 && (a.splice(f, 3), (f -= 3))
    for (let f = 0, d = 0; f < u.children.length; f += 3) {
      let h = u.children[f]
      for (; d < a.length && a[d] < h; ) d += 3
      a.splice(d, 0, u.children[f], u.children[f + 1], u.children[f + 2])
    }
  }
  return new $e(n.sort(Es), a)
}
function DS(e, n) {
  if (!n || !e.length) return e
  let t = []
  for (let r = 0; r < e.length; r++) {
    let i = e[r]
    t.push(new On(i.from + n, i.to + n, i.type))
  }
  return t
}
function tH(e, n, t, r, i, s, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let f = l.local[u].map(r, i, c)
      f ? t.push(f) : o.onRemove && o.onRemove(l.local[u].spec)
    }
    for (let u = 0; u < l.children.length; u += 3) a(l.children[u + 2], l.children[u] + c + 1)
  }
  for (let l = 0; l < e.length; l += 3) e[l + 1] == -1 && a(e[l + 2], n[l] + s + 1)
  return t
}
function jS(e, n, t) {
  if (n.isLeaf) return null
  let r = t + n.nodeSize,
    i = null
  for (let s = 0, o; s < e.length; s++)
    (o = e[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), (e[s] = null))
  return i
}
function LS(e) {
  let n = []
  for (let t = 0; t < e.length; t++) e[t] != null && n.push(e[t])
  return n
}
function Fu(e, n, t, r) {
  let i = [],
    s = !1
  n.forEach((a, l) => {
    let c = jS(e, a, l + t)
    if (c) {
      s = !0
      let u = Fu(c, a, t + l + 1, r)
      u != kn && i.push(l, l + a.nodeSize, u)
    }
  })
  let o = DS(s ? LS(e) : e, -t).sort(Es)
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(n, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1))
  return o.length || i.length ? new $e(o, i) : kn
}
function Es(e, n) {
  return e.from - n.from || e.to - n.to
}
function _g(e) {
  let n = e
  for (let t = 0; t < n.length - 1; t++) {
    let r = n[t]
    if (r.from != r.to)
      for (let i = t + 1; i < n.length; i++) {
        let s = n[i]
        if (s.from == r.from) {
          s.to != r.to &&
            (n == e && (n = e.slice()),
            (n[i] = s.copy(s.from, r.to)),
            Qv(n, i + 1, s.copy(r.to, s.to)))
          continue
        } else {
          s.from < r.to &&
            (n == e && (n = e.slice()),
            (n[t] = r.copy(r.from, s.from)),
            Qv(n, i, r.copy(s.from, r.to)))
          break
        }
      }
  }
  return n
}
function Qv(e, n, t) {
  for (; n < e.length && Es(t, e[n]) > 0; ) n++
  e.splice(n, 0, t)
}
function gh(e) {
  let n = []
  return (
    e.someProp('decorations', (t) => {
      let r = t(e.state)
      r && r != kn && n.push(r)
    }),
    e.cursorWrapper && n.push($e.create(e.state.doc, [e.cursorWrapper.deco])),
    Ci.from(n)
  )
}
const eH = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0,
  },
  nH = Fn && Bi <= 11
class rH {
  constructor() {
    ;((this.anchorNode = null),
      (this.anchorOffset = 0),
      (this.focusNode = null),
      (this.focusOffset = 0))
  }
  set(n) {
    ;((this.anchorNode = n.anchorNode),
      (this.anchorOffset = n.anchorOffset),
      (this.focusNode = n.focusNode),
      (this.focusOffset = n.focusOffset))
  }
  clear() {
    this.anchorNode = this.focusNode = null
  }
  eq(n) {
    return (
      n.anchorNode == this.anchorNode &&
      n.anchorOffset == this.anchorOffset &&
      n.focusNode == this.focusNode &&
      n.focusOffset == this.focusOffset
    )
  }
}
class iH {
  constructor(n, t) {
    ;((this.view = n),
      (this.handleDOMChange = t),
      (this.queue = []),
      (this.flushingSoon = -1),
      (this.observer = null),
      (this.currentSelection = new rH()),
      (this.onCharData = null),
      (this.suppressingSelectionUpdates = !1),
      (this.lastChangedTextNode = null),
      (this.observer =
        window.MutationObserver &&
        new window.MutationObserver((r) => {
          for (let i = 0; i < r.length; i++) this.queue.push(r[i])
          Fn &&
          Bi <= 11 &&
          r.some(
            (i) =>
              (i.type == 'childList' && i.removedNodes.length) ||
              (i.type == 'characterData' && i.oldValue.length > i.target.nodeValue.length),
          )
            ? this.flushSoon()
            : this.flush()
        })),
      nH &&
        (this.onCharData = (r) => {
          ;(this.queue.push({ target: r.target, type: 'characterData', oldValue: r.prevValue }),
            this.flushSoon())
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this)))
  }
  flushSoon() {
    this.flushingSoon < 0 &&
      (this.flushingSoon = window.setTimeout(() => {
        ;((this.flushingSoon = -1), this.flush())
      }, 20))
  }
  forceFlush() {
    this.flushingSoon > -1 &&
      (window.clearTimeout(this.flushingSoon), (this.flushingSoon = -1), this.flush())
  }
  start() {
    ;(this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, eH)),
      this.onCharData &&
        this.view.dom.addEventListener('DOMCharacterDataModified', this.onCharData),
      this.connectSelection())
  }
  stop() {
    if (this.observer) {
      let n = this.observer.takeRecords()
      if (n.length) {
        for (let t = 0; t < n.length; t++) this.queue.push(n[t])
        window.setTimeout(() => this.flush(), 20)
      }
      this.observer.disconnect()
    }
    ;(this.onCharData &&
      this.view.dom.removeEventListener('DOMCharacterDataModified', this.onCharData),
      this.disconnectSelection())
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener('selectionchange', this.onSelectionChange)
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener('selectionchange', this.onSelectionChange)
  }
  suppressSelectionUpdates() {
    ;((this.suppressingSelectionUpdates = !0),
      setTimeout(() => (this.suppressingSelectionUpdates = !1), 50))
  }
  onSelectionChange() {
    if (qv(this.view)) {
      if (this.suppressingSelectionUpdates) return ti(this.view)
      if (Fn && Bi <= 11 && !this.view.state.selection.empty) {
        let n = this.view.domSelectionRange()
        if (n.focusNode && Bs(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset))
          return this.flushSoon()
      }
      this.flush()
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange())
  }
  ignoreSelectionChange(n) {
    if (!n.focusNode) return !0
    let t = new Set(),
      r
    for (let s = n.focusNode; s; s = $o(s)) t.add(s)
    for (let s = n.anchorNode; s; s = $o(s))
      if (t.has(s)) {
        r = s
        break
      }
    let i = r && this.view.docView.nearestDesc(r)
    if (i && i.ignoreMutation({ type: 'selection', target: r.nodeType == 3 ? r.parentNode : r }))
      return (this.setCurSelection(), !0)
  }
  pendingRecords() {
    if (this.observer) for (let n of this.observer.takeRecords()) this.queue.push(n)
    return this.queue
  }
  flush() {
    let { view: n } = this
    if (!n.docView || this.flushingSoon > -1) return
    let t = this.pendingRecords()
    t.length && (this.queue = [])
    let r = n.domSelectionRange(),
      i =
        !this.suppressingSelectionUpdates &&
        !this.currentSelection.eq(r) &&
        qv(n) &&
        !this.ignoreSelectionChange(r),
      s = -1,
      o = -1,
      a = !1,
      l = []
    if (n.editable)
      for (let u = 0; u < t.length; u++) {
        let f = this.registerMutation(t[u], l)
        f &&
          ((s = s < 0 ? f.from : Math.min(f.from, s)),
          (o = o < 0 ? f.to : Math.max(f.to, o)),
          f.typeOver && (a = !0))
      }
    if (lr && l.length) {
      let u = l.filter((f) => f.nodeName == 'BR')
      if (u.length == 2) {
        let [f, d] = u
        f.parentNode && f.parentNode.parentNode == d.parentNode ? d.remove() : f.remove()
      } else {
        let { focusNode: f } = this.currentSelection
        for (let d of u) {
          let h = d.parentNode
          h && h.nodeName == 'LI' && (!f || aH(n, f) != h) && d.remove()
        }
      }
    }
    let c = null
    s < 0 &&
    i &&
    n.input.lastFocus > Date.now() - 200 &&
    Math.max(n.input.lastTouch, n.input.lastClick.time) < Date.now() - 300 &&
    Jf(r) &&
    (c = gg(n)) &&
    c.eq(ye.near(n.state.doc.resolve(0), 1))
      ? ((n.input.lastFocus = 0), ti(n), this.currentSelection.set(r), n.scrollToSelection())
      : (s > -1 || i) &&
        (s > -1 && (n.docView.markDirty(s, o), sH(n)),
        this.handleDOMChange(s, o, a, l),
        n.docView && n.docView.dirty
          ? n.updateState(n.state)
          : this.currentSelection.eq(r) || ti(n),
        this.currentSelection.set(r))
  }
  registerMutation(n, t) {
    if (t.indexOf(n.target) > -1) return null
    let r = this.view.docView.nearestDesc(n.target)
    if (
      (n.type == 'attributes' &&
        (r == this.view.docView ||
          n.attributeName == 'contenteditable' ||
          (n.attributeName == 'style' && !n.oldValue && !n.target.getAttribute('style')))) ||
      !r ||
      r.ignoreMutation(n)
    )
      return null
    if (n.type == 'childList') {
      for (let u = 0; u < n.addedNodes.length; u++) {
        let f = n.addedNodes[u]
        ;(t.push(f), f.nodeType == 3 && (this.lastChangedTextNode = f))
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(n.target))
        return { from: r.posBefore, to: r.posAfter }
      let i = n.previousSibling,
        s = n.nextSibling
      if (Fn && Bi <= 11 && n.addedNodes.length)
        for (let u = 0; u < n.addedNodes.length; u++) {
          let { previousSibling: f, nextSibling: d } = n.addedNodes[u]
          ;((!f || Array.prototype.indexOf.call(n.addedNodes, f) < 0) && (i = f),
            (!d || Array.prototype.indexOf.call(n.addedNodes, d) < 0) && (s = d))
        }
      let o = i && i.parentNode == n.target ? wn(i) + 1 : 0,
        a = r.localPosFromDOM(n.target, o, -1),
        l = s && s.parentNode == n.target ? wn(s) : n.target.childNodes.length,
        c = r.localPosFromDOM(n.target, l, 1)
      return { from: a, to: c }
    } else
      return n.type == 'attributes'
        ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
        : ((this.lastChangedTextNode = n.target),
          { from: r.posAtStart, to: r.posAtEnd, typeOver: n.target.nodeValue == n.oldValue })
  }
}
let t2 = new WeakMap(),
  e2 = !1
function sH(e) {
  if (
    !t2.has(e) &&
    (t2.set(e, null),
    ['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1)
  ) {
    if (((e.requiresGeckoHackNode = lr), e2)) return
    ;(console.warn(
      "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.",
    ),
      (e2 = !0))
  }
}
function n2(e, n) {
  let t = n.startContainer,
    r = n.startOffset,
    i = n.endContainer,
    s = n.endOffset,
    o = e.domAtPos(e.state.selection.anchor)
  return (
    Bs(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]),
    { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s }
  )
}
function oH(e, n) {
  if (n.getComposedRanges) {
    let i = n.getComposedRanges(e.root)[0]
    if (i) return n2(e, i)
  }
  let t
  function r(i) {
    ;(i.preventDefault(), i.stopImmediatePropagation(), (t = i.getTargetRanges()[0]))
  }
  return (
    e.dom.addEventListener('beforeinput', r, !0),
    document.execCommand('indent'),
    e.dom.removeEventListener('beforeinput', r, !0),
    t ? n2(e, t) : null
  )
}
function aH(e, n) {
  for (let t = n.parentNode; t && t != e.dom; t = t.parentNode) {
    let r = e.docView.nearestDesc(t, !0)
    if (r && r.node.isBlock) return t
  }
  return null
}
function lH(e, n, t) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = e.docView.parseRange(n, t),
    l = e.domSelectionRange(),
    c,
    u = l.anchorNode
  if (
    (u &&
      e.dom.contains(u.nodeType == 1 ? u : u.parentNode) &&
      ((c = [{ node: u, offset: l.anchorOffset }]),
      Jf(l) || c.push({ node: l.focusNode, offset: l.focusOffset })),
    En && e.input.lastKeyCode === 8)
  )
    for (let m = s; m > i; m--) {
      let y = r.childNodes[m - 1],
        b = y.pmViewDesc
      if (y.nodeName == 'BR' && !b) {
        s = m
        break
      }
      if (!b || b.size) break
    }
  let f = e.state.doc,
    d = e.someProp('domParser') || Fi.fromSchema(e.state.schema),
    h = f.resolve(o),
    p = null,
    g = d.parse(r, {
      topNode: h.parent,
      topMatch: h.parent.contentMatchAt(h.index()),
      topOpen: !0,
      from: i,
      to: s,
      preserveWhitespace: h.parent.type.whitespace == 'pre' ? 'full' : !0,
      findPositions: c,
      ruleFromNode: cH,
      context: h,
    })
  if (c && c[0].pos != null) {
    let m = c[0].pos,
      y = c[1] && c[1].pos
    ;(y == null && (y = m), (p = { anchor: m + o, head: y + o }))
  }
  return { doc: g, sel: p, from: o, to: a }
}
function cH(e) {
  let n = e.pmViewDesc
  if (n) return n.parseRule()
  if (e.nodeName == 'BR' && e.parentNode) {
    if (Pn && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
      let t = document.createElement('div')
      return (t.appendChild(document.createElement('li')), { skip: t })
    } else if (e.parentNode.lastChild == e || (Pn && /^(tr|table)$/i.test(e.parentNode.nodeName)))
      return { ignore: !0 }
  } else if (e.nodeName == 'IMG' && e.getAttribute('mark-placeholder')) return { ignore: !0 }
  return null
}
const uH =
  /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i
function fH(e, n, t, r, i) {
  let s = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0)
  if (((e.input.compositionPendingChanges = 0), n < 0)) {
    let B = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null,
      E = gg(e, B)
    if (E && !e.state.selection.eq(E)) {
      if (
        En &&
        Yr &&
        e.input.lastKeyCode === 13 &&
        Date.now() - 100 < e.input.lastKeyCodeTime &&
        e.someProp('handleKeyDown', (P) => P(e, as(13, 'Enter')))
      )
        return
      let O = e.state.tr.setSelection(E)
      ;(B == 'pointer' ? O.setMeta('pointer', !0) : B == 'key' && O.scrollIntoView(),
        s && O.setMeta('composition', s),
        e.dispatch(O))
    }
    return
  }
  let o = e.state.doc.resolve(n),
    a = o.sharedDepth(t)
  ;((n = o.before(a + 1)), (t = e.state.doc.resolve(t).after(a + 1)))
  let l = e.state.selection,
    c = lH(e, n, t),
    u = e.state.doc,
    f = u.slice(c.from, c.to),
    d,
    h
  ;(e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime
    ? ((d = e.state.selection.to), (h = 'end'))
    : ((d = e.state.selection.from), (h = 'start')),
    (e.input.lastKeyCode = null))
  let p = pH(f.content, c.doc.content, c.from, d, h)
  if (
    (p && e.input.domChangeCount++,
    ((Vo && e.input.lastIOSEnter > Date.now() - 225) || Yr) &&
      i.some((B) => B.nodeType == 1 && !uH.test(B.nodeName)) &&
      (!p || p.endA >= p.endB) &&
      e.someProp('handleKeyDown', (B) => B(e, as(13, 'Enter'))))
  ) {
    e.input.lastIOSEnter = 0
    return
  }
  if (!p)
    if (
      r &&
      l instanceof oe &&
      !l.empty &&
      l.$head.sameParent(l.$anchor) &&
      !e.composing &&
      !(c.sel && c.sel.anchor != c.sel.head)
    )
      p = { start: l.from, endA: l.to, endB: l.to }
    else {
      if (c.sel) {
        let B = r2(e, e.state.doc, c.sel)
        if (B && !B.eq(e.state.selection)) {
          let E = e.state.tr.setSelection(B)
          ;(s && E.setMeta('composition', s), e.dispatch(E))
        }
      }
      return
    }
  ;(e.state.selection.from < e.state.selection.to &&
    p.start == p.endB &&
    e.state.selection instanceof oe &&
    (p.start > e.state.selection.from &&
    p.start <= e.state.selection.from + 2 &&
    e.state.selection.from >= c.from
      ? (p.start = e.state.selection.from)
      : p.endA < e.state.selection.to &&
        p.endA >= e.state.selection.to - 2 &&
        e.state.selection.to <= c.to &&
        ((p.endB += e.state.selection.to - p.endA), (p.endA = e.state.selection.to))),
    Fn &&
      Bi <= 11 &&
      p.endB == p.start + 1 &&
      p.endA == p.start &&
      p.start > c.from &&
      c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == ' ' &&
      (p.start--, p.endA--, p.endB--))
  let g = c.doc.resolveNoCache(p.start - c.from),
    m = c.doc.resolveNoCache(p.endB - c.from),
    y = u.resolve(p.start),
    b = g.sameParent(m) && g.parent.inlineContent && y.end() >= p.endA
  if (
    ((Vo &&
      e.input.lastIOSEnter > Date.now() - 225 &&
      (!b || i.some((B) => B.nodeName == 'DIV' || B.nodeName == 'P'))) ||
      (!b &&
        g.pos < c.doc.content.size &&
        (!g.sameParent(m) || !g.parent.inlineContent) &&
        g.pos < m.pos &&
        !/\S/.test(c.doc.textBetween(g.pos, m.pos, '', '')))) &&
    e.someProp('handleKeyDown', (B) => B(e, as(13, 'Enter')))
  ) {
    e.input.lastIOSEnter = 0
    return
  }
  if (
    e.state.selection.anchor > p.start &&
    hH(u, p.start, p.endA, g, m) &&
    e.someProp('handleKeyDown', (B) => B(e, as(8, 'Backspace')))
  ) {
    Yr && En && e.domObserver.suppressSelectionUpdates()
    return
  }
  ;(En && p.endB == p.start && (e.input.lastChromeDelete = Date.now()),
    Yr &&
      !b &&
      g.start() != m.start() &&
      m.parentOffset == 0 &&
      g.depth == m.depth &&
      c.sel &&
      c.sel.anchor == c.sel.head &&
      c.sel.head == p.endA &&
      ((p.endB -= 2),
      (m = c.doc.resolveNoCache(p.endB - c.from)),
      setTimeout(() => {
        e.someProp('handleKeyDown', function (B) {
          return B(e, as(13, 'Enter'))
        })
      }, 20)))
  let w = p.start,
    C = p.endA,
    T = (B) => {
      let E = B || e.state.tr.replace(w, C, c.doc.slice(p.start - c.from, p.endB - c.from))
      if (c.sel) {
        let O = r2(e, E.doc, c.sel)
        O &&
          !(
            (En &&
              e.composing &&
              O.empty &&
              (p.start != p.endB || e.input.lastChromeDelete < Date.now() - 100) &&
              (O.head == w || O.head == E.mapping.map(C) - 1)) ||
            (Fn && O.empty && O.head == w)
          ) &&
          E.setSelection(O)
      }
      return (s && E.setMeta('composition', s), E.scrollIntoView())
    },
    I
  if (b)
    if (g.pos == m.pos) {
      Fn &&
        Bi <= 11 &&
        g.parentOffset == 0 &&
        (e.domObserver.suppressSelectionUpdates(), setTimeout(() => ti(e), 20))
      let B = T(e.state.tr.delete(w, C)),
        E = u.resolve(p.start).marksAcross(u.resolve(p.endA))
      ;(E && B.ensureMarks(E), e.dispatch(B))
    } else if (
      p.endA == p.endB &&
      (I = dH(
        g.parent.content.cut(g.parentOffset, m.parentOffset),
        y.parent.content.cut(y.parentOffset, p.endA - y.start()),
      ))
    ) {
      let B = T(e.state.tr)
      ;(I.type == 'add' ? B.addMark(w, C, I.mark) : B.removeMark(w, C, I.mark), e.dispatch(B))
    } else if (
      g.parent.child(g.index()).isText &&
      g.index() == m.index() - (m.textOffset ? 0 : 1)
    ) {
      let B = g.parent.textBetween(g.parentOffset, m.parentOffset),
        E = () => T(e.state.tr.insertText(B, w, C))
      e.someProp('handleTextInput', (O) => O(e, w, C, B, E)) || e.dispatch(E())
    } else e.dispatch(T())
  else e.dispatch(T())
}
function r2(e, n, t) {
  return Math.max(t.anchor, t.head) > n.content.size
    ? null
    : yg(e, n.resolve(t.anchor), n.resolve(t.head))
}
function dH(e, n) {
  let t = e.firstChild.marks,
    r = n.firstChild.marks,
    i = t,
    s = r,
    o,
    a,
    l
  for (let u = 0; u < r.length; u++) i = r[u].removeFromSet(i)
  for (let u = 0; u < t.length; u++) s = t[u].removeFromSet(s)
  if (i.length == 1 && s.length == 0)
    ((a = i[0]), (o = 'add'), (l = (u) => u.mark(a.addToSet(u.marks))))
  else if (i.length == 0 && s.length == 1)
    ((a = s[0]), (o = 'remove'), (l = (u) => u.mark(a.removeFromSet(u.marks))))
  else return null
  let c = []
  for (let u = 0; u < n.childCount; u++) c.push(l(n.child(u)))
  if (St.from(c).eq(e)) return { mark: a, type: o }
}
function hH(e, n, t, r, i) {
  if (t - n <= i.pos - r.pos || yh(r, !0, !1) < i.pos) return !1
  let s = e.resolve(n)
  if (!r.parent.isTextblock) {
    let a = s.nodeAfter
    return a != null && t == n + a.nodeSize
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock) return !1
  let o = e.resolve(yh(s, !0, !0))
  return !o.parent.isTextblock || o.pos > t || yh(o, !0, !1) < t
    ? !1
    : r.parent.content.cut(r.parentOffset).eq(o.parent.content)
}
function yh(e, n, t) {
  let r = e.depth,
    i = n ? e.end() : e.pos
  for (; r > 0 && (n || e.indexAfter(r) == e.node(r).childCount); ) (r--, i++, (n = !1))
  if (t) {
    let s = e.node(r).maybeChild(e.indexAfter(r))
    for (; s && !s.isLeaf; ) ((s = s.firstChild), i++)
  }
  return i
}
function pH(e, n, t, r, i) {
  let s = e.findDiffStart(n, t)
  if (s == null) return null
  let { a: o, b: a } = e.findDiffEnd(n, t + e.size, t + n.size)
  if (i == 'end') {
    let l = Math.max(0, s - Math.min(o, a))
    r -= o + l - s
  }
  if (o < s && e.size < n.size) {
    let l = r <= s && r >= o ? s - r : 0
    ;((s -= l),
      s && s < n.size && i2(n.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1),
      (a = s + (a - o)),
      (o = s))
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0
    ;((s -= l),
      s && s < e.size && i2(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1),
      (o = s + (o - a)),
      (a = s))
  }
  return { start: s, endA: o, endB: a }
}
function i2(e) {
  if (e.length != 2) return !1
  let n = e.charCodeAt(0),
    t = e.charCodeAt(1)
  return n >= 56320 && n <= 57343 && t >= 55296 && t <= 56319
}
class FS {
  constructor(n, t) {
    ;((this._root = null),
      (this.focused = !1),
      (this.trackWrites = null),
      (this.mounted = !1),
      (this.markCursor = null),
      (this.cursorWrapper = null),
      (this.lastSelectedViewDesc = void 0),
      (this.input = new NV()),
      (this.prevDirectPlugins = []),
      (this.pluginViews = []),
      (this.requiresGeckoHackNode = !1),
      (this.dragging = null),
      (this._props = t),
      (this.state = t.state),
      (this.directPlugins = t.plugins || []),
      this.directPlugins.forEach(c2),
      (this.dispatch = this.dispatch.bind(this)),
      (this.dom = (n && n.mount) || document.createElement('div')),
      n &&
        (n.appendChild
          ? n.appendChild(this.dom)
          : typeof n == 'function'
            ? n(this.dom)
            : n.mount && (this.mounted = !0)),
      (this.editable = a2(this)),
      o2(this),
      (this.nodeViews = l2(this)),
      (this.docView = Bv(this.state.doc, s2(this), gh(this), this.dom, this)),
      (this.domObserver = new iH(this, (r, i, s, o) => fH(this, r, i, s, o))),
      this.domObserver.start(),
      IV(this),
      this.updatePluginViews())
  }
  get composing() {
    return this.input.composing
  }
  get props() {
    if (this._props.state != this.state) {
      let n = this._props
      this._props = {}
      for (let t in n) this._props[t] = n[t]
      this._props.state = this.state
    }
    return this._props
  }
  update(n) {
    n.handleDOMEvents != this._props.handleDOMEvents && am(this)
    let t = this._props
    ;((this._props = n),
      n.plugins && (n.plugins.forEach(c2), (this.directPlugins = n.plugins)),
      this.updateStateInner(n.state, t))
  }
  setProps(n) {
    let t = {}
    for (let r in this._props) t[r] = this._props[r]
    t.state = this.state
    for (let r in n) t[r] = n[r]
    this.update(t)
  }
  updateState(n) {
    this.updateStateInner(n, this._props)
  }
  updateStateInner(n, t) {
    var r
    let i = this.state,
      s = !1,
      o = !1
    ;(n.storedMarks && this.composing && (OS(this), (o = !0)), (this.state = n))
    let a = i.plugins != n.plugins || this._props.plugins != t.plugins
    if (a || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let h = l2(this)
      gH(h, this.nodeViews) && ((this.nodeViews = h), (s = !0))
    }
    ;((a || t.handleDOMEvents != this._props.handleDOMEvents) && am(this),
      (this.editable = a2(this)),
      o2(this))
    let l = gh(this),
      c = s2(this),
      u =
        i.plugins != n.plugins && !i.doc.eq(n.doc)
          ? 'reset'
          : n.scrollToSelection > i.scrollToSelection
            ? 'to selection'
            : 'preserve',
      f = s || !this.docView.matchesNode(n.doc, c, l)
    ;(f || !n.selection.eq(i.selection)) && (o = !0)
    let d = u == 'preserve' && o && this.dom.style.overflowAnchor == null && G$(this)
    if (o) {
      this.domObserver.stop()
      let h =
        f &&
        (Fn || En) &&
        !this.composing &&
        !i.selection.empty &&
        !n.selection.empty &&
        mH(i.selection, n.selection)
      if (f) {
        let p = En ? (this.trackWrites = this.domSelectionRange().focusNode) : null
        ;(this.composing && (this.input.compositionNode = KV(this)),
          (s || !this.docView.update(n.doc, c, l, this)) &&
            (this.docView.updateOuterDeco(c),
            this.docView.destroy(),
            (this.docView = Bv(n.doc, c, l, this.dom, this))),
          p && !this.trackWrites && (h = !0))
      }
      ;(h ||
      !(
        this.input.mouseDown &&
        this.domObserver.currentSelection.eq(this.domSelectionRange()) &&
        bV(this)
      )
        ? ti(this, h)
        : (vS(this, n.selection), this.domObserver.setCurSelection()),
        this.domObserver.start())
    }
    ;(this.updatePluginViews(i),
      !((r = this.dragging) === null || r === void 0) &&
        r.node &&
        !i.doc.eq(n.doc) &&
        this.updateDraggedNode(this.dragging, i),
      u == 'reset'
        ? (this.dom.scrollTop = 0)
        : u == 'to selection'
          ? this.scrollToSelection()
          : d && X$(d))
  }
  scrollToSelection() {
    let n = this.domSelectionRange().focusNode
    if (!(!n || !this.dom.contains(n.nodeType == 1 ? n : n.parentNode))) {
      if (!this.someProp('handleScrollToSelection', (t) => t(this)))
        if (this.state.selection instanceof Zt) {
          let t = this.docView.domAfterPos(this.state.selection.from)
          t.nodeType == 1 && Nv(this, t.getBoundingClientRect(), n)
        } else Nv(this, this.coordsAtPos(this.state.selection.head, 1), n)
    }
  }
  destroyPluginViews() {
    let n
    for (; (n = this.pluginViews.pop()); ) n.destroy && n.destroy()
  }
  updatePluginViews(n) {
    if (!n || n.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      ;((this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews())
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t]
        r.update && r.update(this, n)
      }
  }
  updateDraggedNode(n, t) {
    let r = n.node,
      i = -1
    if (this.state.doc.nodeAt(r.from) == r.node) i = r.from
    else {
      let s = r.from + (this.state.doc.content.size - t.doc.content.size)
      ;(s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s)
    }
    this.dragging = new NS(n.slice, n.move, i < 0 ? void 0 : Zt.create(this.state.doc, i))
  }
  someProp(n, t) {
    let r = this._props && this._props[n],
      i
    if (r != null && (i = t ? t(r) : r)) return i
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[n]
      if (a != null && (i = t ? t(a) : a)) return i
    }
    let s = this.state.plugins
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[n]
        if (a != null && (i = t ? t(a) : a)) return i
      }
  }
  hasFocus() {
    if (Fn) {
      let n = this.root.activeElement
      if (n == this.dom) return !0
      if (!n || !this.dom.contains(n)) return !1
      for (; n && this.dom != n && this.dom.contains(n); ) {
        if (n.contentEditable == 'false') return !1
        n = n.parentElement
      }
      return !0
    }
    return this.root.activeElement == this.dom
  }
  focus() {
    ;(this.domObserver.stop(), this.editable && Y$(this.dom), ti(this), this.domObserver.start())
  }
  get root() {
    let n = this._root
    if (n == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || (t.nodeType == 11 && t.host))
          return (
            t.getSelection ||
              (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()),
            (this._root = t)
          )
    }
    return n || document
  }
  updateRoot() {
    this._root = null
  }
  posAtCoords(n) {
    return eV(this, n)
  }
  coordsAtPos(n, t = 1) {
    return fS(this, n, t)
  }
  domAtPos(n, t = 0) {
    return this.docView.domFromPos(n, t)
  }
  nodeDOM(n) {
    let t = this.docView.descAt(n)
    return t ? t.nodeDOM : null
  }
  posAtDOM(n, t, r = -1) {
    let i = this.docView.posFromDOM(n, t, r)
    if (i == null) throw new RangeError('DOM position not inside the editor')
    return i
  }
  endOfTextblock(n, t) {
    return oV(this, t || this.state, n)
  }
  pasteHTML(n, t) {
    return bl(this, '', n, !1, t || new ClipboardEvent('paste'))
  }
  pasteText(n, t) {
    return bl(this, n, null, !0, t || new ClipboardEvent('paste'))
  }
  serializeForClipboard(n) {
    return bg(this, n)
  }
  destroy() {
    this.docView &&
      (DV(this),
      this.destroyPluginViews(),
      this.mounted
        ? (this.docView.update(this.state.doc, [], gh(this), this), (this.dom.textContent = ''))
        : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
      this.docView.destroy(),
      (this.docView = null),
      L$())
  }
  get isDestroyed() {
    return this.docView == null
  }
  dispatchEvent(n) {
    return LV(this, n)
  }
  domSelectionRange() {
    let n = this.domSelection()
    return n
      ? (Pn &&
          this.root.nodeType === 11 &&
          V$(this.dom.ownerDocument) == this.dom &&
          oH(this, n)) ||
          n
      : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 }
  }
  domSelection() {
    return this.root.getSelection()
  }
}
FS.prototype.dispatch = function (e) {
  let n = this._props.dispatchTransaction
  n ? n.call(this, e) : this.updateState(this.state.apply(e))
}
function s2(e) {
  let n = Object.create(null)
  return (
    (n.class = 'ProseMirror'),
    (n.contenteditable = String(e.editable)),
    e.someProp('attributes', (t) => {
      if ((typeof t == 'function' && (t = t(e.state)), t))
        for (let r in t)
          r == 'class'
            ? (n.class += ' ' + t[r])
            : r == 'style'
              ? (n.style = (n.style ? n.style + ';' : '') + t[r])
              : !n[r] && r != 'contenteditable' && r != 'nodeName' && (n[r] = String(t[r]))
    }),
    n.translate || (n.translate = 'no'),
    [On.node(0, e.state.doc.content.size, n)]
  )
}
function o2(e) {
  if (e.markCursor) {
    let n = document.createElement('img')
    ;((n.className = 'ProseMirror-separator'),
      n.setAttribute('mark-placeholder', 'true'),
      n.setAttribute('alt', ''),
      (e.cursorWrapper = {
        dom: n,
        deco: On.widget(e.state.selection.from, n, { raw: !0, marks: e.markCursor }),
      }))
  } else e.cursorWrapper = null
}
function a2(e) {
  return !e.someProp('editable', (n) => n(e.state) === !1)
}
function mH(e, n) {
  let t = Math.min(e.$anchor.sharedDepth(e.head), n.$anchor.sharedDepth(n.head))
  return e.$anchor.start(t) != n.$anchor.start(t)
}
function l2(e) {
  let n = Object.create(null)
  function t(r) {
    for (let i in r) Object.prototype.hasOwnProperty.call(n, i) || (n[i] = r[i])
  }
  return (e.someProp('nodeViews', t), e.someProp('markViews', t), n)
}
function gH(e, n) {
  let t = 0,
    r = 0
  for (let i in e) {
    if (e[i] != n[i]) return !0
    t++
  }
  for (let i in n) r++
  return t != r
}
function c2(e) {
  if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
    throw new RangeError('Plugins passed directly to the view must not have a state component')
}
var Ki = {
    8: 'Backspace',
    9: 'Tab',
    10: 'Enter',
    12: 'NumLock',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    44: 'PrintScreen',
    45: 'Insert',
    46: 'Delete',
    59: ';',
    61: '=',
    91: 'Meta',
    92: 'Meta',
    106: '*',
    107: '+',
    108: ',',
    109: '-',
    110: '.',
    111: '/',
    144: 'NumLock',
    145: 'ScrollLock',
    160: 'Shift',
    161: 'Shift',
    162: 'Control',
    163: 'Control',
    164: 'Alt',
    165: 'Alt',
    173: '-',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: "'",
  },
  Bu = {
    48: ')',
    49: '!',
    50: '@',
    51: '#',
    52: '$',
    53: '%',
    54: '^',
    55: '&',
    56: '*',
    57: '(',
    59: ':',
    61: '+',
    173: '_',
    186: ':',
    187: '+',
    188: '<',
    189: '_',
    190: '>',
    191: '?',
    192: '~',
    219: '{',
    220: '|',
    221: '}',
    222: '"',
  },
  yH = typeof navigator < 'u' && /Mac/.test(navigator.platform),
  bH =
    typeof navigator < 'u' &&
    /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
for (var xn = 0; xn < 10; xn++) Ki[48 + xn] = Ki[96 + xn] = String(xn)
for (var xn = 1; xn <= 24; xn++) Ki[xn + 111] = 'F' + xn
for (var xn = 65; xn <= 90; xn++)
  ((Ki[xn] = String.fromCharCode(xn + 32)), (Bu[xn] = String.fromCharCode(xn)))
for (var bh in Ki) Bu.hasOwnProperty(bh) || (Bu[bh] = Ki[bh])
function vH(e) {
  var n =
      (yH && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey) ||
      (bH && e.shiftKey && e.key && e.key.length == 1) ||
      e.key == 'Unidentified',
    t = (!n && e.key) || (e.shiftKey ? Bu : Ki)[e.keyCode] || e.key || 'Unidentified'
  return (
    t == 'Esc' && (t = 'Escape'),
    t == 'Del' && (t = 'Delete'),
    t == 'Left' && (t = 'ArrowLeft'),
    t == 'Up' && (t = 'ArrowUp'),
    t == 'Right' && (t = 'ArrowRight'),
    t == 'Down' && (t = 'ArrowDown'),
    t
  )
}
const wH = typeof navigator < 'u' && /Mac|iP(hone|[oa]d)/.test(navigator.platform),
  xH = typeof navigator < 'u' && /Win/.test(navigator.platform)
function SH(e) {
  let n = e.split(/-(?!$)/),
    t = n[n.length - 1]
  t == 'Space' && (t = ' ')
  let r, i, s, o
  for (let a = 0; a < n.length - 1; a++) {
    let l = n[a]
    if (/^(cmd|meta|m)$/i.test(l)) o = !0
    else if (/^a(lt)?$/i.test(l)) r = !0
    else if (/^(c|ctrl|control)$/i.test(l)) i = !0
    else if (/^s(hift)?$/i.test(l)) s = !0
    else if (/^mod$/i.test(l)) wH ? (o = !0) : (i = !0)
    else throw new Error('Unrecognized modifier name: ' + l)
  }
  return (
    r && (t = 'Alt-' + t),
    i && (t = 'Ctrl-' + t),
    o && (t = 'Meta-' + t),
    s && (t = 'Shift-' + t),
    t
  )
}
function _H(e) {
  let n = Object.create(null)
  for (let t in e) n[SH(t)] = e[t]
  return n
}
function vh(e, n, t = !0) {
  return (
    n.altKey && (e = 'Alt-' + e),
    n.ctrlKey && (e = 'Ctrl-' + e),
    n.metaKey && (e = 'Meta-' + e),
    t && n.shiftKey && (e = 'Shift-' + e),
    e
  )
}
function kH(e) {
  return new Ke({ props: { handleKeyDown: BS(e) } })
}
function BS(e) {
  let n = _H(e)
  return function (t, r) {
    let i = vH(r),
      s,
      o = n[vh(i, r)]
    if (o && o(t.state, t.dispatch, t)) return !0
    if (i.length == 1 && i != ' ') {
      if (r.shiftKey) {
        let a = n[vh(i, r, !1)]
        if (a && a(t.state, t.dispatch, t)) return !0
      }
      if (
        (r.altKey || r.metaKey || r.ctrlKey) &&
        !(xH && r.ctrlKey && r.altKey) &&
        (s = Ki[r.keyCode]) &&
        s != i
      ) {
        let a = n[vh(s, r)]
        if (a && a(t.state, t.dispatch, t)) return !0
      }
    }
    return !1
  }
}
var CH = Object.defineProperty,
  kg = (e, n) => {
    for (var t in n) CH(e, t, { get: n[t], enumerable: !0 })
  }
function ed(e) {
  const { state: n, transaction: t } = e
  let { selection: r } = t,
    { doc: i } = t,
    { storedMarks: s } = t
  return {
    ...n,
    apply: n.apply.bind(n),
    applyTransaction: n.applyTransaction.bind(n),
    plugins: n.plugins,
    schema: n.schema,
    reconfigure: n.reconfigure.bind(n),
    toJSON: n.toJSON.bind(n),
    get storedMarks() {
      return s
    },
    get selection() {
      return r
    },
    get doc() {
      return i
    },
    get tr() {
      return ((r = t.selection), (i = t.doc), (s = t.storedMarks), t)
    },
  }
}
var nd = class {
    constructor(e) {
      ;((this.editor = e.editor),
        (this.rawCommands = this.editor.extensionManager.commands),
        (this.customState = e.state))
    }
    get hasCustomState() {
      return !!this.customState
    }
    get state() {
      return this.customState || this.editor.state
    }
    get commands() {
      const { rawCommands: e, editor: n, state: t } = this,
        { view: r } = n,
        { tr: i } = t,
        s = this.buildProps(i)
      return Object.fromEntries(
        Object.entries(e).map(([o, a]) => [
          o,
          (...c) => {
            const u = a(...c)(s)
            return (!i.getMeta('preventDispatch') && !this.hasCustomState && r.dispatch(i), u)
          },
        ]),
      )
    }
    get chain() {
      return () => this.createChain()
    }
    get can() {
      return () => this.createCan()
    }
    createChain(e, n = !0) {
      const { rawCommands: t, editor: r, state: i } = this,
        { view: s } = r,
        o = [],
        a = !!e,
        l = e || i.tr,
        c = () => (
          !a && n && !l.getMeta('preventDispatch') && !this.hasCustomState && s.dispatch(l),
          o.every((f) => f === !0)
        ),
        u = {
          ...Object.fromEntries(
            Object.entries(t).map(([f, d]) => [
              f,
              (...p) => {
                const g = this.buildProps(l, n),
                  m = d(...p)(g)
                return (o.push(m), u)
              },
            ]),
          ),
          run: c,
        }
      return u
    }
    createCan(e) {
      const { rawCommands: n, state: t } = this,
        r = !1,
        i = e || t.tr,
        s = this.buildProps(i, r)
      return {
        ...Object.fromEntries(
          Object.entries(n).map(([a, l]) => [a, (...c) => l(...c)({ ...s, dispatch: void 0 })]),
        ),
        chain: () => this.createChain(i, r),
      }
    }
    buildProps(e, n = !0) {
      const { rawCommands: t, editor: r, state: i } = this,
        { view: s } = r,
        o = {
          tr: e,
          editor: r,
          view: s,
          state: ed({ state: i, transaction: e }),
          dispatch: n ? () => {} : void 0,
          chain: () => this.createChain(e, n),
          can: () => this.createCan(e),
          get commands() {
            return Object.fromEntries(Object.entries(t).map(([a, l]) => [a, (...c) => l(...c)(o)]))
          },
        }
      return o
    }
  },
  zS = {}
kg(zS, {
  blur: () => MH,
  clearContent: () => EH,
  clearNodes: () => TH,
  command: () => AH,
  createParagraphNear: () => RH,
  cut: () => OH,
  deleteCurrentNode: () => PH,
  deleteNode: () => NH,
  deleteRange: () => IH,
  deleteSelection: () => DH,
  enter: () => jH,
  exitCode: () => LH,
  extendMarkRange: () => FH,
  first: () => BH,
  focus: () => $H,
  forEach: () => VH,
  insertContent: () => HH,
  insertContentAt: () => WH,
  joinBackward: () => XH,
  joinDown: () => GH,
  joinForward: () => YH,
  joinItemBackward: () => ZH,
  joinItemForward: () => JH,
  joinTextblockBackward: () => QH,
  joinTextblockForward: () => tU,
  joinUp: () => KH,
  keyboardShortcut: () => nU,
  lift: () => rU,
  liftEmptyBlock: () => iU,
  liftListItem: () => sU,
  newlineInCode: () => oU,
  resetAttributes: () => aU,
  scrollIntoView: () => lU,
  selectAll: () => cU,
  selectNodeBackward: () => uU,
  selectNodeForward: () => fU,
  selectParentNode: () => dU,
  selectTextblockEnd: () => hU,
  selectTextblockStart: () => pU,
  setContent: () => mU,
  setMark: () => NU,
  setMeta: () => IU,
  setNode: () => DU,
  setNodeSelection: () => jU,
  setTextSelection: () => LU,
  sinkListItem: () => FU,
  splitBlock: () => BU,
  splitListItem: () => zU,
  toggleList: () => $U,
  toggleMark: () => VU,
  toggleNode: () => HU,
  toggleWrap: () => UU,
  undoInputRule: () => qU,
  unsetAllMarks: () => WU,
  unsetMark: () => KU,
  updateAttributes: () => GU,
  wrapIn: () => XU,
  wrapInList: () => YU,
})
var MH =
    () =>
    ({ editor: e, view: n }) => (
      requestAnimationFrame(() => {
        var t
        e.isDestroyed || (n.dom.blur(), (t = window?.getSelection()) == null || t.removeAllRanges())
      }),
      !0
    ),
  EH =
    (e = !0) =>
    ({ commands: n }) =>
      n.setContent('', { emitUpdate: e }),
  TH =
    () =>
    ({ state: e, tr: n, dispatch: t }) => {
      const { selection: r } = n,
        { ranges: i } = r
      return (
        t &&
          i.forEach(({ $from: s, $to: o }) => {
            e.doc.nodesBetween(s.pos, o.pos, (a, l) => {
              if (a.type.isText) return
              const { doc: c, mapping: u } = n,
                f = c.resolve(u.map(l)),
                d = c.resolve(u.map(l + a.nodeSize)),
                h = f.blockRange(d)
              if (!h) return
              const p = ra(h)
              if (a.type.isTextblock) {
                const { defaultType: g } = f.parent.contentMatchAt(f.index())
                n.setNodeMarkup(h.start, g)
              }
              ;(p || p === 0) && n.lift(h, p)
            })
          }),
        !0
      )
    },
  AH = (e) => (n) => e(n),
  RH =
    () =>
    ({ state: e, dispatch: n }) =>
      eS(e, n),
  OH =
    (e, n) =>
    ({ editor: t, tr: r }) => {
      const { state: i } = t,
        s = i.doc.slice(e.from, e.to)
      r.deleteRange(e.from, e.to)
      const o = r.mapping.map(n)
      return (r.insert(o, s.content), r.setSelection(new oe(r.doc.resolve(Math.max(o - 1, 0)))), !0)
    },
  PH =
    () =>
    ({ tr: e, dispatch: n }) => {
      const { selection: t } = e,
        r = t.$anchor.node()
      if (r.content.size > 0) return !1
      const i = e.selection.$anchor
      for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === r.type) {
          if (n) {
            const a = i.before(s),
              l = i.after(s)
            e.delete(a, l).scrollIntoView()
          }
          return !0
        }
      return !1
    }
function tn(e, n) {
  if (typeof e == 'string') {
    if (!n.nodes[e])
      throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`)
    return n.nodes[e]
  }
  return e
}
var NH =
    (e) =>
    ({ tr: n, state: t, dispatch: r }) => {
      const i = tn(e, t.schema),
        s = n.selection.$anchor
      for (let o = s.depth; o > 0; o -= 1)
        if (s.node(o).type === i) {
          if (r) {
            const l = s.before(o),
              c = s.after(o)
            n.delete(l, c).scrollIntoView()
          }
          return !0
        }
      return !1
    },
  IH =
    (e) =>
    ({ tr: n, dispatch: t }) => {
      const { from: r, to: i } = e
      return (t && n.delete(r, i), !0)
    },
  DH =
    () =>
    ({ state: e, dispatch: n }) =>
      ug(e, n),
  jH =
    () =>
    ({ commands: e }) =>
      e.keyboardShortcut('Enter'),
  LH =
    () =>
    ({ state: e, dispatch: n }) =>
      S$(e, n)
function Cg(e) {
  return Object.prototype.toString.call(e) === '[object RegExp]'
}
function zu(e, n, t = { strict: !0 }) {
  const r = Object.keys(n)
  return r.length
    ? r.every((i) => (t.strict ? n[i] === e[i] : Cg(n[i]) ? n[i].test(e[i]) : n[i] === e[i]))
    : !0
}
function $S(e, n, t = {}) {
  return e.find(
    (r) => r.type === n && zu(Object.fromEntries(Object.keys(t).map((i) => [i, r.attrs[i]])), t),
  )
}
function u2(e, n, t = {}) {
  return !!$S(e, n, t)
}
function Mg(e, n, t) {
  var r
  if (!e || !n) return
  let i = e.parent.childAfter(e.parentOffset)
  if (
    ((!i.node || !i.node.marks.some((u) => u.type === n)) &&
      (i = e.parent.childBefore(e.parentOffset)),
    !i.node ||
      !i.node.marks.some((u) => u.type === n) ||
      ((t = t || ((r = i.node.marks[0]) == null ? void 0 : r.attrs)), !$S([...i.node.marks], n, t)))
  )
    return
  let o = i.index,
    a = e.start() + i.offset,
    l = o + 1,
    c = a + i.node.nodeSize
  for (; o > 0 && u2([...e.parent.child(o - 1).marks], n, t); )
    ((o -= 1), (a -= e.parent.child(o).nodeSize))
  for (; l < e.parent.childCount && u2([...e.parent.child(l).marks], n, t); )
    ((c += e.parent.child(l).nodeSize), (l += 1))
  return { from: a, to: c }
}
function ai(e, n) {
  if (typeof e == 'string') {
    if (!n.marks[e])
      throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`)
    return n.marks[e]
  }
  return e
}
var FH =
    (e, n = {}) =>
    ({ tr: t, state: r, dispatch: i }) => {
      const s = ai(e, r.schema),
        { doc: o, selection: a } = t,
        { $from: l, from: c, to: u } = a
      if (i) {
        const f = Mg(l, s, n)
        if (f && f.from <= c && f.to >= u) {
          const d = oe.create(o, f.from, f.to)
          t.setSelection(d)
        }
      }
      return !0
    },
  BH = (e) => (n) => {
    const t = typeof e == 'function' ? e(n) : e
    for (let r = 0; r < t.length; r += 1) if (t[r](n)) return !0
    return !1
  }
function VS(e) {
  return e instanceof oe
}
function ms(e = 0, n = 0, t = 0) {
  return Math.min(Math.max(e, n), t)
}
function HS(e, n = null) {
  if (!n) return null
  const t = ye.atStart(e),
    r = ye.atEnd(e)
  if (n === 'start' || n === !0) return t
  if (n === 'end') return r
  const i = t.from,
    s = r.to
  return n === 'all'
    ? oe.create(e, ms(0, i, s), ms(e.content.size, i, s))
    : oe.create(e, ms(n, i, s), ms(n, i, s))
}
function zH() {
  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent)
}
function Eg() {
  return (
    ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(
      navigator.platform,
    ) ||
    (navigator.userAgent.includes('Mac') && 'ontouchend' in document)
  )
}
var $H =
    (e = null, n = {}) =>
    ({ editor: t, view: r, tr: i, dispatch: s }) => {
      n = { scrollIntoView: !0, ...n }
      const o = () => {
        ;((Eg() || zH()) && r.dom.focus(),
          requestAnimationFrame(() => {
            t.isDestroyed || (r.focus(), n?.scrollIntoView && t.commands.scrollIntoView())
          }))
      }
      if ((r.hasFocus() && e === null) || e === !1) return !0
      if (s && e === null && !VS(t.state.selection)) return (o(), !0)
      const a = HS(i.doc, e) || t.state.selection,
        l = t.state.selection.eq(a)
      return (
        s && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()),
        !0
      )
    },
  VH = (e, n) => (t) => e.every((r, i) => n(r, { ...t, index: i })),
  HH =
    (e, n) =>
    ({ tr: t, commands: r }) =>
      r.insertContentAt({ from: t.selection.from, to: t.selection.to }, e, n),
  US = (e) => {
    const n = e.childNodes
    for (let t = n.length - 1; t >= 0; t -= 1) {
      const r = n[t]
      r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
        ? e.removeChild(r)
        : r.nodeType === 1 && US(r)
    }
    return e
  }
function _c(e) {
  if (typeof window > 'u')
    throw new Error(
      '[tiptap error]: there is no window object available, so this function cannot be used',
    )
  const n = `<body>${e}</body>`,
    t = new window.DOMParser().parseFromString(n, 'text/html').body
  return US(t)
}
function wl(e, n, t) {
  if (e instanceof Li || e instanceof St) return e
  t = { slice: !0, parseOptions: {}, ...t }
  const r = typeof e == 'object' && e !== null,
    i = typeof e == 'string'
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0) return St.fromArray(e.map((a) => n.nodeFromJSON(a)))
      const o = n.nodeFromJSON(e)
      return (t.errorOnInvalidContent && o.check(), o)
    } catch (s) {
      if (t.errorOnInvalidContent)
        throw new Error('[tiptap error]: Invalid JSON content', { cause: s })
      return (
        console.warn('[tiptap warn]: Invalid content.', 'Passed value:', e, 'Error:', s),
        wl('', n, t)
      )
    }
  if (i) {
    if (t.errorOnInvalidContent) {
      let o = !1,
        a = ''
      const l = new T5({
        topNode: n.spec.topNode,
        marks: n.spec.marks,
        nodes: n.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: 'inline*',
            group: 'block',
            parseDOM: [
              {
                tag: '*',
                getAttrs: (c) => ((o = !0), (a = typeof c == 'string' ? c : c.outerHTML), null),
              },
            ],
          },
        }),
      })
      if (
        (t.slice
          ? Fi.fromSchema(l).parseSlice(_c(e), t.parseOptions)
          : Fi.fromSchema(l).parse(_c(e), t.parseOptions),
        t.errorOnInvalidContent && o)
      )
        throw new Error('[tiptap error]: Invalid HTML content', {
          cause: new Error(`Invalid element found: ${a}`),
        })
    }
    const s = Fi.fromSchema(n)
    return t.slice ? s.parseSlice(_c(e), t.parseOptions).content : s.parse(_c(e), t.parseOptions)
  }
  return wl('', n, t)
}
function UH(e, n, t) {
  const r = e.steps.length - 1
  if (r < n) return
  const i = e.steps[r]
  if (!(i instanceof cn || i instanceof un)) return
  const s = e.mapping.maps[r]
  let o = 0
  ;(s.forEach((a, l, c, u) => {
    o === 0 && (o = u)
  }),
    e.setSelection(ye.near(e.doc.resolve(o), t)))
}
var qH = (e) => !('type' in e),
  WH =
    (e, n, t) =>
    ({ tr: r, dispatch: i, editor: s }) => {
      var o
      if (i) {
        t = {
          parseOptions: s.options.parseOptions,
          updateSelection: !0,
          applyInputRules: !1,
          applyPasteRules: !1,
          ...t,
        }
        let a
        const l = (m) => {
            s.emit('contentError', {
              editor: s,
              error: m,
              disableCollaboration: () => {
                'collaboration' in s.storage &&
                  typeof s.storage.collaboration == 'object' &&
                  s.storage.collaboration &&
                  (s.storage.collaboration.isDisabled = !0)
              },
            })
          },
          c = { preserveWhitespace: 'full', ...t.parseOptions }
        if (!t.errorOnInvalidContent && !s.options.enableContentCheck && s.options.emitContentError)
          try {
            wl(n, s.schema, { parseOptions: c, errorOnInvalidContent: !0 })
          } catch (m) {
            l(m)
          }
        try {
          a = wl(n, s.schema, {
            parseOptions: c,
            errorOnInvalidContent:
              (o = t.errorOnInvalidContent) != null ? o : s.options.enableContentCheck,
          })
        } catch (m) {
          return (l(m), !1)
        }
        let { from: u, to: f } =
            typeof e == 'number' ? { from: e, to: e } : { from: e.from, to: e.to },
          d = !0,
          h = !0
        if (
          ((qH(a) ? a : [a]).forEach((m) => {
            ;(m.check(), (d = d ? m.isText && m.marks.length === 0 : !1), (h = h ? m.isBlock : !1))
          }),
          u === f && h)
        ) {
          const { parent: m } = r.doc.resolve(u)
          m.isTextblock && !m.type.spec.code && !m.childCount && ((u -= 1), (f += 1))
        }
        let g
        if (d) {
          if (Array.isArray(n)) g = n.map((m) => m.text || '').join('')
          else if (n instanceof St) {
            let m = ''
            ;(n.forEach((y) => {
              y.text && (m += y.text)
            }),
              (g = m))
          } else typeof n == 'object' && n && n.text ? (g = n.text) : (g = n)
          r.insertText(g, u, f)
        } else {
          g = a
          const m = r.doc.resolve(u),
            y = m.node(),
            b = m.parentOffset === 0,
            w = y.isText || y.isTextblock,
            C = y.content.size > 0
          ;(b && w && C && (u = Math.max(0, u - 1)), r.replaceWith(u, f, g))
        }
        ;(t.updateSelection && UH(r, r.steps.length - 1, -1),
          t.applyInputRules && r.setMeta('applyInputRules', { from: u, text: g }),
          t.applyPasteRules && r.setMeta('applyPasteRules', { from: u, text: g }))
      }
      return !0
    },
  KH =
    () =>
    ({ state: e, dispatch: n }) =>
      v$(e, n),
  GH =
    () =>
    ({ state: e, dispatch: n }) =>
      w$(e, n),
  XH =
    () =>
    ({ state: e, dispatch: n }) =>
      G5(e, n),
  YH =
    () =>
    ({ state: e, dispatch: n }) =>
      J5(e, n),
  ZH =
    () =>
    ({ state: e, dispatch: n, tr: t }) => {
      try {
        const r = Xf(e.doc, e.selection.$from.pos, -1)
        return r == null ? !1 : (t.join(r, 2), n && n(t), !0)
      } catch {
        return !1
      }
    },
  JH =
    () =>
    ({ state: e, dispatch: n, tr: t }) => {
      try {
        const r = Xf(e.doc, e.selection.$from.pos, 1)
        return r == null ? !1 : (t.join(r, 2), n && n(t), !0)
      } catch {
        return !1
      }
    },
  QH =
    () =>
    ({ state: e, dispatch: n }) =>
      y$(e, n),
  tU =
    () =>
    ({ state: e, dispatch: n }) =>
      b$(e, n)
function qS() {
  return typeof navigator < 'u' ? /Mac/.test(navigator.platform) : !1
}
function eU(e) {
  const n = e.split(/-(?!$)/)
  let t = n[n.length - 1]
  t === 'Space' && (t = ' ')
  let r, i, s, o
  for (let a = 0; a < n.length - 1; a += 1) {
    const l = n[a]
    if (/^(cmd|meta|m)$/i.test(l)) o = !0
    else if (/^a(lt)?$/i.test(l)) r = !0
    else if (/^(c|ctrl|control)$/i.test(l)) i = !0
    else if (/^s(hift)?$/i.test(l)) s = !0
    else if (/^mod$/i.test(l)) Eg() || qS() ? (o = !0) : (i = !0)
    else throw new Error(`Unrecognized modifier name: ${l}`)
  }
  return (
    r && (t = `Alt-${t}`),
    i && (t = `Ctrl-${t}`),
    o && (t = `Meta-${t}`),
    s && (t = `Shift-${t}`),
    t
  )
}
var nU =
  (e) =>
  ({ editor: n, view: t, tr: r, dispatch: i }) => {
    const s = eU(e).split(/-(?!$)/),
      o = s.find((c) => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(c)),
      a = new KeyboardEvent('keydown', {
        key: o === 'Space' ? ' ' : o,
        altKey: s.includes('Alt'),
        ctrlKey: s.includes('Ctrl'),
        metaKey: s.includes('Meta'),
        shiftKey: s.includes('Shift'),
        bubbles: !0,
        cancelable: !0,
      }),
      l = n.captureTransaction(() => {
        t.someProp('handleKeyDown', (c) => c(t, a))
      })
    return (
      l?.steps.forEach((c) => {
        const u = c.map(r.mapping)
        u && i && r.maybeStep(u)
      }),
      !0
    )
  }
function Gi(e, n, t = {}) {
  const { from: r, to: i, empty: s } = e.selection,
    o = n ? tn(n, e.schema) : null,
    a = []
  e.doc.nodesBetween(r, i, (f, d) => {
    if (f.isText) return
    const h = Math.max(r, d),
      p = Math.min(i, d + f.nodeSize)
    a.push({ node: f, from: h, to: p })
  })
  const l = i - r,
    c = a
      .filter((f) => (o ? o.name === f.node.type.name : !0))
      .filter((f) => zu(f.node.attrs, t, { strict: !1 }))
  return s ? !!c.length : c.reduce((f, d) => f + d.to - d.from, 0) >= l
}
var rU =
    (e, n = {}) =>
    ({ state: t, dispatch: r }) => {
      const i = tn(e, t.schema)
      return Gi(t, i, n) ? x$(t, r) : !1
    },
  iU =
    () =>
    ({ state: e, dispatch: n }) =>
      nS(e, n),
  sU =
    (e) =>
    ({ state: n, dispatch: t }) => {
      const r = tn(e, n.schema)
      return N$(r)(n, t)
    },
  oU =
    () =>
    ({ state: e, dispatch: n }) =>
      tS(e, n)
function rd(e, n) {
  return n.nodes[e] ? 'node' : n.marks[e] ? 'mark' : null
}
function f2(e, n) {
  const t = typeof n == 'string' ? [n] : n
  return Object.keys(e).reduce((r, i) => (t.includes(i) || (r[i] = e[i]), r), {})
}
var aU =
    (e, n) =>
    ({ tr: t, state: r, dispatch: i }) => {
      let s = null,
        o = null
      const a = rd(typeof e == 'string' ? e : e.name, r.schema)
      return a
        ? (a === 'node' && (s = tn(e, r.schema)),
          a === 'mark' && (o = ai(e, r.schema)),
          i &&
            t.selection.ranges.forEach((l) => {
              r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
                ;(s && s === c.type && t.setNodeMarkup(u, void 0, f2(c.attrs, n)),
                  o &&
                    c.marks.length &&
                    c.marks.forEach((f) => {
                      o === f.type && t.addMark(u, u + c.nodeSize, o.create(f2(f.attrs, n)))
                    }))
              })
            }),
          !0)
        : !1
    },
  lU =
    () =>
    ({ tr: e, dispatch: n }) => (n && e.scrollIntoView(), !0),
  cU =
    () =>
    ({ tr: e, dispatch: n }) => {
      if (n) {
        const t = new qn(e.doc)
        e.setSelection(t)
      }
      return !0
    },
  uU =
    () =>
    ({ state: e, dispatch: n }) =>
      Y5(e, n),
  fU =
    () =>
    ({ state: e, dispatch: n }) =>
      Q5(e, n),
  dU =
    () =>
    ({ state: e, dispatch: n }) =>
      C$(e, n),
  hU =
    () =>
    ({ state: e, dispatch: n }) =>
      T$(e, n),
  pU =
    () =>
    ({ state: e, dispatch: n }) =>
      E$(e, n)
function lm(e, n, t = {}, r = {}) {
  return wl(e, n, { slice: !1, parseOptions: t, errorOnInvalidContent: r.errorOnInvalidContent })
}
var mU =
  (e, { errorOnInvalidContent: n, emitUpdate: t = !0, parseOptions: r = {} } = {}) =>
  ({ editor: i, tr: s, dispatch: o, commands: a }) => {
    const { doc: l } = s
    if (r.preserveWhitespace !== 'full') {
      const c = lm(e, i.schema, r, { errorOnInvalidContent: n ?? i.options.enableContentCheck })
      return (o && s.replaceWith(0, l.content.size, c).setMeta('preventUpdate', !t), !0)
    }
    return (
      o && s.setMeta('preventUpdate', !t),
      a.insertContentAt({ from: 0, to: l.content.size }, e, {
        parseOptions: r,
        errorOnInvalidContent: n ?? i.options.enableContentCheck,
      })
    )
  }
function WS(e, n) {
  const t = ai(n, e.schema),
    { from: r, to: i, empty: s } = e.selection,
    o = []
  s
    ? (e.storedMarks && o.push(...e.storedMarks), o.push(...e.selection.$head.marks()))
    : e.doc.nodesBetween(r, i, (l) => {
        o.push(...l.marks)
      })
  const a = o.find((l) => l.type.name === t.name)
  return a ? { ...a.attrs } : {}
}
function KS(e, n) {
  const t = new U5(e)
  return (
    n.forEach((r) => {
      r.steps.forEach((i) => {
        t.step(i)
      })
    }),
    t
  )
}
function gU(e) {
  for (let n = 0; n < e.edgeCount; n += 1) {
    const { type: t } = e.edge(n)
    if (t.isTextblock && !t.hasRequiredAttrs()) return t
  }
  return null
}
function yU(e, n, t) {
  const r = []
  return (
    e.nodesBetween(n.from, n.to, (i, s) => {
      t(i) && r.push({ node: i, pos: s })
    }),
    r
  )
}
function bU(e, n) {
  for (let t = e.depth; t > 0; t -= 1) {
    const r = e.node(t)
    if (n(r)) return { pos: t > 0 ? e.before(t) : 0, start: e.start(t), depth: t, node: r }
  }
}
function id(e) {
  return (n) => bU(n.$from, e)
}
function Xt(e, n, t) {
  return e.config[n] === void 0 && e.parent
    ? Xt(e.parent, n, t)
    : typeof e.config[n] == 'function'
      ? e.config[n].bind({ ...t, parent: e.parent ? Xt(e.parent, n, t) : null })
      : e.config[n]
}
function Tg(e) {
  return e
    .map((n) => {
      const t = { name: n.name, options: n.options, storage: n.storage },
        r = Xt(n, 'addExtensions', t)
      return r ? [n, ...Tg(r())] : n
    })
    .flat(10)
}
function Ag(e, n) {
  const t = Hs.fromSchema(n).serializeFragment(e),
    i = document.implementation.createHTMLDocument().createElement('div')
  return (i.appendChild(t), i.innerHTML)
}
function GS(e) {
  return typeof e == 'function'
}
function Re(e, n = void 0, ...t) {
  return GS(e) ? (n ? e.bind(n)(...t) : e(...t)) : e
}
function vU(e = {}) {
  return Object.keys(e).length === 0 && e.constructor === Object
}
function xl(e) {
  const n = e.filter((i) => i.type === 'extension'),
    t = e.filter((i) => i.type === 'node'),
    r = e.filter((i) => i.type === 'mark')
  return { baseExtensions: n, nodeExtensions: t, markExtensions: r }
}
function XS(e) {
  const n = [],
    { nodeExtensions: t, markExtensions: r } = xl(e),
    i = [...t, ...r],
    s = {
      default: null,
      validate: void 0,
      rendered: !0,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: !0,
      isRequired: !1,
    }
  return (
    e.forEach((o) => {
      const a = { name: o.name, options: o.options, storage: o.storage, extensions: i },
        l = Xt(o, 'addGlobalAttributes', a)
      if (!l) return
      l().forEach((u) => {
        u.types.forEach((f) => {
          Object.entries(u.attributes).forEach(([d, h]) => {
            n.push({ type: f, name: d, attribute: { ...s, ...h } })
          })
        })
      })
    }),
    i.forEach((o) => {
      const a = { name: o.name, options: o.options, storage: o.storage },
        l = Xt(o, 'addAttributes', a)
      if (!l) return
      const c = l()
      Object.entries(c).forEach(([u, f]) => {
        const d = { ...s, ...f }
        ;(typeof d?.default == 'function' && (d.default = d.default()),
          d?.isRequired && d?.default === void 0 && delete d.default,
          n.push({ type: o.name, name: u, attribute: d }))
      })
    }),
    n
  )
}
function en(...e) {
  return e
    .filter((n) => !!n)
    .reduce((n, t) => {
      const r = { ...n }
      return (
        Object.entries(t).forEach(([i, s]) => {
          if (!r[i]) {
            r[i] = s
            return
          }
          if (i === 'class') {
            const a = s ? String(s).split(' ') : [],
              l = r[i] ? r[i].split(' ') : [],
              c = a.filter((u) => !l.includes(u))
            r[i] = [...l, ...c].join(' ')
          } else if (i === 'style') {
            const a = s
                ? s
                    .split(';')
                    .map((u) => u.trim())
                    .filter(Boolean)
                : [],
              l = r[i]
                ? r[i]
                    .split(';')
                    .map((u) => u.trim())
                    .filter(Boolean)
                : [],
              c = new Map()
            ;(l.forEach((u) => {
              const [f, d] = u.split(':').map((h) => h.trim())
              c.set(f, d)
            }),
              a.forEach((u) => {
                const [f, d] = u.split(':').map((h) => h.trim())
                c.set(f, d)
              }),
              (r[i] = Array.from(c.entries())
                .map(([u, f]) => `${u}: ${f}`)
                .join('; ')))
          } else r[i] = s
        }),
        r
      )
    }, {})
}
function $u(e, n) {
  return n
    .filter((t) => t.type === e.type.name)
    .filter((t) => t.attribute.rendered)
    .map((t) =>
      t.attribute.renderHTML
        ? t.attribute.renderHTML(e.attrs) || {}
        : { [t.name]: e.attrs[t.name] },
    )
    .reduce((t, r) => en(t, r), {})
}
function wU(e) {
  return typeof e != 'string'
    ? e
    : e.match(/^[+-]?(?:\d*\.)?\d+$/)
      ? Number(e)
      : e === 'true'
        ? !0
        : e === 'false'
          ? !1
          : e
}
function d2(e, n) {
  return 'style' in e
    ? e
    : {
        ...e,
        getAttrs: (t) => {
          const r = e.getAttrs ? e.getAttrs(t) : e.attrs
          if (r === !1) return !1
          const i = n.reduce((s, o) => {
            const a = o.attribute.parseHTML ? o.attribute.parseHTML(t) : wU(t.getAttribute(o.name))
            return a == null ? s : { ...s, [o.name]: a }
          }, {})
          return { ...r, ...i }
        },
      }
}
function h2(e) {
  return Object.fromEntries(
    Object.entries(e).filter(([n, t]) => (n === 'attrs' && vU(t) ? !1 : t != null)),
  )
}
function xU(e, n) {
  var t
  const r = XS(e),
    { nodeExtensions: i, markExtensions: s } = xl(e),
    o = (t = i.find((c) => Xt(c, 'topNode'))) == null ? void 0 : t.name,
    a = Object.fromEntries(
      i.map((c) => {
        const u = r.filter((y) => y.type === c.name),
          f = { name: c.name, options: c.options, storage: c.storage, editor: n },
          d = e.reduce((y, b) => {
            const w = Xt(b, 'extendNodeSchema', f)
            return { ...y, ...(w ? w(c) : {}) }
          }, {}),
          h = h2({
            ...d,
            content: Re(Xt(c, 'content', f)),
            marks: Re(Xt(c, 'marks', f)),
            group: Re(Xt(c, 'group', f)),
            inline: Re(Xt(c, 'inline', f)),
            atom: Re(Xt(c, 'atom', f)),
            selectable: Re(Xt(c, 'selectable', f)),
            draggable: Re(Xt(c, 'draggable', f)),
            code: Re(Xt(c, 'code', f)),
            whitespace: Re(Xt(c, 'whitespace', f)),
            linebreakReplacement: Re(Xt(c, 'linebreakReplacement', f)),
            defining: Re(Xt(c, 'defining', f)),
            isolating: Re(Xt(c, 'isolating', f)),
            attrs: Object.fromEntries(
              u.map((y) => {
                var b, w
                return [
                  y.name,
                  {
                    default: (b = y?.attribute) == null ? void 0 : b.default,
                    validate: (w = y?.attribute) == null ? void 0 : w.validate,
                  },
                ]
              }),
            ),
          }),
          p = Re(Xt(c, 'parseHTML', f))
        p && (h.parseDOM = p.map((y) => d2(y, u)))
        const g = Xt(c, 'renderHTML', f)
        g && (h.toDOM = (y) => g({ node: y, HTMLAttributes: $u(y, u) }))
        const m = Xt(c, 'renderText', f)
        return (m && (h.toText = m), [c.name, h])
      }),
    ),
    l = Object.fromEntries(
      s.map((c) => {
        const u = r.filter((m) => m.type === c.name),
          f = { name: c.name, options: c.options, storage: c.storage, editor: n },
          d = e.reduce((m, y) => {
            const b = Xt(y, 'extendMarkSchema', f)
            return { ...m, ...(b ? b(c) : {}) }
          }, {}),
          h = h2({
            ...d,
            inclusive: Re(Xt(c, 'inclusive', f)),
            excludes: Re(Xt(c, 'excludes', f)),
            group: Re(Xt(c, 'group', f)),
            spanning: Re(Xt(c, 'spanning', f)),
            code: Re(Xt(c, 'code', f)),
            attrs: Object.fromEntries(
              u.map((m) => {
                var y, b
                return [
                  m.name,
                  {
                    default: (y = m?.attribute) == null ? void 0 : y.default,
                    validate: (b = m?.attribute) == null ? void 0 : b.validate,
                  },
                ]
              }),
            ),
          }),
          p = Re(Xt(c, 'parseHTML', f))
        p && (h.parseDOM = p.map((m) => d2(m, u)))
        const g = Xt(c, 'renderHTML', f)
        return (g && (h.toDOM = (m) => g({ mark: m, HTMLAttributes: $u(m, u) })), [c.name, h])
      }),
    )
  return new T5({ topNode: o, nodes: a, marks: l })
}
function SU(e) {
  const n = e.filter((t, r) => e.indexOf(t) !== r)
  return Array.from(new Set(n))
}
function Rg(e) {
  return e.sort((t, r) => {
    const i = Xt(t, 'priority') || 100,
      s = Xt(r, 'priority') || 100
    return i > s ? -1 : i < s ? 1 : 0
  })
}
function YS(e) {
  const n = Rg(Tg(e)),
    t = SU(n.map((r) => r.name))
  return (
    t.length &&
      console.warn(
        `[tiptap warn]: Duplicate extension names found: [${t.map((r) => `'${r}'`).join(', ')}]. This can lead to issues.`,
      ),
    n
  )
}
function ZS(e, n, t) {
  const { from: r, to: i } = n,
    {
      blockSeparator: s = `

`,
      textSerializers: o = {},
    } = t || {}
  let a = ''
  return (
    e.nodesBetween(r, i, (l, c, u, f) => {
      var d
      l.isBlock && c > r && (a += s)
      const h = o?.[l.type.name]
      if (h) return (u && (a += h({ node: l, pos: c, parent: u, index: f, range: n })), !1)
      l.isText && (a += (d = l?.text) == null ? void 0 : d.slice(Math.max(r, c) - c, i - c))
    }),
    a
  )
}
function _U(e, n) {
  const t = { from: 0, to: e.content.size }
  return ZS(e, t, n)
}
function JS(e) {
  return Object.fromEntries(
    Object.entries(e.nodes)
      .filter(([, n]) => n.spec.toText)
      .map(([n, t]) => [n, t.spec.toText]),
  )
}
function kU(e, n) {
  const t = tn(n, e.schema),
    { from: r, to: i } = e.selection,
    s = []
  e.doc.nodesBetween(r, i, (a) => {
    s.push(a)
  })
  const o = s.reverse().find((a) => a.type.name === t.name)
  return o ? { ...o.attrs } : {}
}
function QS(e, n) {
  const t = rd(typeof n == 'string' ? n : n.name, e.schema)
  return t === 'node' ? kU(e, n) : t === 'mark' ? WS(e, n) : {}
}
function CU(e, n = JSON.stringify) {
  const t = {}
  return e.filter((r) => {
    const i = n(r)
    return Object.prototype.hasOwnProperty.call(t, i) ? !1 : (t[i] = !0)
  })
}
function MU(e) {
  const n = CU(e)
  return n.length === 1
    ? n
    : n.filter(
        (t, r) =>
          !n
            .filter((s, o) => o !== r)
            .some(
              (s) =>
                t.oldRange.from >= s.oldRange.from &&
                t.oldRange.to <= s.oldRange.to &&
                t.newRange.from >= s.newRange.from &&
                t.newRange.to <= s.newRange.to,
            ),
      )
}
function t_(e) {
  const { mapping: n, steps: t } = e,
    r = []
  return (
    n.maps.forEach((i, s) => {
      const o = []
      if (i.ranges.length)
        i.forEach((a, l) => {
          o.push({ from: a, to: l })
        })
      else {
        const { from: a, to: l } = t[s]
        if (a === void 0 || l === void 0) return
        o.push({ from: a, to: l })
      }
      o.forEach(({ from: a, to: l }) => {
        const c = n.slice(s).map(a, -1),
          u = n.slice(s).map(l),
          f = n.invert().map(c, -1),
          d = n.invert().map(u)
        r.push({ oldRange: { from: f, to: d }, newRange: { from: c, to: u } })
      })
    }),
    MU(r)
  )
}
function Og(e, n, t) {
  const r = []
  return (
    e === n
      ? t
          .resolve(e)
          .marks()
          .forEach((i) => {
            const s = t.resolve(e),
              o = Mg(s, i.type)
            o && r.push({ mark: i, ...o })
          })
      : t.nodesBetween(e, n, (i, s) => {
          !i ||
            i?.nodeSize === void 0 ||
            r.push(...i.marks.map((o) => ({ from: s, to: s + i.nodeSize, mark: o })))
        }),
    r
  )
}
var EU = (e, n, t, r = 20) => {
  const i = e.doc.resolve(t)
  let s = r,
    o = null
  for (; s > 0 && o === null; ) {
    const a = i.node(s)
    a?.type.name === n ? (o = a) : (s -= 1)
  }
  return [o, s]
}
function wh(e, n) {
  return n.nodes[e] || n.marks[e] || null
}
function Vc(e, n, t) {
  return Object.fromEntries(
    Object.entries(t).filter(([r]) => {
      const i = e.find((s) => s.type === n && s.name === r)
      return i ? i.attribute.keepOnSplit : !1
    }),
  )
}
var TU = (e, n = 500) => {
  let t = ''
  const r = e.parentOffset
  return (
    e.parent.nodesBetween(Math.max(0, r - n), r, (i, s, o, a) => {
      var l, c
      const u =
        ((c = (l = i.type.spec).toText) == null
          ? void 0
          : c.call(l, { node: i, pos: s, parent: o, index: a })) ||
        i.textContent ||
        '%leaf%'
      t += i.isAtom && !i.isText ? u : u.slice(0, Math.max(0, r - s))
    }),
    t
  )
}
function cm(e, n, t = {}) {
  const { empty: r, ranges: i } = e.selection,
    s = n ? ai(n, e.schema) : null
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks())
      .filter((f) => (s ? s.name === f.type.name : !0))
      .find((f) => zu(f.attrs, t, { strict: !1 }))
  let o = 0
  const a = []
  if (
    (i.forEach(({ $from: f, $to: d }) => {
      const h = f.pos,
        p = d.pos
      e.doc.nodesBetween(h, p, (g, m) => {
        if (!g.isText && !g.marks.length) return
        const y = Math.max(h, m),
          b = Math.min(p, m + g.nodeSize),
          w = b - y
        ;((o += w), a.push(...g.marks.map((C) => ({ mark: C, from: y, to: b }))))
      })
    }),
    o === 0)
  )
    return !1
  const l = a
      .filter((f) => (s ? s.name === f.mark.type.name : !0))
      .filter((f) => zu(f.mark.attrs, t, { strict: !1 }))
      .reduce((f, d) => f + d.to - d.from, 0),
    c = a
      .filter((f) => (s ? f.mark.type !== s && f.mark.type.excludes(s) : !0))
      .reduce((f, d) => f + d.to - d.from, 0)
  return (l > 0 ? l + c : l) >= o
}
function AU(e, n, t = {}) {
  if (!n) return Gi(e, null, t) || cm(e, null, t)
  const r = rd(n, e.schema)
  return r === 'node' ? Gi(e, n, t) : r === 'mark' ? cm(e, n, t) : !1
}
var RU = (e, n) => {
    const { $from: t, $to: r, $anchor: i } = e.selection
    if (n) {
      const s = id((a) => a.type.name === n)(e.selection)
      if (!s) return !1
      const o = e.doc.resolve(s.pos + 1)
      return i.pos + 1 === o.end()
    }
    return !(r.parentOffset < r.parent.nodeSize - 2 || t.pos !== r.pos)
  },
  OU = (e) => {
    const { $from: n, $to: t } = e.selection
    return !(n.parentOffset > 0 || n.pos !== t.pos)
  }
function p2(e, n) {
  return Array.isArray(n) ? n.some((t) => (typeof t == 'string' ? t : t.name) === e.name) : n
}
function m2(e, n) {
  const { nodeExtensions: t } = xl(n),
    r = t.find((o) => o.name === e)
  if (!r) return !1
  const i = { name: r.name, options: r.options, storage: r.storage },
    s = Re(Xt(r, 'group', i))
  return typeof s != 'string' ? !1 : s.split(' ').includes('list')
}
function sd(e, { checkChildren: n = !0, ignoreWhitespace: t = !1 } = {}) {
  var r
  if (t) {
    if (e.type.name === 'hardBreak') return !0
    if (e.isText) return /^\s*$/m.test((r = e.text) != null ? r : '')
  }
  if (e.isText) return !e.text
  if (e.isAtom || e.isLeaf) return !1
  if (e.content.childCount === 0) return !0
  if (n) {
    let i = !0
    return (
      e.content.forEach((s) => {
        i !== !1 && (sd(s, { ignoreWhitespace: t, checkChildren: n }) || (i = !1))
      }),
      i
    )
  }
  return !1
}
function e_(e) {
  return e instanceof Zt
}
function PU(e, n, t) {
  var r
  const { selection: i } = n
  let s = null
  if ((VS(i) && (s = i.$cursor), s)) {
    const a = (r = e.storedMarks) != null ? r : s.marks()
    return s.parent.type.allowsMarkType(t) && (!!t.isInSet(a) || !a.some((c) => c.type.excludes(t)))
  }
  const { ranges: o } = i
  return o.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(t) : !1
    return (
      e.doc.nodesBetween(a.pos, l.pos, (u, f, d) => {
        if (c) return !1
        if (u.isInline) {
          const h = !d || d.type.allowsMarkType(t),
            p = !!t.isInSet(u.marks) || !u.marks.some((g) => g.type.excludes(t))
          c = h && p
        }
        return !c
      }),
      c
    )
  })
}
var NU =
    (e, n = {}) =>
    ({ tr: t, state: r, dispatch: i }) => {
      const { selection: s } = t,
        { empty: o, ranges: a } = s,
        l = ai(e, r.schema)
      if (i)
        if (o) {
          const c = WS(r, l)
          t.addStoredMark(l.create({ ...c, ...n }))
        } else
          a.forEach((c) => {
            const u = c.$from.pos,
              f = c.$to.pos
            r.doc.nodesBetween(u, f, (d, h) => {
              const p = Math.max(h, u),
                g = Math.min(h + d.nodeSize, f)
              d.marks.find((y) => y.type === l)
                ? d.marks.forEach((y) => {
                    l === y.type && t.addMark(p, g, l.create({ ...y.attrs, ...n }))
                  })
                : t.addMark(p, g, l.create(n))
            })
          })
      return PU(r, t, l)
    },
  IU =
    (e, n) =>
    ({ tr: t }) => (t.setMeta(e, n), !0),
  DU =
    (e, n = {}) =>
    ({ state: t, dispatch: r, chain: i }) => {
      const s = tn(e, t.schema)
      let o
      return (
        t.selection.$anchor.sameParent(t.selection.$head) && (o = t.selection.$anchor.parent.attrs),
        s.isTextblock
          ? i()
              .command(({ commands: a }) => (Rv(s, { ...o, ...n })(t) ? !0 : a.clearNodes()))
              .command(({ state: a }) => Rv(s, { ...o, ...n })(a, r))
              .run()
          : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'),
            !1)
      )
    },
  jU =
    (e) =>
    ({ tr: n, dispatch: t }) => {
      if (t) {
        const { doc: r } = n,
          i = ms(e, 0, r.content.size),
          s = Zt.create(r, i)
        n.setSelection(s)
      }
      return !0
    },
  LU =
    (e) =>
    ({ tr: n, dispatch: t }) => {
      if (t) {
        const { doc: r } = n,
          { from: i, to: s } = typeof e == 'number' ? { from: e, to: e } : e,
          o = oe.atStart(r).from,
          a = oe.atEnd(r).to,
          l = ms(i, o, a),
          c = ms(s, o, a),
          u = oe.create(r, l, c)
        n.setSelection(u)
      }
      return !0
    },
  FU =
    (e) =>
    ({ state: n, dispatch: t }) => {
      const r = tn(e, n.schema)
      return j$(r)(n, t)
    }
function g2(e, n) {
  const t = e.storedMarks || (e.selection.$to.parentOffset && e.selection.$from.marks())
  if (t) {
    const r = t.filter((i) => n?.includes(i.type.name))
    e.tr.ensureMarks(r)
  }
}
var BU =
    ({ keepMarks: e = !0 } = {}) =>
    ({ tr: n, state: t, dispatch: r, editor: i }) => {
      const { selection: s, doc: o } = n,
        { $from: a, $to: l } = s,
        c = i.extensionManager.attributes,
        u = Vc(c, a.node().type.name, a.node().attrs)
      if (s instanceof Zt && s.node.isBlock)
        return !a.parentOffset || !Qr(o, a.pos)
          ? !1
          : (r && (e && g2(t, i.extensionManager.splittableMarks), n.split(a.pos).scrollIntoView()),
            !0)
      if (!a.parent.isBlock) return !1
      const f = l.parentOffset === l.parent.content.size,
        d = a.depth === 0 ? void 0 : gU(a.node(-1).contentMatchAt(a.indexAfter(-1)))
      let h = f && d ? [{ type: d, attrs: u }] : void 0,
        p = Qr(n.doc, n.mapping.map(a.pos), 1, h)
      if (
        (!h &&
          !p &&
          Qr(n.doc, n.mapping.map(a.pos), 1, d ? [{ type: d }] : void 0) &&
          ((p = !0), (h = d ? [{ type: d, attrs: u }] : void 0)),
        r)
      ) {
        if (
          p &&
          (s instanceof oe && n.deleteSelection(),
          n.split(n.mapping.map(a.pos), 1, h),
          d && !f && !a.parentOffset && a.parent.type !== d)
        ) {
          const g = n.mapping.map(a.before()),
            m = n.doc.resolve(g)
          a.node(-1).canReplaceWith(m.index(), m.index() + 1, d) &&
            n.setNodeMarkup(n.mapping.map(a.before()), d)
        }
        ;(e && g2(t, i.extensionManager.splittableMarks), n.scrollIntoView())
      }
      return p
    },
  zU =
    (e, n = {}) =>
    ({ tr: t, state: r, dispatch: i, editor: s }) => {
      var o
      const a = tn(e, r.schema),
        { $from: l, $to: c } = r.selection,
        u = r.selection.node
      if ((u && u.isBlock) || l.depth < 2 || !l.sameParent(c)) return !1
      const f = l.node(-1)
      if (f.type !== a) return !1
      const d = s.extensionManager.attributes
      if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
        if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
          return !1
        if (i) {
          let y = St.empty
          const b = l.index(-1) ? 1 : l.index(-2) ? 2 : 3
          for (let E = l.depth - b; E >= l.depth - 3; E -= 1) y = St.from(l.node(E).copy(y))
          const w =
              l.indexAfter(-1) < l.node(-2).childCount
                ? 1
                : l.indexAfter(-2) < l.node(-3).childCount
                  ? 2
                  : 3,
            C = { ...Vc(d, l.node().type.name, l.node().attrs), ...n },
            T = ((o = a.contentMatch.defaultType) == null ? void 0 : o.createAndFill(C)) || void 0
          y = y.append(St.from(a.createAndFill(null, T) || void 0))
          const I = l.before(l.depth - (b - 1))
          t.replace(I, l.after(-w), new jt(y, 4 - b, 0))
          let B = -1
          ;(t.doc.nodesBetween(I, t.doc.content.size, (E, O) => {
            if (B > -1) return !1
            E.isTextblock && E.content.size === 0 && (B = O + 1)
          }),
            B > -1 && t.setSelection(oe.near(t.doc.resolve(B))),
            t.scrollIntoView())
        }
        return !0
      }
      const h = c.pos === l.end() ? f.contentMatchAt(0).defaultType : null,
        p = { ...Vc(d, f.type.name, f.attrs), ...n },
        g = { ...Vc(d, l.node().type.name, l.node().attrs), ...n }
      t.delete(l.pos, c.pos)
      const m = h
        ? [
            { type: a, attrs: p },
            { type: h, attrs: g },
          ]
        : [{ type: a, attrs: p }]
      if (!Qr(t.doc, l.pos, 2)) return !1
      if (i) {
        const { selection: y, storedMarks: b } = r,
          { splittableMarks: w } = s.extensionManager,
          C = b || (y.$to.parentOffset && y.$from.marks())
        if ((t.split(l.pos, 2, m).scrollIntoView(), !C || !i)) return !0
        const T = C.filter((I) => w.includes(I.type.name))
        t.ensureMarks(T)
      }
      return !0
    },
  xh = (e, n) => {
    const t = id((o) => o.type === n)(e.selection)
    if (!t) return !0
    const r = e.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth)
    if (r === void 0) return !0
    const i = e.doc.nodeAt(r)
    return (t.node.type === i?.type && Yi(e.doc, t.pos) && e.join(t.pos), !0)
  },
  Sh = (e, n) => {
    const t = id((o) => o.type === n)(e.selection)
    if (!t) return !0
    const r = e.doc.resolve(t.start).after(t.depth)
    if (r === void 0) return !0
    const i = e.doc.nodeAt(r)
    return (t.node.type === i?.type && Yi(e.doc, r) && e.join(r), !0)
  },
  $U =
    (e, n, t, r = {}) =>
    ({ editor: i, tr: s, state: o, dispatch: a, chain: l, commands: c, can: u }) => {
      const { extensions: f, splittableMarks: d } = i.extensionManager,
        h = tn(e, o.schema),
        p = tn(n, o.schema),
        { selection: g, storedMarks: m } = o,
        { $from: y, $to: b } = g,
        w = y.blockRange(b),
        C = m || (g.$to.parentOffset && g.$from.marks())
      if (!w) return !1
      const T = id((I) => m2(I.type.name, f))(g)
      if (w.depth >= 1 && T && w.depth - T.depth <= 1) {
        if (T.node.type === h) return c.liftListItem(p)
        if (m2(T.node.type.name, f) && h.validContent(T.node.content) && a)
          return l()
            .command(() => (s.setNodeMarkup(T.pos, h), !0))
            .command(() => xh(s, h))
            .command(() => Sh(s, h))
            .run()
      }
      return !t || !C || !a
        ? l()
            .command(() => (u().wrapInList(h, r) ? !0 : c.clearNodes()))
            .wrapInList(h, r)
            .command(() => xh(s, h))
            .command(() => Sh(s, h))
            .run()
        : l()
            .command(() => {
              const I = u().wrapInList(h, r),
                B = C.filter((E) => d.includes(E.type.name))
              return (s.ensureMarks(B), I ? !0 : c.clearNodes())
            })
            .wrapInList(h, r)
            .command(() => xh(s, h))
            .command(() => Sh(s, h))
            .run()
    },
  VU =
    (e, n = {}, t = {}) =>
    ({ state: r, commands: i }) => {
      const { extendEmptyMarkRange: s = !1 } = t,
        o = ai(e, r.schema)
      return cm(r, o, n) ? i.unsetMark(o, { extendEmptyMarkRange: s }) : i.setMark(o, n)
    },
  HU =
    (e, n, t = {}) =>
    ({ state: r, commands: i }) => {
      const s = tn(e, r.schema),
        o = tn(n, r.schema),
        a = Gi(r, s, t)
      let l
      return (
        r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs),
        a ? i.setNode(o, l) : i.setNode(s, { ...l, ...t })
      )
    },
  UU =
    (e, n = {}) =>
    ({ state: t, commands: r }) => {
      const i = tn(e, t.schema)
      return Gi(t, i, n) ? r.lift(i) : r.wrapIn(i, n)
    },
  qU =
    () =>
    ({ state: e, dispatch: n }) => {
      const t = e.plugins
      for (let r = 0; r < t.length; r += 1) {
        const i = t[r]
        let s
        if (i.spec.isInputRules && (s = i.getState(e))) {
          if (n) {
            const o = e.tr,
              a = s.transform
            for (let l = a.steps.length - 1; l >= 0; l -= 1) o.step(a.steps[l].invert(a.docs[l]))
            if (s.text) {
              const l = o.doc.resolve(s.from).marks()
              o.replaceWith(s.from, s.to, e.schema.text(s.text, l))
            } else o.delete(s.from, s.to)
          }
          return !0
        }
      }
      return !1
    },
  WU =
    () =>
    ({ tr: e, dispatch: n }) => {
      const { selection: t } = e,
        { empty: r, ranges: i } = t
      return (
        r ||
          (n &&
            i.forEach((s) => {
              e.removeMark(s.$from.pos, s.$to.pos)
            })),
        !0
      )
    },
  KU =
    (e, n = {}) =>
    ({ tr: t, state: r, dispatch: i }) => {
      var s
      const { extendEmptyMarkRange: o = !1 } = n,
        { selection: a } = t,
        l = ai(e, r.schema),
        { $from: c, empty: u, ranges: f } = a
      if (!i) return !0
      if (u && o) {
        let { from: d, to: h } = a
        const p = (s = c.marks().find((m) => m.type === l)) == null ? void 0 : s.attrs,
          g = Mg(c, l, p)
        ;(g && ((d = g.from), (h = g.to)), t.removeMark(d, h, l))
      } else
        f.forEach((d) => {
          t.removeMark(d.$from.pos, d.$to.pos, l)
        })
      return (t.removeStoredMark(l), !0)
    },
  GU =
    (e, n = {}) =>
    ({ tr: t, state: r, dispatch: i }) => {
      let s = null,
        o = null
      const a = rd(typeof e == 'string' ? e : e.name, r.schema)
      return a
        ? (a === 'node' && (s = tn(e, r.schema)),
          a === 'mark' && (o = ai(e, r.schema)),
          i &&
            t.selection.ranges.forEach((l) => {
              const c = l.$from.pos,
                u = l.$to.pos
              let f, d, h, p
              ;(t.selection.empty
                ? r.doc.nodesBetween(c, u, (g, m) => {
                    s &&
                      s === g.type &&
                      ((h = Math.max(m, c)), (p = Math.min(m + g.nodeSize, u)), (f = m), (d = g))
                  })
                : r.doc.nodesBetween(c, u, (g, m) => {
                    ;(m < c &&
                      s &&
                      s === g.type &&
                      ((h = Math.max(m, c)), (p = Math.min(m + g.nodeSize, u)), (f = m), (d = g)),
                      m >= c &&
                        m <= u &&
                        (s && s === g.type && t.setNodeMarkup(m, void 0, { ...g.attrs, ...n }),
                        o &&
                          g.marks.length &&
                          g.marks.forEach((y) => {
                            if (o === y.type) {
                              const b = Math.max(m, c),
                                w = Math.min(m + g.nodeSize, u)
                              t.addMark(b, w, o.create({ ...y.attrs, ...n }))
                            }
                          })))
                  }),
                d &&
                  (f !== void 0 && t.setNodeMarkup(f, void 0, { ...d.attrs, ...n }),
                  o &&
                    d.marks.length &&
                    d.marks.forEach((g) => {
                      o === g.type && t.addMark(h, p, o.create({ ...g.attrs, ...n }))
                    })))
            }),
          !0)
        : !1
    },
  XU =
    (e, n = {}) =>
    ({ state: t, dispatch: r }) => {
      const i = tn(e, t.schema)
      return A$(i, n)(t, r)
    },
  YU =
    (e, n = {}) =>
    ({ state: t, dispatch: r }) => {
      const i = tn(e, t.schema)
      return R$(i, n)(t, r)
    },
  ZU = class {
    constructor() {
      this.callbacks = {}
    }
    on(e, n) {
      return (this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this)
    }
    emit(e, ...n) {
      const t = this.callbacks[e]
      return (t && t.forEach((r) => r.apply(this, n)), this)
    }
    off(e, n) {
      const t = this.callbacks[e]
      return (
        t && (n ? (this.callbacks[e] = t.filter((r) => r !== n)) : delete this.callbacks[e]),
        this
      )
    }
    once(e, n) {
      const t = (...r) => {
        ;(this.off(e, t), n.apply(this, r))
      }
      return this.on(e, t)
    }
    removeAllListeners() {
      this.callbacks = {}
    }
  },
  od = class {
    constructor(e) {
      var n
      ;((this.find = e.find),
        (this.handler = e.handler),
        (this.undoable = (n = e.undoable) != null ? n : !0))
    }
  },
  JU = (e, n) => {
    if (Cg(n)) return n.exec(e)
    const t = n(e)
    if (!t) return null
    const r = [t.text]
    return (
      (r.index = t.index),
      (r.input = e),
      (r.data = t.data),
      t.replaceWith &&
        (t.text.includes(t.replaceWith) ||
          console.warn(
            '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".',
          ),
        r.push(t.replaceWith)),
      r
    )
  }
function kc(e) {
  var n
  const { editor: t, from: r, to: i, text: s, rules: o, plugin: a } = e,
    { view: l } = t
  if (l.composing) return !1
  const c = l.state.doc.resolve(r)
  if (
    c.parent.type.spec.code ||
    ((n = c.nodeBefore || c.nodeAfter) != null && n.marks.find((d) => d.type.spec.code))
  )
    return !1
  let u = !1
  const f = TU(c) + s
  return (
    o.forEach((d) => {
      if (u) return
      const h = JU(f, d.find)
      if (!h) return
      const p = l.state.tr,
        g = ed({ state: l.state, transaction: p }),
        m = { from: r - (h[0].length - s.length), to: i },
        { commands: y, chain: b, can: w } = new nd({ editor: t, state: g })
      d.handler({ state: g, range: m, match: h, commands: y, chain: b, can: w }) === null ||
        !p.steps.length ||
        (d.undoable && p.setMeta(a, { transform: p, from: r, to: i, text: s }),
        l.dispatch(p),
        (u = !0))
    }),
    u
  )
}
function QU(e) {
  const { editor: n, rules: t } = e,
    r = new Ke({
      state: {
        init() {
          return null
        },
        apply(i, s, o) {
          const a = i.getMeta(r)
          if (a) return a
          const l = i.getMeta('applyInputRules')
          return (
            !!l &&
              setTimeout(() => {
                let { text: u } = l
                typeof u == 'string' ? (u = u) : (u = Ag(St.from(u), o.schema))
                const { from: f } = l,
                  d = f + u.length
                kc({ editor: n, from: f, to: d, text: u, rules: t, plugin: r })
              }),
            i.selectionSet || i.docChanged ? null : s
          )
        },
      },
      props: {
        handleTextInput(i, s, o, a) {
          return kc({ editor: n, from: s, to: o, text: a, rules: t, plugin: r })
        },
        handleDOMEvents: {
          compositionend: (i) => (
            setTimeout(() => {
              const { $cursor: s } = i.state.selection
              s && kc({ editor: n, from: s.pos, to: s.pos, text: '', rules: t, plugin: r })
            }),
            !1
          ),
        },
        handleKeyDown(i, s) {
          if (s.key !== 'Enter') return !1
          const { $cursor: o } = i.state.selection
          return o
            ? kc({
                editor: n,
                from: o.pos,
                to: o.pos,
                text: `
`,
                rules: t,
                plugin: r,
              })
            : !1
        },
      },
      isInputRules: !0,
    })
  return r
}
function tq(e) {
  return Object.prototype.toString.call(e).slice(8, -1)
}
function Cc(e) {
  return tq(e) !== 'Object'
    ? !1
    : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype
}
function n_(e, n) {
  const t = { ...e }
  return (
    Cc(e) &&
      Cc(n) &&
      Object.keys(n).forEach((r) => {
        Cc(n[r]) && Cc(e[r]) ? (t[r] = n_(e[r], n[r])) : (t[r] = n[r])
      }),
    t
  )
}
var Pg = class {
    constructor(e = {}) {
      ;((this.type = 'extendable'),
        (this.parent = null),
        (this.child = null),
        (this.name = ''),
        (this.config = { name: this.name }),
        (this.config = { ...this.config, ...e }),
        (this.name = this.config.name))
    }
    get options() {
      return { ...(Re(Xt(this, 'addOptions', { name: this.name })) || {}) }
    }
    get storage() {
      return { ...(Re(Xt(this, 'addStorage', { name: this.name, options: this.options })) || {}) }
    }
    configure(e = {}) {
      const n = this.extend({ ...this.config, addOptions: () => n_(this.options, e) })
      return ((n.name = this.name), (n.parent = this.parent), n)
    }
    extend(e = {}) {
      const n = new this.constructor({ ...this.config, ...e })
      return (
        (n.parent = this),
        (this.child = n),
        (n.name = 'name' in e ? e.name : n.parent.name),
        n
      )
    }
  },
  Us = class r_ extends Pg {
    constructor() {
      ;(super(...arguments), (this.type = 'mark'))
    }
    static create(n = {}) {
      const t = typeof n == 'function' ? n() : n
      return new r_(t)
    }
    static handleExit({ editor: n, mark: t }) {
      const { tr: r } = n.state,
        i = n.state.selection.$from
      if (i.pos === i.end()) {
        const o = i.marks()
        if (!!!o.find((c) => c?.type.name === t.name)) return !1
        const l = o.find((c) => c?.type.name === t.name)
        return (l && r.removeStoredMark(l), r.insertText(' ', i.pos), n.view.dispatch(r), !0)
      }
      return !1
    }
    configure(n) {
      return super.configure(n)
    }
    extend(n) {
      const t = typeof n == 'function' ? n() : n
      return super.extend(t)
    }
  }
function eq(e) {
  return typeof e == 'number'
}
var nq = class {
    constructor(e) {
      ;((this.find = e.find), (this.handler = e.handler))
    }
  },
  rq = (e, n, t) => {
    if (Cg(n)) return [...e.matchAll(n)]
    const r = n(e, t)
    return r
      ? r.map((i) => {
          const s = [i.text]
          return (
            (s.index = i.index),
            (s.input = e),
            (s.data = i.data),
            i.replaceWith &&
              (i.text.includes(i.replaceWith) ||
                console.warn(
                  '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".',
                ),
              s.push(i.replaceWith)),
            s
          )
        })
      : []
  }
function iq(e) {
  const { editor: n, state: t, from: r, to: i, rule: s, pasteEvent: o, dropEvent: a } = e,
    { commands: l, chain: c, can: u } = new nd({ editor: n, state: t }),
    f = []
  return (
    t.doc.nodesBetween(r, i, (h, p) => {
      var g, m, y, b, w
      if (
        ((m = (g = h.type) == null ? void 0 : g.spec) != null && m.code) ||
        !(h.isText || h.isTextblock || h.isInline)
      )
        return
      const C =
          (w = (b = (y = h.content) == null ? void 0 : y.size) != null ? b : h.nodeSize) != null
            ? w
            : 0,
        T = Math.max(r, p),
        I = Math.min(i, p + C)
      if (T >= I) return
      const B = h.isText ? h.text || '' : h.textBetween(T - p, I - p, void 0, '')
      rq(B, s.find, o).forEach((O) => {
        if (O.index === void 0) return
        const P = T + O.index + 1,
          $ = P + O[0].length,
          F = { from: t.tr.mapping.map(P), to: t.tr.mapping.map($) },
          M = s.handler({
            state: t,
            range: F,
            match: O,
            commands: l,
            chain: c,
            can: u,
            pasteEvent: o,
            dropEvent: a,
          })
        f.push(M)
      })
    }),
    f.every((h) => h !== null)
  )
}
var Mc = null,
  sq = (e) => {
    var n
    const t = new ClipboardEvent('paste', { clipboardData: new DataTransfer() })
    return ((n = t.clipboardData) == null || n.setData('text/html', e), t)
  }
function oq(e) {
  const { editor: n, rules: t } = e
  let r = null,
    i = !1,
    s = !1,
    o = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null,
    a
  try {
    a = typeof DragEvent < 'u' ? new DragEvent('drop') : null
  } catch {
    a = null
  }
  const l = ({ state: u, from: f, to: d, rule: h, pasteEvt: p }) => {
    const g = u.tr,
      m = ed({ state: u, transaction: g })
    if (
      !(
        !iq({
          editor: n,
          state: m,
          from: Math.max(f - 1, 0),
          to: d.b - 1,
          rule: h,
          pasteEvent: p,
          dropEvent: a,
        }) || !g.steps.length
      )
    ) {
      try {
        a = typeof DragEvent < 'u' ? new DragEvent('drop') : null
      } catch {
        a = null
      }
      return ((o = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null), g)
    }
  }
  return t.map(
    (u) =>
      new Ke({
        view(f) {
          const d = (p) => {
              var g
              ;((r =
                (g = f.dom.parentElement) != null && g.contains(p.target)
                  ? f.dom.parentElement
                  : null),
                r && (Mc = n))
            },
            h = () => {
              Mc && (Mc = null)
            }
          return (
            window.addEventListener('dragstart', d),
            window.addEventListener('dragend', h),
            {
              destroy() {
                ;(window.removeEventListener('dragstart', d),
                  window.removeEventListener('dragend', h))
              },
            }
          )
        },
        props: {
          handleDOMEvents: {
            drop: (f, d) => {
              if (((s = r === f.dom.parentElement), (a = d), !s)) {
                const h = Mc
                h?.isEditable &&
                  setTimeout(() => {
                    const p = h.state.selection
                    p && h.commands.deleteRange({ from: p.from, to: p.to })
                  }, 10)
              }
              return !1
            },
            paste: (f, d) => {
              var h
              const p = (h = d.clipboardData) == null ? void 0 : h.getData('text/html')
              return ((o = d), (i = !!p?.includes('data-pm-slice')), !1)
            },
          },
        },
        appendTransaction: (f, d, h) => {
          const p = f[0],
            g = p.getMeta('uiEvent') === 'paste' && !i,
            m = p.getMeta('uiEvent') === 'drop' && !s,
            y = p.getMeta('applyPasteRules'),
            b = !!y
          if (!g && !m && !b) return
          if (b) {
            let { text: T } = y
            typeof T == 'string' ? (T = T) : (T = Ag(St.from(T), h.schema))
            const { from: I } = y,
              B = I + T.length,
              E = sq(T)
            return l({ rule: u, state: h, from: I, to: { b: B }, pasteEvt: E })
          }
          const w = d.doc.content.findDiffStart(h.doc.content),
            C = d.doc.content.findDiffEnd(h.doc.content)
          if (!(!eq(w) || !C || w === C.b))
            return l({ rule: u, state: h, from: w, to: C, pasteEvt: o })
        },
      }),
  )
}
var ad = class {
  constructor(e, n) {
    ;((this.splittableMarks = []),
      (this.editor = n),
      (this.baseExtensions = e),
      (this.extensions = YS(e)),
      (this.schema = xU(this.extensions, n)),
      this.setupExtensions())
  }
  get commands() {
    return this.extensions.reduce((e, n) => {
      const t = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: this.editor,
          type: wh(n.name, this.schema),
        },
        r = Xt(n, 'addCommands', t)
      return r ? { ...e, ...r() } : e
    }, {})
  }
  get plugins() {
    const { editor: e } = this
    return Rg([...this.extensions].reverse()).flatMap((r) => {
      const i = {
          name: r.name,
          options: r.options,
          storage: this.editor.extensionStorage[r.name],
          editor: e,
          type: wh(r.name, this.schema),
        },
        s = [],
        o = Xt(r, 'addKeyboardShortcuts', i)
      let a = {}
      if (
        (r.type === 'mark' &&
          Xt(r, 'exitable', i) &&
          (a.ArrowRight = () => Us.handleExit({ editor: e, mark: r })),
        o)
      ) {
        const d = Object.fromEntries(
          Object.entries(o()).map(([h, p]) => [h, () => p({ editor: e })]),
        )
        a = { ...a, ...d }
      }
      const l = kH(a)
      s.push(l)
      const c = Xt(r, 'addInputRules', i)
      if (p2(r, e.options.enableInputRules) && c) {
        const d = c()
        if (d && d.length) {
          const h = QU({ editor: e, rules: d }),
            p = Array.isArray(h) ? h : [h]
          s.push(...p)
        }
      }
      const u = Xt(r, 'addPasteRules', i)
      if (p2(r, e.options.enablePasteRules) && u) {
        const d = u()
        if (d && d.length) {
          const h = oq({ editor: e, rules: d })
          s.push(...h)
        }
      }
      const f = Xt(r, 'addProseMirrorPlugins', i)
      if (f) {
        const d = f()
        s.push(...d)
      }
      return s
    })
  }
  get attributes() {
    return XS(this.extensions)
  }
  get nodeViews() {
    const { editor: e } = this,
      { nodeExtensions: n } = xl(this.extensions)
    return Object.fromEntries(
      n
        .filter((t) => !!Xt(t, 'addNodeView'))
        .map((t) => {
          const r = this.attributes.filter((a) => a.type === t.name),
            i = {
              name: t.name,
              options: t.options,
              storage: this.editor.extensionStorage[t.name],
              editor: e,
              type: tn(t.name, this.schema),
            },
            s = Xt(t, 'addNodeView', i)
          if (!s) return []
          const o = (a, l, c, u, f) => {
            const d = $u(a, r)
            return s()({
              node: a,
              view: l,
              getPos: c,
              decorations: u,
              innerDecorations: f,
              editor: e,
              extension: t,
              HTMLAttributes: d,
            })
          }
          return [t.name, o]
        }),
    )
  }
  get markViews() {
    const { editor: e } = this,
      { markExtensions: n } = xl(this.extensions)
    return Object.fromEntries(
      n
        .filter((t) => !!Xt(t, 'addMarkView'))
        .map((t) => {
          const r = this.attributes.filter((a) => a.type === t.name),
            i = {
              name: t.name,
              options: t.options,
              storage: this.editor.extensionStorage[t.name],
              editor: e,
              type: ai(t.name, this.schema),
            },
            s = Xt(t, 'addMarkView', i)
          if (!s) return []
          const o = (a, l, c) => {
            const u = $u(a, r)
            return s()({
              mark: a,
              view: l,
              inline: c,
              editor: e,
              extension: t,
              HTMLAttributes: u,
              updateAttributes: (f) => {
                wq(a, e, f)
              },
            })
          }
          return [t.name, o]
        }),
    )
  }
  setupExtensions() {
    const e = this.extensions
    ;((this.editor.extensionStorage = Object.fromEntries(e.map((n) => [n.name, n.storage]))),
      e.forEach((n) => {
        var t
        const r = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: this.editor,
          type: wh(n.name, this.schema),
        }
        n.type === 'mark' &&
          ((t = Re(Xt(n, 'keepOnSplit', r))) == null || t) &&
          this.splittableMarks.push(n.name)
        const i = Xt(n, 'onBeforeCreate', r),
          s = Xt(n, 'onCreate', r),
          o = Xt(n, 'onUpdate', r),
          a = Xt(n, 'onSelectionUpdate', r),
          l = Xt(n, 'onTransaction', r),
          c = Xt(n, 'onFocus', r),
          u = Xt(n, 'onBlur', r),
          f = Xt(n, 'onDestroy', r)
        ;(i && this.editor.on('beforeCreate', i),
          s && this.editor.on('create', s),
          o && this.editor.on('update', o),
          a && this.editor.on('selectionUpdate', a),
          l && this.editor.on('transaction', l),
          c && this.editor.on('focus', c),
          u && this.editor.on('blur', u),
          f && this.editor.on('destroy', f))
      }))
  }
}
ad.resolve = YS
ad.sort = Rg
ad.flatten = Tg
var aq = {}
kg(aq, {
  ClipboardTextSerializer: () => s_,
  Commands: () => o_,
  Delete: () => a_,
  Drop: () => l_,
  Editable: () => c_,
  FocusEvents: () => f_,
  Keymap: () => d_,
  Paste: () => h_,
  Tabindex: () => p_,
  focusEventsPluginKey: () => u_,
})
var nn = class i_ extends Pg {
    constructor() {
      ;(super(...arguments), (this.type = 'extension'))
    }
    static create(n = {}) {
      const t = typeof n == 'function' ? n() : n
      return new i_(t)
    }
    configure(n) {
      return super.configure(n)
    }
    extend(n) {
      const t = typeof n == 'function' ? n() : n
      return super.extend(t)
    }
  },
  s_ = nn.create({
    name: 'clipboardTextSerializer',
    addOptions() {
      return { blockSeparator: void 0 }
    },
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('clipboardTextSerializer'),
          props: {
            clipboardTextSerializer: () => {
              const { editor: e } = this,
                { state: n, schema: t } = e,
                { doc: r, selection: i } = n,
                { ranges: s } = i,
                o = Math.min(...s.map((u) => u.$from.pos)),
                a = Math.max(...s.map((u) => u.$to.pos)),
                l = JS(t)
              return ZS(
                r,
                { from: o, to: a },
                {
                  ...(this.options.blockSeparator !== void 0
                    ? { blockSeparator: this.options.blockSeparator }
                    : {}),
                  textSerializers: l,
                },
              )
            },
          },
        }),
      ]
    },
  }),
  o_ = nn.create({
    name: 'commands',
    addCommands() {
      return { ...zS }
    },
  }),
  a_ = nn.create({
    name: 'delete',
    onUpdate({ transaction: e, appendedTransactions: n }) {
      var t, r, i
      const s = () => {
        var o, a, l, c
        if (
          (c =
            (l =
              (a = (o = this.editor.options.coreExtensionOptions) == null ? void 0 : o.delete) ==
              null
                ? void 0
                : a.filterTransaction) == null
              ? void 0
              : l.call(a, e)) != null
            ? c
            : e.getMeta('y-sync$')
        )
          return
        const u = KS(e.before, [e, ...n])
        t_(u).forEach((h) => {
          u.mapping.mapResult(h.oldRange.from).deletedAfter &&
            u.mapping.mapResult(h.oldRange.to).deletedBefore &&
            u.before.nodesBetween(h.oldRange.from, h.oldRange.to, (p, g) => {
              const m = g + p.nodeSize - 2,
                y = h.oldRange.from <= g && m <= h.oldRange.to
              this.editor.emit('delete', {
                type: 'node',
                node: p,
                from: g,
                to: m,
                newFrom: u.mapping.map(g),
                newTo: u.mapping.map(m),
                deletedRange: h.oldRange,
                newRange: h.newRange,
                partial: !y,
                editor: this.editor,
                transaction: e,
                combinedTransform: u,
              })
            })
        })
        const d = u.mapping
        u.steps.forEach((h, p) => {
          var g, m
          if (h instanceof yr) {
            const y = d.slice(p).map(h.from, -1),
              b = d.slice(p).map(h.to),
              w = d.invert().map(y, -1),
              C = d.invert().map(b),
              T = (g = u.doc.nodeAt(y - 1)) == null ? void 0 : g.marks.some((B) => B.eq(h.mark)),
              I = (m = u.doc.nodeAt(b)) == null ? void 0 : m.marks.some((B) => B.eq(h.mark))
            this.editor.emit('delete', {
              type: 'mark',
              mark: h.mark,
              from: h.from,
              to: h.to,
              deletedRange: { from: w, to: C },
              newRange: { from: y, to: b },
              partial: !!(I || T),
              editor: this.editor,
              transaction: e,
              combinedTransform: u,
            })
          }
        })
      }
      ;(i =
        (r = (t = this.editor.options.coreExtensionOptions) == null ? void 0 : t.delete) == null
          ? void 0
          : r.async) == null || i
        ? setTimeout(s, 0)
        : s()
    },
  }),
  l_ = nn.create({
    name: 'drop',
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('tiptapDrop'),
          props: {
            handleDrop: (e, n, t, r) => {
              this.editor.emit('drop', { editor: this.editor, event: n, slice: t, moved: r })
            },
          },
        }),
      ]
    },
  }),
  c_ = nn.create({
    name: 'editable',
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('editable'),
          props: { editable: () => this.editor.options.editable },
        }),
      ]
    },
  }),
  u_ = new hn('focusEvents'),
  f_ = nn.create({
    name: 'focusEvents',
    addProseMirrorPlugins() {
      const { editor: e } = this
      return [
        new Ke({
          key: u_,
          props: {
            handleDOMEvents: {
              focus: (n, t) => {
                e.isFocused = !0
                const r = e.state.tr.setMeta('focus', { event: t }).setMeta('addToHistory', !1)
                return (n.dispatch(r), !1)
              },
              blur: (n, t) => {
                e.isFocused = !1
                const r = e.state.tr.setMeta('blur', { event: t }).setMeta('addToHistory', !1)
                return (n.dispatch(r), !1)
              },
            },
          },
        }),
      ]
    },
  }),
  d_ = nn.create({
    name: 'keymap',
    addKeyboardShortcuts() {
      const e = () =>
          this.editor.commands.first(({ commands: o }) => [
            () => o.undoInputRule(),
            () =>
              o.command(({ tr: a }) => {
                const { selection: l, doc: c } = a,
                  { empty: u, $anchor: f } = l,
                  { pos: d, parent: h } = f,
                  p = f.parent.isTextblock && d > 0 ? a.doc.resolve(d - 1) : f,
                  g = p.parent.type.spec.isolating,
                  m = f.pos - f.parentOffset,
                  y = g && p.parent.childCount === 1 ? m === f.pos : ye.atStart(c).from === d
                return !u ||
                  !h.type.isTextblock ||
                  h.textContent.length ||
                  !y ||
                  (y && f.parent.type.name === 'paragraph')
                  ? !1
                  : o.clearNodes()
              }),
            () => o.deleteSelection(),
            () => o.joinBackward(),
            () => o.selectNodeBackward(),
          ]),
        n = () =>
          this.editor.commands.first(({ commands: o }) => [
            () => o.deleteSelection(),
            () => o.deleteCurrentNode(),
            () => o.joinForward(),
            () => o.selectNodeForward(),
          ]),
        r = {
          Enter: () =>
            this.editor.commands.first(({ commands: o }) => [
              () => o.newlineInCode(),
              () => o.createParagraphNear(),
              () => o.liftEmptyBlock(),
              () => o.splitBlock(),
            ]),
          'Mod-Enter': () => this.editor.commands.exitCode(),
          Backspace: e,
          'Mod-Backspace': e,
          'Shift-Backspace': e,
          Delete: n,
          'Mod-Delete': n,
          'Mod-a': () => this.editor.commands.selectAll(),
        },
        i = { ...r },
        s = {
          ...r,
          'Ctrl-h': e,
          'Alt-Backspace': e,
          'Ctrl-d': n,
          'Ctrl-Alt-Backspace': n,
          'Alt-Delete': n,
          'Alt-d': n,
          'Ctrl-a': () => this.editor.commands.selectTextblockStart(),
          'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),
        }
      return Eg() || qS() ? s : i
    },
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('clearDocument'),
          appendTransaction: (e, n, t) => {
            if (e.some((g) => g.getMeta('composition'))) return
            const r = e.some((g) => g.docChanged) && !n.doc.eq(t.doc),
              i = e.some((g) => g.getMeta('preventClearDocument'))
            if (!r || i) return
            const { empty: s, from: o, to: a } = n.selection,
              l = ye.atStart(n.doc).from,
              c = ye.atEnd(n.doc).to
            if (s || !(o === l && a === c) || !sd(t.doc)) return
            const d = t.tr,
              h = ed({ state: t, transaction: d }),
              { commands: p } = new nd({ editor: this.editor, state: h })
            if ((p.clearNodes(), !!d.steps.length)) return d
          },
        }),
      ]
    },
  }),
  h_ = nn.create({
    name: 'paste',
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('tiptapPaste'),
          props: {
            handlePaste: (e, n, t) => {
              this.editor.emit('paste', { editor: this.editor, event: n, slice: t })
            },
          },
        }),
      ]
    },
  }),
  p_ = nn.create({
    name: 'tabindex',
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('tabindex'),
          props: { attributes: () => (this.editor.isEditable ? { tabindex: '0' } : {}) },
        }),
      ]
    },
  }),
  lq = class so {
    constructor(n, t, r = !1, i = null) {
      ;((this.currentNode = null),
        (this.actualDepth = null),
        (this.isBlock = r),
        (this.resolvedPos = n),
        (this.editor = t),
        (this.currentNode = i))
    }
    get name() {
      return this.node.type.name
    }
    get node() {
      return this.currentNode || this.resolvedPos.node()
    }
    get element() {
      return this.editor.view.domAtPos(this.pos).node
    }
    get depth() {
      var n
      return (n = this.actualDepth) != null ? n : this.resolvedPos.depth
    }
    get pos() {
      return this.resolvedPos.pos
    }
    get content() {
      return this.node.content
    }
    set content(n) {
      let t = this.from,
        r = this.to
      if (this.isBlock) {
        if (this.content.size === 0) {
          console.error(
            `You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`,
          )
          return
        }
        ;((t = this.from + 1), (r = this.to - 1))
      }
      this.editor.commands.insertContentAt({ from: t, to: r }, n)
    }
    get attributes() {
      return this.node.attrs
    }
    get textContent() {
      return this.node.textContent
    }
    get size() {
      return this.node.nodeSize
    }
    get from() {
      return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth)
    }
    get range() {
      return { from: this.from, to: this.to }
    }
    get to() {
      return this.isBlock
        ? this.pos + this.size
        : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1)
    }
    get parent() {
      if (this.depth === 0) return null
      const n = this.resolvedPos.start(this.resolvedPos.depth - 1),
        t = this.resolvedPos.doc.resolve(n)
      return new so(t, this.editor)
    }
    get before() {
      let n = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2))
      return (
        n.depth !== this.depth && (n = this.resolvedPos.doc.resolve(this.from - 3)),
        new so(n, this.editor)
      )
    }
    get after() {
      let n = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1))
      return (
        n.depth !== this.depth && (n = this.resolvedPos.doc.resolve(this.to + 3)),
        new so(n, this.editor)
      )
    }
    get children() {
      const n = []
      return (
        this.node.content.forEach((t, r) => {
          const i = t.isBlock && !t.isTextblock,
            s = t.isAtom && !t.isText,
            o = this.pos + r + (s ? 0 : 1)
          if (o < 0 || o > this.resolvedPos.doc.nodeSize - 2) return
          const a = this.resolvedPos.doc.resolve(o)
          if (!i && a.depth <= this.depth) return
          const l = new so(a, this.editor, i, i ? t : null)
          ;(i && (l.actualDepth = this.depth + 1), n.push(new so(a, this.editor, i, i ? t : null)))
        }),
        n
      )
    }
    get firstChild() {
      return this.children[0] || null
    }
    get lastChild() {
      const n = this.children
      return n[n.length - 1] || null
    }
    closest(n, t = {}) {
      let r = null,
        i = this.parent
      for (; i && !r; ) {
        if (i.node.type.name === n)
          if (Object.keys(t).length > 0) {
            const s = i.node.attrs,
              o = Object.keys(t)
            for (let a = 0; a < o.length; a += 1) {
              const l = o[a]
              if (s[l] !== t[l]) break
            }
          } else r = i
        i = i.parent
      }
      return r
    }
    querySelector(n, t = {}) {
      return this.querySelectorAll(n, t, !0)[0] || null
    }
    querySelectorAll(n, t = {}, r = !1) {
      let i = []
      if (!this.children || this.children.length === 0) return i
      const s = Object.keys(t)
      return (
        this.children.forEach((o) => {
          ;(r && i.length > 0) ||
            (o.node.type.name === n && s.every((l) => t[l] === o.node.attrs[l]) && i.push(o),
            !(r && i.length > 0) && (i = i.concat(o.querySelectorAll(n, t, r))))
        }),
        i
      )
    }
    setAttribute(n) {
      const { tr: t } = this.editor.state
      ;(t.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...n }),
        this.editor.view.dispatch(t))
    }
  },
  cq = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`
function uq(e, n, t) {
  const r = document.querySelector('style[data-tiptap-style]')
  if (r !== null) return r
  const i = document.createElement('style')
  return (
    n && i.setAttribute('nonce', n),
    i.setAttribute('data-tiptap-style', ''),
    (i.innerHTML = e),
    document.getElementsByTagName('head')[0].appendChild(i),
    i
  )
}
var fq = class extends ZU {
  constructor(e = {}) {
    ;(super(),
      (this.css = null),
      (this.editorView = null),
      (this.isFocused = !1),
      (this.isInitialized = !1),
      (this.extensionStorage = {}),
      (this.instanceId = Math.random().toString(36).slice(2, 9)),
      (this.options = {
        element: typeof document < 'u' ? document.createElement('div') : null,
        content: '',
        injectCSS: !0,
        injectNonce: void 0,
        extensions: [],
        autofocus: !1,
        editable: !0,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: !0,
        enablePasteRules: !0,
        enableCoreExtensions: !0,
        enableContentCheck: !1,
        emitContentError: !1,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onMount: () => null,
        onUnmount: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error: r }) => {
          throw r
        },
        onPaste: () => null,
        onDrop: () => null,
        onDelete: () => null,
      }),
      (this.isCapturingTransaction = !1),
      (this.capturedTransaction = null),
      this.setOptions(e),
      this.createExtensionManager(),
      this.createCommandManager(),
      this.createSchema(),
      this.on('beforeCreate', this.options.onBeforeCreate),
      this.emit('beforeCreate', { editor: this }),
      this.on('mount', this.options.onMount),
      this.on('unmount', this.options.onUnmount),
      this.on('contentError', this.options.onContentError),
      this.on('create', this.options.onCreate),
      this.on('update', this.options.onUpdate),
      this.on('selectionUpdate', this.options.onSelectionUpdate),
      this.on('transaction', this.options.onTransaction),
      this.on('focus', this.options.onFocus),
      this.on('blur', this.options.onBlur),
      this.on('destroy', this.options.onDestroy),
      this.on('drop', ({ event: r, slice: i, moved: s }) => this.options.onDrop(r, i, s)),
      this.on('paste', ({ event: r, slice: i }) => this.options.onPaste(r, i)),
      this.on('delete', this.options.onDelete))
    const n = this.createDoc(),
      t = HS(n, this.options.autofocus)
    ;((this.editorState = po.create({ doc: n, schema: this.schema, selection: t || void 0 })),
      this.options.element && this.mount(this.options.element))
  }
  mount(e) {
    if (typeof document > 'u')
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.",
      )
    ;(this.createView(e),
      this.emit('mount', { editor: this }),
      this.css && !document.head.contains(this.css) && document.head.appendChild(this.css),
      window.setTimeout(() => {
        this.isDestroyed ||
          (this.commands.focus(this.options.autofocus),
          this.emit('create', { editor: this }),
          (this.isInitialized = !0))
      }, 0))
  }
  unmount() {
    if (this.editorView) {
      const e = this.editorView.dom
      ;(e?.editor && delete e.editor, this.editorView.destroy())
    }
    if (((this.editorView = null), (this.isInitialized = !1), this.css))
      try {
        typeof this.css.remove == 'function'
          ? this.css.remove()
          : this.css.parentNode && this.css.parentNode.removeChild(this.css)
      } catch (e) {
        console.warn('Failed to remove CSS element:', e)
      }
    ;((this.css = null), this.emit('unmount', { editor: this }))
  }
  get storage() {
    return this.extensionStorage
  }
  get commands() {
    return this.commandManager.commands
  }
  chain() {
    return this.commandManager.chain()
  }
  can() {
    return this.commandManager.can()
  }
  injectCSS() {
    this.options.injectCSS && typeof document < 'u' && (this.css = uq(cq, this.options.injectNonce))
  }
  setOptions(e = {}) {
    ;((this.options = { ...this.options, ...e }),
      !(!this.editorView || !this.state || this.isDestroyed) &&
        (this.options.editorProps && this.view.setProps(this.options.editorProps),
        this.view.updateState(this.state)))
  }
  setEditable(e, n = !0) {
    ;(this.setOptions({ editable: e }),
      n &&
        this.emit('update', { editor: this, transaction: this.state.tr, appendedTransactions: [] }))
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable
  }
  get view() {
    return this.editorView
      ? this.editorView
      : new Proxy(
          {
            state: this.editorState,
            updateState: (e) => {
              this.editorState = e
            },
            dispatch: (e) => {
              this.dispatchTransaction(e)
            },
            composing: !1,
            dragging: null,
            editable: !0,
            isDestroyed: !1,
          },
          {
            get: (e, n) => {
              if (this.editorView) return this.editorView[n]
              if (n === 'state') return this.editorState
              if (n in e) return Reflect.get(e, n)
              throw new Error(
                `[tiptap error]: The editor view is not available. Cannot access view['${n}']. The editor may not be mounted yet.`,
              )
            },
          },
        )
  }
  get state() {
    return (this.editorView && (this.editorState = this.view.state), this.editorState)
  }
  registerPlugin(e, n) {
    const t = GS(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e],
      r = this.state.reconfigure({ plugins: t })
    return (this.view.updateState(r), r)
  }
  unregisterPlugin(e) {
    if (this.isDestroyed) return
    const n = this.state.plugins
    let t = n
    if (
      ([].concat(e).forEach((i) => {
        const s = typeof i == 'string' ? `${i}$` : i.key
        t = t.filter((o) => !o.key.startsWith(s))
      }),
      n.length === t.length)
    )
      return
    const r = this.state.reconfigure({ plugins: t })
    return (this.view.updateState(r), r)
  }
  createExtensionManager() {
    var e, n
    const r = [
      ...(this.options.enableCoreExtensions
        ? [
            c_,
            s_.configure({
              blockSeparator:
                (n =
                  (e = this.options.coreExtensionOptions) == null
                    ? void 0
                    : e.clipboardTextSerializer) == null
                  ? void 0
                  : n.blockSeparator,
            }),
            o_,
            f_,
            d_,
            p_,
            l_,
            h_,
            a_,
          ].filter((i) =>
            typeof this.options.enableCoreExtensions == 'object'
              ? this.options.enableCoreExtensions[i.name] !== !1
              : !0,
          )
        : []),
      ...this.options.extensions,
    ].filter((i) => ['extension', 'node', 'mark'].includes(i?.type))
    this.extensionManager = new ad(r, this)
  }
  createCommandManager() {
    this.commandManager = new nd({ editor: this })
  }
  createSchema() {
    this.schema = this.extensionManager.schema
  }
  createDoc() {
    let e
    try {
      e = lm(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck,
      })
    } catch (n) {
      if (
        !(n instanceof Error) ||
        !['[tiptap error]: Invalid JSON content', '[tiptap error]: Invalid HTML content'].includes(
          n.message,
        )
      )
        throw n
      ;(this.emit('contentError', {
        editor: this,
        error: n,
        disableCollaboration: () => {
          ;('collaboration' in this.storage &&
            typeof this.storage.collaboration == 'object' &&
            this.storage.collaboration &&
            (this.storage.collaboration.isDisabled = !0),
            (this.options.extensions = this.options.extensions.filter(
              (t) => t.name !== 'collaboration',
            )),
            this.createExtensionManager())
        },
      }),
        (e = lm(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: !1,
        })))
    }
    return e
  }
  createView(e) {
    var n
    this.editorView = new FS(e, {
      ...this.options.editorProps,
      attributes: {
        role: 'textbox',
        ...((n = this.options.editorProps) == null ? void 0 : n.attributes),
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews,
    })
    const t = this.state.reconfigure({ plugins: this.extensionManager.plugins })
    ;(this.view.updateState(t), this.prependClass(), this.injectCSS())
    const r = this.view.dom
    r.editor = this
  }
  createNodeViews() {
    this.view.isDestroyed ||
      this.view.setProps({
        markViews: this.extensionManager.markViews,
        nodeViews: this.extensionManager.nodeViews,
      })
  }
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`
  }
  captureTransaction(e) {
    ;((this.isCapturingTransaction = !0), e(), (this.isCapturingTransaction = !1))
    const n = this.capturedTransaction
    return ((this.capturedTransaction = null), n)
  }
  dispatchTransaction(e) {
    if (this.view.isDestroyed) return
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e
        return
      }
      e.steps.forEach((c) => {
        var u
        return (u = this.capturedTransaction) == null ? void 0 : u.step(c)
      })
      return
    }
    const { state: n, transactions: t } = this.state.applyTransaction(e),
      r = !this.state.selection.eq(n.selection),
      i = t.includes(e),
      s = this.state
    if ((this.emit('beforeTransaction', { editor: this, transaction: e, nextState: n }), !i)) return
    ;(this.view.updateState(n),
      this.emit('transaction', { editor: this, transaction: e, appendedTransactions: t.slice(1) }),
      r && this.emit('selectionUpdate', { editor: this, transaction: e }))
    const o = t.findLast((c) => c.getMeta('focus') || c.getMeta('blur')),
      a = o?.getMeta('focus'),
      l = o?.getMeta('blur')
    ;(a && this.emit('focus', { editor: this, event: a.event, transaction: o }),
      l && this.emit('blur', { editor: this, event: l.event, transaction: o }),
      !(e.getMeta('preventUpdate') || !t.some((c) => c.docChanged) || s.doc.eq(n.doc)) &&
        this.emit('update', { editor: this, transaction: e, appendedTransactions: t.slice(1) }))
  }
  getAttributes(e) {
    return QS(this.state, e)
  }
  isActive(e, n) {
    const t = typeof e == 'string' ? e : null,
      r = typeof e == 'string' ? n : e
    return AU(this.state, t, r)
  }
  getJSON() {
    return this.state.doc.toJSON()
  }
  getHTML() {
    return Ag(this.state.doc.content, this.schema)
  }
  getText(e) {
    const {
      blockSeparator: n = `

`,
      textSerializers: t = {},
    } = e || {}
    return _U(this.state.doc, { blockSeparator: n, textSerializers: { ...JS(this.schema), ...t } })
  }
  get isEmpty() {
    return sd(this.state.doc)
  }
  destroy() {
    ;(this.emit('destroy'), this.unmount(), this.removeAllListeners())
  }
  get isDestroyed() {
    var e, n
    return (n = (e = this.editorView) == null ? void 0 : e.isDestroyed) != null ? n : !0
  }
  $node(e, n) {
    var t
    return ((t = this.$doc) == null ? void 0 : t.querySelector(e, n)) || null
  }
  $nodes(e, n) {
    var t
    return ((t = this.$doc) == null ? void 0 : t.querySelectorAll(e, n)) || null
  }
  $pos(e) {
    const n = this.state.doc.resolve(e)
    return new lq(n, this)
  }
  get $doc() {
    return this.$pos(0)
  }
}
function Ho(e) {
  return new od({
    find: e.find,
    handler: ({ state: n, range: t, match: r }) => {
      const i = Re(e.getAttributes, void 0, r)
      if (i === !1 || i === null) return null
      const { tr: s } = n,
        o = r[r.length - 1],
        a = r[0]
      if (o) {
        const l = a.search(/\S/),
          c = t.from + a.indexOf(o),
          u = c + o.length
        if (
          Og(t.from, t.to, n.doc)
            .filter((h) => h.mark.type.excluded.find((g) => g === e.type && g !== h.mark.type))
            .filter((h) => h.to > c).length
        )
          return null
        ;(u < t.to && s.delete(u, t.to), c > t.from && s.delete(t.from + l, c))
        const d = t.from + l + o.length
        ;(s.addMark(t.from + l, d, e.type.create(i || {})), s.removeStoredMark(e.type))
      }
    },
    undoable: e.undoable,
  })
}
function dq(e) {
  return new od({
    find: e.find,
    handler: ({ state: n, range: t, match: r }) => {
      const i = Re(e.getAttributes, void 0, r) || {},
        { tr: s } = n,
        o = t.from
      let a = t.to
      const l = e.type.create(i)
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1])
        let u = o + c
        u > a ? (u = a) : (a = u + r[1].length)
        const f = r[0][r[0].length - 1]
        ;(s.insertText(f, o + r[0].length - 1), s.replaceWith(u, a, l))
      } else if (r[0]) {
        const c = e.type.isInline ? o : o - 1
        s.insert(c, e.type.create(i)).delete(s.mapping.map(o), s.mapping.map(a))
      }
      s.scrollIntoView()
    },
    undoable: e.undoable,
  })
}
function um(e) {
  return new od({
    find: e.find,
    handler: ({ state: n, range: t, match: r }) => {
      const i = n.doc.resolve(t.from),
        s = Re(e.getAttributes, void 0, r) || {}
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), e.type)) return null
      n.tr.delete(t.from, t.to).setBlockType(t.from, t.from, e.type, s)
    },
    undoable: e.undoable,
  })
}
function Uo(e) {
  return new od({
    find: e.find,
    handler: ({ state: n, range: t, match: r, chain: i }) => {
      const s = Re(e.getAttributes, void 0, r) || {},
        o = n.tr.delete(t.from, t.to),
        l = o.doc.resolve(t.from).blockRange(),
        c = l && lg(l, e.type, s)
      if (!c) return null
      if ((o.wrap(l, c), e.keepMarks && e.editor)) {
        const { selection: f, storedMarks: d } = n,
          { splittableMarks: h } = e.editor.extensionManager,
          p = d || (f.$to.parentOffset && f.$from.marks())
        if (p) {
          const g = p.filter((m) => h.includes(m.type.name))
          o.ensureMarks(g)
        }
      }
      if (e.keepAttributes) {
        const f =
          e.type.name === 'bulletList' || e.type.name === 'orderedList' ? 'listItem' : 'taskList'
        i().updateAttributes(f, s).run()
      }
      const u = o.doc.resolve(t.from - 1).nodeBefore
      u &&
        u.type === e.type &&
        Yi(o.doc, t.from - 1) &&
        (!e.joinPredicate || e.joinPredicate(r, u)) &&
        o.join(t.from - 1)
    },
    undoable: e.undoable,
  })
}
function hq(e, n) {
  const { selection: t } = e,
    { $from: r } = t
  if (t instanceof Zt) {
    const s = r.index()
    return r.parent.canReplaceWith(s, s + 1, n)
  }
  let i = r.depth
  for (; i >= 0; ) {
    const s = r.index(i)
    if (r.node(i).contentMatchAt(s).matchType(n)) return !0
    i -= 1
  }
  return !1
}
var pq = {}
kg(pq, {
  createAtomBlockMarkdownSpec: () => mq,
  createBlockMarkdownSpec: () => gq,
  createInlineMarkdownSpec: () => vq,
  parseAttributes: () => Ng,
  parseIndentedBlocks: () => fm,
  renderNestedMarkdownContent: () => Dg,
  serializeAttributes: () => Ig,
})
function Ng(e) {
  if (!e?.trim()) return {}
  const n = {},
    t = [],
    r = e.replace(/["']([^"']*)["']/g, (c) => (t.push(c), `__QUOTED_${t.length - 1}__`)),
    i = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g)
  if (i) {
    const c = i.map((u) => u.trim().slice(1))
    n.class = c.join(' ')
  }
  const s = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/)
  s && (n.id = s[1])
  const o = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g
  Array.from(r.matchAll(o)).forEach(([, c, u]) => {
    var f
    const d = parseInt(((f = u.match(/__QUOTED_(\d+)__/)) == null ? void 0 : f[1]) || '0', 10),
      h = t[d]
    h && (n[c] = h.slice(1, -1))
  })
  const l = r
    .replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, '')
    .replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, '')
    .replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, '')
    .trim()
  return (
    l &&
      l
        .split(/\s+/)
        .filter(Boolean)
        .forEach((u) => {
          u.match(/^[a-zA-Z][\w-]*$/) && (n[u] = !0)
        }),
    n
  )
}
function Ig(e) {
  if (!e || Object.keys(e).length === 0) return ''
  const n = []
  return (
    e.class &&
      String(e.class)
        .split(/\s+/)
        .filter(Boolean)
        .forEach((r) => n.push(`.${r}`)),
    e.id && n.push(`#${e.id}`),
    Object.entries(e).forEach(([t, r]) => {
      t === 'class' ||
        t === 'id' ||
        (r === !0 ? n.push(t) : r !== !1 && r != null && n.push(`${t}="${String(r)}"`))
    }),
    n.join(' ')
  )
}
function mq(e) {
  const {
      nodeName: n,
      name: t,
      parseAttributes: r = Ng,
      serializeAttributes: i = Ig,
      defaultAttributes: s = {},
      requiredAttributes: o = [],
      allowedAttributes: a,
    } = e,
    l = t || n,
    c = (u) => {
      if (!a) return u
      const f = {}
      return (
        a.forEach((d) => {
          d in u && (f[d] = u[d])
        }),
        f
      )
    }
  return {
    parseMarkdown: (u, f) => {
      const d = { ...s, ...u.attributes }
      return f.createNode(n, d, [])
    },
    markdownTokenizer: {
      name: n,
      level: 'block',
      start(u) {
        var f
        const d = new RegExp(`^:::${l}(?:\\s|$)`, 'm'),
          h = (f = u.match(d)) == null ? void 0 : f.index
        return h !== void 0 ? h : -1
      },
      tokenize(u, f, d) {
        const h = new RegExp(`^:::${l}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`),
          p = u.match(h)
        if (!p) return
        const g = p[1] || '',
          m = r(g)
        if (!o.find((b) => !(b in m))) return { type: n, raw: p[0], attributes: m }
      },
    },
    renderMarkdown: (u) => {
      const f = c(u.attrs || {}),
        d = i(f),
        h = d ? ` {${d}}` : ''
      return `:::${l}${h} :::`
    },
  }
}
function gq(e) {
  const {
      nodeName: n,
      name: t,
      getContent: r,
      parseAttributes: i = Ng,
      serializeAttributes: s = Ig,
      defaultAttributes: o = {},
      content: a = 'block',
      allowedAttributes: l,
    } = e,
    c = t || n,
    u = (f) => {
      if (!l) return f
      const d = {}
      return (
        l.forEach((h) => {
          h in f && (d[h] = f[h])
        }),
        d
      )
    }
  return {
    parseMarkdown: (f, d) => {
      let h
      if (r) {
        const g = r(f)
        h = typeof g == 'string' ? [{ type: 'text', text: g }] : g
      } else
        a === 'block' ? (h = d.parseChildren(f.tokens || [])) : (h = d.parseInline(f.tokens || []))
      const p = { ...o, ...f.attributes }
      return d.createNode(n, p, h)
    },
    markdownTokenizer: {
      name: n,
      level: 'block',
      start(f) {
        var d
        const h = new RegExp(`^:::${c}`, 'm'),
          p = (d = f.match(h)) == null ? void 0 : d.index
        return p !== void 0 ? p : -1
      },
      tokenize(f, d, h) {
        var p
        const g = new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*\\n`),
          m = f.match(g)
        if (!m) return
        const [y, b = ''] = m,
          w = i(b)
        let C = 1
        const T = y.length
        let I = ''
        const B = /^:::([\w-]*)(\s.*)?/gm,
          E = f.slice(T)
        for (B.lastIndex = 0; ; ) {
          const O = B.exec(E)
          if (O === null) break
          const P = O.index,
            $ = O[1]
          if (!((p = O[2]) != null && p.endsWith(':::'))) {
            if ($) C += 1
            else if (((C -= 1), C === 0)) {
              const F = E.slice(0, P)
              I = F.trim()
              const M = f.slice(0, T + P + O[0].length)
              let R = []
              if (I)
                if (a === 'block')
                  for (
                    R = h.blockTokens(F),
                      R.forEach((k) => {
                        k.text &&
                          (!k.tokens || k.tokens.length === 0) &&
                          (k.tokens = h.inlineTokens(k.text))
                      });
                    R.length > 0;

                  ) {
                    const k = R[R.length - 1]
                    if (k.type === 'paragraph' && (!k.text || k.text.trim() === '')) R.pop()
                    else break
                  }
                else R = h.inlineTokens(I)
              return { type: n, raw: M, attributes: w, content: I, tokens: R }
            }
          }
        }
      },
    },
    renderMarkdown: (f, d) => {
      const h = u(f.attrs || {}),
        p = s(h),
        g = p ? ` {${p}}` : '',
        m = d.renderChildren(
          f.content || [],
          `

`,
        )
      return `:::${c}${g}

${m}

:::`
    },
  }
}
function yq(e) {
  if (!e.trim()) return {}
  const n = {},
    t = /(\w+)=(?:"([^"]*)"|'([^']*)')/g
  let r = t.exec(e)
  for (; r !== null; ) {
    const [, i, s, o] = r
    ;((n[i] = s || o), (r = t.exec(e)))
  }
  return n
}
function bq(e) {
  return Object.entries(e)
    .filter(([, n]) => n != null)
    .map(([n, t]) => `${n}="${t}"`)
    .join(' ')
}
function vq(e) {
  const {
      nodeName: n,
      name: t,
      getContent: r,
      parseAttributes: i = yq,
      serializeAttributes: s = bq,
      defaultAttributes: o = {},
      selfClosing: a = !1,
      allowedAttributes: l,
    } = e,
    c = t || n,
    u = (d) => {
      if (!l) return d
      const h = {}
      return (
        l.forEach((p) => {
          p in d && (h[p] = d[p])
        }),
        h
      )
    },
    f = c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  return {
    parseMarkdown: (d, h) => {
      const p = { ...o, ...d.attributes }
      if (a) return h.createNode(n, p)
      const g = r ? r(d) : d.content || ''
      return g ? h.createNode(n, p, [h.createTextNode(g)]) : h.createNode(n, p, [])
    },
    markdownTokenizer: {
      name: n,
      level: 'inline',
      start(d) {
        const h = a
            ? new RegExp(`\\[${f}\\s*[^\\]]*\\]`)
            : new RegExp(`\\[${f}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${f}\\]`),
          p = d.match(h),
          g = p?.index
        return g !== void 0 ? g : -1
      },
      tokenize(d, h, p) {
        const g = a
            ? new RegExp(`^\\[${f}\\s*([^\\]]*)\\]`)
            : new RegExp(`^\\[${f}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${f}\\]`),
          m = d.match(g)
        if (!m) return
        let y = '',
          b = ''
        if (a) {
          const [, C] = m
          b = C
        } else {
          const [, C, T] = m
          ;((b = C), (y = T || ''))
        }
        const w = i(b.trim())
        return { type: n, raw: m[0], content: y.trim(), attributes: w }
      },
    },
    renderMarkdown: (d) => {
      let h = ''
      r
        ? (h = r(d))
        : d.content &&
          d.content.length > 0 &&
          (h = d.content
            .filter((y) => y.type === 'text')
            .map((y) => y.text)
            .join(''))
      const p = u(d.attrs || {}),
        g = s(p),
        m = g ? ` ${g}` : ''
      return a ? `[${c}${m}]` : `[${c}${m}]${h}[/${c}]`
    },
  }
}
function fm(e, n, t) {
  var r, i, s, o
  const a = e.split(`
`),
    l = []
  let c = '',
    u = 0
  const f = n.baseIndentSize || 2
  for (; u < a.length; ) {
    const d = a[u],
      h = d.match(n.itemPattern)
    if (!h) {
      if (l.length > 0) break
      if (d.trim() === '') {
        u += 1
        continue
      } else return
    }
    const p = n.extractItemData(h),
      { indentLevel: g, mainContent: m } = p
    c = `${c}${d}
`
    const y = [m]
    for (u += 1; u < a.length; ) {
      const T = a[u]
      if (T.trim() === '') {
        const B = a.slice(u + 1).findIndex((P) => P.trim() !== '')
        if (B === -1) break
        if (
          (((i = (r = a[u + 1 + B].match(/^(\s*)/)) == null ? void 0 : r[1]) == null
            ? void 0
            : i.length) || 0) > g
        ) {
          ;(y.push(T),
            (c = `${c}${T}
`),
            (u += 1))
          continue
        } else break
      }
      if (
        (((o = (s = T.match(/^(\s*)/)) == null ? void 0 : s[1]) == null ? void 0 : o.length) || 0) >
        g
      )
        (y.push(T),
          (c = `${c}${T}
`),
          (u += 1))
      else break
    }
    let b
    const w = y.slice(1)
    if (w.length > 0) {
      const T = w.map((I) => I.slice(g + f)).join(`
`)
      T.trim() && (n.customNestedParser ? (b = n.customNestedParser(T)) : (b = t.blockTokens(T)))
    }
    const C = n.createToken(p, b)
    l.push(C)
  }
  if (l.length !== 0) return { items: l, raw: c.trim() }
}
function Dg(e, n, t, r) {
  if (!e || !Array.isArray(e.content)) return ''
  const i = typeof t == 'function' ? t(r) : t,
    [s, ...o] = e.content,
    a = n.renderChildren([s]),
    l = [`${i}${a}`]
  return (
    o &&
      o.length > 0 &&
      o.forEach((c) => {
        const u = n.renderChildren([c])
        if (u) {
          const f = u
            .split(
              `
`,
            )
            .map((d) => (d ? n.indent(d) : '')).join(`
`)
          l.push(f)
        }
      }),
    l.join(`
`)
  )
}
function wq(e, n, t = {}) {
  const { state: r } = n,
    { doc: i, tr: s } = r,
    o = e
  ;(i.descendants((a, l) => {
    const c = s.mapping.map(l),
      u = s.mapping.map(l) + a.nodeSize
    let f = null
    if (
      (a.marks.forEach((h) => {
        if (h !== o) return !1
        f = h
      }),
      !f)
    )
      return
    let d = !1
    if (
      (Object.keys(t).forEach((h) => {
        t[h] !== f.attrs[h] && (d = !0)
      }),
      d)
    ) {
      const h = e.type.create({ ...e.attrs, ...t })
      ;(s.removeMark(c, u, e.type), s.addMark(c, u, h))
    }
  }),
    s.docChanged && n.view.dispatch(s))
}
var Gn = class m_ extends Pg {
  constructor() {
    ;(super(...arguments), (this.type = 'node'))
  }
  static create(n = {}) {
    const t = typeof n == 'function' ? n() : n
    return new m_(t)
  }
  configure(n) {
    return super.configure(n)
  }
  extend(n) {
    const t = typeof n == 'function' ? n() : n
    return super.extend(t)
  }
}
function $s(e) {
  return new nq({
    find: e.find,
    handler: ({ state: n, range: t, match: r, pasteEvent: i }) => {
      const s = Re(e.getAttributes, void 0, r, i)
      if (s === !1 || s === null) return null
      const { tr: o } = n,
        a = r[r.length - 1],
        l = r[0]
      let c = t.to
      if (a) {
        const u = l.search(/\S/),
          f = t.from + l.indexOf(a),
          d = f + a.length
        if (
          Og(t.from, t.to, n.doc)
            .filter((p) => p.mark.type.excluded.find((m) => m === e.type && m !== p.mark.type))
            .filter((p) => p.to > f).length
        )
          return null
        ;(d < t.to && o.delete(d, t.to),
          f > t.from && o.delete(t.from + u, f),
          (c = t.from + u + a.length),
          o.addMark(t.from + u, c, e.type.create(s || {})),
          o.removeStoredMark(e.type))
      }
    },
  })
}
var xq = function e(n, t) {
  if (n === t) return !0
  if (n && t && typeof n == 'object' && typeof t == 'object') {
    if (n.constructor !== t.constructor) return !1
    var r, i, s
    if (Array.isArray(n)) {
      if (((r = n.length), r != t.length)) return !1
      for (i = r; i-- !== 0; ) if (!e(n[i], t[i])) return !1
      return !0
    }
    if (n instanceof Map && t instanceof Map) {
      if (n.size !== t.size) return !1
      for (i of n.entries()) if (!t.has(i[0])) return !1
      for (i of n.entries()) if (!e(i[1], t.get(i[0]))) return !1
      return !0
    }
    if (n instanceof Set && t instanceof Set) {
      if (n.size !== t.size) return !1
      for (i of n.entries()) if (!t.has(i[0])) return !1
      return !0
    }
    if (ArrayBuffer.isView(n) && ArrayBuffer.isView(t)) {
      if (((r = n.length), r != t.length)) return !1
      for (i = r; i-- !== 0; ) if (n[i] !== t[i]) return !1
      return !0
    }
    if (n.constructor === RegExp) return n.source === t.source && n.flags === t.flags
    if (n.valueOf !== Object.prototype.valueOf) return n.valueOf() === t.valueOf()
    if (n.toString !== Object.prototype.toString) return n.toString() === t.toString()
    if (((s = Object.keys(n)), (r = s.length), r !== Object.keys(t).length)) return !1
    for (i = r; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(t, s[i])) return !1
    for (i = r; i-- !== 0; ) {
      var o = s[i]
      if (!(o === '_owner' && n.$$typeof) && !e(n[o], t[o])) return !1
    }
    return !0
  }
  return n !== n && t !== t
}
const Sq = kr(xq)
var _q =
    (...e) =>
    (n) => {
      e.forEach((t) => {
        typeof t == 'function' ? t(n) : t && (t.current = n)
      })
    },
  kq = ({ contentComponent: e }) => {
    const n = Em.useSyncExternalStore(e.subscribe, e.getSnapshot, e.getServerSnapshot)
    return Cn.jsx(Cn.Fragment, { children: Object.values(n) })
  }
function Cq() {
  const e = new Set()
  let n = {}
  return {
    subscribe(t) {
      return (
        e.add(t),
        () => {
          e.delete(t)
        }
      )
    },
    getSnapshot() {
      return n
    },
    getServerSnapshot() {
      return n
    },
    setRenderer(t, r) {
      ;((n = { ...n, [t]: W_.createPortal(r.reactElement, r.element, t) }), e.forEach((i) => i()))
    },
    removeRenderer(t) {
      const r = { ...n }
      ;(delete r[t], (n = r), e.forEach((i) => i()))
    },
  }
}
var Mq = class extends ut.Component {
    constructor(e) {
      var n
      ;(super(e),
        (this.editorContentRef = ut.createRef()),
        (this.initialized = !1),
        (this.state = {
          hasContentComponentInitialized: !!((n = e.editor) != null && n.contentComponent),
        }))
    }
    componentDidMount() {
      this.init()
    }
    componentDidUpdate() {
      this.init()
    }
    init() {
      const e = this.props.editor
      if (e && !e.isDestroyed && e.options.element) {
        if (e.contentComponent) return
        const n = this.editorContentRef.current
        ;(n.append(e.view.dom),
          e.setOptions({ element: n }),
          (e.contentComponent = Cq()),
          this.state.hasContentComponentInitialized ||
            (this.unsubscribeToContentComponent = e.contentComponent.subscribe(() => {
              ;(this.setState((t) =>
                t.hasContentComponentInitialized ? t : { hasContentComponentInitialized: !0 },
              ),
                this.unsubscribeToContentComponent && this.unsubscribeToContentComponent())
            })),
          e.createNodeViews(),
          (this.initialized = !0))
      }
    }
    componentWillUnmount() {
      var e
      const n = this.props.editor
      if (n) {
        ;((this.initialized = !1),
          n.isDestroyed || n.view.setProps({ nodeViews: {} }),
          this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(),
          (n.contentComponent = null))
        try {
          if (!((e = n.view.dom) != null && e.firstChild)) return
          const t = document.createElement('div')
          ;(t.append(n.view.dom), n.setOptions({ element: t }))
        } catch {}
      }
    }
    render() {
      const { editor: e, innerRef: n, ...t } = this.props
      return Cn.jsxs(Cn.Fragment, {
        children: [
          Cn.jsx('div', { ref: _q(n, this.editorContentRef), ...t }),
          e?.contentComponent && Cn.jsx(kq, { contentComponent: e.contentComponent }),
        ],
      })
    }
  },
  Eq = Y.forwardRef((e, n) => {
    const t = ut.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [e.editor])
    return ut.createElement(Mq, { key: t, innerRef: n, ...e })
  }),
  wJ = ut.memo(Eq),
  Tq = typeof window < 'u' ? Y.useLayoutEffect : Y.useEffect,
  Aq = class {
    constructor(e) {
      ;((this.transactionNumber = 0),
        (this.lastTransactionNumber = 0),
        (this.subscribers = new Set()),
        (this.editor = e),
        (this.lastSnapshot = { editor: e, transactionNumber: 0 }),
        (this.getSnapshot = this.getSnapshot.bind(this)),
        (this.getServerSnapshot = this.getServerSnapshot.bind(this)),
        (this.watch = this.watch.bind(this)),
        (this.subscribe = this.subscribe.bind(this)))
    }
    getSnapshot() {
      return this.transactionNumber === this.lastTransactionNumber
        ? this.lastSnapshot
        : ((this.lastTransactionNumber = this.transactionNumber),
          (this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }),
          this.lastSnapshot)
    }
    getServerSnapshot() {
      return { editor: null, transactionNumber: 0 }
    }
    subscribe(e) {
      return (
        this.subscribers.add(e),
        () => {
          this.subscribers.delete(e)
        }
      )
    }
    watch(e) {
      if (((this.editor = e), this.editor)) {
        const n = () => {
            ;((this.transactionNumber += 1), this.subscribers.forEach((r) => r()))
          },
          t = this.editor
        return (
          t.on('transaction', n),
          () => {
            t.off('transaction', n)
          }
        )
      }
    }
  }
function Rq(e) {
  var n
  const [t] = Y.useState(() => new Aq(e.editor)),
    r = Tm.useSyncExternalStoreWithSelector(
      t.subscribe,
      t.getSnapshot,
      t.getServerSnapshot,
      e.selector,
      (n = e.equalityFn) != null ? n : Sq,
    )
  return (Tq(() => t.watch(e.editor), [e.editor, t]), Y.useDebugValue(r), r)
}
var Oq = !1,
  dm = typeof window > 'u',
  Pq = dm || !!(typeof window < 'u' && window.next),
  Nq = class g_ {
    constructor(n) {
      ;((this.editor = null),
        (this.subscriptions = new Set()),
        (this.isComponentMounted = !1),
        (this.previousDeps = null),
        (this.instanceId = ''),
        (this.options = n),
        (this.subscriptions = new Set()),
        this.setEditor(this.getInitialEditor()),
        this.scheduleDestroy(),
        (this.getEditor = this.getEditor.bind(this)),
        (this.getServerSnapshot = this.getServerSnapshot.bind(this)),
        (this.subscribe = this.subscribe.bind(this)),
        (this.refreshEditorInstance = this.refreshEditorInstance.bind(this)),
        (this.scheduleDestroy = this.scheduleDestroy.bind(this)),
        (this.onRender = this.onRender.bind(this)),
        (this.createEditor = this.createEditor.bind(this)))
    }
    setEditor(n) {
      ;((this.editor = n),
        (this.instanceId = Math.random().toString(36).slice(2, 9)),
        this.subscriptions.forEach((t) => t()))
    }
    getInitialEditor() {
      return this.options.current.immediatelyRender === void 0
        ? dm || Pq
          ? null
          : this.createEditor()
        : (this.options.current.immediatelyRender,
          this.options.current.immediatelyRender ? this.createEditor() : null)
    }
    createEditor() {
      const n = {
        ...this.options.current,
        onBeforeCreate: (...r) => {
          var i, s
          return (s = (i = this.options.current).onBeforeCreate) == null ? void 0 : s.call(i, ...r)
        },
        onBlur: (...r) => {
          var i, s
          return (s = (i = this.options.current).onBlur) == null ? void 0 : s.call(i, ...r)
        },
        onCreate: (...r) => {
          var i, s
          return (s = (i = this.options.current).onCreate) == null ? void 0 : s.call(i, ...r)
        },
        onDestroy: (...r) => {
          var i, s
          return (s = (i = this.options.current).onDestroy) == null ? void 0 : s.call(i, ...r)
        },
        onFocus: (...r) => {
          var i, s
          return (s = (i = this.options.current).onFocus) == null ? void 0 : s.call(i, ...r)
        },
        onSelectionUpdate: (...r) => {
          var i, s
          return (s = (i = this.options.current).onSelectionUpdate) == null
            ? void 0
            : s.call(i, ...r)
        },
        onTransaction: (...r) => {
          var i, s
          return (s = (i = this.options.current).onTransaction) == null ? void 0 : s.call(i, ...r)
        },
        onUpdate: (...r) => {
          var i, s
          return (s = (i = this.options.current).onUpdate) == null ? void 0 : s.call(i, ...r)
        },
        onContentError: (...r) => {
          var i, s
          return (s = (i = this.options.current).onContentError) == null ? void 0 : s.call(i, ...r)
        },
        onDrop: (...r) => {
          var i, s
          return (s = (i = this.options.current).onDrop) == null ? void 0 : s.call(i, ...r)
        },
        onPaste: (...r) => {
          var i, s
          return (s = (i = this.options.current).onPaste) == null ? void 0 : s.call(i, ...r)
        },
        onDelete: (...r) => {
          var i, s
          return (s = (i = this.options.current).onDelete) == null ? void 0 : s.call(i, ...r)
        },
      }
      return new fq(n)
    }
    getEditor() {
      return this.editor
    }
    getServerSnapshot() {
      return null
    }
    subscribe(n) {
      return (
        this.subscriptions.add(n),
        () => {
          this.subscriptions.delete(n)
        }
      )
    }
    static compareOptions(n, t) {
      return Object.keys(n).every((r) =>
        [
          'onCreate',
          'onBeforeCreate',
          'onDestroy',
          'onUpdate',
          'onTransaction',
          'onFocus',
          'onBlur',
          'onSelectionUpdate',
          'onContentError',
          'onDrop',
          'onPaste',
        ].includes(r)
          ? !0
          : r === 'extensions' && n.extensions && t.extensions
            ? n.extensions.length !== t.extensions.length
              ? !1
              : n.extensions.every((i, s) => {
                  var o
                  return i === ((o = t.extensions) == null ? void 0 : o[s])
                })
            : n[r] === t[r],
      )
    }
    onRender(n) {
      return () => (
        (this.isComponentMounted = !0),
        clearTimeout(this.scheduledDestructionTimeout),
        this.editor && !this.editor.isDestroyed && n.length === 0
          ? g_.compareOptions(this.options.current, this.editor.options) ||
            this.editor.setOptions({ ...this.options.current, editable: this.editor.isEditable })
          : this.refreshEditorInstance(n),
        () => {
          ;((this.isComponentMounted = !1), this.scheduleDestroy())
        }
      )
    }
    refreshEditorInstance(n) {
      if (this.editor && !this.editor.isDestroyed) {
        if (this.previousDeps === null) {
          this.previousDeps = n
          return
        }
        if (this.previousDeps.length === n.length && this.previousDeps.every((r, i) => r === n[i]))
          return
      }
      ;(this.editor && !this.editor.isDestroyed && this.editor.destroy(),
        this.setEditor(this.createEditor()),
        (this.previousDeps = n))
    }
    scheduleDestroy() {
      const n = this.instanceId,
        t = this.editor
      this.scheduledDestructionTimeout = setTimeout(() => {
        if (this.isComponentMounted && this.instanceId === n) {
          t && t.setOptions(this.options.current)
          return
        }
        t && !t.isDestroyed && (t.destroy(), this.instanceId === n && this.setEditor(null))
      }, 1)
    }
  }
function xJ(e = {}, n = []) {
  const t = Y.useRef(e)
  t.current = e
  const [r] = Y.useState(() => new Nq(t)),
    i = Em.useSyncExternalStore(r.subscribe, r.getEditor, r.getServerSnapshot)
  return (
    Y.useDebugValue(i),
    Y.useEffect(r.onRender(n)),
    Rq({
      editor: i,
      selector: ({ transactionNumber: s }) =>
        e.shouldRerenderOnTransaction === !1 || e.shouldRerenderOnTransaction === void 0
          ? null
          : e.immediatelyRender && s === 0
            ? 0
            : s + 1,
    }),
    i
  )
}
var Iq = Y.createContext({ editor: null })
Iq.Consumer
var Dq = Y.createContext({
    onDragStart: () => {},
    nodeViewContentChildren: void 0,
    nodeViewContentRef: () => {},
  }),
  jq = () => Y.useContext(Dq)
ut.forwardRef((e, n) => {
  const { onDragStart: t } = jq(),
    r = e.as || 'div'
  return Cn.jsx(r, {
    ...e,
    ref: n,
    'data-node-view-wrapper': '',
    onDragStart: t,
    style: { whiteSpace: 'normal', ...e.style },
  })
})
ut.createContext({ markViewContentRef: () => {} })
var Vu = (e, n) => {
    if (e === 'slot') return 0
    if (e instanceof Function) return e(n)
    const { children: t, ...r } = n ?? {}
    if (e === 'svg')
      throw new Error(
        'SVG elements are not supported in the JSX syntax, use the array syntax instead',
      )
    return [e, r, t]
  },
  Lq = /^\s*>\s$/,
  Fq = Gn.create({
    name: 'blockquote',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    content: 'block+',
    group: 'block',
    defining: !0,
    parseHTML() {
      return [{ tag: 'blockquote' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return Vu('blockquote', { ...en(this.options.HTMLAttributes, e), children: Vu('slot', {}) })
    },
    parseMarkdown: (e, n) => n.createNode('blockquote', void 0, n.parseChildren(e.tokens || [])),
    renderMarkdown: (e, n) => {
      if (!e.content) return ''
      const t = []
      return (
        e.content.forEach((i) => {
          const o = n
            .renderChildren(i)
            .split(
              `
`,
            )
            .map((a) => `> ${a}`).join(`
`)
          t.push(o)
        }),
        t.flatMap((i) => [i, '> ']).slice(0, -1).join(`
`)
      )
    },
    addCommands() {
      return {
        setBlockquote:
          () =>
          ({ commands: e }) =>
            e.wrapIn(this.name),
        toggleBlockquote:
          () =>
          ({ commands: e }) =>
            e.toggleWrap(this.name),
        unsetBlockquote:
          () =>
          ({ commands: e }) =>
            e.lift(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-b': () => this.editor.commands.toggleBlockquote() }
    },
    addInputRules() {
      return [Uo({ find: Lq, type: this.type })]
    },
  }),
  Bq = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
  zq = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
  $q = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
  Vq = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
  Hq = Us.create({
    name: 'bold',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: 'strong' },
        { tag: 'b', getAttrs: (e) => e.style.fontWeight !== 'normal' && null },
        { style: 'font-weight=400', clearMark: (e) => e.type.name === this.name },
        { style: 'font-weight', getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return Vu('strong', { ...en(this.options.HTMLAttributes, e), children: Vu('slot', {}) })
    },
    markdownTokenName: 'strong',
    parseMarkdown: (e, n) => n.applyMark('bold', n.parseInline(e.tokens || [])),
    renderMarkdown: (e, n) => `**${n.renderChildren(e)}**`,
    addCommands() {
      return {
        setBold:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleBold:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetBold:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-b': () => this.editor.commands.toggleBold(),
        'Mod-B': () => this.editor.commands.toggleBold(),
      }
    },
    addInputRules() {
      return [Ho({ find: Bq, type: this.type }), Ho({ find: $q, type: this.type })]
    },
    addPasteRules() {
      return [$s({ find: zq, type: this.type }), $s({ find: Vq, type: this.type })]
    },
  }),
  Uq = /(^|[^`])`([^`]+)`(?!`)$/,
  qq = /(^|[^`])`([^`]+)`(?!`)/g,
  Wq = Us.create({
    name: 'code',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    excludes: '_',
    code: !0,
    exitable: !0,
    parseHTML() {
      return [{ tag: 'code' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['code', en(this.options.HTMLAttributes, e), 0]
    },
    markdownTokenName: 'codespan',
    parseMarkdown: (e, n) => n.applyMark('code', [{ type: 'text', text: e.text || '' }]),
    renderMarkdown: (e, n) => (e.content ? `\`${n.renderChildren(e.content)}\`` : ''),
    addCommands() {
      return {
        setCode:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleCode:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetCode:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-e': () => this.editor.commands.toggleCode() }
    },
    addInputRules() {
      return [Ho({ find: Uq, type: this.type })]
    },
    addPasteRules() {
      return [$s({ find: qq, type: this.type })]
    },
  }),
  _h = 4,
  Kq = /^```([a-z]+)?[\s\n]$/,
  Gq = /^~~~([a-z]+)?[\s\n]$/,
  Xq = Gn.create({
    name: 'codeBlock',
    addOptions() {
      return {
        languageClassPrefix: 'language-',
        exitOnTripleEnter: !0,
        exitOnArrowDown: !0,
        defaultLanguage: null,
        enableTabIndentation: !1,
        tabSize: _h,
        HTMLAttributes: {},
      }
    },
    content: 'text*',
    marks: '',
    group: 'block',
    code: !0,
    defining: !0,
    addAttributes() {
      return {
        language: {
          default: this.options.defaultLanguage,
          parseHTML: (e) => {
            var n
            const { languageClassPrefix: t } = this.options
            if (!t) return null
            const s = [...(((n = e.firstElementChild) == null ? void 0 : n.classList) || [])]
              .filter((o) => o.startsWith(t))
              .map((o) => o.replace(t, ''))[0]
            return s || null
          },
          rendered: !1,
        },
      }
    },
    parseHTML() {
      return [{ tag: 'pre', preserveWhitespace: 'full' }]
    },
    renderHTML({ node: e, HTMLAttributes: n }) {
      return [
        'pre',
        en(this.options.HTMLAttributes, n),
        [
          'code',
          { class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null },
          0,
        ],
      ]
    },
    markdownTokenName: 'code',
    parseMarkdown: (e, n) => {
      var t
      return ((t = e.raw) == null ? void 0 : t.startsWith('```')) === !1 &&
        e.codeBlockStyle !== 'indented'
        ? []
        : n.createNode(
            'codeBlock',
            { language: e.lang || null },
            e.text ? [n.createTextNode(e.text)] : [],
          )
    },
    renderMarkdown: (e, n) => {
      var t
      let r = ''
      const i = ((t = e.attrs) == null ? void 0 : t.language) || ''
      return (
        e.content
          ? (r = [`\`\`\`${i}`, n.renderChildren(e.content), '```'].join(`
`))
          : (r = `\`\`\`${i}

\`\`\``),
        r
      )
    },
    addCommands() {
      return {
        setCodeBlock:
          (e) =>
          ({ commands: n }) =>
            n.setNode(this.name, e),
        toggleCodeBlock:
          (e) =>
          ({ commands: n }) =>
            n.toggleNode(this.name, 'paragraph', e),
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),
        Backspace: () => {
          const { empty: e, $anchor: n } = this.editor.state.selection,
            t = n.pos === 1
          return !e || n.parent.type.name !== this.name
            ? !1
            : t || !n.parent.textContent.length
              ? this.editor.commands.clearNodes()
              : !1
        },
        Tab: ({ editor: e }) => {
          var n
          if (!this.options.enableTabIndentation) return !1
          const t = (n = this.options.tabSize) != null ? n : _h,
            { state: r } = e,
            { selection: i } = r,
            { $from: s, empty: o } = i
          if (s.parent.type !== this.type) return !1
          const a = ' '.repeat(t)
          return o
            ? e.commands.insertContent(a)
            : e.commands.command(({ tr: l }) => {
                const { from: c, to: u } = i,
                  h = r.doc
                    .textBetween(
                      c,
                      u,
                      `
`,
                      `
`,
                    )
                    .split(
                      `
`,
                    )
                    .map((p) => a + p).join(`
`)
                return (l.replaceWith(c, u, r.schema.text(h)), !0)
              })
        },
        'Shift-Tab': ({ editor: e }) => {
          var n
          if (!this.options.enableTabIndentation) return !1
          const t = (n = this.options.tabSize) != null ? n : _h,
            { state: r } = e,
            { selection: i } = r,
            { $from: s, empty: o } = i
          return s.parent.type !== this.type
            ? !1
            : o
              ? e.commands.command(({ tr: a }) => {
                  var l
                  const { pos: c } = s,
                    u = s.start(),
                    f = s.end(),
                    h = r.doc.textBetween(
                      u,
                      f,
                      `
`,
                      `
`,
                    ).split(`
`)
                  let p = 0,
                    g = 0
                  const m = c - u
                  for (let I = 0; I < h.length; I += 1) {
                    if (g + h[I].length >= m) {
                      p = I
                      break
                    }
                    g += h[I].length + 1
                  }
                  const b = ((l = h[p].match(/^ */)) == null ? void 0 : l[0]) || '',
                    w = Math.min(b.length, t)
                  if (w === 0) return !0
                  let C = u
                  for (let I = 0; I < p; I += 1) C += h[I].length + 1
                  return (a.delete(C, C + w), c - C <= w && a.setSelection(oe.create(a.doc, C)), !0)
                })
              : e.commands.command(({ tr: a }) => {
                  const { from: l, to: c } = i,
                    d = r.doc
                      .textBetween(
                        l,
                        c,
                        `
`,
                        `
`,
                      )
                      .split(
                        `
`,
                      )
                      .map((h) => {
                        var p
                        const g = ((p = h.match(/^ */)) == null ? void 0 : p[0]) || '',
                          m = Math.min(g.length, t)
                        return h.slice(m)
                      }).join(`
`)
                  return (a.replaceWith(l, c, r.schema.text(d)), !0)
                })
        },
        Enter: ({ editor: e }) => {
          if (!this.options.exitOnTripleEnter) return !1
          const { state: n } = e,
            { selection: t } = n,
            { $from: r, empty: i } = t
          if (!i || r.parent.type !== this.type) return !1
          const s = r.parentOffset === r.parent.nodeSize - 2,
            o = r.parent.textContent.endsWith(`

`)
          return !s || !o
            ? !1
            : e
                .chain()
                .command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0))
                .exitCode()
                .run()
        },
        ArrowDown: ({ editor: e }) => {
          if (!this.options.exitOnArrowDown) return !1
          const { state: n } = e,
            { selection: t, doc: r } = n,
            { $from: i, empty: s } = t
          if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
            return !1
          const a = i.after()
          return a === void 0
            ? !1
            : r.nodeAt(a)
              ? e.commands.command(({ tr: c }) => (c.setSelection(ye.near(r.resolve(a))), !0))
              : e.commands.exitCode()
        },
      }
    },
    addInputRules() {
      return [
        um({ find: Kq, type: this.type, getAttributes: (e) => ({ language: e[1] }) }),
        um({ find: Gq, type: this.type, getAttributes: (e) => ({ language: e[1] }) }),
      ]
    },
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('codeBlockVSCodeHandler'),
          props: {
            handlePaste: (e, n) => {
              if (!n.clipboardData || this.editor.isActive(this.type.name)) return !1
              const t = n.clipboardData.getData('text/plain'),
                r = n.clipboardData.getData('vscode-editor-data'),
                i = r ? JSON.parse(r) : void 0,
                s = i?.mode
              if (!t || !s) return !1
              const { tr: o, schema: a } = e.state,
                l = a.text(
                  t.replace(
                    /\r\n?/g,
                    `
`,
                  ),
                )
              return (
                o.replaceSelectionWith(this.type.create({ language: s }, l)),
                o.selection.$from.parent.type !== this.type &&
                  o.setSelection(oe.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))),
                o.setMeta('paste', !0),
                e.dispatch(o),
                !0
              )
            },
          },
        }),
      ]
    },
  }),
  Yq = Gn.create({
    name: 'doc',
    topNode: !0,
    content: 'block+',
    renderMarkdown: (e, n) =>
      e.content
        ? n.renderChildren(
            e.content,
            `

`,
          )
        : '',
  }),
  Zq = Gn.create({
    name: 'hardBreak',
    addOptions() {
      return { keepMarks: !0, HTMLAttributes: {} }
    },
    inline: !0,
    group: 'inline',
    selectable: !1,
    linebreakReplacement: !0,
    parseHTML() {
      return [{ tag: 'br' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['br', en(this.options.HTMLAttributes, e)]
    },
    renderText() {
      return `
`
    },
    renderMarkdown: (e, n) =>
      n.indent(`
`),
    addCommands() {
      return {
        setHardBreak:
          () =>
          ({ commands: e, chain: n, state: t, editor: r }) =>
            e.first([
              () => e.exitCode(),
              () =>
                e.command(() => {
                  const { selection: i, storedMarks: s } = t
                  if (i.$from.parent.type.spec.isolating) return !1
                  const { keepMarks: o } = this.options,
                    { splittableMarks: a } = r.extensionManager,
                    l = s || (i.$to.parentOffset && i.$from.marks())
                  return n()
                    .insertContent({ type: this.name })
                    .command(({ tr: c, dispatch: u }) => {
                      if (u && l && o) {
                        const f = l.filter((d) => a.includes(d.type.name))
                        c.ensureMarks(f)
                      }
                      return !0
                    })
                    .run()
                }),
            ]),
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-Enter': () => this.editor.commands.setHardBreak(),
        'Shift-Enter': () => this.editor.commands.setHardBreak(),
      }
    },
  }),
  Jq = Gn.create({
    name: 'heading',
    addOptions() {
      return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} }
    },
    content: 'inline*',
    group: 'block',
    defining: !0,
    addAttributes() {
      return { level: { default: 1, rendered: !1 } }
    },
    parseHTML() {
      return this.options.levels.map((e) => ({ tag: `h${e}`, attrs: { level: e } }))
    },
    renderHTML({ node: e, HTMLAttributes: n }) {
      return [
        `h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`,
        en(this.options.HTMLAttributes, n),
        0,
      ]
    },
    parseMarkdown: (e, n) =>
      n.createNode('heading', { level: e.depth || 1 }, n.parseInline(e.tokens || [])),
    renderMarkdown: (e, n) => {
      var t
      const r = (t = e.attrs) != null && t.level ? parseInt(e.attrs.level, 10) : 1,
        i = '#'.repeat(r)
      return e.content ? `${i} ${n.renderChildren(e.content)}` : ''
    },
    addCommands() {
      return {
        setHeading:
          (e) =>
          ({ commands: n }) =>
            this.options.levels.includes(e.level) ? n.setNode(this.name, e) : !1,
        toggleHeading:
          (e) =>
          ({ commands: n }) =>
            this.options.levels.includes(e.level) ? n.toggleNode(this.name, 'paragraph', e) : !1,
      }
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce(
        (e, n) => ({
          ...e,
          [`Mod-Alt-${n}`]: () => this.editor.commands.toggleHeading({ level: n }),
        }),
        {},
      )
    },
    addInputRules() {
      return this.options.levels.map((e) =>
        um({
          find: new RegExp(`^(#{${Math.min(...this.options.levels)},${e}})\\s$`),
          type: this.type,
          getAttributes: { level: e },
        }),
      )
    },
  }),
  Qq = Gn.create({
    name: 'horizontalRule',
    addOptions() {
      return { HTMLAttributes: {}, nextNodeType: 'paragraph' }
    },
    group: 'block',
    parseHTML() {
      return [{ tag: 'hr' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['hr', en(this.options.HTMLAttributes, e)]
    },
    markdownTokenName: 'hr',
    parseMarkdown: (e, n) => n.createNode('horizontalRule'),
    renderMarkdown: () => '---',
    addCommands() {
      return {
        setHorizontalRule:
          () =>
          ({ chain: e, state: n }) => {
            if (!hq(n, n.schema.nodes[this.name])) return !1
            const { selection: t } = n,
              { $to: r } = t,
              i = e()
            return (
              e_(t)
                ? i.insertContentAt(r.pos, { type: this.name })
                : i.insertContent({ type: this.name }),
              i
                .command(({ state: s, tr: o, dispatch: a }) => {
                  if (a) {
                    const { $to: l } = o.selection,
                      c = l.end()
                    if (l.nodeAfter)
                      l.nodeAfter.isTextblock
                        ? o.setSelection(oe.create(o.doc, l.pos + 1))
                        : l.nodeAfter.isBlock
                          ? o.setSelection(Zt.create(o.doc, l.pos))
                          : o.setSelection(oe.create(o.doc, l.pos))
                    else {
                      const u =
                          s.schema.nodes[this.options.nextNodeType] ||
                          l.parent.type.contentMatch.defaultType,
                        f = u?.create()
                      f && (o.insert(c, f), o.setSelection(oe.create(o.doc, c + 1)))
                    }
                    o.scrollIntoView()
                  }
                  return !0
                })
                .run()
            )
          },
      }
    },
    addInputRules() {
      return [dq({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })]
    },
  }),
  tW = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
  eW = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
  nW = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
  rW = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
  iW = Us.create({
    name: 'italic',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: 'em' },
        { tag: 'i', getAttrs: (e) => e.style.fontStyle !== 'normal' && null },
        { style: 'font-style=normal', clearMark: (e) => e.type.name === this.name },
        { style: 'font-style=italic' },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['em', en(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setItalic:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleItalic:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetItalic:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    markdownTokenName: 'em',
    parseMarkdown: (e, n) => n.applyMark('italic', n.parseInline(e.tokens || [])),
    renderMarkdown: (e, n) => `*${n.renderChildren(e)}*`,
    addKeyboardShortcuts() {
      return {
        'Mod-i': () => this.editor.commands.toggleItalic(),
        'Mod-I': () => this.editor.commands.toggleItalic(),
      }
    },
    addInputRules() {
      return [Ho({ find: tW, type: this.type }), Ho({ find: nW, type: this.type })]
    },
    addPasteRules() {
      return [$s({ find: eW, type: this.type }), $s({ find: rW, type: this.type })]
    },
  })
const sW =
    'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2',
  oW =
    '121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222',
  hm = 'numeric',
  pm = 'ascii',
  mm = 'alpha',
  Va = 'asciinumeric',
  ka = 'alphanumeric',
  gm = 'domain',
  y_ = 'emoji',
  aW = 'scheme',
  lW = 'slashscheme',
  kh = 'whitespace'
function cW(e, n) {
  return (e in n || (n[e] = []), n[e])
}
function gs(e, n, t) {
  ;(n[hm] && ((n[Va] = !0), (n[ka] = !0)),
    n[pm] && ((n[Va] = !0), (n[mm] = !0)),
    n[Va] && (n[ka] = !0),
    n[mm] && (n[ka] = !0),
    n[ka] && (n[gm] = !0),
    n[y_] && (n[gm] = !0))
  for (const r in n) {
    const i = cW(r, t)
    i.indexOf(e) < 0 && i.push(e)
  }
}
function uW(e, n) {
  const t = {}
  for (const r in n) n[r].indexOf(e) >= 0 && (t[r] = !0)
  return t
}
function jn(e = null) {
  ;((this.j = {}), (this.jr = []), (this.jd = null), (this.t = e))
}
jn.groups = {}
jn.prototype = {
  accepts() {
    return !!this.t
  },
  go(e) {
    const n = this,
      t = n.j[e]
    if (t) return t
    for (let r = 0; r < n.jr.length; r++) {
      const i = n.jr[r][0],
        s = n.jr[r][1]
      if (s && i.test(e)) return s
    }
    return n.jd
  },
  has(e, n = !1) {
    return n ? e in this.j : !!this.go(e)
  },
  ta(e, n, t, r) {
    for (let i = 0; i < e.length; i++) this.tt(e[i], n, t, r)
  },
  tr(e, n, t, r) {
    r = r || jn.groups
    let i
    return (n && n.j ? (i = n) : ((i = new jn(n)), t && r && gs(n, t, r)), this.jr.push([e, i]), i)
  },
  ts(e, n, t, r) {
    let i = this
    const s = e.length
    if (!s) return i
    for (let o = 0; o < s - 1; o++) i = i.tt(e[o])
    return i.tt(e[s - 1], n, t, r)
  },
  tt(e, n, t, r) {
    r = r || jn.groups
    const i = this
    if (n && n.j) return ((i.j[e] = n), n)
    const s = n
    let o,
      a = i.go(e)
    if (
      (a
        ? ((o = new jn()),
          Object.assign(o.j, a.j),
          o.jr.push.apply(o.jr, a.jr),
          (o.jd = a.jd),
          (o.t = a.t))
        : (o = new jn()),
      s)
    ) {
      if (r)
        if (o.t && typeof o.t == 'string') {
          const l = Object.assign(uW(o.t, r), t)
          gs(s, l, r)
        } else t && gs(s, t, r)
      o.t = s
    }
    return ((i.j[e] = o), o)
  },
}
const ge = (e, n, t, r, i) => e.ta(n, t, r, i),
  He = (e, n, t, r, i) => e.tr(n, t, r, i),
  y2 = (e, n, t, r, i) => e.ts(n, t, r, i),
  kt = (e, n, t, r, i) => e.tt(n, t, r, i),
  Wr = 'WORD',
  ym = 'UWORD',
  b_ = 'ASCIINUMERICAL',
  v_ = 'ALPHANUMERICAL',
  Sl = 'LOCALHOST',
  bm = 'TLD',
  vm = 'UTLD',
  Hc = 'SCHEME',
  oo = 'SLASH_SCHEME',
  jg = 'NUM',
  wm = 'WS',
  Lg = 'NL',
  Ha = 'OPENBRACE',
  Ua = 'CLOSEBRACE',
  Hu = 'OPENBRACKET',
  Uu = 'CLOSEBRACKET',
  qu = 'OPENPAREN',
  Wu = 'CLOSEPAREN',
  Ku = 'OPENANGLEBRACKET',
  Gu = 'CLOSEANGLEBRACKET',
  Xu = 'FULLWIDTHLEFTPAREN',
  Yu = 'FULLWIDTHRIGHTPAREN',
  Zu = 'LEFTCORNERBRACKET',
  Ju = 'RIGHTCORNERBRACKET',
  Qu = 'LEFTWHITECORNERBRACKET',
  tf = 'RIGHTWHITECORNERBRACKET',
  ef = 'FULLWIDTHLESSTHAN',
  nf = 'FULLWIDTHGREATERTHAN',
  rf = 'AMPERSAND',
  sf = 'APOSTROPHE',
  of = 'ASTERISK',
  xi = 'AT',
  af = 'BACKSLASH',
  lf = 'BACKTICK',
  cf = 'CARET',
  Mi = 'COLON',
  Fg = 'COMMA',
  uf = 'DOLLAR',
  Cr = 'DOT',
  ff = 'EQUALS',
  Bg = 'EXCLAMATION',
  Jn = 'HYPHEN',
  qa = 'PERCENT',
  df = 'PIPE',
  hf = 'PLUS',
  pf = 'POUND',
  Wa = 'QUERY',
  zg = 'QUOTE',
  w_ = 'FULLWIDTHMIDDLEDOT',
  $g = 'SEMI',
  Mr = 'SLASH',
  Ka = 'TILDE',
  mf = 'UNDERSCORE',
  x_ = 'EMOJI',
  gf = 'SYM'
var S_ = Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: v_,
  AMPERSAND: rf,
  APOSTROPHE: sf,
  ASCIINUMERICAL: b_,
  ASTERISK: of,
  AT: xi,
  BACKSLASH: af,
  BACKTICK: lf,
  CARET: cf,
  CLOSEANGLEBRACKET: Gu,
  CLOSEBRACE: Ua,
  CLOSEBRACKET: Uu,
  CLOSEPAREN: Wu,
  COLON: Mi,
  COMMA: Fg,
  DOLLAR: uf,
  DOT: Cr,
  EMOJI: x_,
  EQUALS: ff,
  EXCLAMATION: Bg,
  FULLWIDTHGREATERTHAN: nf,
  FULLWIDTHLEFTPAREN: Xu,
  FULLWIDTHLESSTHAN: ef,
  FULLWIDTHMIDDLEDOT: w_,
  FULLWIDTHRIGHTPAREN: Yu,
  HYPHEN: Jn,
  LEFTCORNERBRACKET: Zu,
  LEFTWHITECORNERBRACKET: Qu,
  LOCALHOST: Sl,
  NL: Lg,
  NUM: jg,
  OPENANGLEBRACKET: Ku,
  OPENBRACE: Ha,
  OPENBRACKET: Hu,
  OPENPAREN: qu,
  PERCENT: qa,
  PIPE: df,
  PLUS: hf,
  POUND: pf,
  QUERY: Wa,
  QUOTE: zg,
  RIGHTCORNERBRACKET: Ju,
  RIGHTWHITECORNERBRACKET: tf,
  SCHEME: Hc,
  SEMI: $g,
  SLASH: Mr,
  SLASH_SCHEME: oo,
  SYM: gf,
  TILDE: Ka,
  TLD: bm,
  UNDERSCORE: mf,
  UTLD: vm,
  UWORD: ym,
  WORD: Wr,
  WS: wm,
})
const Ur = /[a-z]/,
  pa = /\p{L}/u,
  Ch = /\p{Emoji}/u,
  qr = /\d/,
  Mh = /\s/,
  b2 = '\r',
  Eh = `
`,
  fW = '',
  dW = '',
  Th = ''
let Ec = null,
  Tc = null
function hW(e = []) {
  const n = {}
  jn.groups = n
  const t = new jn()
  ;(Ec == null && (Ec = v2(sW)),
    Tc == null && (Tc = v2(oW)),
    kt(t, "'", sf),
    kt(t, '{', Ha),
    kt(t, '}', Ua),
    kt(t, '[', Hu),
    kt(t, ']', Uu),
    kt(t, '(', qu),
    kt(t, ')', Wu),
    kt(t, '<', Ku),
    kt(t, '>', Gu),
    kt(t, '', Xu),
    kt(t, '', Yu),
    kt(t, '', Zu),
    kt(t, '', Ju),
    kt(t, '', Qu),
    kt(t, '', tf),
    kt(t, '', ef),
    kt(t, '', nf),
    kt(t, '&', rf),
    kt(t, '*', of),
    kt(t, '@', xi),
    kt(t, '`', lf),
    kt(t, '^', cf),
    kt(t, ':', Mi),
    kt(t, ',', Fg),
    kt(t, '$', uf),
    kt(t, '.', Cr),
    kt(t, '=', ff),
    kt(t, '!', Bg),
    kt(t, '-', Jn),
    kt(t, '%', qa),
    kt(t, '|', df),
    kt(t, '+', hf),
    kt(t, '#', pf),
    kt(t, '?', Wa),
    kt(t, '"', zg),
    kt(t, '/', Mr),
    kt(t, ';', $g),
    kt(t, '~', Ka),
    kt(t, '_', mf),
    kt(t, '\\', af),
    kt(t, '', w_))
  const r = He(t, qr, jg, { [hm]: !0 })
  He(r, qr, r)
  const i = He(r, Ur, b_, { [Va]: !0 }),
    s = He(r, pa, v_, { [ka]: !0 }),
    o = He(t, Ur, Wr, { [pm]: !0 })
  ;(He(o, qr, i), He(o, Ur, o), He(i, qr, i), He(i, Ur, i))
  const a = He(t, pa, ym, { [mm]: !0 })
  ;(He(a, Ur), He(a, qr, s), He(a, pa, a), He(s, qr, s), He(s, Ur), He(s, pa, s))
  const l = kt(t, Eh, Lg, { [kh]: !0 }),
    c = kt(t, b2, wm, { [kh]: !0 }),
    u = He(t, Mh, wm, { [kh]: !0 })
  ;(kt(t, Th, u),
    kt(c, Eh, l),
    kt(c, Th, u),
    He(c, Mh, u),
    kt(u, b2),
    kt(u, Eh),
    He(u, Mh, u),
    kt(u, Th, u))
  const f = He(t, Ch, x_, { [y_]: !0 })
  ;(kt(f, '#'), He(f, Ch, f), kt(f, fW, f))
  const d = kt(f, dW)
  ;(kt(d, '#'), He(d, Ch, f))
  const h = [
      [Ur, o],
      [qr, i],
    ],
    p = [
      [Ur, null],
      [pa, a],
      [qr, s],
    ]
  for (let g = 0; g < Ec.length; g++) pi(t, Ec[g], bm, Wr, h)
  for (let g = 0; g < Tc.length; g++) pi(t, Tc[g], vm, ym, p)
  ;(gs(bm, { tld: !0, ascii: !0 }, n),
    gs(vm, { utld: !0, alpha: !0 }, n),
    pi(t, 'file', Hc, Wr, h),
    pi(t, 'mailto', Hc, Wr, h),
    pi(t, 'http', oo, Wr, h),
    pi(t, 'https', oo, Wr, h),
    pi(t, 'ftp', oo, Wr, h),
    pi(t, 'ftps', oo, Wr, h),
    gs(Hc, { scheme: !0, ascii: !0 }, n),
    gs(oo, { slashscheme: !0, ascii: !0 }, n),
    (e = e.sort((g, m) => (g[0] > m[0] ? 1 : -1))))
  for (let g = 0; g < e.length; g++) {
    const m = e[g][0],
      b = e[g][1] ? { [aW]: !0 } : { [lW]: !0 }
    ;(m.indexOf('-') >= 0
      ? (b[gm] = !0)
      : Ur.test(m)
        ? qr.test(m)
          ? (b[Va] = !0)
          : (b[pm] = !0)
        : (b[hm] = !0),
      y2(t, m, m, b))
  }
  return (
    y2(t, 'localhost', Sl, { ascii: !0 }),
    (t.jd = new jn(gf)),
    { start: t, tokens: Object.assign({ groups: n }, S_) }
  )
}
function __(e, n) {
  const t = pW(n.replace(/[A-Z]/g, (a) => a.toLowerCase())),
    r = t.length,
    i = []
  let s = 0,
    o = 0
  for (; o < r; ) {
    let a = e,
      l = null,
      c = 0,
      u = null,
      f = -1,
      d = -1
    for (; o < r && (l = a.go(t[o])); )
      ((a = l),
        a.accepts() ? ((f = 0), (d = 0), (u = a)) : f >= 0 && ((f += t[o].length), d++),
        (c += t[o].length),
        (s += t[o].length),
        o++)
    ;((s -= f), (o -= d), (c -= f), i.push({ t: u.t, v: n.slice(s - c, s), s: s - c, e: s }))
  }
  return i
}
function pW(e) {
  const n = [],
    t = e.length
  let r = 0
  for (; r < t; ) {
    let i = e.charCodeAt(r),
      s,
      o =
        i < 55296 || i > 56319 || r + 1 === t || (s = e.charCodeAt(r + 1)) < 56320 || s > 57343
          ? e[r]
          : e.slice(r, r + 2)
    ;(n.push(o), (r += o.length))
  }
  return n
}
function pi(e, n, t, r, i) {
  let s
  const o = n.length
  for (let a = 0; a < o - 1; a++) {
    const l = n[a]
    ;(e.j[l] ? (s = e.j[l]) : ((s = new jn(r)), (s.jr = i.slice()), (e.j[l] = s)), (e = s))
  }
  return ((s = new jn(t)), (s.jr = i.slice()), (e.j[n[o - 1]] = s), s)
}
function v2(e) {
  const n = [],
    t = []
  let r = 0,
    i = '0123456789'
  for (; r < e.length; ) {
    let s = 0
    for (; i.indexOf(e[r + s]) >= 0; ) s++
    if (s > 0) {
      n.push(t.join(''))
      for (let o = parseInt(e.substring(r, r + s), 10); o > 0; o--) t.pop()
      r += s
    } else (t.push(e[r]), r++)
  }
  return n
}
const _l = {
  defaultProtocol: 'http',
  events: null,
  format: w2,
  formatHref: w2,
  nl2br: !1,
  tagName: 'a',
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null,
}
function Vg(e, n = null) {
  let t = Object.assign({}, _l)
  e && (t = Object.assign(t, e instanceof Vg ? e.o : e))
  const r = t.ignoreTags,
    i = []
  for (let s = 0; s < r.length; s++) i.push(r[s].toUpperCase())
  ;((this.o = t), n && (this.defaultRender = n), (this.ignoreTags = i))
}
Vg.prototype = {
  o: _l,
  ignoreTags: [],
  defaultRender(e) {
    return e
  },
  check(e) {
    return this.get('validate', e.toString(), e)
  },
  get(e, n, t) {
    const r = n != null
    let i = this.o[e]
    return (
      i &&
      (typeof i == 'object'
        ? ((i = t.t in i ? i[t.t] : _l[e]), typeof i == 'function' && r && (i = i(n, t)))
        : typeof i == 'function' && r && (i = i(n, t.t, t)),
      i)
    )
  },
  getObj(e, n, t) {
    let r = this.o[e]
    return (typeof r == 'function' && n != null && (r = r(n, t.t, t)), r)
  },
  render(e) {
    const n = e.render(this)
    return (this.get('render', null, e) || this.defaultRender)(n, e.t, e)
  },
}
function w2(e) {
  return e
}
function k_(e, n) {
  ;((this.t = 'token'), (this.v = e), (this.tk = n))
}
k_.prototype = {
  isLink: !1,
  toString() {
    return this.v
  },
  toHref(e) {
    return this.toString()
  },
  toFormattedString(e) {
    const n = this.toString(),
      t = e.get('truncate', n, this),
      r = e.get('format', n, this)
    return t && r.length > t ? r.substring(0, t) + '' : r
  },
  toFormattedHref(e) {
    return e.get('formatHref', this.toHref(e.get('defaultProtocol')), this)
  },
  startIndex() {
    return this.tk[0].s
  },
  endIndex() {
    return this.tk[this.tk.length - 1].e
  },
  toObject(e = _l.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(e),
      start: this.startIndex(),
      end: this.endIndex(),
    }
  },
  toFormattedObject(e) {
    return {
      type: this.t,
      value: this.toFormattedString(e),
      isLink: this.isLink,
      href: this.toFormattedHref(e),
      start: this.startIndex(),
      end: this.endIndex(),
    }
  },
  validate(e) {
    return e.get('validate', this.toString(), this)
  },
  render(e) {
    const n = this,
      t = this.toHref(e.get('defaultProtocol')),
      r = e.get('formatHref', t, this),
      i = e.get('tagName', t, n),
      s = this.toFormattedString(e),
      o = {},
      a = e.get('className', t, n),
      l = e.get('target', t, n),
      c = e.get('rel', t, n),
      u = e.getObj('attributes', t, n),
      f = e.getObj('events', t, n)
    return (
      (o.href = r),
      a && (o.class = a),
      l && (o.target = l),
      c && (o.rel = c),
      u && Object.assign(o, u),
      { tagName: i, attributes: o, content: s, eventListeners: f }
    )
  },
}
function ld(e, n) {
  class t extends k_ {
    constructor(i, s) {
      ;(super(i, s), (this.t = e))
    }
  }
  for (const r in n) t.prototype[r] = n[r]
  return ((t.t = e), t)
}
const x2 = ld('email', {
    isLink: !0,
    toHref() {
      return 'mailto:' + this.toString()
    },
  }),
  S2 = ld('text'),
  mW = ld('nl'),
  Ac = ld('url', {
    isLink: !0,
    toHref(e = _l.defaultProtocol) {
      return this.hasProtocol() ? this.v : `${e}://${this.v}`
    },
    hasProtocol() {
      const e = this.tk
      return e.length >= 2 && e[0].t !== Sl && e[1].t === Mi
    },
  }),
  Yn = (e) => new jn(e)
function gW({ groups: e }) {
  const n = e.domain.concat([
      rf,
      of,
      xi,
      af,
      lf,
      cf,
      uf,
      ff,
      Jn,
      jg,
      qa,
      df,
      hf,
      pf,
      Mr,
      gf,
      Ka,
      mf,
    ]),
    t = [
      sf,
      Mi,
      Fg,
      Cr,
      Bg,
      qa,
      Wa,
      zg,
      $g,
      Ku,
      Gu,
      Ha,
      Ua,
      Uu,
      Hu,
      qu,
      Wu,
      Xu,
      Yu,
      Zu,
      Ju,
      Qu,
      tf,
      ef,
      nf,
    ],
    r = [rf, sf, of, af, lf, cf, uf, ff, Jn, Ha, Ua, qa, df, hf, pf, Wa, Mr, gf, Ka, mf],
    i = Yn(),
    s = kt(i, Ka)
  ;(ge(s, r, s), ge(s, e.domain, s))
  const o = Yn(),
    a = Yn(),
    l = Yn()
  ;(ge(i, e.domain, o),
    ge(i, e.scheme, a),
    ge(i, e.slashscheme, l),
    ge(o, r, s),
    ge(o, e.domain, o))
  const c = kt(o, xi)
  ;(kt(s, xi, c), kt(a, xi, c), kt(l, xi, c))
  const u = kt(s, Cr)
  ;(ge(u, r, s), ge(u, e.domain, s))
  const f = Yn()
  ;(ge(c, e.domain, f), ge(f, e.domain, f))
  const d = kt(f, Cr)
  ge(d, e.domain, f)
  const h = Yn(x2)
  ;(ge(d, e.tld, h), ge(d, e.utld, h), kt(c, Sl, h))
  const p = kt(f, Jn)
  ;(kt(p, Jn, p), ge(p, e.domain, f), ge(h, e.domain, f), kt(h, Cr, d), kt(h, Jn, p))
  const g = kt(h, Mi)
  ge(g, e.numeric, x2)
  const m = kt(o, Jn),
    y = kt(o, Cr)
  ;(kt(m, Jn, m), ge(m, e.domain, o), ge(y, r, s), ge(y, e.domain, o))
  const b = Yn(Ac)
  ;(ge(y, e.tld, b),
    ge(y, e.utld, b),
    ge(b, e.domain, o),
    ge(b, r, s),
    kt(b, Cr, y),
    kt(b, Jn, m),
    kt(b, xi, c))
  const w = kt(b, Mi),
    C = Yn(Ac)
  ge(w, e.numeric, C)
  const T = Yn(Ac),
    I = Yn()
  ;(ge(T, n, T), ge(T, t, I), ge(I, n, T), ge(I, t, I), kt(b, Mr, T), kt(C, Mr, T))
  const B = kt(a, Mi),
    E = kt(l, Mi),
    O = kt(E, Mr),
    P = kt(O, Mr)
  ;(ge(a, e.domain, o),
    kt(a, Cr, y),
    kt(a, Jn, m),
    ge(l, e.domain, o),
    kt(l, Cr, y),
    kt(l, Jn, m),
    ge(B, e.domain, T),
    kt(B, Mr, T),
    kt(B, Wa, T),
    ge(P, e.domain, T),
    ge(P, n, T),
    kt(P, Mr, T))
  const $ = [
    [Ha, Ua],
    [Hu, Uu],
    [qu, Wu],
    [Ku, Gu],
    [Xu, Yu],
    [Zu, Ju],
    [Qu, tf],
    [ef, nf],
  ]
  for (let F = 0; F < $.length; F++) {
    const [M, R] = $[F],
      k = kt(T, M)
    ;(kt(I, M, k), kt(k, R, T))
    const v = Yn(Ac)
    ge(k, n, v)
    const x = Yn()
    ;(ge(k, t), ge(v, n, v), ge(v, t, x), ge(x, n, v), ge(x, t, x), kt(v, R, T), kt(x, R, T))
  }
  return (kt(i, Sl, b), kt(i, Lg, mW), { start: i, tokens: S_ })
}
function yW(e, n, t) {
  let r = t.length,
    i = 0,
    s = [],
    o = []
  for (; i < r; ) {
    let a = e,
      l = null,
      c = null,
      u = 0,
      f = null,
      d = -1
    for (; i < r && !(l = a.go(t[i].t)); ) o.push(t[i++])
    for (; i < r && (c = l || a.go(t[i].t)); )
      ((l = null), (a = c), a.accepts() ? ((d = 0), (f = a)) : d >= 0 && d++, i++, u++)
    if (d < 0) ((i -= u), i < r && (o.push(t[i]), i++))
    else {
      ;(o.length > 0 && (s.push(Ah(S2, n, o)), (o = [])), (i -= d), (u -= d))
      const h = f.t,
        p = t.slice(i - u, i)
      s.push(Ah(h, n, p))
    }
  }
  return (o.length > 0 && s.push(Ah(S2, n, o)), s)
}
function Ah(e, n, t) {
  const r = t[0].s,
    i = t[t.length - 1].e,
    s = n.slice(r, i)
  return new e(s, t)
}
const bW = (typeof console < 'u' && console && console.warn) || (() => {}),
  vW =
    'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.',
  De = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: !1,
  }
function wW() {
  return (
    (jn.groups = {}),
    (De.scanner = null),
    (De.parser = null),
    (De.tokenQueue = []),
    (De.pluginQueue = []),
    (De.customSchemes = []),
    (De.initialized = !1),
    De
  )
}
function _2(e, n = !1) {
  if (
    (De.initialized &&
      bW(`linkifyjs: already initialized - will not register custom scheme "${e}" ${vW}`),
    !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
  )
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`)
  De.customSchemes.push([e, n])
}
function xW() {
  De.scanner = hW(De.customSchemes)
  for (let e = 0; e < De.tokenQueue.length; e++) De.tokenQueue[e][1]({ scanner: De.scanner })
  De.parser = gW(De.scanner.tokens)
  for (let e = 0; e < De.pluginQueue.length; e++)
    De.pluginQueue[e][1]({ scanner: De.scanner, parser: De.parser })
  return ((De.initialized = !0), De)
}
function Hg(e) {
  return (De.initialized || xW(), yW(De.parser.start, e, __(De.scanner.start, e)))
}
Hg.scan = __
function C_(e, n = null, t = null) {
  if (n && typeof n == 'object') {
    if (t) throw Error(`linkifyjs: Invalid link type ${n}; must be a string`)
    ;((t = n), (n = null))
  }
  const r = new Vg(t),
    i = Hg(e),
    s = []
  for (let o = 0; o < i.length; o++) {
    const a = i[o]
    a.isLink && (!n || a.t === n) && r.check(a) && s.push(a.toFormattedObject(r))
  }
  return s
}
var Ug = '[\0- -\u2029]',
  SW = new RegExp(Ug),
  _W = new RegExp(`${Ug}$`),
  kW = new RegExp(Ug, 'g')
function CW(e) {
  return e.length === 1
    ? e[0].isLink
    : e.length === 3 && e[1].isLink
      ? ['()', '[]'].includes(e[0].value + e[2].value)
      : !1
}
function MW(e) {
  return new Ke({
    key: new hn('autolink'),
    appendTransaction: (n, t, r) => {
      const i = n.some((c) => c.docChanged) && !t.doc.eq(r.doc),
        s = n.some((c) => c.getMeta('preventAutolink'))
      if (!i || s) return
      const { tr: o } = r,
        a = KS(t.doc, [...n])
      if (
        (t_(a).forEach(({ newRange: c }) => {
          const u = yU(r.doc, c, (h) => h.isTextblock)
          let f, d
          if (u.length > 1)
            ((f = u[0]), (d = r.doc.textBetween(f.pos, f.pos + f.node.nodeSize, void 0, ' ')))
          else if (u.length) {
            const h = r.doc.textBetween(c.from, c.to, ' ', ' ')
            if (!_W.test(h)) return
            ;((f = u[0]), (d = r.doc.textBetween(f.pos, c.to, void 0, ' ')))
          }
          if (f && d) {
            const h = d.split(SW).filter(Boolean)
            if (h.length <= 0) return !1
            const p = h[h.length - 1],
              g = f.pos + d.lastIndexOf(p)
            if (!p) return !1
            const m = Hg(p).map((y) => y.toObject(e.defaultProtocol))
            if (!CW(m)) return !1
            m.filter((y) => y.isLink)
              .map((y) => ({ ...y, from: g + y.start + 1, to: g + y.end + 1 }))
              .filter((y) =>
                r.schema.marks.code ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code) : !0,
              )
              .filter((y) => e.validate(y.value))
              .filter((y) => e.shouldAutoLink(y.value))
              .forEach((y) => {
                Og(y.from, y.to, r.doc).some((b) => b.mark.type === e.type) ||
                  o.addMark(y.from, y.to, e.type.create({ href: y.href }))
              })
          }
        }),
        !!o.steps.length)
      )
        return o
    },
  })
}
function EW(e) {
  return new Ke({
    key: new hn('handleClickLink'),
    props: {
      handleClick: (n, t, r) => {
        var i, s
        if (r.button !== 0 || !n.editable) return !1
        let o = null
        if (r.target instanceof HTMLAnchorElement) o = r.target
        else {
          let u = r.target
          const f = []
          for (; u.nodeName !== 'DIV'; ) (f.push(u), (u = u.parentNode))
          o = f.find((d) => d.nodeName === 'A')
        }
        if (!o) return !1
        const a = QS(n.state, e.type.name),
          l = (i = o?.href) != null ? i : a.href,
          c = (s = o?.target) != null ? s : a.target
        return (
          e.enableClickSelection && e.editor.commands.extendMarkRange(e.type.name),
          o && l ? (window.open(l, c), !0) : !1
        )
      },
    },
  })
}
function TW(e) {
  return new Ke({
    key: new hn('handlePasteLink'),
    props: {
      handlePaste: (n, t, r) => {
        const { shouldAutoLink: i } = e,
          { state: s } = n,
          { selection: o } = s,
          { empty: a } = o
        if (a) return !1
        let l = ''
        r.content.forEach((u) => {
          l += u.textContent
        })
        const c = C_(l, { defaultProtocol: e.defaultProtocol }).find(
          (u) => u.isLink && u.value === l,
        )
        return !l || !c || (i !== void 0 && !i(c.href))
          ? !1
          : e.editor.commands.setMark(e.type, { href: c.href })
      },
    },
  })
}
function es(e, n) {
  const t = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp']
  return (
    n &&
      n.forEach((r) => {
        const i = typeof r == 'string' ? r : r.scheme
        i && t.push(i)
      }),
    !e ||
      e
        .replace(kW, '')
        .match(new RegExp(`^(?:(?:${t.join('|')}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`, 'i'))
  )
}
var M_ = Us.create({
    name: 'link',
    priority: 1e3,
    keepOnSplit: !1,
    exitable: !0,
    onCreate() {
      ;(this.options.validate &&
        !this.options.shouldAutoLink &&
        ((this.options.shouldAutoLink = this.options.validate),
        console.warn(
          'The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.',
        )),
        this.options.protocols.forEach((e) => {
          if (typeof e == 'string') {
            _2(e)
            return
          }
          _2(e.scheme, e.optionalSlashes)
        }))
    },
    onDestroy() {
      wW()
    },
    inclusive() {
      return this.options.autolink
    },
    addOptions() {
      return {
        openOnClick: !0,
        enableClickSelection: !1,
        linkOnPaste: !0,
        autolink: !0,
        protocols: [],
        defaultProtocol: 'http',
        HTMLAttributes: { target: '_blank', rel: 'noopener noreferrer nofollow', class: null },
        isAllowedUri: (e, n) => !!es(e, n.protocols),
        validate: (e) => !!e,
        shouldAutoLink: (e) => !!e,
      }
    },
    addAttributes() {
      return {
        href: {
          default: null,
          parseHTML(e) {
            return e.getAttribute('href')
          },
        },
        target: { default: this.options.HTMLAttributes.target },
        rel: { default: this.options.HTMLAttributes.rel },
        class: { default: this.options.HTMLAttributes.class },
      }
    },
    parseHTML() {
      return [
        {
          tag: 'a[href]',
          getAttrs: (e) => {
            const n = e.getAttribute('href')
            return !n ||
              !this.options.isAllowedUri(n, {
                defaultValidate: (t) => !!es(t, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol,
              })
              ? !1
              : null
          },
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return this.options.isAllowedUri(e.href, {
        defaultValidate: (n) => !!es(n, this.options.protocols),
        protocols: this.options.protocols,
        defaultProtocol: this.options.defaultProtocol,
      })
        ? ['a', en(this.options.HTMLAttributes, e), 0]
        : ['a', en(this.options.HTMLAttributes, { ...e, href: '' }), 0]
    },
    markdownTokenName: 'link',
    parseMarkdown: (e, n) =>
      n.applyMark('link', n.parseInline(e.tokens || []), { href: e.href, title: e.title || null }),
    renderMarkdown: (e, n) => {
      var t
      const r = ((t = e.attrs) == null ? void 0 : t.href) || ''
      return `[${n.renderChildren(e)}](${r})`
    },
    addCommands() {
      return {
        setLink:
          (e) =>
          ({ chain: n }) => {
            const { href: t } = e
            return this.options.isAllowedUri(t, {
              defaultValidate: (r) => !!es(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol,
            })
              ? n().setMark(this.name, e).setMeta('preventAutolink', !0).run()
              : !1
          },
        toggleLink:
          (e) =>
          ({ chain: n }) => {
            const { href: t } = e || {}
            return t &&
              !this.options.isAllowedUri(t, {
                defaultValidate: (r) => !!es(r, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol,
              })
              ? !1
              : n()
                  .toggleMark(this.name, e, { extendEmptyMarkRange: !0 })
                  .setMeta('preventAutolink', !0)
                  .run()
          },
        unsetLink:
          () =>
          ({ chain: e }) =>
            e()
              .unsetMark(this.name, { extendEmptyMarkRange: !0 })
              .setMeta('preventAutolink', !0)
              .run(),
      }
    },
    addPasteRules() {
      return [
        $s({
          find: (e) => {
            const n = []
            if (e) {
              const { protocols: t, defaultProtocol: r } = this.options,
                i = C_(e).filter(
                  (s) =>
                    s.isLink &&
                    this.options.isAllowedUri(s.value, {
                      defaultValidate: (o) => !!es(o, t),
                      protocols: t,
                      defaultProtocol: r,
                    }),
                )
              i.length &&
                i.forEach((s) => {
                  this.options.shouldAutoLink(s.value) &&
                    n.push({ text: s.value, data: { href: s.href }, index: s.start })
                })
            }
            return n
          },
          type: this.type,
          getAttributes: (e) => {
            var n
            return { href: (n = e.data) == null ? void 0 : n.href }
          },
        }),
      ]
    },
    addProseMirrorPlugins() {
      const e = [],
        { protocols: n, defaultProtocol: t } = this.options
      return (
        this.options.autolink &&
          e.push(
            MW({
              type: this.type,
              defaultProtocol: this.options.defaultProtocol,
              validate: (r) =>
                this.options.isAllowedUri(r, {
                  defaultValidate: (i) => !!es(i, n),
                  protocols: n,
                  defaultProtocol: t,
                }),
              shouldAutoLink: this.options.shouldAutoLink,
            }),
          ),
        this.options.openOnClick === !0 &&
          e.push(
            EW({
              type: this.type,
              editor: this.editor,
              enableClickSelection: this.options.enableClickSelection,
            }),
          ),
        this.options.linkOnPaste &&
          e.push(
            TW({
              editor: this.editor,
              defaultProtocol: this.options.defaultProtocol,
              type: this.type,
              shouldAutoLink: this.options.shouldAutoLink,
            }),
          ),
        e
      )
    },
  }),
  SJ = M_,
  AW = Object.defineProperty,
  RW = (e, n) => {
    for (var t in n) AW(e, t, { get: n[t], enumerable: !0 })
  },
  OW = 'listItem',
  k2 = 'textStyle',
  C2 = /^\s*([-+*])\s$/,
  E_ = Gn.create({
    name: 'bulletList',
    addOptions() {
      return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 }
    },
    group: 'block list',
    content() {
      return `${this.options.itemTypeName}+`
    },
    parseHTML() {
      return [{ tag: 'ul' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['ul', en(this.options.HTMLAttributes, e), 0]
    },
    markdownTokenName: 'list',
    parseMarkdown: (e, n) =>
      e.type !== 'list' || e.ordered
        ? []
        : { type: 'bulletList', content: e.items ? n.parseChildren(e.items) : [] },
    renderMarkdown: (e, n) =>
      e.content
        ? n.renderChildren(
            e.content,
            `
`,
          )
        : '',
    markdownOptions: { indentsContent: !0 },
    addCommands() {
      return {
        toggleBulletList:
          () =>
          ({ commands: e, chain: n }) =>
            this.options.keepAttributes
              ? n()
                  .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
                  .updateAttributes(OW, this.editor.getAttributes(k2))
                  .run()
              : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks),
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-8': () => this.editor.commands.toggleBulletList() }
    },
    addInputRules() {
      let e = Uo({ find: C2, type: this.type })
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (e = Uo({
            find: C2,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => this.editor.getAttributes(k2),
            editor: this.editor,
          })),
        [e]
      )
    },
  }),
  T_ = Gn.create({
    name: 'listItem',
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: 'bulletList',
        orderedListTypeName: 'orderedList',
      }
    },
    content: 'paragraph block*',
    defining: !0,
    parseHTML() {
      return [{ tag: 'li' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['li', en(this.options.HTMLAttributes, e), 0]
    },
    markdownTokenName: 'list_item',
    parseMarkdown: (e, n) => {
      if (e.type !== 'list_item') return []
      let t = []
      if (e.tokens && e.tokens.length > 0)
        if (e.tokens.some((i) => i.type === 'paragraph')) t = n.parseChildren(e.tokens)
        else {
          const i = e.tokens[0]
          if (i && i.type === 'text' && i.tokens && i.tokens.length > 0) {
            if (
              ((t = [{ type: 'paragraph', content: n.parseInline(i.tokens) }]), e.tokens.length > 1)
            ) {
              const o = e.tokens.slice(1),
                a = n.parseChildren(o)
              t.push(...a)
            }
          } else t = n.parseChildren(e.tokens)
        }
      return (
        t.length === 0 && (t = [{ type: 'paragraph', content: [] }]),
        { type: 'listItem', content: t }
      )
    },
    renderMarkdown: (e, n, t) =>
      Dg(
        e,
        n,
        (r) =>
          r.parentType === 'bulletList'
            ? '- '
            : r.parentType === 'orderedList'
              ? `${r.index + 1}. `
              : '- ',
        t,
      ),
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        'Shift-Tab': () => this.editor.commands.liftListItem(this.name),
      }
    },
  }),
  PW = {}
RW(PW, {
  findListItemPos: () => Bl,
  getNextListDepth: () => qg,
  handleBackspace: () => xm,
  handleDelete: () => Sm,
  hasListBefore: () => A_,
  hasListItemAfter: () => NW,
  hasListItemBefore: () => R_,
  listItemHasSubList: () => O_,
  nextListIsDeeper: () => P_,
  nextListIsHigher: () => N_,
})
var Bl = (e, n) => {
    const { $from: t } = n.selection,
      r = tn(e, n.schema)
    let i = null,
      s = t.depth,
      o = t.pos,
      a = null
    for (; s > 0 && a === null; ) ((i = t.node(s)), i.type === r ? (a = s) : ((s -= 1), (o -= 1)))
    return a === null ? null : { $pos: n.doc.resolve(o), depth: a }
  },
  qg = (e, n) => {
    const t = Bl(e, n)
    if (!t) return !1
    const [, r] = EU(n, e, t.$pos.pos + 4)
    return r
  },
  A_ = (e, n, t) => {
    const { $anchor: r } = e.selection,
      i = Math.max(0, r.pos - 2),
      s = e.doc.resolve(i).node()
    return !(!s || !t.includes(s.type.name))
  },
  R_ = (e, n) => {
    var t
    const { $anchor: r } = n.selection,
      i = n.doc.resolve(r.pos - 2)
    return !(i.index() === 0 || ((t = i.nodeBefore) == null ? void 0 : t.type.name) !== e)
  },
  O_ = (e, n, t) => {
    if (!t) return !1
    const r = tn(e, n.schema)
    let i = !1
    return (
      t.descendants((s) => {
        s.type === r && (i = !0)
      }),
      i
    )
  },
  xm = (e, n, t) => {
    if (e.commands.undoInputRule()) return !0
    if (e.state.selection.from !== e.state.selection.to) return !1
    if (!Gi(e.state, n) && A_(e.state, n, t)) {
      const { $anchor: a } = e.state.selection,
        l = e.state.doc.resolve(a.before() - 1),
        c = []
      l.node().descendants((d, h) => {
        d.type.name === n && c.push({ node: d, pos: h })
      })
      const u = c.at(-1)
      if (!u) return !1
      const f = e.state.doc.resolve(l.start() + u.pos + 1)
      return e
        .chain()
        .cut({ from: a.start() - 1, to: a.end() + 1 }, f.end())
        .joinForward()
        .run()
    }
    if (!Gi(e.state, n) || !OU(e.state)) return !1
    const r = Bl(n, e.state)
    if (!r) return !1
    const s = e.state.doc.resolve(r.$pos.pos - 2).node(r.depth),
      o = O_(n, e.state, s)
    return R_(n, e.state) && !o ? e.commands.joinItemBackward() : e.chain().liftListItem(n).run()
  },
  P_ = (e, n) => {
    const t = qg(e, n),
      r = Bl(e, n)
    return !r || !t ? !1 : t > r.depth
  },
  N_ = (e, n) => {
    const t = qg(e, n),
      r = Bl(e, n)
    return !r || !t ? !1 : t < r.depth
  },
  Sm = (e, n) => {
    if (!Gi(e.state, n) || !RU(e.state, n)) return !1
    const { selection: t } = e.state,
      { $from: r, $to: i } = t
    return !t.empty && r.sameParent(i)
      ? !1
      : P_(n, e.state)
        ? e
            .chain()
            .focus(e.state.selection.from + 4)
            .lift(n)
            .joinBackward()
            .run()
        : N_(n, e.state)
          ? e.chain().joinForward().joinBackward().run()
          : e.commands.joinItemForward()
  },
  NW = (e, n) => {
    var t
    const { $anchor: r } = n.selection,
      i = n.doc.resolve(r.pos - r.parentOffset - 2)
    return !(
      i.index() === i.parent.childCount - 1 ||
      ((t = i.nodeAfter) == null ? void 0 : t.type.name) !== e
    )
  },
  I_ = nn.create({
    name: 'listKeymap',
    addOptions() {
      return {
        listTypes: [
          { itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] },
          { itemName: 'taskItem', wrapperNames: ['taskList'] },
        ],
      }
    },
    addKeyboardShortcuts() {
      return {
        Delete: ({ editor: e }) => {
          let n = !1
          return (
            this.options.listTypes.forEach(({ itemName: t }) => {
              e.state.schema.nodes[t] !== void 0 && Sm(e, t) && (n = !0)
            }),
            n
          )
        },
        'Mod-Delete': ({ editor: e }) => {
          let n = !1
          return (
            this.options.listTypes.forEach(({ itemName: t }) => {
              e.state.schema.nodes[t] !== void 0 && Sm(e, t) && (n = !0)
            }),
            n
          )
        },
        Backspace: ({ editor: e }) => {
          let n = !1
          return (
            this.options.listTypes.forEach(({ itemName: t, wrapperNames: r }) => {
              e.state.schema.nodes[t] !== void 0 && xm(e, t, r) && (n = !0)
            }),
            n
          )
        },
        'Mod-Backspace': ({ editor: e }) => {
          let n = !1
          return (
            this.options.listTypes.forEach(({ itemName: t, wrapperNames: r }) => {
              e.state.schema.nodes[t] !== void 0 && xm(e, t, r) && (n = !0)
            }),
            n
          )
        },
      }
    },
  }),
  M2 = /^(\s*)(\d+)\.\s+(.*)$/,
  IW = /^\s/
function DW(e) {
  const n = []
  let t = 0,
    r = 0
  for (; t < e.length; ) {
    const i = e[t],
      s = i.match(M2)
    if (!s) break
    const [, o, a, l] = s,
      c = o.length
    let u = l,
      f = t + 1
    const d = [i]
    for (; f < e.length; ) {
      const h = e[f]
      if (h.match(M2)) break
      if (h.trim() === '')
        (d.push(h),
          (u += `
`),
          (f += 1))
      else if (h.match(IW))
        (d.push(h),
          (u += `
${h.slice(c + 2)}`),
          (f += 1))
      else break
    }
    ;(n.push({
      indent: c,
      number: parseInt(a, 10),
      content: u.trim(),
      raw: d.join(`
`),
    }),
      (r = f),
      (t = f))
  }
  return [n, r]
}
function D_(e, n, t) {
  var r
  const i = []
  let s = 0
  for (; s < e.length; ) {
    const o = e[s]
    if (o.indent === n) {
      const a = o.content.split(`
`),
        l = ((r = a[0]) == null ? void 0 : r.trim()) || '',
        c = []
      l && c.push({ type: 'paragraph', raw: l, tokens: t.inlineTokens(l) })
      const u = a
        .slice(1)
        .join(
          `
`,
        )
        .trim()
      if (u) {
        const h = t.blockTokens(u)
        c.push(...h)
      }
      let f = s + 1
      const d = []
      for (; f < e.length && e[f].indent > n; ) (d.push(e[f]), (f += 1))
      if (d.length > 0) {
        const h = Math.min(...d.map((g) => g.indent)),
          p = D_(d, h, t)
        c.push({
          type: 'list',
          ordered: !0,
          start: d[0].number,
          items: p,
          raw: d.map((g) => g.raw).join(`
`),
        })
      }
      ;(i.push({ type: 'list_item', raw: o.raw, tokens: c }), (s = f))
    } else s += 1
  }
  return i
}
function jW(e, n) {
  return e.map((t) => {
    if (t.type !== 'list_item') return n.parseChildren([t])[0]
    const r = []
    return (
      t.tokens &&
        t.tokens.length > 0 &&
        t.tokens.forEach((i) => {
          if (
            i.type === 'paragraph' ||
            i.type === 'list' ||
            i.type === 'blockquote' ||
            i.type === 'code'
          )
            r.push(...n.parseChildren([i]))
          else if (i.type === 'text' && i.tokens) {
            const s = n.parseChildren([i])
            r.push({ type: 'paragraph', content: s })
          } else {
            const s = n.parseChildren([i])
            s.length > 0 && r.push(...s)
          }
        }),
      { type: 'listItem', content: r }
    )
  })
}
var LW = 'listItem',
  E2 = 'textStyle',
  T2 = /^(\d+)\.\s$/,
  j_ = Gn.create({
    name: 'orderedList',
    addOptions() {
      return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 }
    },
    group: 'block list',
    content() {
      return `${this.options.itemTypeName}+`
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (e) =>
            e.hasAttribute('start') ? parseInt(e.getAttribute('start') || '', 10) : 1,
        },
        type: { default: null, parseHTML: (e) => e.getAttribute('type') },
      }
    },
    parseHTML() {
      return [{ tag: 'ol' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      const { start: n, ...t } = e
      return n === 1
        ? ['ol', en(this.options.HTMLAttributes, t), 0]
        : ['ol', en(this.options.HTMLAttributes, e), 0]
    },
    markdownTokenName: 'list',
    parseMarkdown: (e, n) => {
      if (e.type !== 'list' || !e.ordered) return []
      const t = e.start || 1,
        r = e.items ? jW(e.items, n) : []
      return t !== 1
        ? { type: 'orderedList', attrs: { start: t }, content: r }
        : { type: 'orderedList', content: r }
    },
    renderMarkdown: (e, n) =>
      e.content
        ? n.renderChildren(
            e.content,
            `
`,
          )
        : '',
    markdownTokenizer: {
      name: 'orderedList',
      level: 'block',
      start: (e) => {
        const n = e.match(/^(\s*)(\d+)\.\s+/),
          t = n?.index
        return t !== void 0 ? t : -1
      },
      tokenize: (e, n, t) => {
        var r
        const i = e.split(`
`),
          [s, o] = DW(i)
        if (s.length === 0) return
        const a = D_(s, 0, t)
        return a.length === 0
          ? void 0
          : {
              type: 'list',
              ordered: !0,
              start: ((r = s[0]) == null ? void 0 : r.number) || 1,
              items: a,
              raw: i.slice(0, o).join(`
`),
            }
      },
    },
    markdownOptions: { indentsContent: !0 },
    addCommands() {
      return {
        toggleOrderedList:
          () =>
          ({ commands: e, chain: n }) =>
            this.options.keepAttributes
              ? n()
                  .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
                  .updateAttributes(LW, this.editor.getAttributes(E2))
                  .run()
              : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks),
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-7': () => this.editor.commands.toggleOrderedList() }
    },
    addInputRules() {
      let e = Uo({
        find: T2,
        type: this.type,
        getAttributes: (n) => ({ start: +n[1] }),
        joinPredicate: (n, t) => t.childCount + t.attrs.start === +n[1],
      })
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (e = Uo({
            find: T2,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (n) => ({ start: +n[1], ...this.editor.getAttributes(E2) }),
            joinPredicate: (n, t) => t.childCount + t.attrs.start === +n[1],
            editor: this.editor,
          })),
        [e]
      )
    },
  }),
  FW = /^\s*(\[([( |x])?\])\s$/,
  BW = Gn.create({
    name: 'taskItem',
    addOptions() {
      return { nested: !1, HTMLAttributes: {}, taskListTypeName: 'taskList', a11y: void 0 }
    },
    content() {
      return this.options.nested ? 'paragraph block*' : 'paragraph+'
    },
    defining: !0,
    addAttributes() {
      return {
        checked: {
          default: !1,
          keepOnSplit: !1,
          parseHTML: (e) => {
            const n = e.getAttribute('data-checked')
            return n === '' || n === 'true'
          },
          renderHTML: (e) => ({ 'data-checked': e.checked }),
        },
      }
    },
    parseHTML() {
      return [{ tag: `li[data-type="${this.name}"]`, priority: 51 }]
    },
    renderHTML({ node: e, HTMLAttributes: n }) {
      return [
        'li',
        en(this.options.HTMLAttributes, n, { 'data-type': this.name }),
        [
          'label',
          ['input', { type: 'checkbox', checked: e.attrs.checked ? 'checked' : null }],
          ['span'],
        ],
        ['div', 0],
      ]
    },
    parseMarkdown: (e, n) => {
      const t = []
      if (
        (e.tokens && e.tokens.length > 0
          ? t.push(n.createNode('paragraph', {}, n.parseInline(e.tokens)))
          : e.text
            ? t.push(n.createNode('paragraph', {}, [n.createNode('text', { text: e.text })]))
            : t.push(n.createNode('paragraph', {}, [])),
        e.nestedTokens && e.nestedTokens.length > 0)
      ) {
        const r = n.parseChildren(e.nestedTokens)
        t.push(...r)
      }
      return n.createNode('taskItem', { checked: e.checked || !1 }, t)
    },
    renderMarkdown: (e, n) => {
      var t
      const i = `- [${(t = e.attrs) != null && t.checked ? 'x' : ' '}] `
      return Dg(e, n, i)
    },
    addKeyboardShortcuts() {
      const e = {
        Enter: () => this.editor.commands.splitListItem(this.name),
        'Shift-Tab': () => this.editor.commands.liftListItem(this.name),
      }
      return this.options.nested
        ? { ...e, Tab: () => this.editor.commands.sinkListItem(this.name) }
        : e
    },
    addNodeView() {
      return ({ node: e, HTMLAttributes: n, getPos: t, editor: r }) => {
        const i = document.createElement('li'),
          s = document.createElement('label'),
          o = document.createElement('span'),
          a = document.createElement('input'),
          l = document.createElement('div'),
          c = (u) => {
            var f, d
            a.ariaLabel =
              ((d = (f = this.options.a11y) == null ? void 0 : f.checkboxLabel) == null
                ? void 0
                : d.call(f, u, a.checked)) ||
              `Task item checkbox for ${u.textContent || 'empty task item'}`
          }
        return (
          c(e),
          (s.contentEditable = 'false'),
          (a.type = 'checkbox'),
          a.addEventListener('mousedown', (u) => u.preventDefault()),
          a.addEventListener('change', (u) => {
            if (!r.isEditable && !this.options.onReadOnlyChecked) {
              a.checked = !a.checked
              return
            }
            const { checked: f } = u.target
            ;(r.isEditable &&
              typeof t == 'function' &&
              r
                .chain()
                .focus(void 0, { scrollIntoView: !1 })
                .command(({ tr: d }) => {
                  const h = t()
                  if (typeof h != 'number') return !1
                  const p = d.doc.nodeAt(h)
                  return (d.setNodeMarkup(h, void 0, { ...p?.attrs, checked: f }), !0)
                })
                .run(),
              !r.isEditable &&
                this.options.onReadOnlyChecked &&
                (this.options.onReadOnlyChecked(e, f) || (a.checked = !a.checked)))
          }),
          Object.entries(this.options.HTMLAttributes).forEach(([u, f]) => {
            i.setAttribute(u, f)
          }),
          (i.dataset.checked = e.attrs.checked),
          (a.checked = e.attrs.checked),
          s.append(a, o),
          i.append(s, l),
          Object.entries(n).forEach(([u, f]) => {
            i.setAttribute(u, f)
          }),
          {
            dom: i,
            contentDOM: l,
            update: (u) =>
              u.type !== this.type
                ? !1
                : ((i.dataset.checked = u.attrs.checked), (a.checked = u.attrs.checked), c(u), !0),
          }
        )
      }
    },
    addInputRules() {
      return [
        Uo({
          find: FW,
          type: this.type,
          getAttributes: (e) => ({ checked: e[e.length - 1] === 'x' }),
        }),
      ]
    },
  }),
  zW = Gn.create({
    name: 'taskList',
    addOptions() {
      return { itemTypeName: 'taskItem', HTMLAttributes: {} }
    },
    group: 'block list',
    content() {
      return `${this.options.itemTypeName}+`
    },
    parseHTML() {
      return [{ tag: `ul[data-type="${this.name}"]`, priority: 51 }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['ul', en(this.options.HTMLAttributes, e, { 'data-type': this.name }), 0]
    },
    parseMarkdown: (e, n) => n.createNode('taskList', {}, n.parseChildren(e.items || [])),
    renderMarkdown: (e, n) =>
      e.content
        ? n.renderChildren(
            e.content,
            `
`,
          )
        : '',
    markdownTokenizer: {
      name: 'taskList',
      level: 'block',
      start(e) {
        var n
        const t = (n = e.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : n.index
        return t !== void 0 ? t : -1
      },
      tokenize(e, n, t) {
        const r = (s) => {
            const o = fm(
              s,
              {
                itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
                extractItemData: (a) => ({
                  indentLevel: a[1].length,
                  mainContent: a[4],
                  checked: a[3].toLowerCase() === 'x',
                }),
                createToken: (a, l) => ({
                  type: 'taskItem',
                  raw: '',
                  mainContent: a.mainContent,
                  indentLevel: a.indentLevel,
                  checked: a.checked,
                  text: a.mainContent,
                  tokens: t.inlineTokens(a.mainContent),
                  nestedTokens: l,
                }),
                customNestedParser: r,
              },
              t,
            )
            return o ? [{ type: 'taskList', raw: o.raw, items: o.items }] : t.blockTokens(s)
          },
          i = fm(
            e,
            {
              itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
              extractItemData: (s) => ({
                indentLevel: s[1].length,
                mainContent: s[4],
                checked: s[3].toLowerCase() === 'x',
              }),
              createToken: (s, o) => ({
                type: 'taskItem',
                raw: '',
                mainContent: s.mainContent,
                indentLevel: s.indentLevel,
                checked: s.checked,
                text: s.mainContent,
                tokens: t.inlineTokens(s.mainContent),
                nestedTokens: o,
              }),
              customNestedParser: r,
            },
            t,
          )
        if (i) return { type: 'taskList', raw: i.raw, items: i.items }
      },
    },
    markdownOptions: { indentsContent: !0 },
    addCommands() {
      return {
        toggleTaskList:
          () =>
          ({ commands: e }) =>
            e.toggleList(this.name, this.options.itemTypeName),
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-9': () => this.editor.commands.toggleTaskList() }
    },
  })
nn.create({
  name: 'listKit',
  addExtensions() {
    const e = []
    return (
      this.options.bulletList !== !1 && e.push(E_.configure(this.options.bulletList)),
      this.options.listItem !== !1 && e.push(T_.configure(this.options.listItem)),
      this.options.listKeymap !== !1 && e.push(I_.configure(this.options.listKeymap)),
      this.options.orderedList !== !1 && e.push(j_.configure(this.options.orderedList)),
      this.options.taskItem !== !1 && e.push(BW.configure(this.options.taskItem)),
      this.options.taskList !== !1 && e.push(zW.configure(this.options.taskList)),
      e
    )
  },
})
var $W = Gn.create({
    name: 'paragraph',
    priority: 1e3,
    addOptions() {
      return { HTMLAttributes: {} }
    },
    group: 'block',
    content: 'inline*',
    parseHTML() {
      return [{ tag: 'p' }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['p', en(this.options.HTMLAttributes, e), 0]
    },
    parseMarkdown: (e, n) => {
      const t = e.tokens || []
      return t.length === 1 && t[0].type === 'image'
        ? n.parseChildren([t[0]])
        : n.createNode('paragraph', void 0, n.parseInline(t))
    },
    renderMarkdown: (e, n) => (!e || !Array.isArray(e.content) ? '' : n.renderChildren(e.content)),
    addCommands() {
      return {
        setParagraph:
          () =>
          ({ commands: e }) =>
            e.setNode(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Alt-0': () => this.editor.commands.setParagraph() }
    },
  }),
  VW = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
  HW = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
  UW = Us.create({
    name: 'strike',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: 's' },
        { tag: 'del' },
        { tag: 'strike' },
        {
          style: 'text-decoration',
          consuming: !1,
          getAttrs: (e) => (e.includes('line-through') ? {} : !1),
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['s', en(this.options.HTMLAttributes, e), 0]
    },
    markdownTokenName: 'del',
    parseMarkdown: (e, n) => n.applyMark('strike', n.parseInline(e.tokens || [])),
    renderMarkdown: (e, n) => `~~${n.renderChildren(e)}~~`,
    addCommands() {
      return {
        setStrike:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleStrike:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetStrike:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { 'Mod-Shift-s': () => this.editor.commands.toggleStrike() }
    },
    addInputRules() {
      return [Ho({ find: VW, type: this.type })]
    },
    addPasteRules() {
      return [$s({ find: HW, type: this.type })]
    },
  }),
  qW = Gn.create({
    name: 'text',
    group: 'inline',
    parseMarkdown: (e) => ({ type: 'text', text: e.text || '' }),
    renderMarkdown: (e) => e.text || '',
  }),
  WW = Us.create({
    name: 'underline',
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: 'u' },
        {
          style: 'text-decoration',
          consuming: !1,
          getAttrs: (e) => (e.includes('underline') ? {} : !1),
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ['u', en(this.options.HTMLAttributes, e), 0]
    },
    parseMarkdown(e, n) {
      return n.applyMark(this.name || 'underline', n.parseInline(e.tokens || []))
    },
    renderMarkdown(e, n) {
      return `++${n.renderChildren(e)}++`
    },
    markdownTokenizer: {
      name: 'underline',
      level: 'inline',
      start(e) {
        return e.indexOf('++')
      },
      tokenize(e, n, t) {
        const i = /^(\+\+)([\s\S]+?)(\+\+)/.exec(e)
        if (!i) return
        const s = i[2].trim()
        return { type: 'underline', raw: i[0], text: s, tokens: t.inlineTokens(s) }
      },
    },
    addCommands() {
      return {
        setUnderline:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleUnderline:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetUnderline:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return {
        'Mod-u': () => this.editor.commands.toggleUnderline(),
        'Mod-U': () => this.editor.commands.toggleUnderline(),
      }
    },
  })
function KW(e = {}) {
  return new Ke({
    view(n) {
      return new GW(n, e)
    },
  })
}
class GW {
  constructor(n, t) {
    var r
    ;((this.editorView = n),
      (this.cursorPos = null),
      (this.element = null),
      (this.timeout = -1),
      (this.width = (r = t.width) !== null && r !== void 0 ? r : 1),
      (this.color = t.color === !1 ? void 0 : t.color || 'black'),
      (this.class = t.class),
      (this.handlers = ['dragover', 'dragend', 'drop', 'dragleave'].map((i) => {
        let s = (o) => {
          this[i](o)
        }
        return (n.dom.addEventListener(i, s), { name: i, handler: s })
      })))
  }
  destroy() {
    this.handlers.forEach(({ name: n, handler: t }) =>
      this.editorView.dom.removeEventListener(n, t),
    )
  }
  update(n, t) {
    this.cursorPos != null &&
      t.doc != n.state.doc &&
      (this.cursorPos > n.state.doc.content.size ? this.setCursor(null) : this.updateOverlay())
  }
  setCursor(n) {
    n != this.cursorPos &&
      ((this.cursorPos = n),
      n == null
        ? (this.element.parentNode.removeChild(this.element), (this.element = null))
        : this.updateOverlay())
  }
  updateOverlay() {
    let n = this.editorView.state.doc.resolve(this.cursorPos),
      t = !n.parent.inlineContent,
      r,
      i = this.editorView.dom,
      s = i.getBoundingClientRect(),
      o = s.width / i.offsetWidth,
      a = s.height / i.offsetHeight
    if (t) {
      let f = n.nodeBefore,
        d = n.nodeAfter
      if (f || d) {
        let h = this.editorView.nodeDOM(this.cursorPos - (f ? f.nodeSize : 0))
        if (h) {
          let p = h.getBoundingClientRect(),
            g = f ? p.bottom : p.top
          f &&
            d &&
            (g = (g + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2)
          let m = (this.width / 2) * a
          r = { left: p.left, right: p.right, top: g - m, bottom: g + m }
        }
      }
    }
    if (!r) {
      let f = this.editorView.coordsAtPos(this.cursorPos),
        d = (this.width / 2) * o
      r = { left: f.left - d, right: f.left + d, top: f.top, bottom: f.bottom }
    }
    let l = this.editorView.dom.offsetParent
    ;(this.element ||
      ((this.element = l.appendChild(document.createElement('div'))),
      this.class && (this.element.className = this.class),
      (this.element.style.cssText = 'position: absolute; z-index: 50; pointer-events: none;'),
      this.color && (this.element.style.backgroundColor = this.color)),
      this.element.classList.toggle('prosemirror-dropcursor-block', t),
      this.element.classList.toggle('prosemirror-dropcursor-inline', !t))
    let c, u
    if (!l || (l == document.body && getComputedStyle(l).position == 'static'))
      ((c = -pageXOffset), (u = -pageYOffset))
    else {
      let f = l.getBoundingClientRect(),
        d = f.width / l.offsetWidth,
        h = f.height / l.offsetHeight
      ;((c = f.left - l.scrollLeft * d), (u = f.top - l.scrollTop * h))
    }
    ;((this.element.style.left = (r.left - c) / o + 'px'),
      (this.element.style.top = (r.top - u) / a + 'px'),
      (this.element.style.width = (r.right - r.left) / o + 'px'),
      (this.element.style.height = (r.bottom - r.top) / a + 'px'))
  }
  scheduleRemoval(n) {
    ;(clearTimeout(this.timeout), (this.timeout = setTimeout(() => this.setCursor(null), n)))
  }
  dragover(n) {
    if (!this.editorView.editable) return
    let t = this.editorView.posAtCoords({ left: n.clientX, top: n.clientY }),
      r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside),
      i = r && r.type.spec.disableDropCursor,
      s = typeof i == 'function' ? i(this.editorView, t, n) : i
    if (t && !s) {
      let o = t.pos
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = B5(this.editorView.state.doc, o, this.editorView.dragging.slice)
        a != null && (o = a)
      }
      ;(this.setCursor(o), this.scheduleRemoval(5e3))
    }
  }
  dragend() {
    this.scheduleRemoval(20)
  }
  drop() {
    this.scheduleRemoval(20)
  }
  dragleave(n) {
    this.editorView.dom.contains(n.relatedTarget) || this.setCursor(null)
  }
}
class qe extends ye {
  constructor(n) {
    super(n, n)
  }
  map(n, t) {
    let r = n.resolve(t.map(this.head))
    return qe.valid(r) ? new qe(r) : ye.near(r)
  }
  content() {
    return jt.empty
  }
  eq(n) {
    return n instanceof qe && n.head == this.head
  }
  toJSON() {
    return { type: 'gapcursor', pos: this.head }
  }
  static fromJSON(n, t) {
    if (typeof t.pos != 'number') throw new RangeError('Invalid input for GapCursor.fromJSON')
    return new qe(n.resolve(t.pos))
  }
  getBookmark() {
    return new Wg(this.anchor)
  }
  static valid(n) {
    let t = n.parent
    if (t.isTextblock || !XW(n) || !YW(n)) return !1
    let r = t.type.spec.allowGapCursor
    if (r != null) return r
    let i = t.contentMatchAt(n.index()).defaultType
    return i && i.isTextblock
  }
  static findGapCursorFrom(n, t, r = !1) {
    t: for (;;) {
      if (!r && qe.valid(n)) return n
      let i = n.pos,
        s = null
      for (let o = n.depth; ; o--) {
        let a = n.node(o)
        if (t > 0 ? n.indexAfter(o) < a.childCount : n.index(o) > 0) {
          s = a.child(t > 0 ? n.indexAfter(o) : n.index(o) - 1)
          break
        } else if (o == 0) return null
        i += t
        let l = n.doc.resolve(i)
        if (qe.valid(l)) return l
      }
      for (;;) {
        let o = t > 0 ? s.firstChild : s.lastChild
        if (!o) {
          if (s.isAtom && !s.isText && !Zt.isSelectable(s)) {
            ;((n = n.doc.resolve(i + s.nodeSize * t)), (r = !1))
            continue t
          }
          break
        }
        ;((s = o), (i += t))
        let a = n.doc.resolve(i)
        if (qe.valid(a)) return a
      }
      return null
    }
  }
}
qe.prototype.visible = !1
qe.findFrom = qe.findGapCursorFrom
ye.jsonID('gapcursor', qe)
class Wg {
  constructor(n) {
    this.pos = n
  }
  map(n) {
    return new Wg(n.map(this.pos))
  }
  resolve(n) {
    let t = n.resolve(this.pos)
    return qe.valid(t) ? new qe(t) : ye.near(t)
  }
}
function L_(e) {
  return e.isAtom || e.spec.isolating || e.spec.createGapCursor
}
function XW(e) {
  for (let n = e.depth; n >= 0; n--) {
    let t = e.index(n),
      r = e.node(n)
    if (t == 0) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if ((i.childCount == 0 && !i.inlineContent) || L_(i.type)) return !0
      if (i.inlineContent) return !1
    }
  }
  return !0
}
function YW(e) {
  for (let n = e.depth; n >= 0; n--) {
    let t = e.indexAfter(n),
      r = e.node(n)
    if (t == r.childCount) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if ((i.childCount == 0 && !i.inlineContent) || L_(i.type)) return !0
      if (i.inlineContent) return !1
    }
  }
  return !0
}
function ZW() {
  return new Ke({
    props: {
      decorations: eK,
      createSelectionBetween(e, n, t) {
        return n.pos == t.pos && qe.valid(t) ? new qe(t) : null
      },
      handleClick: QW,
      handleKeyDown: JW,
      handleDOMEvents: { beforeinput: tK },
    },
  })
}
const JW = BS({
  ArrowLeft: Rc('horiz', -1),
  ArrowRight: Rc('horiz', 1),
  ArrowUp: Rc('vert', -1),
  ArrowDown: Rc('vert', 1),
})
function Rc(e, n) {
  const t = e == 'vert' ? (n > 0 ? 'down' : 'up') : n > 0 ? 'right' : 'left'
  return function (r, i, s) {
    let o = r.selection,
      a = n > 0 ? o.$to : o.$from,
      l = o.empty
    if (o instanceof oe) {
      if (!s.endOfTextblock(t) || a.depth == 0) return !1
      ;((l = !1), (a = r.doc.resolve(n > 0 ? a.after() : a.before())))
    }
    let c = qe.findGapCursorFrom(a, n, l)
    return c ? (i && i(r.tr.setSelection(new qe(c))), !0) : !1
  }
}
function QW(e, n, t) {
  if (!e || !e.editable) return !1
  let r = e.state.doc.resolve(n)
  if (!qe.valid(r)) return !1
  let i = e.posAtCoords({ left: t.clientX, top: t.clientY })
  return i && i.inside > -1 && Zt.isSelectable(e.state.doc.nodeAt(i.inside))
    ? !1
    : (e.dispatch(e.state.tr.setSelection(new qe(r))), !0)
}
function tK(e, n) {
  if (n.inputType != 'insertCompositionText' || !(e.state.selection instanceof qe)) return !1
  let { $from: t } = e.state.selection,
    r = t.parent.contentMatchAt(t.index()).findWrapping(e.state.schema.nodes.text)
  if (!r) return !1
  let i = St.empty
  for (let o = r.length - 1; o >= 0; o--) i = St.from(r[o].createAndFill(null, i))
  let s = e.state.tr.replace(t.pos, t.pos, new jt(i, 0, 0))
  return (s.setSelection(oe.near(s.doc.resolve(t.pos + 1))), e.dispatch(s), !1)
}
function eK(e) {
  if (!(e.selection instanceof qe)) return null
  let n = document.createElement('div')
  return (
    (n.className = 'ProseMirror-gapcursor'),
    $e.create(e.doc, [On.widget(e.selection.head, n, { key: 'gapcursor' })])
  )
}
var yf = 200,
  fn = function () {}
fn.prototype.append = function (n) {
  return n.length
    ? ((n = fn.from(n)),
      (!this.length && n) ||
        (n.length < yf && this.leafAppend(n)) ||
        (this.length < yf && n.leafPrepend(this)) ||
        this.appendInner(n))
    : this
}
fn.prototype.prepend = function (n) {
  return n.length ? fn.from(n).append(this) : this
}
fn.prototype.appendInner = function (n) {
  return new nK(this, n)
}
fn.prototype.slice = function (n, t) {
  return (
    n === void 0 && (n = 0),
    t === void 0 && (t = this.length),
    n >= t ? fn.empty : this.sliceInner(Math.max(0, n), Math.min(this.length, t))
  )
}
fn.prototype.get = function (n) {
  if (!(n < 0 || n >= this.length)) return this.getInner(n)
}
fn.prototype.forEach = function (n, t, r) {
  ;(t === void 0 && (t = 0),
    r === void 0 && (r = this.length),
    t <= r ? this.forEachInner(n, t, r, 0) : this.forEachInvertedInner(n, t, r, 0))
}
fn.prototype.map = function (n, t, r) {
  ;(t === void 0 && (t = 0), r === void 0 && (r = this.length))
  var i = []
  return (
    this.forEach(
      function (s, o) {
        return i.push(n(s, o))
      },
      t,
      r,
    ),
    i
  )
}
fn.from = function (n) {
  return n instanceof fn ? n : n && n.length ? new F_(n) : fn.empty
}
var F_ = (function (e) {
  function n(r) {
    ;(e.call(this), (this.values = r))
  }
  ;(e && (n.__proto__ = e),
    (n.prototype = Object.create(e && e.prototype)),
    (n.prototype.constructor = n))
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } }
  return (
    (n.prototype.flatten = function () {
      return this.values
    }),
    (n.prototype.sliceInner = function (i, s) {
      return i == 0 && s == this.length ? this : new n(this.values.slice(i, s))
    }),
    (n.prototype.getInner = function (i) {
      return this.values[i]
    }),
    (n.prototype.forEachInner = function (i, s, o, a) {
      for (var l = s; l < o; l++) if (i(this.values[l], a + l) === !1) return !1
    }),
    (n.prototype.forEachInvertedInner = function (i, s, o, a) {
      for (var l = s - 1; l >= o; l--) if (i(this.values[l], a + l) === !1) return !1
    }),
    (n.prototype.leafAppend = function (i) {
      if (this.length + i.length <= yf) return new n(this.values.concat(i.flatten()))
    }),
    (n.prototype.leafPrepend = function (i) {
      if (this.length + i.length <= yf) return new n(i.flatten().concat(this.values))
    }),
    (t.length.get = function () {
      return this.values.length
    }),
    (t.depth.get = function () {
      return 0
    }),
    Object.defineProperties(n.prototype, t),
    n
  )
})(fn)
fn.empty = new F_([])
var nK = (function (e) {
  function n(t, r) {
    ;(e.call(this),
      (this.left = t),
      (this.right = r),
      (this.length = t.length + r.length),
      (this.depth = Math.max(t.depth, r.depth) + 1))
  }
  return (
    e && (n.__proto__ = e),
    (n.prototype = Object.create(e && e.prototype)),
    (n.prototype.constructor = n),
    (n.prototype.flatten = function () {
      return this.left.flatten().concat(this.right.flatten())
    }),
    (n.prototype.getInner = function (r) {
      return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
    }),
    (n.prototype.forEachInner = function (r, i, s, o) {
      var a = this.left.length
      if (
        (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === !1) ||
        (s > a &&
          this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) ===
            !1)
      )
        return !1
    }),
    (n.prototype.forEachInvertedInner = function (r, i, s, o) {
      var a = this.left.length
      if (
        (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === !1) ||
        (s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === !1)
      )
        return !1
    }),
    (n.prototype.sliceInner = function (r, i) {
      if (r == 0 && i == this.length) return this
      var s = this.left.length
      return i <= s
        ? this.left.slice(r, i)
        : r >= s
          ? this.right.slice(r - s, i - s)
          : this.left.slice(r, s).append(this.right.slice(0, i - s))
    }),
    (n.prototype.leafAppend = function (r) {
      var i = this.right.leafAppend(r)
      if (i) return new n(this.left, i)
    }),
    (n.prototype.leafPrepend = function (r) {
      var i = this.left.leafPrepend(r)
      if (i) return new n(i, this.right)
    }),
    (n.prototype.appendInner = function (r) {
      return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
        ? new n(this.left, new n(this.right, r))
        : new n(this, r)
    }),
    n
  )
})(fn)
const rK = 500
class gr {
  constructor(n, t) {
    ;((this.items = n), (this.eventCount = t))
  }
  popEvent(n, t) {
    if (this.eventCount == 0) return null
    let r = this.items.length
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r
        break
      }
    let i, s
    t && ((i = this.remapping(r, this.items.length)), (s = i.maps.length))
    let o = n.tr,
      a,
      l,
      c = [],
      u = []
    return (
      this.items.forEach(
        (f, d) => {
          if (!f.step) {
            ;(i || ((i = this.remapping(r, d + 1)), (s = i.maps.length)), s--, u.push(f))
            return
          }
          if (i) {
            u.push(new Er(f.map))
            let h = f.step.map(i.slice(s)),
              p
            ;(h &&
              o.maybeStep(h).doc &&
              ((p = o.mapping.maps[o.mapping.maps.length - 1]),
              c.push(new Er(p, void 0, void 0, c.length + u.length))),
              s--,
              p && i.appendMap(p, s))
          } else o.maybeStep(f.step)
          if (f.selection)
            return (
              (a = i ? f.selection.map(i.slice(s)) : f.selection),
              (l = new gr(
                this.items.slice(0, r).append(u.reverse().concat(c)),
                this.eventCount - 1,
              )),
              !1
            )
        },
        this.items.length,
        0,
      ),
      { remaining: l, transform: o, selection: a }
    )
  }
  addTransform(n, t, r, i) {
    let s = [],
      o = this.eventCount,
      a = this.items,
      l = !i && a.length ? a.get(a.length - 1) : null
    for (let u = 0; u < n.steps.length; u++) {
      let f = n.steps[u].invert(n.docs[u]),
        d = new Er(n.mapping.maps[u], f, t),
        h
      ;((h = l && l.merge(d)) && ((d = h), u ? s.pop() : (a = a.slice(0, a.length - 1))),
        s.push(d),
        t && (o++, (t = void 0)),
        i || (l = d))
    }
    let c = o - r.depth
    return (c > sK && ((a = iK(a, c)), (o -= c)), new gr(a.append(s), o))
  }
  remapping(n, t) {
    let r = new ml()
    return (
      this.items.forEach(
        (i, s) => {
          let o =
            i.mirrorOffset != null && s - i.mirrorOffset >= n
              ? r.maps.length - i.mirrorOffset
              : void 0
          r.appendMap(i.map, o)
        },
        n,
        t,
      ),
      r
    )
  }
  addMaps(n) {
    return this.eventCount == 0
      ? this
      : new gr(this.items.append(n.map((t) => new Er(t))), this.eventCount)
  }
  rebased(n, t) {
    if (!this.eventCount) return this
    let r = [],
      i = Math.max(0, this.items.length - t),
      s = n.mapping,
      o = n.steps.length,
      a = this.eventCount
    this.items.forEach((d) => {
      d.selection && a--
    }, i)
    let l = t
    this.items.forEach((d) => {
      let h = s.getMirror(--l)
      if (h == null) return
      o = Math.min(o, h)
      let p = s.maps[h]
      if (d.step) {
        let g = n.steps[h].invert(n.docs[h]),
          m = d.selection && d.selection.map(s.slice(l + 1, h))
        ;(m && a++, r.push(new Er(p, g, m)))
      } else r.push(new Er(p))
    }, i)
    let c = []
    for (let d = t; d < o; d++) c.push(new Er(s.maps[d]))
    let u = this.items.slice(0, i).append(c).append(r),
      f = new gr(u, a)
    return (f.emptyItemCount() > rK && (f = f.compress(this.items.length - r.length)), f)
  }
  emptyItemCount() {
    let n = 0
    return (
      this.items.forEach((t) => {
        t.step || n++
      }),
      n
    )
  }
  compress(n = this.items.length) {
    let t = this.remapping(0, n),
      r = t.maps.length,
      i = [],
      s = 0
    return (
      this.items.forEach(
        (o, a) => {
          if (a >= n) (i.push(o), o.selection && s++)
          else if (o.step) {
            let l = o.step.map(t.slice(r)),
              c = l && l.getMap()
            if ((r--, c && t.appendMap(c, r), l)) {
              let u = o.selection && o.selection.map(t.slice(r))
              u && s++
              let f = new Er(c.invert(), l, u),
                d,
                h = i.length - 1
              ;(d = i.length && i[h].merge(f)) ? (i[h] = d) : i.push(f)
            }
          } else o.map && r--
        },
        this.items.length,
        0,
      ),
      new gr(fn.from(i.reverse()), s)
    )
  }
}
gr.empty = new gr(fn.empty, 0)
function iK(e, n) {
  let t
  return (
    e.forEach((r, i) => {
      if (r.selection && n-- == 0) return ((t = i), !1)
    }),
    e.slice(t)
  )
}
class Er {
  constructor(n, t, r, i) {
    ;((this.map = n), (this.step = t), (this.selection = r), (this.mirrorOffset = i))
  }
  merge(n) {
    if (this.step && n.step && !n.selection) {
      let t = n.step.merge(this.step)
      if (t) return new Er(t.getMap().invert(), t, this.selection)
    }
  }
}
class Si {
  constructor(n, t, r, i, s) {
    ;((this.done = n),
      (this.undone = t),
      (this.prevRanges = r),
      (this.prevTime = i),
      (this.prevComposition = s))
  }
}
const sK = 20
function oK(e, n, t, r) {
  let i = t.getMeta(Ts),
    s
  if (i) return i.historyState
  t.getMeta(cK) && (e = new Si(e.done, e.undone, null, 0, -1))
  let o = t.getMeta('appendedTransaction')
  if (t.steps.length == 0) return e
  if (o && o.getMeta(Ts))
    return o.getMeta(Ts).redo
      ? new Si(
          e.done.addTransform(t, void 0, r, Uc(n)),
          e.undone,
          A2(t.mapping.maps),
          e.prevTime,
          e.prevComposition,
        )
      : new Si(
          e.done,
          e.undone.addTransform(t, void 0, r, Uc(n)),
          null,
          e.prevTime,
          e.prevComposition,
        )
  if (t.getMeta('addToHistory') !== !1 && !(o && o.getMeta('addToHistory') === !1)) {
    let a = t.getMeta('composition'),
      l =
        e.prevTime == 0 ||
        (!o &&
          e.prevComposition != a &&
          (e.prevTime < (t.time || 0) - r.newGroupDelay || !aK(t, e.prevRanges))),
      c = o ? Rh(e.prevRanges, t.mapping) : A2(t.mapping.maps)
    return new Si(
      e.done.addTransform(t, l ? n.selection.getBookmark() : void 0, r, Uc(n)),
      gr.empty,
      c,
      t.time,
      a ?? e.prevComposition,
    )
  } else
    return (s = t.getMeta('rebased'))
      ? new Si(
          e.done.rebased(t, s),
          e.undone.rebased(t, s),
          Rh(e.prevRanges, t.mapping),
          e.prevTime,
          e.prevComposition,
        )
      : new Si(
          e.done.addMaps(t.mapping.maps),
          e.undone.addMaps(t.mapping.maps),
          Rh(e.prevRanges, t.mapping),
          e.prevTime,
          e.prevComposition,
        )
}
function aK(e, n) {
  if (!n) return !1
  if (!e.docChanged) return !0
  let t = !1
  return (
    e.mapping.maps[0].forEach((r, i) => {
      for (let s = 0; s < n.length; s += 2) r <= n[s + 1] && i >= n[s] && (t = !0)
    }),
    t
  )
}
function A2(e) {
  let n = []
  for (let t = e.length - 1; t >= 0 && n.length == 0; t--)
    e[t].forEach((r, i, s, o) => n.push(s, o))
  return n
}
function Rh(e, n) {
  if (!e) return null
  let t = []
  for (let r = 0; r < e.length; r += 2) {
    let i = n.map(e[r], 1),
      s = n.map(e[r + 1], -1)
    i <= s && t.push(i, s)
  }
  return t
}
function lK(e, n, t) {
  let r = Uc(n),
    i = Ts.get(n).spec.config,
    s = (t ? e.undone : e.done).popEvent(n, r)
  if (!s) return null
  let o = s.selection.resolve(s.transform.doc),
    a = (t ? e.done : e.undone).addTransform(s.transform, n.selection.getBookmark(), i, r),
    l = new Si(t ? a : s.remaining, t ? s.remaining : a, null, 0, -1)
  return s.transform.setSelection(o).setMeta(Ts, { redo: t, historyState: l })
}
let Oh = !1,
  R2 = null
function Uc(e) {
  let n = e.plugins
  if (R2 != n) {
    ;((Oh = !1), (R2 = n))
    for (let t = 0; t < n.length; t++)
      if (n[t].spec.historyPreserveItems) {
        Oh = !0
        break
      }
  }
  return Oh
}
const Ts = new hn('history'),
  cK = new hn('closeHistory')
function uK(e = {}) {
  return (
    (e = { depth: e.depth || 100, newGroupDelay: e.newGroupDelay || 500 }),
    new Ke({
      key: Ts,
      state: {
        init() {
          return new Si(gr.empty, gr.empty, null, 0, -1)
        },
        apply(n, t, r) {
          return oK(t, r, n, e)
        },
      },
      config: e,
      props: {
        handleDOMEvents: {
          beforeinput(n, t) {
            let r = t.inputType,
              i = r == 'historyUndo' ? z_ : r == 'historyRedo' ? $_ : null
            return i ? (t.preventDefault(), i(n.state, n.dispatch)) : !1
          },
        },
      },
    })
  )
}
function B_(e, n) {
  return (t, r) => {
    let i = Ts.getState(t)
    if (!i || (e ? i.undone : i.done).eventCount == 0) return !1
    if (r) {
      let s = lK(i, t, e)
      s && r(n ? s.scrollIntoView() : s)
    }
    return !0
  }
}
const z_ = B_(!1, !0),
  $_ = B_(!0, !0)
nn.create({
  name: 'characterCount',
  addOptions() {
    return {
      limit: null,
      mode: 'textSize',
      textCounter: (e) => e.length,
      wordCounter: (e) => e.split(' ').filter((n) => n !== '').length,
    }
  },
  addStorage() {
    return { characters: () => 0, words: () => 0 }
  },
  onBeforeCreate() {
    ;((this.storage.characters = (e) => {
      const n = e?.node || this.editor.state.doc
      if ((e?.mode || this.options.mode) === 'textSize') {
        const r = n.textBetween(0, n.content.size, void 0, ' ')
        return this.options.textCounter(r)
      }
      return n.nodeSize
    }),
      (this.storage.words = (e) => {
        const n = e?.node || this.editor.state.doc,
          t = n.textBetween(0, n.content.size, ' ', ' ')
        return this.options.wordCounter(t)
      }))
  },
  addProseMirrorPlugins() {
    let e = !1
    return [
      new Ke({
        key: new hn('characterCount'),
        appendTransaction: (n, t, r) => {
          if (e) return
          const i = this.options.limit
          if (i == null || i === 0) {
            e = !0
            return
          }
          const s = this.storage.characters({ node: r.doc })
          if (s > i) {
            const o = s - i,
              a = 0,
              l = o
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${i} characters. Content was automatically trimmed.`,
            )
            const c = r.tr.deleteRange(a, l)
            return ((e = !0), c)
          }
          e = !0
        },
        filterTransaction: (n, t) => {
          const r = this.options.limit
          if (!n.docChanged || r === 0 || r === null || r === void 0) return !0
          const i = this.storage.characters({ node: t.doc }),
            s = this.storage.characters({ node: n.doc })
          if (s <= r || (i > r && s > r && s <= i)) return !0
          if ((i > r && s > r && s > i) || !n.getMeta('paste')) return !1
          const a = n.selection.$head.pos,
            l = s - r,
            c = a - l,
            u = a
          return (n.deleteRange(c, u), !(this.storage.characters({ node: n.doc }) > r))
        },
      }),
    ]
  },
})
var fK = nn.create({
  name: 'dropCursor',
  addOptions() {
    return { color: 'currentColor', width: 1, class: void 0 }
  },
  addProseMirrorPlugins() {
    return [KW(this.options)]
  },
})
nn.create({
  name: 'focus',
  addOptions() {
    return { className: 'has-focus', mode: 'all' }
  },
  addProseMirrorPlugins() {
    return [
      new Ke({
        key: new hn('focus'),
        props: {
          decorations: ({ doc: e, selection: n }) => {
            const { isEditable: t, isFocused: r } = this.editor,
              { anchor: i } = n,
              s = []
            if (!t || !r) return $e.create(e, [])
            let o = 0
            this.options.mode === 'deepest' &&
              e.descendants((l, c) => {
                if (l.isText) return
                if (!(i >= c && i <= c + l.nodeSize - 1)) return !1
                o += 1
              })
            let a = 0
            return (
              e.descendants((l, c) => {
                if (l.isText || !(i >= c && i <= c + l.nodeSize - 1)) return !1
                if (
                  ((a += 1),
                  (this.options.mode === 'deepest' && o - a > 0) ||
                    (this.options.mode === 'shallowest' && a > 1))
                )
                  return this.options.mode === 'deepest'
                s.push(On.node(c, c + l.nodeSize, { class: this.options.className }))
              }),
              $e.create(e, s)
            )
          },
        },
      }),
    ]
  },
})
var dK = nn.create({
    name: 'gapCursor',
    addProseMirrorPlugins() {
      return [ZW()]
    },
    extendNodeSchema(e) {
      var n
      const t = { name: e.name, options: e.options, storage: e.storage }
      return { allowGapCursor: (n = Re(Xt(e, 'allowGapCursor', t))) != null ? n : null }
    },
  }),
  hK = nn.create({
    name: 'placeholder',
    addOptions() {
      return {
        emptyEditorClass: 'is-editor-empty',
        emptyNodeClass: 'is-empty',
        placeholder: 'Write something ',
        showOnlyWhenEditable: !0,
        showOnlyCurrent: !0,
        includeChildren: !1,
      }
    },
    addProseMirrorPlugins() {
      return [
        new Ke({
          key: new hn('placeholder'),
          props: {
            decorations: ({ doc: e, selection: n }) => {
              const t = this.editor.isEditable || !this.options.showOnlyWhenEditable,
                { anchor: r } = n,
                i = []
              if (!t) return null
              const s = this.editor.isEmpty
              return (
                e.descendants((o, a) => {
                  const l = r >= a && r <= a + o.nodeSize,
                    c = !o.isLeaf && sd(o)
                  if ((l || !this.options.showOnlyCurrent) && c) {
                    const u = [this.options.emptyNodeClass]
                    s && u.push(this.options.emptyEditorClass)
                    const f = On.node(a, a + o.nodeSize, {
                      class: u.join(' '),
                      'data-placeholder':
                        typeof this.options.placeholder == 'function'
                          ? this.options.placeholder({
                              editor: this.editor,
                              node: o,
                              pos: a,
                              hasAnchor: l,
                            })
                          : this.options.placeholder,
                    })
                    i.push(f)
                  }
                  return this.options.includeChildren
                }),
                $e.create(e, i)
              )
            },
          },
        }),
      ]
    },
  })
nn.create({
  name: 'selection',
  addOptions() {
    return { className: 'selection' }
  },
  addProseMirrorPlugins() {
    const { editor: e, options: n } = this
    return [
      new Ke({
        key: new hn('selection'),
        props: {
          decorations(t) {
            return t.selection.empty ||
              e.isFocused ||
              !e.isEditable ||
              e_(t.selection) ||
              e.view.dragging
              ? null
              : $e.create(t.doc, [
                  On.inline(t.selection.from, t.selection.to, { class: n.className }),
                ])
          },
        },
      }),
    ]
  },
})
function O2({ types: e, node: n }) {
  return (n && Array.isArray(e) && e.includes(n.type)) || n?.type === e
}
var pK = nn.create({
    name: 'trailingNode',
    addOptions() {
      return { node: void 0, notAfter: [] }
    },
    addProseMirrorPlugins() {
      var e
      const n = new hn(this.name),
        t =
          ((e = this.editor.schema.topNodeType.contentMatch.defaultType) == null
            ? void 0
            : e.name) ||
          this.options.node ||
          'paragraph',
        r = Object.entries(this.editor.schema.nodes)
          .map(([, i]) => i)
          .filter((i) => (this.options.notAfter || []).concat(t).includes(i.name))
      return [
        new Ke({
          key: n,
          appendTransaction: (i, s, o) => {
            const { doc: a, tr: l, schema: c } = o,
              u = n.getState(o),
              f = a.content.size,
              d = c.nodes[t]
            if (u) return l.insert(f, d.create())
          },
          state: {
            init: (i, s) => {
              const o = s.tr.doc.lastChild
              return !O2({ node: o, types: r })
            },
            apply: (i, s) => {
              if (!i.docChanged) return s
              const o = i.doc.lastChild
              return !O2({ node: o, types: r })
            },
          },
        }),
      ]
    },
  }),
  mK = nn.create({
    name: 'undoRedo',
    addOptions() {
      return { depth: 100, newGroupDelay: 500 }
    },
    addCommands() {
      return {
        undo:
          () =>
          ({ state: e, dispatch: n }) =>
            z_(e, n),
        redo:
          () =>
          ({ state: e, dispatch: n }) =>
            $_(e, n),
      }
    },
    addProseMirrorPlugins() {
      return [uK(this.options)]
    },
    addKeyboardShortcuts() {
      return {
        'Mod-z': () => this.editor.commands.undo(),
        'Shift-Mod-z': () => this.editor.commands.redo(),
        'Mod-y': () => this.editor.commands.redo(),
        'Mod-': () => this.editor.commands.undo(),
        'Shift-Mod-': () => this.editor.commands.redo(),
      }
    },
  }),
  gK = nn.create({
    name: 'starterKit',
    addExtensions() {
      var e, n, t, r
      const i = []
      return (
        this.options.bold !== !1 && i.push(Hq.configure(this.options.bold)),
        this.options.blockquote !== !1 && i.push(Fq.configure(this.options.blockquote)),
        this.options.bulletList !== !1 && i.push(E_.configure(this.options.bulletList)),
        this.options.code !== !1 && i.push(Wq.configure(this.options.code)),
        this.options.codeBlock !== !1 && i.push(Xq.configure(this.options.codeBlock)),
        this.options.document !== !1 && i.push(Yq.configure(this.options.document)),
        this.options.dropcursor !== !1 && i.push(fK.configure(this.options.dropcursor)),
        this.options.gapcursor !== !1 && i.push(dK.configure(this.options.gapcursor)),
        this.options.hardBreak !== !1 && i.push(Zq.configure(this.options.hardBreak)),
        this.options.heading !== !1 && i.push(Jq.configure(this.options.heading)),
        this.options.undoRedo !== !1 && i.push(mK.configure(this.options.undoRedo)),
        this.options.horizontalRule !== !1 && i.push(Qq.configure(this.options.horizontalRule)),
        this.options.italic !== !1 && i.push(iW.configure(this.options.italic)),
        this.options.listItem !== !1 && i.push(T_.configure(this.options.listItem)),
        this.options.listKeymap !== !1 &&
          i.push(I_.configure((e = this.options) == null ? void 0 : e.listKeymap)),
        this.options.link !== !1 &&
          i.push(M_.configure((n = this.options) == null ? void 0 : n.link)),
        this.options.orderedList !== !1 && i.push(j_.configure(this.options.orderedList)),
        this.options.paragraph !== !1 && i.push($W.configure(this.options.paragraph)),
        this.options.strike !== !1 && i.push(UW.configure(this.options.strike)),
        this.options.text !== !1 && i.push(qW.configure(this.options.text)),
        this.options.underline !== !1 &&
          i.push(WW.configure((t = this.options) == null ? void 0 : t.underline)),
        this.options.trailingNode !== !1 &&
          i.push(pK.configure((r = this.options) == null ? void 0 : r.trailingNode)),
        i
      )
    },
  }),
  _J = gK,
  kJ = hK,
  V_ = { exports: {} }
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ ;(function (e) {
  ;(function () {
    var n = {}.hasOwnProperty
    function t() {
      for (var s = '', o = 0; o < arguments.length; o++) {
        var a = arguments[o]
        a && (s = i(s, r(a)))
      }
      return s
    }
    function r(s) {
      if (typeof s == 'string' || typeof s == 'number') return s
      if (typeof s != 'object') return ''
      if (Array.isArray(s)) return t.apply(null, s)
      if (
        s.toString !== Object.prototype.toString &&
        !s.toString.toString().includes('[native code]')
      )
        return s.toString()
      var o = ''
      for (var a in s) n.call(s, a) && s[a] && (o = i(o, a))
      return o
    }
    function i(s, o) {
      return o ? (s ? s + ' ' + o : s + o) : s
    }
    e.exports ? ((t.default = t), (e.exports = t)) : (window.classNames = t)
  })()
})(V_)
var CJ = V_.exports,
  H_ = { exports: {} }
;(function (e, n) {
  ;(function (t, r) {
    var i = r(t)
    e.exports = i
  })(xe, function (t) {
    var r = ['N', 'E', 'A', 'D']
    function i(E, O) {
      ;((E.super_ = O),
        (E.prototype = Object.create(O.prototype, {
          constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 },
        })))
    }
    function s(E, O) {
      ;(Object.defineProperty(this, 'kind', { value: E, enumerable: !0 }),
        O && O.length && Object.defineProperty(this, 'path', { value: O, enumerable: !0 }))
    }
    function o(E, O, P) {
      ;(o.super_.call(this, 'E', E),
        Object.defineProperty(this, 'lhs', { value: O, enumerable: !0 }),
        Object.defineProperty(this, 'rhs', { value: P, enumerable: !0 }))
    }
    i(o, s)
    function a(E, O) {
      ;(a.super_.call(this, 'N', E),
        Object.defineProperty(this, 'rhs', { value: O, enumerable: !0 }))
    }
    i(a, s)
    function l(E, O) {
      ;(l.super_.call(this, 'D', E),
        Object.defineProperty(this, 'lhs', { value: O, enumerable: !0 }))
    }
    i(l, s)
    function c(E, O, P) {
      ;(c.super_.call(this, 'A', E),
        Object.defineProperty(this, 'index', { value: O, enumerable: !0 }),
        Object.defineProperty(this, 'item', { value: P, enumerable: !0 }))
    }
    i(c, s)
    function u(E, O, P) {
      var $ = E.slice(O + 1 || E.length)
      return ((E.length = O < 0 ? E.length + O : O), E.push.apply(E, $), E)
    }
    function f(E) {
      var O = typeof E
      return O !== 'object'
        ? O
        : E === Math
          ? 'math'
          : E === null
            ? 'null'
            : Array.isArray(E)
              ? 'array'
              : Object.prototype.toString.call(E) === '[object Date]'
                ? 'date'
                : typeof E.toString == 'function' && /^\/.*\//.test(E.toString())
                  ? 'regexp'
                  : 'object'
    }
    function d(E) {
      var O = 0
      if (E.length === 0) return O
      for (var P = 0; P < E.length; P++) {
        var $ = E.charCodeAt(P)
        ;((O = (O << 5) - O + $), (O = O & O))
      }
      return O
    }
    function h(E) {
      var O = 0,
        P = f(E)
      if (P === 'array') {
        E.forEach(function (k) {
          O += h(k)
        })
        var $ = '[type: array, hash: ' + O + ']'
        return O + d($)
      }
      if (P === 'object') {
        for (var F in E)
          if (E.hasOwnProperty(F)) {
            var M = '[ type: object, key: ' + F + ', value hash: ' + h(E[F]) + ']'
            O += d(M)
          }
        return O
      }
      var R = '[ type: ' + P + ' ; value: ' + E + ']'
      return O + d(R)
    }
    function p(E, O, P, $, F, M, R, k) {
      ;((P = P || []), (F = F || []), (R = R || []))
      var v = F.slice(0)
      if (typeof M < 'u' && M !== null) {
        if ($) {
          if (typeof $ == 'function' && $(v, M)) return
          if (typeof $ == 'object') {
            if ($.prefilter && $.prefilter(v, M)) return
            if ($.normalize) {
              var x = $.normalize(v, M, E, O)
              x && ((E = x[0]), (O = x[1]))
            }
          }
        }
        v.push(M)
      }
      f(E) === 'regexp' && f(O) === 'regexp' && ((E = E.toString()), (O = O.toString()))
      var _ = typeof E,
        S = typeof O,
        A,
        j,
        L,
        H,
        U =
          _ !== 'undefined' ||
          (R &&
            R.length > 0 &&
            R[R.length - 1].lhs &&
            Object.getOwnPropertyDescriptor(R[R.length - 1].lhs, M)),
        K =
          S !== 'undefined' ||
          (R &&
            R.length > 0 &&
            R[R.length - 1].rhs &&
            Object.getOwnPropertyDescriptor(R[R.length - 1].rhs, M))
      if (!U && K) P.push(new a(v, O))
      else if (!K && U) P.push(new l(v, E))
      else if (f(E) !== f(O)) P.push(new o(v, E, O))
      else if (f(E) === 'date' && E - O !== 0) P.push(new o(v, E, O))
      else if (_ === 'object' && E !== null && O !== null) {
        for (A = R.length - 1; A > -1; --A)
          if (R[A].lhs === E) {
            H = !0
            break
          }
        if (H) E !== O && P.push(new o(v, E, O))
        else {
          if ((R.push({ lhs: E, rhs: O }), Array.isArray(E))) {
            for (
              k &&
                (E.sort(function (D, N) {
                  return h(D) - h(N)
                }),
                O.sort(function (D, N) {
                  return h(D) - h(N)
                })),
                A = O.length - 1,
                j = E.length - 1;
              A > j;

            )
              P.push(new c(v, A, new a(void 0, O[A--])))
            for (; j > A; ) P.push(new c(v, j, new l(void 0, E[j--])))
            for (; A >= 0; --A) p(E[A], O[A], P, $, v, A, R, k)
          } else {
            var z = Object.keys(E),
              q = Object.keys(O)
            for (A = 0; A < z.length; ++A)
              ((L = z[A]),
                (H = q.indexOf(L)),
                H >= 0
                  ? (p(E[L], O[L], P, $, v, L, R, k), (q[H] = null))
                  : p(E[L], void 0, P, $, v, L, R, k))
            for (A = 0; A < q.length; ++A) ((L = q[A]), L && p(void 0, O[L], P, $, v, L, R, k))
          }
          R.length = R.length - 1
        }
      } else E !== O && ((_ === 'number' && isNaN(E) && isNaN(O)) || P.push(new o(v, E, O)))
    }
    function g(E, O, P, $, F) {
      var M = []
      if ((p(E, O, M, $, null, null, null, F), P)) for (var R = 0; R < M.length; ++R) P(M[R])
      return M
    }
    function m(E, O, P, $, F, M, R) {
      return p(E, O, P, $, F, M, R, !0)
    }
    function y(E, O, P, $) {
      var F = $
          ? function (R) {
              R && $.push(R)
            }
          : void 0,
        M = g(E, O, F, P)
      return $ || (M.length ? M : void 0)
    }
    function b(E, O, P, $) {
      var F = $
          ? function (R) {
              R && $.push(R)
            }
          : void 0,
        M = g(E, O, F, P, !0)
      return $ || (M.length ? M : void 0)
    }
    function w(E, O, P) {
      if (P.path && P.path.length) {
        var $ = E[O],
          F,
          M = P.path.length - 1
        for (F = 0; F < M; F++) $ = $[P.path[F]]
        switch (P.kind) {
          case 'A':
            w($[P.path[F]], P.index, P.item)
            break
          case 'D':
            delete $[P.path[F]]
            break
          case 'E':
          case 'N':
            $[P.path[F]] = P.rhs
            break
        }
      } else
        switch (P.kind) {
          case 'A':
            w(E[O], P.index, P.item)
            break
          case 'D':
            E = u(E, O)
            break
          case 'E':
          case 'N':
            E[O] = P.rhs
            break
        }
      return E
    }
    function C(E, O, P) {
      if ((typeof P > 'u' && O && ~r.indexOf(O.kind) && (P = O), E && P && P.kind)) {
        for (var $ = E, F = -1, M = P.path ? P.path.length - 1 : 0; ++F < M; )
          (typeof $[P.path[F]] > 'u' &&
            ($[P.path[F]] =
              typeof P.path[F + 1] < 'u' && typeof P.path[F + 1] == 'number' ? [] : {}),
            ($ = $[P.path[F]]))
        switch (P.kind) {
          case 'A':
            ;(P.path && typeof $[P.path[F]] > 'u' && ($[P.path[F]] = []),
              w(P.path ? $[P.path[F]] : $, P.index, P.item))
            break
          case 'D':
            delete $[P.path[F]]
            break
          case 'E':
          case 'N':
            $[P.path[F]] = P.rhs
            break
        }
      }
    }
    function T(E, O, P) {
      if (P.path && P.path.length) {
        var $ = E[O],
          F,
          M = P.path.length - 1
        for (F = 0; F < M; F++) $ = $[P.path[F]]
        switch (P.kind) {
          case 'A':
            T($[P.path[F]], P.index, P.item)
            break
          case 'D':
            $[P.path[F]] = P.lhs
            break
          case 'E':
            $[P.path[F]] = P.lhs
            break
          case 'N':
            delete $[P.path[F]]
            break
        }
      } else
        switch (P.kind) {
          case 'A':
            T(E[O], P.index, P.item)
            break
          case 'D':
            E[O] = P.lhs
            break
          case 'E':
            E[O] = P.lhs
            break
          case 'N':
            E = u(E, O)
            break
        }
      return E
    }
    function I(E, O, P) {
      if (E && O && P && P.kind) {
        var $ = E,
          F,
          M
        for (M = P.path.length - 1, F = 0; F < M; F++)
          (typeof $[P.path[F]] > 'u' && ($[P.path[F]] = {}), ($ = $[P.path[F]]))
        switch (P.kind) {
          case 'A':
            T($[P.path[F]], P.index, P.item)
            break
          case 'D':
            $[P.path[F]] = P.lhs
            break
          case 'E':
            $[P.path[F]] = P.lhs
            break
          case 'N':
            delete $[P.path[F]]
            break
        }
      }
    }
    function B(E, O, P) {
      if (E && O) {
        var $ = function (F) {
          ;(!P || P(E, O, F)) && C(E, O, F)
        }
        g(E, O, $)
      }
    }
    return (
      Object.defineProperties(y, {
        diff: { value: y, enumerable: !0 },
        orderIndependentDiff: { value: b, enumerable: !0 },
        observableDiff: { value: g, enumerable: !0 },
        orderIndependentObservableDiff: { value: m, enumerable: !0 },
        orderIndepHash: { value: h, enumerable: !0 },
        applyDiff: { value: B, enumerable: !0 },
        applyChange: { value: C, enumerable: !0 },
        revertChange: { value: I, enumerable: !0 },
        isConflict: {
          value: function () {
            return typeof $conflict < 'u'
          },
          enumerable: !0,
        },
      }),
      (y.DeepDiff = y),
      t && (t.DeepDiff = y),
      y
    )
  })
})(H_)
var MJ = H_.exports
const U_ = {},
  { useDebugValue: yK } = ut,
  { useSyncExternalStoreWithSelector: bK } = iw
let P2 = !1
const vK = (e) => e
function wK(e, n = vK, t) {
  ;(U_ ? 'production' : void 0) !== 'production' &&
    t &&
    !P2 &&
    (console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937",
    ),
    (P2 = !0))
  const r = bK(e.subscribe, e.getState, e.getServerState || e.getInitialState, n, t)
  return (yK(r), r)
}
const N2 = (e) => {
    ;(U_ ? 'production' : void 0) !== 'production' &&
      typeof e != 'function' &&
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.",
      )
    const n = typeof e == 'function' ? m6(e) : e,
      t = (r, i) => wK(n, r, i)
    return (Object.assign(t, n), t)
  },
  xK = (e) => (e ? N2(e) : N2)
var I2, D2
const j2 =
  typeof window < 'u' &&
  (((I2 = window.document) != null && I2.createElement) ||
    ((D2 = window.navigator) == null ? void 0 : D2.product) === 'ReactNative')
    ? ut.useLayoutEffect
    : ut.useEffect
function EJ() {
  const e = xK((n) => ({ current: new Array(), version: 0, set: n }))
  return {
    In: ({ children: n }) => {
      const t = e((i) => i.set),
        r = e((i) => i.version)
      return (
        j2(() => {
          t((i) => ({ version: i.version + 1 }))
        }, []),
        j2(
          () => (
            t(({ current: i }) => ({ current: [...i, n] })),
            () => t(({ current: i }) => ({ current: i.filter((s) => s !== n) }))
          ),
          [n, r],
        ),
        null
      )
    },
    Out: () => {
      const n = e((t) => t.current)
      return ut.createElement(ut.Fragment, null, n)
    },
  }
}
export {
  gZ as $,
  bo as A,
  RK as B,
  hd as C,
  EK as D,
  Ao as E,
  e8 as F,
  r8 as G,
  jh as H,
  pr as I,
  Ga as J,
  Xr as K,
  NK as L,
  vn as M,
  tr as N,
  Oo as O,
  qZ as P,
  rC as Q,
  TK as R,
  DK as S,
  ya as T,
  IK as U,
  cZ as V,
  fZ as W,
  dZ as X,
  hZ as Y,
  mZ as Z,
  mE as _,
  sZ as a,
  jX as a$,
  bZ as a0,
  yZ as a1,
  pZ as a2,
  uZ as a3,
  Em as a4,
  L9 as a5,
  YZ as a6,
  ZZ as a7,
  Tm as a8,
  Yj as a9,
  BY as aA,
  rY as aB,
  pX as aC,
  JY as aD,
  uY as aE,
  CG as aF,
  bG as aG,
  QG as aH,
  WY as aI,
  lG as aJ,
  cX as aK,
  wG as aL,
  xG as aM,
  vG as aN,
  SG as aO,
  wZ as aP,
  vZ as aQ,
  dG as aR,
  AX as aS,
  qY as aT,
  xY as aU,
  IG as aV,
  gX as aW,
  qK as aX,
  xZ as aY,
  _Z as aZ,
  f8 as a_,
  JZ as aa,
  nJ as ab,
  tJ as ac,
  dL as ad,
  QZ as ae,
  iJ as af,
  aJ as ag,
  cJ as ah,
  lJ as ai,
  oJ as aj,
  sJ as ak,
  uJ as al,
  fJ as am,
  dJ as an,
  Lo as ao,
  rJ as ap,
  eJ as aq,
  vL as ar,
  nL as as,
  Sn as at,
  g6 as au,
  dn as av,
  dF as aw,
  LK as ax,
  rZ as ay,
  nZ as az,
  tu as b,
  UG as b$,
  qX as b0,
  $X as b1,
  CY as b2,
  NG as b3,
  kX as b4,
  KG as b5,
  DY as b6,
  kZ as b7,
  aX as b8,
  QX as b9,
  WG as bA,
  RG as bB,
  oG as bC,
  XG as bD,
  xX as bE,
  wX as bF,
  oX as bG,
  uG as bH,
  lY as bI,
  GX as bJ,
  ZY as bK,
  wY as bL,
  bY as bM,
  HY as bN,
  $K as bO,
  $G as bP,
  TZ as bQ,
  PX as bR,
  TG as bS,
  MX as bT,
  rG as bU,
  qG as bV,
  fY as bW,
  BX as bX,
  DX as bY,
  LX as bZ,
  AY as b_,
  BG as ba,
  JX as bb,
  OX as bc,
  DG as bd,
  mY as be,
  mG as bf,
  dY as bg,
  hX as bh,
  AG as bi,
  RX as bj,
  QY as bk,
  zG as bl,
  FY as bm,
  FX as bn,
  LY as bo,
  iY as bp,
  sY as bq,
  iG as br,
  aG as bs,
  SZ as bt,
  YY as bu,
  XY as bv,
  MG as bw,
  EZ as bx,
  CZ as by,
  NX as bz,
  oZ as c,
  BZ as c$,
  SY as c0,
  VK as c1,
  LG as c2,
  OY as c3,
  RY as c4,
  UY as c5,
  hY as c6,
  tG as c7,
  vY as c8,
  bX as c9,
  AZ as cA,
  NZ as cB,
  KK as cC,
  kG as cD,
  _G as cE,
  yX as cF,
  GY as cG,
  YX as cH,
  UZ as cI,
  YG as cJ,
  GZ as cK,
  PG as cL,
  $Y as cM,
  nX as cN,
  HK as cO,
  tX as cP,
  GK as cQ,
  EY as cR,
  mX as cS,
  XK as cT,
  MY as cU,
  yY as cV,
  jZ as cW,
  DZ as cX,
  Y3 as cY,
  FZ as cZ,
  WI as c_,
  HX as ca,
  JG as cb,
  VG as cc,
  OG as cd,
  pY as ce,
  rX as cf,
  vX as cg,
  fX as ch,
  KY as ci,
  IX as cj,
  sG as ck,
  EX as cl,
  fG as cm,
  GG as cn,
  _X as co,
  ZG as cp,
  WK as cq,
  UK as cr,
  YK as cs,
  VX as ct,
  gY as cu,
  TX as cv,
  IZ as cw,
  RZ as cx,
  PZ as cy,
  OZ as cz,
  iZ as d,
  Yt as d$,
  VZ as d0,
  $Z as d1,
  zZ as d2,
  Ps as d3,
  HZ as d4,
  V3 as d5,
  mD as d6,
  H3 as d7,
  jG as d8,
  uX as d9,
  SX as dA,
  hJ as dB,
  eG as dC,
  PY as dD,
  CX as dE,
  VY as dF,
  ig as dG,
  mJ as dH,
  gJ as dI,
  tz as dJ,
  js as dK,
  vJ as dL,
  vr as dM,
  bJ as dN,
  yJ as dO,
  X0 as dP,
  tZ as dQ,
  eZ as dR,
  JK as dS,
  xJ as dT,
  _J as dU,
  kJ as dV,
  SJ as dW,
  wJ as dX,
  eY as dY,
  zY as dZ,
  Tu as d_,
  zX as da,
  QK as db,
  ZK as dc,
  iX as dd,
  gG as de,
  LZ as df,
  Z3 as dg,
  yG as dh,
  XZ as di,
  ZX as dj,
  FG as dk,
  hG as dl,
  eX as dm,
  HG as dn,
  cY as dp,
  EG as dq,
  TY as dr,
  KX as ds,
  tY as dt,
  nY as du,
  IY as dv,
  NY as dw,
  kY as dx,
  nG as dy,
  cG as dz,
  aZ as e,
  E6 as e0,
  Dl as e1,
  pJ as e2,
  Mu as e3,
  _Y as e4,
  aY as e5,
  WX as e6,
  UX as e7,
  pG as e8,
  MJ as e9,
  lX as ea,
  sX as eb,
  dX as ec,
  pD as ed,
  EJ as ee,
  qD as ef,
  XX as eg,
  jY as eh,
  oY as ei,
  KZ as f,
  lZ as g,
  FK as h,
  WZ as i,
  CJ as j,
  OK as k,
  PK as l,
  BK as m,
  Gc as n,
  AK as o,
  xj as p,
  Ea as q,
  dr as r,
  kK as s,
  MK as t,
  Nm as u,
  e1 as v,
  zK as w,
  yo as x,
  k8 as y,
  CK as z,
}
//# sourceMappingURL=vendor-misc-BiJvMP0A.js.map
