{"version":3,"file":"person.types-Ck48Y8hE.js","sources":["../../src/hooks/usePersons.ts","../../src/types/person.types.ts"],"sourcesContent":["/**\n * Persons Hook\n * Feature: persons-entity-management\n *\n * Comprehensive TanStack Query hooks for person entity management:\n * - List persons with search/filters\n * - Get single person with full profile\n * - Create/update/archive persons\n * - Manage roles, affiliations, relationships\n * - Get relationship network for visualization\n */\n\nimport { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query'\nimport { useTranslation } from 'react-i18next'\nimport { toast } from 'sonner'\nimport { supabase } from '@/lib/supabase'\nimport type {\n  PersonDossier,\n  PersonFullProfile,\n  PersonCreate,\n  PersonUpdate,\n  PersonSearchParams,\n  PersonListResponse,\n  PersonListItem,\n  PersonRole,\n  PersonRoleCreate,\n  PersonAffiliation,\n  PersonAffiliationCreate,\n  PersonRelationship,\n  PersonRelationshipCreate,\n  PersonNetwork,\n} from '@/types/person.types'\n\n// API Base URL\nconst API_BASE_URL = import.meta.env.VITE_SUPABASE_URL + '/functions/v1'\n\n// ============================================================================\n// Query Keys\n// ============================================================================\n\nexport const personKeys = {\n  all: ['persons'] as const,\n  lists: () => [...personKeys.all, 'list'] as const,\n  list: (params?: PersonSearchParams) => [...personKeys.lists(), params] as const,\n  details: () => [...personKeys.all, 'detail'] as const,\n  detail: (id: string) => [...personKeys.details(), id] as const,\n  network: (id: string, depth?: number) => [...personKeys.all, 'network', id, depth] as const,\n  roles: (personId: string) => [...personKeys.all, 'roles', personId] as const,\n  affiliations: (personId: string) => [...personKeys.all, 'affiliations', personId] as const,\n  relationships: (personId: string) => [...personKeys.all, 'relationships', personId] as const,\n}\n\n// ============================================================================\n// Auth Helper\n// ============================================================================\n\nconst getAuthHeaders = async () => {\n  const { data: { session } } = await supabase.auth.getSession()\n  return {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${session?.access_token}`,\n  }\n}\n\n// ============================================================================\n// List Persons Hook\n// ============================================================================\n\n/**\n * Hook to list persons with search and filters\n */\nexport function usePersons(\n  params?: PersonSearchParams,\n  options?: Omit<UseQueryOptions<PersonListResponse, Error>, 'queryKey' | 'queryFn'>\n) {\n  return useQuery({\n    queryKey: personKeys.list(params),\n    queryFn: async (): Promise<PersonListResponse> => {\n      const headers = await getAuthHeaders()\n      const searchParams = new URLSearchParams()\n\n      if (params?.search) searchParams.set('search', params.search)\n      if (params?.organization_id) searchParams.set('organization_id', params.organization_id)\n      if (params?.nationality_id) searchParams.set('nationality_id', params.nationality_id)\n      if (params?.importance_level) searchParams.set('importance_level', String(params.importance_level))\n      if (params?.limit) searchParams.set('limit', String(params.limit))\n      if (params?.offset) searchParams.set('offset', String(params.offset))\n\n      const response = await fetch(`${API_BASE_URL}/persons?${searchParams}`, { headers })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to fetch persons')\n      }\n\n      return response.json()\n    },\n    staleTime: 30_000,\n    gcTime: 5 * 60_000,\n    ...options,\n  })\n}\n\n// ============================================================================\n// Get Person Hook\n// ============================================================================\n\n/**\n * Hook to get a single person with full profile\n */\nexport function usePerson(\n  id: string,\n  options?: Omit<UseQueryOptions<PersonFullProfile, Error>, 'queryKey' | 'queryFn'>\n) {\n  return useQuery({\n    queryKey: personKeys.detail(id),\n    queryFn: async (): Promise<PersonFullProfile> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${id}`, { headers })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to fetch person')\n      }\n\n      return response.json()\n    },\n    enabled: !!id,\n    staleTime: 60_000,\n    gcTime: 10 * 60_000,\n    ...options,\n  })\n}\n\n// ============================================================================\n// Person Network Hook\n// ============================================================================\n\n/**\n * Hook to get person's relationship network for visualization\n */\nexport function usePersonNetwork(\n  id: string,\n  depth: number = 1,\n  options?: Omit<UseQueryOptions<PersonNetwork, Error>, 'queryKey' | 'queryFn'>\n) {\n  return useQuery({\n    queryKey: personKeys.network(id, depth),\n    queryFn: async (): Promise<PersonNetwork> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${id}/network?depth=${depth}`, { headers })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to fetch network')\n      }\n\n      return response.json()\n    },\n    enabled: !!id,\n    staleTime: 60_000,\n    ...options,\n  })\n}\n\n// ============================================================================\n// Create Person Hook\n// ============================================================================\n\n/**\n * Hook to create a new person\n */\nexport function useCreatePerson() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async (data: PersonCreate): Promise<PersonDossier> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(data),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to create person')\n      }\n\n      return response.json()\n    },\n    onSuccess: (data) => {\n      queryClient.invalidateQueries({ queryKey: personKeys.lists() })\n      queryClient.setQueryData(personKeys.detail(data.id), data)\n      toast.success(t('messages.created', { name: data.name_en }))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.createError', { error: error.message }))\n    },\n  })\n}\n\n// ============================================================================\n// Update Person Hook\n// ============================================================================\n\n/**\n * Hook to update a person\n */\nexport function useUpdatePerson() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async ({ id, updates }: { id: string; updates: PersonUpdate }): Promise<PersonFullProfile> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${id}`, {\n        method: 'PATCH',\n        headers,\n        body: JSON.stringify(updates),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to update person')\n      }\n\n      return response.json()\n    },\n    onMutate: async ({ id, updates }) => {\n      await queryClient.cancelQueries({ queryKey: personKeys.detail(id) })\n      const previousPerson = queryClient.getQueryData<PersonFullProfile>(personKeys.detail(id))\n\n      if (previousPerson) {\n        queryClient.setQueryData<PersonFullProfile>(personKeys.detail(id), {\n          ...previousPerson,\n          person: { ...previousPerson.person, ...updates, updated_at: new Date().toISOString() },\n        })\n      }\n\n      return { previousPerson }\n    },\n    onSuccess: (data, { id }) => {\n      queryClient.setQueryData(personKeys.detail(id), data)\n      queryClient.invalidateQueries({ queryKey: personKeys.lists() })\n      toast.success(t('messages.updated'))\n    },\n    onError: (error: Error, { id }, context) => {\n      if (context?.previousPerson) {\n        queryClient.setQueryData(personKeys.detail(id), context.previousPerson)\n      }\n      toast.error(t('messages.updateError', { error: error.message }))\n    },\n  })\n}\n\n// ============================================================================\n// Archive Person Hook\n// ============================================================================\n\n/**\n * Hook to archive (soft delete) a person\n */\nexport function useArchivePerson() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async (id: string): Promise<{ success: boolean }> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${id}`, {\n        method: 'DELETE',\n        headers,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to archive person')\n      }\n\n      return response.json()\n    },\n    onSuccess: (_, id) => {\n      queryClient.removeQueries({ queryKey: personKeys.detail(id) })\n      queryClient.invalidateQueries({ queryKey: personKeys.lists() })\n      toast.success(t('messages.archived'))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.archiveError', { error: error.message }))\n    },\n  })\n}\n\n// ============================================================================\n// Person Roles Hooks\n// ============================================================================\n\n/**\n * Hook to add a role to a person\n */\nexport function useAddPersonRole() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async ({ personId, role }: { personId: string; role: PersonRoleCreate }): Promise<PersonRole> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${personId}/roles`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(role),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to add role')\n      }\n\n      return response.json()\n    },\n    onSuccess: (_, { personId }) => {\n      queryClient.invalidateQueries({ queryKey: personKeys.detail(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.roles(personId) })\n      toast.success(t('messages.roleAdded'))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.roleAddError', { error: error.message }))\n    },\n  })\n}\n\n/**\n * Hook to delete a role from a person\n */\nexport function useDeletePersonRole() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async ({ personId, roleId }: { personId: string; roleId: string }): Promise<{ success: boolean }> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${personId}/roles?role_id=${roleId}`, {\n        method: 'DELETE',\n        headers,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to delete role')\n      }\n\n      return response.json()\n    },\n    onSuccess: (_, { personId }) => {\n      queryClient.invalidateQueries({ queryKey: personKeys.detail(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.roles(personId) })\n      toast.success(t('messages.roleDeleted'))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.roleDeleteError', { error: error.message }))\n    },\n  })\n}\n\n// ============================================================================\n// Person Affiliations Hooks\n// ============================================================================\n\n/**\n * Hook to add an affiliation to a person\n */\nexport function useAddPersonAffiliation() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async ({ personId, affiliation }: { personId: string; affiliation: PersonAffiliationCreate }): Promise<PersonAffiliation> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${personId}/affiliations`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(affiliation),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to add affiliation')\n      }\n\n      return response.json()\n    },\n    onSuccess: (_, { personId }) => {\n      queryClient.invalidateQueries({ queryKey: personKeys.detail(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.affiliations(personId) })\n      toast.success(t('messages.affiliationAdded'))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.affiliationAddError', { error: error.message }))\n    },\n  })\n}\n\n/**\n * Hook to delete an affiliation from a person\n */\nexport function useDeletePersonAffiliation() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async ({ personId, affiliationId }: { personId: string; affiliationId: string }): Promise<{ success: boolean }> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${personId}/affiliations?affiliation_id=${affiliationId}`, {\n        method: 'DELETE',\n        headers,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to delete affiliation')\n      }\n\n      return response.json()\n    },\n    onSuccess: (_, { personId }) => {\n      queryClient.invalidateQueries({ queryKey: personKeys.detail(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.affiliations(personId) })\n      toast.success(t('messages.affiliationDeleted'))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.affiliationDeleteError', { error: error.message }))\n    },\n  })\n}\n\n// ============================================================================\n// Person Relationships Hooks\n// ============================================================================\n\n/**\n * Hook to add a relationship between persons\n */\nexport function useAddPersonRelationship() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async ({ personId, relationship }: { personId: string; relationship: PersonRelationshipCreate }): Promise<PersonRelationship> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${personId}/relationships`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(relationship),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to add relationship')\n      }\n\n      return response.json()\n    },\n    onSuccess: (_, { personId, relationship }) => {\n      queryClient.invalidateQueries({ queryKey: personKeys.detail(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.detail(relationship.to_person_id) })\n      queryClient.invalidateQueries({ queryKey: personKeys.relationships(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.network(personId) })\n      toast.success(t('messages.relationshipAdded'))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.relationshipAddError', { error: error.message }))\n    },\n  })\n}\n\n/**\n * Hook to delete a relationship\n */\nexport function useDeletePersonRelationship() {\n  const queryClient = useQueryClient()\n  const { t } = useTranslation('persons')\n\n  return useMutation({\n    mutationFn: async ({ personId, relationshipId }: { personId: string; relationshipId: string }): Promise<{ success: boolean }> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/persons/${personId}/relationships?relationship_id=${relationshipId}`, {\n        method: 'DELETE',\n        headers,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error?.message_en || 'Failed to delete relationship')\n      }\n\n      return response.json()\n    },\n    onSuccess: (_, { personId }) => {\n      queryClient.invalidateQueries({ queryKey: personKeys.detail(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.relationships(personId) })\n      queryClient.invalidateQueries({ queryKey: personKeys.network(personId) })\n      toast.success(t('messages.relationshipDeleted'))\n    },\n    onError: (error: Error) => {\n      toast.error(t('messages.relationshipDeleteError', { error: error.message }))\n    },\n  })\n}\n\n// ============================================================================\n// Cache Invalidation Helper\n// ============================================================================\n\n/**\n * Hook to invalidate all person queries\n */\nexport function useInvalidatePersons() {\n  const queryClient = useQueryClient()\n\n  return () => {\n    queryClient.invalidateQueries({ queryKey: personKeys.all })\n  }\n}\n","/**\n * Person Entity Types\n * Feature: persons-entity-management\n *\n * Comprehensive type definitions for person dossiers including:\n * - Person extension data\n * - Roles (career history)\n * - Affiliations (organization memberships)\n * - Relationships (person-to-person connections)\n * - Engagements (event participation)\n */\n\n// ============================================================================\n// Base Person Types\n// ============================================================================\n\n/**\n * Person extension data stored in the persons table\n */\nexport interface PersonExtension {\n  id: string\n  title_en?: string\n  title_ar?: string\n  organization_id?: string\n  nationality_country_id?: string\n  email?: string\n  phone?: string\n  biography_en?: string\n  biography_ar?: string\n  photo_url?: string\n  linkedin_url?: string\n  twitter_url?: string\n  expertise_areas: string[]\n  languages: string[]\n  notes?: string\n  importance_level: ImportanceLevel\n}\n\n/**\n * Importance levels for persons\n * 1 = Regular contact\n * 2 = Important\n * 3 = Key contact\n * 4 = VIP\n * 5 = Critical\n */\nexport type ImportanceLevel = 1 | 2 | 3 | 4 | 5\n\n/**\n * Full person dossier combining base dossier and extension\n */\nexport interface PersonDossier {\n  id: string\n  type: 'person'\n  name_en: string\n  name_ar: string\n  description_en?: string\n  description_ar?: string\n  status: 'active' | 'inactive' | 'archived'\n  sensitivity_level: number\n  tags: string[]\n  created_at: string\n  updated_at: string\n  created_by?: string\n  updated_by?: string\n  extension: PersonExtension\n}\n\n/**\n * Full person profile returned by get_person_full RPC\n */\nexport interface PersonFullProfile {\n  person: PersonDossier & PersonExtension\n  current_role?: PersonRole\n  roles: PersonRole[]\n  affiliations: PersonAffiliation[]\n  relationships: PersonRelationshipWithPerson[]\n  recent_engagements: PersonEngagementWithDetails[]\n}\n\n// ============================================================================\n// Person Roles (Career History)\n// ============================================================================\n\n/**\n * Person role representing a position held\n */\nexport interface PersonRole {\n  id: string\n  person_id: string\n  organization_id?: string\n  organization_name_en?: string\n  organization_name_ar?: string\n  role_title_en: string\n  role_title_ar?: string\n  department_en?: string\n  department_ar?: string\n  start_date?: string\n  end_date?: string\n  is_current: boolean\n  description_en?: string\n  description_ar?: string\n  created_at: string\n  updated_at: string\n  created_by?: string\n}\n\n/**\n * Input for creating a new role\n */\nexport interface PersonRoleCreate {\n  organization_id?: string\n  organization_name_en?: string\n  organization_name_ar?: string\n  role_title_en: string\n  role_title_ar?: string\n  department_en?: string\n  department_ar?: string\n  start_date?: string\n  end_date?: string\n  is_current?: boolean\n  description_en?: string\n  description_ar?: string\n}\n\n// ============================================================================\n// Person Affiliations\n// ============================================================================\n\n/**\n * Affiliation types for secondary organization memberships\n */\nexport type AffiliationType =\n  | 'member'\n  | 'board_member'\n  | 'advisor'\n  | 'consultant'\n  | 'representative'\n  | 'delegate'\n  | 'liaison'\n  | 'partner'\n  | 'volunteer'\n  | 'alumni'\n\n/**\n * Person affiliation with an organization\n */\nexport interface PersonAffiliation {\n  id: string\n  person_id: string\n  organization_id?: string\n  organization_name_en?: string\n  organization_name_ar?: string\n  affiliation_type: AffiliationType\n  position_title_en?: string\n  position_title_ar?: string\n  start_date?: string\n  end_date?: string\n  is_active: boolean\n  notes?: string\n  created_at: string\n  updated_at: string\n  created_by?: string\n}\n\n/**\n * Input for creating a new affiliation\n */\nexport interface PersonAffiliationCreate {\n  organization_id?: string\n  organization_name_en?: string\n  organization_name_ar?: string\n  affiliation_type: AffiliationType\n  position_title_en?: string\n  position_title_ar?: string\n  start_date?: string\n  end_date?: string\n  is_active?: boolean\n  notes?: string\n}\n\n// ============================================================================\n// Person Relationships\n// ============================================================================\n\n/**\n * Relationship types between persons\n */\nexport type RelationshipType =\n  | 'reports_to'\n  | 'supervises'\n  | 'colleague'\n  | 'collaborates_with'\n  | 'mentors'\n  | 'knows'\n  | 'former_colleague'\n  | 'referral'\n\n/**\n * Relationship strength\n * 1 = Weak, 2 = Casual, 3 = Normal, 4 = Strong, 5 = Very Strong\n */\nexport type RelationshipStrength = 1 | 2 | 3 | 4 | 5\n\n/**\n * Person relationship record\n */\nexport interface PersonRelationship {\n  id: string\n  from_person_id: string\n  to_person_id: string\n  relationship_type: RelationshipType\n  strength: RelationshipStrength\n  notes?: string\n  start_date?: string\n  end_date?: string\n  created_at: string\n  created_by?: string\n}\n\n/**\n * Person relationship with related person data\n */\nexport interface PersonRelationshipWithPerson {\n  relationship: PersonRelationship\n  related_person: {\n    id: string\n    name_en: string\n    name_ar: string\n    photo_url?: string\n    title_en?: string\n    organization_id?: string\n  }\n}\n\n/**\n * Input for creating a new relationship\n */\nexport interface PersonRelationshipCreate {\n  to_person_id: string\n  relationship_type: RelationshipType\n  strength?: RelationshipStrength\n  notes?: string\n  start_date?: string\n  end_date?: string\n}\n\n// ============================================================================\n// Person Engagements\n// ============================================================================\n\n/**\n * Role types for engagement participation\n */\nexport type EngagementRole =\n  | 'organizer'\n  | 'presenter'\n  | 'attendee'\n  | 'speaker'\n  | 'moderator'\n  | 'observer'\n  | 'delegate'\n  | 'advisor'\n  | 'guest'\n\n/**\n * Person engagement link record\n */\nexport interface PersonEngagement {\n  id: string\n  person_id: string\n  engagement_id: string\n  role: EngagementRole\n  notes?: string\n  attended: boolean\n  created_at: string\n  created_by?: string\n}\n\n/**\n * Person engagement with full engagement details\n */\nexport interface PersonEngagementWithDetails {\n  link: PersonEngagement\n  engagement: {\n    id: string\n    name_en: string\n    name_ar: string\n    engagement_type: string\n    engagement_category: string\n    location_en?: string\n    location_ar?: string\n  }\n}\n\n// ============================================================================\n// Network Graph Types\n// ============================================================================\n\n/**\n * Node in the person network graph\n */\nexport interface PersonNetworkNode {\n  id: string\n  name_en: string\n  name_ar: string\n  photo_url?: string\n  depth: number\n}\n\n/**\n * Edge in the person network graph\n */\nexport interface PersonNetworkEdge {\n  from: string\n  to: string\n  type: RelationshipType\n  strength: RelationshipStrength\n}\n\n/**\n * Person network graph data\n */\nexport interface PersonNetwork {\n  nodes: PersonNetworkNode[]\n  edges: PersonNetworkEdge[]\n}\n\n// ============================================================================\n// API Request/Response Types\n// ============================================================================\n\n/**\n * Input for creating a new person\n */\nexport interface PersonCreate {\n  name_en: string\n  name_ar: string\n  description_en?: string\n  description_ar?: string\n  title_en?: string\n  title_ar?: string\n  organization_id?: string\n  nationality_country_id?: string\n  email?: string\n  phone?: string\n  biography_en?: string\n  biography_ar?: string\n  photo_url?: string\n  linkedin_url?: string\n  twitter_url?: string\n  expertise_areas?: string[]\n  languages?: string[]\n  importance_level?: ImportanceLevel\n  sensitivity_level?: number\n  tags?: string[]\n}\n\n/**\n * Input for updating a person\n */\nexport interface PersonUpdate {\n  name_en?: string\n  name_ar?: string\n  description_en?: string\n  description_ar?: string\n  title_en?: string\n  title_ar?: string\n  organization_id?: string\n  nationality_country_id?: string\n  email?: string\n  phone?: string\n  biography_en?: string\n  biography_ar?: string\n  photo_url?: string\n  linkedin_url?: string\n  twitter_url?: string\n  expertise_areas?: string[]\n  languages?: string[]\n  importance_level?: ImportanceLevel\n  notes?: string\n  tags?: string[]\n  status?: 'active' | 'inactive' | 'archived'\n}\n\n/**\n * Search parameters for persons\n */\nexport interface PersonSearchParams {\n  search?: string\n  organization_id?: string\n  nationality_id?: string\n  importance_level?: ImportanceLevel\n  limit?: number\n  offset?: number\n}\n\n/**\n * Person list item (compact version for lists)\n */\nexport interface PersonListItem {\n  id: string\n  name_en: string\n  name_ar: string\n  title_en?: string\n  title_ar?: string\n  photo_url?: string\n  organization_id?: string\n  organization_name?: string\n  importance_level: ImportanceLevel\n  email?: string\n  phone?: string\n}\n\n/**\n * Person list response\n */\nexport interface PersonListResponse {\n  data: PersonListItem[]\n  pagination: {\n    total: number\n    limit: number\n    offset: number\n    has_more: boolean\n  }\n}\n\n// ============================================================================\n// Helper Types\n// ============================================================================\n\n/**\n * Labels for importance levels\n */\nexport const IMPORTANCE_LEVEL_LABELS: Record<ImportanceLevel, { en: string; ar: string }> = {\n  1: { en: 'Regular', ar: 'عادي' },\n  2: { en: 'Important', ar: 'مهم' },\n  3: { en: 'Key Contact', ar: 'جهة اتصال رئيسية' },\n  4: { en: 'VIP', ar: 'شخصية هامة' },\n  5: { en: 'Critical', ar: 'حرج' },\n}\n\n/**\n * Labels for relationship types\n */\nexport const RELATIONSHIP_TYPE_LABELS: Record<RelationshipType, { en: string; ar: string }> = {\n  reports_to: { en: 'Reports to', ar: 'يرفع تقاريره إلى' },\n  supervises: { en: 'Supervises', ar: 'يشرف على' },\n  colleague: { en: 'Colleague', ar: 'زميل' },\n  collaborates_with: { en: 'Collaborates with', ar: 'يتعاون مع' },\n  mentors: { en: 'Mentors', ar: 'يوجه' },\n  knows: { en: 'Knows', ar: 'يعرف' },\n  former_colleague: { en: 'Former colleague', ar: 'زميل سابق' },\n  referral: { en: 'Referral', ar: 'إحالة' },\n}\n\n/**\n * Labels for affiliation types\n */\nexport const AFFILIATION_TYPE_LABELS: Record<AffiliationType, { en: string; ar: string }> = {\n  member: { en: 'Member', ar: 'عضو' },\n  board_member: { en: 'Board Member', ar: 'عضو مجلس إدارة' },\n  advisor: { en: 'Advisor', ar: 'مستشار' },\n  consultant: { en: 'Consultant', ar: 'استشاري' },\n  representative: { en: 'Representative', ar: 'ممثل' },\n  delegate: { en: 'Delegate', ar: 'مندوب' },\n  liaison: { en: 'Liaison', ar: 'منسق' },\n  partner: { en: 'Partner', ar: 'شريك' },\n  volunteer: { en: 'Volunteer', ar: 'متطوع' },\n  alumni: { en: 'Alumni', ar: 'خريج' },\n}\n\n/**\n * Labels for engagement roles\n */\nexport const ENGAGEMENT_ROLE_LABELS: Record<EngagementRole, { en: string; ar: string }> = {\n  organizer: { en: 'Organizer', ar: 'منظم' },\n  presenter: { en: 'Presenter', ar: 'مقدم' },\n  attendee: { en: 'Attendee', ar: 'حاضر' },\n  speaker: { en: 'Speaker', ar: 'متحدث' },\n  moderator: { en: 'Moderator', ar: 'مدير جلسة' },\n  observer: { en: 'Observer', ar: 'مراقب' },\n  delegate: { en: 'Delegate', ar: 'مندوب' },\n  advisor: { en: 'Advisor', ar: 'مستشار' },\n  guest: { en: 'Guest', ar: 'ضيف' },\n}\n"],"names":["API_BASE_URL","personKeys","params","id","depth","personId","getAuthHeaders","session","supabase","usePersons","options","useQuery","headers","searchParams","response","error","usePerson","useCreatePerson","queryClient","useQueryClient","t","useTranslation","useMutation","data","toast","useArchivePerson","_","IMPORTANCE_LEVEL_LABELS","RELATIONSHIP_TYPE_LABELS","AFFILIATION_TYPE_LABELS"],"mappings":"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"}