{"version":3,"file":"useIntakeApi-84Q7PHHY.js","sources":["../../src/hooks/useIntakeApi.ts"],"sourcesContent":["/**\n * TanStack Query hooks for Intake API\n *\n * Provides React hooks for all intake-related API operations\n */\n\nimport { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'\nimport { supabase } from '../lib/supabase'\nimport {\n  IntakeFormData,\n  TicketResponse,\n  TicketDetailResponse,\n  TicketListResponse,\n  CreateTicketRequest,\n  UpdateTicketRequest,\n  ApplyTriageRequest,\n  AssignTicketRequest,\n  ConvertTicketRequest,\n  MergeTicketsRequest,\n  CloseTicketRequest,\n  TriageSuggestions,\n  DuplicateCandidate,\n  Attachment,\n} from '../types/intake'\n\n// API base URL\nconst API_BASE_URL = import.meta.env.VITE_SUPABASE_URL + '/functions/v1'\n\n// Query keys\nexport const intakeKeys = {\n  all: ['intake'] as const,\n  tickets: () => [...intakeKeys.all, 'tickets'] as const,\n  ticketList: (filters?: any) => [...intakeKeys.tickets(), 'list', filters] as const,\n  ticket: (id: string) => [...intakeKeys.tickets(), 'detail', id] as const,\n  triage: (id: string) => [...intakeKeys.tickets(), 'triage', id] as const,\n  duplicates: (id: string) => [...intakeKeys.tickets(), 'duplicates', id] as const,\n  attachments: (id: string) => [...intakeKeys.tickets(), 'attachments', id] as const,\n  health: () => [...intakeKeys.all, 'health'] as const,\n  aiHealth: () => [...intakeKeys.all, 'ai-health'] as const,\n}\n\n// Helper to get auth headers\nconst getAuthHeaders = async () => {\n  const {\n    data: { session },\n  } = await supabase.auth.getSession()\n\n  if (!session) {\n    throw new Error('No active session')\n  }\n\n  return {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${session.access_token}`,\n  }\n}\n\n/**\n * Create Ticket\n */\nexport const useCreateTicket = () => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: async (data: CreateTicketRequest): Promise<TicketResponse> => {\n      const headers = await getAuthHeaders()\n\n      // Transform camelCase to snake_case for API\n      const payload = {\n        request_type: data.requestType,\n        title: data.title,\n        title_ar: data.titleAr,\n        description: data.description,\n        description_ar: data.descriptionAr,\n        urgency: data.urgency,\n        dossier_id: data.dossierId,\n        type_specific_fields: data.typeSpecificFields,\n        attachments: data.attachments,\n      }\n\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-create`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(payload),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to create ticket')\n      }\n\n      return response.json()\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: intakeKeys.tickets() })\n    },\n  })\n}\n\n/**\n * List Tickets\n */\nexport const useTicketList = (filters?: {\n  status?: string\n  requestType?: string\n  sensitivity?: string\n  urgency?: string\n  assignedTo?: string\n  assignedUnit?: string\n  slaBreached?: boolean\n  createdAfter?: string\n  createdBefore?: string\n  page?: number\n  limit?: number\n}) => {\n  return useQuery({\n    queryKey: intakeKeys.ticketList(filters),\n    queryFn: async (): Promise<TicketListResponse> => {\n      const headers = await getAuthHeaders()\n      const params = new URLSearchParams()\n\n      if (filters) {\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined && value !== null) {\n            params.append(key, String(value))\n          }\n        })\n      }\n\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-list?${params.toString()}`, {\n        headers,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to fetch tickets')\n      }\n\n      return response.json()\n    },\n  })\n}\n\n/**\n * Get Ticket Detail\n */\nexport const useTicket = (ticketId: string) => {\n  return useQuery({\n    queryKey: intakeKeys.ticket(ticketId),\n    queryFn: async (): Promise<TicketDetailResponse> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-get?id=${ticketId}`, {\n        headers,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to fetch ticket')\n      }\n\n      return response.json()\n    },\n    enabled: !!ticketId,\n  })\n}\n\n/**\n * Update Ticket\n */\nexport const useUpdateTicket = (ticketId: string) => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: async (data: UpdateTicketRequest): Promise<TicketResponse> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-update`, {\n        method: 'PATCH',\n        headers,\n        body: JSON.stringify({ id: ticketId, ...data }),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to update ticket')\n      }\n\n      return response.json()\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: intakeKeys.ticket(ticketId) })\n      queryClient.invalidateQueries({ queryKey: intakeKeys.tickets() })\n    },\n  })\n}\n\n/**\n * Get Triage Suggestions\n */\nexport const useTriageSuggestions = (ticketId: string) => {\n  return useQuery({\n    queryKey: intakeKeys.triage(ticketId),\n    queryFn: async (): Promise<TriageSuggestions> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-triage/${ticketId}/triage`, {\n        method: 'GET',\n        headers,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to fetch triage suggestions')\n      }\n\n      return response.json()\n    },\n    enabled: !!ticketId,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  })\n}\n\n/**\n * Apply Triage\n */\nexport const useApplyTriage = (ticketId: string) => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: async (data: ApplyTriageRequest): Promise<TicketResponse> => {\n      const headers = await getAuthHeaders()\n\n      // Transform decision_type to action as expected by the Edge Function\n      const action = data.decision_type === 'ai_suggestion' ? 'accept' : 'override'\n\n      const requestBody = {\n        action,\n        sensitivity: data.suggested_sensitivity,\n        urgency: data.suggested_urgency,\n        assigned_to: data.suggested_assignee,\n        assigned_unit: data.suggested_unit,\n        override_reason: data.override_reason,\n        override_reason_ar: data.override_reason_ar,\n      }\n\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-triage/${ticketId}/triage`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(requestBody),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to apply triage')\n      }\n\n      return response.json()\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: intakeKeys.ticket(ticketId) })\n      queryClient.invalidateQueries({ queryKey: intakeKeys.triage(ticketId) })\n      queryClient.invalidateQueries({ queryKey: intakeKeys.tickets() })\n    },\n  })\n}\n\n/**\n * Assign Ticket\n */\nexport const useAssignTicket = (ticketId: string) => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: async (data: AssignTicketRequest): Promise<TicketResponse> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-assign`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({ id: ticketId, ...data }),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to assign ticket')\n      }\n\n      return response.json()\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: intakeKeys.ticket(ticketId) })\n      queryClient.invalidateQueries({ queryKey: intakeKeys.tickets() })\n    },\n  })\n}\n\n/**\n * Convert Ticket\n */\nexport const useConvertTicket = (ticketId: string) => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: async (\n      data: ConvertTicketRequest,\n    ): Promise<{ success: boolean; artifactId: string }> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-convert`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({ id: ticketId, ...data }),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to convert ticket')\n      }\n\n      return response.json()\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: intakeKeys.ticket(ticketId) })\n      queryClient.invalidateQueries({ queryKey: intakeKeys.tickets() })\n    },\n  })\n}\n\n/**\n * Get Duplicate Candidates\n */\nexport const useDuplicateCandidates = (ticketId: string, threshold = 0.65) => {\n  return useQuery({\n    queryKey: intakeKeys.duplicates(ticketId),\n    queryFn: async (): Promise<{ candidates: DuplicateCandidate[] }> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(\n        `${API_BASE_URL}/intake-tickets-duplicates?id=${ticketId}&threshold=${threshold}`,\n        { headers },\n      )\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to fetch duplicates')\n      }\n\n      return response.json()\n    },\n    enabled: !!ticketId,\n  })\n}\n\n/**\n * Merge Tickets\n */\nexport const useMergeTickets = (ticketId: string) => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: async (data: MergeTicketsRequest): Promise<TicketResponse> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-merge`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({ id: ticketId, ...data }),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to merge tickets')\n      }\n\n      return response.json()\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: intakeKeys.tickets() })\n    },\n  })\n}\n\n/**\n * Close Ticket\n */\nexport const useCloseTicket = (ticketId: string) => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: async (data: CloseTicketRequest): Promise<TicketResponse> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-close`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({ id: ticketId, ...data }),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to close ticket')\n      }\n\n      return response.json()\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: intakeKeys.ticket(ticketId) })\n      queryClient.invalidateQueries({ queryKey: intakeKeys.tickets() })\n    },\n  })\n}\n\n/**\n * Upload Attachment\n */\nexport const useUploadAttachment = () => {\n  return useMutation({\n    mutationFn: async (formData: FormData): Promise<Attachment> => {\n      const {\n        data: { session },\n      } = await supabase.auth.getSession()\n\n      if (!session) {\n        throw new Error('No active session')\n      }\n\n      const response = await fetch(`${API_BASE_URL}/intake-tickets-attachments`, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${session.access_token}`,\n        },\n        body: formData,\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to upload attachment')\n      }\n\n      return response.json()\n    },\n  })\n}\n\n/**\n * Delete Attachment\n */\nexport const useDeleteAttachment = () => {\n  return useMutation({\n    mutationFn: async (attachmentId: string): Promise<void> => {\n      const headers = await getAuthHeaders()\n      const response = await fetch(\n        `${API_BASE_URL}/intake-tickets-attachments?id=${attachmentId}`,\n        {\n          method: 'DELETE',\n          headers,\n        },\n      )\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || 'Failed to delete attachment')\n      }\n    },\n  })\n}\n\n/**\n * Get SLA Preview\n */\nexport const useGetSLAPreview = (urgency: string) => {\n  return useQuery({\n    queryKey: ['sla-preview', urgency],\n    queryFn: async (): Promise<{\n      acknowledgmentMinutes: number\n      resolutionHours: number\n      businessHoursOnly: boolean\n    }> => {\n      // This would typically come from an API endpoint\n      // For now, return default values based on urgency\n      const slaMap = {\n        critical: { acknowledgmentMinutes: 15, resolutionHours: 4, businessHoursOnly: false },\n        high: { acknowledgmentMinutes: 30, resolutionHours: 8, businessHoursOnly: true },\n        medium: { acknowledgmentMinutes: 60, resolutionHours: 24, businessHoursOnly: true },\n        low: { acknowledgmentMinutes: 120, resolutionHours: 72, businessHoursOnly: true },\n      }\n\n      return slaMap[urgency as keyof typeof slaMap] || slaMap.medium\n    },\n    enabled: !!urgency,\n  })\n}\n\n/**\n * Health Check\n */\nexport const useHealthCheck = () => {\n  return useQuery({\n    queryKey: intakeKeys.health(),\n    queryFn: async () => {\n      const response = await fetch(`${API_BASE_URL}/intake-health`)\n      if (!response.ok) {\n        throw new Error('Health check failed')\n      }\n      return response.json()\n    },\n    refetchInterval: 30000, // 30 seconds\n  })\n}\n\n/**\n * AI Health Check\n */\nexport const useAIHealthCheck = () => {\n  return useQuery({\n    queryKey: intakeKeys.aiHealth(),\n    queryFn: async () => {\n      // AI health check is public - no auth required\n      const response = await fetch(`${API_BASE_URL}/intake-ai-health`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      })\n\n      if (!response.ok) {\n        // Return a degraded status instead of throwing\n        return {\n          status: 'unhealthy',\n          services: {\n            embedding_model: false,\n            classification_model: false,\n            vector_store: false,\n          },\n          fallback_active: true,\n          last_success: null,\n          timestamp: new Date().toISOString(),\n        }\n      }\n      return response.json()\n    },\n    refetchInterval: 60000, // 60 seconds\n    retry: false, // Don't retry health checks\n  })\n}\n"],"names":["API_BASE_URL","intakeKeys","filters","id","getAuthHeaders","session","supabase","useCreateTicket","queryClient","useQueryClient","useMutation","data","headers","payload","response","error","useTicketList","useQuery","params","key","value","useTicket","ticketId","useUpdateTicket","useTriageSuggestions","useApplyTriage","requestBody","useConvertTicket","useDuplicateCandidates","threshold","useMergeTickets","useCloseTicket","useUploadAttachment","formData","useDeleteAttachment","attachmentId","useGetSLAPreview","urgency","slaMap"],"mappings":"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"}