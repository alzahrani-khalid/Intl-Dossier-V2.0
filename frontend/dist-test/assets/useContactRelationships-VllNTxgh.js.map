{"version":3,"file":"useContactRelationships-VllNTxgh.js","sources":["../../src/services/contact-relationship-api.ts","../../src/hooks/useContactRelationships.ts"],"sourcesContent":["/**\n * Contact Relationship API Client\n * Part of: 027-contact-directory Phase 6\n *\n * API client for contact relationship operations using Supabase Edge Functions.\n * Handles creating, fetching, and deleting relationships between contacts.\n */\n\nimport { supabase } from '@/lib/supabase';\nimport type { Database } from '../types/contact-directory.types';\n\n// Get Supabase URL for Edge Functions\nconst supabaseUrl = import.meta.env.VITE_SUPABASE_URL;\n\nif (!supabaseUrl) {\n  throw new Error('Missing VITE_SUPABASE_URL environment variable');\n}\n\n// Type definitions from database\ntype ContactRelationship = Database['public']['Tables']['cd_contact_relationships']['Row'];\ntype ContactRelationshipInsert = Database['public']['Tables']['cd_contact_relationships']['Insert'];\n\n/**\n * Relationship Type enum matching database values\n */\nexport type RelationshipType =\n  | 'reports_to'\n  | 'collaborates_with'\n  | 'partner'\n  | 'colleague'\n  | 'other';\n\n/**\n * Relationship Response with expanded contact information\n */\nexport interface RelationshipResponse extends ContactRelationship {\n  from_contact?: {\n    id: string;\n    full_name: string;\n    position?: string | null;\n    organization_id?: string | null;\n  };\n  to_contact?: {\n    id: string;\n    full_name: string;\n    position?: string | null;\n    organization_id?: string | null;\n  };\n}\n\n/**\n * Create Relationship Input\n */\nexport interface CreateRelationshipInput {\n  from_contact_id: string;\n  to_contact_id: string;\n  relationship_type: RelationshipType;\n  notes?: string;\n  start_date?: string;\n  end_date?: string;\n}\n\n/**\n * API Error\n */\nexport class RelationshipAPIError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'RelationshipAPIError';\n  }\n}\n\n/**\n * Get authorization headers with current user's JWT token\n */\nasync function getAuthHeaders(): Promise<HeadersInit> {\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new RelationshipAPIError('Not authenticated', 401);\n  }\n\n  return {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${session.access_token}`,\n  };\n}\n\n/**\n * Handle Edge Function responses\n */\nasync function handleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    let errorMessage = `Request failed with status ${response.status}`;\n    try {\n      const errorData = await response.json();\n      errorMessage = errorData.error || errorData.message || errorMessage;\n    } catch {\n      // Ignore JSON parse errors\n    }\n    throw new RelationshipAPIError(errorMessage, response.status);\n  }\n\n  try {\n    return await response.json();\n  } catch (error) {\n    throw new RelationshipAPIError('Failed to parse response', response.status, error);\n  }\n}\n\n/**\n * Create a new relationship between contacts\n */\nexport async function createRelationship(\n  input: CreateRelationshipInput\n): Promise<RelationshipResponse> {\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(`${supabaseUrl}/functions/v1/relationships-manage`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(input),\n  });\n\n  return handleResponse<RelationshipResponse>(response);\n}\n\n/**\n * Get all relationships for a specific contact\n * Returns both outgoing (from_contact_id) and incoming (to_contact_id) relationships\n */\nexport async function getRelationshipsForContact(\n  contactId: string\n): Promise<RelationshipResponse[]> {\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(\n    `${supabaseUrl}/functions/v1/relationships-manage?contact_id=${contactId}`,\n    {\n      method: 'GET',\n      headers,\n    }\n  );\n\n  const data = await handleResponse<{ relationships: RelationshipResponse[] }>(response);\n  return data.relationships;\n}\n\n/**\n * Delete a relationship\n */\nexport async function deleteRelationship(relationshipId: string): Promise<void> {\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(\n    `${supabaseUrl}/functions/v1/relationships-manage?relationship_id=${relationshipId}`,\n    {\n      method: 'DELETE',\n      headers,\n    }\n  );\n\n  await handleResponse<{ success: boolean }>(response);\n}\n\n/**\n * Get relationships for a contact (direct Supabase query - fallback method)\n * Used when Edge Function is unavailable\n */\nexport async function getRelationshipsForContactDirect(\n  contactId: string\n): Promise<RelationshipResponse[]> {\n  // Query relationships where contact is either from or to\n  const { data, error } = await supabase\n    .from('cd_contact_relationships')\n    .select(\n      `\n      *,\n      from_contact:cd_contacts!cd_contact_relationships_from_contact_id_fkey(id, full_name, position, organization_id),\n      to_contact:cd_contacts!cd_contact_relationships_to_contact_id_fkey(id, full_name, position, organization_id)\n    `\n    )\n    .or(`from_contact_id.eq.${contactId},to_contact_id.eq.${contactId}`);\n\n  if (error) {\n    throw new RelationshipAPIError(error.message, 500, error);\n  }\n\n  return data || [];\n}\n\n/**\n * Get relationship statistics for a contact\n * Returns count by relationship type\n */\nexport interface RelationshipStats {\n  total: number;\n  by_type: Record<RelationshipType, number>;\n}\n\nexport async function getRelationshipStats(contactId: string): Promise<RelationshipStats> {\n  const relationships = await getRelationshipsForContact(contactId);\n\n  const stats: RelationshipStats = {\n    total: relationships.length,\n    by_type: {\n      reports_to: 0,\n      collaborates_with: 0,\n      partner: 0,\n      colleague: 0,\n      other: 0,\n    },\n  };\n\n  relationships.forEach((rel) => {\n    stats.by_type[rel.relationship_type as RelationshipType]++;\n  });\n\n  return stats;\n}\n","/**\n * Contact Relationship Hooks\n * Part of: 027-contact-directory Phase 6\n *\n * TanStack Query hooks for contact relationship operations with automatic caching,\n * invalidation, and optimistic updates.\n */\n\nimport { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';\nimport {\n  createRelationship,\n  getRelationshipsForContact,\n  deleteRelationship,\n  getRelationshipStats,\n  type RelationshipResponse,\n  type CreateRelationshipInput,\n  type RelationshipStats,\n  RelationshipAPIError,\n} from '@/services/contact-relationship-api';\nimport { toast } from 'sonner';\nimport { useTranslation } from 'react-i18next';\n\n/**\n * Query Keys Factory\n */\nexport const relationshipKeys = {\n  all: ['contact-relationships'] as const,\n  lists: () => [...relationshipKeys.all, 'list'] as const,\n  list: (contactId: string) => [...relationshipKeys.lists(), contactId] as const,\n  stats: (contactId: string) => [...relationshipKeys.all, 'stats', contactId] as const,\n};\n\n/**\n * Hook to fetch relationships for a contact\n */\nexport function useRelationships(\n  contactId: string,\n  options?: Omit<UseQueryOptions<RelationshipResponse[], RelationshipAPIError>, 'queryKey' | 'queryFn'>\n) {\n  return useQuery({\n    queryKey: relationshipKeys.list(contactId),\n    queryFn: () => getRelationshipsForContact(contactId),\n    enabled: !!contactId,\n    ...options,\n  });\n}\n\n/**\n * Hook to get relationship statistics for a contact\n */\nexport function useRelationshipStats(\n  contactId: string,\n  options?: Omit<UseQueryOptions<RelationshipStats, RelationshipAPIError>, 'queryKey' | 'queryFn'>\n) {\n  return useQuery({\n    queryKey: relationshipKeys.stats(contactId),\n    queryFn: () => getRelationshipStats(contactId),\n    enabled: !!contactId,\n    ...options,\n  });\n}\n\n/**\n * Hook to create a new relationship\n */\nexport function useCreateRelationship() {\n  const queryClient = useQueryClient();\n  const { t } = useTranslation('contacts');\n\n  return useMutation({\n    mutationFn: (input: CreateRelationshipInput) => createRelationship(input),\n    onSuccess: (data) => {\n      // Invalidate relationship lists for both contacts\n      queryClient.invalidateQueries({ queryKey: relationshipKeys.list(data.from_contact_id) });\n      queryClient.invalidateQueries({ queryKey: relationshipKeys.list(data.to_contact_id) });\n\n      // Invalidate stats for both contacts\n      queryClient.invalidateQueries({ queryKey: relationshipKeys.stats(data.from_contact_id) });\n      queryClient.invalidateQueries({ queryKey: relationshipKeys.stats(data.to_contact_id) });\n\n      toast.success(t('contactDirectory.relationships.created_success'));\n    },\n    onError: (error: RelationshipAPIError) => {\n      toast.error(t('contactDirectory.relationships.created_error', { error: error.message }));\n    },\n  });\n}\n\n/**\n * Hook to delete a relationship\n */\nexport function useDeleteRelationship() {\n  const queryClient = useQueryClient();\n  const { t } = useTranslation('contacts');\n\n  return useMutation({\n    mutationFn: (relationshipId: string) => deleteRelationship(relationshipId),\n    onMutate: async (relationshipId) => {\n      // Find all relationship queries to update optimistically\n      const queryCache = queryClient.getQueryCache();\n      const queries = queryCache.findAll({ queryKey: relationshipKeys.lists() });\n\n      // Store previous values for rollback\n      const previousData: Record<string, RelationshipResponse[]> = {};\n\n      queries.forEach((query) => {\n        const data = query.state.data as RelationshipResponse[] | undefined;\n        if (data) {\n          previousData[query.queryKey.join('|')] = data;\n\n          // Optimistically remove the relationship\n          const updated = data.filter((rel) => rel.id !== relationshipId);\n          queryClient.setQueryData(query.queryKey, updated);\n        }\n      });\n\n      return { previousData };\n    },\n    onSuccess: () => {\n      // Invalidate all relationship queries to refetch\n      queryClient.invalidateQueries({ queryKey: relationshipKeys.all });\n\n      toast.success(t('contactDirectory.relationships.deleted_success'));\n    },\n    onError: (error: RelationshipAPIError, variables, context) => {\n      // Rollback optimistic updates\n      if (context?.previousData) {\n        Object.entries(context.previousData).forEach(([key, data]) => {\n          const queryKey = key.split('|');\n          queryClient.setQueryData(queryKey, data);\n        });\n      }\n\n      toast.error(t('contactDirectory.relationships.deleted_error', { error: error.message }));\n    },\n  });\n}\n\n/**\n * Hook to invalidate all relationship queries\n * Useful after bulk operations or external changes\n */\nexport function useInvalidateRelationships() {\n  const queryClient = useQueryClient();\n\n  return () => {\n    queryClient.invalidateQueries({ queryKey: relationshipKeys.all });\n  };\n}\n"],"names":["supabaseUrl","RelationshipAPIError","message","statusCode","details","getAuthHeaders","session","supabase","handleResponse","response","errorMessage","errorData","error","createRelationship","input","headers","getRelationshipsForContact","contactId","getRelationshipStats","relationships","stats","rel","relationshipKeys","useRelationships","options","useQuery","useRelationshipStats","useCreateRelationship","queryClient","useQueryClient","t","useTranslation","useMutation","data","toast"],"mappings":"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"}