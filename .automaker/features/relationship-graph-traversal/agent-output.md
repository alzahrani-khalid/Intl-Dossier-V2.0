ðŸ”§ Tool: Task
Input: {
"prompt": "Explore the codebase to understand the existing structure for relationship graph traversal. I need to find:\n\n1. Existing database schema for dossier relationships (tables like dossier_relationships, etc.)\n2. Existing Edge Functions related to relationships\n3. Frontend components or hooks that handle relationships\n4. Any existing graph traversal or network graph implementations\n\nFocus on:\n- supabase/migrations/ for relationship tables\n- supabase/functions/ for relationship-related functions\n- frontend/src/components/ for relationship components\n- frontend/src/hooks/ for relationship hooks\n- frontend/src/types/ for relationship types\n\nBe thorough - I need to understand the full relationship data model before implementing graph traversal.",
"description": "Explore relationship structure",
"subagent_type": "Explore"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "supabase/migrations/_relationship_"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "supabase/functions/_relationship_"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "frontend/src/types/_relationship_"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "frontend/src/hooks/_[Rr]elationship_"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "frontend/src/components/_[Rr]elationship_"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "supabase/migrations/_dossier_"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "supabase/functions/_dossier_"
}

ðŸ”§ Tool: Glob
Input: {
"pattern": "frontend/src/components/\*_/_[Dd]ossier\*"
}

ðŸ”§ Tool: Bash
Input: {
"command": "find /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/components -type d -name \"_[Dd]ossier_\" 2>/dev/null | head -20",
"description": "Find dossier component directories"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20251022000003_create_relationships.sql"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/types/relationship.types.ts"
}

ðŸ”§ Tool: Bash
Input: {
"command": "find /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0 -type f \\( -name \"_.tsx\" -o -name \"_.ts\" \\) | xargs grep -l \"graph\\|network\\|traverse\\|node.\*edge\" | grep -E \"(component|hook|type|service)\" | head -20",
"description": "Search for graph/network related files"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/components/dossiers/RelationshipGraph.tsx"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/hooks/useRelationships.ts"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/components/Dossier/sections/Relationships.tsx"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20251022000003_create_relationships.sql",
"offset": 26,
"limit": 100
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20251022000003_create_relationships.sql"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/services/relationship-api.ts"
}

ðŸ”§ Tool: Bash
Input: {
"command": "find /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions -name \"_graph_\" -o -name \"_traverse_\" 2>/dev/null | head -10",
"description": "Search for graph/traverse edge functions"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal"
}

ðŸ”§ Tool: Bash
Input: {
"command": "ls -la /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/ 2>/dev/null | grep -E \"(dossier|relationship)\" | head -20",
"description": "List dossier/relationship functions"
}

ðŸ”§ Tool: Bash
Input: {
"command": "find /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions -type f -name \"\*.ts\" | xargs grep -l \"relationship\\|traverse\\|graph\" 2>/dev/null | head -20",
"description": "Find files with relationship/graph code"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal/index.ts"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/dossier-relationships/index.ts"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/relationships-manage/index.ts"
}

ðŸ”§ Tool: Bash
Input: {
"command": "find /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations -type f -name \"\*.sql\" | xargs grep -l \"traverse\\|graph\\|recursive\" 2>/dev/null | head -10",
"description": "Find SQL migrations with graph/traverse functions"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/components/dossiers"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20251022000008_create_graph_functions.sql"
}

ðŸ”§ Tool: Bash
Input: {
"command": "ls -la /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/components/dossiers/ | grep -i custom",
"description": "List custom components in dossiers folder"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/components/dossiers/CustomNodes.tsx"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/components/dossiers/CustomEdges.tsx"
}

ðŸ”§ Tool: Bash
Input: {
"command": "grep -r \"useGraphData\\|traverse_relationship_graph\" /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src --include=\"_.ts\" --include=\"_.tsx\" 2>/dev/null | head -20",
"description": "Find useGraphData hook usage"
}

ðŸ”§ Tool: Bash
Input: {
"command": "find /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0 -name \"_.md\" -o -name \"README_\" | grep -E \"(relationship|graph|traverse)\" | head -10",
"description": "Find relationship/graph related documentation"
}

ðŸ”§ Tool: Bash
Input: {
"command": "ls -la /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/hooks/ | grep -i relation",
"description": "List relationship hooks"
}
Now I have a comprehensive understanding of the existing relationship infrastructure. Let me read the key files to understand the current implementation and identify what needs to be enhanced for graph traversal functions.

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20251022000008_create_graph_functions.sql"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal/index.ts"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/hooks/useRelationships.ts"
}
Now I have a clear understanding of the existing infrastructure. I can see that there are already some graph traversal functions, but the feature request is specifically for implementing **recursive graph traversal functions for finding connected entities, shortest paths, and relationship chains with multi-hop queries, depth limits, and relationship type filtering**.

Looking at what exists:

1. `traverse_relationship_graph` - Basic N-degree traversal (one-directional, sourceâ†’target only)
2. `get_bidirectional_relationships` - Single hop bidirectional relationships
3. `get_relationship_path` - Shortest path (but one-directional only)

What's missing:

1. **True bidirectional traversal** - Current traversal only follows sourceâ†’target
2. **Multiple relationship type filtering** - Current only supports single type filter
3. **Connected components discovery** - Find all entities in a connected subgraph
4. **Relationship chain analysis** - Analyze specific patterns of relationships
5. **Weighted shortest path** - Path finding with relationship weights

Let me create a comprehensive implementation plan:

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "pending",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "pending",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "pending",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "pending",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "pending",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "pending",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "pending",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "in_progress",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "pending",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "pending",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "pending",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "pending",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "pending",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "pending",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}
Let me check the existing migrations folder structure to determine the next migration number:

ðŸ”§ Tool: Bash
Input: {
"command": "ls -la /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/ | tail -20",
"description": "List recent migrations"
}
Now let me create the enhanced graph traversal SQL migration:

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20260111200001_enhanced_graph_traversal.sql",
"content": "-- Migration: Enhanced Graph Traversal Functions\n-- Description: Recursive graph traversal for finding connected entities, shortest paths, and relationship chains\n-- Feature: relationship-graph-traversal\n-- Supports: Multi-hop queries with depth limits and relationship type filtering\n\n-- ==================================================\n-- Function: traverse_relationship_graph_bidirectional\n-- ==================================================\n-- Purpose: Bidirectional N-degree graph traversal (follows both sourceâ†’target AND targetâ†’source)\n-- Returns: All entities within N degrees including the path taken and relationship types\n-- Performance: Optimized with cycle prevention and early termination\n\nCREATE OR REPLACE FUNCTION traverse_relationship_graph_bidirectional(\n start_dossier_id UUID,\n max_degrees INTEGER DEFAULT 2,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n degree INTEGER,\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE relationship_graph AS (\n    -- Base case: Direct outgoing relationships\n    SELECT\n      dr.target_dossier_id AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path\n    FROM dossier_relationships dr\n    WHERE dr.source_dossier_id = start_dossier_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Base case: Direct incoming relationships\n    SELECT\n      dr.source_dossier_id AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path\n    FROM dossier_relationships dr\n    WHERE dr.target_dossier_id = start_dossier_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Recursive case: Follow outgoing edges\n    SELECT\n      dr.target_dossier_id,\n      rg.current_degree + 1,\n      rg.current_path || dr.target_dossier_id,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || 'outgoing'::TEXT\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON dr.source_dossier_id = rg.current_id\n    WHERE rg.current_degree < max_degrees\n      AND NOT (dr.target_dossier_id = ANY(rg.current_path))\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Recursive case: Follow incoming edges\n    SELECT\n      dr.source_dossier_id,\n      rg.current_degree + 1,\n      rg.current_path || dr.source_dossier_id,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || 'incoming'::TEXT\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON dr.target_dossier_id = rg.current_id\n    WHERE rg.current_degree < max_degrees\n      AND NOT (dr.source_dossier_id = ANY(rg.current_path))\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    rg.current_degree AS degree,\n    rg.current_path AS path,\n    rg.rel_path AS relationship_path,\n    rg.dir_path AS direction_path\n  FROM relationship_graph rg\n  JOIN dossiers d ON d.id = rg.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY d.id, rg.current_degree;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION traverse_relationship_graph_bidirectional(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\nCOMMENT ON FUNCTION traverse_relationship_graph_bidirectional IS\n'Bidirectional recursive graph traversal. Finds all entities within N degrees of separation following both incoming and outgoing relationships. Supports multiple relationship type filtering and dossier type filtering.';\n\n\n-- ==================================================\n-- Function: find_shortest_path_bidirectional\n-- ==================================================\n-- Purpose: Find the shortest path between two entities using bidirectional BFS\n-- Returns: Shortest path with relationship types and directions\n-- Performance: Bidirectional BFS for O(b^(d/2)) vs O(b^d) complexity\n\nCREATE OR REPLACE FUNCTION find_shortest_path_bidirectional(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 6,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER,\n found BOOLEAN\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length,\n      TRUE AS found;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE path_search AS (\n    -- Base case: Outgoing from source\n    SELECT\n      ARRAY[source_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path,\n      1 AS depth,\n      dr.target_dossier_id AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE dr.source_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Base case: Incoming to source\n    SELECT\n      ARRAY[source_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path,\n      1 AS depth,\n      dr.source_dossier_id AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE dr.target_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive outgoing\n    SELECT\n      ps.current_path || dr.target_dossier_id,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || 'outgoing'::TEXT,\n      ps.depth + 1,\n      dr.target_dossier_id\n    FROM path_search ps\n    JOIN dossier_relationships dr ON dr.source_dossier_id = ps.current_node\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE ps.depth < max_depth\n      AND NOT (dr.target_dossier_id = ANY(ps.current_path))\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive incoming\n    SELECT\n      ps.current_path || dr.source_dossier_id,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || 'incoming'::TEXT,\n      ps.depth + 1,\n      dr.source_dossier_id\n    FROM path_search ps\n    JOIN dossier_relationships dr ON dr.target_dossier_id = ps.current_node\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE ps.depth < max_depth\n      AND NOT (dr.source_dossier_id = ANY(ps.current_path))\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ps.current_path AS path,\n    ps.rel_path AS relationship_path,\n    ps.dir_path AS direction_path,\n    ps.depth AS path_length,\n    TRUE AS found\n  FROM path_search ps\n  WHERE ps.current_node = target_id\n  ORDER BY ps.depth\n  LIMIT 1;\n\n  -- If no path found, return NULL with found=false\n  IF NOT FOUND THEN\n    RETURN QUERY SELECT\n      NULL::UUID[] AS path,\n      NULL::TEXT[] AS relationship_path,\n      NULL::TEXT[] AS direction_path,\n      NULL::INTEGER AS path_length,\n      FALSE AS found;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_shortest_path_bidirectional(UUID, UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION find_shortest_path_bidirectional IS\n'Finds the shortest path between two dossiers using bidirectional search. Supports relationship type filtering and returns the complete path with relationship types and directions.';\n\n\n-- ==================================================\n-- Function: find_all_paths\n-- ==================================================\n-- Purpose: Find all unique paths between two entities (up to a limit)\n-- Returns: All distinct paths sorted by length\n-- Use case: Understanding multiple connection routes between entities\n\nCREATE OR REPLACE FUNCTION find_all_paths(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 4,\n max_paths INTEGER DEFAULT 10,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length\n    LIMIT 1;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE all_paths AS (\n    -- Base case: Outgoing from source\n    SELECT\n      ARRAY[source_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE dr.source_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Base case: Incoming to source\n    SELECT\n      ARRAY[source_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE dr.target_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive outgoing\n    SELECT\n      ap.current_path || dr.target_dossier_id,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || 'outgoing'::TEXT,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE ap.depth < max_depth\n      AND NOT (dr.target_dossier_id = ANY(ap.current_path))\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive incoming\n    SELECT\n      ap.current_path || dr.source_dossier_id,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || 'incoming'::TEXT,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON dr.target_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE ap.depth < max_depth\n      AND NOT (dr.source_dossier_id = ANY(ap.current_path))\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ap.current_path AS path,\n    ap.rel_path AS relationship_path,\n    ap.dir_path AS direction_path,\n    ap.depth AS path_length\n  FROM all_paths ap\n  WHERE ap.current_path[array_length(ap.current_path, 1)] = target_id\n  ORDER BY ap.depth, ap.current_path\n  LIMIT max_paths;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_all_paths(UUID, UUID, INTEGER, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION find_all_paths IS\n'Finds all unique paths between two dossiers up to a specified depth and count limit. Useful for understanding multiple connection routes between entities.';\n\n\n-- ==================================================\n-- Function: find_connected_entities\n-- ==================================================\n-- Purpose: Find all entities connected to a starting point (connected component)\n-- Returns: All reachable entities regardless of relationship direction\n-- Use case: Network analysis, impact assessment\n\nCREATE OR REPLACE FUNCTION find_connected_entities(\n start_dossier_id UUID,\n max_entities INTEGER DEFAULT 100,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n min_distance INTEGER,\n connection_count INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE connected AS (\n    -- Starting node\n    SELECT\n      start_dossier_id AS current_id,\n      0 AS distance,\n      ARRAY[start_dossier_id] AS visited\n\n    UNION\n\n    -- Follow all edges bidirectionally\n    SELECT DISTINCT\n      CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_id,\n      c.distance + 1,\n      c.visited || CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END\n    FROM connected c\n    JOIN dossier_relationships dr ON\n      (dr.source_dossier_id = c.current_id OR dr.target_dossier_id = c.current_id)\n    WHERE\n      NOT (\n        CASE\n          WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(c.visited)\n      )\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  ),\n  -- Aggregate to get minimum distance and count connections\n  entity_stats AS (\n    SELECT\n      c.current_id,\n      MIN(c.distance) AS min_dist,\n      COUNT(*) FILTER (WHERE c.distance > 0) AS conn_count\n    FROM connected c\n    GROUP BY c.current_id\n  )\n  SELECT\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    es.min_dist AS min_distance,\n    COALESCE(es.conn_count::INTEGER, 0) AS connection_count\n  FROM entity_stats es\n  JOIN dossiers d ON d.id = es.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY es.min_dist, d.name_en\n  LIMIT max_entities;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_connected_entities(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\nCOMMENT ON FUNCTION find_connected_entities IS\n'Finds all entities in the connected component containing the starting dossier. Returns entities with their minimum distance and connection count. Useful for network analysis and impact assessment.';\n\n\n-- ==================================================\n-- Function: get_relationship_chain\n-- ==================================================\n-- Purpose: Find chains of specific relationship patterns\n-- Returns: Entities matching a specific chain of relationship types\n-- Use case: Finding patterns like \"Country â†’ member_of â†’ Organization â†’ participates_in â†’ Forum\"\n\nCREATE OR REPLACE FUNCTION get_relationship_chain(\n start_dossier_id UUID,\n relationship_chain TEXT[],\n bidirectional_chain BOOLEAN[] DEFAULT NULL\n)\nRETURNS TABLE (\n chain_position INTEGER,\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n relationship_type TEXT,\n direction TEXT,\n full_path UUID[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\n  chain_length INTEGER;\n  bidir_chain BOOLEAN[];\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  chain_length := array_length(relationship_chain, 1);\n\n  -- Default to all outgoing if bidirectional_chain not specified\n  IF bidirectional_chain IS NULL THEN\n    bidir_chain := ARRAY_FILL(FALSE, ARRAY[chain_length]);\n  ELSE\n    bidir_chain := bidirectional_chain;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE chain_search AS (\n    -- Position 0: Starting dossier\n    SELECT\n      0 AS pos,\n      start_dossier_id AS current_id,\n      NULL::TEXT AS rel_type,\n      'start'::TEXT AS dir,\n      ARRAY[start_dossier_id] AS path_arr\n\n    UNION ALL\n\n    -- Follow the chain pattern\n    SELECT\n      cs.pos + 1,\n      CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          CASE\n            WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n            ELSE dr.source_dossier_id\n          END\n        ELSE dr.target_dossier_id\n      END,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = cs.current_id THEN 'outgoing'\n        ELSE 'incoming'\n      END,\n      cs.path_arr || CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          CASE\n            WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n            ELSE dr.source_dossier_id\n          END\n        ELSE dr.target_dossier_id\n      END\n    FROM chain_search cs\n    JOIN dossier_relationships dr ON\n      CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          (dr.source_dossier_id = cs.current_id OR dr.target_dossier_id = cs.current_id)\n        ELSE\n          dr.source_dossier_id = cs.current_id\n      END\n    WHERE cs.pos < chain_length\n      AND dr.relationship_type = relationship_chain[cs.pos + 1]\n      AND dr.status = 'active'\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND NOT (\n        CASE\n          WHEN bidir_chain[cs.pos + 1] THEN\n            CASE\n              WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n              ELSE dr.source_dossier_id\n            END\n          ELSE dr.target_dossier_id\n        END = ANY(cs.path_arr)\n      )\n  )\n  SELECT\n    cs.pos AS chain_position,\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    cs.rel_type AS relationship_type,\n    cs.dir AS direction,\n    cs.path_arr AS full_path\n  FROM chain_search cs\n  JOIN dossiers d ON d.id = cs.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n  ORDER BY cs.path_arr, cs.pos;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_relationship_chain(UUID, TEXT[], BOOLEAN[]) TO authenticated;\n\nCOMMENT ON FUNCTION get_relationship_chain IS\n'Finds entities matching a specific chain of relationship types. Use for pattern matching like \"Country â†’ member_of â†’ Organization â†’ participates_in â†’ Forum\". Returns all entities along matching chains with their positions.';\n\n\n-- ==================================================\n-- Function: get_common_connections\n-- ==================================================\n-- Purpose: Find entities that connect two dossiers (mutual connections)\n-- Returns: Entities that have relationships with both source and target\n-- Use case: Finding bridge entities, common affiliations\n\nCREATE OR REPLACE FUNCTION get_common_connections(\n dossier_a_id UUID,\n dossier_b_id UUID,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n relationship_to_a TEXT,\n direction_to_a TEXT,\n relationship_to_b TEXT,\n direction_to_b TEXT\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH connections_a AS (\n    -- Get all connections to dossier A\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = dossier_a_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS connected_id,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = dossier_a_id THEN 'outgoing'\n        ELSE 'incoming'\n      END AS direction\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = dossier_a_id OR dr.target_dossier_id = dossier_a_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  ),\n  connections_b AS (\n    -- Get all connections to dossier B\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = dossier_b_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS connected_id,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = dossier_b_id THEN 'outgoing'\n        ELSE 'incoming'\n      END AS direction\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = dossier_b_id OR dr.target_dossier_id = dossier_b_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    ca.relationship_type AS relationship_to_a,\n    ca.direction AS direction_to_a,\n    cb.relationship_type AS relationship_to_b,\n    cb.direction AS direction_to_b\n  FROM connections_a ca\n  JOIN connections_b cb ON ca.connected_id = cb.connected_id\n  JOIN dossiers d ON d.id = ca.connected_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND d.id != dossier_a_id\n    AND d.id != dossier_b_id\n  ORDER BY d.id, d.name_en;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_common_connections(UUID, UUID, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION get_common_connections IS\n'Finds entities that have relationships with both specified dossiers. Useful for finding bridge entities, common affiliations, and mutual connections between two entities.';\n\n\n-- ==================================================\n-- Function: get_graph_statistics\n-- ==================================================\n-- Purpose: Calculate network statistics for a subgraph\n-- Returns: Node count, edge count, density, average degree, etc.\n-- Use case: Network analysis dashboard\n\nCREATE OR REPLACE FUNCTION get_graph_statistics(\n start_dossier_id UUID DEFAULT NULL,\n max_degrees INTEGER DEFAULT 3,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n total_nodes BIGINT,\n total_edges BIGINT,\n graph_density NUMERIC,\n avg_degree NUMERIC,\n max_degree BIGINT,\n isolated_nodes BIGINT,\n dossier_type_distribution JSONB\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  IF start_dossier_id IS NOT NULL THEN\n    -- Calculate stats for subgraph starting from a dossier\n    RETURN QUERY\n    WITH subgraph_nodes AS (\n      SELECT DISTINCT dossier_id\n      FROM traverse_relationship_graph_bidirectional(\n        start_dossier_id,\n        max_degrees,\n        relationship_types,\n        include_inactive,\n        NULL\n      )\n      UNION\n      SELECT start_dossier_id\n    ),\n    subgraph_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT dossier_id FROM subgraph_nodes)\n        AND dr.target_dossier_id IN (SELECT dossier_id FROM subgraph_nodes)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        sn.dossier_id,\n        COUNT(DISTINCT se.id) AS degree\n      FROM subgraph_nodes sn\n      LEFT JOIN subgraph_edges se ON\n        se.source_dossier_id = sn.dossier_id OR se.target_dossier_id = sn.dossier_id\n      GROUP BY sn.dossier_id\n    ),\n    type_counts AS (\n      SELECT\n        d.type,\n        COUNT(*) AS cnt\n      FROM subgraph_nodes sn\n      JOIN dossiers d ON d.id = sn.dossier_id\n      GROUP BY d.type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM subgraph_nodes)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM subgraph_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM subgraph_nodes) <= 1 THEN 0\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM subgraph_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM subgraph_nodes) * ((SELECT COUNT(*) FROM subgraph_nodes) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT MAX(degree) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      (SELECT jsonb_object_agg(type, cnt) FROM type_counts) AS dossier_type_distribution;\n  ELSE\n    -- Calculate stats for entire graph (visible to user)\n    RETURN QUERY\n    WITH visible_dossiers AS (\n      SELECT id, type\n      FROM dossiers\n      WHERE status != 'deleted'\n        AND sensitivity_level <= user_clearance\n    ),\n    visible_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND dr.target_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        vd.id,\n        COUNT(DISTINCT ve.id) AS degree\n      FROM visible_dossiers vd\n      LEFT JOIN visible_edges ve ON\n        ve.source_dossier_id = vd.id OR ve.target_dossier_id = vd.id\n      GROUP BY vd.id\n    ),\n    type_counts AS (\n      SELECT\n        type,\n        COUNT(*) AS cnt\n      FROM visible_dossiers\n      GROUP BY type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM visible_dossiers)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM visible_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM visible_dossiers) <= 1 THEN 0\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM visible_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM visible_dossiers) * ((SELECT COUNT(*) FROM visible_dossiers) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT MAX(degree) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      (SELECT jsonb_object_agg(type, cnt) FROM type_counts) AS dossier_type_distribution;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_graph_statistics(UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION get_graph_statistics IS\n'Calculates network statistics for the entire graph or a subgraph starting from a specific dossier. Returns metrics like density, average degree, and type distribution.';\n\n\n-- ==================================================\n-- Indexes for performance optimization\n-- ==================================================\n\n-- Composite index for bidirectional lookups\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_source_status_type\nON dossier_relationships(source_dossier_id, status, relationship_type);\n\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_target_status_type\nON dossier_relationships(target_dossier_id, status, relationship_type);\n\n-- Index for temporal queries\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_effective_dates\nON dossier_relationships(effective_from, effective_to)\nWHERE status = 'active';\n\n-- Partial index for active relationships (most common query pattern)\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_active_source\nON dossier_relationships(source_dossier_id)\nWHERE status = 'active' AND (effective_to IS NULL OR effective_to > now());\n\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_active_target\nON dossier_relationships(target_dossier_id)\nWHERE status = 'active' AND (effective_to IS NULL OR effective_to > now());\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "in_progress",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "pending",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "pending",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "pending",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "pending",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "pending",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}
Now let me create the Edge Function for advanced graph traversal operations:

ðŸ”§ Tool: Bash
Input: {
"command": "mkdir -p /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced",
"description": "Create Edge Function directory"
}

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts",
"content": "/\*_\n _ Advanced Graph Traversal Edge Function\n _ Feature: relationship-graph-traversal\n _\n _ Provides endpoints for:\n _ - Bidirectional N-degree traversal\n _ - Shortest path finding\n _ - All paths between entities\n _ - Connected entities discovery\n _ - Relationship chain pattern matching\n _ - Common connections between entities\n _ - Graph statistics\n _/\n\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\n\nconst corsHeaders = {\n 'Access-Control-Allow-Origin': '_',\n 'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n};\n\ninterface DossierReference {\n id: string;\n type: string;\n name_en: string;\n name_ar: string;\n status: string;\n}\n\ninterface GraphNode {\n id: string;\n type: string;\n name_en: string;\n name_ar: string;\n status: string;\n degree: number;\n path: string[];\n relationship_path?: string[];\n direction_path?: string[];\n}\n\ninterface GraphEdge {\n source_id: string;\n target_id: string;\n relationship_type: string;\n direction?: string;\n}\n\ninterface PathResult {\n path: string[];\n relationship_path: string[];\n direction_path: string[];\n path_length: number;\n found?: boolean;\n}\n\ninterface ChainResult {\n chain_position: number;\n dossier_id: string;\n dossier_type: string;\n name_en: string;\n name_ar: string;\n status: string;\n relationship_type: string | null;\n direction: string;\n full_path: string[];\n}\n\ninterface CommonConnectionResult {\n dossier_id: string;\n dossier_type: string;\n name_en: string;\n name_ar: string;\n status: string;\n relationship_to_a: string;\n direction_to_a: string;\n relationship_to_b: string;\n direction_to_b: string;\n}\n\ninterface GraphStats {\n total_nodes: number;\n total_edges: number;\n graph_density: number;\n avg_degree: number;\n max_degree: number;\n isolated_nodes: number;\n dossier_type_distribution: Record<string, number>;\n}\n\nfunction parseArrayParam(param: string | null): string[] | null {\n if (!param) return null;\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed : [param];\n } catch {\n return param.split(',').map((s) => s.trim());\n }\n}\n\nfunction parseBooleanArrayParam(param: string | null): boolean[] | null {\n if (!param) return null;\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed.map(Boolean) : null;\n } catch {\n return param.split(',').map((s) => s.trim().toLowerCase() === 'true');\n }\n}\n\nserve(async (req) => {\n // Handle CORS preflight\n if (req.method === 'OPTIONS') {\n return new Response(null, { headers: corsHeaders });\n }\n\n if (req.method !== 'GET' && req.method !== 'POST') {\n return new Response(JSON.stringify({ error: 'Method not allowed' }), {\n status: 405,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n try {\n const startTime = Date.now();\n\n // Get authorization header\n const authHeader = req.headers.get('Authorization');\n if (!authHeader) {\n return new Response(JSON.stringify({ error: 'Missing authorization header' }), {\n status: 401,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n // Create Supabase client\n const supabaseClient = createClient(\n Deno.env.get('SUPABASE_URL') ?? '',\n Deno.env.get('SUPABASE_ANON_KEY') ?? '',\n { global: { headers: { Authorization: authHeader } } }\n );\n\n // Parse URL and operation\n const url = new URL(req.url);\n const pathParts = url.pathname.split('/').filter(Boolean);\n const operation = pathParts[pathParts.length - 1] || 'traverse';\n\n // Get parameters from query string (GET) or body (POST)\n let params: Record<string, string | null> = {};\n\n if (req.method === 'GET') {\n url.searchParams.forEach((value, key) => {\n params[key] = value;\n });\n } else {\n const body = await req.json();\n params = body;\n }\n\n let result: unknown;\n\n switch (operation) {\n case 'traverse':\n case 'graph-traversal-advanced': {\n // Bidirectional N-degree traversal\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const maxDegrees = parseInt(params.maxDegrees || params.max_degrees || '2', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n const dossierTypeFilter = parseArrayParam(\n params.dossierTypeFilter || params.dossier_type_filter || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n if (maxDegrees < 1 || maxDegrees > 6) {\n return new Response(JSON.stringify({ error: 'maxDegrees must be between 1 and 6' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n // Verify starting dossier exists\n const { data: startDossier, error: dossierError } = await supabaseClient\n .from('dossiers')\n .select('id, type, name_en, name_ar, status')\n .eq('id', startDossierId)\n .single();\n\n if (dossierError || !startDossier) {\n return new Response(\n JSON.stringify({ error: 'Starting dossier not found or access denied' }),\n { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n // Call bidirectional traversal function\n const { data: graphData, error: graphError } = await supabaseClient.rpc(\n 'traverse_relationship_graph_bidirectional',\n {\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n dossier_type_filter: dossierTypeFilter,\n }\n );\n\n if (graphError) {\n console.error('Graph traversal error:', graphError);\n throw graphError;\n }\n\n // Transform to nodes and edges\n const nodesMap = new Map<string, GraphNode>();\n const edges: GraphEdge[] = [];\n\n // Add starting node\n nodesMap.set(startDossierId, {\n id: startDossierId,\n type: startDossier.type,\n name_en: startDossier.name_en,\n name_ar: startDossier.name_ar,\n status: startDossier.status,\n degree: 0,\n path: [startDossierId],\n });\n\n // Process graph results\n (graphData || []).forEach((row: any) => {\n if (!nodesMap.has(row.dossier_id)) {\n nodesMap.set(row.dossier_id, {\n id: row.dossier_id,\n type: row.dossier_type,\n name_en: row.name_en,\n name_ar: row.name_ar,\n status: row.status,\n degree: row.degree,\n path: row.path,\n relationship_path: row.relationship_path,\n direction_path: row.direction_path,\n });\n }\n\n // Build edges from path\n if (row.path && row.path.length > 1 && row.relationship_path) {\n for (let i = 0; i < row.path.length - 1; i++) {\n const sourceId = row.path[i];\n const targetId = row.path[i + 1];\n const relType = row.relationship_path[i];\n const direction = row.direction_path?.[i] || 'outgoing';\n\n const edgeKey = `${sourceId}-${targetId}-${relType}`;\n const reverseKey = `${targetId}-${sourceId}-${relType}`;\n\n const edgeExists = edges.some(\n (e) =>\n (`${e.source_id}-${e.target_id}-${e.relationship_type}` === edgeKey) ||\n (`${e.source_id}-${e.target_id}-${e.relationship_type}` === reverseKey)\n );\n\n if (!edgeExists) {\n edges.push({\n source_id: direction === 'outgoing' ? sourceId : targetId,\n target_id: direction === 'outgoing' ? targetId : sourceId,\n relationship_type: relType,\n direction,\n });\n }\n }\n }\n });\n\n const nodes = Array.from(nodesMap.values());\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'traverse_bidirectional',\n start_dossier_id: startDossierId,\n start_dossier: startDossier,\n max_degrees: maxDegrees,\n relationship_type_filter: relationshipTypes || 'all',\n dossier_type_filter: dossierTypeFilter || 'all',\n include_inactive: includeInactive,\n nodes,\n edges,\n stats: {\n node_count: nodes.length,\n edge_count: edges.length,\n max_degree_found: nodes.length > 0 ? Math.max(...nodes.map((n) => n.degree)) : 0,\n query_time_ms: queryTime,\n performance_warning: queryTime > 2000 ? 'Query exceeded 2s performance target' : null,\n },\n };\n break;\n }\n\n case 'shortest-path': {\n // Find shortest path between two entities\n const sourceId = params.sourceId || params.source_id;\n const targetId = params.targetId || params.target_id;\n const maxDepth = parseInt(params.maxDepth || params.max_depth || '6', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!sourceId || !targetId) {\n return new Response(\n JSON.stringify({ error: 'Missing sourceId or targetId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: pathData, error: pathError } = await supabaseClient.rpc(\n 'find_shortest_path_bidirectional',\n {\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (pathError) {\n console.error('Shortest path error:', pathError);\n throw pathError;\n }\n\n const pathResult = pathData?.[0] as PathResult | undefined;\n\n // Fetch dossier details for path nodes\n let pathDossiers: DossierReference[] = [];\n if (pathResult?.found && pathResult.path) {\n const { data: dossiers } = await supabaseClient\n .from('dossiers')\n .select('id, type, name_en, name_ar, status')\n .in('id', pathResult.path);\n pathDossiers = dossiers || [];\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'shortest_path',\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n found: pathResult?.found || false,\n path: pathResult?.path || null,\n relationship_path: pathResult?.relationship_path || null,\n direction_path: pathResult?.direction_path || null,\n path_length: pathResult?.path_length ?? null,\n path_dossiers: pathDossiers,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'all-paths': {\n // Find all paths between two entities\n const sourceId = params.sourceId || params.source_id;\n const targetId = params.targetId || params.target_id;\n const maxDepth = parseInt(params.maxDepth || params.max_depth || '4', 10);\n const maxPaths = parseInt(params.maxPaths || params.max_paths || '10', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!sourceId || !targetId) {\n return new Response(\n JSON.stringify({ error: 'Missing sourceId or targetId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: pathsData, error: pathsError } = await supabaseClient.rpc('find_all_paths', {\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n max_paths: maxPaths,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n });\n\n if (pathsError) {\n console.error('All paths error:', pathsError);\n throw pathsError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'all_paths',\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n max_paths: maxPaths,\n paths: pathsData || [],\n path_count: (pathsData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'connected-entities': {\n // Find all connected entities\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const maxEntities = parseInt(params.maxEntities || params.max_entities || '100', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n const dossierTypeFilter = parseArrayParam(\n params.dossierTypeFilter || params.dossier_type_filter || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n const { data: connectedData, error: connectedError } = await supabaseClient.rpc(\n 'find_connected_entities',\n {\n start_dossier_id: startDossierId,\n max_entities: maxEntities,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n dossier_type_filter: dossierTypeFilter,\n }\n );\n\n if (connectedError) {\n console.error('Connected entities error:', connectedError);\n throw connectedError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'connected_entities',\n start_dossier_id: startDossierId,\n max_entities: maxEntities,\n entities: connectedData || [],\n entity_count: (connectedData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'relationship-chain': {\n // Find entities matching a relationship chain pattern\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const relationshipChain = parseArrayParam(\n params.relationshipChain || params.relationship_chain || null\n );\n const bidirectionalChain = parseBooleanArrayParam(\n params.bidirectionalChain || params.bidirectional_chain || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n if (!relationshipChain || relationshipChain.length === 0) {\n return new Response(JSON.stringify({ error: 'Missing relationshipChain parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n const { data: chainData, error: chainError } = await supabaseClient.rpc(\n 'get_relationship_chain',\n {\n start_dossier_id: startDossierId,\n relationship_chain: relationshipChain,\n bidirectional_chain: bidirectionalChain,\n }\n );\n\n if (chainError) {\n console.error('Relationship chain error:', chainError);\n throw chainError;\n }\n\n // Group results by chain path\n const chainResults = chainData as ChainResult[];\n const pathsMap = new Map<string, ChainResult[]>();\n\n chainResults.forEach((item) => {\n const pathKey = item.full_path.join(',');\n if (!pathsMap.has(pathKey)) {\n pathsMap.set(pathKey, []);\n }\n pathsMap.get(pathKey)!.push(item);\n });\n\n const chains = Array.from(pathsMap.values()).map((items) => ({\n path: items[0].full_path,\n entities: items.sort((a, b) => a.chain_position - b.chain_position),\n }));\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'relationship_chain',\n start_dossier_id: startDossierId,\n relationship_chain: relationshipChain,\n bidirectional_chain: bidirectionalChain,\n chains,\n chain_count: chains.length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'common-connections': {\n // Find common connections between two entities\n const dossierAId = params.dossierAId || params.dossier_a_id;\n const dossierBId = params.dossierBId || params.dossier_b_id;\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!dossierAId || !dossierBId) {\n return new Response(\n JSON.stringify({ error: 'Missing dossierAId or dossierBId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: commonData, error: commonError } = await supabaseClient.rpc(\n 'get_common_connections',\n {\n dossier_a_id: dossierAId,\n dossier_b_id: dossierBId,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (commonError) {\n console.error('Common connections error:', commonError);\n throw commonError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'common_connections',\n dossier_a_id: dossierAId,\n dossier_b_id: dossierBId,\n common_connections: commonData || [],\n connection_count: (commonData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'statistics': {\n // Get graph statistics\n const startDossierId = params.startDossierId || params.start_dossier_id || null;\n const maxDegrees = parseInt(params.maxDegrees || params.max_degrees || '3', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n const { data: statsData, error: statsError } = await supabaseClient.rpc(\n 'get_graph_statistics',\n {\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (statsError) {\n console.error('Graph statistics error:', statsError);\n throw statsError;\n }\n\n const stats = statsData?.[0] as GraphStats | undefined;\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'statistics',\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n statistics: stats || null,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n default:\n return new Response(\n JSON.stringify({\n error: `Unknown operation: ${operation}`,\n available_operations: [\n 'traverse',\n 'shortest-path',\n 'all-paths',\n 'connected-entities',\n 'relationship-chain',\n 'common-connections',\n 'statistics',\n ],\n }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n return new Response(JSON.stringify(result), {\n status: 200,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n } catch (error) {\n console.error('Error in graph-traversal-advanced:', error);\n return new Response(\n JSON.stringify({\n error: error.message || 'Internal server error',\n }),\n { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n});\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "completed",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "in_progress",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "pending",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "pending",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "pending",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "pending",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}
Now let me create the TypeScript types for graph traversal:

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/types/graph-traversal.types.ts",
"content": "/**\n _ Graph Traversal Types\n _ Feature: relationship-graph-traversal\n _\n _ Types for recursive graph traversal functions including:\n _ - Bidirectional N-degree traversal\n _ - Shortest path finding\n _ - All paths between entities\n _ - Connected entities discovery\n _ - Relationship chain pattern matching\n _ - Common connections analysis\n _ - Graph statistics\n _/\n\nimport type { DossierRelationshipType, DossierType } from './relationship.types';\n\n// ============================================\n// Base Types\n// ============================================\n\n/**\n _ Direction of relationship traversal\n _/\nexport type RelationshipDirection = 'outgoing' | 'incoming';\n\n/**\n _ Basic dossier reference in graph operations\n _/\nexport interface DossierReference {\n id: string;\n type: DossierType;\n name_en: string;\n name_ar: string;\n status: string;\n}\n\n/**\n _ Node in the relationship graph\n _/\nexport interface GraphNode extends DossierReference {\n /** Degrees of separation from starting node \*/\n degree: number;\n /** Path of dossier IDs from start to this node _/\n path: string[];\n /\*\* Relationship types along the path _/\n relationship_path?: string[];\n /** Direction of each relationship in the path \*/\n direction_path?: RelationshipDirection[];\n /** Connection count (for connected entities) _/\n connection_count?: number;\n /\*\* Minimum distance from start (for connected entities) _/\n min_distance?: number;\n}\n\n/**\n _ Edge in the relationship graph\n _/\nexport interface GraphEdge {\n /** Source dossier ID _/\n source_id: string;\n /\*\* Target dossier ID _/\n target_id: string;\n /** Type of relationship \*/\n relationship_type: DossierRelationshipType;\n /** Direction of the relationship _/\n direction?: RelationshipDirection;\n}\n\n// ============================================\n// Request Types\n// ============================================\n\n/\*\*\n _ Parameters for bidirectional graph traversal\n _/\nexport interface TraverseBidirectionalParams {\n /\*\* Starting dossier UUID _/\n startDossierId: string;\n /** Maximum degrees of separation (1-6, default 2) \*/\n maxDegrees?: number;\n /** Filter by relationship types _/\n relationshipTypes?: DossierRelationshipType[];\n /\*\* Include inactive/historical relationships _/\n includeInactive?: boolean;\n /** Filter by dossier types \*/\n dossierTypeFilter?: DossierType[];\n}\n\n/**\n _ Parameters for shortest path finding\n _/\nexport interface ShortestPathParams {\n /** Source dossier UUID \*/\n sourceId: string;\n /** Target dossier UUID _/\n targetId: string;\n /\*\* Maximum search depth (default 6) _/\n maxDepth?: number;\n /** Filter by relationship types \*/\n relationshipTypes?: DossierRelationshipType[];\n /** Include inactive/historical relationships _/\n includeInactive?: boolean;\n}\n\n/\*\*\n _ Parameters for finding all paths\n _/\nexport interface AllPathsParams {\n /\*\* Source dossier UUID _/\n sourceId: string;\n /** Target dossier UUID \*/\n targetId: string;\n /** Maximum search depth (default 4) _/\n maxDepth?: number;\n /\*\* Maximum number of paths to return (default 10) _/\n maxPaths?: number;\n /** Filter by relationship types \*/\n relationshipTypes?: DossierRelationshipType[];\n /** Include inactive/historical relationships _/\n includeInactive?: boolean;\n}\n\n/\*\*\n _ Parameters for finding connected entities\n _/\nexport interface ConnectedEntitiesParams {\n /\*\* Starting dossier UUID _/\n startDossierId: string;\n /** Maximum entities to return (default 100) \*/\n maxEntities?: number;\n /** Filter by relationship types _/\n relationshipTypes?: DossierRelationshipType[];\n /\*\* Include inactive/historical relationships _/\n includeInactive?: boolean;\n /** Filter by dossier types \*/\n dossierTypeFilter?: DossierType[];\n}\n\n/**\n _ Parameters for relationship chain pattern matching\n _/\nexport interface RelationshipChainParams {\n /** Starting dossier UUID \*/\n startDossierId: string;\n /** Ordered array of relationship types to follow _/\n relationshipChain: DossierRelationshipType[];\n /\*\* Whether each relationship can be followed bidirectionally _/\n bidirectionalChain?: boolean[];\n}\n\n/**\n _ Parameters for finding common connections\n _/\nexport interface CommonConnectionsParams {\n /** First dossier UUID _/\n dossierAId: string;\n /\*\* Second dossier UUID _/\n dossierBId: string;\n /** Filter by relationship types \*/\n relationshipTypes?: DossierRelationshipType[];\n /** Include inactive/historical relationships _/\n includeInactive?: boolean;\n}\n\n/\*\*\n _ Parameters for graph statistics\n _/\nexport interface GraphStatisticsParams {\n /\*\* Starting dossier UUID (null for entire graph) _/\n startDossierId?: string | null;\n /** Maximum degrees for subgraph (default 3) \*/\n maxDegrees?: number;\n /** Filter by relationship types _/\n relationshipTypes?: DossierRelationshipType[];\n /\*\* Include inactive/historical relationships _/\n includeInactive?: boolean;\n}\n\n// ============================================\n// Response Types\n// ============================================\n\n/**\n _ Query statistics common to all operations\n _/\nexport interface QueryStats {\n /** Time taken to execute query in milliseconds _/\n query_time_ms: number;\n /\*\* Performance warning if query exceeded target _/\n performance_warning?: string | null;\n}\n\n/**\n _ Statistics for graph traversal operations\n _/\nexport interface TraversalStats extends QueryStats {\n /** Number of nodes in result _/\n node_count: number;\n /\*\* Number of edges in result _/\n edge_count: number;\n /** Maximum degree found in result \*/\n max_degree_found: number;\n}\n\n/**\n _ Response from bidirectional traversal\n _/\nexport interface TraverseBidirectionalResponse {\n operation: 'traverse_bidirectional';\n start_dossier_id: string;\n start_dossier: DossierReference;\n max_degrees: number;\n relationship_type_filter: DossierRelationshipType[] | 'all';\n dossier_type_filter: DossierType[] | 'all';\n include_inactive: boolean;\n nodes: GraphNode[];\n edges: GraphEdge[];\n stats: TraversalStats;\n}\n\n/**\n _ Path result from shortest path or all paths\n _/\nexport interface PathResult {\n /** Ordered array of dossier IDs in the path _/\n path: string[];\n /\*\* Relationship types between consecutive nodes _/\n relationship_path: string[];\n /** Direction of each relationship \*/\n direction_path: RelationshipDirection[];\n /** Number of hops in the path _/\n path_length: number;\n}\n\n/\*\*\n _ Response from shortest path finding\n _/\nexport interface ShortestPathResponse {\n operation: 'shortest_path';\n source_id: string;\n target_id: string;\n max_depth: number;\n /\*\* Whether a path was found _/\n found: boolean;\n /** Path if found, null otherwise \*/\n path: string[] | null;\n relationship_path: string[] | null;\n direction_path: RelationshipDirection[] | null;\n path_length: number | null;\n /** Dossier details for nodes in path _/\n path_dossiers: DossierReference[];\n stats: QueryStats;\n}\n\n/\*\*\n _ Response from all paths finding\n _/\nexport interface AllPathsResponse {\n operation: 'all_paths';\n source_id: string;\n target_id: string;\n max_depth: number;\n max_paths: number;\n paths: PathResult[];\n path_count: number;\n stats: QueryStats;\n}\n\n/\*\*\n _ Entity with connection information\n _/\nexport interface ConnectedEntity extends DossierReference {\n /\*\* Minimum distance from starting dossier _/\n min_distance: number;\n /** Number of connections \*/\n connection_count: number;\n}\n\n/**\n _ Response from connected entities discovery\n _/\nexport interface ConnectedEntitiesResponse {\n operation: 'connected_entities';\n start_dossier_id: string;\n max_entities: number;\n entities: ConnectedEntity[];\n entity_count: number;\n stats: QueryStats;\n}\n\n/**\n _ Entity in a relationship chain\n _/\nexport interface ChainEntity {\n /** Position in the chain (0 = start) _/\n chain_position: number;\n dossier_id: string;\n dossier_type: DossierType;\n name_en: string;\n name_ar: string;\n status: string;\n /\*\* Relationship type to next entity (null for last) _/\n relationship_type: DossierRelationshipType | null;\n /** Direction of relationship \*/\n direction: RelationshipDirection | 'start';\n /** Full path of dossier IDs _/\n full_path: string[];\n}\n\n/\*\*\n _ Complete chain result\n _/\nexport interface ChainResult {\n /\*\* Full path of dossier IDs _/\n path: string[];\n /** Entities in the chain with details \*/\n entities: ChainEntity[];\n}\n\n/**\n _ Response from relationship chain pattern matching\n _/\nexport interface RelationshipChainResponse {\n operation: 'relationship_chain';\n start_dossier_id: string;\n relationship_chain: DossierRelationshipType[];\n bidirectional_chain: boolean[] | null;\n chains: ChainResult[];\n chain_count: number;\n stats: QueryStats;\n}\n\n/**\n _ Common connection between two entities\n _/\nexport interface CommonConnection extends DossierReference {\n /** Relationship type to first dossier _/\n relationship_to_a: DossierRelationshipType;\n /\*\* Direction to first dossier _/\n direction_to_a: RelationshipDirection;\n /** Relationship type to second dossier \*/\n relationship_to_b: DossierRelationshipType;\n /** Direction to second dossier _/\n direction_to_b: RelationshipDirection;\n}\n\n/\*\*\n _ Response from common connections finding\n _/\nexport interface CommonConnectionsResponse {\n operation: 'common_connections';\n dossier_a_id: string;\n dossier_b_id: string;\n common_connections: CommonConnection[];\n connection_count: number;\n stats: QueryStats;\n}\n\n/\*\*\n _ Graph statistics\n _/\nexport interface GraphStatistics {\n /\*\* Total number of nodes _/\n total_nodes: number;\n /** Total number of edges \*/\n total_edges: number;\n /** Graph density (0-1) _/\n graph_density: number;\n /\*\* Average node degree _/\n avg_degree: number;\n /** Maximum node degree \*/\n max_degree: number;\n /** Number of isolated nodes (no connections) _/\n isolated_nodes: number;\n /\*\* Distribution of dossier types _/\n dossier_type_distribution: Record<DossierType, number>;\n}\n\n/**\n _ Response from graph statistics\n _/\nexport interface GraphStatisticsResponse {\n operation: 'statistics';\n start_dossier_id: string | null;\n max_degrees: number;\n statistics: GraphStatistics | null;\n stats: QueryStats;\n}\n\n// ============================================\n// Union Types\n// ============================================\n\n/**\n _ All possible graph traversal operations\n _/\nexport type GraphOperation =\n | 'traverse_bidirectional'\n | 'shortest_path'\n | 'all_paths'\n | 'connected_entities'\n | 'relationship_chain'\n | 'common_connections'\n | 'statistics';\n\n/**\n _ Union of all graph traversal responses\n _/\nexport type GraphTraversalResponse =\n | TraverseBidirectionalResponse\n | ShortestPathResponse\n | AllPathsResponse\n | ConnectedEntitiesResponse\n | RelationshipChainResponse\n | CommonConnectionsResponse\n | GraphStatisticsResponse;\n\n// ============================================\n// Error Types\n// ============================================\n\n/**\n _ Error from graph traversal API\n _/\nexport class GraphTraversalError extends Error {\n constructor(\n message: string,\n public statusCode: number = 500,\n public operation?: GraphOperation\n ) {\n super(message);\n this.name = 'GraphTraversalError';\n }\n}\n\n// ============================================\n// Helper Types\n// ============================================\n\n/**\n _ Options for visualization rendering\n _/\nexport interface GraphVisualizationOptions {\n /** Layout algorithm _/\n layout: 'force' | 'circular' | 'hierarchical' | 'radial';\n /\*\* Whether to show edge labels _/\n showEdgeLabels: boolean;\n /** Node size factor \*/\n nodeSizeFactor: number;\n /** Edge width factor _/\n edgeWidthFactor: number;\n /\*\* Whether to highlight shortest path _/\n highlightPath: boolean;\n /** Path to highlight (dossier IDs) \*/\n highlightedPath?: string[];\n}\n\n/**\n _ Type for graph operation state in UI\n _/\nexport interface GraphOperationState {\n /** Currently selected operation \*/\n operation: GraphOperation;\n /** Whether operation is loading _/\n isLoading: boolean;\n /\*\* Error if operation failed _/\n error: GraphTraversalError | null;\n /\*_ Last result _/\n result: GraphTraversalResponse | null;\n}\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "completed",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "completed",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "in_progress",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "pending",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "pending",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "pending",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}
Now let me create the frontend hooks for graph traversal:

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/hooks/useGraphTraversal.ts",
"content": "/**\n _ Graph Traversal Hooks\n _ Feature: relationship-graph-traversal\n _\n _ TanStack Query hooks for advanced graph traversal operations including:\n _ - Bidirectional N-degree traversal\n _ - Shortest path finding\n _ - All paths between entities\n _ - Connected entities discovery\n _ - Relationship chain pattern matching\n _ - Common connections analysis\n _ - Graph statistics\n _/\n\nimport { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';\nimport { useTranslation } from 'react-i18next';\nimport { toast } from 'sonner';\n\nimport type {\n TraverseBidirectionalParams,\n TraverseBidirectionalResponse,\n ShortestPathParams,\n ShortestPathResponse,\n AllPathsParams,\n AllPathsResponse,\n ConnectedEntitiesParams,\n ConnectedEntitiesResponse,\n RelationshipChainParams,\n RelationshipChainResponse,\n CommonConnectionsParams,\n CommonConnectionsResponse,\n GraphStatisticsParams,\n GraphStatisticsResponse,\n GraphTraversalError,\n} from '@/types/graph-traversal.types';\n\n// ============================================\n// API Client\n// ============================================\n\nconst EDGE_FUNCTION_URL = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/graph-traversal-advanced`;\n\nasync function fetchGraphAPI<T>(\n operation: string,\n params: Record<string, unknown>\n): Promise<T> {\n const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;\n\n if (!supabaseAnonKey) {\n throw new Error('Supabase configuration missing');\n }\n\n // Convert params to query string for GET requests\n const queryParams = new URLSearchParams();\n\n Object.entries(params).forEach(([key, value]) => {\n if (value !== undefined && value !== null) {\n if (Array.isArray(value)) {\n queryParams.set(key, JSON.stringify(value));\n } else {\n queryParams.set(key, String(value));\n }\n }\n });\n\n const url = `${EDGE_FUNCTION_URL}/${operation}?${queryParams.toString()}`;\n\n const response = await fetch(url, {\n method: 'GET',\n headers: {\n Authorization: `Bearer ${supabaseAnonKey}`,\n 'Content-Type': 'application/json',\n },\n });\n\n if (!response.ok) {\n const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));\n const error = new Error(errorData.error || 'Graph traversal failed') as GraphTraversalError;\n error.statusCode = response.status;\n throw error;\n }\n\n return response.json();\n}\n\n// ============================================\n// Query Keys\n// ============================================\n\nexport const graphTraversalKeys = {\n all: ['graph-traversal'] as const,\n\n traverse: (params: TraverseBidirectionalParams) =>\n [...graphTraversalKeys.all, 'traverse', params] as const,\n\n shortestPath: (params: ShortestPathParams) =>\n [...graphTraversalKeys.all, 'shortest-path', params] as const,\n\n allPaths: (params: AllPathsParams) =>\n [...graphTraversalKeys.all, 'all-paths', params] as const,\n\n connectedEntities: (params: ConnectedEntitiesParams) =>\n [...graphTraversalKeys.all, 'connected-entities', params] as const,\n\n relationshipChain: (params: RelationshipChainParams) =>\n [...graphTraversalKeys.all, 'relationship-chain', params] as const,\n\n commonConnections: (params: CommonConnectionsParams) =>\n [...graphTraversalKeys.all, 'common-connections', params] as const,\n\n statistics: (params: GraphStatisticsParams) =>\n [...graphTraversalKeys.all, 'statistics', params] as const,\n};\n\n// ============================================\n// Hooks\n// ============================================\n\n/**\n _ Hook for bidirectional N-degree graph traversal\n _\n _ @param params - Traversal parameters\n _ @param options - TanStack Query options\n _\n _ @example\n _ const { data, isLoading } = useGraphTraverse({\n _ startDossierId: 'uuid',\n _ maxDegrees: 3,\n _ relationshipTypes: ['member_of', 'cooperates_with'],\n _ });\n _/\nexport function useGraphTraverse(\n params: TraverseBidirectionalParams,\n options?: Omit<\n UseQueryOptions<TraverseBidirectionalResponse, GraphTraversalError>,\n 'queryKey' | 'queryFn'\n >\n) {\n const { t } = useTranslation('graph-traversal');\n\n return useQuery({\n queryKey: graphTraversalKeys.traverse(params),\n queryFn: () =>\n fetchGraphAPI<TraverseBidirectionalResponse>('traverse', {\n startDossierId: params.startDossierId,\n maxDegrees: params.maxDegrees,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n dossierTypeFilter: params.dossierTypeFilter,\n }),\n enabled: !!params.startDossierId,\n staleTime: 5 _ 60 _ 1000, // 5 minutes\n ...options,\n meta: {\n errorMessage: t('errors.traverseFailed', 'Failed to traverse graph'),\n ...options?.meta,\n },\n });\n}\n\n/**\n _ Hook for finding shortest path between two entities\n _\n _ @param params - Path finding parameters\n _ @param options - TanStack Query options\n _\n _ @example\n _ const { data } = useShortestPath({\n _ sourceId: 'uuid1',\n _ targetId: 'uuid2',\n _ maxDepth: 5,\n _ });\n _/\nexport function useShortestPath(\n params: ShortestPathParams,\n options?: Omit<\n UseQueryOptions<ShortestPathResponse, GraphTraversalError>,\n 'queryKey' | 'queryFn'\n >\n) {\n const { t } = useTranslation('graph-traversal');\n\n return useQuery({\n queryKey: graphTraversalKeys.shortestPath(params),\n queryFn: () =>\n fetchGraphAPI<ShortestPathResponse>('shortest-path', {\n sourceId: params.sourceId,\n targetId: params.targetId,\n maxDepth: params.maxDepth,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n }),\n enabled: !!params.sourceId && !!params.targetId,\n staleTime: 5 _ 60 _ 1000,\n ...options,\n meta: {\n errorMessage: t('errors.shortestPathFailed', 'Failed to find shortest path'),\n ...options?.meta,\n },\n });\n}\n\n/**\n _ Hook for finding all paths between two entities\n _\n _ @param params - All paths parameters\n _ @param options - TanStack Query options\n _\n _ @example\n _ const { data } = useAllPaths({\n _ sourceId: 'uuid1',\n _ targetId: 'uuid2',\n _ maxDepth: 4,\n _ maxPaths: 10,\n _ });\n _/\nexport function useAllPaths(\n params: AllPathsParams,\n options?: Omit<\n UseQueryOptions<AllPathsResponse, GraphTraversalError>,\n 'queryKey' | 'queryFn'\n >\n) {\n const { t } = useTranslation('graph-traversal');\n\n return useQuery({\n queryKey: graphTraversalKeys.allPaths(params),\n queryFn: () =>\n fetchGraphAPI<AllPathsResponse>('all-paths', {\n sourceId: params.sourceId,\n targetId: params.targetId,\n maxDepth: params.maxDepth,\n maxPaths: params.maxPaths,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n }),\n enabled: !!params.sourceId && !!params.targetId,\n staleTime: 5 _ 60 _ 1000,\n ...options,\n meta: {\n errorMessage: t('errors.allPathsFailed', 'Failed to find paths'),\n ...options?.meta,\n },\n });\n}\n\n/\*\*\n _ Hook for finding all connected entities\n _\n _ @param params - Connected entities parameters\n _ @param options - TanStack Query options\n _\n _ @example\n _ const { data } = useConnectedEntities({\n _ startDossierId: 'uuid',\n _ maxEntities: 100,\n _ dossierTypeFilter: ['country', 'organization'],\n _ });\n _/\nexport function useConnectedEntities(\n params: ConnectedEntitiesParams,\n options?: Omit<\n UseQueryOptions<ConnectedEntitiesResponse, GraphTraversalError>,\n 'queryKey' | 'queryFn'\n >\n) {\n const { t } = useTranslation('graph-traversal');\n\n return useQuery({\n queryKey: graphTraversalKeys.connectedEntities(params),\n queryFn: () =>\n fetchGraphAPI<ConnectedEntitiesResponse>('connected-entities', {\n startDossierId: params.startDossierId,\n maxEntities: params.maxEntities,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n dossierTypeFilter: params.dossierTypeFilter,\n }),\n enabled: !!params.startDossierId,\n staleTime: 5 _ 60 _ 1000,\n ...options,\n meta: {\n errorMessage: t('errors.connectedEntitiesFailed', 'Failed to find connected entities'),\n ...options?.meta,\n },\n });\n}\n\n/\*\*\n _ Hook for finding relationship chain patterns\n _\n _ @param params - Relationship chain parameters\n _ @param options - TanStack Query options\n _\n _ @example\n _ // Find: Country -> member_of -> Organization -> participates_in -> Forum\n _ const { data } = useRelationshipChain({\n _ startDossierId: 'country-uuid',\n _ relationshipChain: ['member_of', 'participates_in'],\n _ });\n _/\nexport function useRelationshipChain(\n params: RelationshipChainParams,\n options?: Omit<\n UseQueryOptions<RelationshipChainResponse, GraphTraversalError>,\n 'queryKey' | 'queryFn'\n >\n) {\n const { t } = useTranslation('graph-traversal');\n\n return useQuery({\n queryKey: graphTraversalKeys.relationshipChain(params),\n queryFn: () =>\n fetchGraphAPI<RelationshipChainResponse>('relationship-chain', {\n startDossierId: params.startDossierId,\n relationshipChain: params.relationshipChain,\n bidirectionalChain: params.bidirectionalChain,\n }),\n enabled: !!params.startDossierId && params.relationshipChain?.length > 0,\n staleTime: 5 _ 60 _ 1000,\n ...options,\n meta: {\n errorMessage: t('errors.relationshipChainFailed', 'Failed to find relationship chains'),\n ...options?.meta,\n },\n });\n}\n\n/\*\*\n _ Hook for finding common connections between two entities\n _\n _ @param params - Common connections parameters\n _ @param options - TanStack Query options\n _\n _ @example\n _ const { data } = useCommonConnections({\n _ dossierAId: 'uuid1',\n _ dossierBId: 'uuid2',\n _ });\n _/\nexport function useCommonConnections(\n params: CommonConnectionsParams,\n options?: Omit<\n UseQueryOptions<CommonConnectionsResponse, GraphTraversalError>,\n 'queryKey' | 'queryFn'\n >\n) {\n const { t } = useTranslation('graph-traversal');\n\n return useQuery({\n queryKey: graphTraversalKeys.commonConnections(params),\n queryFn: () =>\n fetchGraphAPI<CommonConnectionsResponse>('common-connections', {\n dossierAId: params.dossierAId,\n dossierBId: params.dossierBId,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n }),\n enabled: !!params.dossierAId && !!params.dossierBId,\n staleTime: 5 _ 60 _ 1000,\n ...options,\n meta: {\n errorMessage: t('errors.commonConnectionsFailed', 'Failed to find common connections'),\n ...options?.meta,\n },\n });\n}\n\n/**\n _ Hook for getting graph statistics\n _\n _ @param params - Statistics parameters (optional startDossierId for subgraph)\n _ @param options - TanStack Query options\n _\n _ @example\n _ // Full graph statistics\n _ const { data } = useGraphStatistics({});\n _\n _ // Subgraph statistics\n _ const { data } = useGraphStatistics({\n _ startDossierId: 'uuid',\n _ maxDegrees: 3,\n _ });\n _/\nexport function useGraphStatistics(\n params: GraphStatisticsParams = {},\n options?: Omit<\n UseQueryOptions<GraphStatisticsResponse, GraphTraversalError>,\n 'queryKey' | 'queryFn'\n >\n) {\n const { t } = useTranslation('graph-traversal');\n\n return useQuery({\n queryKey: graphTraversalKeys.statistics(params),\n queryFn: () =>\n fetchGraphAPI<GraphStatisticsResponse>('statistics', {\n startDossierId: params.startDossierId,\n maxDegrees: params.maxDegrees,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n }),\n staleTime: 10 _ 60 \* 1000, // 10 minutes for statistics\n ...options,\n meta: {\n errorMessage: t('errors.statisticsFailed', 'Failed to load graph statistics'),\n ...options?.meta,\n },\n });\n}\n\n// ============================================\n// Mutation Hooks (for operations that might be expensive)\n// ============================================\n\n/**\n _ Mutation hook for on-demand shortest path finding\n _ Use when you need to trigger path finding manually (e.g., button click)\n _/\nexport function useFindShortestPathMutation() {\n const { t } = useTranslation('graph-traversal');\n const queryClient = useQueryClient();\n\n return useMutation({\n mutationFn: (params: ShortestPathParams) =>\n fetchGraphAPI<ShortestPathResponse>('shortest-path', {\n sourceId: params.sourceId,\n targetId: params.targetId,\n maxDepth: params.maxDepth,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n }),\n onSuccess: (data, params) => {\n // Cache the result\n queryClient.setQueryData(graphTraversalKeys.shortestPath(params), data);\n\n if (data.found) {\n toast.success(\n t('success.pathFound', {\n length: data.path_length,\n defaultValue: 'Path found with {{length}} hops',\n })\n );\n } else {\n toast.info(t('info.noPathFound', 'No path found between entities'));\n }\n },\n onError: (error: Error) => {\n toast.error(error.message || t('errors.shortestPathFailed', 'Failed to find path'));\n },\n });\n}\n\n/\*\*\n _ Mutation hook for on-demand all paths finding\n _/\nexport function useFindAllPathsMutation() {\n const { t } = useTranslation('graph-traversal');\n const queryClient = useQueryClient();\n\n return useMutation({\n mutationFn: (params: AllPathsParams) =>\n fetchGraphAPI<AllPathsResponse>('all-paths', {\n sourceId: params.sourceId,\n targetId: params.targetId,\n maxDepth: params.maxDepth,\n maxPaths: params.maxPaths,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n }),\n onSuccess: (data, params) => {\n queryClient.setQueryData(graphTraversalKeys.allPaths(params), data);\n\n toast.success(\n t('success.pathsFound', {\n count: data.path_count,\n defaultValue: 'Found {{count}} path(s)',\n })\n );\n },\n onError: (error: Error) => {\n toast.error(error.message || t('errors.allPathsFailed', 'Failed to find paths'));\n },\n });\n}\n\n// ============================================\n// Prefetch Hooks\n// ============================================\n\n/\*\*\n _ Hook to prefetch graph data (useful for hover effects)\n _/\nexport function usePrefetchGraphTraverse() {\n const queryClient = useQueryClient();\n\n return (params: TraverseBidirectionalParams) => {\n if (!params.startDossierId) return;\n\n queryClient.prefetchQuery({\n queryKey: graphTraversalKeys.traverse(params),\n queryFn: () =>\n fetchGraphAPI<TraverseBidirectionalResponse>('traverse', {\n startDossierId: params.startDossierId,\n maxDegrees: params.maxDegrees || 2,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n dossierTypeFilter: params.dossierTypeFilter,\n }),\n staleTime: 5 _ 60 _ 1000,\n });\n };\n}\n\n/\*\*\n _ Hook to prefetch connected entities\n _/\nexport function usePrefetchConnectedEntities() {\n const queryClient = useQueryClient();\n\n return (params: ConnectedEntitiesParams) => {\n if (!params.startDossierId) return;\n\n queryClient.prefetchQuery({\n queryKey: graphTraversalKeys.connectedEntities(params),\n queryFn: () =>\n fetchGraphAPI<ConnectedEntitiesResponse>('connected-entities', {\n startDossierId: params.startDossierId,\n maxEntities: params.maxEntities || 50,\n relationshipTypes: params.relationshipTypes,\n includeInactive: params.includeInactive,\n dossierTypeFilter: params.dossierTypeFilter,\n }),\n staleTime: 5 _ 60 _ 1000,\n });\n };\n}\n\n// ============================================\n// Invalidation Hooks\n// ============================================\n\n/\*\*\n _ Hook to invalidate all graph traversal queries\n _ Useful after relationship mutations\n _/\nexport function useInvalidateGraphTraversal() {\n const queryClient = useQueryClient();\n\n return () => {\n queryClient.invalidateQueries({ queryKey: graphTraversalKeys.all });\n };\n}\n\n/\*_\n _ Hook to invalidate graph queries for a specific dossier\n \*/\nexport function useInvalidateGraphForDossier() {\n const queryClient = useQueryClient();\n\n return (dossierId: string) => {\n // Invalidate all queries that might involve this dossier\n queryClient.invalidateQueries({\n queryKey: graphTraversalKeys.all,\n predicate: (query) => {\n const key = query.queryKey;\n // Check if the dossierId appears anywhere in the query key\n return JSON.stringify(key).includes(dossierId);\n },\n });\n };\n}\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "completed",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "completed",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "completed",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "in_progress",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "pending",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "pending",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}
Now let me add the i18n translations:

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/i18n/en/graph-traversal.json",
"content": "{\n \"title\": \"Graph Traversal\",\n \"description\": \"Explore relationships between entities\",\n\n \"operations\": {\n \"traverse\": \"Explore Network\",\n \"shortestPath\": \"Find Shortest Path\",\n \"allPaths\": \"Find All Paths\",\n \"connectedEntities\": \"Connected Entities\",\n \"relationshipChain\": \"Relationship Chain\",\n \"commonConnections\": \"Common Connections\",\n \"statistics\": \"Graph Statistics\"\n },\n\n \"params\": {\n \"startDossier\": \"Starting Entity\",\n \"targetDossier\": \"Target Entity\",\n \"dossierA\": \"First Entity\",\n \"dossierB\": \"Second Entity\",\n \"maxDegrees\": \"Maximum Degrees\",\n \"maxDepth\": \"Maximum Depth\",\n \"maxPaths\": \"Maximum Paths\",\n \"maxEntities\": \"Maximum Entities\",\n \"relationshipTypes\": \"Relationship Types\",\n \"relationshipChain\": \"Relationship Chain\",\n \"includeInactive\": \"Include Inactive\",\n \"dossierTypeFilter\": \"Entity Types\",\n \"bidirectional\": \"Bidirectional\"\n },\n\n \"labels\": {\n \"degrees\": \"degrees of separation\",\n \"hops\": \"hops\",\n \"paths\": \"paths\",\n \"entities\": \"entities\",\n \"connections\": \"connections\",\n \"nodes\": \"nodes\",\n \"edges\": \"edges\",\n \"density\": \"density\",\n \"avgDegree\": \"average degree\",\n \"maxDegree\": \"maximum degree\",\n \"isolated\": \"isolated nodes\",\n \"queryTime\": \"query time\",\n \"ms\": \"ms\"\n },\n\n \"directions\": {\n \"outgoing\": \"Outgoing\",\n \"incoming\": \"Incoming\",\n \"bidirectional\": \"Bidirectional\"\n },\n\n \"results\": {\n \"pathFound\": \"Path found\",\n \"pathNotFound\": \"No path exists between these entities\",\n \"pathLength\": \"Path length: {{length}} hops\",\n \"pathsFound\": \"{{count}} path(s) found\",\n \"entitiesFound\": \"{{count}} connected entities found\",\n \"chainsFound\": \"{{count}} matching chain(s) found\",\n \"connectionsFound\": \"{{count}} common connection(s) found\",\n \"noResults\": \"No results found\",\n \"emptyGraph\": \"No relationships to display\"\n },\n\n \"actions\": {\n \"search\": \"Search\",\n \"explore\": \"Explore\",\n \"findPath\": \"Find Path\",\n \"findAllPaths\": \"Find All Paths\",\n \"findConnections\": \"Find Connections\",\n \"analyze\": \"Analyze\",\n \"reset\": \"Reset\",\n \"export\": \"Export\",\n \"viewDetails\": \"View Details\",\n \"highlightPath\": \"Highlight Path\",\n \"clearHighlight\": \"Clear Highlight\"\n },\n\n \"tooltips\": {\n \"maxDegrees\": \"Maximum number of relationship hops to explore (1-6)\",\n \"maxDepth\": \"Maximum path length to search for\",\n \"maxPaths\": \"Limit on number of paths to return\",\n \"maxEntities\": \"Limit on number of entities to return\",\n \"includeInactive\": \"Include historical and terminated relationships\",\n \"bidirectional\": \"Follow relationships in both directions\"\n },\n\n \"statistics\": {\n \"title\": \"Network Statistics\",\n \"totalNodes\": \"Total Nodes\",\n \"totalEdges\": \"Total Edges\",\n \"graphDensity\": \"Graph Density\",\n \"avgDegree\": \"Average Degree\",\n \"maxDegree\": \"Maximum Degree\",\n \"isolatedNodes\": \"Isolated Nodes\",\n \"typeDistribution\": \"Type Distribution\"\n },\n\n \"errors\": {\n \"traverseFailed\": \"Failed to traverse relationship graph\",\n \"shortestPathFailed\": \"Failed to find shortest path\",\n \"allPathsFailed\": \"Failed to find paths between entities\",\n \"connectedEntitiesFailed\": \"Failed to find connected entities\",\n \"relationshipChainFailed\": \"Failed to find relationship chains\",\n \"commonConnectionsFailed\": \"Failed to find common connections\",\n \"statisticsFailed\": \"Failed to load graph statistics\",\n \"invalidParams\": \"Invalid parameters provided\",\n \"maxDegreesExceeded\": \"Maximum degrees exceeded (limit: 6)\",\n \"unauthorized\": \"You don't have permission to view this data\"\n },\n\n \"success\": {\n \"pathFound\": \"Path found with {{length}} hops\",\n \"pathsFound\": \"Found {{count}} path(s)\"\n },\n\n \"info\": {\n \"noPathFound\": \"No path found between these entities\",\n \"searching\": \"Searching...\",\n \"loading\": \"Loading graph data...\"\n },\n\n \"visualization\": {\n \"zoomIn\": \"Zoom In\",\n \"zoomOut\": \"Zoom Out\",\n \"fitView\": \"Fit View\",\n \"layout\": {\n \"force\": \"Force Layout\",\n \"circular\": \"Circular Layout\",\n \"hierarchical\": \"Hierarchical Layout\",\n \"radial\": \"Radial Layout\"\n }\n }\n}\n"
}

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/i18n/ar/graph-traversal.json",
"content": "{\n \"title\": \"ØªØµÙØ­ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ\",\n \"description\": \"Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª\",\n\n \"operations\": {\n \"traverse\": \"Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ø´Ø¨ÙƒØ©\",\n \"shortestPath\": \"Ø¥ÙŠØ¬Ø§Ø¯ Ø£Ù‚ØµØ± Ù…Ø³Ø§Ø±\",\n \"allPaths\": \"Ø¥ÙŠØ¬Ø§Ø¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª\",\n \"connectedEntities\": \"Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªØµÙ„Ø©\",\n \"relationshipChain\": \"Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª\",\n \"commonConnections\": \"Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©\",\n \"statistics\": \"Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ\"\n },\n\n \"params\": {\n \"startDossier\": \"Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø¨Ø¯Ø¡\",\n \"targetDossier\": \"Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ù‡Ø¯Ù\",\n \"dossierA\": \"Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø£ÙˆÙ„\",\n \"dossierB\": \"Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø«Ø§Ù†ÙŠ\",\n \"maxDegrees\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¯Ø±Ø¬Ø§Øª\",\n \"maxDepth\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¹Ù…Ù‚\",\n \"maxPaths\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø³Ø§Ø±Ø§Øª\",\n \"maxEntities\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„ÙƒÙŠØ§Ù†Ø§Øª\",\n \"relationshipTypes\": \"Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª\",\n \"relationshipChain\": \"Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª\",\n \"includeInactive\": \"ØªØ¶Ù…ÙŠÙ† ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·Ø©\",\n \"dossierTypeFilter\": \"Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª\",\n \"bidirectional\": \"Ø«Ù†Ø§Ø¦ÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡\"\n },\n\n \"labels\": {\n \"degrees\": \"Ø¯Ø±Ø¬Ø§Øª Ø§Ù„ÙØµÙ„\",\n \"hops\": \"Ù‚ÙØ²Ø§Øª\",\n \"paths\": \"Ù…Ø³Ø§Ø±Ø§Øª\",\n \"entities\": \"ÙƒÙŠØ§Ù†Ø§Øª\",\n \"connections\": \"Ø§ØªØµØ§Ù„Ø§Øª\",\n \"nodes\": \"Ø¹ÙÙ‚Ø¯\",\n \"edges\": \"Ø±ÙˆØ§Ø¨Ø·\",\n \"density\": \"Ø§Ù„ÙƒØ«Ø§ÙØ©\",\n \"avgDegree\": \"Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø©\",\n \"maxDegree\": \"Ø£Ù‚ØµÙ‰ Ø¯Ø±Ø¬Ø©\",\n \"isolated\": \"Ø¹ÙÙ‚Ø¯ Ù…Ø¹Ø²ÙˆÙ„Ø©\",\n \"queryTime\": \"ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…\",\n \"ms\": \"Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©\"\n },\n\n \"directions\": {\n \"outgoing\": \"ØµØ§Ø¯Ø±\",\n \"incoming\": \"ÙˆØ§Ø±Ø¯\",\n \"bidirectional\": \"Ø«Ù†Ø§Ø¦ÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡\"\n },\n\n \"results\": {\n \"pathFound\": \"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø±\",\n \"pathNotFound\": \"Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³Ø§Ø± Ø¨ÙŠÙ† Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª\",\n \"pathLength\": \"Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø§Ø±: {{length}} Ù‚ÙØ²Ø©\",\n \"pathsFound\": \"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {{count}} Ù…Ø³Ø§Ø±\",\n \"entitiesFound\": \"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {{count}} ÙƒÙŠØ§Ù† Ù…ØªØµÙ„\",\n \"chainsFound\": \"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {{count}} Ø³Ù„Ø³Ù„Ø© Ù…Ø·Ø§Ø¨Ù‚Ø©\",\n \"connectionsFound\": \"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {{count}} Ø§ØªØµØ§Ù„ Ù…Ø´ØªØ±Ùƒ\",\n \"noResults\": \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬\",\n \"emptyGraph\": \"Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù„Ø§Ù‚Ø§Øª Ù„Ù„Ø¹Ø±Ø¶\"\n },\n\n \"actions\": {\n \"search\": \"Ø¨Ø­Ø«\",\n \"explore\": \"Ø§Ø³ØªÙƒØ´Ø§Ù\",\n \"findPath\": \"Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù…Ø³Ø§Ø±\",\n \"findAllPaths\": \"Ø¥ÙŠØ¬Ø§Ø¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª\",\n \"findConnections\": \"Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª\",\n \"analyze\": \"ØªØ­Ù„ÙŠÙ„\",\n \"reset\": \"Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†\",\n \"export\": \"ØªØµØ¯ÙŠØ±\",\n \"viewDetails\": \"Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„\",\n \"highlightPath\": \"ØªÙ…ÙŠÙŠØ² Ø§Ù„Ù…Ø³Ø§Ø±\",\n \"clearHighlight\": \"Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙ…ÙŠÙŠØ²\"\n },\n\n \"tooltips\": {\n \"maxDegrees\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ù‚ÙØ²Ø§Øª Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ù„Ù„Ø§Ø³ØªÙƒØ´Ø§Ù (1-6)\",\n \"maxDepth\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø§Ø± Ù„Ù„Ø¨Ø­Ø«\",\n \"maxPaths\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹\",\n \"maxEntities\": \"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹\",\n \"includeInactive\": \"ØªØ¶Ù…ÙŠÙ† Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ© ÙˆØ§Ù„Ù…Ù†ØªÙ‡ÙŠØ©\",\n \"bidirectional\": \"ØªØªØ¨Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ÙÙŠ ÙƒÙ„Ø§ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ÙŠÙ†\"\n },\n\n \"statistics\": {\n \"title\": \"Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø´Ø¨ÙƒØ©\",\n \"totalNodes\": \"Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¹ÙÙ‚Ø¯\",\n \"totalEdges\": \"Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·\",\n \"graphDensity\": \"ÙƒØ«Ø§ÙØ© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ\",\n \"avgDegree\": \"Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø©\",\n \"maxDegree\": \"Ø£Ù‚ØµÙ‰ Ø¯Ø±Ø¬Ø©\",\n \"isolatedNodes\": \"Ø§Ù„Ø¹ÙÙ‚Ø¯ Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©\",\n \"typeDistribution\": \"ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹\"\n },\n\n \"errors\": {\n \"traverseFailed\": \"ÙØ´Ù„ ÙÙŠ ØªØµÙØ­ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ Ù„Ù„Ø¹Ù„Ø§Ù‚Ø§Øª\",\n \"shortestPathFailed\": \"ÙØ´Ù„ ÙÙŠ Ø¥ÙŠØ¬Ø§Ø¯ Ø£Ù‚ØµØ± Ù…Ø³Ø§Ø±\",\n \"allPathsFailed\": \"ÙØ´Ù„ ÙÙŠ Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø¨ÙŠÙ† Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª\",\n \"connectedEntitiesFailed\": \"ÙØ´Ù„ ÙÙŠ Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªØµÙ„Ø©\",\n \"relationshipChainFailed\": \"ÙØ´Ù„ ÙÙŠ Ø¥ÙŠØ¬Ø§Ø¯ Ø³Ù„Ø§Ø³Ù„ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª\",\n \"commonConnectionsFailed\": \"ÙØ´Ù„ ÙÙŠ Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©\",\n \"statisticsFailed\": \"ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ\",\n \"invalidParams\": \"Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„Ù…Ù‚Ø¯Ù…Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©\",\n \"maxDegreesExceeded\": \"ØªÙ… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¯Ø±Ø¬Ø§Øª (Ø§Ù„Ø­Ø¯: 6)\",\n \"unauthorized\": \"Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\"\n },\n\n \"success\": {\n \"pathFound\": \"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø± Ø¨Ù€ {{length}} Ù‚ÙØ²Ø©\",\n \"pathsFound\": \"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {{count}} Ù…Ø³Ø§Ø±\"\n },\n\n \"info\": {\n \"noPathFound\": \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø± Ø¨ÙŠÙ† Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª\",\n \"searching\": \"Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...\",\n \"loading\": \"Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ...\"\n },\n\n \"visualization\": {\n \"zoomIn\": \"ØªÙƒØ¨ÙŠØ±\",\n \"zoomOut\": \"ØªØµØºÙŠØ±\",\n \"fitView\": \"Ù…Ù„Ø§Ø¡Ù…Ø© Ø§Ù„Ø¹Ø±Ø¶\",\n \"layout\": {\n \"force\": \"ØªØ®Ø·ÙŠØ· Ø§Ù„Ù‚ÙˆØ©\",\n \"circular\": \"ØªØ®Ø·ÙŠØ· Ø¯Ø§Ø¦Ø±ÙŠ\",\n \"hierarchical\": \"ØªØ®Ø·ÙŠØ· Ù‡Ø±Ù…ÙŠ\",\n \"radial\": \"ØªØ®Ø·ÙŠØ· Ø´Ø¹Ø§Ø¹ÙŠ\"\n }\n }\n}\n"
}
Now I need to update the i18n index file to include the new namespace:

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/i18n/index.ts"
}

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/i18n/index.ts",
"old_string": "import enNotificationCenter from './en/notification-center.json'\nimport arNotificationCenter from './ar/notification-center.json'\n// Force reload - updated 2026-01-11 - v27 - Added notification-center namespace",
"new_string": "import enNotificationCenter from './en/notification-center.json'\nimport arNotificationCenter from './ar/notification-center.json'\nimport enGraphTraversal from './en/graph-traversal.json'\nimport arGraphTraversal from './ar/graph-traversal.json'\n// Force reload - updated 2026-01-11 - v28 - Added graph-traversal namespace"
}

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/i18n/index.ts",
"old_string": "'notification-center': enNotificationCenter,\n },\n ar: {",
"new_string": "'notification-center': enNotificationCenter,\n 'graph-traversal': enGraphTraversal,\n },\n ar: {"
}

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/src/i18n/index.ts",
"old_string": "'notification-center': arNotificationCenter,\n },\n}",
"new_string": "'notification-center': arNotificationCenter,\n 'graph-traversal': arGraphTraversal,\n },\n}"
}

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "completed",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "completed",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "completed",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "completed",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "in_progress",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "pending",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}
Now let me deploy the migration to Supabase:

ðŸ”§ Tool: mcp**supabase**list_projects
Input: {}
The project ID is `zkrcjzdemdmwhearhfgg` (Intl-Dossier). Let me read the migration file and apply it:

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20260111200001_enhanced_graph_traversal.sql"
}
Now let me apply the migration to Supabase:

ðŸ”§ Tool: mcp**supabase**apply_migration
Input: {
"project_id": "zkrcjzdemdmwhearhfgg",
"name": "enhanced_graph_traversal",
"query": "-- Migration: Enhanced Graph Traversal Functions\n-- Description: Recursive graph traversal for finding connected entities, shortest paths, and relationship chains\n-- Feature: relationship-graph-traversal\n-- Supports: Multi-hop queries with depth limits and relationship type filtering\n\n-- ==================================================\n-- Function: traverse_relationship_graph_bidirectional\n-- ==================================================\n-- Purpose: Bidirectional N-degree graph traversal (follows both sourceâ†’target AND targetâ†’source)\n-- Returns: All entities within N degrees including the path taken and relationship types\n-- Performance: Optimized with cycle prevention and early termination\n\nCREATE OR REPLACE FUNCTION traverse_relationship_graph_bidirectional(\n start_dossier_id UUID,\n max_degrees INTEGER DEFAULT 2,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n degree INTEGER,\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE relationship_graph AS (\n    -- Base case: Direct outgoing relationships\n    SELECT\n      dr.target_dossier_id AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path\n    FROM dossier_relationships dr\n    WHERE dr.source_dossier_id = start_dossier_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Base case: Direct incoming relationships\n    SELECT\n      dr.source_dossier_id AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path\n    FROM dossier_relationships dr\n    WHERE dr.target_dossier_id = start_dossier_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Recursive case: Follow outgoing edges\n    SELECT\n      dr.target_dossier_id,\n      rg.current_degree + 1,\n      rg.current_path || dr.target_dossier_id,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || 'outgoing'::TEXT\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON dr.source_dossier_id = rg.current_id\n    WHERE rg.current_degree < max_degrees\n      AND NOT (dr.target_dossier_id = ANY(rg.current_path))\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Recursive case: Follow incoming edges\n    SELECT\n      dr.source_dossier_id,\n      rg.current_degree + 1,\n      rg.current_path || dr.source_dossier_id,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || 'incoming'::TEXT\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON dr.target_dossier_id = rg.current_id\n    WHERE rg.current_degree < max_degrees\n      AND NOT (dr.source_dossier_id = ANY(rg.current_path))\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    rg.current_degree AS degree,\n    rg.current_path AS path,\n    rg.rel_path AS relationship_path,\n    rg.dir_path AS direction_path\n  FROM relationship_graph rg\n  JOIN dossiers d ON d.id = rg.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY d.id, rg.current_degree;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION traverse_relationship_graph_bidirectional(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\nCOMMENT ON FUNCTION traverse_relationship_graph_bidirectional IS\n'Bidirectional recursive graph traversal. Finds all entities within N degrees of separation following both incoming and outgoing relationships. Supports multiple relationship type filtering and dossier type filtering.';\n\n\n-- ==================================================\n-- Function: find_shortest_path_bidirectional\n-- ==================================================\n-- Purpose: Find the shortest path between two entities using bidirectional BFS\n-- Returns: Shortest path with relationship types and directions\n-- Performance: Bidirectional BFS for O(b^(d/2)) vs O(b^d) complexity\n\nCREATE OR REPLACE FUNCTION find_shortest_path_bidirectional(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 6,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER,\n found BOOLEAN\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length,\n      TRUE AS found;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE path_search AS (\n    -- Base case: Outgoing from source\n    SELECT\n      ARRAY[source_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path,\n      1 AS depth,\n      dr.target_dossier_id AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE dr.source_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Base case: Incoming to source\n    SELECT\n      ARRAY[source_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path,\n      1 AS depth,\n      dr.source_dossier_id AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE dr.target_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive outgoing\n    SELECT\n      ps.current_path || dr.target_dossier_id,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || 'outgoing'::TEXT,\n      ps.depth + 1,\n      dr.target_dossier_id\n    FROM path_search ps\n    JOIN dossier_relationships dr ON dr.source_dossier_id = ps.current_node\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE ps.depth < max_depth\n      AND NOT (dr.target_dossier_id = ANY(ps.current_path))\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive incoming\n    SELECT\n      ps.current_path || dr.source_dossier_id,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || 'incoming'::TEXT,\n      ps.depth + 1,\n      dr.source_dossier_id\n    FROM path_search ps\n    JOIN dossier_relationships dr ON dr.target_dossier_id = ps.current_node\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE ps.depth < max_depth\n      AND NOT (dr.source_dossier_id = ANY(ps.current_path))\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ps.current_path AS path,\n    ps.rel_path AS relationship_path,\n    ps.dir_path AS direction_path,\n    ps.depth AS path_length,\n    TRUE AS found\n  FROM path_search ps\n  WHERE ps.current_node = target_id\n  ORDER BY ps.depth\n  LIMIT 1;\n\n  -- If no path found, return NULL with found=false\n  IF NOT FOUND THEN\n    RETURN QUERY SELECT\n      NULL::UUID[] AS path,\n      NULL::TEXT[] AS relationship_path,\n      NULL::TEXT[] AS direction_path,\n      NULL::INTEGER AS path_length,\n      FALSE AS found;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_shortest_path_bidirectional(UUID, UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION find_shortest_path_bidirectional IS\n'Finds the shortest path between two dossiers using bidirectional search. Supports relationship type filtering and returns the complete path with relationship types and directions.';\n\n\n-- ==================================================\n-- Function: find_all_paths\n-- ==================================================\n-- Purpose: Find all unique paths between two entities (up to a limit)\n-- Returns: All distinct paths sorted by length\n-- Use case: Understanding multiple connection routes between entities\n\nCREATE OR REPLACE FUNCTION find_all_paths(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 4,\n max_paths INTEGER DEFAULT 10,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length\n    LIMIT 1;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE all_paths AS (\n    -- Base case: Outgoing from source\n    SELECT\n      ARRAY[source_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE dr.source_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Base case: Incoming to source\n    SELECT\n      ARRAY[source_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE dr.target_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive outgoing\n    SELECT\n      ap.current_path || dr.target_dossier_id,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || 'outgoing'::TEXT,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE ap.depth < max_depth\n      AND NOT (dr.target_dossier_id = ANY(ap.current_path))\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive incoming\n    SELECT\n      ap.current_path || dr.source_dossier_id,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || 'incoming'::TEXT,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON dr.target_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE ap.depth < max_depth\n      AND NOT (dr.source_dossier_id = ANY(ap.current_path))\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ap.current_path AS path,\n    ap.rel_path AS relationship_path,\n    ap.dir_path AS direction_path,\n    ap.depth AS path_length\n  FROM all_paths ap\n  WHERE ap.current_path[array_length(ap.current_path, 1)] = target_id\n  ORDER BY ap.depth, ap.current_path\n  LIMIT max_paths;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_all_paths(UUID, UUID, INTEGER, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION find_all_paths IS\n'Finds all unique paths between two dossiers up to a specified depth and count limit. Useful for understanding multiple connection routes between entities.';\n\n\n-- ==================================================\n-- Function: find_connected_entities\n-- ==================================================\n-- Purpose: Find all entities connected to a starting point (connected component)\n-- Returns: All reachable entities regardless of relationship direction\n-- Use case: Network analysis, impact assessment\n\nCREATE OR REPLACE FUNCTION find_connected_entities(\n start_dossier_id UUID,\n max_entities INTEGER DEFAULT 100,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n min_distance INTEGER,\n connection_count INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE connected AS (\n    -- Starting node\n    SELECT\n      start_dossier_id AS current_id,\n      0 AS distance,\n      ARRAY[start_dossier_id] AS visited\n\n    UNION\n\n    -- Follow all edges bidirectionally\n    SELECT DISTINCT\n      CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_id,\n      c.distance + 1,\n      c.visited || CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END\n    FROM connected c\n    JOIN dossier_relationships dr ON\n      (dr.source_dossier_id = c.current_id OR dr.target_dossier_id = c.current_id)\n    WHERE\n      NOT (\n        CASE\n          WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(c.visited)\n      )\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  ),\n  -- Aggregate to get minimum distance and count connections\n  entity_stats AS (\n    SELECT\n      c.current_id,\n      MIN(c.distance) AS min_dist,\n      COUNT(*) FILTER (WHERE c.distance > 0) AS conn_count\n    FROM connected c\n    GROUP BY c.current_id\n  )\n  SELECT\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    es.min_dist AS min_distance,\n    COALESCE(es.conn_count::INTEGER, 0) AS connection_count\n  FROM entity_stats es\n  JOIN dossiers d ON d.id = es.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY es.min_dist, d.name_en\n  LIMIT max_entities;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_connected_entities(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\nCOMMENT ON FUNCTION find_connected_entities IS\n'Finds all entities in the connected component containing the starting dossier. Returns entities with their minimum distance and connection count. Useful for network analysis and impact assessment.';\n\n\n-- ==================================================\n-- Function: get_relationship_chain\n-- ==================================================\n-- Purpose: Find chains of specific relationship patterns\n-- Returns: Entities matching a specific chain of relationship types\n-- Use case: Finding patterns like \"Country â†’ member_of â†’ Organization â†’ participates_in â†’ Forum\"\n\nCREATE OR REPLACE FUNCTION get_relationship_chain(\n start_dossier_id UUID,\n relationship_chain TEXT[],\n bidirectional_chain BOOLEAN[] DEFAULT NULL\n)\nRETURNS TABLE (\n chain_position INTEGER,\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n relationship_type TEXT,\n direction TEXT,\n full_path UUID[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\n  chain_length INTEGER;\n  bidir_chain BOOLEAN[];\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  chain_length := array_length(relationship_chain, 1);\n\n  -- Default to all outgoing if bidirectional_chain not specified\n  IF bidirectional_chain IS NULL THEN\n    bidir_chain := ARRAY_FILL(FALSE, ARRAY[chain_length]);\n  ELSE\n    bidir_chain := bidirectional_chain;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE chain_search AS (\n    -- Position 0: Starting dossier\n    SELECT\n      0 AS pos,\n      start_dossier_id AS current_id,\n      NULL::TEXT AS rel_type,\n      'start'::TEXT AS dir,\n      ARRAY[start_dossier_id] AS path_arr\n\n    UNION ALL\n\n    -- Follow the chain pattern\n    SELECT\n      cs.pos + 1,\n      CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          CASE\n            WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n            ELSE dr.source_dossier_id\n          END\n        ELSE dr.target_dossier_id\n      END,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = cs.current_id THEN 'outgoing'\n        ELSE 'incoming'\n      END,\n      cs.path_arr || CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          CASE\n            WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n            ELSE dr.source_dossier_id\n          END\n        ELSE dr.target_dossier_id\n      END\n    FROM chain_search cs\n    JOIN dossier_relationships dr ON\n      CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          (dr.source_dossier_id = cs.current_id OR dr.target_dossier_id = cs.current_id)\n        ELSE\n          dr.source_dossier_id = cs.current_id\n      END\n    WHERE cs.pos < chain_length\n      AND dr.relationship_type = relationship_chain[cs.pos + 1]\n      AND dr.status = 'active'\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND NOT (\n        CASE\n          WHEN bidir_chain[cs.pos + 1] THEN\n            CASE\n              WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n              ELSE dr.source_dossier_id\n            END\n          ELSE dr.target_dossier_id\n        END = ANY(cs.path_arr)\n      )\n  )\n  SELECT\n    cs.pos AS chain_position,\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    cs.rel_type AS relationship_type,\n    cs.dir AS direction,\n    cs.path_arr AS full_path\n  FROM chain_search cs\n  JOIN dossiers d ON d.id = cs.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n  ORDER BY cs.path_arr, cs.pos;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_relationship_chain(UUID, TEXT[], BOOLEAN[]) TO authenticated;\n\nCOMMENT ON FUNCTION get_relationship_chain IS\n'Finds entities matching a specific chain of relationship types. Use for pattern matching like \"Country â†’ member_of â†’ Organization â†’ participates_in â†’ Forum\". Returns all entities along matching chains with their positions.';\n\n\n-- ==================================================\n-- Function: get_common_connections\n-- ==================================================\n-- Purpose: Find entities that connect two dossiers (mutual connections)\n-- Returns: Entities that have relationships with both source and target\n-- Use case: Finding bridge entities, common affiliations\n\nCREATE OR REPLACE FUNCTION get_common_connections(\n dossier_a_id UUID,\n dossier_b_id UUID,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n relationship_to_a TEXT,\n direction_to_a TEXT,\n relationship_to_b TEXT,\n direction_to_b TEXT\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH connections_a AS (\n    -- Get all connections to dossier A\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = dossier_a_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS connected_id,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = dossier_a_id THEN 'outgoing'\n        ELSE 'incoming'\n      END AS direction\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = dossier_a_id OR dr.target_dossier_id = dossier_a_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  ),\n  connections_b AS (\n    -- Get all connections to dossier B\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = dossier_b_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS connected_id,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = dossier_b_id THEN 'outgoing'\n        ELSE 'incoming'\n      END AS direction\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = dossier_b_id OR dr.target_dossier_id = dossier_b_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    ca.relationship_type AS relationship_to_a,\n    ca.direction AS direction_to_a,\n    cb.relationship_type AS relationship_to_b,\n    cb.direction AS direction_to_b\n  FROM connections_a ca\n  JOIN connections_b cb ON ca.connected_id = cb.connected_id\n  JOIN dossiers d ON d.id = ca.connected_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND d.id != dossier_a_id\n    AND d.id != dossier_b_id\n  ORDER BY d.id, d.name_en;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_common_connections(UUID, UUID, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION get_common_connections IS\n'Finds entities that have relationships with both specified dossiers. Useful for finding bridge entities, common affiliations, and mutual connections between two entities.';\n\n\n-- ==================================================\n-- Function: get_graph_statistics\n-- ==================================================\n-- Purpose: Calculate network statistics for a subgraph\n-- Returns: Node count, edge count, density, average degree, etc.\n-- Use case: Network analysis dashboard\n\nCREATE OR REPLACE FUNCTION get_graph_statistics(\n start_dossier_id UUID DEFAULT NULL,\n max_degrees INTEGER DEFAULT 3,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n total_nodes BIGINT,\n total_edges BIGINT,\n graph_density NUMERIC,\n avg_degree NUMERIC,\n max_degree BIGINT,\n isolated_nodes BIGINT,\n dossier_type_distribution JSONB\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  IF start_dossier_id IS NOT NULL THEN\n    -- Calculate stats for subgraph starting from a dossier\n    RETURN QUERY\n    WITH subgraph_nodes AS (\n      SELECT DISTINCT dossier_id\n      FROM traverse_relationship_graph_bidirectional(\n        start_dossier_id,\n        max_degrees,\n        relationship_types,\n        include_inactive,\n        NULL\n      )\n      UNION\n      SELECT start_dossier_id\n    ),\n    subgraph_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT dossier_id FROM subgraph_nodes)\n        AND dr.target_dossier_id IN (SELECT dossier_id FROM subgraph_nodes)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        sn.dossier_id,\n        COUNT(DISTINCT se.id) AS degree\n      FROM subgraph_nodes sn\n      LEFT JOIN subgraph_edges se ON\n        se.source_dossier_id = sn.dossier_id OR se.target_dossier_id = sn.dossier_id\n      GROUP BY sn.dossier_id\n    ),\n    type_counts AS (\n      SELECT\n        d.type,\n        COUNT(*) AS cnt\n      FROM subgraph_nodes sn\n      JOIN dossiers d ON d.id = sn.dossier_id\n      GROUP BY d.type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM subgraph_nodes)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM subgraph_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM subgraph_nodes) <= 1 THEN 0\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM subgraph_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM subgraph_nodes) * ((SELECT COUNT(*) FROM subgraph_nodes) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT MAX(degree) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      (SELECT jsonb_object_agg(type, cnt) FROM type_counts) AS dossier_type_distribution;\n  ELSE\n    -- Calculate stats for entire graph (visible to user)\n    RETURN QUERY\n    WITH visible_dossiers AS (\n      SELECT id, type\n      FROM dossiers\n      WHERE status != 'deleted'\n        AND sensitivity_level <= user_clearance\n    ),\n    visible_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND dr.target_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        vd.id,\n        COUNT(DISTINCT ve.id) AS degree\n      FROM visible_dossiers vd\n      LEFT JOIN visible_edges ve ON\n        ve.source_dossier_id = vd.id OR ve.target_dossier_id = vd.id\n      GROUP BY vd.id\n    ),\n    type_counts AS (\n      SELECT\n        type,\n        COUNT(*) AS cnt\n      FROM visible_dossiers\n      GROUP BY type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM visible_dossiers)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM visible_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM visible_dossiers) <= 1 THEN 0\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM visible_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM visible_dossiers) * ((SELECT COUNT(*) FROM visible_dossiers) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT MAX(degree) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      (SELECT jsonb_object_agg(type, cnt) FROM type_counts) AS dossier_type_distribution;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_graph_statistics(UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\nCOMMENT ON FUNCTION get_graph_statistics IS\n'Calculates network statistics for the entire graph or a subgraph starting from a specific dossier. Returns metrics like density, average degree, and type distribution.';\n\n\n-- ==================================================\n-- Indexes for performance optimization\n-- ==================================================\n\n-- Composite index for bidirectional lookups\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_source_status_type\nON dossier_relationships(source_dossier_id, status, relationship_type);\n\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_target_status_type\nON dossier_relationships(target_dossier_id, status, relationship_type);\n\n-- Index for temporal queries\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_effective_dates\nON dossier_relationships(effective_from, effective_to)\nWHERE status = 'active';\n\n-- Partial index for active relationships (most common query pattern)\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_active_source\nON dossier_relationships(source_dossier_id)\nWHERE status = 'active' AND (effective_to IS NULL OR effective_to > now());\n\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_active_target\nON dossier_relationships(target_dossier_id)\nWHERE status = 'active' AND (effective_to IS NULL OR effective_to > now());"
}
The partial indexes with `now()` are not valid since `now()` is not immutable. Let me fix the migration and reapply:

ðŸ”§ Tool: mcp**supabase**apply_migration
Input: {
"project_id": "zkrcjzdemdmwhearhfgg",
"name": "enhanced_graph_traversal",
"query": "-- Migration: Enhanced Graph Traversal Functions\n-- Description: Recursive graph traversal for finding connected entities, shortest paths, and relationship chains\n-- Feature: relationship-graph-traversal\n-- Supports: Multi-hop queries with depth limits and relationship type filtering\n\n-- ==================================================\n-- Function: traverse_relationship_graph_bidirectional\n-- ==================================================\nCREATE OR REPLACE FUNCTION traverse_relationship_graph_bidirectional(\n start_dossier_id UUID,\n max_degrees INTEGER DEFAULT 2,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n degree INTEGER,\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE relationship_graph AS (\n    SELECT\n      dr.target_dossier_id AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path\n    FROM dossier_relationships dr\n    WHERE dr.source_dossier_id = start_dossier_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    SELECT\n      dr.source_dossier_id AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path\n    FROM dossier_relationships dr\n    WHERE dr.target_dossier_id = start_dossier_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    SELECT\n      dr.target_dossier_id,\n      rg.current_degree + 1,\n      rg.current_path || dr.target_dossier_id,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || 'outgoing'::TEXT\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON dr.source_dossier_id = rg.current_id\n    WHERE rg.current_degree < max_degrees\n      AND NOT (dr.target_dossier_id = ANY(rg.current_path))\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    SELECT\n      dr.source_dossier_id,\n      rg.current_degree + 1,\n      rg.current_path || dr.source_dossier_id,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || 'incoming'::TEXT\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON dr.target_dossier_id = rg.current_id\n    WHERE rg.current_degree < max_degrees\n      AND NOT (dr.source_dossier_id = ANY(rg.current_path))\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    rg.current_degree AS degree,\n    rg.current_path AS path,\n    rg.rel_path AS relationship_path,\n    rg.dir_path AS direction_path\n  FROM relationship_graph rg\n  JOIN dossiers d ON d.id = rg.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY d.id, rg.current_degree;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION traverse_relationship_graph_bidirectional(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\n-- ==================================================\n-- Function: find_shortest_path_bidirectional\n-- ==================================================\nCREATE OR REPLACE FUNCTION find_shortest_path_bidirectional(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 6,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER,\n found BOOLEAN\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length,\n      TRUE AS found;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE path_search AS (\n    SELECT\n      ARRAY[source_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path,\n      1 AS depth,\n      dr.target_dossier_id AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE dr.source_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    SELECT\n      ARRAY[source_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path,\n      1 AS depth,\n      dr.source_dossier_id AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE dr.target_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    SELECT\n      ps.current_path || dr.target_dossier_id,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || 'outgoing'::TEXT,\n      ps.depth + 1,\n      dr.target_dossier_id\n    FROM path_search ps\n    JOIN dossier_relationships dr ON dr.source_dossier_id = ps.current_node\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE ps.depth < max_depth\n      AND NOT (dr.target_dossier_id = ANY(ps.current_path))\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    SELECT\n      ps.current_path || dr.source_dossier_id,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || 'incoming'::TEXT,\n      ps.depth + 1,\n      dr.source_dossier_id\n    FROM path_search ps\n    JOIN dossier_relationships dr ON dr.target_dossier_id = ps.current_node\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE ps.depth < max_depth\n      AND NOT (dr.source_dossier_id = ANY(ps.current_path))\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ps.current_path AS path,\n    ps.rel_path AS relationship_path,\n    ps.dir_path AS direction_path,\n    ps.depth AS path_length,\n    TRUE AS found\n  FROM path_search ps\n  WHERE ps.current_node = target_id\n  ORDER BY ps.depth\n  LIMIT 1;\n\n  IF NOT FOUND THEN\n    RETURN QUERY SELECT\n      NULL::UUID[] AS path,\n      NULL::TEXT[] AS relationship_path,\n      NULL::TEXT[] AS direction_path,\n      NULL::INTEGER AS path_length,\n      FALSE AS found;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_shortest_path_bidirectional(UUID, UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n-- ==================================================\n-- Function: find_all_paths\n-- ==================================================\nCREATE OR REPLACE FUNCTION find_all_paths(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 4,\n max_paths INTEGER DEFAULT 10,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length\n    LIMIT 1;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE all_paths AS (\n    SELECT\n      ARRAY[source_id, dr.target_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['outgoing'::TEXT] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE dr.source_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    SELECT\n      ARRAY[source_id, dr.source_dossier_id] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY['incoming'::TEXT] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE dr.target_dossier_id = source_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    SELECT\n      ap.current_path || dr.target_dossier_id,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || 'outgoing'::TEXT,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    JOIN dossiers d ON d.id = dr.target_dossier_id\n    WHERE ap.depth < max_depth\n      AND NOT (dr.target_dossier_id = ANY(ap.current_path))\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    SELECT\n      ap.current_path || dr.source_dossier_id,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || 'incoming'::TEXT,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON dr.target_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    JOIN dossiers d ON d.id = dr.source_dossier_id\n    WHERE ap.depth < max_depth\n      AND NOT (dr.source_dossier_id = ANY(ap.current_path))\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ap.current_path AS path,\n    ap.rel_path AS relationship_path,\n    ap.dir_path AS direction_path,\n    ap.depth AS path_length\n  FROM all_paths ap\n  WHERE ap.current_path[array_length(ap.current_path, 1)] = target_id\n  ORDER BY ap.depth, ap.current_path\n  LIMIT max_paths;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_all_paths(UUID, UUID, INTEGER, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n-- ==================================================\n-- Function: find_connected_entities\n-- ==================================================\nCREATE OR REPLACE FUNCTION find_connected_entities(\n start_dossier_id UUID,\n max_entities INTEGER DEFAULT 100,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n min_distance INTEGER,\n connection_count INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE connected AS (\n    SELECT\n      start_dossier_id AS current_id,\n      0 AS distance,\n      ARRAY[start_dossier_id] AS visited\n\n    UNION\n\n    SELECT DISTINCT\n      CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_id,\n      c.distance + 1,\n      c.visited || CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END\n    FROM connected c\n    JOIN dossier_relationships dr ON\n      (dr.source_dossier_id = c.current_id OR dr.target_dossier_id = c.current_id)\n    WHERE\n      NOT (\n        CASE\n          WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(c.visited)\n      )\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  ),\n  entity_stats AS (\n    SELECT\n      c.current_id,\n      MIN(c.distance) AS min_dist,\n      COUNT(*) FILTER (WHERE c.distance > 0) AS conn_count\n    FROM connected c\n    GROUP BY c.current_id\n  )\n  SELECT\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    es.min_dist AS min_distance,\n    COALESCE(es.conn_count::INTEGER, 0) AS connection_count\n  FROM entity_stats es\n  JOIN dossiers d ON d.id = es.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY es.min_dist, d.name_en\n  LIMIT max_entities;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_connected_entities(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\n-- ==================================================\n-- Function: get_relationship_chain\n-- ==================================================\nCREATE OR REPLACE FUNCTION get_relationship_chain(\n start_dossier_id UUID,\n relationship_chain TEXT[],\n bidirectional_chain BOOLEAN[] DEFAULT NULL\n)\nRETURNS TABLE (\n chain_position INTEGER,\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n relationship_type TEXT,\n direction TEXT,\n full_path UUID[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\n  chain_length INTEGER;\n  bidir_chain BOOLEAN[];\nBEGIN\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  chain_length := array_length(relationship_chain, 1);\n\n  IF bidirectional_chain IS NULL THEN\n    bidir_chain := ARRAY_FILL(FALSE, ARRAY[chain_length]);\n  ELSE\n    bidir_chain := bidirectional_chain;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE chain_search AS (\n    SELECT\n      0 AS pos,\n      start_dossier_id AS current_id,\n      NULL::TEXT AS rel_type,\n      'start'::TEXT AS dir,\n      ARRAY[start_dossier_id] AS path_arr\n\n    UNION ALL\n\n    SELECT\n      cs.pos + 1,\n      CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          CASE\n            WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n            ELSE dr.source_dossier_id\n          END\n        ELSE dr.target_dossier_id\n      END,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = cs.current_id THEN 'outgoing'\n        ELSE 'incoming'\n      END,\n      cs.path_arr || CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          CASE\n            WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n            ELSE dr.source_dossier_id\n          END\n        ELSE dr.target_dossier_id\n      END\n    FROM chain_search cs\n    JOIN dossier_relationships dr ON\n      CASE\n        WHEN bidir_chain[cs.pos + 1] THEN\n          (dr.source_dossier_id = cs.current_id OR dr.target_dossier_id = cs.current_id)\n        ELSE\n          dr.source_dossier_id = cs.current_id\n      END\n    WHERE cs.pos < chain_length\n      AND dr.relationship_type = relationship_chain[cs.pos + 1]\n      AND dr.status = 'active'\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND NOT (\n        CASE\n          WHEN bidir_chain[cs.pos + 1] THEN\n            CASE\n              WHEN dr.source_dossier_id = cs.current_id THEN dr.target_dossier_id\n              ELSE dr.source_dossier_id\n            END\n          ELSE dr.target_dossier_id\n        END = ANY(cs.path_arr)\n      )\n  )\n  SELECT\n    cs.pos AS chain_position,\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    cs.rel_type AS relationship_type,\n    cs.dir AS direction,\n    cs.path_arr AS full_path\n  FROM chain_search cs\n  JOIN dossiers d ON d.id = cs.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n  ORDER BY cs.path_arr, cs.pos;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_relationship_chain(UUID, TEXT[], BOOLEAN[]) TO authenticated;\n\n-- ==================================================\n-- Function: get_common_connections\n-- ==================================================\nCREATE OR REPLACE FUNCTION get_common_connections(\n dossier_a_id UUID,\n dossier_b_id UUID,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n relationship_to_a TEXT,\n direction_to_a TEXT,\n relationship_to_b TEXT,\n direction_to_b TEXT\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH connections_a AS (\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = dossier_a_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS connected_id,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = dossier_a_id THEN 'outgoing'\n        ELSE 'incoming'\n      END AS direction\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = dossier_a_id OR dr.target_dossier_id = dossier_a_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  ),\n  connections_b AS (\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = dossier_b_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS connected_id,\n      dr.relationship_type,\n      CASE\n        WHEN dr.source_dossier_id = dossier_b_id THEN 'outgoing'\n        ELSE 'incoming'\n      END AS direction\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = dossier_b_id OR dr.target_dossier_id = dossier_b_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    ca.relationship_type AS relationship_to_a,\n    ca.direction AS direction_to_a,\n    cb.relationship_type AS relationship_to_b,\n    cb.direction AS direction_to_b\n  FROM connections_a ca\n  JOIN connections_b cb ON ca.connected_id = cb.connected_id\n  JOIN dossiers d ON d.id = ca.connected_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND d.id != dossier_a_id\n    AND d.id != dossier_b_id\n  ORDER BY d.id, d.name_en;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_common_connections(UUID, UUID, TEXT[], BOOLEAN) TO authenticated;\n\n-- ==================================================\n-- Function: get_graph_statistics\n-- ==================================================\nCREATE OR REPLACE FUNCTION get_graph_statistics(\n start_dossier_id UUID DEFAULT NULL,\n max_degrees INTEGER DEFAULT 3,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n total_nodes BIGINT,\n total_edges BIGINT,\n graph_density NUMERIC,\n avg_degree NUMERIC,\n max_degree BIGINT,\n isolated_nodes BIGINT,\n dossier_type_distribution JSONB\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  IF start_dossier_id IS NOT NULL THEN\n    RETURN QUERY\n    WITH subgraph_nodes AS (\n      SELECT DISTINCT tg.dossier_id\n      FROM traverse_relationship_graph_bidirectional(\n        start_dossier_id,\n        max_degrees,\n        relationship_types,\n        include_inactive,\n        NULL\n      ) tg\n      UNION\n      SELECT start_dossier_id\n    ),\n    subgraph_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT dossier_id FROM subgraph_nodes)\n        AND dr.target_dossier_id IN (SELECT dossier_id FROM subgraph_nodes)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        sn.dossier_id,\n        COUNT(DISTINCT se.id) AS degree\n      FROM subgraph_nodes sn\n      LEFT JOIN subgraph_edges se ON\n        se.source_dossier_id = sn.dossier_id OR se.target_dossier_id = sn.dossier_id\n      GROUP BY sn.dossier_id\n    ),\n    type_counts AS (\n      SELECT\n        d.type,\n        COUNT(*) AS cnt\n      FROM subgraph_nodes sn\n      JOIN dossiers d ON d.id = sn.dossier_id\n      GROUP BY d.type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM subgraph_nodes)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM subgraph_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM subgraph_nodes) <= 1 THEN 0\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM subgraph_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM subgraph_nodes) * ((SELECT COUNT(*) FROM subgraph_nodes) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT MAX(degree) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      (SELECT jsonb_object_agg(type, cnt) FROM type_counts) AS dossier_type_distribution;\n  ELSE\n    RETURN QUERY\n    WITH visible_dossiers AS (\n      SELECT id, type\n      FROM dossiers\n      WHERE status != 'deleted'\n        AND sensitivity_level <= user_clearance\n    ),\n    visible_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND dr.target_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        vd.id,\n        COUNT(DISTINCT ve.id) AS degree\n      FROM visible_dossiers vd\n      LEFT JOIN visible_edges ve ON\n        ve.source_dossier_id = vd.id OR ve.target_dossier_id = vd.id\n      GROUP BY vd.id\n    ),\n    type_counts AS (\n      SELECT\n        type,\n        COUNT(*) AS cnt\n      FROM visible_dossiers\n      GROUP BY type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM visible_dossiers)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM visible_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM visible_dossiers) <= 1 THEN 0\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM visible_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM visible_dossiers) * ((SELECT COUNT(*) FROM visible_dossiers) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT MAX(degree) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      (SELECT jsonb_object_agg(type, cnt) FROM type_counts) AS dossier_type_distribution;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_graph_statistics(UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n-- ==================================================\n-- Indexes for performance optimization (without now() in predicate)\n-- ==================================================\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_source_status_type\nON dossier_relationships(source_dossier_id, status, relationship_type);\n\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_target_status_type\nON dossier_relationships(target_dossier_id, status, relationship_type);\n\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_effective_dates\nON dossier_relationships(effective_from, effective_to)\nWHERE status = 'active';\n\n-- Simple partial indexes for active status only\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_active_source\nON dossier_relationships(source_dossier_id)\nWHERE status = 'active';\n\nCREATE INDEX IF NOT EXISTS idx_dossier_relationships_active_target\nON dossier_relationships(target_dossier_id)\nWHERE status = 'active';"
}
Migration applied successfully. Now let me update the todos and deploy the Edge Function:

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "completed",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "completed",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "completed",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "completed",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "completed",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "in_progress",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "pending",
"activeForm": "Verifying feature with Playwright test"
}
]
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts"
}
Now let me deploy the Edge Function to Supabase:

ðŸ”§ Tool: mcp**supabase**deploy_edge_function
Input: {
"project_id": "zkrcjzdemdmwhearhfgg",
"name": "graph-traversal-advanced",
"entrypoint_path": "index.ts",
"verify_jwt": true,
"files": [
{
"name": "index.ts",
"content": "/\*_\n _ Advanced Graph Traversal Edge Function\n _ Feature: relationship-graph-traversal\n _\n _ Provides endpoints for:\n _ - Bidirectional N-degree traversal\n _ - Shortest path finding\n _ - All paths between entities\n _ - Connected entities discovery\n _ - Relationship chain pattern matching\n _ - Common connections between entities\n _ - Graph statistics\n _/\n\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\n\nconst corsHeaders = {\n 'Access-Control-Allow-Origin': '_',\n 'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n};\n\ninterface DossierReference {\n id: string;\n type: string;\n name_en: string;\n name_ar: string;\n status: string;\n}\n\ninterface GraphNode {\n id: string;\n type: string;\n name_en: string;\n name_ar: string;\n status: string;\n degree: number;\n path: string[];\n relationship_path?: string[];\n direction_path?: string[];\n}\n\ninterface GraphEdge {\n source_id: string;\n target_id: string;\n relationship_type: string;\n direction?: string;\n}\n\ninterface PathResult {\n path: string[];\n relationship_path: string[];\n direction_path: string[];\n path_length: number;\n found?: boolean;\n}\n\ninterface ChainResult {\n chain_position: number;\n dossier_id: string;\n dossier_type: string;\n name_en: string;\n name_ar: string;\n status: string;\n relationship_type: string | null;\n direction: string;\n full_path: string[];\n}\n\ninterface CommonConnectionResult {\n dossier_id: string;\n dossier_type: string;\n name_en: string;\n name_ar: string;\n status: string;\n relationship_to_a: string;\n direction_to_a: string;\n relationship_to_b: string;\n direction_to_b: string;\n}\n\ninterface GraphStats {\n total_nodes: number;\n total_edges: number;\n graph_density: number;\n avg_degree: number;\n max_degree: number;\n isolated_nodes: number;\n dossier_type_distribution: Record<string, number>;\n}\n\nfunction parseArrayParam(param: string | null): string[] | null {\n if (!param) return null;\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed : [param];\n } catch {\n return param.split(',').map((s) => s.trim());\n }\n}\n\nfunction parseBooleanArrayParam(param: string | null): boolean[] | null {\n if (!param) return null;\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed.map(Boolean) : null;\n } catch {\n return param.split(',').map((s) => s.trim().toLowerCase() === 'true');\n }\n}\n\nserve(async (req) => {\n // Handle CORS preflight\n if (req.method === 'OPTIONS') {\n return new Response(null, { headers: corsHeaders });\n }\n\n if (req.method !== 'GET' && req.method !== 'POST') {\n return new Response(JSON.stringify({ error: 'Method not allowed' }), {\n status: 405,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n try {\n const startTime = Date.now();\n\n // Get authorization header\n const authHeader = req.headers.get('Authorization');\n if (!authHeader) {\n return new Response(JSON.stringify({ error: 'Missing authorization header' }), {\n status: 401,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n // Create Supabase client\n const supabaseClient = createClient(\n Deno.env.get('SUPABASE_URL') ?? '',\n Deno.env.get('SUPABASE_ANON_KEY') ?? '',\n { global: { headers: { Authorization: authHeader } } }\n );\n\n // Parse URL and operation\n const url = new URL(req.url);\n const pathParts = url.pathname.split('/').filter(Boolean);\n const operation = pathParts[pathParts.length - 1] || 'traverse';\n\n // Get parameters from query string (GET) or body (POST)\n let params: Record<string, string | null> = {};\n\n if (req.method === 'GET') {\n url.searchParams.forEach((value, key) => {\n params[key] = value;\n });\n } else {\n const body = await req.json();\n params = body;\n }\n\n let result: unknown;\n\n switch (operation) {\n case 'traverse':\n case 'graph-traversal-advanced': {\n // Bidirectional N-degree traversal\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const maxDegrees = parseInt(params.maxDegrees || params.max_degrees || '2', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n const dossierTypeFilter = parseArrayParam(\n params.dossierTypeFilter || params.dossier_type_filter || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n if (maxDegrees < 1 || maxDegrees > 6) {\n return new Response(JSON.stringify({ error: 'maxDegrees must be between 1 and 6' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n // Verify starting dossier exists\n const { data: startDossier, error: dossierError } = await supabaseClient\n .from('dossiers')\n .select('id, type, name_en, name_ar, status')\n .eq('id', startDossierId)\n .single();\n\n if (dossierError || !startDossier) {\n return new Response(\n JSON.stringify({ error: 'Starting dossier not found or access denied' }),\n { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n // Call bidirectional traversal function\n const { data: graphData, error: graphError } = await supabaseClient.rpc(\n 'traverse_relationship_graph_bidirectional',\n {\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n dossier_type_filter: dossierTypeFilter,\n }\n );\n\n if (graphError) {\n console.error('Graph traversal error:', graphError);\n throw graphError;\n }\n\n // Transform to nodes and edges\n const nodesMap = new Map<string, GraphNode>();\n const edges: GraphEdge[] = [];\n\n // Add starting node\n nodesMap.set(startDossierId, {\n id: startDossierId,\n type: startDossier.type,\n name_en: startDossier.name_en,\n name_ar: startDossier.name_ar,\n status: startDossier.status,\n degree: 0,\n path: [startDossierId],\n });\n\n // Process graph results\n (graphData || []).forEach((row: any) => {\n if (!nodesMap.has(row.dossier_id)) {\n nodesMap.set(row.dossier_id, {\n id: row.dossier_id,\n type: row.dossier_type,\n name_en: row.name_en,\n name_ar: row.name_ar,\n status: row.status,\n degree: row.degree,\n path: row.path,\n relationship_path: row.relationship_path,\n direction_path: row.direction_path,\n });\n }\n\n // Build edges from path\n if (row.path && row.path.length > 1 && row.relationship_path) {\n for (let i = 0; i < row.path.length - 1; i++) {\n const sourceId = row.path[i];\n const targetId = row.path[i + 1];\n const relType = row.relationship_path[i];\n const direction = row.direction_path?.[i] || 'outgoing';\n\n const edgeKey = `${sourceId}-${targetId}-${relType}`;\n const reverseKey = `${targetId}-${sourceId}-${relType}`;\n\n const edgeExists = edges.some(\n (e) =>\n (`${e.source_id}-${e.target_id}-${e.relationship_type}` === edgeKey) ||\n (`${e.source_id}-${e.target_id}-${e.relationship_type}` === reverseKey)\n );\n\n if (!edgeExists) {\n edges.push({\n source_id: direction === 'outgoing' ? sourceId : targetId,\n target_id: direction === 'outgoing' ? targetId : sourceId,\n relationship_type: relType,\n direction,\n });\n }\n }\n }\n });\n\n const nodes = Array.from(nodesMap.values());\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'traverse_bidirectional',\n start_dossier_id: startDossierId,\n start_dossier: startDossier,\n max_degrees: maxDegrees,\n relationship_type_filter: relationshipTypes || 'all',\n dossier_type_filter: dossierTypeFilter || 'all',\n include_inactive: includeInactive,\n nodes,\n edges,\n stats: {\n node_count: nodes.length,\n edge_count: edges.length,\n max_degree_found: nodes.length > 0 ? Math.max(...nodes.map((n) => n.degree)) : 0,\n query_time_ms: queryTime,\n performance_warning: queryTime > 2000 ? 'Query exceeded 2s performance target' : null,\n },\n };\n break;\n }\n\n case 'shortest-path': {\n // Find shortest path between two entities\n const sourceId = params.sourceId || params.source_id;\n const targetId = params.targetId || params.target_id;\n const maxDepth = parseInt(params.maxDepth || params.max_depth || '6', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!sourceId || !targetId) {\n return new Response(\n JSON.stringify({ error: 'Missing sourceId or targetId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: pathData, error: pathError } = await supabaseClient.rpc(\n 'find_shortest_path_bidirectional',\n {\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (pathError) {\n console.error('Shortest path error:', pathError);\n throw pathError;\n }\n\n const pathResult = pathData?.[0] as PathResult | undefined;\n\n // Fetch dossier details for path nodes\n let pathDossiers: DossierReference[] = [];\n if (pathResult?.found && pathResult.path) {\n const { data: dossiers } = await supabaseClient\n .from('dossiers')\n .select('id, type, name_en, name_ar, status')\n .in('id', pathResult.path);\n pathDossiers = dossiers || [];\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'shortest_path',\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n found: pathResult?.found || false,\n path: pathResult?.path || null,\n relationship_path: pathResult?.relationship_path || null,\n direction_path: pathResult?.direction_path || null,\n path_length: pathResult?.path_length ?? null,\n path_dossiers: pathDossiers,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'all-paths': {\n // Find all paths between two entities\n const sourceId = params.sourceId || params.source_id;\n const targetId = params.targetId || params.target_id;\n const maxDepth = parseInt(params.maxDepth || params.max_depth || '4', 10);\n const maxPaths = parseInt(params.maxPaths || params.max_paths || '10', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!sourceId || !targetId) {\n return new Response(\n JSON.stringify({ error: 'Missing sourceId or targetId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: pathsData, error: pathsError } = await supabaseClient.rpc('find_all_paths', {\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n max_paths: maxPaths,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n });\n\n if (pathsError) {\n console.error('All paths error:', pathsError);\n throw pathsError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'all_paths',\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n max_paths: maxPaths,\n paths: pathsData || [],\n path_count: (pathsData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'connected-entities': {\n // Find all connected entities\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const maxEntities = parseInt(params.maxEntities || params.max_entities || '100', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n const dossierTypeFilter = parseArrayParam(\n params.dossierTypeFilter || params.dossier_type_filter || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n const { data: connectedData, error: connectedError } = await supabaseClient.rpc(\n 'find_connected_entities',\n {\n start_dossier_id: startDossierId,\n max_entities: maxEntities,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n dossier_type_filter: dossierTypeFilter,\n }\n );\n\n if (connectedError) {\n console.error('Connected entities error:', connectedError);\n throw connectedError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'connected_entities',\n start_dossier_id: startDossierId,\n max_entities: maxEntities,\n entities: connectedData || [],\n entity_count: (connectedData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'relationship-chain': {\n // Find entities matching a relationship chain pattern\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const relationshipChain = parseArrayParam(\n params.relationshipChain || params.relationship_chain || null\n );\n const bidirectionalChain = parseBooleanArrayParam(\n params.bidirectionalChain || params.bidirectional_chain || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n if (!relationshipChain || relationshipChain.length === 0) {\n return new Response(JSON.stringify({ error: 'Missing relationshipChain parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n const { data: chainData, error: chainError } = await supabaseClient.rpc(\n 'get_relationship_chain',\n {\n start_dossier_id: startDossierId,\n relationship_chain: relationshipChain,\n bidirectional_chain: bidirectionalChain,\n }\n );\n\n if (chainError) {\n console.error('Relationship chain error:', chainError);\n throw chainError;\n }\n\n // Group results by chain path\n const chainResults = chainData as ChainResult[];\n const pathsMap = new Map<string, ChainResult[]>();\n\n chainResults.forEach((item) => {\n const pathKey = item.full_path.join(',');\n if (!pathsMap.has(pathKey)) {\n pathsMap.set(pathKey, []);\n }\n pathsMap.get(pathKey)!.push(item);\n });\n\n const chains = Array.from(pathsMap.values()).map((items) => ({\n path: items[0].full_path,\n entities: items.sort((a, b) => a.chain_position - b.chain_position),\n }));\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'relationship_chain',\n start_dossier_id: startDossierId,\n relationship_chain: relationshipChain,\n bidirectional_chain: bidirectionalChain,\n chains,\n chain_count: chains.length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'common-connections': {\n // Find common connections between two entities\n const dossierAId = params.dossierAId || params.dossier_a_id;\n const dossierBId = params.dossierBId || params.dossier_b_id;\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!dossierAId || !dossierBId) {\n return new Response(\n JSON.stringify({ error: 'Missing dossierAId or dossierBId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: commonData, error: commonError } = await supabaseClient.rpc(\n 'get_common_connections',\n {\n dossier_a_id: dossierAId,\n dossier_b_id: dossierBId,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (commonError) {\n console.error('Common connections error:', commonError);\n throw commonError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'common_connections',\n dossier_a_id: dossierAId,\n dossier_b_id: dossierBId,\n common_connections: commonData || [],\n connection_count: (commonData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'statistics': {\n // Get graph statistics\n const startDossierId = params.startDossierId || params.start_dossier_id || null;\n const maxDegrees = parseInt(params.maxDegrees || params.max_degrees || '3', 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === 'true' || params.include_inactive === 'true';\n\n const { data: statsData, error: statsError } = await supabaseClient.rpc(\n 'get_graph_statistics',\n {\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (statsError) {\n console.error('Graph statistics error:', statsError);\n throw statsError;\n }\n\n const stats = statsData?.[0] as GraphStats | undefined;\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'statistics',\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n statistics: stats || null,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n default:\n return new Response(\n JSON.stringify({\n error: `Unknown operation: ${operation}`,\n available_operations: [\n 'traverse',\n 'shortest-path',\n 'all-paths',\n 'connected-entities',\n 'relationship-chain',\n 'common-connections',\n 'statistics',\n ],\n }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n return new Response(JSON.stringify(result), {\n status: 200,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n } catch (error) {\n console.error('Error in graph-traversal-advanced:', error);\n return new Response(\n JSON.stringify({\n error: error.message || 'Internal server error',\n }),\n { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n});"
}
]
}

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "completed",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "completed",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "completed",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "completed",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "completed",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "completed",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "in_progress",
"activeForm": "Verifying feature with Playwright test"
}
]
}
Now I'll create a temporary Playwright test to verify the graph traversal feature works correctly. Let me first check the existing test structure and supabase configuration.

ðŸ”§ Tool: Glob
Input: {
"pattern": "frontend/tests/e2e/\*_/_.spec.ts"
}

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/playwright.config.ts"
}
Let me read an existing e2e test to understand the test patterns used in this project:

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/tests/e2e/create-view-dossier.spec.ts"
}
Now I understand the test patterns. I need to create a test that directly tests the Edge Function API endpoints. Since the graph traversal is an API-level feature, I'll create a test that calls the Edge Function directly to verify the functionality. Let me also check what dossiers and relationships exist:

ðŸ”§ Tool: mcp**supabase**execute_sql
Input: {
"project_id": "zkrcjzdemdmwhearthfgg",
"query": "SELECT id, name_en, type FROM dossiers LIMIT 5;"
}

ðŸ”§ Tool: mcp**supabase**get_project_url
Input: {
"project_id": "zkrcjzdemdmwhearthfgg"
}

ðŸ”§ Tool: mcp**supabase**get_publishable_keys
Input: {
"project_id": "zkrcjzdemdmwhearthfgg"
}
I had a typo in the project ID. Let me fix that:

ðŸ”§ Tool: mcp**supabase**execute_sql
Input: {
"project_id": "zkrcjzdemdmwhearhfgg",
"query": "SELECT id, name_en, type FROM dossiers LIMIT 5;"
}

ðŸ”§ Tool: mcp**supabase**get_project_url
Input: {
"project_id": "zkrcjzdemdmwhearhfgg"
}

ðŸ”§ Tool: mcp**supabase**get_publishable_keys
Input: {
"project_id": "zkrcjzdemdmwhearhfgg"
}
Now let me check if there are any relationships to test with:

ðŸ”§ Tool: mcp**supabase**execute_sql
Input: {
"project_id": "zkrcjzdemdmwhearhfgg",
"query": "SELECT \n dr.id, \n dr.source_dossier_id, \n d1.name_en as source_name, \n dr.target_dossier_id, \n d2.name_en as target_name, \n dr.relationship_type \nFROM dossier_relationships dr\nJOIN dossiers d1 ON dr.source_dossier_id = d1.id\nJOIN dossiers d2 ON dr.target_dossier_id = d2.id\nLIMIT 10;"
}
I have test data. Now let me create the temporary Playwright test file for verifying the graph traversal feature:

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/tests/e2e/graph-traversal-verification.spec.ts",
"content": "import { test, expect } from '@playwright/test';\n\n/\*_\n _ TEMPORARY VERIFICATION TEST - DELETE AFTER VERIFICATION\n _\n _ E2E Test: Graph Traversal Feature Verification\n _ Feature: relationship-graph-traversal\n _\n _ Tests the graph traversal Edge Function endpoints directly to verify:\n _ - Bidirectional N-degree traversal\n _ - Shortest path finding\n _ - All paths between entities\n _ - Connected entities discovery\n _ - Common connections analysis\n _ - Graph statistics\n _/\n\nconst SUPABASE_URL = 'https://zkrcjzdemdmwhearhfgg.supabase.co';\nconst ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InprcmNqemRlbWRtd2hlYXJoZmdnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg4MjY0OTAsImV4cCI6MjA3NDQwMjQ5MH0.JnSwNH0rsz8yg9zx73_3qc5CpJ6oo-udpo3G4ZIwkYQ';\n\n// Test data: dossiers with known relationships\nconst TEST_DOSSIERS = {\n saudiArabia: '41c7fb7b-1e69-4381-8310-04b6e74d0551',\n china: 'df37ee05-8502-45d1-8709-822a76db269a',\n saudiChinaTrade: '9f2408f6-9f96-45b8-a1b6-0b24168c2ec3',\n internationalTrade: 'a7ccb228-245a-4e24-b822-8f1413ec07e8',\n};\n\ntest.describe('Graph Traversal API Verification', () => {\n let authToken: string;\n\n test.beforeAll(async ({ request }) => {\n // Login to get auth token\n const loginResponse = await request.post(`${SUPABASE_URL}/auth/v1/token?grant_type=password`, {\n headers: {\n 'Content-Type': 'application/json',\n 'apikey': ANON_KEY,\n },\n data: {\n email: 'kazahrani@stats.gov.sa',\n password: 'itisme',\n },\n });\n\n if (loginResponse.ok()) {\n const authData = await loginResponse.json();\n authToken = authData.access_token;\n }\n });\n\n test('should traverse graph bidirectionally from Saudi Arabia', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'traverse',\n startDossierId: TEST_DOSSIERS.saudiArabia,\n maxDegrees: 2,\n includeInactive: false,\n },\n });\n\n console.log('Traverse response status:', response.status());\n const body = await response.json();\n console.log('Traverse response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(200);\n expect(body.operation).toBe('traverse_bidirectional');\n expect(body.start_dossier_id).toBe(TEST_DOSSIERS.saudiArabia);\n expect(body.nodes).toBeDefined();\n expect(Array.isArray(body.nodes)).toBe(true);\n expect(body.edges).toBeDefined();\n expect(Array.isArray(body.edges)).toBe(true);\n expect(body.stats).toBeDefined();\n expect(body.stats.query_time_ms).toBeGreaterThanOrEqual(0);\n\n // Should find China via bilateral_relation\n const chinaNode = body.nodes.find((n: { id: string }) => n.id === TEST_DOSSIERS.china);\n expect(chinaNode).toBeDefined();\n expect(chinaNode.degree).toBe(1);\n });\n\n test('should find shortest path between Saudi Arabia and International Trade', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'shortest-path',\n sourceId: TEST_DOSSIERS.saudiArabia,\n targetId: TEST_DOSSIERS.internationalTrade,\n maxDepth: 4,\n },\n });\n\n console.log('Shortest path response status:', response.status());\n const body = await response.json();\n console.log('Shortest path response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(200);\n expect(body.operation).toBe('shortest_path');\n expect(body.source_id).toBe(TEST_DOSSIERS.saudiArabia);\n expect(body.target_id).toBe(TEST_DOSSIERS.internationalTrade);\n\n // Path should exist: Saudi Arabia <- involves <- Saudi-China Trade -> discusses -> International Trade\n expect(body.found).toBe(true);\n expect(body.path).toBeDefined();\n expect(Array.isArray(body.path)).toBe(true);\n expect(body.path_length).toBeGreaterThanOrEqual(2);\n expect(body.path_dossiers).toBeDefined();\n });\n\n test('should find all paths between Saudi Arabia and China', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'all-paths',\n sourceId: TEST_DOSSIERS.saudiArabia,\n targetId: TEST_DOSSIERS.china,\n maxDepth: 3,\n maxPaths: 5,\n },\n });\n\n console.log('All paths response status:', response.status());\n const body = await response.json();\n console.log('All paths response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(200);\n expect(body.operation).toBe('all_paths');\n expect(body.source_id).toBe(TEST_DOSSIERS.saudiArabia);\n expect(body.target_id).toBe(TEST_DOSSIERS.china);\n expect(body.paths).toBeDefined();\n expect(Array.isArray(body.paths)).toBe(true);\n expect(body.path_count).toBeGreaterThanOrEqual(1); // At least direct path exists\n });\n\n test('should find connected entities from Saudi-China Trade', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'connected-entities',\n startDossierId: TEST_DOSSIERS.saudiChinaTrade,\n maxEntities: 50,\n },\n });\n\n console.log('Connected entities response status:', response.status());\n const body = await response.json();\n console.log('Connected entities response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(200);\n expect(body.operation).toBe('connected_entities');\n expect(body.start_dossier_id).toBe(TEST_DOSSIERS.saudiChinaTrade);\n expect(body.entities).toBeDefined();\n expect(Array.isArray(body.entities)).toBe(true);\n expect(body.entity_count).toBeGreaterThanOrEqual(3); // Saudi Arabia, China, International Trade\n\n // Check entities have required fields\n if (body.entities.length > 0) {\n const entity = body.entities[0];\n expect(entity.id).toBeDefined();\n expect(entity.name_en).toBeDefined();\n expect(entity.type).toBeDefined();\n expect(entity.min_distance).toBeDefined();\n expect(entity.connection_count).toBeDefined();\n }\n });\n\n test('should find common connections between Saudi Arabia and China', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'common-connections',\n dossierAId: TEST_DOSSIERS.saudiArabia,\n dossierBId: TEST_DOSSIERS.china,\n },\n });\n\n console.log('Common connections response status:', response.status());\n const body = await response.json();\n console.log('Common connections response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(200);\n expect(body.operation).toBe('common_connections');\n expect(body.dossier_a_id).toBe(TEST_DOSSIERS.saudiArabia);\n expect(body.dossier_b_id).toBe(TEST_DOSSIERS.china);\n expect(body.common_connections).toBeDefined();\n expect(Array.isArray(body.common_connections)).toBe(true);\n\n // Saudi-China Trade should be a common connection\n const tradeConnection = body.common_connections.find(\n (c: { id: string }) => c.id === TEST_DOSSIERS.saudiChinaTrade\n );\n expect(tradeConnection).toBeDefined();\n expect(tradeConnection.relationship_to_a).toBeDefined();\n expect(tradeConnection.relationship_to_b).toBeDefined();\n });\n\n test('should get graph statistics', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'statistics',\n startDossierId: TEST_DOSSIERS.saudiArabia,\n maxDegrees: 3,\n },\n });\n\n console.log('Statistics response status:', response.status());\n const body = await response.json();\n console.log('Statistics response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(200);\n expect(body.operation).toBe('statistics');\n expect(body.statistics).toBeDefined();\n\n const stats = body.statistics;\n expect(stats.total_nodes).toBeGreaterThanOrEqual(1);\n expect(stats.total_edges).toBeGreaterThanOrEqual(0);\n expect(typeof stats.graph_density).toBe('number');\n expect(typeof stats.avg_degree).toBe('number');\n expect(typeof stats.max_degree).toBe('number');\n expect(typeof stats.isolated_nodes).toBe('number');\n expect(stats.dossier_type_distribution).toBeDefined();\n });\n\n test('should handle invalid operation gracefully', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'invalid-operation',\n },\n });\n\n console.log('Invalid operation response status:', response.status());\n const body = await response.json();\n console.log('Invalid operation response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(400);\n expect(body.error).toBeDefined();\n });\n\n test('should reject unauthorized requests', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'apikey': ANON_KEY,\n // No Authorization header\n },\n data: {\n operation: 'traverse',\n startDossierId: TEST_DOSSIERS.saudiArabia,\n },\n });\n\n console.log('Unauthorized response status:', response.status());\n\n // Should return 401 Unauthorized\n expect(response.status()).toBe(401);\n });\n\n test('should filter by relationship types', async ({ request }) => {\n const response = await request.post(`${SUPABASE_URL}/functions/v1/graph-traversal-advanced`, {\n headers: {\n 'Content-Type': 'application/json',\n 'Authorization': `Bearer ${authToken}`,\n 'apikey': ANON_KEY,\n },\n data: {\n operation: 'traverse',\n startDossierId: TEST_DOSSIERS.saudiArabia,\n maxDegrees: 2,\n relationshipTypes: ['bilateral_relation'],\n },\n });\n\n console.log('Filtered traverse response status:', response.status());\n const body = await response.json();\n console.log('Filtered traverse response:', JSON.stringify(body, null, 2));\n\n expect(response.status()).toBe(200);\n expect(body.relationship_type_filter).toContain('bilateral_relation');\n\n // All edges should be bilateral_relation type\n for (const edge of body.edges) {\n expect(edge.relationship_type).toBe('bilateral_relation');\n }\n });\n});\n"
}
Now let me run the Playwright test to verify the graph traversal feature:

ðŸ”§ Tool: Bash
Input: {
"command": "cd /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend && npx playwright test graph-traversal-verification.spec.ts --project=chromium --reporter=list 2>&1",
"description": "Run graph traversal verification test",
"timeout": 120000
}
The tests revealed several issues. I can see three main problems:

1. **SQL recursive CTE error**: "recursive reference to query must not appear within its non-recursive term"
2. **Edge Function parameter handling issues**: Missing `startDossierId` for some operations (needs `sourceId` instead)
3. **Array parameter parsing**: `param.split is not a function`

Let me fix the Edge Function first:

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts"
}
I see the Edge Function issues. The Edge Function is getting the operation from the URL path, but for POST requests with `operation` in the body, it's not reading from the body. Let me fix the Edge Function to handle the operation from the body correctly:

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts",
"old_string": "function parseArrayParam(param: string | null): string[] | null {\n if (!param) return null;\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed : [param];\n } catch {\n return param.split(',').map((s) => s.trim());\n }\n}",
"new_string": "function parseArrayParam(param: unknown): string[] | null {\n if (!param) return null;\n if (Array.isArray(param)) return param as string[];\n if (typeof param === 'string') {\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed : [param];\n } catch {\n return param.split(',').map((s) => s.trim());\n }\n }\n return null;\n}"
}

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts",
"old_string": "function parseBooleanArrayParam(param: string | null): boolean[] | null {\n if (!param) return null;\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed.map(Boolean) : null;\n } catch {\n return param.split(',').map((s) => s.trim().toLowerCase() === 'true');\n }\n}",
"new_string": "function parseBooleanArrayParam(param: unknown): boolean[] | null {\n if (!param) return null;\n if (Array.isArray(param)) return param.map(Boolean);\n if (typeof param === 'string') {\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed.map(Boolean) : null;\n } catch {\n return param.split(',').map((s) => s.trim().toLowerCase() === 'true');\n }\n }\n return null;\n}"
}
Now let me fix the operation parsing to read from the body for POST requests:

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts",
"old_string": " // Parse URL and operation\n const url = new URL(req.url);\n const pathParts = url.pathname.split('/').filter(Boolean);\n const operation = pathParts[pathParts.length - 1] || 'traverse';\n\n // Get parameters from query string (GET) or body (POST)\n let params: Record<string, string | null> = {};\n\n if (req.method === 'GET') {\n url.searchParams.forEach((value, key) => {\n params[key] = value;\n });\n } else {\n const body = await req.json();\n params = body;\n }",
"new_string": " // Parse URL and operation\n const url = new URL(req.url);\n const pathParts = url.pathname.split('/').filter(Boolean);\n let urlOperation = pathParts[pathParts.length - 1] || 'traverse';\n\n // Get parameters from query string (GET) or body (POST)\n let params: Record<string, unknown> = {};\n let operation = urlOperation;\n\n if (req.method === 'GET') {\n url.searchParams.forEach((value, key) => {\n params[key] = value;\n });\n if (params.operation) {\n operation = params.operation as string;\n }\n } else {\n const body = await req.json();\n params = body;\n // For POST requests, operation can come from body\n if (body.operation) {\n operation = body.operation as string;\n }\n }\n\n // Normalize operation name (e.g., graph-traversal-advanced is the default endpoint)\n if (operation === 'graph-traversal-advanced') {\n operation = 'traverse';\n }"
}
Now let me update the switch case to remove the duplicate handling:

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts",
"old_string": " switch (operation) {\n case 'traverse':\n case 'graph-traversal-advanced': {",
"new_string": " switch (operation) {\n case 'traverse': {"
}
Now I need to fix the SQL function - the recursive CTE error. Let me check the migration file for the issue:

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20260111200001_enhanced_graph_traversal.sql"
}
I see the issue! The recursive CTE has multiple `UNION ALL` clauses in the non-recursive term, which PostgreSQL doesn't allow. PostgreSQL requires that a recursive CTE have exactly ONE non-recursive term followed by ONE recursive term. I need to restructure the CTEs to use a single base case and a single recursive case.

Let me create a fix migration:

ðŸ”§ Tool: Write
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/migrations/20260111200002_fix_graph_traversal_recursive_cte.sql",
"content": "-- Migration: Fix Graph Traversal Recursive CTEs\n-- Description: Fix recursive CTE structure to comply with PostgreSQL requirements\n-- Feature: relationship-graph-traversal\n-- Issue: Recursive CTEs can only have ONE non-recursive term\n\n-- ==================================================\n-- Function: traverse_relationship_graph_bidirectional (FIXED)\n-- ==================================================\n-- Issue: Multiple UNION ALL in non-recursive part causes \"recursive reference must not appear within its non-recursive term\"\n\nDROP FUNCTION IF EXISTS traverse_relationship_graph_bidirectional(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]);\n\nCREATE OR REPLACE FUNCTION traverse_relationship_graph_bidirectional(\n start_dossier_id UUID,\n max_degrees INTEGER DEFAULT 2,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n degree INTEGER,\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE relationship_graph AS (\n    -- Base case: All direct neighbors (both outgoing and incoming)\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = start_dossier_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id,\n        CASE\n          WHEN dr.source_dossier_id = start_dossier_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END\n      ] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY[\n        CASE\n          WHEN dr.source_dossier_id = start_dossier_id THEN 'outgoing'::TEXT\n          ELSE 'incoming'::TEXT\n        END\n      ] AS dir_path\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = start_dossier_id OR dr.target_dossier_id = start_dossier_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Recursive case: Follow all edges from current nodes\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = rg.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      rg.current_degree + 1,\n      rg.current_path || CASE\n        WHEN dr.source_dossier_id = rg.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || CASE\n        WHEN dr.source_dossier_id = rg.current_id THEN 'outgoing'::TEXT\n        ELSE 'incoming'::TEXT\n      END\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON (dr.source_dossier_id = rg.current_id OR dr.target_dossier_id = rg.current_id)\n    WHERE rg.current_degree < max_degrees\n      AND NOT (\n        CASE\n          WHEN dr.source_dossier_id = rg.current_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(rg.current_path)\n      )\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    rg.current_degree AS degree,\n    rg.current_path AS path,\n    rg.rel_path AS relationship_path,\n    rg.dir_path AS direction_path\n  FROM relationship_graph rg\n  JOIN dossiers d ON d.id = rg.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY d.id, rg.current_degree;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION traverse_relationship_graph_bidirectional(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\n\n-- ==================================================\n-- Function: find_shortest_path_bidirectional (FIXED)\n-- ==================================================\n\nDROP FUNCTION IF EXISTS find_shortest_path_bidirectional(UUID, UUID, INTEGER, TEXT[], BOOLEAN);\n\nCREATE OR REPLACE FUNCTION find_shortest_path_bidirectional(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 6,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER,\n found BOOLEAN\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length,\n      TRUE AS found;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE path_search AS (\n    -- Base case: All neighbors of source\n    SELECT\n      ARRAY[source_id,\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END\n      ] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY[\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN 'outgoing'::TEXT\n          ELSE 'incoming'::TEXT\n        END\n      ] AS dir_path,\n      1 AS depth,\n      CASE\n        WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE (dr.source_dossier_id = source_id OR dr.target_dossier_id = source_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive case: Expand from current nodes\n    SELECT\n      ps.current_path || CASE\n        WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || CASE\n        WHEN dr.source_dossier_id = ps.current_node THEN 'outgoing'::TEXT\n        ELSE 'incoming'::TEXT\n      END,\n      ps.depth + 1,\n      CASE\n        WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END\n    FROM path_search ps\n    JOIN dossier_relationships dr ON (dr.source_dossier_id = ps.current_node OR dr.target_dossier_id = ps.current_node)\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE ps.depth < max_depth\n      AND NOT (\n        CASE\n          WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(ps.current_path)\n      )\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ps.current_path AS path,\n    ps.rel_path AS relationship_path,\n    ps.dir_path AS direction_path,\n    ps.depth AS path_length,\n    TRUE AS found\n  FROM path_search ps\n  WHERE ps.current_node = target_id\n  ORDER BY ps.depth\n  LIMIT 1;\n\n  -- If no path found, return NULL with found=false\n  IF NOT FOUND THEN\n    RETURN QUERY SELECT\n      NULL::UUID[] AS path,\n      NULL::TEXT[] AS relationship_path,\n      NULL::TEXT[] AS direction_path,\n      NULL::INTEGER AS path_length,\n      FALSE AS found;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_shortest_path_bidirectional(UUID, UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n\n-- ==================================================\n-- Function: find_all_paths (FIXED)\n-- ==================================================\n\nDROP FUNCTION IF EXISTS find_all_paths(UUID, UUID, INTEGER, INTEGER, TEXT[], BOOLEAN);\n\nCREATE OR REPLACE FUNCTION find_all_paths(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 4,\n max_paths INTEGER DEFAULT 10,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length\n    LIMIT 1;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE all_paths AS (\n    -- Base case: All neighbors of source\n    SELECT\n      ARRAY[source_id,\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END\n      ] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY[\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN 'outgoing'::TEXT\n          ELSE 'incoming'::TEXT\n        END\n      ] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE (dr.source_dossier_id = source_id OR dr.target_dossier_id = source_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive case\n    SELECT\n      ap.current_path || CASE\n        WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || CASE\n        WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN 'outgoing'::TEXT\n        ELSE 'incoming'::TEXT\n      END,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON (\n      dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n      OR dr.target_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    )\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE ap.depth < max_depth\n      AND NOT (\n        CASE\n          WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(ap.current_path)\n      )\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ap.current_path AS path,\n    ap.rel_path AS relationship_path,\n    ap.dir_path AS direction_path,\n    ap.depth AS path_length\n  FROM all_paths ap\n  WHERE ap.current_path[array_length(ap.current_path, 1)] = target_id\n  ORDER BY ap.depth, ap.current_path\n  LIMIT max_paths;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_all_paths(UUID, UUID, INTEGER, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n\n-- ==================================================\n-- Function: find_connected_entities (FIXED)\n-- ==================================================\n\nDROP FUNCTION IF EXISTS find_connected_entities(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]);\n\nCREATE OR REPLACE FUNCTION find_connected_entities(\n start_dossier_id UUID,\n max_entities INTEGER DEFAULT 100,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n id UUID,\n type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n min_distance INTEGER,\n connection_count BIGINT\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE connected AS (\n    -- Starting node\n    SELECT\n      start_dossier_id AS current_id,\n      0 AS distance,\n      ARRAY[start_dossier_id] AS visited\n\n    UNION ALL\n\n    -- Follow all edges bidirectionally (single recursive term)\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_id,\n      c.distance + 1,\n      c.visited || CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END\n    FROM connected c\n    JOIN dossier_relationships dr ON (dr.source_dossier_id = c.current_id OR dr.target_dossier_id = c.current_id)\n    WHERE NOT (\n        CASE\n          WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(c.visited)\n      )\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND c.distance < 10  -- Prevent infinite recursion\n  ),\n  -- Aggregate to get minimum distance\n  entity_stats AS (\n    SELECT\n      c.current_id,\n      MIN(c.distance) AS min_dist\n    FROM connected c\n    GROUP BY c.current_id\n  ),\n  -- Count connections per entity\n  conn_counts AS (\n    SELECT\n      es.current_id,\n      es.min_dist,\n      COUNT(DISTINCT dr.id) AS conn_cnt\n    FROM entity_stats es\n    LEFT JOIN dossier_relationships dr ON (dr.source_dossier_id = es.current_id OR dr.target_dossier_id = es.current_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    GROUP BY es.current_id, es.min_dist\n  )\n  SELECT\n    d.id,\n    d.type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    cc.min_dist AS min_distance,\n    cc.conn_cnt AS connection_count\n  FROM conn_counts cc\n  JOIN dossiers d ON d.id = cc.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY cc.min_dist, d.name_en\n  LIMIT max_entities;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_connected_entities(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\n\n-- ==================================================\n-- Function: get_graph_statistics (FIXED)\n-- ==================================================\n-- Need to fix the call to traverse_relationship_graph_bidirectional since it returns different columns now\n\nDROP FUNCTION IF EXISTS get_graph_statistics(UUID, INTEGER, TEXT[], BOOLEAN);\n\nCREATE OR REPLACE FUNCTION get_graph_statistics(\n start_dossier_id UUID DEFAULT NULL,\n max_degrees INTEGER DEFAULT 3,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n total_nodes BIGINT,\n total_edges BIGINT,\n graph_density NUMERIC,\n avg_degree NUMERIC,\n max_degree BIGINT,\n isolated_nodes BIGINT,\n dossier_type_distribution JSONB\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  IF start_dossier_id IS NOT NULL THEN\n    -- Calculate stats for subgraph starting from a dossier\n    RETURN QUERY\n    WITH subgraph_nodes AS (\n      SELECT t.dossier_id\n      FROM traverse_relationship_graph_bidirectional(\n        start_dossier_id,\n        max_degrees,\n        relationship_types,\n        include_inactive,\n        NULL\n      ) t\n      UNION\n      SELECT start_dossier_id\n    ),\n    subgraph_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT sn.dossier_id FROM subgraph_nodes sn)\n        AND dr.target_dossier_id IN (SELECT sn.dossier_id FROM subgraph_nodes sn)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        sn.dossier_id,\n        COUNT(DISTINCT se.id) AS degree\n      FROM subgraph_nodes sn\n      LEFT JOIN subgraph_edges se ON\n        se.source_dossier_id = sn.dossier_id OR se.target_dossier_id = sn.dossier_id\n      GROUP BY sn.dossier_id\n    ),\n    type_counts AS (\n      SELECT\n        d.type,\n        COUNT(*) AS cnt\n      FROM subgraph_nodes sn\n      JOIN dossiers d ON d.id = sn.dossier_id\n      GROUP BY d.type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM subgraph_nodes)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM subgraph_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM subgraph_nodes) <= 1 THEN 0::NUMERIC\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM subgraph_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM subgraph_nodes) * ((SELECT COUNT(*) FROM subgraph_nodes) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT COALESCE(MAX(degree), 0) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      COALESCE((SELECT jsonb_object_agg(type, cnt) FROM type_counts), '{}'::JSONB) AS dossier_type_distribution;\n  ELSE\n    -- Calculate stats for entire graph (visible to user)\n    RETURN QUERY\n    WITH visible_dossiers AS (\n      SELECT id, type\n      FROM dossiers\n      WHERE status != 'deleted'\n        AND sensitivity_level <= user_clearance\n    ),\n    visible_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND dr.target_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        vd.id,\n        COUNT(DISTINCT ve.id) AS degree\n      FROM visible_dossiers vd\n      LEFT JOIN visible_edges ve ON\n        ve.source_dossier_id = vd.id OR ve.target_dossier_id = vd.id\n      GROUP BY vd.id\n    ),\n    type_counts AS (\n      SELECT\n        type,\n        COUNT(*) AS cnt\n      FROM visible_dossiers\n      GROUP BY type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM visible_dossiers)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM visible_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM visible_dossiers) <= 1 THEN 0::NUMERIC\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM visible_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM visible_dossiers) * ((SELECT COUNT(*) FROM visible_dossiers) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT COALESCE(MAX(degree), 0) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      COALESCE((SELECT jsonb_object_agg(type, cnt) FROM type_counts), '{}'::JSONB) AS dossier_type_distribution;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_graph_statistics(UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n-- Add comments\nCOMMENT ON FUNCTION traverse_relationship_graph_bidirectional IS\n'Bidirectional recursive graph traversal. Finds all entities within N degrees of separation following both incoming and outgoing relationships. Fixed recursive CTE structure.';\n\nCOMMENT ON FUNCTION find_shortest_path_bidirectional IS\n'Finds the shortest path between two dossiers using bidirectional search. Fixed recursive CTE structure.';\n\nCOMMENT ON FUNCTION find_all_paths IS\n'Finds all unique paths between two dossiers up to a specified depth and count limit. Fixed recursive CTE structure.';\n\nCOMMENT ON FUNCTION find_connected_entities IS\n'Finds all entities in the connected component containing the starting dossier. Returns entities with their minimum distance and connection count. Fixed recursive CTE structure.';\n\nCOMMENT ON FUNCTION get_graph_statistics IS\n'Calculates network statistics for the entire graph or a subgraph. Fixed to work with updated traverse function.';\n"
}
Now let me apply the fix migration and redeploy the Edge Function:

ðŸ”§ Tool: mcp**supabase**apply_migration
Input: {
"project_id": "zkrcjzdemdmwhearhfgg",
"name": "fix_graph_traversal_recursive_cte",
"query": "-- Migration: Fix Graph Traversal Recursive CTEs\n-- Description: Fix recursive CTE structure to comply with PostgreSQL requirements\n-- Feature: relationship-graph-traversal\n-- Issue: Recursive CTEs can only have ONE non-recursive term\n\n-- ==================================================\n-- Function: traverse_relationship_graph_bidirectional (FIXED)\n-- ==================================================\n-- Issue: Multiple UNION ALL in non-recursive part causes \"recursive reference must not appear within its non-recursive term\"\n\nDROP FUNCTION IF EXISTS traverse_relationship_graph_bidirectional(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]);\n\nCREATE OR REPLACE FUNCTION traverse_relationship_graph_bidirectional(\n start_dossier_id UUID,\n max_degrees INTEGER DEFAULT 2,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n dossier_id UUID,\n dossier_type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n degree INTEGER,\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[]\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE relationship_graph AS (\n    -- Base case: All direct neighbors (both outgoing and incoming)\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = start_dossier_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_id,\n      1 AS current_degree,\n      ARRAY[start_dossier_id,\n        CASE\n          WHEN dr.source_dossier_id = start_dossier_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END\n      ] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY[\n        CASE\n          WHEN dr.source_dossier_id = start_dossier_id THEN 'outgoing'::TEXT\n          ELSE 'incoming'::TEXT\n        END\n      ] AS dir_path\n    FROM dossier_relationships dr\n    WHERE (dr.source_dossier_id = start_dossier_id OR dr.target_dossier_id = start_dossier_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n\n    UNION ALL\n\n    -- Recursive case: Follow all edges from current nodes\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = rg.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      rg.current_degree + 1,\n      rg.current_path || CASE\n        WHEN dr.source_dossier_id = rg.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      rg.rel_path || dr.relationship_type,\n      rg.dir_path || CASE\n        WHEN dr.source_dossier_id = rg.current_id THEN 'outgoing'::TEXT\n        ELSE 'incoming'::TEXT\n      END\n    FROM relationship_graph rg\n    JOIN dossier_relationships dr ON (dr.source_dossier_id = rg.current_id OR dr.target_dossier_id = rg.current_id)\n    WHERE rg.current_degree < max_degrees\n      AND NOT (\n        CASE\n          WHEN dr.source_dossier_id = rg.current_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(rg.current_path)\n      )\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n  )\n  SELECT DISTINCT ON (d.id)\n    d.id AS dossier_id,\n    d.type AS dossier_type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    rg.current_degree AS degree,\n    rg.current_path AS path,\n    rg.rel_path AS relationship_path,\n    rg.dir_path AS direction_path\n  FROM relationship_graph rg\n  JOIN dossiers d ON d.id = rg.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY d.id, rg.current_degree;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION traverse_relationship_graph_bidirectional(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\n\n-- ==================================================\n-- Function: find_shortest_path_bidirectional (FIXED)\n-- ==================================================\n\nDROP FUNCTION IF EXISTS find_shortest_path_bidirectional(UUID, UUID, INTEGER, TEXT[], BOOLEAN);\n\nCREATE OR REPLACE FUNCTION find_shortest_path_bidirectional(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 6,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER,\n found BOOLEAN\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length,\n      TRUE AS found;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE path_search AS (\n    -- Base case: All neighbors of source\n    SELECT\n      ARRAY[source_id,\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END\n      ] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY[\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN 'outgoing'::TEXT\n          ELSE 'incoming'::TEXT\n        END\n      ] AS dir_path,\n      1 AS depth,\n      CASE\n        WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_node\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE (dr.source_dossier_id = source_id OR dr.target_dossier_id = source_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive case: Expand from current nodes\n    SELECT\n      ps.current_path || CASE\n        WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      ps.rel_path || dr.relationship_type,\n      ps.dir_path || CASE\n        WHEN dr.source_dossier_id = ps.current_node THEN 'outgoing'::TEXT\n        ELSE 'incoming'::TEXT\n      END,\n      ps.depth + 1,\n      CASE\n        WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END\n    FROM path_search ps\n    JOIN dossier_relationships dr ON (dr.source_dossier_id = ps.current_node OR dr.target_dossier_id = ps.current_node)\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE ps.depth < max_depth\n      AND NOT (\n        CASE\n          WHEN dr.source_dossier_id = ps.current_node THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(ps.current_path)\n      )\n      AND ps.current_node != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ps.current_path AS path,\n    ps.rel_path AS relationship_path,\n    ps.dir_path AS direction_path,\n    ps.depth AS path_length,\n    TRUE AS found\n  FROM path_search ps\n  WHERE ps.current_node = target_id\n  ORDER BY ps.depth\n  LIMIT 1;\n\n  -- If no path found, return NULL with found=false\n  IF NOT FOUND THEN\n    RETURN QUERY SELECT\n      NULL::UUID[] AS path,\n      NULL::TEXT[] AS relationship_path,\n      NULL::TEXT[] AS direction_path,\n      NULL::INTEGER AS path_length,\n      FALSE AS found;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_shortest_path_bidirectional(UUID, UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n\n-- ==================================================\n-- Function: find_all_paths (FIXED)\n-- ==================================================\n\nDROP FUNCTION IF EXISTS find_all_paths(UUID, UUID, INTEGER, INTEGER, TEXT[], BOOLEAN);\n\nCREATE OR REPLACE FUNCTION find_all_paths(\n source_id UUID,\n target_id UUID,\n max_depth INTEGER DEFAULT 4,\n max_paths INTEGER DEFAULT 10,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n path UUID[],\n relationship_path TEXT[],\n direction_path TEXT[],\n path_length INTEGER\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  -- Check if source and target are the same\n  IF source_id = target_id THEN\n    RETURN QUERY SELECT\n      ARRAY[source_id]::UUID[] AS path,\n      ARRAY[]::TEXT[] AS relationship_path,\n      ARRAY[]::TEXT[] AS direction_path,\n      0 AS path_length\n    LIMIT 1;\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  WITH RECURSIVE all_paths AS (\n    -- Base case: All neighbors of source\n    SELECT\n      ARRAY[source_id,\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END\n      ] AS current_path,\n      ARRAY[dr.relationship_type] AS rel_path,\n      ARRAY[\n        CASE\n          WHEN dr.source_dossier_id = source_id THEN 'outgoing'::TEXT\n          ELSE 'incoming'::TEXT\n        END\n      ] AS dir_path,\n      1 AS depth\n    FROM dossier_relationships dr\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = source_id THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE (dr.source_dossier_id = source_id OR dr.target_dossier_id = source_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n\n    UNION ALL\n\n    -- Recursive case\n    SELECT\n      ap.current_path || CASE\n        WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END,\n      ap.rel_path || dr.relationship_type,\n      ap.dir_path || CASE\n        WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN 'outgoing'::TEXT\n        ELSE 'incoming'::TEXT\n      END,\n      ap.depth + 1\n    FROM all_paths ap\n    JOIN dossier_relationships dr ON (\n      dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n      OR dr.target_dossier_id = ap.current_path[array_length(ap.current_path, 1)]\n    )\n    JOIN dossiers d ON d.id = CASE\n      WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN dr.target_dossier_id\n      ELSE dr.source_dossier_id\n    END\n    WHERE ap.depth < max_depth\n      AND NOT (\n        CASE\n          WHEN dr.source_dossier_id = ap.current_path[array_length(ap.current_path, 1)] THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(ap.current_path)\n      )\n      AND ap.current_path[array_length(ap.current_path, 1)] != target_id\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND d.status != 'deleted'\n      AND d.sensitivity_level <= user_clearance\n  )\n  SELECT\n    ap.current_path AS path,\n    ap.rel_path AS relationship_path,\n    ap.dir_path AS direction_path,\n    ap.depth AS path_length\n  FROM all_paths ap\n  WHERE ap.current_path[array_length(ap.current_path, 1)] = target_id\n  ORDER BY ap.depth, ap.current_path\n  LIMIT max_paths;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_all_paths(UUID, UUID, INTEGER, INTEGER, TEXT[], BOOLEAN) TO authenticated;\n\n\n-- ==================================================\n-- Function: find_connected_entities (FIXED)\n-- ==================================================\n\nDROP FUNCTION IF EXISTS find_connected_entities(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]);\n\nCREATE OR REPLACE FUNCTION find_connected_entities(\n start_dossier_id UUID,\n max_entities INTEGER DEFAULT 100,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE,\n dossier_type_filter TEXT[] DEFAULT NULL\n)\nRETURNS TABLE (\n id UUID,\n type TEXT,\n name_en TEXT,\n name_ar TEXT,\n status TEXT,\n min_distance INTEGER,\n connection_count BIGINT\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  RETURN QUERY\n  WITH RECURSIVE connected AS (\n    -- Starting node\n    SELECT\n      start_dossier_id AS current_id,\n      0 AS distance,\n      ARRAY[start_dossier_id] AS visited\n\n    UNION ALL\n\n    -- Follow all edges bidirectionally (single recursive term)\n    SELECT\n      CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END AS current_id,\n      c.distance + 1,\n      c.visited || CASE\n        WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n        ELSE dr.source_dossier_id\n      END\n    FROM connected c\n    JOIN dossier_relationships dr ON (dr.source_dossier_id = c.current_id OR dr.target_dossier_id = c.current_id)\n    WHERE NOT (\n        CASE\n          WHEN dr.source_dossier_id = c.current_id THEN dr.target_dossier_id\n          ELSE dr.source_dossier_id\n        END = ANY(c.visited)\n      )\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n      AND c.distance < 10  -- Prevent infinite recursion\n  ),\n  -- Aggregate to get minimum distance\n  entity_stats AS (\n    SELECT\n      c.current_id,\n      MIN(c.distance) AS min_dist\n    FROM connected c\n    GROUP BY c.current_id\n  ),\n  -- Count connections per entity\n  conn_counts AS (\n    SELECT\n      es.current_id,\n      es.min_dist,\n      COUNT(DISTINCT dr.id) AS conn_cnt\n    FROM entity_stats es\n    LEFT JOIN dossier_relationships dr ON (dr.source_dossier_id = es.current_id OR dr.target_dossier_id = es.current_id)\n      AND (include_inactive OR dr.status = 'active')\n      AND (dr.effective_to IS NULL OR dr.effective_to > now())\n      AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    GROUP BY es.current_id, es.min_dist\n  )\n  SELECT\n    d.id,\n    d.type,\n    d.name_en,\n    d.name_ar,\n    d.status,\n    cc.min_dist AS min_distance,\n    cc.conn_cnt AS connection_count\n  FROM conn_counts cc\n  JOIN dossiers d ON d.id = cc.current_id\n  WHERE d.status != 'deleted'\n    AND d.sensitivity_level <= user_clearance\n    AND (dossier_type_filter IS NULL OR d.type = ANY(dossier_type_filter))\n  ORDER BY cc.min_dist, d.name_en\n  LIMIT max_entities;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION find_connected_entities(UUID, INTEGER, TEXT[], BOOLEAN, TEXT[]) TO authenticated;\n\n\n-- ==================================================\n-- Function: get_graph_statistics (FIXED)\n-- ==================================================\n-- Need to fix the call to traverse_relationship_graph_bidirectional since it returns different columns now\n\nDROP FUNCTION IF EXISTS get_graph_statistics(UUID, INTEGER, TEXT[], BOOLEAN);\n\nCREATE OR REPLACE FUNCTION get_graph_statistics(\n start_dossier_id UUID DEFAULT NULL,\n max_degrees INTEGER DEFAULT 3,\n relationship_types TEXT[] DEFAULT NULL,\n include_inactive BOOLEAN DEFAULT FALSE\n)\nRETURNS TABLE (\n total_nodes BIGINT,\n total_edges BIGINT,\n graph_density NUMERIC,\n avg_degree NUMERIC,\n max_degree BIGINT,\n isolated_nodes BIGINT,\n dossier_type_distribution JSONB\n)\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  user_clearance INTEGER;\nBEGIN\n  -- Get user's clearance level\n  SELECT COALESCE(clearance_level, 1) INTO user_clearance\n  FROM profiles\n  WHERE user_id = auth.uid();\n\n  IF start_dossier_id IS NOT NULL THEN\n    -- Calculate stats for subgraph starting from a dossier\n    RETURN QUERY\n    WITH subgraph_nodes AS (\n      SELECT t.dossier_id\n      FROM traverse_relationship_graph_bidirectional(\n        start_dossier_id,\n        max_degrees,\n        relationship_types,\n        include_inactive,\n        NULL\n      ) t\n      UNION\n      SELECT start_dossier_id\n    ),\n    subgraph_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT sn.dossier_id FROM subgraph_nodes sn)\n        AND dr.target_dossier_id IN (SELECT sn.dossier_id FROM subgraph_nodes sn)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        sn.dossier_id,\n        COUNT(DISTINCT se.id) AS degree\n      FROM subgraph_nodes sn\n      LEFT JOIN subgraph_edges se ON\n        se.source_dossier_id = sn.dossier_id OR se.target_dossier_id = sn.dossier_id\n      GROUP BY sn.dossier_id\n    ),\n    type_counts AS (\n      SELECT\n        d.type,\n        COUNT(*) AS cnt\n      FROM subgraph_nodes sn\n      JOIN dossiers d ON d.id = sn.dossier_id\n      GROUP BY d.type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM subgraph_nodes)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM subgraph_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM subgraph_nodes) <= 1 THEN 0::NUMERIC\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM subgraph_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM subgraph_nodes) * ((SELECT COUNT(*) FROM subgraph_nodes) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT COALESCE(MAX(degree), 0) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      COALESCE((SELECT jsonb_object_agg(type, cnt) FROM type_counts), '{}'::JSONB) AS dossier_type_distribution;\n  ELSE\n    -- Calculate stats for entire graph (visible to user)\n    RETURN QUERY\n    WITH visible_dossiers AS (\n      SELECT id, type\n      FROM dossiers\n      WHERE status != 'deleted'\n        AND sensitivity_level <= user_clearance\n    ),\n    visible_edges AS (\n      SELECT DISTINCT dr.id, dr.source_dossier_id, dr.target_dossier_id\n      FROM dossier_relationships dr\n      WHERE dr.source_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND dr.target_dossier_id IN (SELECT id FROM visible_dossiers)\n        AND (include_inactive OR dr.status = 'active')\n        AND (dr.effective_to IS NULL OR dr.effective_to > now())\n        AND (relationship_types IS NULL OR dr.relationship_type = ANY(relationship_types))\n    ),\n    node_degrees AS (\n      SELECT\n        vd.id,\n        COUNT(DISTINCT ve.id) AS degree\n      FROM visible_dossiers vd\n      LEFT JOIN visible_edges ve ON\n        ve.source_dossier_id = vd.id OR ve.target_dossier_id = vd.id\n      GROUP BY vd.id\n    ),\n    type_counts AS (\n      SELECT\n        type,\n        COUNT(*) AS cnt\n      FROM visible_dossiers\n      GROUP BY type\n    )\n    SELECT\n      (SELECT COUNT(*) FROM visible_dossiers)::BIGINT AS total_nodes,\n      (SELECT COUNT(*) FROM visible_edges)::BIGINT AS total_edges,\n      CASE\n        WHEN (SELECT COUNT(*) FROM visible_dossiers) <= 1 THEN 0::NUMERIC\n        ELSE ROUND(\n          (SELECT COUNT(*) FROM visible_edges)::NUMERIC * 2 /\n          ((SELECT COUNT(*) FROM visible_dossiers) * ((SELECT COUNT(*) FROM visible_dossiers) - 1)),\n          4\n        )\n      END AS graph_density,\n      ROUND((SELECT AVG(degree) FROM node_degrees), 2) AS avg_degree,\n      (SELECT COALESCE(MAX(degree), 0) FROM node_degrees)::BIGINT AS max_degree,\n      (SELECT COUNT(*) FROM node_degrees WHERE degree = 0)::BIGINT AS isolated_nodes,\n      COALESCE((SELECT jsonb_object_agg(type, cnt) FROM type_counts), '{}'::JSONB) AS dossier_type_distribution;\n  END IF;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION get_graph_statistics(UUID, INTEGER, TEXT[], BOOLEAN) TO authenticated;"
}
Migration applied successfully. Now let me update the Edge Function to fix the connected-entities response structure and redeploy:

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts",
"limit": 100,
"offset": 440
}
The Edge Function looks correct. Let me now deploy the updated Edge Function:

ðŸ”§ Tool: Read
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/supabase/functions/graph-traversal-advanced/index.ts"
}
Now let me deploy the updated Edge Function:

ðŸ”§ Tool: mcp**supabase**deploy_edge_function
Input: {
"project_id": "zkrcjzdemdmwhearhfgg",
"name": "graph-traversal-advanced",
"entrypoint_path": "index.ts",
"verify_jwt": true,
"files": [
{
"name": "index.ts",
"content": "/\*_\n _ Advanced Graph Traversal Edge Function\n _ Feature: relationship-graph-traversal\n _\n _ Provides endpoints for:\n _ - Bidirectional N-degree traversal\n _ - Shortest path finding\n _ - All paths between entities\n _ - Connected entities discovery\n _ - Relationship chain pattern matching\n _ - Common connections between entities\n _ - Graph statistics\n _/\n\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\n\nconst corsHeaders = {\n 'Access-Control-Allow-Origin': '_',\n 'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n};\n\ninterface DossierReference {\n id: string;\n type: string;\n name_en: string;\n name_ar: string;\n status: string;\n}\n\ninterface GraphNode {\n id: string;\n type: string;\n name_en: string;\n name_ar: string;\n status: string;\n degree: number;\n path: string[];\n relationship_path?: string[];\n direction_path?: string[];\n}\n\ninterface GraphEdge {\n source_id: string;\n target_id: string;\n relationship_type: string;\n direction?: string;\n}\n\ninterface PathResult {\n path: string[];\n relationship_path: string[];\n direction_path: string[];\n path_length: number;\n found?: boolean;\n}\n\ninterface ChainResult {\n chain_position: number;\n dossier_id: string;\n dossier_type: string;\n name_en: string;\n name_ar: string;\n status: string;\n relationship_type: string | null;\n direction: string;\n full_path: string[];\n}\n\ninterface CommonConnectionResult {\n dossier_id: string;\n dossier_type: string;\n name_en: string;\n name_ar: string;\n status: string;\n relationship_to_a: string;\n direction_to_a: string;\n relationship_to_b: string;\n direction_to_b: string;\n}\n\ninterface GraphStats {\n total_nodes: number;\n total_edges: number;\n graph_density: number;\n avg_degree: number;\n max_degree: number;\n isolated_nodes: number;\n dossier_type_distribution: Record<string, number>;\n}\n\nfunction parseArrayParam(param: unknown): string[] | null {\n if (!param) return null;\n if (Array.isArray(param)) return param as string[];\n if (typeof param === 'string') {\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed : [param];\n } catch {\n return param.split(',').map((s) => s.trim());\n }\n }\n return null;\n}\n\nfunction parseBooleanArrayParam(param: unknown): boolean[] | null {\n if (!param) return null;\n if (Array.isArray(param)) return param.map(Boolean);\n if (typeof param === 'string') {\n try {\n const parsed = JSON.parse(param);\n return Array.isArray(parsed) ? parsed.map(Boolean) : null;\n } catch {\n return param.split(',').map((s) => s.trim().toLowerCase() === 'true');\n }\n }\n return null;\n}\n\nserve(async (req) => {\n // Handle CORS preflight\n if (req.method === 'OPTIONS') {\n return new Response(null, { headers: corsHeaders });\n }\n\n if (req.method !== 'GET' && req.method !== 'POST') {\n return new Response(JSON.stringify({ error: 'Method not allowed' }), {\n status: 405,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n try {\n const startTime = Date.now();\n\n // Get authorization header\n const authHeader = req.headers.get('Authorization');\n if (!authHeader) {\n return new Response(JSON.stringify({ error: 'Missing authorization header' }), {\n status: 401,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n // Create Supabase client\n const supabaseClient = createClient(\n Deno.env.get('SUPABASE_URL') ?? '',\n Deno.env.get('SUPABASE_ANON_KEY') ?? '',\n { global: { headers: { Authorization: authHeader } } }\n );\n\n // Parse URL and operation\n const url = new URL(req.url);\n const pathParts = url.pathname.split('/').filter(Boolean);\n let urlOperation = pathParts[pathParts.length - 1] || 'traverse';\n\n // Get parameters from query string (GET) or body (POST)\n let params: Record<string, unknown> = {};\n let operation = urlOperation;\n\n if (req.method === 'GET') {\n url.searchParams.forEach((value, key) => {\n params[key] = value;\n });\n if (params.operation) {\n operation = params.operation as string;\n }\n } else {\n const body = await req.json();\n params = body;\n // For POST requests, operation can come from body\n if (body.operation) {\n operation = body.operation as string;\n }\n }\n\n // Normalize operation name (e.g., graph-traversal-advanced is the default endpoint)\n if (operation === 'graph-traversal-advanced') {\n operation = 'traverse';\n }\n\n let result: unknown;\n\n switch (operation) {\n case 'traverse': {\n // Bidirectional N-degree traversal\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const maxDegrees = parseInt(String(params.maxDegrees || params.max_degrees || '2'), 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === true || params.includeInactive === 'true' || params.include_inactive === 'true';\n const dossierTypeFilter = parseArrayParam(\n params.dossierTypeFilter || params.dossier_type_filter || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n if (maxDegrees < 1 || maxDegrees > 6) {\n return new Response(JSON.stringify({ error: 'maxDegrees must be between 1 and 6' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n // Verify starting dossier exists\n const { data: startDossier, error: dossierError } = await supabaseClient\n .from('dossiers')\n .select('id, type, name_en, name_ar, status')\n .eq('id', startDossierId)\n .single();\n\n if (dossierError || !startDossier) {\n return new Response(\n JSON.stringify({ error: 'Starting dossier not found or access denied' }),\n { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n // Call bidirectional traversal function\n const { data: graphData, error: graphError } = await supabaseClient.rpc(\n 'traverse_relationship_graph_bidirectional',\n {\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n dossier_type_filter: dossierTypeFilter,\n }\n );\n\n if (graphError) {\n console.error('Graph traversal error:', graphError);\n throw graphError;\n }\n\n // Transform to nodes and edges\n const nodesMap = new Map<string, GraphNode>();\n const edges: GraphEdge[] = [];\n\n // Add starting node\n nodesMap.set(startDossierId as string, {\n id: startDossierId as string,\n type: startDossier.type,\n name_en: startDossier.name_en,\n name_ar: startDossier.name_ar,\n status: startDossier.status,\n degree: 0,\n path: [startDossierId as string],\n });\n\n // Process graph results\n (graphData || []).forEach((row: any) => {\n if (!nodesMap.has(row.dossier_id)) {\n nodesMap.set(row.dossier_id, {\n id: row.dossier_id,\n type: row.dossier_type,\n name_en: row.name_en,\n name_ar: row.name_ar,\n status: row.status,\n degree: row.degree,\n path: row.path,\n relationship_path: row.relationship_path,\n direction_path: row.direction_path,\n });\n }\n\n // Build edges from path\n if (row.path && row.path.length > 1 && row.relationship_path) {\n for (let i = 0; i < row.path.length - 1; i++) {\n const sourceId = row.path[i];\n const targetId = row.path[i + 1];\n const relType = row.relationship_path[i];\n const direction = row.direction_path?.[i] || 'outgoing';\n\n const edgeKey = `${sourceId}-${targetId}-${relType}`;\n const reverseKey = `${targetId}-${sourceId}-${relType}`;\n\n const edgeExists = edges.some(\n (e) =>\n (`${e.source_id}-${e.target_id}-${e.relationship_type}` === edgeKey) ||\n (`${e.source_id}-${e.target_id}-${e.relationship_type}` === reverseKey)\n );\n\n if (!edgeExists) {\n edges.push({\n source_id: direction === 'outgoing' ? sourceId : targetId,\n target_id: direction === 'outgoing' ? targetId : sourceId,\n relationship_type: relType,\n direction,\n });\n }\n }\n }\n });\n\n const nodes = Array.from(nodesMap.values());\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'traverse_bidirectional',\n start_dossier_id: startDossierId,\n start_dossier: startDossier,\n max_degrees: maxDegrees,\n relationship_type_filter: relationshipTypes || 'all',\n dossier_type_filter: dossierTypeFilter || 'all',\n include_inactive: includeInactive,\n nodes,\n edges,\n stats: {\n node_count: nodes.length,\n edge_count: edges.length,\n max_degree_found: nodes.length > 0 ? Math.max(...nodes.map((n) => n.degree)) : 0,\n query_time_ms: queryTime,\n performance_warning: queryTime > 2000 ? 'Query exceeded 2s performance target' : null,\n },\n };\n break;\n }\n\n case 'shortest-path': {\n // Find shortest path between two entities\n const sourceId = params.sourceId || params.source_id;\n const targetId = params.targetId || params.target_id;\n const maxDepth = parseInt(String(params.maxDepth || params.max_depth || '6'), 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === true || params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!sourceId || !targetId) {\n return new Response(\n JSON.stringify({ error: 'Missing sourceId or targetId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: pathData, error: pathError } = await supabaseClient.rpc(\n 'find_shortest_path_bidirectional',\n {\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (pathError) {\n console.error('Shortest path error:', pathError);\n throw pathError;\n }\n\n const pathResult = pathData?.[0] as PathResult | undefined;\n\n // Fetch dossier details for path nodes\n let pathDossiers: DossierReference[] = [];\n if (pathResult?.found && pathResult.path) {\n const { data: dossiers } = await supabaseClient\n .from('dossiers')\n .select('id, type, name_en, name_ar, status')\n .in('id', pathResult.path);\n pathDossiers = dossiers || [];\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'shortest_path',\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n found: pathResult?.found || false,\n path: pathResult?.path || null,\n relationship_path: pathResult?.relationship_path || null,\n direction_path: pathResult?.direction_path || null,\n path_length: pathResult?.path_length ?? null,\n path_dossiers: pathDossiers,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'all-paths': {\n // Find all paths between two entities\n const sourceId = params.sourceId || params.source_id;\n const targetId = params.targetId || params.target_id;\n const maxDepth = parseInt(String(params.maxDepth || params.max_depth || '4'), 10);\n const maxPaths = parseInt(String(params.maxPaths || params.max_paths || '10'), 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === true || params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!sourceId || !targetId) {\n return new Response(\n JSON.stringify({ error: 'Missing sourceId or targetId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: pathsData, error: pathsError } = await supabaseClient.rpc('find_all_paths', {\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n max_paths: maxPaths,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n });\n\n if (pathsError) {\n console.error('All paths error:', pathsError);\n throw pathsError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'all_paths',\n source_id: sourceId,\n target_id: targetId,\n max_depth: maxDepth,\n max_paths: maxPaths,\n paths: pathsData || [],\n path_count: (pathsData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'connected-entities': {\n // Find all connected entities\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const maxEntities = parseInt(String(params.maxEntities || params.max_entities || '100'), 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === true || params.includeInactive === 'true' || params.include_inactive === 'true';\n const dossierTypeFilter = parseArrayParam(\n params.dossierTypeFilter || params.dossier_type_filter || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n const { data: connectedData, error: connectedError } = await supabaseClient.rpc(\n 'find_connected_entities',\n {\n start_dossier_id: startDossierId,\n max_entities: maxEntities,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n dossier_type_filter: dossierTypeFilter,\n }\n );\n\n if (connectedError) {\n console.error('Connected entities error:', connectedError);\n throw connectedError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'connected_entities',\n start_dossier_id: startDossierId,\n max_entities: maxEntities,\n entities: connectedData || [],\n entity_count: (connectedData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'relationship-chain': {\n // Find entities matching a relationship chain pattern\n const startDossierId = params.startDossierId || params.start_dossier_id;\n const relationshipChain = parseArrayParam(\n params.relationshipChain || params.relationship_chain || null\n );\n const bidirectionalChain = parseBooleanArrayParam(\n params.bidirectionalChain || params.bidirectional_chain || null\n );\n\n if (!startDossierId) {\n return new Response(JSON.stringify({ error: 'Missing startDossierId parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n if (!relationshipChain || relationshipChain.length === 0) {\n return new Response(JSON.stringify({ error: 'Missing relationshipChain parameter' }), {\n status: 400,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n }\n\n const { data: chainData, error: chainError } = await supabaseClient.rpc(\n 'get_relationship_chain',\n {\n start_dossier_id: startDossierId,\n relationship_chain: relationshipChain,\n bidirectional_chain: bidirectionalChain,\n }\n );\n\n if (chainError) {\n console.error('Relationship chain error:', chainError);\n throw chainError;\n }\n\n // Group results by chain path\n const chainResults = (chainData || []) as ChainResult[];\n const pathsMap = new Map<string, ChainResult[]>();\n\n chainResults.forEach((item) => {\n const pathKey = item.full_path.join(',');\n if (!pathsMap.has(pathKey)) {\n pathsMap.set(pathKey, []);\n }\n pathsMap.get(pathKey)!.push(item);\n });\n\n const chains = Array.from(pathsMap.values()).map((items) => ({\n path: items[0].full_path,\n entities: items.sort((a, b) => a.chain_position - b.chain_position),\n }));\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'relationship_chain',\n start_dossier_id: startDossierId,\n relationship_chain: relationshipChain,\n bidirectional_chain: bidirectionalChain,\n chains,\n chain_count: chains.length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'common-connections': {\n // Find common connections between two entities\n const dossierAId = params.dossierAId || params.dossier_a_id;\n const dossierBId = params.dossierBId || params.dossier_b_id;\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === true || params.includeInactive === 'true' || params.include_inactive === 'true';\n\n if (!dossierAId || !dossierBId) {\n return new Response(\n JSON.stringify({ error: 'Missing dossierAId or dossierBId parameter' }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n const { data: commonData, error: commonError } = await supabaseClient.rpc(\n 'get_common_connections',\n {\n dossier_a_id: dossierAId,\n dossier_b_id: dossierBId,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (commonError) {\n console.error('Common connections error:', commonError);\n throw commonError;\n }\n\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'common_connections',\n dossier_a_id: dossierAId,\n dossier_b_id: dossierBId,\n common_connections: commonData || [],\n connection_count: (commonData || []).length,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n case 'statistics': {\n // Get graph statistics\n const startDossierId = params.startDossierId || params.start_dossier_id || null;\n const maxDegrees = parseInt(String(params.maxDegrees || params.max_degrees || '3'), 10);\n const relationshipTypes = parseArrayParam(\n params.relationshipTypes || params.relationship_types || null\n );\n const includeInactive = params.includeInactive === true || params.includeInactive === 'true' || params.include_inactive === 'true';\n\n const { data: statsData, error: statsError } = await supabaseClient.rpc(\n 'get_graph_statistics',\n {\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n relationship_types: relationshipTypes,\n include_inactive: includeInactive,\n }\n );\n\n if (statsError) {\n console.error('Graph statistics error:', statsError);\n throw statsError;\n }\n\n const stats = statsData?.[0] as GraphStats | undefined;\n const queryTime = Date.now() - startTime;\n\n result = {\n operation: 'statistics',\n start_dossier_id: startDossierId,\n max_degrees: maxDegrees,\n statistics: stats || null,\n stats: {\n query_time_ms: queryTime,\n },\n };\n break;\n }\n\n default:\n return new Response(\n JSON.stringify({\n error: `Unknown operation: ${operation}`,\n available_operations: [\n 'traverse',\n 'shortest-path',\n 'all-paths',\n 'connected-entities',\n 'relationship-chain',\n 'common-connections',\n 'statistics',\n ],\n }),\n { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n\n return new Response(JSON.stringify(result), {\n status: 200,\n headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n });\n } catch (error) {\n console.error('Error in graph-traversal-advanced:', error);\n return new Response(\n JSON.stringify({\n error: error.message || 'Internal server error',\n }),\n { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n );\n }\n});\n"
}
]
}
Edge Function deployed (version 2). Now let me run the Playwright tests again to verify the fixes:

ðŸ”§ Tool: Bash
Input: {
"command": "cd /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend && npx playwright test graph-traversal-verification.spec.ts --project=chromium --reporter=list 2>&1",
"description": "Run graph traversal verification test",
"timeout": 120000
}
Excellent progress! 8 out of 9 tests pass now. The only failing test is checking for `id` field in common connections, but the API returns `dossier_id`. Let me update the test to fix this field name:

ðŸ”§ Tool: Edit
Input: {
"file_path": "/Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/tests/e2e/graph-traversal-verification.spec.ts",
"old_string": " // Saudi-China Trade should be a common connection\n const tradeConnection = body.common_connections.find(\n (c: { id: string }) => c.id === TEST_DOSSIERS.saudiChinaTrade\n );\n expect(tradeConnection).toBeDefined();\n expect(tradeConnection.relationship_to_a).toBeDefined();\n expect(tradeConnection.relationship_to_b).toBeDefined();",
"new_string": " // Saudi-China Trade should be a common connection\n const tradeConnection = body.common_connections.find(\n (c: { dossier_id: string }) => c.dossier_id === TEST_DOSSIERS.saudiChinaTrade\n );\n expect(tradeConnection).toBeDefined();\n expect(tradeConnection.relationship_to_a).toBeDefined();\n expect(tradeConnection.relationship_to_b).toBeDefined();"
}
Now let me run the tests again to verify all pass:

ðŸ”§ Tool: Bash
Input: {
"command": "cd /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend && npx playwright test graph-traversal-verification.spec.ts --project=chromium --reporter=list 2>&1",
"description": "Run graph traversal verification test",
"timeout": 120000
}
All 9 tests pass. Now let me delete the temporary verification test as requested and update the todo list:

ðŸ”§ Tool: Bash
Input: {
"command": "rm /Users/khalidalzahrani/Library/CloudStorage/OneDrive-Personal/coding/Intl-DossierV2.0/frontend/tests/e2e/graph-traversal-verification.spec.ts",
"description": "Delete temporary verification test"
}
Based on the conversation summary, the graph-traversal-advanced feature implementation is complete and verified. All 9 Playwright tests passed successfully, and the temporary test file was deleted as required.

Let me update the todo list to reflect the completed status:

ðŸ”§ Tool: TodoWrite
Input: {
"todos": [
{
"content": "Create enhanced graph traversal SQL migration with bidirectional traversal functions",
"status": "completed",
"activeForm": "Creating enhanced graph traversal SQL migration"
},
{
"content": "Create Edge Function for advanced graph traversal operations",
"status": "completed",
"activeForm": "Creating advanced graph traversal Edge Function"
},
{
"content": "Create TypeScript types for graph traversal",
"status": "completed",
"activeForm": "Creating TypeScript types for graph traversal"
},
{
"content": "Create frontend hooks for graph traversal",
"status": "completed",
"activeForm": "Creating frontend hooks for graph traversal"
},
{
"content": "Add i18n translations for graph traversal features",
"status": "completed",
"activeForm": "Adding i18n translations"
},
{
"content": "Deploy migration to Supabase",
"status": "completed",
"activeForm": "Deploying migration to Supabase"
},
{
"content": "Deploy Edge Function to Supabase",
"status": "completed",
"activeForm": "Deploying Edge Function to Supabase"
},
{
"content": "Verify feature with Playwright test",
"status": "completed",
"activeForm": "Verifying feature with Playwright test"
}
]
}
The **relationship-graph-traversal** feature is fully implemented and verified. Here's a summary of what was completed:

## Feature Summary

### Database Functions (PostgreSQL)

- `traverse_relationship_graph_bidirectional` - N-degree traversal following both incoming/outgoing relationships
- `find_shortest_path_bidirectional` - BFS shortest path between two entities
- `find_all_paths` - All paths between entities up to max depth
- `find_connected_entities` - Connected entities within N degrees
- `find_relationship_chains` - Pattern-based relationship chain matching
- `find_common_connections` - Common connections between two entities
- `get_graph_statistics` - Network density, degree distribution, etc.

### Edge Function

- `graph-traversal-advanced` - Supports all 7 operations via POST/GET
- Handles array/string parameters, authorization, and RLS

### Frontend

- TypeScript types in `/frontend/src/types/graph-traversal.types.ts`
- TanStack Query hooks in `/frontend/src/hooks/useGraphTraversal.ts`
- i18n translations (EN/AR) in `/frontend/src/i18n/{en,ar}/graph-traversal.json`

### Verification Results (9/9 tests passed)

- âœ“ Bidirectional graph traversal
- âœ“ Shortest path finding
- âœ“ All paths discovery
- âœ“ Connected entities
- âœ“ Common connections
- âœ“ Graph statistics
- âœ“ Relationship type filtering
- âœ“ Invalid operation handling (400)
- âœ“ Unauthorized access rejection (401)
