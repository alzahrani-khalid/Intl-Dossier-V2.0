---
tags: [i18n]
summary: i18n implementation decisions and patterns
relevantTo: [i18n]
importance: 0.7
relatedFiles: []
usageStats:
  loaded: 0
  referenced: 0
  successfulFeatures: 0
---

# i18n

#### [Pattern] Duplicate detection strings fully extracted to i18n (both EN/AR), including technical terms (e.g., 'confidence', 'score') that are often left hardcoded in English (2026-01-13)

- **Problem solved:** RTL language support (Arabic) requires not just translation but proper text direction handling in UI
- **Why this works:** Complete i18n prevents: (1) hardcoded English leaking in Arabic mode, (2) re-rendering needed when language switches, (3) incomplete user experience. Technical terms translated to Arabic provide cultural localization beyond just translation
- **Trade-offs:** Easier: Consistent experience across languages. Harder: More translation strings to maintain, need domain expertise for technical term translation

### Separate i18n namespaces for role-dashboard (en/role-dashboard.json, ar/role-dashboard.json) vs mixed in general dashboard translations (2026-01-13)

- **Context:** Role-specific labels (quick actions, KPIs, sections) are different per language AND per role. Without namespacing, translation keys become unmaintainable.
- **Why:** Namespace pattern enables: (1) logical grouping by feature, (2) easy removal of entire role-dashboard feature (delete namespace), (3) translation teams can work independently on features, (4) scaling to N languages trivial
- **Rejected:** Single flat namespace (hundreds of keys, unclear scope) or per-role files (duplication across languages)
- **Trade-offs:** More files to maintain but clearer intent and easier to parallelize translation work. i18n namespace loading adds 1KB overhead.
- **Breaking if changed:** If namespaces are merged into flat structure, adding languages requires updating monolithic file; feature removal becomes manual key deletion; translation scope becomes unclear

#### [Pattern] Translations split into descriptive category strings and usage tips separately rather than embedding all text in one translation key (2026-01-14)

- **Problem solved:** Need to support English and Arabic with proper RTL layout without duplicating relationship type definitions
- **Why this works:** Separates concerns - type definitions remain code-driven for validation logic, while strings become translatable. Makes it easy to update tips or descriptions without touching type logic
- **Trade-offs:** Translations live in two places (code and i18n files) but each has clear purpose. Allows type metadata to drive validation while strings drive UX

#### [Pattern] 20 new translation keys added under 'calendar:conflictComparison' namespace with English and Arabic translations simultaneously (2026-01-14)

- **Problem solved:** Component needs UI text strings for both English and Arabic users; translations required for badge labels, button text, and explanatory content
- **Why this works:** Namespaced translations prevent key collisions and make component translations portable/reusable; creating both language translations together ensures semantic consistency (not just mechanical translation) and catches context-dependent phrasing early
- **Trade-offs:** Requires simultaneous work in two language files adding task complexity upfront; prevents later discovery that English phrasing doesn't translate well; namespace adds verbosity (calendar:conflictComparison.title vs title) but isolates component translations

#### [Pattern] Separate translation files per language (en/, ar/) with same structure rather than single file with language keys (2026-01-14)

- **Problem solved:** Could structure as translations.json with {en: {}, ar: {}} or separate language folders with identical structures.
- **Why this works:** Separate files enable: lazy loading per language, simpler merge conflicts in git (changes to English don't touch Arabic), easier for translation services to manage single file per language, clearer file organization reflecting URL structure (ar/ prefix in app)
- **Trade-offs:** Easier: translation tooling integration, cleaner git history per language, scales to many languages. Harder: slight redundancy in structure duplication, must keep schemas in sync
